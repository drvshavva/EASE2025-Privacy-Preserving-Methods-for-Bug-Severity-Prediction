{"project_name":"Closure","project_version":"144","label":2,"code":"\/**\r\n * Builds the function type, and puts it in the registry.\r\n *\/\r\nFunctionType buildAndRegister() {\r\n    if (returnType == null) {\r\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\r\n    }\r\n    if (parametersNode == null) {\r\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\r\n    }\r\n    FunctionType fnType;\r\n    if (isConstructor) {\r\n        fnType = getOrCreateConstructor();\r\n    } else if (isInterface) {\r\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\r\n        if (scope.isGlobal() && !fnName.isEmpty()) {\r\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\r\n        }\r\n        maybeSetBaseType(fnType);\r\n    } else {\r\n        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\r\n        maybeSetBaseType(fnType);\r\n    }\r\n    if (implementedInterfaces != null) {\r\n        fnType.setImplementedInterfaces(implementedInterfaces);\r\n    }\r\n    typeRegistry.clearTemplateTypeName();\r\n    return fnType;\r\n}","code_comment":"\/**\r\n * Builds the function type, and puts it in the registry.\r\n *\/\r\n","code_no_comment":"FunctionType buildAndRegister() {\r\n    if (returnType == null) {\r\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\r\n    }\r\n    if (parametersNode == null) {\r\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\r\n    }\r\n    FunctionType fnType;\r\n    if (isConstructor) {\r\n        fnType = getOrCreateConstructor();\r\n    } else if (isInterface) {\r\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\r\n        if (scope.isGlobal() && !fnName.isEmpty()) {\r\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\r\n        }\r\n        maybeSetBaseType(fnType);\r\n    } else {\r\n        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\r\n        maybeSetBaseType(fnType);\r\n    }\r\n    if (implementedInterfaces != null) {\r\n        fnType.setImplementedInterfaces(implementedInterfaces);\r\n    }\r\n    typeRegistry.clearTemplateTypeName();\r\n    return fnType;\r\n}","lc":0.5454545455,"pi":-0.1244019139,"ma":0.8,"nbd":0.5,"ml":0.75,"d":0.2896825397,"mi":-0.4319943622,"fo":1.0,"r":-0.0263157895,"e":0.4110141019}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3764_48454f4d","label":1,"code":"\/**\r\n *  Returns whether or not this behavior is stateless. Most behaviors should either not override\r\n *  this method or return {@code false} because most behavior are not stateless.\r\n *\r\n *  A small subset of behaviors are made specifically to be stateless and as such should override\r\n *  this method and return {@code true}. One sideeffect of this method is that the behavior id\r\n *  will be generated eagerly when the behavior is added to the component instead of before\r\n *  render when a method to create the url is called - this allows for stateless callback urls.\r\n *\r\n *  @param component\r\n *  @return whether or not this behavior is stateless\r\n *\/\r\npublic boolean isStateless(Component component) {\r\n    return false;\r\n}","code_comment":"\/**\r\n *  Returns whether or not this behavior is stateless. Most behaviors should either not override\r\n *  this method or return {@code false} because most behavior are not stateless.\r\n *\r\n *  A small subset of behaviors are made specifically to be stateless and as such should override\r\n *  this method and return {@code true}. One sideeffect of this method is that the behavior id\r\n *  will be generated eagerly when the behavior is added to the component instead of before\r\n *  render when a method to create the url is called - this allows for stateless callback urls.\r\n *\r\n *  @param component\r\n *  @return whether or not this behavior is stateless\r\n *\/\r\n","code_no_comment":"public boolean isStateless(Component component) {\r\n    return false;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.5,"r":2.1052631579,"e":-0.1627934049}
{"project_name":"Lang","project_version":"22","label":3,"code":"\/**\r\n * <p>Gets the greatest common divisor of the absolute value of\r\n * two numbers, using the \"binary gcd\" method which avoids\r\n * division and modulo operations.  See Knuth 4.5.2 algorithm B.\r\n * This algorithm is due to Josef Stein (1961).<\/p>\r\n *\r\n * @param u  a non-zero number\r\n * @param v  a non-zero number\r\n * @return the greatest common divisor, never zero\r\n *\/\r\nprivate static int greatestCommonDivisor(int u, int v) {\r\n    \/\/ if either operand is abs 1, return 1:\r\n    if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\r\n        return 1;\r\n    }\r\n    \/\/ make u negative\r\n    if (u > 0) {\r\n        u = -u;\r\n    }\r\n    \/\/ make v negative\r\n    if (v > 0) {\r\n        v = -v;\r\n    }\r\n    \/\/ B1. [Find power of 2]\r\n    int k = 0;\r\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\r\n        \/\/ while u and v are both even...\r\n        \/\/ cast out twos.\r\n        u \/= 2;\r\n        \/\/ cast out twos.\r\n        v \/= 2;\r\n        \/\/ cast out twos.\r\n        k++;\r\n    }\r\n    if (k == 31) {\r\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\r\n    }\r\n    \/\/ B2. Initialize: u and v have been divided by 2^k and at least\r\n    \/\/ one is odd.\r\n    int t = ((u & 1) == 1) ? v : -(u \/ 2);\r\n    \/\/ t positive: u was even, v is odd (t replaces u)\r\n    do {\r\n        \/\/ B4\/B3: cast out twos from t.\r\n        while ((t & 1) == 0) {\r\n            \/\/ while t is even..\r\n            \/\/ cast out twos\r\n            t \/= 2;\r\n        }\r\n        \/\/ B5 [reset max(u,v)]\r\n        if (t > 0) {\r\n            u = -t;\r\n        } else {\r\n            v = t;\r\n        }\r\n        \/\/ B6\/B3. at this point both u and v should be odd.\r\n        t = (v - u) \/ 2;\r\n    \/\/ |u| larger: t positive (replace u)\r\n    \/\/ |v| larger: t negative (replace v)\r\n    } while (t != 0);\r\n    \/\/ gcd is u*2^k\r\n    return -u * (1 << k);\r\n}","code_comment":"\/**\r\n * <p>Gets the greatest common divisor of the absolute value of\r\n * two numbers, using the \"binary gcd\" method which avoids\r\n * division and modulo operations.  See Knuth 4.5.2 algorithm B.\r\n * This algorithm is due to Josef Stein (1961).<\/p>\r\n *\r\n * @param u  a non-zero number\r\n * @param v  a non-zero number\r\n * @return the greatest common divisor, never zero\r\n *\/\r\n","code_no_comment":"private static int greatestCommonDivisor(int u, int v) {\r\n        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\r\n        return 1;\r\n    }\r\n        if (u > 0) {\r\n        u = -u;\r\n    }\r\n        if (v > 0) {\r\n        v = -v;\r\n    }\r\n        int k = 0;\r\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\r\n                        u \/= 2;\r\n                v \/= 2;\r\n                k++;\r\n    }\r\n    if (k == 31) {\r\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\r\n    }\r\n            int t = ((u & 1) == 1) ? v : -(u \/ 2);\r\n        do {\r\n                while ((t & 1) == 0) {\r\n                                    t \/= 2;\r\n        }\r\n                if (t > 0) {\r\n            u = -t;\r\n        } else {\r\n            v = t;\r\n        }\r\n                t = (v - u) \/ 2;\r\n            } while (t != 0);\r\n        return -u * (1 << k);\r\n}","lc":0.8636363636,"pi":-0.009569378,"ma":1.4,"nbd":0.0,"ml":1.0833333333,"d":6.2817460317,"mi":-0.6070472163,"fo":-0.3333333333,"r":0.0526315789,"e":7.8653896025}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4841_ce172da8","label":1,"code":"\/**\r\n *  Returns base url without context or filter mapping.\r\n *  <p>\r\n *  Example: if current url is\r\n *\r\n *  <pre>\r\n *  http:\/\/localhost:8080\/context\/filter\/mapping\/wicket\/bookmarkable\/com.foo.Page?1&id=2\r\n *  <\/pre>\r\n *\r\n *  the base url is <em>wicket\/bookmarkable\/com.foo.Page<\/em>\r\n *  <\/p>\r\n *\r\n *  @see org.apache.wicket.request.Request#getClientUrl()\r\n *\/\r\n@Override\r\npublic Url getClientUrl() {\r\n    if (errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri())) {\r\n        String problematicURI = Url.parse(errorAttributes.getRequestUri(), getCharset()).toString();\r\n        return getContextRelativeUrl(problematicURI, filterPrefix);\r\n    } else if (forwardAttributes != null && !Strings.isEmpty(forwardAttributes.getRequestUri())) {\r\n        String forwardURI = Url.parse(forwardAttributes.getRequestUri(), getCharset()).toString();\r\n        return getContextRelativeUrl(forwardURI, filterPrefix);\r\n    } else if (!isAjax()) {\r\n        return getContextRelativeUrl(httpServletRequest.getRequestURI(), filterPrefix);\r\n    } else {\r\n        String base = getHeader(HEADER_AJAX_BASE_URL);\r\n        if (base == null) {\r\n            base = getRequestParameters().getParameterValue(PARAM_AJAX_BASE_URL).toString(null);\r\n        }\r\n        Checks.notNull(base, \"Current ajax request is missing the base url header or parameter\");\r\n        return setParameters(Url.parse(base, getCharset()));\r\n    }\r\n}","code_comment":"\/**\r\n *  Returns base url without context or filter mapping.\r\n *  <p>\r\n *  Example: if current url is\r\n *\r\n *  <pre>\r\n *  http:\/\/localhost:8080\/context\/filter\/mapping\/wicket\/bookmarkable\/com.foo.Page?1&id=2\r\n *  <\/pre>\r\n *\r\n *  the base url is <em>wicket\/bookmarkable\/com.foo.Page<\/em>\r\n *  <\/p>\r\n *\r\n *  @see org.apache.wicket.request.Request#getClientUrl()\r\n *\/\r\n","code_no_comment":"@Override\r\npublic Url getClientUrl() {\r\n    if (errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri())) {\r\n        String problematicURI = Url.parse(errorAttributes.getRequestUri(), getCharset()).toString();\r\n        return getContextRelativeUrl(problematicURI, filterPrefix);\r\n    } else if (forwardAttributes != null && !Strings.isEmpty(forwardAttributes.getRequestUri())) {\r\n        String forwardURI = Url.parse(forwardAttributes.getRequestUri(), getCharset()).toString();\r\n        return getContextRelativeUrl(forwardURI, filterPrefix);\r\n    } else if (!isAjax()) {\r\n        return getContextRelativeUrl(httpServletRequest.getRequestURI(), filterPrefix);\r\n    } else {\r\n        String base = getHeader(HEADER_AJAX_BASE_URL);\r\n        if (base == null) {\r\n            base = getRequestParameters().getParameterValue(PARAM_AJAX_BASE_URL).toString(null);\r\n        }\r\n        Checks.notNull(base, \"Current ajax request is missing the base url header or parameter\");\r\n        return setParameters(Url.parse(base, getCharset()));\r\n    }\r\n}","lc":0.2272727273,"pi":0.1387559809,"ma":0.2,"nbd":1.0,"ml":0.75,"d":0.4543650794,"mi":-0.274982382,"fo":1.5833333333,"r":-0.0263157895,"e":0.5851696893}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"@Override\r\npublic Iterator<String> iterator() {\r\n    PathIterator it = new PathIterator(filter, indexName);\r\n    if (values == null) {\r\n        it.setPathContainsValue(true);\r\n        it.enqueue(getChildNodeEntries(index).iterator());\r\n    } else {\r\n        for (String p : values) {\r\n            NodeState property = index.getChildNode(p);\r\n            if (property.exists()) {\r\n                \/\/ we have an entry for this value, so use it\r\n                it.enqueue(Iterators.singletonIterator(new MemoryChildNodeEntry(\"\", property)));\r\n            }\r\n        }\r\n    }\r\n    return it;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Iterator<String> iterator() {\r\n    PathIterator it = new PathIterator(filter, indexName);\r\n    if (values == null) {\r\n        it.setPathContainsValue(true);\r\n        it.enqueue(getChildNodeEntries(index).iterator());\r\n    } else {\r\n        for (String p : values) {\r\n            NodeState property = index.getChildNode(p);\r\n            if (property.exists()) {\r\n                                it.enqueue(Iterators.singletonIterator(new MemoryChildNodeEntry(\"\", property)));\r\n            }\r\n        }\r\n    }\r\n    return it;\r\n}","lc":0.0909090909,"pi":0.7990430622,"ma":0.0,"nbd":0.5,"ml":-0.0833333333,"d":-0.0634920635,"mi":-0.0872445384,"fo":0.1666666667,"r":0.0,"e":-0.0261798148}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-1897_8ee095bf","label":1,"code":"\/**\r\n *  @return The component path.\r\n *\/\r\npublic String getComponentPath() {\r\n    return componentPath;\r\n}","code_comment":"\/**\r\n *  @return The component path.\r\n *\/\r\n","code_no_comment":"public String getComponentPath() {\r\n    return componentPath;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1646229739,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"@Override\r\npublic String next() {\r\n    if (closed) {\r\n        throw new IllegalStateException(\"This iterator is closed\");\r\n    }\r\n    if (!init) {\r\n        fetchNext();\r\n        init = true;\r\n    }\r\n    String result = currentPath;\r\n    fetchNext();\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String next() {\r\n    if (closed) {\r\n        throw new IllegalStateException(\"This iterator is closed\");\r\n    }\r\n    if (!init) {\r\n        fetchNext();\r\n        init = true;\r\n    }\r\n    String result = currentPath;\r\n    fetchNext();\r\n    return result;\r\n}","lc":-0.0454545455,"pi":-0.1291866029,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":-0.1011904762,"mi":0.1526427061,"fo":-0.3333333333,"r":2.0526315789,"e":-0.1183266772}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Returns the internal storage array.  Note that this method returns\r\n * a reference to the internal storage array, not a copy, and to correctly\r\n * address elements of the array, the <code>startIndex<\/code> is\r\n * required (available via the {@link #start} method).  This method should\r\n * only be used in cases where copying the internal array is not practical.\r\n * The {@link #getElements} method should be used in all other cases.\r\n *\r\n * @return the internal storage array used by this object\r\n * @since 2.0\r\n * @deprecated As of 3.1.\r\n *\/\r\n@Deprecated\r\npublic synchronized double[] getInternalValues() {\r\n    return internalArray;\r\n}","code_comment":"\/**\r\n * Returns the internal storage array.  Note that this method returns\r\n * a reference to the internal storage array, not a copy, and to correctly\r\n * address elements of the array, the <code>startIndex<\/code> is\r\n * required (available via the {@link #start} method).  This method should\r\n * only be used in cases where copying the internal array is not practical.\r\n * The {@link #getElements} method should be used in all other cases.\r\n *\r\n * @return the internal storage array used by this object\r\n * @since 2.0\r\n * @deprecated As of 3.1.\r\n *\/\r\n","code_no_comment":"@Deprecated\r\npublic synchronized double[] getInternalValues() {\r\n    return internalArray;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0332628612,"fo":-0.5,"r":1.1052631579,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3433_e76d23b0","label":3,"code":"@Override\r\npublic String toString() {\r\n    return \"\" + expression + \".convertToEvaluatedType(\" + type + \")\";\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String toString() {\r\n    return \"\" + expression + \".convertToEvaluatedType(\" + type + \")\";\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8246652572,"fo":-0.5,"r":2.3684210526,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5505_6cceff44","label":3,"code":"@Override\r\npublic Property resolveProperty(FormComponent<?> component) {\r\n    IModel<?> model = component.getModel();\r\n    while (true) {\r\n        if (model == null) {\r\n            return null;\r\n        }\r\n        if (model instanceof IPropertyReflectionAwareModel) {\r\n            break;\r\n        }\r\n        if (model instanceof IWrapModel<?>) {\r\n            model = ((IWrapModel<?>) model).getWrappedModel();\r\n            continue;\r\n        }\r\n        return null;\r\n    }\r\n    IPropertyReflectionAwareModel<?> delegate = (IPropertyReflectionAwareModel<?>) model;\r\n    Field field = delegate.getPropertyField();\r\n    if (field != null) {\r\n        return new Property(field.getDeclaringClass(), field.getName());\r\n    }\r\n    Method getter = delegate.getPropertyGetter();\r\n    if (getter != null) {\r\n        String name = getter.getName().substring(3, 4).toLowerCase() + getter.getName().substring(4);\r\n        return new Property(getter.getDeclaringClass(), name);\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Property resolveProperty(FormComponent<?> component) {\r\n    IModel<?> model = component.getModel();\r\n    while (true) {\r\n        if (model == null) {\r\n            return null;\r\n        }\r\n        if (model instanceof IPropertyReflectionAwareModel) {\r\n            break;\r\n        }\r\n        if (model instanceof IWrapModel<?>) {\r\n            model = ((IWrapModel<?>) model).getWrappedModel();\r\n            continue;\r\n        }\r\n        return null;\r\n    }\r\n    IPropertyReflectionAwareModel<?> delegate = (IPropertyReflectionAwareModel<?>) model;\r\n    Field field = delegate.getPropertyField();\r\n    if (field != null) {\r\n        return new Property(field.getDeclaringClass(), field.getName());\r\n    }\r\n    Method getter = delegate.getPropertyGetter();\r\n    if (getter != null) {\r\n        String name = getter.getName().substring(3, 4).toLowerCase() + getter.getName().substring(4);\r\n        return new Property(getter.getDeclaringClass(), name);\r\n    }\r\n    return null;\r\n}","lc":0.6363636364,"pi":0.2248803828,"ma":1.0,"nbd":0.0,"ml":0.3333333333,"d":0.4702380952,"mi":-0.4644115574,"fo":0.5,"r":-0.0263157895,"e":0.5318511091}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-1797_5d99b35c","label":1,"code":"\/**\r\n * @todo desperately needs refactoring. It's just here because it's implementation is maven-project specific\r\n *\/\r\npublic static Set createArtifacts(ArtifactFactory artifactFactory, List dependencies, String inheritedScope, ArtifactFilter dependencyFilter, MavenProject project) throws InvalidDependencyVersionException {\r\n    Set projectArtifacts = new LinkedHashSet(dependencies.size());\r\n    for (Iterator i = dependencies.iterator(); i.hasNext(); ) {\r\n        Dependency d = (Dependency) i.next();\r\n        String scope = d.getScope();\r\n        if (StringUtils.isEmpty(scope)) {\r\n            scope = Artifact.SCOPE_COMPILE;\r\n            d.setScope(scope);\r\n        }\r\n        VersionRange versionRange;\r\n        try {\r\n            versionRange = VersionRange.createFromVersionSpec(d.getVersion());\r\n        } catch (InvalidVersionSpecificationException e) {\r\n            throw new InvalidDependencyVersionException(\"Unable to parse version '\" + d.getVersion() + \"' for dependency '\" + d.getManagementKey() + \"': \" + e.getMessage(), e);\r\n        }\r\n        Artifact artifact = artifactFactory.createDependencyArtifact(d.getGroupId(), d.getArtifactId(), versionRange, d.getType(), d.getClassifier(), scope, inheritedScope, d.isOptional());\r\n        if (Artifact.SCOPE_SYSTEM.equals(scope)) {\r\n            artifact.setFile(new File(d.getSystemPath()));\r\n        }\r\n        if (artifact != null && (dependencyFilter == null || dependencyFilter.include(artifact))) {\r\n            if (d.getExclusions() != null && !d.getExclusions().isEmpty()) {\r\n                List exclusions = new ArrayList();\r\n                for (Iterator j = d.getExclusions().iterator(); j.hasNext(); ) {\r\n                    Exclusion e = (Exclusion) j.next();\r\n                    exclusions.add(e.getGroupId() + \":\" + e.getArtifactId());\r\n                }\r\n                ArtifactFilter newFilter = new ExcludesArtifactFilter(exclusions);\r\n                if (dependencyFilter != null) {\r\n                    AndArtifactFilter filter = new AndArtifactFilter();\r\n                    filter.add(dependencyFilter);\r\n                    filter.add(newFilter);\r\n                    dependencyFilter = filter;\r\n                } else {\r\n                    dependencyFilter = newFilter;\r\n                }\r\n            }\r\n            artifact.setDependencyFilter(dependencyFilter);\r\n            if (project != null) {\r\n                artifact = project.replaceWithActiveArtifact(artifact);\r\n            }\r\n            projectArtifacts.add(artifact);\r\n        }\r\n    }\r\n    return projectArtifacts;\r\n}","code_comment":"\/**\r\n * @todo desperately needs refactoring. It's just here because it's implementation is maven-project specific\r\n *\/\r\n","code_no_comment":"public static Set createArtifacts(ArtifactFactory artifactFactory, List dependencies, String inheritedScope, ArtifactFilter dependencyFilter, MavenProject project) throws InvalidDependencyVersionException {\r\n    Set projectArtifacts = new LinkedHashSet(dependencies.size());\r\n    for (Iterator i = dependencies.iterator(); i.hasNext(); ) {\r\n        Dependency d = (Dependency) i.next();\r\n        String scope = d.getScope();\r\n        if (StringUtils.isEmpty(scope)) {\r\n            scope = Artifact.SCOPE_COMPILE;\r\n            d.setScope(scope);\r\n        }\r\n        VersionRange versionRange;\r\n        try {\r\n            versionRange = VersionRange.createFromVersionSpec(d.getVersion());\r\n        } catch (InvalidVersionSpecificationException e) {\r\n            throw new InvalidDependencyVersionException(\"Unable to parse version '\" + d.getVersion() + \"' for dependency '\" + d.getManagementKey() + \"': \" + e.getMessage(), e);\r\n        }\r\n        Artifact artifact = artifactFactory.createDependencyArtifact(d.getGroupId(), d.getArtifactId(), versionRange, d.getType(), d.getClassifier(), scope, inheritedScope, d.isOptional());\r\n        if (Artifact.SCOPE_SYSTEM.equals(scope)) {\r\n            artifact.setFile(new File(d.getSystemPath()));\r\n        }\r\n        if (artifact != null && (dependencyFilter == null || dependencyFilter.include(artifact))) {\r\n            if (d.getExclusions() != null && !d.getExclusions().isEmpty()) {\r\n                List exclusions = new ArrayList();\r\n                for (Iterator j = d.getExclusions().iterator(); j.hasNext(); ) {\r\n                    Exclusion e = (Exclusion) j.next();\r\n                    exclusions.add(e.getGroupId() + \":\" + e.getArtifactId());\r\n                }\r\n                ArtifactFilter newFilter = new ExcludesArtifactFilter(exclusions);\r\n                if (dependencyFilter != null) {\r\n                    AndArtifactFilter filter = new AndArtifactFilter();\r\n                    filter.add(dependencyFilter);\r\n                    filter.add(newFilter);\r\n                    dependencyFilter = filter;\r\n                } else {\r\n                    dependencyFilter = newFilter;\r\n                }\r\n            }\r\n            artifact.setDependencyFilter(dependencyFilter);\r\n            if (project != null) {\r\n                artifact = project.replaceWithActiveArtifact(artifact);\r\n            }\r\n            projectArtifacts.add(artifact);\r\n        }\r\n    }\r\n    return projectArtifacts;\r\n}","lc":1.4090909091,"pi":1.1578947368,"ma":1.4,"nbd":1.0,"ml":1.4166666667,"d":0.9801587302,"mi":-0.8635658915,"fo":2.5833333333,"r":-0.0263157895,"e":3.3930049619}
{"project_name":"Math","project_version":"62","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException {\r\n    optima = new UnivariateRealPointValuePair[starts];\r\n    totalEvaluations = 0;\r\n    \/\/ Multi-start loop.\r\n    for (int i = 0; i < starts; ++i) {\r\n        try {\r\n            final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\r\n            final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\r\n            optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\r\n        } catch (FunctionEvaluationException fee) {\r\n            optima[i] = null;\r\n        } catch (ConvergenceException ce) {\r\n            optima[i] = null;\r\n        }\r\n        final int usedEvaluations = optimizer.getEvaluations();\r\n        optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\r\n        totalEvaluations += usedEvaluations;\r\n    }\r\n    sortPairs(goal);\r\n    if (optima[0] == null) {\r\n        throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts);\r\n    }\r\n    \/\/ Return the point with the best objective function value.\r\n    return optima[0];\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException {\r\n    optima = new UnivariateRealPointValuePair[starts];\r\n    totalEvaluations = 0;\r\n        for (int i = 0; i < starts; ++i) {\r\n        try {\r\n            final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\r\n            final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\r\n            optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\r\n        } catch (FunctionEvaluationException fee) {\r\n            optima[i] = null;\r\n        } catch (ConvergenceException ce) {\r\n            optima[i] = null;\r\n        }\r\n        final int usedEvaluations = optimizer.getEvaluations();\r\n        optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\r\n        totalEvaluations += usedEvaluations;\r\n    }\r\n    sortPairs(goal);\r\n    if (optima[0] == null) {\r\n        throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts);\r\n    }\r\n        return optima[0];\r\n}","lc":0.4090909091,"pi":0.3014354067,"ma":0.8,"nbd":0.0,"ml":0.0833333333,"d":1.6547619048,"mi":-0.4356589147,"fo":0.25,"r":-0.0263157895,"e":2.5030249592}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3309_debca73b","label":1,"code":"\/**\r\n *  @see javax.swing.event.TreeModelListener#treeNodesInserted(javax.swing.event.TreeModelEvent)\r\n *\/\r\npublic final void treeNodesInserted(TreeModelEvent e) {\r\n    if (dirtyAll) {\r\n        return;\r\n    }\r\n    \/\/ get the parent node of inserted nodes\r\n    Object parentNode = e.getTreePath().getLastPathComponent();\r\n    TreeItem parentItem = nodeToItemMap.get(parentNode);\r\n    if (parentItem != null && isNodeVisible(parentNode)) {\r\n        List<?> eventChildren = Arrays.asList(e.getChildren());\r\n        \/\/ parentNode was a leaf before this insertion event only if every one of\r\n        \/\/ its current children is in the event's list of children\r\n        boolean wasLeaf = true;\r\n        int nodeChildCount = getChildCount(parentNode);\r\n        for (int i = 0; wasLeaf && i < nodeChildCount; i++) {\r\n            wasLeaf = eventChildren.contains(getChildAt(parentNode, i));\r\n        }\r\n        if (wasLeaf) {\r\n            \/\/ parentNode now has children for the first time, so we need to invalidate\r\n            \/\/ grandparent so that parentNode's junctionLink gets rebuilt with a plus\/minus link\r\n            Object grandparentNode = getParentNode(parentNode);\r\n            invalidateNodeWithChildren(grandparentNode);\r\n            getTreeState().expandNode(parentNode);\r\n        } else {\r\n            if (isNodeExpanded(parentNode)) {\r\n                List<TreeItem> itemChildren = parentItem.getChildren();\r\n                int childLevel = parentItem.getLevel() + 1;\r\n                final int[] childIndices = e.getChildIndices();\r\n                for (int i = 0; i < eventChildren.size(); ++i) {\r\n                    TreeItem item = newTreeItem(parentItem, eventChildren.get(i), childLevel);\r\n                    itemContainer.add(item);\r\n                    if (itemChildren != null) {\r\n                        itemChildren.add(childIndices[i], item);\r\n                        markTheLastButOneChildDirty(parentItem, item);\r\n                    }\r\n                    if (!dirtyItems.contains(item)) {\r\n                        dirtyItems.add(item);\r\n                    }\r\n                    if (!dirtyItemsCreateDOM.contains(item) && !item.hasParentWithChildrenMarkedToRecreation()) {\r\n                        dirtyItemsCreateDOM.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  @see javax.swing.event.TreeModelListener#treeNodesInserted(javax.swing.event.TreeModelEvent)\r\n *\/\r\n","code_no_comment":"public final void treeNodesInserted(TreeModelEvent e) {\r\n    if (dirtyAll) {\r\n        return;\r\n    }\r\n        Object parentNode = e.getTreePath().getLastPathComponent();\r\n    TreeItem parentItem = nodeToItemMap.get(parentNode);\r\n    if (parentItem != null && isNodeVisible(parentNode)) {\r\n        List<?> eventChildren = Arrays.asList(e.getChildren());\r\n                        boolean wasLeaf = true;\r\n        int nodeChildCount = getChildCount(parentNode);\r\n        for (int i = 0; wasLeaf && i < nodeChildCount; i++) {\r\n            wasLeaf = eventChildren.contains(getChildAt(parentNode, i));\r\n        }\r\n        if (wasLeaf) {\r\n                                    Object grandparentNode = getParentNode(parentNode);\r\n            invalidateNodeWithChildren(grandparentNode);\r\n            getTreeState().expandNode(parentNode);\r\n        } else {\r\n            if (isNodeExpanded(parentNode)) {\r\n                List<TreeItem> itemChildren = parentItem.getChildren();\r\n                int childLevel = parentItem.getLevel() + 1;\r\n                final int[] childIndices = e.getChildIndices();\r\n                for (int i = 0; i < eventChildren.size(); ++i) {\r\n                    TreeItem item = newTreeItem(parentItem, eventChildren.get(i), childLevel);\r\n                    itemContainer.add(item);\r\n                    if (itemChildren != null) {\r\n                        itemChildren.add(childIndices[i], item);\r\n                        markTheLastButOneChildDirty(parentItem, item);\r\n                    }\r\n                    if (!dirtyItems.contains(item)) {\r\n                        dirtyItems.add(item);\r\n                    }\r\n                    if (!dirtyItemsCreateDOM.contains(item) && !item.hasParentWithChildrenMarkedToRecreation()) {\r\n                        dirtyItemsCreateDOM.add(item);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","lc":1.1818181818,"pi":1.9282296651,"ma":1.2,"nbd":1.5,"ml":1.75,"d":0.9345238095,"mi":-0.7465821001,"fo":1.8333333333,"r":-0.0263157895,"e":2.1699786195}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2962_023be574","label":0,"code":"@Override\r\npublic void readFields(DataInput in) throws IOException {\r\n    range.readFields(in);\r\n    int numLocs = in.readInt();\r\n    locations = new String[numLocs];\r\n    for (int i = 0; i < numLocs; ++i) locations[i] = in.readUTF();\r\n    if (in.readBoolean()) {\r\n        isolatedScan = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        offline = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        localIterators = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        mockInstance = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        int numColumns = in.readInt();\r\n        List<String> columns = new ArrayList<String>(numColumns);\r\n        for (int i = 0; i < numColumns; i++) {\r\n            columns.add(in.readUTF());\r\n        }\r\n        fetchedColumns = InputConfigurator.deserializeFetchedColumns(columns);\r\n    }\r\n    if (in.readBoolean()) {\r\n        String strAuths = in.readUTF();\r\n        auths = new Authorizations(strAuths.getBytes(Charset.forName(\"UTF-8\")));\r\n    }\r\n    if (in.readBoolean()) {\r\n        principal = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        String tokenClass = in.readUTF();\r\n        byte[] base64TokenBytes = in.readUTF().getBytes(Charset.forName(\"UTF-8\"));\r\n        byte[] tokenBytes = Base64.decodeBase64(base64TokenBytes);\r\n        try {\r\n            token = CredentialHelper.extractToken(tokenClass, tokenBytes);\r\n        } catch (AccumuloSecurityException e) {\r\n            throw new IOException(e);\r\n        }\r\n    }\r\n    if (in.readBoolean()) {\r\n        instanceName = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        zooKeepers = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        level = Level.toLevel(in.readInt());\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void readFields(DataInput in) throws IOException {\r\n    range.readFields(in);\r\n    int numLocs = in.readInt();\r\n    locations = new String[numLocs];\r\n    for (int i = 0; i < numLocs; ++i) locations[i] = in.readUTF();\r\n    if (in.readBoolean()) {\r\n        isolatedScan = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        offline = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        localIterators = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        mockInstance = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        int numColumns = in.readInt();\r\n        List<String> columns = new ArrayList<String>(numColumns);\r\n        for (int i = 0; i < numColumns; i++) {\r\n            columns.add(in.readUTF());\r\n        }\r\n        fetchedColumns = InputConfigurator.deserializeFetchedColumns(columns);\r\n    }\r\n    if (in.readBoolean()) {\r\n        String strAuths = in.readUTF();\r\n        auths = new Authorizations(strAuths.getBytes(Charset.forName(\"UTF-8\")));\r\n    }\r\n    if (in.readBoolean()) {\r\n        principal = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        String tokenClass = in.readUTF();\r\n        byte[] base64TokenBytes = in.readUTF().getBytes(Charset.forName(\"UTF-8\"));\r\n        byte[] tokenBytes = Base64.decodeBase64(base64TokenBytes);\r\n        try {\r\n            token = CredentialHelper.extractToken(tokenClass, tokenBytes);\r\n        } catch (AccumuloSecurityException e) {\r\n            throw new IOException(e);\r\n        }\r\n    }\r\n    if (in.readBoolean()) {\r\n        instanceName = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        zooKeepers = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        level = Level.toLevel(in.readInt());\r\n    }\r\n}","lc":1.7727272727,"pi":-0.1148325359,"ma":2.4,"nbd":0.0,"ml":1.0,"d":0.1468253968,"mi":-0.9343199436,"fo":2.5,"r":-0.0263157895,"e":0.8932510388}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Expands the internal storage array to the specified size.\r\n *\r\n * @param size Size of the new internal storage array.\r\n *\/\r\nprivate synchronized void expandTo(int size) {\r\n    final double[] tempArray = new double[size];\r\n    \/\/ Copy and swap\r\n    System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\r\n    internalArray = tempArray;\r\n}","code_comment":"\/**\r\n * Expands the internal storage array to the specified size.\r\n *\r\n * @param size Size of the new internal storage array.\r\n *\/\r\n","code_no_comment":"private synchronized void expandTo(int size) {\r\n    final double[] tempArray = new double[size];\r\n        System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\r\n    internalArray = tempArray;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.644820296,"fo":-0.4166666667,"r":2.2631578947,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4138_50db442b","label":1,"code":"\/**\r\n * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.\r\n *\r\n * @param tableName\r\n *          the table to compact\r\n * @param start\r\n *          first tablet to be compacted contains the row after this row, null means the first tablet in table\r\n * @param end\r\n *          last tablet to be merged contains this row, null means the last tablet in table\r\n * @param flush\r\n *          when true, table memory is flushed before compaction starts\r\n * @param wait\r\n *          when true, the call will not return until compactions are finished\r\n *\/\r\nvoid compact(String tableName, Text start, Text end, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;","code_comment":"\/**\r\n * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.\r\n *\r\n * @param tableName\r\n *          the table to compact\r\n * @param start\r\n *          first tablet to be compacted contains the row after this row, null means the first tablet in table\r\n * @param end\r\n *          last tablet to be merged contains this row, null means the last tablet in table\r\n * @param flush\r\n *          when true, table memory is flushed before compaction starts\r\n * @param wait\r\n *          when true, the call will not return until compactions are finished\r\n *\/\r\n","code_no_comment":"void compact(String tableName, Text start, Text end, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.4078928823,"fo":-0.5,"r":0.8421052632,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2047_a0a495f0","label":0,"code":"@SuppressWarnings(\"deprecation\")\r\nprivate void copyPrivileges(NodeBuilder root) throws RepositoryException {\r\n    PrivilegeRegistry registry = source.getPrivilegeRegistry();\r\n    NodeBuilder privileges = root.child(JCR_SYSTEM).child(REP_PRIVILEGES);\r\n    privileges.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGES, NAME);\r\n    PrivilegeBits next = PrivilegeBits.NEXT_AFTER_BUILT_INS;\r\n    logger.info(\"Copying registered privileges\");\r\n    for (Privilege privilege : registry.getRegisteredPrivileges()) {\r\n        String name = privilege.getName();\r\n        NodeBuilder def = privileges.child(name);\r\n        def.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGE, NAME);\r\n        if (privilege.isAbstract()) {\r\n            def.setProperty(REP_IS_ABSTRACT, true);\r\n        }\r\n        Privilege[] aggregate = privilege.getDeclaredAggregatePrivileges();\r\n        if (aggregate.length > 0) {\r\n            List<String> names = newArrayListWithCapacity(aggregate.length);\r\n            for (Privilege p : aggregate) {\r\n                names.add(p.getName());\r\n            }\r\n            def.setProperty(REP_AGGREGATES, names, NAMES);\r\n        }\r\n        PrivilegeBits bits = PrivilegeBits.BUILT_IN.get(name);\r\n        if (bits != null) {\r\n            def.setProperty(bits.asPropertyState(REP_BITS));\r\n        } else if (aggregate.length == 0) {\r\n            bits = next;\r\n            next = next.nextBits();\r\n            def.setProperty(bits.asPropertyState(REP_BITS));\r\n        }\r\n    }\r\n    privileges.setProperty(next.asPropertyState(REP_NEXT));\r\n    \/\/ resolve privilege bits also for all aggregates\r\n    for (String name : privileges.getChildNodeNames()) {\r\n        resolvePrivilegeBits(privileges, name);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings(\"deprecation\")\r\nprivate void copyPrivileges(NodeBuilder root) throws RepositoryException {\r\n    PrivilegeRegistry registry = source.getPrivilegeRegistry();\r\n    NodeBuilder privileges = root.child(JCR_SYSTEM).child(REP_PRIVILEGES);\r\n    privileges.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGES, NAME);\r\n    PrivilegeBits next = PrivilegeBits.NEXT_AFTER_BUILT_INS;\r\n    logger.info(\"Copying registered privileges\");\r\n    for (Privilege privilege : registry.getRegisteredPrivileges()) {\r\n        String name = privilege.getName();\r\n        NodeBuilder def = privileges.child(name);\r\n        def.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGE, NAME);\r\n        if (privilege.isAbstract()) {\r\n            def.setProperty(REP_IS_ABSTRACT, true);\r\n        }\r\n        Privilege[] aggregate = privilege.getDeclaredAggregatePrivileges();\r\n        if (aggregate.length > 0) {\r\n            List<String> names = newArrayListWithCapacity(aggregate.length);\r\n            for (Privilege p : aggregate) {\r\n                names.add(p.getName());\r\n            }\r\n            def.setProperty(REP_AGGREGATES, names, NAMES);\r\n        }\r\n        PrivilegeBits bits = PrivilegeBits.BUILT_IN.get(name);\r\n        if (bits != null) {\r\n            def.setProperty(bits.asPropertyState(REP_BITS));\r\n        } else if (aggregate.length == 0) {\r\n            bits = next;\r\n            next = next.nextBits();\r\n            def.setProperty(bits.asPropertyState(REP_BITS));\r\n        }\r\n    }\r\n    privileges.setProperty(next.asPropertyState(REP_NEXT));\r\n        for (String name : privileges.getChildNodeNames()) {\r\n        resolvePrivilegeBits(privileges, name);\r\n    }\r\n}","lc":1.0,"pi":0.4354066986,"ma":0.8,"nbd":0.5,"ml":0.1666666667,"d":0.4503968254,"mi":-0.6851303735,"fo":1.6666666667,"r":-0.0263157895,"e":1.2964436991}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3052_8dc70f2e","label":1,"code":"@Override\r\nprotected List<OperatorDescriptorSingle> getPossibleProperties() {\r\n    return this.operator;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected List<OperatorDescriptorSingle> getPossibleProperties() {\r\n    return this.operator;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9362931642,"fo":-0.5,"r":0.9210526316,"e":-0.1627934049}
{"project_name":"Cli","project_version":"29","label":1,"code":"\/**\r\n * Remove the leading and trailing quotes from <code>str<\/code>.\r\n * E.g. if str is '\"one two\"', then 'one two' is returned.\r\n *\r\n * @param str The string from which the leading and trailing quotes\r\n * should be removed.\r\n *\r\n * @return The string without the leading and trailing quotes.\r\n *\/\r\nstatic String stripLeadingAndTrailingQuotes(String str) {\r\n    if (str.startsWith(\"\\\"\")) {\r\n        str = str.substring(1, str.length());\r\n    }\r\n    int length = str.length();\r\n    if (str.endsWith(\"\\\"\")) {\r\n        str = str.substring(0, length - 1);\r\n    }\r\n    return str;\r\n}","code_comment":"\/**\r\n * Remove the leading and trailing quotes from <code>str<\/code>.\r\n * E.g. if str is '\"one two\"', then 'one two' is returned.\r\n *\r\n * @param str The string from which the leading and trailing quotes\r\n * should be removed.\r\n *\r\n * @return The string without the leading and trailing quotes.\r\n *\/\r\n","code_no_comment":"static String stripLeadingAndTrailingQuotes(String str) {\r\n    if (str.startsWith(\"\\\"\")) {\r\n        str = str.substring(1, str.length());\r\n    }\r\n    int length = str.length();\r\n    if (str.endsWith(\"\\\"\")) {\r\n        str = str.substring(0, length - 1);\r\n    }\r\n    return str;\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":0.121031746,"mi":0.2115574348,"fo":0.0,"r":0.0,"e":-0.032980066}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public void recv_setTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\r\n    setTableProperty_result result = new setTableProperty_result();\r\n    receiveBase(result, \"setTableProperty\");\r\n    if (result.ouch1 != null) {\r\n        throw result.ouch1;\r\n    }\r\n    if (result.ouch2 != null) {\r\n        throw result.ouch2;\r\n    }\r\n    return;\r\n}","code_comment":null,"code_no_comment":"public void recv_setTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\r\n    setTableProperty_result result = new setTableProperty_result();\r\n    receiveBase(result, \"setTableProperty\");\r\n    if (result.ouch1 != null) {\r\n        throw result.ouch1;\r\n    }\r\n    if (result.ouch2 != null) {\r\n        throw result.ouch2;\r\n    }\r\n    return;\r\n}","lc":-0.1363636364,"pi":-0.2775119617,"ma":0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0476190476,"mi":0.1605355884,"fo":-0.4166666667,"r":-0.0263157895,"e":-0.081384024}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-4388_f39bc60d","label":1,"code":"@Override\r\npublic boolean process(Exchange exchange, AsyncCallback callback) {\r\n    String msg = expression.evaluate(exchange, String.class);\r\n    logger.log(msg);\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean process(Exchange exchange, AsyncCallback callback) {\r\n    String msg = expression.evaluate(exchange, String.class);\r\n    logger.log(msg);\r\n    return true;\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5295278365,"fo":-0.3333333333,"r":0.4210526316,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4290_e1953357","label":1,"code":"@Override\r\npublic Url mapHandler(IRequestHandler requestHandler) {\r\n    Url url = super.mapHandler(requestHandler);\r\n    if (url == null && requestHandler instanceof ListenerInterfaceRequestHandler) {\r\n        ListenerInterfaceRequestHandler handler = (ListenerInterfaceRequestHandler) requestHandler;\r\n        IRequestablePage page = handler.getPage();\r\n        if (checkPageInstance(page)) {\r\n            String componentPath = handler.getComponentPath();\r\n            RequestListenerInterface listenerInterface = handler.getListenerInterface();\r\n            Integer renderCount = null;\r\n            if (listenerInterface.isIncludeRenderCount()) {\r\n                renderCount = page.getRenderCount();\r\n            }\r\n            PageInfo pageInfo = new PageInfo(page.getPageId());\r\n            ComponentInfo componentInfo = new ComponentInfo(renderCount, requestListenerInterfaceToString(listenerInterface), componentPath, handler.getBehaviorIndex());\r\n            PageComponentInfo pageComponentInfo = new PageComponentInfo(pageInfo, componentInfo);\r\n            UrlInfo urlInfo = new UrlInfo(pageComponentInfo, page.getClass(), handler.getPageParameters());\r\n            url = buildUrl(urlInfo);\r\n        }\r\n    }\r\n    return url;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Url mapHandler(IRequestHandler requestHandler) {\r\n    Url url = super.mapHandler(requestHandler);\r\n    if (url == null && requestHandler instanceof ListenerInterfaceRequestHandler) {\r\n        ListenerInterfaceRequestHandler handler = (ListenerInterfaceRequestHandler) requestHandler;\r\n        IRequestablePage page = handler.getPage();\r\n        if (checkPageInstance(page)) {\r\n            String componentPath = handler.getComponentPath();\r\n            RequestListenerInterface listenerInterface = handler.getListenerInterface();\r\n            Integer renderCount = null;\r\n            if (listenerInterface.isIncludeRenderCount()) {\r\n                renderCount = page.getRenderCount();\r\n            }\r\n            PageInfo pageInfo = new PageInfo(page.getPageId());\r\n            ComponentInfo componentInfo = new ComponentInfo(renderCount, requestListenerInterfaceToString(listenerInterface), componentPath, handler.getBehaviorIndex());\r\n            PageComponentInfo pageComponentInfo = new PageComponentInfo(pageInfo, componentInfo);\r\n            UrlInfo urlInfo = new UrlInfo(pageComponentInfo, page.getClass(), handler.getPageParameters());\r\n            url = buildUrl(urlInfo);\r\n        }\r\n    }\r\n    return url;\r\n}","lc":0.3636363636,"pi":0.7990430622,"ma":0.0,"nbd":0.5,"ml":0.3333333333,"d":0.005952381,"mi":-0.3570119803,"fo":0.5833333333,"r":-0.0263157895,"e":0.2294819707}
{"project_name":"Math","project_version":"76","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic RealMatrix getU() throws InvalidMatrixException {\r\n    if (cachedU == null) {\r\n        final int p = singularValues.length;\r\n        if (m >= n) {\r\n            \/\/ the tridiagonal matrix is Bt.B, where B is upper bidiagonal\r\n            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\r\n            final double[][] eData = e.getData();\r\n            final double[][] wData = new double[m][p];\r\n            double[] ei1 = eData[0];\r\n            for (int i = 0; i < p - 1; ++i) {\r\n                \/\/ compute W = B.E.S^(-1) where E is the eigenvectors matrix\r\n                final double mi = mainBidiagonal[i];\r\n                final double[] ei0 = ei1;\r\n                final double[] wi = wData[i];\r\n                ei1 = eData[i + 1];\r\n                final double si = secondaryBidiagonal[i];\r\n                for (int j = 0; j < p; ++j) {\r\n                    wi[j] = (mi * ei0[j] + si * ei1[j]) \/ singularValues[j];\r\n                }\r\n            }\r\n            for (int j = 0; j < p; ++j) {\r\n                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] \/ singularValues[j];\r\n            }\r\n            for (int i = p; i < m; ++i) {\r\n                wData[i] = new double[p];\r\n            }\r\n            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\r\n        } else {\r\n            \/\/ the tridiagonal matrix is B.Bt, where B is lower bidiagonal\r\n            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\r\n            cachedU = transformer.getU().multiply(e);\r\n        }\r\n    }\r\n    \/\/ return the cached matrix\r\n    return cachedU;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public RealMatrix getU() throws InvalidMatrixException {\r\n    if (cachedU == null) {\r\n        final int p = singularValues.length;\r\n        if (m >= n) {\r\n                        final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\r\n            final double[][] eData = e.getData();\r\n            final double[][] wData = new double[m][p];\r\n            double[] ei1 = eData[0];\r\n            for (int i = 0; i < p - 1; ++i) {\r\n                                final double mi = mainBidiagonal[i];\r\n                final double[] ei0 = ei1;\r\n                final double[] wi = wData[i];\r\n                ei1 = eData[i + 1];\r\n                final double si = secondaryBidiagonal[i];\r\n                for (int j = 0; j < p; ++j) {\r\n                    wi[j] = (mi * ei0[j] + si * ei1[j]) \/ singularValues[j];\r\n                }\r\n            }\r\n            for (int j = 0; j < p; ++j) {\r\n                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] \/ singularValues[j];\r\n            }\r\n            for (int i = p; i < m; ++i) {\r\n                wData[i] = new double[p];\r\n            }\r\n            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\r\n        } else {\r\n                        final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\r\n            cachedU = transformer.getU().multiply(e);\r\n        }\r\n    }\r\n        return cachedU;\r\n}","lc":0.8181818182,"pi":0.8708133971,"ma":0.6,"nbd":1.0,"ml":0.5833333333,"d":2.4007936508,"mi":-0.6405919662,"fo":0.3333333333,"r":-0.0263157895,"e":5.347180489}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1789_07646fba","label":1,"code":"private void fixFrozenUuid() {\r\n    \/\/ OAK-1789: Convert the jcr:frozenUuid of a non-referenceable\r\n    \/\/ frozen node from UUID to a path identifier\r\n    PropertyState frozenUuid = properties.get(JCR_FROZENUUID);\r\n    if (frozenUuid != null && frozenUuid.getType() == STRING && isFrozenNode.apply(this)) {\r\n        String frozenPrimary = NT_BASE;\r\n        Set<String> frozenMixins = newHashSet();\r\n        PropertyState property = properties.get(JCR_FROZENPRIMARYTYPE);\r\n        if (property != null && property.getType() == NAME) {\r\n            frozenPrimary = property.getValue(NAME);\r\n        }\r\n        property = properties.get(JCR_FROZENMIXINTYPES);\r\n        if (property != null && property.getType() == NAMES) {\r\n            addAll(frozenMixins, property.getValue(NAMES));\r\n        }\r\n        if (!isReferenceable.apply(frozenPrimary, frozenMixins)) {\r\n            frozenUuid = PropertyStates.createProperty(JCR_FROZENUUID, parent.getString(JCR_FROZENUUID) + \"\/\" + name);\r\n            properties.put(JCR_FROZENUUID, frozenUuid);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void fixFrozenUuid() {\r\n            PropertyState frozenUuid = properties.get(JCR_FROZENUUID);\r\n    if (frozenUuid != null && frozenUuid.getType() == STRING && isFrozenNode.apply(this)) {\r\n        String frozenPrimary = NT_BASE;\r\n        Set<String> frozenMixins = newHashSet();\r\n        PropertyState property = properties.get(JCR_FROZENPRIMARYTYPE);\r\n        if (property != null && property.getType() == NAME) {\r\n            frozenPrimary = property.getValue(NAME);\r\n        }\r\n        property = properties.get(JCR_FROZENMIXINTYPES);\r\n        if (property != null && property.getType() == NAMES) {\r\n            addAll(frozenMixins, property.getValue(NAMES));\r\n        }\r\n        if (!isReferenceable.apply(frozenPrimary, frozenMixins)) {\r\n            frozenUuid = PropertyStates.createProperty(JCR_FROZENUUID, parent.getString(JCR_FROZENUUID) + \"\/\" + name);\r\n            properties.put(JCR_FROZENUUID, frozenUuid);\r\n        }\r\n    }\r\n}","lc":0.2272727273,"pi":0.2440191388,"ma":0.2,"nbd":0.0,"ml":0.9166666667,"d":0.8253968254,"mi":-0.2947145877,"fo":0.75,"r":-0.0263157895,"e":1.0799513609}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3727_ff2713d1","label":1,"code":"\/**\r\n * Sends the given exchange to the recipient list\r\n *\/\r\npublic boolean sendToRecipientList(Exchange exchange, Object recipientList, AsyncCallback callback) {\r\n    Iterator<Object> iter = ObjectHelper.createIterator(recipientList, delimiter);\r\n    RecipientListProcessor rlp = new RecipientListProcessor(exchange.getContext(), producerCache, iter, getAggregationStrategy(), isParallelProcessing(), getExecutorService(), isStreaming(), isStopOnException(), getTimeout());\r\n    rlp.setIgnoreInvalidEndpoints(isIgnoreInvalidEndpoints());\r\n    \/\/ start the service\r\n    try {\r\n        ServiceHelper.startService(rlp);\r\n    } catch (Exception e) {\r\n        exchange.setException(e);\r\n        callback.done(true);\r\n        return true;\r\n    }\r\n    \/\/ now let the multicast process the exchange\r\n    return AsyncProcessorHelper.process(rlp, exchange, callback);\r\n}","code_comment":"\/**\r\n * Sends the given exchange to the recipient list\r\n *\/\r\n","code_no_comment":"public boolean sendToRecipientList(Exchange exchange, Object recipientList, AsyncCallback callback) {\r\n    Iterator<Object> iter = ObjectHelper.createIterator(recipientList, delimiter);\r\n    RecipientListProcessor rlp = new RecipientListProcessor(exchange.getContext(), producerCache, iter, getAggregationStrategy(), isParallelProcessing(), getExecutorService(), isStreaming(), isStopOnException(), getTimeout());\r\n    rlp.setIgnoreInvalidEndpoints(isIgnoreInvalidEndpoints());\r\n        try {\r\n        ServiceHelper.startService(rlp);\r\n    } catch (Exception e) {\r\n        exchange.setException(e);\r\n        callback.done(true);\r\n        return true;\r\n    }\r\n        return AsyncProcessorHelper.process(rlp, exchange, callback);\r\n}","lc":-0.0454545455,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.0198731501,"fo":0.6666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Closure","project_version":"40","label":2,"code":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    \/\/ Record global variable and function declarations\r\n    if (t.inGlobalScope()) {\r\n        if (NodeUtil.isVarDeclaration(n)) {\r\n            NameInformation ns = createNameInformation(t, n, parent);\r\n            Preconditions.checkNotNull(ns);\r\n            recordSet(ns.name, n);\r\n        } else if (NodeUtil.isFunctionDeclaration(n)) {\r\n            Node nameNode = n.getFirstChild();\r\n            NameInformation ns = createNameInformation(t, nameNode, n);\r\n            if (ns != null) {\r\n                JsName nameInfo = getName(nameNode.getString(), true);\r\n                recordSet(nameInfo.name, nameNode);\r\n            }\r\n        } else if (NodeUtil.isObjectLitKey(n, parent)) {\r\n            NameInformation ns = createNameInformation(t, n, parent);\r\n            if (ns != null) {\r\n                recordSet(ns.name, n);\r\n            }\r\n        }\r\n    }\r\n    \/\/ Record assignments and call sites\r\n    if (n.isAssign()) {\r\n        Node nameNode = n.getFirstChild();\r\n        NameInformation ns = createNameInformation(t, nameNode, n);\r\n        if (ns != null) {\r\n            if (ns.isPrototype) {\r\n                recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\r\n            } else {\r\n                recordSet(ns.name, nameNode);\r\n            }\r\n        }\r\n    } else if (n.isCall()) {\r\n        Node nameNode = n.getFirstChild();\r\n        NameInformation ns = createNameInformation(t, nameNode, n);\r\n        if (ns != null && ns.onlyAffectsClassDef) {\r\n            JsName name = getName(ns.name, false);\r\n            if (name != null) {\r\n                refNodes.add(new ClassDefiningFunctionNode(name, n, parent, parent.getParent()));\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n        if (t.inGlobalScope()) {\r\n        if (NodeUtil.isVarDeclaration(n)) {\r\n            NameInformation ns = createNameInformation(t, n, parent);\r\n            Preconditions.checkNotNull(ns);\r\n            recordSet(ns.name, n);\r\n        } else if (NodeUtil.isFunctionDeclaration(n)) {\r\n            Node nameNode = n.getFirstChild();\r\n            NameInformation ns = createNameInformation(t, nameNode, n);\r\n            if (ns != null) {\r\n                JsName nameInfo = getName(nameNode.getString(), true);\r\n                recordSet(nameInfo.name, nameNode);\r\n            }\r\n        } else if (NodeUtil.isObjectLitKey(n, parent)) {\r\n            NameInformation ns = createNameInformation(t, n, parent);\r\n            if (ns != null) {\r\n                recordSet(ns.name, n);\r\n            }\r\n        }\r\n    }\r\n        if (n.isAssign()) {\r\n        Node nameNode = n.getFirstChild();\r\n        NameInformation ns = createNameInformation(t, nameNode, n);\r\n        if (ns != null) {\r\n            if (ns.isPrototype) {\r\n                recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\r\n            } else {\r\n                recordSet(ns.name, nameNode);\r\n            }\r\n        }\r\n    } else if (n.isCall()) {\r\n        Node nameNode = n.getFirstChild();\r\n        NameInformation ns = createNameInformation(t, nameNode, n);\r\n        if (ns != null && ns.onlyAffectsClassDef) {\r\n            JsName name = getName(ns.name, false);\r\n            if (name != null) {\r\n                refNodes.add(new ClassDefiningFunctionNode(name, n, parent, parent.getParent()));\r\n            }\r\n        }\r\n    }\r\n}","lc":1.2727272727,"pi":0.6602870813,"ma":1.8,"nbd":1.5,"ml":1.6666666667,"d":0.2599206349,"mi":-0.7880197322,"fo":1.5833333333,"r":-0.0263157895,"e":0.95621445}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_46f62443","label":1,"code":"@Override\r\npublic void clearLocatorCache(String tableName) throws TableNotFoundException {\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void clearLocatorCache(String tableName) throws TableNotFoundException {\r\n}","lc":-0.5,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.067653277,"fo":-0.5,"r":2.2631578947,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7429_43956f93","label":1,"code":"private String createPlaceholderPart(String key, Properties properties, List<String> replaced, String prefixToken, String suffixToken) {\r\n    \/\/ keep track of which parts we have replaced\r\n    replaced.add(key);\r\n    String propertyValue = System.getProperty(key);\r\n    if (propertyValue != null) {\r\n        log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\r\n    } else if (properties != null) {\r\n        propertyValue = properties.getProperty(key);\r\n    }\r\n    \/\/ we need to check if the propertyValue is nested\r\n    \/\/ we need to check if there is cycle dependency of the nested properties\r\n    List<String> visited = new ArrayList<String>();\r\n    while (isNestProperty(propertyValue, prefixToken, suffixToken)) {\r\n        visited.add(key);\r\n        \/\/ need to take off the token first\r\n        String value = takeOffNestTokes(propertyValue, prefixToken, suffixToken);\r\n        key = parseUri(value, properties, prefixToken, suffixToken);\r\n        if (visited.contains(key)) {\r\n            throw new IllegalArgumentException(\"Circular reference detected with key [\" + key + \"] from text: \" + propertyValue);\r\n        }\r\n        propertyValue = System.getProperty(key);\r\n        if (propertyValue != null) {\r\n            log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\r\n        } else if (properties != null) {\r\n            propertyValue = properties.getProperty(key);\r\n        }\r\n    }\r\n    return parseProperty(key, propertyValue, properties);\r\n}","code_comment":null,"code_no_comment":"private String createPlaceholderPart(String key, Properties properties, List<String> replaced, String prefixToken, String suffixToken) {\r\n        replaced.add(key);\r\n    String propertyValue = System.getProperty(key);\r\n    if (propertyValue != null) {\r\n        log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\r\n    } else if (properties != null) {\r\n        propertyValue = properties.getProperty(key);\r\n    }\r\n            List<String> visited = new ArrayList<String>();\r\n    while (isNestProperty(propertyValue, prefixToken, suffixToken)) {\r\n        visited.add(key);\r\n                String value = takeOffNestTokes(propertyValue, prefixToken, suffixToken);\r\n        key = parseUri(value, properties, prefixToken, suffixToken);\r\n        if (visited.contains(key)) {\r\n            throw new IllegalArgumentException(\"Circular reference detected with key [\" + key + \"] from text: \" + propertyValue);\r\n        }\r\n        propertyValue = System.getProperty(key);\r\n        if (propertyValue != null) {\r\n            log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\r\n        } else if (properties != null) {\r\n            propertyValue = properties.getProperty(key);\r\n        }\r\n    }\r\n    return parseProperty(key, propertyValue, properties);\r\n}","lc":0.5,"pi":0.1004784689,"ma":0.8,"nbd":0.5,"ml":0.6666666667,"d":0.2361111111,"mi":-0.4551092319,"fo":0.5833333333,"r":-0.0263157895,"e":0.5367057969}
{"project_name":"JxPath","project_version":"14","label":1,"code":"protected Object functionRound(EvalContext context) {\r\n    assertArgCount(1);\r\n    double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\r\n    return new Double(Math.round(v));\r\n}","code_comment":null,"code_no_comment":"protected Object functionRound(EvalContext context) {\r\n    assertArgCount(1);\r\n    double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\r\n    return new Double(Math.round(v));\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6093023256,"fo":-0.0833333333,"r":1.2105263158,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2330_408a566e","label":3,"code":"@Override\r\npublic void onResult(Aggregate.PropertyIncludeResult result) throws CommitFailedException {\r\n    boolean dirty = false;\r\n    if (result.pd.ordered) {\r\n        dirty |= addTypedOrderedFields(fields, result.propertyState, result.propertyPath, result.pd);\r\n    }\r\n    dirty |= indexProperty(path, fields, state, result.propertyState, result.propertyPath, true, result.pd);\r\n    if (dirty) {\r\n        dirtyFlag.set(true);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void onResult(Aggregate.PropertyIncludeResult result) throws CommitFailedException {\r\n    boolean dirty = false;\r\n    if (result.pd.ordered) {\r\n        dirty |= addTypedOrderedFields(fields, result.propertyState, result.propertyPath, result.pd);\r\n    }\r\n    dirty |= indexProperty(path, fields, state, result.propertyState, result.propertyPath, true, result.pd);\r\n    if (dirty) {\r\n        dirtyFlag.set(true);\r\n    }\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0158730159,"mi":0.1010570825,"fo":-0.25,"r":-0.0263157895,"e":-0.0158157708}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3903_690fb9f4","label":1,"code":"\/**\r\n * Updates a commit root document.\r\n *\r\n * @param commit the updates to apply on the commit root document.\r\n * @return the document before the update was applied or <code>null<\/code>\r\n *          if the update failed because of a collision.\r\n * @throws DocumentStoreException if the update fails with an error.\r\n *\/\r\n@CheckForNull\r\nNodeDocument updateCommitRoot(UpdateOp commit) throws DocumentStoreException {\r\n    \/\/ use batch commit when there are only revision and modified updates\r\n    boolean batch = true;\r\n    for (Map.Entry<Key, Operation> op : commit.getChanges().entrySet()) {\r\n        String name = op.getKey().getName();\r\n        if (NodeDocument.isRevisionsEntry(name) || NodeDocument.MODIFIED_IN_SECS.equals(name)) {\r\n            continue;\r\n        }\r\n        batch = false;\r\n        break;\r\n    }\r\n    if (batch) {\r\n        return batchUpdateCommitRoot(commit);\r\n    } else {\r\n        return store.findAndUpdate(NODES, commit);\r\n    }\r\n}","code_comment":"\/**\r\n * Updates a commit root document.\r\n *\r\n * @param commit the updates to apply on the commit root document.\r\n * @return the document before the update was applied or <code>null<\/code>\r\n *          if the update failed because of a collision.\r\n * @throws DocumentStoreException if the update fails with an error.\r\n *\/\r\n","code_no_comment":"@CheckForNull\r\nNodeDocument updateCommitRoot(UpdateOp commit) throws DocumentStoreException {\r\n        boolean batch = true;\r\n    for (Map.Entry<Key, Operation> op : commit.getChanges().entrySet()) {\r\n        String name = op.getKey().getName();\r\n        if (NodeDocument.isRevisionsEntry(name) || NodeDocument.MODIFIED_IN_SECS.equals(name)) {\r\n            continue;\r\n        }\r\n        batch = false;\r\n        break;\r\n    }\r\n    if (batch) {\r\n        return batchUpdateCommitRoot(commit);\r\n    } else {\r\n        return store.findAndUpdate(NODES, commit);\r\n    }\r\n}","lc":0.1363636364,"pi":0.1674641148,"ma":0.4,"nbd":0.0,"ml":0.1666666667,"d":-0.0952380952,"mi":-0.1362931642,"fo":0.1666666667,"r":0.0263157895,"e":-0.0338468099}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-209_397f86f6","label":1,"code":"private boolean matches(Matcher matcher, ByteSequence bs) {\r\n    if (matcher != null) {\r\n        babcs.set(bs);\r\n        matcher.reset(babcs);\r\n        return matcher.matches();\r\n    }\r\n    return !orFields;\r\n}","code_comment":null,"code_no_comment":"private boolean matches(Matcher matcher, ByteSequence bs) {\r\n    if (matcher != null) {\r\n        babcs.set(bs);\r\n        matcher.reset(babcs);\r\n        return matcher.matches();\r\n    }\r\n    return !orFields;\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0575396825,"mi":0.3916842847,"fo":-0.25,"r":0.5,"e":-0.1126974522}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1008_0c20bfd8","label":1,"code":"\/**\r\n * Finds matching classes within a jar files that contains a folder structure\r\n * matching the package structure.  If the File is not a JarFile or does not exist a warning\r\n * will be logged, but no error will be raised.\r\n *\r\n * @param test a Test used to filter the classes that are discovered\r\n * @param parent the parent package under which classes must be in order to be considered\r\n * @param stream The jar InputStream\r\n *\/\r\nprivate void loadImplementationsInJar(final Test test, final String parent, final String path, final JarInputStream stream) {\r\n    try {\r\n        JarEntry entry;\r\n        while ((entry = stream.getNextJarEntry()) != null) {\r\n            final String name = entry.getName();\r\n            if (!entry.isDirectory() && name.startsWith(parent) && isTestApplicable(test, name)) {\r\n                addIfMatching(test, name);\r\n            }\r\n        }\r\n    } catch (final IOException ioe) {\r\n        LOGGER.error(\"Could not search jar file '\" + path + \"' for classes matching criteria: \" + test + \" due to an IOException\", ioe);\r\n    }\r\n}","code_comment":"\/**\r\n * Finds matching classes within a jar files that contains a folder structure\r\n * matching the package structure.  If the File is not a JarFile or does not exist a warning\r\n * will be logged, but no error will be raised.\r\n *\r\n * @param test a Test used to filter the classes that are discovered\r\n * @param parent the parent package under which classes must be in order to be considered\r\n * @param stream The jar InputStream\r\n *\/\r\n","code_no_comment":"private void loadImplementationsInJar(final Test test, final String parent, final String path, final JarInputStream stream) {\r\n    try {\r\n        JarEntry entry;\r\n        while ((entry = stream.getNextJarEntry()) != null) {\r\n            final String name = entry.getName();\r\n            if (!entry.isDirectory() && name.startsWith(parent) && isTestApplicable(test, name)) {\r\n                addIfMatching(test, name);\r\n            }\r\n        }\r\n    } catch (final IOException ioe) {\r\n        LOGGER.error(\"Could not search jar file '\" + path + \"' for classes matching criteria: \" + test + \" due to an IOException\", ioe);\r\n    }\r\n}","lc":-0.0454545455,"pi":0.8038277512,"ma":0.0,"nbd":0.5,"ml":0.4166666667,"d":0.2599206349,"mi":-0.0184637068,"fo":0.0833333333,"r":0.1052631579,"e":0.1757715116}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public boolean equals(removeConstraint_result that) {\r\n    if (that == null)\r\n        return false;\r\n    boolean this_present_ouch1 = true && this.isSetOuch1();\r\n    boolean that_present_ouch1 = true && that.isSetOuch1();\r\n    if (this_present_ouch1 || that_present_ouch1) {\r\n        if (!(this_present_ouch1 && that_present_ouch1))\r\n            return false;\r\n        if (!this.ouch1.equals(that.ouch1))\r\n            return false;\r\n    }\r\n    boolean this_present_ouch2 = true && this.isSetOuch2();\r\n    boolean that_present_ouch2 = true && that.isSetOuch2();\r\n    if (this_present_ouch2 || that_present_ouch2) {\r\n        if (!(this_present_ouch2 && that_present_ouch2))\r\n            return false;\r\n        if (!this.ouch2.equals(that.ouch2))\r\n            return false;\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"public boolean equals(removeConstraint_result that) {\r\n    if (that == null)\r\n        return false;\r\n    boolean this_present_ouch1 = true && this.isSetOuch1();\r\n    boolean that_present_ouch1 = true && that.isSetOuch1();\r\n    if (this_present_ouch1 || that_present_ouch1) {\r\n        if (!(this_present_ouch1 && that_present_ouch1))\r\n            return false;\r\n        if (!this.ouch1.equals(that.ouch1))\r\n            return false;\r\n    }\r\n    boolean this_present_ouch2 = true && this.isSetOuch2();\r\n    boolean that_present_ouch2 = true && that.isSetOuch2();\r\n    if (this_present_ouch2 || that_present_ouch2) {\r\n        if (!(this_present_ouch2 && that_present_ouch2))\r\n            return false;\r\n        if (!this.ouch2.equals(that.ouch2))\r\n            return false;\r\n    }\r\n    return true;\r\n}","lc":0.3181818182,"pi":0.3014354067,"ma":0.8,"nbd":-0.5,"ml":1.25,"d":0.746031746,"mi":-0.2769556025,"fo":0.0,"r":-0.0263157895,"e":0.4955492932}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5176_34634266","label":3,"code":"\/**\r\n *  @see org.apache.wicket.model.IDetachable#detach()\r\n *\/\r\n@Override\r\nprotected final void onDetach() {\r\n    super.onDetach();\r\n    \/\/ detach any model\r\n    if (model != null) {\r\n        model.detach();\r\n    }\r\n    \/\/ some parameters can be detachable\r\n    if (parameters != null) {\r\n        for (Object parameter : parameters) {\r\n            if (parameter instanceof IDetachable) {\r\n                ((IDetachable) parameter).detach();\r\n            }\r\n        }\r\n    }\r\n    if (defaultValue != null) {\r\n        defaultValue.detach();\r\n    }\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.model.IDetachable#detach()\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected final void onDetach() {\r\n    super.onDetach();\r\n        if (model != null) {\r\n        model.detach();\r\n    }\r\n        if (parameters != null) {\r\n        for (Object parameter : parameters) {\r\n            if (parameter instanceof IDetachable) {\r\n                ((IDetachable) parameter).detach();\r\n            }\r\n        }\r\n    }\r\n    if (defaultValue != null) {\r\n        defaultValue.detach();\r\n    }\r\n}","lc":0.1363636364,"pi":0.6555023923,"ma":0.4,"nbd":0.5,"ml":0.25,"d":-0.3650793651,"mi":-0.014235377,"fo":-0.1666666667,"r":0.5789473684,"e":-0.1627934049}
{"project_name":"Lang","project_version":"17","label":1,"code":"\/**\r\n * Translate an input onto a Writer. This is intentionally final as its algorithm is\r\n * tightly coupled with the abstract method of this class.\r\n *\r\n * @param input CharSequence that is being translated\r\n * @param out Writer to translate the text to\r\n * @throws IOException if and only if the Writer produces an IOException\r\n *\/\r\npublic final void translate(CharSequence input, Writer out) throws IOException {\r\n    if (out == null) {\r\n        throw new IllegalArgumentException(\"The Writer must not be null\");\r\n    }\r\n    if (input == null) {\r\n        return;\r\n    }\r\n    int pos = 0;\r\n    int len = Character.codePointCount(input, 0, input.length());\r\n    while (pos < len) {\r\n        int consumed = translate(input, pos, out);\r\n        if (consumed == 0) {\r\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\r\n            out.write(c);\r\n        } else {\r\n            \/\/ \/\/ and they just took care of a surrogate pair\r\n            for (int pt = 0; pt < consumed; pt++) {\r\n                if (pos < len - 2) {\r\n                    pos += Character.charCount(Character.codePointAt(input, pos));\r\n                } else {\r\n                    pos++;\r\n                }\r\n            }\r\n            pos--;\r\n        }\r\n        pos++;\r\n    }\r\n}","code_comment":"\/**\r\n * Translate an input onto a Writer. This is intentionally final as its algorithm is\r\n * tightly coupled with the abstract method of this class.\r\n *\r\n * @param input CharSequence that is being translated\r\n * @param out Writer to translate the text to\r\n * @throws IOException if and only if the Writer produces an IOException\r\n *\/\r\n","code_no_comment":"public final void translate(CharSequence input, Writer out) throws IOException {\r\n    if (out == null) {\r\n        throw new IllegalArgumentException(\"The Writer must not be null\");\r\n    }\r\n    if (input == null) {\r\n        return;\r\n    }\r\n    int pos = 0;\r\n    int len = Character.codePointCount(input, 0, input.length());\r\n    while (pos < len) {\r\n        int consumed = translate(input, pos, out);\r\n        if (consumed == 0) {\r\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\r\n            out.write(c);\r\n        } else {\r\n                        for (int pt = 0; pt < consumed; pt++) {\r\n                if (pos < len - 2) {\r\n                    pos += Character.charCount(Character.codePointAt(input, pos));\r\n                } else {\r\n                    pos++;\r\n                }\r\n            }\r\n            pos--;\r\n        }\r\n        pos++;\r\n    }\r\n}","lc":0.5909090909,"pi":1.1770334928,"ma":0.8,"nbd":1.0,"ml":0.5833333333,"d":1.0992063492,"mi":-0.4486257928,"fo":0.1666666667,"r":-0.0263157895,"e":1.1174195928}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6447_020c451a","label":1,"code":"public boolean process(Exchange exchange, AsyncCallback callback) {\r\n    Iterator<Processor> processors = next().iterator();\r\n    exchange.setProperty(Exchange.FILTER_MATCHED, false);\r\n    while (continueRouting(processors, exchange)) {\r\n        \/\/ get the next processor\r\n        Processor processor = processors.next();\r\n        AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\r\n        boolean sync = process(exchange, callback, processors, async);\r\n        \/\/ continue as long its being processed synchronously\r\n        if (!sync) {\r\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\r\n            \/\/ so we break out now, then the callback will be invoked which then continue routing from where we left here\r\n            return false;\r\n        }\r\n        LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\r\n        \/\/ check for error if so we should break out\r\n        if (!continueProcessing(exchange, \"so breaking out of content based router\", LOG)) {\r\n            break;\r\n        }\r\n    }\r\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n    callback.done(true);\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"public boolean process(Exchange exchange, AsyncCallback callback) {\r\n    Iterator<Processor> processors = next().iterator();\r\n    exchange.setProperty(Exchange.FILTER_MATCHED, false);\r\n    while (continueRouting(processors, exchange)) {\r\n                Processor processor = processors.next();\r\n        AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\r\n        boolean sync = process(exchange, callback, processors, async);\r\n                if (!sync) {\r\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\r\n                        return false;\r\n        }\r\n        LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\r\n                if (!continueProcessing(exchange, \"so breaking out of content based router\", LOG)) {\r\n            break;\r\n        }\r\n    }\r\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n    callback.done(true);\r\n    return true;\r\n}","lc":0.2727272727,"pi":0.2153110048,"ma":0.2,"nbd":0.0,"ml":0.25,"d":0.0198412698,"mi":-0.274136716,"fo":0.75,"r":-0.0263157895,"e":0.1342876737}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8964_ea8ee025","label":1,"code":"\/**\r\n * Suspends the given {@code service}.\r\n * <p\/>\r\n * If {@code service} is a {@link org.apache.camel.SuspendableService} then\r\n * it's {@link org.apache.camel.SuspendableService#suspend()} is called but\r\n * <b>only<\/b> if {@code service} is <b>not<\/b> already\r\n * {@link #isSuspended(Object) suspended}.\r\n * <p\/>\r\n * If {@code service} is <b>not<\/b> a\r\n * {@link org.apache.camel.SuspendableService} then it's\r\n * {@link org.apache.camel.Service#stop()} is called.\r\n * <p\/>\r\n * Calling this method has no effect if {@code service} is {@code null}.\r\n *\r\n * @param service the service\r\n * @return <tt>true<\/tt> if either the <tt>suspend<\/tt> method or\r\n *         {@link #stopService(Object)} was called, <tt>false<\/tt>\r\n *         otherwise.\r\n * @throws Exception is thrown if error occurred\r\n * @see #stopService(Object)\r\n *\/\r\npublic static boolean suspendService(Service service) throws Exception {\r\n    if (service instanceof SuspendableService) {\r\n        SuspendableService ss = (SuspendableService) service;\r\n        if (!ss.isSuspended()) {\r\n            LOG.trace(\"Suspending service {}\", service);\r\n            ss.suspend();\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } else {\r\n        stopService(service);\r\n        return true;\r\n    }\r\n}","code_comment":"\/**\r\n * Suspends the given {@code service}.\r\n * <p\/>\r\n * If {@code service} is a {@link org.apache.camel.SuspendableService} then\r\n * it's {@link org.apache.camel.SuspendableService#suspend()} is called but\r\n * <b>only<\/b> if {@code service} is <b>not<\/b> already\r\n * {@link #isSuspended(Object) suspended}.\r\n * <p\/>\r\n * If {@code service} is <b>not<\/b> a\r\n * {@link org.apache.camel.SuspendableService} then it's\r\n * {@link org.apache.camel.Service#stop()} is called.\r\n * <p\/>\r\n * Calling this method has no effect if {@code service} is {@code null}.\r\n *\r\n * @param service the service\r\n * @return <tt>true<\/tt> if either the <tt>suspend<\/tt> method or\r\n *         {@link #stopService(Object)} was called, <tt>false<\/tt>\r\n *         otherwise.\r\n * @throws Exception is thrown if error occurred\r\n * @see #stopService(Object)\r\n *\/\r\n","code_no_comment":"public static boolean suspendService(Service service) throws Exception {\r\n    if (service instanceof SuspendableService) {\r\n        SuspendableService ss = (SuspendableService) service;\r\n        if (!ss.isSuspended()) {\r\n            LOG.trace(\"Suspending service {}\", service);\r\n            ss.suspend();\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } else {\r\n        stopService(service);\r\n        return true;\r\n    }\r\n}","lc":0.0454545455,"pi":0.4449760766,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0476190476,"mi":0.0376321353,"fo":-0.1666666667,"r":-0.0263157895,"e":-0.0843991863}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1051_bda25b40","label":1,"code":"\/**\r\n * Perform a double QR step involving rows l:idx and columns m:n\r\n *\r\n * @param il the index of the small sub-diagonal element\r\n * @param im the start index for the QR step\r\n * @param iu the current eigenvalue index\r\n * @param shift shift information holder\r\n * @param hVec the initial houseHolder vector\r\n *\/\r\nprivate void performDoubleQRStep(final int il, final int im, final int iu, final ShiftInfo shift, final double[] hVec) {\r\n    final int n = matrixT.length;\r\n    double p = hVec[0];\r\n    double q = hVec[1];\r\n    double r = hVec[2];\r\n    for (int k = im; k <= iu - 1; k++) {\r\n        boolean notlast = k != (iu - 1);\r\n        if (k != im) {\r\n            p = matrixT[k][k - 1];\r\n            q = matrixT[k + 1][k - 1];\r\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\r\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\r\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\r\n                p = p \/ shift.x;\r\n                q = q \/ shift.x;\r\n                r = r \/ shift.x;\r\n            }\r\n        }\r\n        if (shift.x == 0.0) {\r\n            break;\r\n        }\r\n        double s = FastMath.sqrt(p * p + q * q + r * r);\r\n        if (p < 0.0) {\r\n            s = -s;\r\n        }\r\n        if (s != 0.0) {\r\n            if (k != im) {\r\n                matrixT[k][k - 1] = -s * shift.x;\r\n            } else if (il != im) {\r\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\r\n            }\r\n            p = p + s;\r\n            shift.x = p \/ s;\r\n            shift.y = q \/ s;\r\n            double z = r \/ s;\r\n            q = q \/ p;\r\n            r = r \/ p;\r\n            \/\/ Row modification\r\n            for (int j = k; j < n; j++) {\r\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\r\n                if (notlast) {\r\n                    p = p + r * matrixT[k + 2][j];\r\n                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\r\n                }\r\n                matrixT[k][j] = matrixT[k][j] - p * shift.x;\r\n                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\r\n            }\r\n            \/\/ Column modification\r\n            for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\r\n                p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\r\n                if (notlast) {\r\n                    p = p + z * matrixT[i][k + 2];\r\n                    matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\r\n                }\r\n                matrixT[i][k] = matrixT[i][k] - p;\r\n                matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\r\n            }\r\n            \/\/ Accumulate transformations\r\n            final int high = matrixT.length - 1;\r\n            for (int i = 0; i <= high; i++) {\r\n                p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\r\n                if (notlast) {\r\n                    p = p + z * matrixP[i][k + 2];\r\n                    matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\r\n                }\r\n                matrixP[i][k] = matrixP[i][k] - p;\r\n                matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\r\n            }\r\n        }\r\n    \/\/ (s != 0)\r\n    }\r\n    \/\/ clean up pollution due to round-off errors\r\n    for (int i = im + 2; i <= iu; i++) {\r\n        matrixT[i][i - 2] = 0.0;\r\n        if (i > im + 2) {\r\n            matrixT[i][i - 3] = 0.0;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Perform a double QR step involving rows l:idx and columns m:n\r\n *\r\n * @param il the index of the small sub-diagonal element\r\n * @param im the start index for the QR step\r\n * @param iu the current eigenvalue index\r\n * @param shift shift information holder\r\n * @param hVec the initial houseHolder vector\r\n *\/\r\n","code_no_comment":"private void performDoubleQRStep(final int il, final int im, final int iu, final ShiftInfo shift, final double[] hVec) {\r\n    final int n = matrixT.length;\r\n    double p = hVec[0];\r\n    double q = hVec[1];\r\n    double r = hVec[2];\r\n    for (int k = im; k <= iu - 1; k++) {\r\n        boolean notlast = k != (iu - 1);\r\n        if (k != im) {\r\n            p = matrixT[k][k - 1];\r\n            q = matrixT[k + 1][k - 1];\r\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\r\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\r\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\r\n                p = p \/ shift.x;\r\n                q = q \/ shift.x;\r\n                r = r \/ shift.x;\r\n            }\r\n        }\r\n        if (shift.x == 0.0) {\r\n            break;\r\n        }\r\n        double s = FastMath.sqrt(p * p + q * q + r * r);\r\n        if (p < 0.0) {\r\n            s = -s;\r\n        }\r\n        if (s != 0.0) {\r\n            if (k != im) {\r\n                matrixT[k][k - 1] = -s * shift.x;\r\n            } else if (il != im) {\r\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\r\n            }\r\n            p = p + s;\r\n            shift.x = p \/ s;\r\n            shift.y = q \/ s;\r\n            double z = r \/ s;\r\n            q = q \/ p;\r\n            r = r \/ p;\r\n                        for (int j = k; j < n; j++) {\r\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\r\n                if (notlast) {\r\n                    p = p + r * matrixT[k + 2][j];\r\n                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\r\n                }\r\n                matrixT[k][j] = matrixT[k][j] - p * shift.x;\r\n                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\r\n            }\r\n                        for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\r\n                p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\r\n                if (notlast) {\r\n                    p = p + z * matrixT[i][k + 2];\r\n                    matrixT[i][k + 2] = matrixT[i][k + 2] - p * r;\r\n                }\r\n                matrixT[i][k] = matrixT[i][k] - p;\r\n                matrixT[i][k + 1] = matrixT[i][k + 1] - p * q;\r\n            }\r\n                        final int high = matrixT.length - 1;\r\n            for (int i = 0; i <= high; i++) {\r\n                p = shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];\r\n                if (notlast) {\r\n                    p = p + z * matrixP[i][k + 2];\r\n                    matrixP[i][k + 2] = matrixP[i][k + 2] - p * r;\r\n                }\r\n                matrixP[i][k] = matrixP[i][k] - p;\r\n                matrixP[i][k + 1] = matrixP[i][k + 1] - p * q;\r\n            }\r\n        }\r\n        }\r\n        for (int i = im + 2; i <= iu; i++) {\r\n        matrixT[i][i - 2] = 0.0;\r\n        if (i > im + 2) {\r\n            matrixT[i][i - 3] = 0.0;\r\n        }\r\n    }\r\n}","lc":2.7272727273,"pi":0.8708133971,"ma":3.0,"nbd":1.0,"ml":2.25,"d":10.2162698413,"mi":-1.2641296688,"fo":0.0,"r":-0.0263157895,"e":63.9683246601}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4259_1f128536","label":3,"code":"\/**\r\n *  get a model that accesses the parent model lazily. this is required since we eventually\r\n *  request the parents model before the component is added to the parent.\r\n *\r\n *  @return model\r\n *\/\r\nprivate IModel<T> getDelegatingParentModel() {\r\n    return new IModel<T>() {\r\n\r\n        private static final long serialVersionUID = 1L;\r\n\r\n        public T getObject() {\r\n            return getParentModel().getObject();\r\n        }\r\n\r\n        public void setObject(final T object) {\r\n            getParentModel().setObject(object);\r\n        }\r\n\r\n        public void detach() {\r\n            getParentModel().detach();\r\n        }\r\n    };\r\n}","code_comment":"\/**\r\n *  get a model that accesses the parent model lazily. this is required since we eventually\r\n *  request the parents model before the component is added to the parent.\r\n *\r\n *  @return model\r\n *\/\r\n","code_no_comment":"private IModel<T> getDelegatingParentModel() {\r\n    return new IModel<T>() {\r\n\r\n        private static final long serialVersionUID = 1L;\r\n\r\n        public T getObject() {\r\n            return getParentModel().getObject();\r\n        }\r\n\r\n        public void setObject(final T object) {\r\n            getParentModel().setObject(object);\r\n        }\r\n\r\n        public void detach() {\r\n            getParentModel().detach();\r\n        }\r\n    };\r\n}","lc":0.0,"pi":0.3684210526,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.1255813953,"fo":0.0,"r":1.9473684211,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1133_27e40205","label":1,"code":"\/\/ for (Rich)Functions\r\n@SuppressWarnings(\"unchecked\")\r\nprivate <IN1, IN2, OUT> TypeInformation<OUT> privateCreateTypeInfo(Class<?> baseClass, Class<?> clazz, int returnParamPos, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\r\n    ArrayList<Type> typeHierarchy = new ArrayList<Type>();\r\n    Type returnType = getParameterType(baseClass, typeHierarchy, clazz, returnParamPos);\r\n    TypeInformation<OUT> typeInfo = null;\r\n    \/\/ return type is a variable -> try to get the type info from the input directly\r\n    if (returnType instanceof TypeVariable<?>) {\r\n        typeInfo = (TypeInformation<OUT>) createTypeInfoFromInput((TypeVariable<?>) returnType, typeHierarchy, in1Type, in2Type);\r\n        if (typeInfo != null) {\r\n            return typeInfo;\r\n        }\r\n    }\r\n    \/\/ get info from hierarchy\r\n    return (TypeInformation<OUT>) createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type);\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings(\"unchecked\")\r\nprivate <IN1, IN2, OUT> TypeInformation<OUT> privateCreateTypeInfo(Class<?> baseClass, Class<?> clazz, int returnParamPos, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\r\n    ArrayList<Type> typeHierarchy = new ArrayList<Type>();\r\n    Type returnType = getParameterType(baseClass, typeHierarchy, clazz, returnParamPos);\r\n    TypeInformation<OUT> typeInfo = null;\r\n        if (returnType instanceof TypeVariable<?>) {\r\n        typeInfo = (TypeInformation<OUT>) createTypeInfoFromInput((TypeVariable<?>) returnType, typeHierarchy, in1Type, in2Type);\r\n        if (typeInfo != null) {\r\n            return typeInfo;\r\n        }\r\n    }\r\n        return (TypeInformation<OUT>) createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type);\r\n}","lc":-0.0454545455,"pi":0.2200956938,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":0.1071428571,"mi":-0.0449612403,"fo":-0.25,"r":-0.0263157895,"e":0.1563066568}
{"project_name":"Closure","project_version":"141","label":2,"code":"\/**\r\n * @param knownConstants A set of names known to be constant value at\r\n * node 'n' (such as locals that are last written before n can execute).\r\n * @return Whether the tree can be affected by side-effects or\r\n * has side-effects.\r\n *\/\r\nstatic boolean canBeSideEffected(Node n, Set<String> knownConstants) {\r\n    switch(n.getType()) {\r\n        case Token.CALL:\r\n        case Token.NEW:\r\n            \/\/ are unaffected by side effects.\r\n            return true;\r\n        case Token.NAME:\r\n            \/\/ Non-constant names values may have been changed.\r\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\r\n        \/\/ Properties on constant NAMEs can still be side-effected.\r\n        case Token.GETPROP:\r\n        case Token.GETELEM:\r\n            return true;\r\n    }\r\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\r\n        if (canBeSideEffected(c, knownConstants)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":"\/**\r\n * @param knownConstants A set of names known to be constant value at\r\n * node 'n' (such as locals that are last written before n can execute).\r\n * @return Whether the tree can be affected by side-effects or\r\n * has side-effects.\r\n *\/\r\n","code_no_comment":"static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\r\n    switch(n.getType()) {\r\n        case Token.CALL:\r\n        case Token.NEW:\r\n                        return true;\r\n        case Token.NAME:\r\n                        return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\r\n                case Token.GETPROP:\r\n        case Token.GETELEM:\r\n            return true;\r\n    }\r\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\r\n        if (canBeSideEffected(c, knownConstants)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","lc":0.1818181818,"pi":0.3540669856,"ma":0.8,"nbd":0.0,"ml":0.5,"d":0.3293650794,"mi":-0.191825229,"fo":0.0833333333,"r":0.0263157895,"e":0.2095560819}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3110_d10362c0","label":1,"code":"public Directory wrapForRead(String indexPath, IndexDefinition definition, Directory remote) throws IOException {\r\n    Directory local = createLocalDirForIndexReader(indexPath, definition);\r\n    return new CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath);\r\n}","code_comment":null,"code_no_comment":"public Directory wrapForRead(String indexPath, IndexDefinition definition, Directory remote) throws IOException {\r\n    Directory local = createLocalDirForIndexReader(indexPath, definition);\r\n    return new CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath);\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6958421424,"fo":-0.4166666667,"r":0.0,"e":-0.1627934049}
{"project_name":"Closure","project_version":"130","label":2,"code":"\/**\r\n * For each qualified name N in the global scope, we check if:\r\n * (a) No ancestor of N is ever aliased or assigned an unknown value type.\r\n *     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\r\n * (b) N has exactly one write, and it lives in the global scope.\r\n * (c) N is aliased in a local scope.\r\n *\r\n * If (a) is true, then GlobalNamespace must know all the writes to N.\r\n * If (a) and (b) are true, then N cannot change during the execution of\r\n *    a local scope.\r\n * If (a) and (b) and (c) are true, then the alias can be inlined if the\r\n *    alias obeys the usual rules for how we decide whether a variable is\r\n *    inlineable.\r\n * @see InlineVariables\r\n *\/\r\nprivate void inlineAliases(GlobalNamespace namespace) {\r\n    \/\/ Invariant: All the names in the worklist meet condition (a).\r\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\r\n    while (!workList.isEmpty()) {\r\n        Name name = workList.pop();\r\n        \/\/ Don't attempt to inline a getter or setter property as a variable.\r\n        if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\r\n            continue;\r\n        }\r\n        if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {\r\n            \/\/ {@code name} meets condition (b). Find all of its local aliases\r\n            \/\/ and try to inline them.\r\n            List<Ref> refs = Lists.newArrayList(name.getRefs());\r\n            for (Ref ref : refs) {\r\n                if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\r\n                    \/\/ {@code name} meets condition (c). Try to inline it.\r\n                    if (inlineAliasIfPossible(ref, namespace)) {\r\n                        name.removeRef(ref);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \/\/ local-alias-inlining above.\r\n        if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) {\r\n            \/\/ All of {@code name}'s children meet condition (a), so they can be\r\n            \/\/ added to the worklist.\r\n            workList.addAll(name.props);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * For each qualified name N in the global scope, we check if:\r\n * (a) No ancestor of N is ever aliased or assigned an unknown value type.\r\n *     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\r\n * (b) N has exactly one write, and it lives in the global scope.\r\n * (c) N is aliased in a local scope.\r\n *\r\n * If (a) is true, then GlobalNamespace must know all the writes to N.\r\n * If (a) and (b) are true, then N cannot change during the execution of\r\n *    a local scope.\r\n * If (a) and (b) and (c) are true, then the alias can be inlined if the\r\n *    alias obeys the usual rules for how we decide whether a variable is\r\n *    inlineable.\r\n * @see InlineVariables\r\n *\/\r\n","code_no_comment":"private void inlineAliases(GlobalNamespace namespace) {\r\n        Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\r\n    while (!workList.isEmpty()) {\r\n        Name name = workList.pop();\r\n                if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\r\n            continue;\r\n        }\r\n        if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {\r\n                                    List<Ref> refs = Lists.newArrayList(name.getRefs());\r\n            for (Ref ref : refs) {\r\n                if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\r\n                                        if (inlineAliasIfPossible(ref, namespace)) {\r\n                        name.removeRef(ref);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n                if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) {\r\n                                    workList.addAll(name.props);\r\n        }\r\n    }\r\n}","lc":0.3636363636,"pi":1.4976076555,"ma":1.0,"nbd":1.5,"ml":1.5833333333,"d":0.873015873,"mi":-0.4170542636,"fo":0.25,"r":-0.0263157895,"e":1.4163309763}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"@Override\r\npublic void write(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {\r\n    TTupleProtocol oprot = (TTupleProtocol) prot;\r\n    BitSet optionals = new BitSet();\r\n    if (struct.isSetOuch1()) {\r\n        optionals.set(0);\r\n    }\r\n    if (struct.isSetOuch2()) {\r\n        optionals.set(1);\r\n    }\r\n    oprot.writeBitSet(optionals, 2);\r\n    if (struct.isSetOuch1()) {\r\n        struct.ouch1.write(oprot);\r\n    }\r\n    if (struct.isSetOuch2()) {\r\n        struct.ouch2.write(oprot);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void write(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {\r\n    TTupleProtocol oprot = (TTupleProtocol) prot;\r\n    BitSet optionals = new BitSet();\r\n    if (struct.isSetOuch1()) {\r\n        optionals.set(0);\r\n    }\r\n    if (struct.isSetOuch2()) {\r\n        optionals.set(1);\r\n    }\r\n    oprot.writeBitSet(optionals, 2);\r\n    if (struct.isSetOuch1()) {\r\n        struct.ouch1.write(oprot);\r\n    }\r\n    if (struct.isSetOuch2()) {\r\n        struct.ouch2.write(oprot);\r\n    }\r\n}","lc":0.1818181818,"pi":-0.2440191388,"ma":0.2,"nbd":-0.5,"ml":0.0833333333,"d":-0.3650793651,"mi":-0.1749119098,"fo":0.25,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3280_295e73bd","label":1,"code":"\/**\r\n *  Processes components added to the target. This involves attaching components, rendering\r\n *  markup into a client side xml envelope, and detaching them\r\n *\r\n *  @param response\r\n *\/\r\nprivate void respondComponents(WebResponse response) {\r\n    \/\/ process component markup\r\n    for (Map.Entry<String, Component> stringComponentEntry : markupIdToComponent.entrySet()) {\r\n        final Component component = stringComponentEntry.getValue();\r\n        if (!containsAncestorFor(component)) {\r\n            respondComponent(response, getAjaxRegionMarkupId(component), component);\r\n        }\r\n    }\r\n    if (header != null) {\r\n        \/\/ some header responses buffer all calls to render*** until close is called.\r\n        \/\/ when they are closed, they do something (i.e. aggregate all JS resource urls to a\r\n        \/\/ single url), and then \"flush\" (by writing to the real response) before closing.\r\n        \/\/ to support this, we need to allow header contributions to be written in the close\r\n        \/\/ tag, which we do here:\r\n        headerRendering = true;\r\n        \/\/ save old response, set new\r\n        Response oldResponse = RequestCycle.get().setResponse(encodingHeaderResponse);\r\n        encodingHeaderResponse.reset();\r\n        \/\/ now, close the response (which may render things)\r\n        header.getHeaderResponse().close();\r\n        \/\/ revert to old response\r\n        RequestCycle.get().setResponse(oldResponse);\r\n        \/\/ write the XML tags and we're done\r\n        writeHeaderContribution(response);\r\n        headerRendering = false;\r\n    }\r\n}","code_comment":"\/**\r\n *  Processes components added to the target. This involves attaching components, rendering\r\n *  markup into a client side xml envelope, and detaching them\r\n *\r\n *  @param response\r\n *\/\r\n","code_no_comment":"private void respondComponents(WebResponse response) {\r\n        for (Map.Entry<String, Component> stringComponentEntry : markupIdToComponent.entrySet()) {\r\n        final Component component = stringComponentEntry.getValue();\r\n        if (!containsAncestorFor(component)) {\r\n            respondComponent(response, getAjaxRegionMarkupId(component), component);\r\n        }\r\n    }\r\n    if (header != null) {\r\n                                                headerRendering = true;\r\n                Response oldResponse = RequestCycle.get().setResponse(encodingHeaderResponse);\r\n        encodingHeaderResponse.reset();\r\n                header.getHeaderResponse().close();\r\n                RequestCycle.get().setResponse(oldResponse);\r\n                writeHeaderContribution(response);\r\n        headerRendering = false;\r\n    }\r\n}","lc":0.1363636364,"pi":0.04784689,"ma":0.0,"nbd":0.0,"ml":0.0,"d":-0.0773809524,"mi":-0.1568710359,"fo":0.5833333333,"r":-0.0263157895,"e":0.0108504348}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"public void update(String writer, Map<ByteBuffer, List<ColumnUpdate>> cells) throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException {\r\n    send_update(writer, cells);\r\n    recv_update();\r\n}","code_comment":null,"code_no_comment":"public void update(String writer, Map<ByteBuffer, List<ColumnUpdate>> cells) throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException {\r\n    send_update(writer, cells);\r\n    recv_update();\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7000704722,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5687_3d2d8619","label":1,"code":"public List<MavenProject> getUpstreamProjects(MavenProject project, boolean transitive) {\r\n    if (project == null) {\r\n        throw new IllegalArgumentException(\"project missing\");\r\n    }\r\n    Collection<String> projectIds = new HashSet<String>();\r\n    getUpstreamProjects(ProjectSorter.getId(project), projectIds, transitive);\r\n    return getProjects(projectIds);\r\n}","code_comment":null,"code_no_comment":"public List<MavenProject> getUpstreamProjects(MavenProject project, boolean transitive) {\r\n    if (project == null) {\r\n        throw new IllegalArgumentException(\"project missing\");\r\n    }\r\n    Collection<String> projectIds = new HashSet<String>();\r\n    getUpstreamProjects(ProjectSorter.getId(project), projectIds, transitive);\r\n    return getProjects(projectIds);\r\n}","lc":-0.2727272727,"pi":-0.2822966507,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0674603175,"mi":0.3217758985,"fo":-0.25,"r":0.1052631579,"e":-0.0878154481}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-1619_b154d12f","label":1,"code":"\/**\r\n *  Create a new PagingNavigation. May be subclassed to make us of specialized PagingNavigation.\r\n *\r\n *  @param pageable\r\n *             the pageable component\r\n *  @param labelProvider\r\n *             The label provider for the link text.\r\n *  @return the navigation object\r\n *\/\r\nprotected PagingNavigation newNavigation(final IPageable pageable, final IPagingLabelProvider labelProvider) {\r\n    return new PagingNavigation(\"navigation\", pageable, labelProvider) {\r\n\r\n        private static final long serialVersionUID = 1L;\r\n\r\n        @Override\r\n        public boolean isEnabled() {\r\n            return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\r\n        }\r\n    };\r\n}","code_comment":"\/**\r\n *  Create a new PagingNavigation. May be subclassed to make us of specialized PagingNavigation.\r\n *\r\n *  @param pageable\r\n *             the pageable component\r\n *  @param labelProvider\r\n *             The label provider for the link text.\r\n *  @return the navigation object\r\n *\/\r\n","code_no_comment":"protected PagingNavigation newNavigation(final IPageable pageable, final IPagingLabelProvider labelProvider) {\r\n    return new PagingNavigation(\"navigation\", pageable, labelProvider) {\r\n\r\n        private static final long serialVersionUID = 1L;\r\n\r\n        @Override\r\n        public boolean isEnabled() {\r\n            return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\r\n        }\r\n    };\r\n}","lc":-0.2272727273,"pi":0.3971291866,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.0952380952,"mi":0.318111346,"fo":-0.3333333333,"r":2.1315789474,"e":-0.1102355307}
{"project_name":"Lang","project_version":"52","label":3,"code":"\/**\r\n * <p>Worker method for the {@link #escapeJavaScript(String)} method.<\/p>\r\n *\r\n * @param out write to receieve the escaped string\r\n * @param str String to escape values in, may be null\r\n * @param escapeSingleQuote escapes single quotes if <code>true<\/code>\r\n * @throws IOException if an IOException occurs\r\n *\/\r\nprivate static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\r\n    if (out == null) {\r\n        throw new IllegalArgumentException(\"The Writer must not be null\");\r\n    }\r\n    if (str == null) {\r\n        return;\r\n    }\r\n    int sz;\r\n    sz = str.length();\r\n    for (int i = 0; i < sz; i++) {\r\n        char ch = str.charAt(i);\r\n        \/\/ handle unicode\r\n        if (ch > 0xfff) {\r\n            out.write(\"\\\\u\" + hex(ch));\r\n        } else if (ch > 0xff) {\r\n            out.write(\"\\\\u0\" + hex(ch));\r\n        } else if (ch > 0x7f) {\r\n            out.write(\"\\\\u00\" + hex(ch));\r\n        } else if (ch < 32) {\r\n            switch(ch) {\r\n                case '\\b':\r\n                    out.write('\\\\');\r\n                    out.write('b');\r\n                    break;\r\n                case '\\n':\r\n                    out.write('\\\\');\r\n                    out.write('n');\r\n                    break;\r\n                case '\\t':\r\n                    out.write('\\\\');\r\n                    out.write('t');\r\n                    break;\r\n                case '\\f':\r\n                    out.write('\\\\');\r\n                    out.write('f');\r\n                    break;\r\n                case '\\r':\r\n                    out.write('\\\\');\r\n                    out.write('r');\r\n                    break;\r\n                default:\r\n                    if (ch > 0xf) {\r\n                        out.write(\"\\\\u00\" + hex(ch));\r\n                    } else {\r\n                        out.write(\"\\\\u000\" + hex(ch));\r\n                    }\r\n                    break;\r\n            }\r\n        } else {\r\n            switch(ch) {\r\n                case '\\'':\r\n                    if (escapeSingleQuote) {\r\n                        out.write('\\\\');\r\n                    }\r\n                    out.write('\\'');\r\n                    break;\r\n                case '\"':\r\n                    out.write('\\\\');\r\n                    out.write('\"');\r\n                    break;\r\n                case '\\\\':\r\n                    out.write('\\\\');\r\n                    out.write('\\\\');\r\n                    break;\r\n                default:\r\n                    out.write(ch);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * <p>Worker method for the {@link #escapeJavaScript(String)} method.<\/p>\r\n *\r\n * @param out write to receieve the escaped string\r\n * @param str String to escape values in, may be null\r\n * @param escapeSingleQuote escapes single quotes if <code>true<\/code>\r\n * @throws IOException if an IOException occurs\r\n *\/\r\n","code_no_comment":"private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\r\n    if (out == null) {\r\n        throw new IllegalArgumentException(\"The Writer must not be null\");\r\n    }\r\n    if (str == null) {\r\n        return;\r\n    }\r\n    int sz;\r\n    sz = str.length();\r\n    for (int i = 0; i < sz; i++) {\r\n        char ch = str.charAt(i);\r\n                if (ch > 0xfff) {\r\n            out.write(\"\\\\u\" + hex(ch));\r\n        } else if (ch > 0xff) {\r\n            out.write(\"\\\\u0\" + hex(ch));\r\n        } else if (ch > 0x7f) {\r\n            out.write(\"\\\\u00\" + hex(ch));\r\n        } else if (ch < 32) {\r\n            switch(ch) {\r\n                case '\\b':\r\n                    out.write('\\\\');\r\n                    out.write('b');\r\n                    break;\r\n                case '\\n':\r\n                    out.write('\\\\');\r\n                    out.write('n');\r\n                    break;\r\n                case '\\t':\r\n                    out.write('\\\\');\r\n                    out.write('t');\r\n                    break;\r\n                case '\\f':\r\n                    out.write('\\\\');\r\n                    out.write('f');\r\n                    break;\r\n                case '\\r':\r\n                    out.write('\\\\');\r\n                    out.write('r');\r\n                    break;\r\n                default:\r\n                    if (ch > 0xf) {\r\n                        out.write(\"\\\\u00\" + hex(ch));\r\n                    } else {\r\n                        out.write(\"\\\\u000\" + hex(ch));\r\n                    }\r\n                    break;\r\n            }\r\n        } else {\r\n            switch(ch) {\r\n                case '\\'':\r\n                    if (escapeSingleQuote) {\r\n                        out.write('\\\\');\r\n                    }\r\n                    out.write('\\'');\r\n                    break;\r\n                case '\"':\r\n                    out.write('\\\\');\r\n                    out.write('\"');\r\n                    break;\r\n                case '\\\\':\r\n                    out.write('\\\\');\r\n                    out.write('\\\\');\r\n                    break;\r\n                default:\r\n                    out.write(ch);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}","lc":2.5454545455,"pi":1.6746411483,"ma":5.4,"nbd":3.0,"ml":1.5,"d":1.4345238095,"mi":-1.1403805497,"fo":1.9166666667,"r":-0.0263157895,"e":3.1133509679}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4927_8c827e33","label":1,"code":"@Override\r\npublic void write(CharSequence sequence) {\r\n    writeBuffered();\r\n    originalResponse.write(sequence);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void write(CharSequence sequence) {\r\n    writeBuffered();\r\n    originalResponse.write(sequence);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7626497533,"fo":-0.3333333333,"r":1.3947368421,"e":-0.1627934049}
{"project_name":"Math","project_version":"32","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected void computeGeometricalProperties() {\r\n    final Vector2D[][] v = getVertices();\r\n    if (v.length == 0) {\r\n        final BSPTree<Euclidean2D> tree = getTree(false);\r\n        if ((Boolean) tree.getAttribute()) {\r\n            \/\/ the instance covers the whole space\r\n            setSize(Double.POSITIVE_INFINITY);\r\n            setBarycenter(Vector2D.NaN);\r\n        } else {\r\n            setSize(0);\r\n            setBarycenter(new Vector2D(0, 0));\r\n        }\r\n    } else if (v[0][0] == null) {\r\n        \/\/ there is at least one open-loop: the polygon is infinite\r\n        setSize(Double.POSITIVE_INFINITY);\r\n        setBarycenter(Vector2D.NaN);\r\n    } else {\r\n        \/\/ all loops are closed, we compute some integrals around the shape\r\n        double sum = 0;\r\n        double sumX = 0;\r\n        double sumY = 0;\r\n        for (Vector2D[] loop : v) {\r\n            double x1 = loop[loop.length - 1].getX();\r\n            double y1 = loop[loop.length - 1].getY();\r\n            for (final Vector2D point : loop) {\r\n                final double x0 = x1;\r\n                final double y0 = y1;\r\n                x1 = point.getX();\r\n                y1 = point.getY();\r\n                final double factor = x0 * y1 - y0 * x1;\r\n                sum += factor;\r\n                sumX += factor * (x0 + x1);\r\n                sumY += factor * (y0 + y1);\r\n            }\r\n        }\r\n        if (sum < 0) {\r\n            \/\/ the polygon as a finite outside surrounded by an infinite inside\r\n            setSize(Double.POSITIVE_INFINITY);\r\n            setBarycenter(Vector2D.NaN);\r\n        } else {\r\n            setSize(sum \/ 2);\r\n            setBarycenter(new Vector2D(sumX \/ (3 * sum), sumY \/ (3 * sum)));\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void computeGeometricalProperties() {\r\n    final Vector2D[][] v = getVertices();\r\n    if (v.length == 0) {\r\n        final BSPTree<Euclidean2D> tree = getTree(false);\r\n        if ((Boolean) tree.getAttribute()) {\r\n                        setSize(Double.POSITIVE_INFINITY);\r\n            setBarycenter(Vector2D.NaN);\r\n        } else {\r\n            setSize(0);\r\n            setBarycenter(new Vector2D(0, 0));\r\n        }\r\n    } else if (v[0][0] == null) {\r\n                setSize(Double.POSITIVE_INFINITY);\r\n        setBarycenter(Vector2D.NaN);\r\n    } else {\r\n                double sum = 0;\r\n        double sumX = 0;\r\n        double sumY = 0;\r\n        for (Vector2D[] loop : v) {\r\n            double x1 = loop[loop.length - 1].getX();\r\n            double y1 = loop[loop.length - 1].getY();\r\n            for (final Vector2D point : loop) {\r\n                final double x0 = x1;\r\n                final double y0 = y1;\r\n                x1 = point.getX();\r\n                y1 = point.getY();\r\n                final double factor = x0 * y1 - y0 * x1;\r\n                sum += factor;\r\n                sumX += factor * (x0 + x1);\r\n                sumY += factor * (y0 + y1);\r\n            }\r\n        }\r\n        if (sum < 0) {\r\n                        setSize(Double.POSITIVE_INFINITY);\r\n            setBarycenter(Vector2D.NaN);\r\n        } else {\r\n            setSize(sum \/ 2);\r\n            setBarycenter(new Vector2D(sumX \/ (3 * sum), sumY \/ (3 * sum)));\r\n        }\r\n    }\r\n}","lc":1.2727272727,"pi":0.7416267943,"ma":0.6,"nbd":1.0,"ml":0.0833333333,"d":1.994047619,"mi":-0.7468639887,"fo":0.9166666667,"r":-0.0263157895,"e":3.9966598088}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4138_eb0f9b41","label":1,"code":"public static Option startRowOpt() {\r\n    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (inclusive)\");\r\n    o.setArgName(\"begin-row\");\r\n    return o;\r\n}","code_comment":null,"code_no_comment":"public static Option startRowOpt() {\r\n    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (inclusive)\");\r\n    o.setArgName(\"begin-row\");\r\n    return o;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6631430585,"fo":-0.4166666667,"r":0.3157894737,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1348_6ff92b12","label":1,"code":"public int start() throws IOException {\r\n    if (configError)\r\n        return 1;\r\n    String input;\r\n    if (isVerbose())\r\n        printInfo();\r\n    if (execFile != null) {\r\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\r\n        while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());\r\n    } else if (execCommand != null) {\r\n        for (String command : execCommand.split(\"\\n\")) {\r\n            execCommand(command, true, isVerbose());\r\n        }\r\n        return exitCode;\r\n    }\r\n    while (true) {\r\n        if (hasExited())\r\n            return exitCode;\r\n        reader.setDefaultPrompt(getDefaultPrompt());\r\n        input = reader.readLine();\r\n        if (input == null) {\r\n            reader.printNewline();\r\n            return exitCode;\r\n        }\r\n        \/\/ user canceled\r\n        execCommand(input, false, false);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public int start() throws IOException {\r\n    if (configError)\r\n        return 1;\r\n    String input;\r\n    if (isVerbose())\r\n        printInfo();\r\n    if (execFile != null) {\r\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\r\n        while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());\r\n    } else if (execCommand != null) {\r\n        for (String command : execCommand.split(\"\\n\")) {\r\n            execCommand(command, true, isVerbose());\r\n        }\r\n        return exitCode;\r\n    }\r\n    while (true) {\r\n        if (hasExited())\r\n            return exitCode;\r\n        reader.setDefaultPrompt(getDefaultPrompt());\r\n        input = reader.readLine();\r\n        if (input == null) {\r\n            reader.printNewline();\r\n            return exitCode;\r\n        }\r\n                execCommand(input, false, false);\r\n    }\r\n}","lc":0.5909090909,"pi":0.1148325359,"ma":1.2,"nbd":0.5,"ml":0.8333333333,"d":0.0,"mi":-0.4356589147,"fo":0.75,"r":-0.0263157895,"e":0.1045924748}
{"project_name":"Math","project_version":"76","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic RealMatrix getV() throws InvalidMatrixException {\r\n    if (cachedV == null) {\r\n        final int p = singularValues.length;\r\n        if (m >= n) {\r\n            \/\/ the tridiagonal matrix is Bt.B, where B is upper bidiagonal\r\n            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\r\n            cachedV = transformer.getV().multiply(e);\r\n        } else {\r\n            \/\/ the tridiagonal matrix is B.Bt, where B is lower bidiagonal\r\n            \/\/ compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\r\n            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\r\n            final double[][] eData = e.getData();\r\n            final double[][] wData = new double[n][p];\r\n            double[] ei1 = eData[0];\r\n            for (int i = 0; i < p - 1; ++i) {\r\n                final double mi = mainBidiagonal[i];\r\n                final double[] ei0 = ei1;\r\n                final double[] wi = wData[i];\r\n                ei1 = eData[i + 1];\r\n                final double si = secondaryBidiagonal[i];\r\n                for (int j = 0; j < p; ++j) {\r\n                    wi[j] = (mi * ei0[j] + si * ei1[j]) \/ singularValues[j];\r\n                }\r\n            }\r\n            for (int j = 0; j < p; ++j) {\r\n                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] \/ singularValues[j];\r\n            }\r\n            for (int i = p; i < n; ++i) {\r\n                wData[i] = new double[p];\r\n            }\r\n            cachedV = transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\r\n        }\r\n    }\r\n    \/\/ return the cached matrix\r\n    return cachedV;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public RealMatrix getV() throws InvalidMatrixException {\r\n    if (cachedV == null) {\r\n        final int p = singularValues.length;\r\n        if (m >= n) {\r\n                        final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\r\n            cachedV = transformer.getV().multiply(e);\r\n        } else {\r\n                                    final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\r\n            final double[][] eData = e.getData();\r\n            final double[][] wData = new double[n][p];\r\n            double[] ei1 = eData[0];\r\n            for (int i = 0; i < p - 1; ++i) {\r\n                final double mi = mainBidiagonal[i];\r\n                final double[] ei0 = ei1;\r\n                final double[] wi = wData[i];\r\n                ei1 = eData[i + 1];\r\n                final double si = secondaryBidiagonal[i];\r\n                for (int j = 0; j < p; ++j) {\r\n                    wi[j] = (mi * ei0[j] + si * ei1[j]) \/ singularValues[j];\r\n                }\r\n            }\r\n            for (int j = 0; j < p; ++j) {\r\n                wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] \/ singularValues[j];\r\n            }\r\n            for (int i = p; i < n; ++i) {\r\n                wData[i] = new double[p];\r\n            }\r\n            cachedV = transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\r\n        }\r\n    }\r\n        return cachedV;\r\n}","lc":0.8181818182,"pi":0.8708133971,"ma":0.6,"nbd":1.0,"ml":0.5833333333,"d":2.4880952381,"mi":-0.6394644116,"fo":0.3333333333,"r":-0.0263157895,"e":5.4827290907}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1437_fb7ce0e3","label":1,"code":"@Override\r\npublic T copy(T from, T reuse) {\r\n    try {\r\n        for (int i = 0; i < numFields; i++) {\r\n            Object copy = fieldSerializers[i].copy(fields[i].get(from), fields[i].get(reuse));\r\n            fields[i].set(reuse, copy);\r\n        }\r\n    } catch (IllegalAccessException e) {\r\n        throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\r\n    }\r\n    return reuse;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic T copy(T from, T reuse) {\r\n    try {\r\n        for (int i = 0; i < numFields; i++) {\r\n            Object copy = fieldSerializers[i].copy(fields[i].get(from), fields[i].get(reuse));\r\n            fields[i].set(reuse, copy);\r\n        }\r\n    } catch (IllegalAccessException e) {\r\n        throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\r\n    }\r\n    return reuse;\r\n}","lc":-0.0909090909,"pi":0.5358851675,"ma":0.0,"nbd":0.0,"ml":-0.1666666667,"d":0.4067460317,"mi":0.0477801268,"fo":-0.1666666667,"r":0.0,"e":0.1783533019}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"@Override\r\npublic NodeStateBuilder addNode(String name) {\r\n    if (hasChild(name)) {\r\n        return null;\r\n    } else {\r\n        String targetPath = PathUtils.concat(path, name);\r\n        context.addNode(targetPath);\r\n        return new KernelNodeStateBuilder(context, targetPath);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic NodeStateBuilder addNode(String name) {\r\n    if (hasChild(name)) {\r\n        return null;\r\n    } else {\r\n        String targetPath = PathUtils.concat(path, name);\r\n        context.addNode(targetPath);\r\n        return new KernelNodeStateBuilder(context, targetPath);\r\n    }\r\n}","lc":-0.1818181818,"pi":0.1578947368,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.260324172,"fo":-0.25,"r":0.5789473684,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"@Override\r\npublic boolean removeNode(String name) {\r\n    if (hasChild(name)) {\r\n        context.removeNode(PathUtils.concat(path, name));\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean removeNode(String name) {\r\n    if (hasChild(name)) {\r\n        context.removeNode(PathUtils.concat(path, name));\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}","lc":-0.2272727273,"pi":0.1339712919,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.3770260747,"fo":-0.25,"r":0.7894736842,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3077_17654199","label":0,"code":"\/**\r\n * Gets this class's ZooKeeper reader\/writer.\r\n *\r\n * @return reader\/writer\r\n *\/\r\nstatic IZooReaderWriter getZooReaderWriter() {\r\n    return zoo;\r\n}","code_comment":"\/**\r\n * Gets this class's ZooKeeper reader\/writer.\r\n *\r\n * @return reader\/writer\r\n *\/\r\n","code_no_comment":"static IZooReaderWriter getZooReaderWriter() {\r\n    return zoo;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1646229739,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"Cli","project_version":"21","label":1,"code":"\/**\r\n * Helper method for testing whether an element of the command line looks\r\n * like an option. This method queries the command line, but sets the\r\n * current option first.\r\n *\r\n * @param commandLine the command line\r\n * @param trigger the trigger to be checked\r\n * @return a flag whether this element looks like an option\r\n *\/\r\nprivate boolean looksLikeOption(final WriteableCommandLine commandLine, final String trigger) {\r\n    return commandLine.looksLikeOption(trigger);\r\n}","code_comment":"\/**\r\n * Helper method for testing whether an element of the command line looks\r\n * like an option. This method queries the command line, but sets the\r\n * current option first.\r\n *\r\n * @param commandLine the command line\r\n * @param trigger the trigger to be checked\r\n * @return a flag whether this element looks like an option\r\n *\/\r\n","code_no_comment":"private boolean looksLikeOption(final WriteableCommandLine commandLine, final String trigger) {\r\n    return commandLine.looksLikeOption(trigger);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.008174771,"fo":-0.4166666667,"r":2.5,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"@Override\r\npublic void closeWriter(String writer) throws TException {\r\n    try {\r\n        BatchWriter batchwriter = writerCache.getIfPresent(UUID.fromString(writer));\r\n        if (batchwriter == null) {\r\n            throw new UnknownWriter(\"Writer never existed or no longer exists\");\r\n        }\r\n        batchwriter.close();\r\n        writerCache.invalidate(UUID.fromString(writer));\r\n    } catch (Exception e) {\r\n        throw translateException(e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void closeWriter(String writer) throws TException {\r\n    try {\r\n        BatchWriter batchwriter = writerCache.getIfPresent(UUID.fromString(writer));\r\n        if (batchwriter == null) {\r\n            throw new UnknownWriter(\"Writer never existed or no longer exists\");\r\n        }\r\n        batchwriter.close();\r\n        writerCache.invalidate(UUID.fromString(writer));\r\n    } catch (Exception e) {\r\n        throw translateException(e);\r\n    }\r\n}","lc":-0.0454545455,"pi":0.3349282297,"ma":0.2,"nbd":0.0,"ml":-0.25,"d":-0.0873015873,"mi":0.0562367865,"fo":0.0,"r":0.5789473684,"e":-0.0764417397}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5853_b80f6640","label":3,"code":"\/**\r\n *  Creates a new {@link NumberFormat} for the given locale. The instance is later cached and is\r\n *  accessible through {@link #getNumberFormat(Locale)}\r\n *\r\n *  @param locale\r\n *  @return number format\r\n *\/\r\nprotected NumberFormat newNumberFormat(final Locale locale) {\r\n    return NumberFormat.getInstance(locale);\r\n}","code_comment":"\/**\r\n *  Creates a new {@link NumberFormat} for the given locale. The instance is later cached and is\r\n *  accessible through {@link #getNumberFormat(Locale)}\r\n *\r\n *  @param locale\r\n *  @return number format\r\n *\/\r\n","code_no_comment":"protected NumberFormat newNumberFormat(final Locale locale) {\r\n    return NumberFormat.getInstance(locale);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0253699789,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-867_bfbb156d","label":1,"code":"\/**\r\n * Checks dimensions and values of boundaries and inputSigma if defined.\r\n *\/\r\nprivate void checkParameters() {\r\n    final double[] init = getStartPoint();\r\n    final double[] lB = getLowerBound();\r\n    final double[] uB = getUpperBound();\r\n    \/\/ Checks whether there is at least one finite bound value.\r\n    boolean hasFiniteBounds = false;\r\n    for (int i = 0; i < lB.length; i++) {\r\n        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\r\n            hasFiniteBounds = true;\r\n            break;\r\n        }\r\n    }\r\n    \/\/ Checks whether there is at least one infinite bound value.\r\n    boolean hasInfiniteBounds = false;\r\n    if (hasFiniteBounds) {\r\n        for (int i = 0; i < lB.length; i++) {\r\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\r\n                hasInfiniteBounds = true;\r\n                break;\r\n            }\r\n        }\r\n        if (hasInfiniteBounds) {\r\n            \/\/ because mixed cases are not supported by the current code.\r\n            throw new MathUnsupportedOperationException();\r\n        } else {\r\n            \/\/ Convert API to internal handling of boundaries.\r\n            boundaries = new double[2][];\r\n            boundaries[0] = lB;\r\n            boundaries[1] = uB;\r\n            \/\/ Abort early if the normalization will overflow (cf. \"encode\" method).\r\n            for (int i = 0; i < lB.length; i++) {\r\n                if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\r\n                    final double max = Double.MAX_VALUE + boundaries[0][i];\r\n                    final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true);\r\n                    e.getContext().addMessage(LocalizedFormats.OVERFLOW);\r\n                    e.getContext().addMessage(LocalizedFormats.INDEX, i);\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        \/\/ Convert API to internal handling of boundaries.\r\n        boundaries = null;\r\n    }\r\n    if (inputSigma != null) {\r\n        if (inputSigma.length != init.length) {\r\n            throw new DimensionMismatchException(inputSigma.length, init.length);\r\n        }\r\n        for (int i = 0; i < init.length; i++) {\r\n            if (inputSigma[i] < 0) {\r\n                throw new NotPositiveException(inputSigma[i]);\r\n            }\r\n            if (boundaries != null) {\r\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\r\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Checks dimensions and values of boundaries and inputSigma if defined.\r\n *\/\r\n","code_no_comment":"private void checkParameters() {\r\n    final double[] init = getStartPoint();\r\n    final double[] lB = getLowerBound();\r\n    final double[] uB = getUpperBound();\r\n        boolean hasFiniteBounds = false;\r\n    for (int i = 0; i < lB.length; i++) {\r\n        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\r\n            hasFiniteBounds = true;\r\n            break;\r\n        }\r\n    }\r\n        boolean hasInfiniteBounds = false;\r\n    if (hasFiniteBounds) {\r\n        for (int i = 0; i < lB.length; i++) {\r\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\r\n                hasInfiniteBounds = true;\r\n                break;\r\n            }\r\n        }\r\n        if (hasInfiniteBounds) {\r\n                        throw new MathUnsupportedOperationException();\r\n        } else {\r\n                        boundaries = new double[2][];\r\n            boundaries[0] = lB;\r\n            boundaries[1] = uB;\r\n                        for (int i = 0; i < lB.length; i++) {\r\n                if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\r\n                    final double max = Double.MAX_VALUE + boundaries[0][i];\r\n                    final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true);\r\n                    e.getContext().addMessage(LocalizedFormats.OVERFLOW);\r\n                    e.getContext().addMessage(LocalizedFormats.INDEX, i);\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n                boundaries = null;\r\n    }\r\n    if (inputSigma != null) {\r\n        if (inputSigma.length != init.length) {\r\n            throw new DimensionMismatchException(inputSigma.length, init.length);\r\n        }\r\n        for (int i = 0; i < init.length; i++) {\r\n            if (inputSigma[i] < 0) {\r\n                throw new NotPositiveException(inputSigma[i]);\r\n            }\r\n            if (boundaries != null) {\r\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\r\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","lc":1.8181818182,"pi":1.1626794258,"ma":3.6,"nbd":1.0,"ml":1.8333333333,"d":2.8095238095,"mi":-0.9949260042,"fo":0.5,"r":-0.0263157895,"e":7.0055750535}
{"project_name":"Math","project_version":"24","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected UnivariatePointValuePair doOptimize() {\r\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\r\n    final double lo = getMin();\r\n    final double mid = getStartValue();\r\n    final double hi = getMax();\r\n    \/\/ Optional additional convergence criteria.\r\n    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\r\n    double a;\r\n    double b;\r\n    if (lo < hi) {\r\n        a = lo;\r\n        b = hi;\r\n    } else {\r\n        a = hi;\r\n        b = lo;\r\n    }\r\n    double x = mid;\r\n    double v = x;\r\n    double w = x;\r\n    double d = 0;\r\n    double e = 0;\r\n    double fx = computeObjectiveValue(x);\r\n    if (!isMinim) {\r\n        fx = -fx;\r\n    }\r\n    double fv = fx;\r\n    double fw = fx;\r\n    UnivariatePointValuePair previous = null;\r\n    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\r\n    int iter = 0;\r\n    while (true) {\r\n        final double m = 0.5 * (a + b);\r\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\r\n        final double tol2 = 2 * tol1;\r\n        \/\/ Default stopping criterion.\r\n        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\r\n        if (!stop) {\r\n            double p = 0;\r\n            double q = 0;\r\n            double r = 0;\r\n            double u = 0;\r\n            if (FastMath.abs(e) > tol1) {\r\n                \/\/ Fit parabola.\r\n                r = (x - w) * (fx - fv);\r\n                q = (x - v) * (fx - fw);\r\n                p = (x - v) * q - (x - w) * r;\r\n                q = 2 * (q - r);\r\n                if (q > 0) {\r\n                    p = -p;\r\n                } else {\r\n                    q = -q;\r\n                }\r\n                r = e;\r\n                e = d;\r\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\r\n                    \/\/ Parabolic interpolation step.\r\n                    d = p \/ q;\r\n                    u = x + d;\r\n                    \/\/ f must not be evaluated too close to a or b.\r\n                    if (u - a < tol2 || b - u < tol2) {\r\n                        if (x <= m) {\r\n                            d = tol1;\r\n                        } else {\r\n                            d = -tol1;\r\n                        }\r\n                    }\r\n                } else {\r\n                    \/\/ Golden section step.\r\n                    if (x < m) {\r\n                        e = b - x;\r\n                    } else {\r\n                        e = a - x;\r\n                    }\r\n                    d = GOLDEN_SECTION * e;\r\n                }\r\n            } else {\r\n                \/\/ Golden section step.\r\n                if (x < m) {\r\n                    e = b - x;\r\n                } else {\r\n                    e = a - x;\r\n                }\r\n                d = GOLDEN_SECTION * e;\r\n            }\r\n            \/\/ Update by at least \"tol1\".\r\n            if (FastMath.abs(d) < tol1) {\r\n                if (d >= 0) {\r\n                    u = x + tol1;\r\n                } else {\r\n                    u = x - tol1;\r\n                }\r\n            } else {\r\n                u = x + d;\r\n            }\r\n            double fu = computeObjectiveValue(u);\r\n            if (!isMinim) {\r\n                fu = -fu;\r\n            }\r\n            \/\/ User-defined convergence checker.\r\n            previous = current;\r\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\r\n            if (checker != null) {\r\n                if (checker.converged(iter, previous, current)) {\r\n                    return current;\r\n                }\r\n            }\r\n            \/\/ Update a, b, v, w and x.\r\n            if (fu <= fx) {\r\n                if (u < x) {\r\n                    b = x;\r\n                } else {\r\n                    a = x;\r\n                }\r\n                v = w;\r\n                fv = fw;\r\n                w = x;\r\n                fw = fx;\r\n                x = u;\r\n                fx = fu;\r\n            } else {\r\n                if (u < x) {\r\n                    a = u;\r\n                } else {\r\n                    b = u;\r\n                }\r\n                if (fu <= fw || Precision.equals(w, x)) {\r\n                    v = w;\r\n                    fv = fw;\r\n                    w = u;\r\n                    fw = fu;\r\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\r\n                    v = u;\r\n                    fv = fu;\r\n                }\r\n            }\r\n        } else {\r\n            \/\/ Default termination (Brent's criterion).\r\n            return current;\r\n        }\r\n        ++iter;\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected UnivariatePointValuePair doOptimize() {\r\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\r\n    final double lo = getMin();\r\n    final double mid = getStartValue();\r\n    final double hi = getMax();\r\n        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\r\n    double a;\r\n    double b;\r\n    if (lo < hi) {\r\n        a = lo;\r\n        b = hi;\r\n    } else {\r\n        a = hi;\r\n        b = lo;\r\n    }\r\n    double x = mid;\r\n    double v = x;\r\n    double w = x;\r\n    double d = 0;\r\n    double e = 0;\r\n    double fx = computeObjectiveValue(x);\r\n    if (!isMinim) {\r\n        fx = -fx;\r\n    }\r\n    double fv = fx;\r\n    double fw = fx;\r\n    UnivariatePointValuePair previous = null;\r\n    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\r\n    int iter = 0;\r\n    while (true) {\r\n        final double m = 0.5 * (a + b);\r\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\r\n        final double tol2 = 2 * tol1;\r\n                final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\r\n        if (!stop) {\r\n            double p = 0;\r\n            double q = 0;\r\n            double r = 0;\r\n            double u = 0;\r\n            if (FastMath.abs(e) > tol1) {\r\n                                r = (x - w) * (fx - fv);\r\n                q = (x - v) * (fx - fw);\r\n                p = (x - v) * q - (x - w) * r;\r\n                q = 2 * (q - r);\r\n                if (q > 0) {\r\n                    p = -p;\r\n                } else {\r\n                    q = -q;\r\n                }\r\n                r = e;\r\n                e = d;\r\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\r\n                                        d = p \/ q;\r\n                    u = x + d;\r\n                                        if (u - a < tol2 || b - u < tol2) {\r\n                        if (x <= m) {\r\n                            d = tol1;\r\n                        } else {\r\n                            d = -tol1;\r\n                        }\r\n                    }\r\n                } else {\r\n                                        if (x < m) {\r\n                        e = b - x;\r\n                    } else {\r\n                        e = a - x;\r\n                    }\r\n                    d = GOLDEN_SECTION * e;\r\n                }\r\n            } else {\r\n                                if (x < m) {\r\n                    e = b - x;\r\n                } else {\r\n                    e = a - x;\r\n                }\r\n                d = GOLDEN_SECTION * e;\r\n            }\r\n                        if (FastMath.abs(d) < tol1) {\r\n                if (d >= 0) {\r\n                    u = x + tol1;\r\n                } else {\r\n                    u = x - tol1;\r\n                }\r\n            } else {\r\n                u = x + d;\r\n            }\r\n            double fu = computeObjectiveValue(u);\r\n            if (!isMinim) {\r\n                fu = -fu;\r\n            }\r\n                        previous = current;\r\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\r\n            if (checker != null) {\r\n                if (checker.converged(iter, previous, current)) {\r\n                    return current;\r\n                }\r\n            }\r\n                        if (fu <= fx) {\r\n                if (u < x) {\r\n                    b = x;\r\n                } else {\r\n                    a = x;\r\n                }\r\n                v = w;\r\n                fv = fw;\r\n                w = x;\r\n                fw = fx;\r\n                x = u;\r\n                fx = fu;\r\n            } else {\r\n                if (u < x) {\r\n                    a = u;\r\n                } else {\r\n                    b = u;\r\n                }\r\n                if (fu <= fw || Precision.equals(w, x)) {\r\n                    v = w;\r\n                    fv = fw;\r\n                    w = u;\r\n                    fw = fu;\r\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\r\n                    v = u;\r\n                    fv = fu;\r\n                }\r\n            }\r\n        } else {\r\n                        return current;\r\n        }\r\n        ++iter;\r\n    }\r\n}","lc":5.3636363636,"pi":1.6555023923,"ma":4.0,"nbd":2.0,"ml":4.8333333333,"d":6.9206349206,"mi":-1.5601127555,"fo":0.9166666667,"r":-0.0263157895,"e":43.7353180846}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-4011_cbffff59","label":3,"code":"\/**\r\n * Returns the converted value, or null if the value is null\r\n *\/\r\n@Converter\r\npublic static Integer toInteger(Object value) {\r\n    if (value instanceof Integer) {\r\n        return (Integer) value;\r\n    } else if (value instanceof Number) {\r\n        Number number = (Number) value;\r\n        return number.intValue();\r\n    } else if (value instanceof String) {\r\n        return Integer.valueOf((String) value);\r\n    } else {\r\n        return null;\r\n    }\r\n}","code_comment":"\/**\r\n * Returns the converted value, or null if the value is null\r\n *\/\r\n","code_no_comment":"@Converter\r\npublic static Integer toInteger(Object value) {\r\n    if (value instanceof Integer) {\r\n        return (Integer) value;\r\n    } else if (value instanceof Number) {\r\n        Number number = (Number) value;\r\n        return number.intValue();\r\n    } else if (value instanceof String) {\r\n        return Integer.valueOf((String) value);\r\n    } else {\r\n        return null;\r\n    }\r\n}","lc":-0.0454545455,"pi":0.043062201,"ma":0.0,"nbd":0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.1109231853,"fo":-0.3333333333,"r":0.1315789474,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-843_65390f8c","label":3,"code":"@Override\r\npublic void compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {\r\n    throw new NotImplementedException();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {\r\n    throw new NotImplementedException();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.4,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7014799154,"fo":-0.5,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-434_133cbc2d","label":1,"code":"\/**\r\n * Solves Phase 1 of the Simplex method.\r\n * @param tableau simple tableau for the problem\r\n * @exception OptimizationException if the maximal number of iterations is\r\n * exceeded, or if the problem is found not to have a bounded solution, or\r\n * if there is no feasible solution\r\n *\/\r\nprotected void solvePhase1(final SimplexTableau tableau) throws OptimizationException {\r\n    \/\/ make sure we're in Phase 1\r\n    if (tableau.getNumArtificialVariables() == 0) {\r\n        return;\r\n    }\r\n    while (!tableau.isOptimal()) {\r\n        doIteration(tableau);\r\n    }\r\n    \/\/ if W is not zero then we have no feasible solution\r\n    if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {\r\n        throw new NoFeasibleSolutionException();\r\n    }\r\n}","code_comment":"\/**\r\n * Solves Phase 1 of the Simplex method.\r\n * @param tableau simple tableau for the problem\r\n * @exception OptimizationException if the maximal number of iterations is\r\n * exceeded, or if the problem is found not to have a bounded solution, or\r\n * if there is no feasible solution\r\n *\/\r\n","code_no_comment":"protected void solvePhase1(final SimplexTableau tableau) throws OptimizationException {\r\n        if (tableau.getNumArtificialVariables() == 0) {\r\n        return;\r\n    }\r\n    while (!tableau.isOptimal()) {\r\n        doIteration(tableau);\r\n    }\r\n        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {\r\n        throw new NoFeasibleSolutionException();\r\n    }\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":0.2,"nbd":-0.5,"ml":0.3333333333,"d":-0.0734126984,"mi":0.1718111346,"fo":0.0,"r":0.0526315789,"e":-0.0936982417}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"@Override\r\npublic Tree apply(ChildNodeEntry entry) {\r\n    NodeStateBuilder childBuilder = builder.getChildBuilder(entry.getName());\r\n    return new TreeImpl(store, childBuilder.getNodeState(), childBuilder, TreeImpl.this, entry.getName(), listener);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Tree apply(ChildNodeEntry entry) {\r\n    NodeStateBuilder childBuilder = builder.getChildBuilder(entry.getName());\r\n    return new TreeImpl(store, childBuilder.getNodeState(), childBuilder, TreeImpl.this, entry.getName(), listener);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5797040169,"fo":-0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  @return Any feedback message for this component\r\n *\/\r\npublic final FeedbackMessage getFeedbackMessage() {\r\n    return getPage().getFeedbackMessages().messageForComponent(this);\r\n}","code_comment":"\/**\r\n *  @return Any feedback message for this component\r\n *\/\r\n","code_no_comment":"public final FeedbackMessage getFeedbackMessage() {\r\n    return getPage().getFeedbackMessages().messageForComponent(this);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.067653277,"fo":-0.25,"r":2.5,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-843_65390f8c","label":3,"code":"@Override\r\npublic Map<String, Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {\r\n    throw new NotImplementedException();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Map<String, Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {\r\n    throw new NotImplementedException();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.4,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7854827343,"fo":-0.5,"r":0.2368421053,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4072_7d5b8645","label":1,"code":"\/**\r\n *  Parses the given URL string.\r\n *\r\n *  @param url\r\n *            absolute or relative url with query string\r\n *  @return Url object\r\n *\/\r\npublic static Url parse(final String url) {\r\n    return parse(url, null);\r\n}","code_comment":"\/**\r\n *  Parses the given URL string.\r\n *\r\n *  @param url\r\n *            absolute or relative url with query string\r\n *  @return Url object\r\n *\/\r\n","code_no_comment":"public static Url parse(final String url) {\r\n    return parse(url, null);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0253699789,"fo":-0.4166666667,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-546_428e32c6","label":1,"code":"@Override\r\npublic Result executeQuery(String statement, String language, long limit, long offset, Map<String, ? extends PropertyValue> bindings, NamePathMapper namePathMapper) throws ParseException {\r\n    Query q = parseQuery(statement, language);\r\n    q.setRootTree(getRootTree());\r\n    q.setRootState(getRootState());\r\n    q.setNamePathMapper(namePathMapper);\r\n    q.setLimit(limit);\r\n    q.setOffset(offset);\r\n    if (bindings != null) {\r\n        for (Entry<String, ? extends PropertyValue> e : bindings.entrySet()) {\r\n            q.bindValue(e.getKey(), e.getValue());\r\n        }\r\n    }\r\n    q.setQueryEngine(this);\r\n    q.prepare();\r\n    return q.executeQuery();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Result executeQuery(String statement, String language, long limit, long offset, Map<String, ? extends PropertyValue> bindings, NamePathMapper namePathMapper) throws ParseException {\r\n    Query q = parseQuery(statement, language);\r\n    q.setRootTree(getRootTree());\r\n    q.setRootState(getRootState());\r\n    q.setNamePathMapper(namePathMapper);\r\n    q.setLimit(limit);\r\n    q.setOffset(offset);\r\n    if (bindings != null) {\r\n        for (Entry<String, ? extends PropertyValue> e : bindings.entrySet()) {\r\n            q.bindValue(e.getKey(), e.getValue());\r\n        }\r\n    }\r\n    q.setQueryEngine(this);\r\n    q.prepare();\r\n    return q.executeQuery();\r\n}","lc":0.1363636364,"pi":-0.043062201,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.0317460317,"mi":-0.1740662438,"fo":0.75,"r":-0.0263157895,"e":0.0729655435}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-691_118f0cc0","label":3,"code":"\/**\r\n * Add a value to the data\r\n * @param value the value to add\r\n *\/\r\npublic void addValue(double value) {\r\n    sumImpl.increment(value);\r\n    sumsqImpl.increment(value);\r\n    minImpl.increment(value);\r\n    maxImpl.increment(value);\r\n    sumLogImpl.increment(value);\r\n    secondMoment.increment(value);\r\n    \/\/ need to increment these\r\n    if (!(meanImpl instanceof Mean)) {\r\n        meanImpl.increment(value);\r\n    }\r\n    if (!(varianceImpl instanceof Variance)) {\r\n        varianceImpl.increment(value);\r\n    }\r\n    if (!(geoMeanImpl instanceof GeometricMean)) {\r\n        geoMeanImpl.increment(value);\r\n    }\r\n    n++;\r\n}","code_comment":"\/**\r\n * Add a value to the data\r\n * @param value the value to add\r\n *\/\r\n","code_no_comment":"public void addValue(double value) {\r\n    sumImpl.increment(value);\r\n    sumsqImpl.increment(value);\r\n    minImpl.increment(value);\r\n    maxImpl.increment(value);\r\n    sumLogImpl.increment(value);\r\n    secondMoment.increment(value);\r\n        if (!(meanImpl instanceof Mean)) {\r\n        meanImpl.increment(value);\r\n    }\r\n    if (!(varianceImpl instanceof Variance)) {\r\n        varianceImpl.increment(value);\r\n    }\r\n    if (!(geoMeanImpl instanceof GeometricMean)) {\r\n        geoMeanImpl.increment(value);\r\n    }\r\n    n++;\r\n}","lc":0.1818181818,"pi":-0.4258373206,"ma":0.0,"nbd":-0.5,"ml":0.0833333333,"d":0.0674603175,"mi":-0.1247357294,"fo":0.25,"r":-0.0263157895,"e":0.0119707474}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"public void update(String writer, Map<ByteBuffer, List<ColumnUpdate>> cells) throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException;","code_comment":null,"code_no_comment":"public void update(String writer, Map<ByteBuffer, List<ColumnUpdate>> cells) throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException;","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.3743481325,"fo":-0.5,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6447_020c451a","label":1,"code":"protected boolean continueRouting(Iterator<Processor> it, Exchange exchange) {\r\n    boolean answer = it.hasNext();\r\n    if (answer) {\r\n        Object matched = exchange.getProperty(Exchange.FILTER_MATCHED);\r\n        if (matched != null) {\r\n            boolean hasMatched = exchange.getContext().getTypeConverter().convertTo(Boolean.class, matched);\r\n            if (hasMatched) {\r\n                LOG.debug(\"ExchangeId: {} has been matched: {}\", exchange.getExchangeId(), exchange);\r\n                answer = false;\r\n            }\r\n        }\r\n    }\r\n    LOG.trace(\"ExchangeId: {} should continue matching: {}\", exchange.getExchangeId(), answer);\r\n    return answer;\r\n}","code_comment":null,"code_no_comment":"protected boolean continueRouting(Iterator<Processor> it, Exchange exchange) {\r\n    boolean answer = it.hasNext();\r\n    if (answer) {\r\n        Object matched = exchange.getProperty(Exchange.FILTER_MATCHED);\r\n        if (matched != null) {\r\n            boolean hasMatched = exchange.getContext().getTypeConverter().convertTo(Boolean.class, matched);\r\n            if (hasMatched) {\r\n                LOG.debug(\"ExchangeId: {} has been matched: {}\", exchange.getExchangeId(), exchange);\r\n                answer = false;\r\n            }\r\n        }\r\n    }\r\n    LOG.trace(\"ExchangeId: {} should continue matching: {}\", exchange.getExchangeId(), answer);\r\n    return answer;\r\n}","lc":0.0454545455,"pi":0.976076555,"ma":0.0,"nbd":0.5,"ml":0.0833333333,"d":-0.0436507937,"mi":-0.0796335447,"fo":0.25,"r":-0.0263157895,"e":0.0054793889}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3324_5f863af6","label":1,"code":"@Override\r\npublic boolean isGranted(long permissions) {\r\n    return hasPermissions(getIterator(null, permissions), permissions, tree.getPath());\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean isGranted(long permissions) {\r\n    return hasPermissions(getIterator(null, permissions), permissions, tree.getPath());\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8173361522,"fo":-0.25,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-724_9c8bb934","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n * <p>\r\n * <strong>Algorithm Description<\/strong>: scales the output of\r\n * Random.nextDouble(), but rejects 0 values (i.e., will generate another\r\n * random double if Random.nextDouble() returns 0). This is necessary to\r\n * provide a symmetric output interval (both endpoints excluded).\r\n * <\/p>\r\n *\r\n * @param lower\r\n *            the lower bound.\r\n * @param upper\r\n *            the upper bound.\r\n * @return a uniformly distributed random value from the interval (lower,\r\n *         upper)\r\n * @throws NumberIsTooLargeException if {@code lower >= upper}.\r\n *\/\r\npublic double nextUniform(double lower, double upper) {\r\n    if (lower >= upper) {\r\n        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false);\r\n    }\r\n    final RandomGenerator generator = getRan();\r\n    \/\/ ensure nextDouble() isn't 0.0\r\n    double u = generator.nextDouble();\r\n    while (u <= 0.0) {\r\n        u = generator.nextDouble();\r\n    }\r\n    return lower + u * (upper - lower);\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n * <p>\r\n * <strong>Algorithm Description<\/strong>: scales the output of\r\n * Random.nextDouble(), but rejects 0 values (i.e., will generate another\r\n * random double if Random.nextDouble() returns 0). This is necessary to\r\n * provide a symmetric output interval (both endpoints excluded).\r\n * <\/p>\r\n *\r\n * @param lower\r\n *            the lower bound.\r\n * @param upper\r\n *            the upper bound.\r\n * @return a uniformly distributed random value from the interval (lower,\r\n *         upper)\r\n * @throws NumberIsTooLargeException if {@code lower >= upper}.\r\n *\/\r\n","code_no_comment":"public double nextUniform(double lower, double upper) {\r\n    if (lower >= upper) {\r\n        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false);\r\n    }\r\n    final RandomGenerator generator = getRan();\r\n        double u = generator.nextDouble();\r\n    while (u <= 0.0) {\r\n        u = generator.nextDouble();\r\n    }\r\n    return lower + u * (upper - lower);\r\n}","lc":-0.1363636364,"pi":-0.2775119617,"ma":0.0,"nbd":-0.5,"ml":0.0,"d":0.7837301587,"mi":0.1210711769,"fo":-0.25,"r":0.0263157895,"e":0.2406989275}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public removeConstraint_result getResult(I iface, removeConstraint_args args) throws org.apache.thrift.TException {\r\n    removeConstraint_result result = new removeConstraint_result();\r\n    try {\r\n        iface.removeConstraint(args.login, args.tableName, args.constraint);\r\n    } catch (AccumuloException ouch1) {\r\n        result.ouch1 = ouch1;\r\n    } catch (AccumuloSecurityException ouch2) {\r\n        result.ouch2 = ouch2;\r\n    }\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"public removeConstraint_result getResult(I iface, removeConstraint_args args) throws org.apache.thrift.TException {\r\n    removeConstraint_result result = new removeConstraint_result();\r\n    try {\r\n        iface.removeConstraint(args.login, args.tableName, args.constraint);\r\n    } catch (AccumuloException ouch1) {\r\n        result.ouch1 = ouch1;\r\n    } catch (AccumuloSecurityException ouch2) {\r\n        result.ouch2 = ouch2;\r\n    }\r\n    return result;\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.1207892882,"fo":-0.4166666667,"r":0.0,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"@Override\r\npublic Tree addChild(String name) {\r\n    if (builder.addNode(name) != null) {\r\n        listener.addChild(this, name);\r\n    }\r\n    return getChild(name);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Tree addChild(String name) {\r\n    if (builder.addNode(name) != null) {\r\n        listener.addChild(this, name);\r\n    }\r\n    return getChild(name);\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.4824524313,"fo":-0.25,"r":0.6052631579,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5883_cd3b9234","label":3,"code":"@Override\r\npublic void component(final Component component, final IVisit<Boolean> visit) {\r\n    if (component.hasErrorMessage()) {\r\n        visit.stop(true);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void component(final Component component, final IVisit<Boolean> visit) {\r\n    if (component.hasErrorMessage()) {\r\n        visit.stop(true);\r\n    }\r\n}","lc":-0.3636363636,"pi":-0.004784689,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.5943622269,"fo":-0.3333333333,"r":0.3947368421,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"public Iterable<String> query(final Filter filter, final String indexName, final NodeState indexMeta, final String indexStorageNodeName, final Iterable<String> values) {\r\n    final NodeState index = indexMeta.getChildNode(indexStorageNodeName);\r\n    return new Iterable<String>() {\r\n\r\n        @Override\r\n        public Iterator<String> iterator() {\r\n            PathIterator it = new PathIterator(filter, indexName);\r\n            if (values == null) {\r\n                it.setPathContainsValue(true);\r\n                it.enqueue(getChildNodeEntries(index).iterator());\r\n            } else {\r\n                for (String p : values) {\r\n                    NodeState property = index.getChildNode(p);\r\n                    if (property.exists()) {\r\n                        \/\/ we have an entry for this value, so use it\r\n                        it.enqueue(Iterators.singletonIterator(new MemoryChildNodeEntry(\"\", property)));\r\n                    }\r\n                }\r\n            }\r\n            return it;\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"public Iterable<String> query(final Filter filter, final String indexName, final NodeState indexMeta, final String indexStorageNodeName, final Iterable<String> values) {\r\n    final NodeState index = indexMeta.getChildNode(indexStorageNodeName);\r\n    return new Iterable<String>() {\r\n\r\n        @Override\r\n        public Iterator<String> iterator() {\r\n            PathIterator it = new PathIterator(filter, indexName);\r\n            if (values == null) {\r\n                it.setPathContainsValue(true);\r\n                it.enqueue(getChildNodeEntries(index).iterator());\r\n            } else {\r\n                for (String p : values) {\r\n                    NodeState property = index.getChildNode(p);\r\n                    if (property.exists()) {\r\n                                                it.enqueue(Iterators.singletonIterator(new MemoryChildNodeEntry(\"\", property)));\r\n                    }\r\n                }\r\n            }\r\n            return it;\r\n        }\r\n    };\r\n}","lc":0.3181818182,"pi":1.7464114833,"ma":0.0,"nbd":1.0,"ml":-0.0833333333,"d":0.0257936508,"mi":-0.2817477097,"fo":0.25,"r":-0.0263157895,"e":0.1228171482}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5359_61122bab","label":3,"code":"\/**\r\n *  Convert this text to a Duration instance.\r\n *\r\n *  @return Converted text\r\n *  @throws StringValueConversionException\r\n *  @see Duration#valueOf(String, java.util.Locale)\r\n *\/\r\npublic final Duration toDuration() throws StringValueConversionException {\r\n    return Duration.valueOf(text, locale);\r\n}","code_comment":"\/**\r\n *  Convert this text to a Duration instance.\r\n *\r\n *  @return Converted text\r\n *  @throws StringValueConversionException\r\n *  @see Duration#valueOf(String, java.util.Locale)\r\n *\/\r\n","code_no_comment":"public final Duration toDuration() throws StringValueConversionException {\r\n    return Duration.valueOf(text, locale);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0132487667,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-676_3b2e880e","label":1,"code":"@Override\r\nprotected void shutdownInternal() {\r\n    Closer.closeSilent(this.connection);\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void shutdownInternal() {\r\n    Closer.closeSilent(this.connection);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9362931642,"fo":-0.4166666667,"r":1.2631578947,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public void recv_removeConstraint() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\r\n    removeConstraint_result result = new removeConstraint_result();\r\n    receiveBase(result, \"removeConstraint\");\r\n    if (result.ouch1 != null) {\r\n        throw result.ouch1;\r\n    }\r\n    if (result.ouch2 != null) {\r\n        throw result.ouch2;\r\n    }\r\n    return;\r\n}","code_comment":null,"code_no_comment":"public void recv_removeConstraint() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\r\n    removeConstraint_result result = new removeConstraint_result();\r\n    receiveBase(result, \"removeConstraint\");\r\n    if (result.ouch1 != null) {\r\n        throw result.ouch1;\r\n    }\r\n    if (result.ouch2 != null) {\r\n        throw result.ouch2;\r\n    }\r\n    return;\r\n}","lc":-0.1363636364,"pi":-0.2775119617,"ma":0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0476190476,"mi":0.1605355884,"fo":-0.4166666667,"r":-0.0263157895,"e":-0.081384024}
{"project_name":"Closure","project_version":"42","label":2,"code":"@Override\r\nNode processForInLoop(ForInLoop loopNode) {\r\n    \/\/ Return the bare minimum to put the AST in a valid state.\r\n    return newNode(Token.FOR, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody()));\r\n}","code_comment":null,"code_no_comment":"@Override\r\nNode processForInLoop(ForInLoop loopNode) {\r\n        return newNode(Token.FOR, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody()));\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7183932347,"fo":0.0833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6593_7f8a295a","label":3,"code":"\/**\r\n * Returns some descriptive text to describe this node\r\n *\/\r\npublic String getLabel() {\r\n    String language = getExpression();\r\n    if (ObjectHelper.isEmpty(language)) {\r\n        Predicate predicate = getPredicate();\r\n        if (predicate != null) {\r\n            return predicate.toString();\r\n        }\r\n        Expression expressionValue = getExpressionValue();\r\n        if (expressionValue != null) {\r\n            return expressionValue.toString();\r\n        }\r\n    } else {\r\n        return language;\r\n    }\r\n    return \"\";\r\n}","code_comment":"\/**\r\n * Returns some descriptive text to describe this node\r\n *\/\r\n","code_no_comment":"public String getLabel() {\r\n    String language = getExpression();\r\n    if (ObjectHelper.isEmpty(language)) {\r\n        Predicate predicate = getPredicate();\r\n        if (predicate != null) {\r\n            return predicate.toString();\r\n        }\r\n        Expression expressionValue = getExpressionValue();\r\n        if (expressionValue != null) {\r\n            return expressionValue.toString();\r\n        }\r\n    } else {\r\n        return language;\r\n    }\r\n    return \"\";\r\n}","lc":0.0909090909,"pi":0.2248803828,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":-0.0555555556,"mi":-0.022410148,"fo":0.0,"r":1.1052631579,"e":-0.0726750921}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2567_948b6e05","label":3,"code":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, StringValue reusable) {\r\n    this.result = reusable;\r\n    int i = startPos;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    if (quotedStringParsing == true && bytes[i] == quoteCharacter) {\r\n        \/\/ quoted string parsing enabled and first character is a quote\r\n        i++;\r\n        \/\/ search for ending quote character\r\n        while (i < limit && bytes[i] != quoteCharacter) {\r\n            i++;\r\n        }\r\n        if (i == limit) {\r\n            setErrorState(ParseErrorState.UNTERMINATED_QUOTED_STRING);\r\n            return -1;\r\n        } else {\r\n            i++;\r\n            \/\/ check for proper termination\r\n            if (i == limit) {\r\n                \/\/ either by end of line\r\n                reusable.setValueAscii(bytes, startPos + 1, i - startPos - 2);\r\n                return limit;\r\n            } else if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n                \/\/ or following field delimiter\r\n                reusable.setValueAscii(bytes, startPos + 1, i - startPos - 2);\r\n                return i + delimiter.length;\r\n            } else {\r\n                \/\/ no proper termination\r\n                setErrorState(ParseErrorState.UNQUOTED_CHARS_AFTER_QUOTED_STRING);\r\n                return -1;\r\n            }\r\n        }\r\n    } else {\r\n        \/\/ look for delimiter\r\n        while (i < delimLimit && !delimiterNext(bytes, i, delimiter)) {\r\n            i++;\r\n        }\r\n        if (i >= delimLimit) {\r\n            \/\/ no delimiter found. Take the full string\r\n            reusable.setValueAscii(bytes, startPos, limit - startPos);\r\n            return limit;\r\n        } else {\r\n            \/\/ delimiter found.\r\n            reusable.setValueAscii(bytes, startPos, i - startPos);\r\n            return i + delimiter.length;\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, StringValue reusable) {\r\n    this.result = reusable;\r\n    int i = startPos;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    if (quotedStringParsing == true && bytes[i] == quoteCharacter) {\r\n                i++;\r\n                while (i < limit && bytes[i] != quoteCharacter) {\r\n            i++;\r\n        }\r\n        if (i == limit) {\r\n            setErrorState(ParseErrorState.UNTERMINATED_QUOTED_STRING);\r\n            return -1;\r\n        } else {\r\n            i++;\r\n                        if (i == limit) {\r\n                                reusable.setValueAscii(bytes, startPos + 1, i - startPos - 2);\r\n                return limit;\r\n            } else if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n                                reusable.setValueAscii(bytes, startPos + 1, i - startPos - 2);\r\n                return i + delimiter.length;\r\n            } else {\r\n                                setErrorState(ParseErrorState.UNQUOTED_CHARS_AFTER_QUOTED_STRING);\r\n                return -1;\r\n            }\r\n        }\r\n    } else {\r\n                while (i < delimLimit && !delimiterNext(bytes, i, delimiter)) {\r\n            i++;\r\n        }\r\n        if (i >= delimLimit) {\r\n                        reusable.setValueAscii(bytes, startPos, limit - startPos);\r\n            return limit;\r\n        } else {\r\n                        reusable.setValueAscii(bytes, startPos, i - startPos);\r\n            return i + delimiter.length;\r\n        }\r\n    }\r\n}","lc":1.1363636364,"pi":0.7511961722,"ma":0.8,"nbd":1.0,"ml":1.1666666667,"d":3.5198412698,"mi":-0.6958421424,"fo":0.1666666667,"r":-0.0263157895,"e":5.6706419322}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7478_69b00a31","label":1,"code":"public void process(Exchange exchange) throws Exception {\r\n    \/\/ copy the original exchange to avoid side effects on it\r\n    Exchange resultExchange = exchange.copy();\r\n    \/\/ remove any existing exception in case we do OGNL on the exception\r\n    resultExchange.setException(null);\r\n    \/\/ force to use InOut to retrieve the result on the OUT message\r\n    resultExchange.setPattern(ExchangePattern.InOut);\r\n    \/\/ do not propagate any method name when using OGNL, as with OGNL we\r\n    \/\/ compute and provide the method name to explicit to invoke\r\n    resultExchange.getIn().removeHeader(Exchange.BEAN_METHOD_NAME);\r\n    \/\/ current ognl path as we go along\r\n    String ognlPath = \"\";\r\n    \/\/ loop and invoke each method\r\n    Object beanToCall = beanHolder.getBean();\r\n    \/\/ there must be a bean to call with, we currently does not support OGNL expressions on using purely static methods\r\n    if (beanToCall == null) {\r\n        throw new IllegalArgumentException(\"Bean instance is null. OGNL bean expressions requires bean instances.\");\r\n    }\r\n    \/\/ Split ognl except when this is not a Map, Array\r\n    \/\/ and we would like to keep the dots within the key name\r\n    List<String> methods = OgnlHelper.splitOgnl(ognl);\r\n    for (String methodName : methods) {\r\n        BeanHolder holder = new ConstantBeanHolder(beanToCall, exchange.getContext());\r\n        \/\/ support the null safe operator\r\n        boolean nullSafe = OgnlHelper.isNullSafeOperator(methodName);\r\n        \/\/ keep up with how far are we doing\r\n        ognlPath += methodName;\r\n        \/\/ get rid of leading ?. or . as we only needed that to determine if null safe was enabled or not\r\n        methodName = OgnlHelper.removeLeadingOperators(methodName);\r\n        \/\/ are we doing an index lookup (eg in Map\/List\/array etc)?\r\n        String key = null;\r\n        KeyValueHolder<String, String> index = OgnlHelper.isOgnlIndex(methodName);\r\n        if (index != null) {\r\n            methodName = index.getKey();\r\n            key = index.getValue();\r\n        }\r\n        \/\/ only invoke if we have a method name to use to invoke\r\n        if (methodName != null) {\r\n            InvokeProcessor invoke = new InvokeProcessor(holder, methodName);\r\n            invoke.process(resultExchange);\r\n            \/\/ check for exception and rethrow if we failed\r\n            if (resultExchange.getException() != null) {\r\n                throw new RuntimeBeanExpressionException(exchange, beanName, methodName, resultExchange.getException());\r\n            }\r\n            result = invoke.getResult();\r\n        }\r\n        \/\/ if there was a key then we need to lookup using the key\r\n        if (key != null) {\r\n            result = lookupResult(resultExchange, key, result, nullSafe, ognlPath, holder.getBean());\r\n        }\r\n        \/\/ check null safe for null results\r\n        if (result == null && nullSafe) {\r\n            return;\r\n        }\r\n        \/\/ prepare for next bean to invoke\r\n        beanToCall = result;\r\n        \/\/ we need to set the result to the exchange for further processing\r\n        resultExchange.getIn().setBody(result);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void process(Exchange exchange) throws Exception {\r\n        Exchange resultExchange = exchange.copy();\r\n        resultExchange.setException(null);\r\n        resultExchange.setPattern(ExchangePattern.InOut);\r\n            resultExchange.getIn().removeHeader(Exchange.BEAN_METHOD_NAME);\r\n        String ognlPath = \"\";\r\n        Object beanToCall = beanHolder.getBean();\r\n        if (beanToCall == null) {\r\n        throw new IllegalArgumentException(\"Bean instance is null. OGNL bean expressions requires bean instances.\");\r\n    }\r\n            List<String> methods = OgnlHelper.splitOgnl(ognl);\r\n    for (String methodName : methods) {\r\n        BeanHolder holder = new ConstantBeanHolder(beanToCall, exchange.getContext());\r\n                boolean nullSafe = OgnlHelper.isNullSafeOperator(methodName);\r\n                ognlPath += methodName;\r\n                methodName = OgnlHelper.removeLeadingOperators(methodName);\r\n                String key = null;\r\n        KeyValueHolder<String, String> index = OgnlHelper.isOgnlIndex(methodName);\r\n        if (index != null) {\r\n            methodName = index.getKey();\r\n            key = index.getValue();\r\n        }\r\n                if (methodName != null) {\r\n            InvokeProcessor invoke = new InvokeProcessor(holder, methodName);\r\n            invoke.process(resultExchange);\r\n                        if (resultExchange.getException() != null) {\r\n                throw new RuntimeBeanExpressionException(exchange, beanName, methodName, resultExchange.getException());\r\n            }\r\n            result = invoke.getResult();\r\n        }\r\n                if (key != null) {\r\n            result = lookupResult(resultExchange, key, result, nullSafe, ognlPath, holder.getBean());\r\n        }\r\n                if (result == null && nullSafe) {\r\n            return;\r\n        }\r\n                beanToCall = result;\r\n                resultExchange.getIn().setBody(result);\r\n    }\r\n}","lc":1.1818181818,"pi":0.2727272727,"ma":1.2,"nbd":0.5,"ml":0.75,"d":0.5277777778,"mi":-0.754756871,"fo":1.25,"r":-0.0263157895,"e":1.5313773967}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2074_6bc6dbec","label":0,"code":"@Override\r\npublic void evict(int n) {\r\n    toRemove += n;\r\n    Integer lastPreAggregateSize = elementsPerPreAggregate.peek();\r\n    while (lastPreAggregateSize != null && lastPreAggregateSize <= toRemove) {\r\n        toRemove = max(toRemove - elementsPerPreAggregate.removeFirst(), 0);\r\n        reduced.removeFirst();\r\n        lastPreAggregateSize = elementsPerPreAggregate.peek();\r\n    }\r\n    if (toRemove > 0 && lastPreAggregateSize == null) {\r\n        currentReduced = null;\r\n        toRemove = 0;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void evict(int n) {\r\n    toRemove += n;\r\n    Integer lastPreAggregateSize = elementsPerPreAggregate.peek();\r\n    while (lastPreAggregateSize != null && lastPreAggregateSize <= toRemove) {\r\n        toRemove = max(toRemove - elementsPerPreAggregate.removeFirst(), 0);\r\n        reduced.removeFirst();\r\n        lastPreAggregateSize = elementsPerPreAggregate.peek();\r\n    }\r\n    if (toRemove > 0 && lastPreAggregateSize == null) {\r\n        currentReduced = null;\r\n        toRemove = 0;\r\n    }\r\n}","lc":0.0,"pi":-0.009569378,"ma":-0.2,"nbd":-0.5,"ml":0.0833333333,"d":1.380952381,"mi":-0.0294573643,"fo":-0.0833333333,"r":0.0,"e":0.6814243645}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4038_f3d7565c","label":1,"code":"\/**\r\n *  Cleans the original parameters from entries used by Wicket internals.\r\n *\r\n *  @param originalParameters\r\n *             the current request's non-modified parameters\r\n *  @return all parameters but Wicket internal ones\r\n *\/\r\nprivate PageParameters cleanPageParameters(final PageParameters originalParameters) {\r\n    PageParameters cleanParameters = new PageParameters(originalParameters);\r\n    \/\/ WICKET-4038: Ajax related parameters are set by wicket-ajax.js when needed.\r\n    \/\/ They shouldn't be propagated to the next requests\r\n    cleanParameters.remove(WebRequest.PARAM_AJAX);\r\n    cleanParameters.remove(WebRequest.PARAM_AJAX_BASE_URL);\r\n    return cleanParameters;\r\n}","code_comment":"\/**\r\n *  Cleans the original parameters from entries used by Wicket internals.\r\n *\r\n *  @param originalParameters\r\n *             the current request's non-modified parameters\r\n *  @return all parameters but Wicket internal ones\r\n *\/\r\n","code_no_comment":"private PageParameters cleanPageParameters(final PageParameters originalParameters) {\r\n    PageParameters cleanParameters = new PageParameters(originalParameters);\r\n            cleanParameters.remove(WebRequest.PARAM_AJAX);\r\n    cleanParameters.remove(WebRequest.PARAM_AJAX_BASE_URL);\r\n    return cleanParameters;\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5453136011,"fo":-0.3333333333,"r":2.1052631579,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\r\n    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\r\n        throw new IllegalStateException(\"Method call not finished!\");\r\n    }\r\n    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());\r\n    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\r\n    (new Client(prot)).recv_removeTableProperty();\r\n}","code_comment":null,"code_no_comment":"public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\r\n    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\r\n        throw new IllegalStateException(\"Method call not finished!\");\r\n    }\r\n    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());\r\n    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\r\n    (new Client(prot)).recv_removeTableProperty();\r\n}","lc":-0.2727272727,"pi":-0.2822966507,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0535714286,"mi":0.2109936575,"fo":0.0,"r":-0.0263157895,"e":0.0042899212}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-334_9d8cc45d","label":1,"code":"@Override\r\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\r\n    RegExFilter result = new RegExFilter();\r\n    result.setSource(getSource().deepCopy(env));\r\n    result.rowMatcher = copyMatcher(rowMatcher);\r\n    result.colfMatcher = copyMatcher(colfMatcher);\r\n    result.colqMatcher = copyMatcher(colqMatcher);\r\n    result.valueMatcher = copyMatcher(valueMatcher);\r\n    result.orFields = orFields;\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\r\n    RegExFilter result = new RegExFilter();\r\n    result.setSource(getSource().deepCopy(env));\r\n    result.rowMatcher = copyMatcher(rowMatcher);\r\n    result.colfMatcher = copyMatcher(colfMatcher);\r\n    result.colqMatcher = copyMatcher(colqMatcher);\r\n    result.valueMatcher = copyMatcher(valueMatcher);\r\n    result.orFields = orFields;\r\n    return result;\r\n}","lc":-0.1363636364,"pi":-0.5789473684,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.1162790698,"fo":0.0833333333,"r":0.0,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4616_dd1df04b","label":1,"code":"@Override\r\npublic void component(final Component component, final IVisit<Void> visit) {\r\n    final Form<?> form = (Form<?>) component;\r\n    if (!form.isEnabledInHierarchy() || !form.isVisibleInHierarchy()) {\r\n        visit.dontGoDeeper();\r\n        return;\r\n    }\r\n    if (form.hasError()) {\r\n        form.onError();\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void component(final Component component, final IVisit<Void> visit) {\r\n    final Form<?> form = (Form<?>) component;\r\n    if (!form.isEnabledInHierarchy() || !form.isVisibleInHierarchy()) {\r\n        visit.dontGoDeeper();\r\n        return;\r\n    }\r\n    if (form.hasError()) {\r\n        form.onError();\r\n    }\r\n}","lc":-0.1363636364,"pi":-0.019138756,"ma":-0.2,"nbd":-0.5,"ml":0.0833333333,"d":-0.0535714286,"mi":0.1791402396,"fo":-0.0833333333,"r":-0.0263157895,"e":-0.0858007296}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5319_c863b032","label":3,"code":"\/**\r\n *  Generate the next segment\r\n *\r\n *  @return segment\r\n *\/\r\npublic String next() {\r\n    char a = characters[Math.abs(hash % characters.length)];\r\n    hash++;\r\n    char b = characters[Math.abs(hash % characters.length)];\r\n    hash++;\r\n    char c = characters[Math.abs(hash % characters.length)];\r\n    String segment = \"\" + a + b + c;\r\n    hash = hashString(segment);\r\n    segment += String.format(\"%02x\", Math.abs(hash % 256));\r\n    hash = hashString(segment);\r\n    return segment;\r\n}","code_comment":"\/**\r\n *  Generate the next segment\r\n *\r\n *  @return segment\r\n *\/\r\n","code_no_comment":"public String next() {\r\n    char a = characters[Math.abs(hash % characters.length)];\r\n    hash++;\r\n    char b = characters[Math.abs(hash % characters.length)];\r\n    hash++;\r\n    char c = characters[Math.abs(hash % characters.length)];\r\n    String segment = \"\" + a + b + c;\r\n    hash = hashString(segment);\r\n    segment += String.format(\"%02x\", Math.abs(hash % 256));\r\n    hash = hashString(segment);\r\n    return segment;\r\n}","lc":-0.0909090909,"pi":-0.7177033493,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":0.7321428571,"mi":0.0145172657,"fo":0.0833333333,"r":0.5789473684,"e":0.5306662517}
{"project_name":"Closure","project_version":"80","label":1,"code":"\/**\r\n * @param locals A predicate to apply to unknown local values.\r\n * @return Whether the node is known to be a value that is not a reference\r\n *     outside the expression scope.\r\n *\/\r\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\r\n    switch(value.getType()) {\r\n        case Token.ASSIGN:\r\n            \/\/ value is immutable.\r\n            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals));\r\n        case Token.COMMA:\r\n            return evaluatesToLocalValue(value.getLastChild(), locals);\r\n        case Token.AND:\r\n        case Token.OR:\r\n            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\r\n        case Token.HOOK:\r\n            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\r\n        case Token.INC:\r\n        case Token.DEC:\r\n            if (value.getBooleanProp(Node.INCRDECR_PROP)) {\r\n                return evaluatesToLocalValue(value.getFirstChild(), locals);\r\n            } else {\r\n                return true;\r\n            }\r\n        case Token.THIS:\r\n            return locals.apply(value);\r\n        case Token.NAME:\r\n            return isImmutableValue(value) || locals.apply(value);\r\n        case Token.GETELEM:\r\n        case Token.GETPROP:\r\n            \/\/ There is no information about the locality of object properties.\r\n            return locals.apply(value);\r\n        case Token.CALL:\r\n            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value);\r\n        case Token.NEW:\r\n            return newHasLocalResult(value) || locals.apply(value);\r\n        case Token.FUNCTION:\r\n        case Token.REGEXP:\r\n        case Token.ARRAYLIT:\r\n        case Token.OBJECTLIT:\r\n            \/\/ Literals objects with non-literal children are allowed.\r\n            return true;\r\n        case Token.IN:\r\n            \/\/ TODO(johnlenz): should IN operator be included in #isSimpleOperator?\r\n            return true;\r\n        default:\r\n            \/\/ x -= g (x is now an local number)\r\n            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {\r\n                return true;\r\n            }\r\n            throw new IllegalStateException(\"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent());\r\n    }\r\n}","code_comment":"\/**\r\n * @param locals A predicate to apply to unknown local values.\r\n * @return Whether the node is known to be a value that is not a reference\r\n *     outside the expression scope.\r\n *\/\r\n","code_no_comment":"static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\r\n    switch(value.getType()) {\r\n        case Token.ASSIGN:\r\n                        return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals));\r\n        case Token.COMMA:\r\n            return evaluatesToLocalValue(value.getLastChild(), locals);\r\n        case Token.AND:\r\n        case Token.OR:\r\n            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\r\n        case Token.HOOK:\r\n            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\r\n        case Token.INC:\r\n        case Token.DEC:\r\n            if (value.getBooleanProp(Node.INCRDECR_PROP)) {\r\n                return evaluatesToLocalValue(value.getFirstChild(), locals);\r\n            } else {\r\n                return true;\r\n            }\r\n        case Token.THIS:\r\n            return locals.apply(value);\r\n        case Token.NAME:\r\n            return isImmutableValue(value) || locals.apply(value);\r\n        case Token.GETELEM:\r\n        case Token.GETPROP:\r\n                        return locals.apply(value);\r\n        case Token.CALL:\r\n            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value);\r\n        case Token.NEW:\r\n            return newHasLocalResult(value) || locals.apply(value);\r\n        case Token.FUNCTION:\r\n        case Token.REGEXP:\r\n        case Token.ARRAYLIT:\r\n        case Token.OBJECTLIT:\r\n                        return true;\r\n        case Token.IN:\r\n                        return true;\r\n        default:\r\n                        if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {\r\n                return true;\r\n            }\r\n            throw new IllegalStateException(\"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent());\r\n    }\r\n}","lc":1.3181818182,"pi":0.2296650718,"ma":3.8,"nbd":0.5,"ml":1.9166666667,"d":0.1944444444,"mi":-0.8573643411,"fo":2.25,"r":-0.0263157895,"e":0.7970609084}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3733_a5ff019e","label":1,"code":"\/**\r\n * Checks if the update operation introduced any conflicts on the given\r\n * document. The document shows the state right before the operation was\r\n * applied.\r\n *\r\n * @param op the update operation.\r\n * @param before how the document looked before the update was applied or\r\n *               {@code null} if it didn't exist before.\r\n * @throws ConflictException if there was a conflict introduced by the\r\n *          given update operation.\r\n *\/\r\nprivate void checkConflicts(@Nonnull UpdateOp op, @Nullable NodeDocument before) throws ConflictException {\r\n    DocumentStore store = nodeStore.getDocumentStore();\r\n    collisions.clear();\r\n    if (baseRevision != null) {\r\n        Revision newestRev = null;\r\n        if (before != null) {\r\n            Revision base = baseRevision;\r\n            if (nodeStore.isDisableBranches()) {\r\n                base = base.asTrunkRevision();\r\n            }\r\n            newestRev = before.getNewestRevision(nodeStore, base, revision, getBranch(), collisions);\r\n        }\r\n        String conflictMessage = null;\r\n        Revision conflictRevision = newestRev;\r\n        if (newestRev == null) {\r\n            if ((op.isDelete() || !op.isNew()) && isConflicting(before, op)) {\r\n                conflictMessage = \"The node \" + op.getId() + \" does not exist or is already deleted\";\r\n                if (before != null && !before.getLocalDeleted().isEmpty()) {\r\n                    conflictRevision = before.getLocalDeleted().firstKey();\r\n                }\r\n            }\r\n        } else {\r\n            if (op.isNew() && isConflicting(before, op)) {\r\n                conflictMessage = \"The node \" + op.getId() + \" was already added in revision\\n\" + formatConflictRevision(newestRev);\r\n            } else if (nodeStore.isRevisionNewer(newestRev, baseRevision) && (op.isDelete() || isConflicting(before, op))) {\r\n                conflictMessage = \"The node \" + op.getId() + \" was changed in revision\\n\" + formatConflictRevision(newestRev) + \", which was applied after the base revision\\n\" + baseRevision;\r\n            }\r\n        }\r\n        if (conflictMessage == null) {\r\n            \/\/ TODO: unify above conflict detection and isConflicting()\r\n            if (!collisions.isEmpty() && isConflicting(before, op)) {\r\n                for (Revision r : collisions) {\r\n                    \/\/ mark collisions on commit root\r\n                    Collision c = new Collision(before, r, op, revision);\r\n                    if (c.mark(store).equals(revision)) {\r\n                        \/\/ our revision was marked\r\n                        if (baseRevision.isBranch()) {\r\n                        \/\/ this is a branch commit. do not fail immediately\r\n                        \/\/ merging this branch will fail later.\r\n                        } else {\r\n                            \/\/ fail immediately\r\n                            conflictMessage = \"The node \" + op.getId() + \" was changed in revision\\n\" + formatConflictRevision(r) + \", which was applied after the base revision\\n\" + baseRevision;\r\n                            conflictRevision = r;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (conflictMessage != null) {\r\n            conflictMessage += \", before\\n\" + revision;\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(conflictMessage + \"; document:\\n\" + (before == null ? \"\" : before.format()) + \",\\nrevision order:\\n\" + nodeStore.getRevisionComparator());\r\n            }\r\n            throw new ConflictException(conflictMessage, conflictRevision);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Checks if the update operation introduced any conflicts on the given\r\n * document. The document shows the state right before the operation was\r\n * applied.\r\n *\r\n * @param op the update operation.\r\n * @param before how the document looked before the update was applied or\r\n *               {@code null} if it didn't exist before.\r\n * @throws ConflictException if there was a conflict introduced by the\r\n *          given update operation.\r\n *\/\r\n","code_no_comment":"private void checkConflicts(@Nonnull UpdateOp op, @Nullable NodeDocument before) throws ConflictException {\r\n    DocumentStore store = nodeStore.getDocumentStore();\r\n    collisions.clear();\r\n    if (baseRevision != null) {\r\n        Revision newestRev = null;\r\n        if (before != null) {\r\n            Revision base = baseRevision;\r\n            if (nodeStore.isDisableBranches()) {\r\n                base = base.asTrunkRevision();\r\n            }\r\n            newestRev = before.getNewestRevision(nodeStore, base, revision, getBranch(), collisions);\r\n        }\r\n        String conflictMessage = null;\r\n        Revision conflictRevision = newestRev;\r\n        if (newestRev == null) {\r\n            if ((op.isDelete() || !op.isNew()) && isConflicting(before, op)) {\r\n                conflictMessage = \"The node \" + op.getId() + \" does not exist or is already deleted\";\r\n                if (before != null && !before.getLocalDeleted().isEmpty()) {\r\n                    conflictRevision = before.getLocalDeleted().firstKey();\r\n                }\r\n            }\r\n        } else {\r\n            if (op.isNew() && isConflicting(before, op)) {\r\n                conflictMessage = \"The node \" + op.getId() + \" was already added in revision\\n\" + formatConflictRevision(newestRev);\r\n            } else if (nodeStore.isRevisionNewer(newestRev, baseRevision) && (op.isDelete() || isConflicting(before, op))) {\r\n                conflictMessage = \"The node \" + op.getId() + \" was changed in revision\\n\" + formatConflictRevision(newestRev) + \", which was applied after the base revision\\n\" + baseRevision;\r\n            }\r\n        }\r\n        if (conflictMessage == null) {\r\n                        if (!collisions.isEmpty() && isConflicting(before, op)) {\r\n                for (Revision r : collisions) {\r\n                                        Collision c = new Collision(before, r, op, revision);\r\n                    if (c.mark(store).equals(revision)) {\r\n                                                if (baseRevision.isBranch()) {\r\n                                                                        } else {\r\n                                                        conflictMessage = \"The node \" + op.getId() + \" was changed in revision\\n\" + formatConflictRevision(r) + \", which was applied after the base revision\\n\" + baseRevision;\r\n                            conflictRevision = r;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (conflictMessage != null) {\r\n            conflictMessage += \", before\\n\" + revision;\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(conflictMessage + \"; document:\\n\" + (before == null ? \"\" : before.format()) + \",\\nrevision order:\\n\" + nodeStore.getRevisionComparator());\r\n            }\r\n            throw new ConflictException(conflictMessage, conflictRevision);\r\n        }\r\n    }\r\n}","lc":1.6818181818,"pi":1.6124401914,"ma":2.8,"nbd":2.0,"ml":2.75,"d":1.7797619048,"mi":-0.9684284708,"fo":2.3333333333,"r":-0.0263157895,"e":5.5983333621}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4572_dfc56674","label":0,"code":"\/**\r\n *\/\r\nprivate void rebuildIndices() {\r\n    idToWindowIndex = null;\r\n    idToWindowIndex = new IntHashMap<Integer>();\r\n    for (int i = 0; i < windows.size(); ++i) {\r\n        PageWindowInternal window = windows.get(i);\r\n        putWindowIndex(window.pageId, i);\r\n    }\r\n}","code_comment":"\/**\r\n *\/\r\n","code_no_comment":"private void rebuildIndices() {\r\n    idToWindowIndex = null;\r\n    idToWindowIndex = new IntHashMap<Integer>();\r\n    for (int i = 0; i < windows.size(); ++i) {\r\n        PageWindowInternal window = windows.get(i);\r\n        putWindowIndex(window.pageId, i);\r\n    }\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0734126984,"mi":0.3172656801,"fo":-0.25,"r":2.0526315789,"e":-0.0838459455}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-657_32b0f733","label":3,"code":"\/**\r\n * Returns a {@code Complex} whose value is\r\n * {@code (this \/ divisor)}.\r\n * Implements the definitional formula\r\n * <pre>\r\n *  <code>\r\n *    a + bi          ac + bd + (bc - ad)i\r\n *    ----------- = -------------------------\r\n *    c + di         c<sup>2<\/sup> + d<sup>2<\/sup>\r\n *  <\/code>\r\n * <\/pre>\r\n * but uses\r\n * <a href=\"http:\/\/doi.acm.org\/10.1145\/1039813.1039814\">\r\n * prescaling of operands<\/a> to limit the effects of overflows and\r\n * underflows in the computation.\r\n * <br\/>\r\n * {@code Infinite} and {@code NaN} values are handled according to the\r\n * following rules, applied in the order presented:\r\n * <ul>\r\n *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\r\n *   in either part, {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} and {@code divisor} are both infinite,\r\n *   {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\r\n *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\r\n *   infinite), {@link #ZERO} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} is infinite and {@code divisor} is finite,\r\n *   {@code NaN} values are returned in the parts of the result if the\r\n *   {@link java.lang.Double} rules applied to the definitional formula\r\n *   force {@code NaN} results.\r\n *  <\/li>\r\n * <\/ul>\r\n *\r\n * @param divisor Value by which this {@code Complex} is to be divided.\r\n * @return {@code this \/ divisor}.\r\n * @throws NullArgumentException if {@code divisor} is {@code null}.\r\n *\/\r\npublic Complex divide(Complex divisor) throws NullArgumentException {\r\n    MathUtils.checkNotNull(divisor);\r\n    if (isNaN || divisor.isNaN) {\r\n        return NaN;\r\n    }\r\n    final double c = divisor.getReal();\r\n    final double d = divisor.getImaginary();\r\n    if (c == 0.0 && d == 0.0) {\r\n        return NaN;\r\n    }\r\n    if (divisor.isInfinite() && !isInfinite()) {\r\n        return ZERO;\r\n    }\r\n    if (FastMath.abs(c) < FastMath.abs(d)) {\r\n        double q = c \/ d;\r\n        double denominator = c * q + d;\r\n        return createComplex((real * q + imaginary) \/ denominator, (imaginary * q - real) \/ denominator);\r\n    } else {\r\n        double q = d \/ c;\r\n        double denominator = d * q + c;\r\n        return createComplex((imaginary * q + real) \/ denominator, (imaginary - real * q) \/ denominator);\r\n    }\r\n}","code_comment":"\/**\r\n * Returns a {@code Complex} whose value is\r\n * {@code (this \/ divisor)}.\r\n * Implements the definitional formula\r\n * <pre>\r\n *  <code>\r\n *    a + bi          ac + bd + (bc - ad)i\r\n *    ----------- = -------------------------\r\n *    c + di         c<sup>2<\/sup> + d<sup>2<\/sup>\r\n *  <\/code>\r\n * <\/pre>\r\n * but uses\r\n * <a href=\"http:\/\/doi.acm.org\/10.1145\/1039813.1039814\">\r\n * prescaling of operands<\/a> to limit the effects of overflows and\r\n * underflows in the computation.\r\n * <br\/>\r\n * {@code Infinite} and {@code NaN} values are handled according to the\r\n * following rules, applied in the order presented:\r\n * <ul>\r\n *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\r\n *   in either part, {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} and {@code divisor} are both infinite,\r\n *   {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\r\n *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\r\n *   infinite), {@link #ZERO} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} is infinite and {@code divisor} is finite,\r\n *   {@code NaN} values are returned in the parts of the result if the\r\n *   {@link java.lang.Double} rules applied to the definitional formula\r\n *   force {@code NaN} results.\r\n *  <\/li>\r\n * <\/ul>\r\n *\r\n * @param divisor Value by which this {@code Complex} is to be divided.\r\n * @return {@code this \/ divisor}.\r\n * @throws NullArgumentException if {@code divisor} is {@code null}.\r\n *\/\r\n","code_no_comment":"public Complex divide(Complex divisor) throws NullArgumentException {\r\n    MathUtils.checkNotNull(divisor);\r\n    if (isNaN || divisor.isNaN) {\r\n        return NaN;\r\n    }\r\n    final double c = divisor.getReal();\r\n    final double d = divisor.getImaginary();\r\n    if (c == 0.0 && d == 0.0) {\r\n        return NaN;\r\n    }\r\n    if (divisor.isInfinite() && !isInfinite()) {\r\n        return ZERO;\r\n    }\r\n    if (FastMath.abs(c) < FastMath.abs(d)) {\r\n        double q = c \/ d;\r\n        double denominator = c * q + d;\r\n        return createComplex((real * q + imaginary) \/ denominator, (imaginary * q - real) \/ denominator);\r\n    } else {\r\n        double q = d \/ c;\r\n        double denominator = d * q + c;\r\n        return createComplex((imaginary * q + real) \/ denominator, (imaginary - real * q) \/ denominator);\r\n    }\r\n}","lc":0.4090909091,"pi":-0.2440191388,"ma":0.2,"nbd":-0.5,"ml":0.8333333333,"d":2.4821428571,"mi":-0.3945031712,"fo":0.25,"r":-0.0263157895,"e":3.0738864589}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5853_b80f6640","label":3,"code":"@Override\r\npublic BigInteger convertToObject(final String value, final Locale locale) {\r\n    if (Strings.isEmpty(value)) {\r\n        return null;\r\n    }\r\n    final Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);\r\n    if (number instanceof BigInteger) {\r\n        return (BigInteger) number;\r\n    } else if (number instanceof Long) {\r\n        return BigInteger.valueOf(number.longValue());\r\n    } else if (number instanceof Integer) {\r\n        return BigInteger.valueOf(number.intValue());\r\n    } else {\r\n        return new BigInteger(value);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic BigInteger convertToObject(final String value, final Locale locale) {\r\n    if (Strings.isEmpty(value)) {\r\n        return null;\r\n    }\r\n    final Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);\r\n    if (number instanceof BigInteger) {\r\n        return (BigInteger) number;\r\n    } else if (number instanceof Long) {\r\n        return BigInteger.valueOf(number.longValue());\r\n    } else if (number instanceof Integer) {\r\n        return BigInteger.valueOf(number.intValue());\r\n    } else {\r\n        return new BigInteger(value);\r\n    }\r\n}","lc":0.0909090909,"pi":-0.1004784689,"ma":0.2,"nbd":0.5,"ml":0.1666666667,"d":0.003968254,"mi":-0.0863988724,"fo":0.0,"r":-0.0263157895,"e":-0.0039948595}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_46f62443","label":1,"code":"@Override\r\npublic void delete(String tableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n    acu.tables.remove(tableName);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void delete(String tableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n    acu.tables.remove(tableName);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7919661734,"fo":-0.4166666667,"r":0.1842105263,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-367_3a15d8ce","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic Entry next() {\r\n    tmp.setIndex(current.getIndex());\r\n    if (next != null) {\r\n        current.setIndex(next.getIndex());\r\n        advance(next);\r\n        if (next.getIndex() < 0) {\r\n            next = null;\r\n        }\r\n    } else {\r\n        current = null;\r\n    }\r\n    return tmp;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public Entry next() {\r\n    tmp.setIndex(current.getIndex());\r\n    if (next != null) {\r\n        current.setIndex(next.getIndex());\r\n        advance(next);\r\n        if (next.getIndex() < 0) {\r\n            next = null;\r\n        }\r\n    } else {\r\n        current = null;\r\n    }\r\n    return tmp;\r\n}","lc":-0.0454545455,"pi":0.1674641148,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":0.0912698413,"mi":0.11205074,"fo":0.0,"r":1.0526315789,"e":-0.0568477954}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3989_6a8fc1cc","label":1,"code":"\/**\r\n *  Nothing to add to the response by default\r\n *\/\r\npublic void onComponentTag(final Component component, final ComponentTag tag) {\r\n}","code_comment":"\/**\r\n *  Nothing to add to the response by default\r\n *\/\r\n","code_no_comment":"public void onComponentTag(final Component component, final ComponentTag tag) {\r\n}","lc":-0.5454545455,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.2528541226,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5154_a8586a69","label":3,"code":"\/**\r\n * Introspects the given method\r\n *\r\n * @param clazz the class\r\n * @param method the method\r\n * @return the method info, is newer <tt>null<\/tt>\r\n *\/\r\nprivate MethodInfo introspect(Class<?> clazz, Method method) {\r\n    LOG.trace(\"Introspecting class: {}, method: {}\", clazz, method);\r\n    String opName = method.getName();\r\n    MethodInfo methodInfo = createMethodInfo(clazz, method);\r\n    \/\/ methods already registered should be preferred to use instead of super classes of existing methods\r\n    \/\/ we want to us the method from the sub class over super classes, so if we have already registered\r\n    \/\/ the method then use it (we are traversing upwards: sub (child) -> super (farther) )\r\n    MethodInfo existingMethodInfo = overridesExistingMethod(methodInfo);\r\n    if (existingMethodInfo != null) {\r\n        LOG.trace(\"This method is already overridden in a subclass, so the method from the sub class is preferred: {}\", existingMethodInfo);\r\n        return existingMethodInfo;\r\n    }\r\n    LOG.trace(\"Adding operation: {} for method: {}\", opName, methodInfo);\r\n    if (hasMethod(opName)) {\r\n        \/\/ we have an overloaded method so add the method info to the same key\r\n        List<MethodInfo> existing = getOperations(opName);\r\n        existing.add(methodInfo);\r\n    } else {\r\n        \/\/ its a new method we have not seen before so wrap it in a list and add it\r\n        List<MethodInfo> methods = new ArrayList<MethodInfo>();\r\n        methods.add(methodInfo);\r\n        operations.put(opName, methods);\r\n    }\r\n    if (methodInfo.hasCustomAnnotation()) {\r\n        operationsWithCustomAnnotation.add(methodInfo);\r\n    } else if (methodInfo.hasBodyParameter()) {\r\n        operationsWithBody.add(methodInfo);\r\n    }\r\n    if (methodInfo.hasHandlerAnnotation()) {\r\n        operationsWithHandlerAnnotation.add(methodInfo);\r\n    }\r\n    \/\/ must add to method map last otherwise we break stuff\r\n    methodMap.put(method, methodInfo);\r\n    return methodInfo;\r\n}","code_comment":"\/**\r\n * Introspects the given method\r\n *\r\n * @param clazz the class\r\n * @param method the method\r\n * @return the method info, is newer <tt>null<\/tt>\r\n *\/\r\n","code_no_comment":"private MethodInfo introspect(Class<?> clazz, Method method) {\r\n    LOG.trace(\"Introspecting class: {}, method: {}\", clazz, method);\r\n    String opName = method.getName();\r\n    MethodInfo methodInfo = createMethodInfo(clazz, method);\r\n                MethodInfo existingMethodInfo = overridesExistingMethod(methodInfo);\r\n    if (existingMethodInfo != null) {\r\n        LOG.trace(\"This method is already overridden in a subclass, so the method from the sub class is preferred: {}\", existingMethodInfo);\r\n        return existingMethodInfo;\r\n    }\r\n    LOG.trace(\"Adding operation: {} for method: {}\", opName, methodInfo);\r\n    if (hasMethod(opName)) {\r\n                List<MethodInfo> existing = getOperations(opName);\r\n        existing.add(methodInfo);\r\n    } else {\r\n                List<MethodInfo> methods = new ArrayList<MethodInfo>();\r\n        methods.add(methodInfo);\r\n        operations.put(opName, methods);\r\n    }\r\n    if (methodInfo.hasCustomAnnotation()) {\r\n        operationsWithCustomAnnotation.add(methodInfo);\r\n    } else if (methodInfo.hasBodyParameter()) {\r\n        operationsWithBody.add(methodInfo);\r\n    }\r\n    if (methodInfo.hasHandlerAnnotation()) {\r\n        operationsWithHandlerAnnotation.add(methodInfo);\r\n    }\r\n        methodMap.put(method, methodInfo);\r\n    return methodInfo;\r\n}","lc":0.6818181818,"pi":-0.3205741627,"ma":0.4,"nbd":0.0,"ml":0.5,"d":0.0694444444,"mi":-0.4931642001,"fo":1.0,"r":-0.0263157895,"e":0.2885035413}
{"project_name":"Cli","project_version":"22","label":1,"code":"\/**\r\n * Add the special token \"<b>--<\/b>\" and the current <code>value<\/code>\r\n * to the processed tokens list. Then add all the remaining\r\n * <code>argument<\/code> values to the processed tokens list.\r\n *\r\n * @param value The current token\r\n *\/\r\nprivate void processNonOptionToken(String value) {\r\n    eatTheRest = true;\r\n    tokens.add(\"--\");\r\n    tokens.add(value);\r\n}","code_comment":"\/**\r\n * Add the special token \"<b>--<\/b>\" and the current <code>value<\/code>\r\n * to the processed tokens list. Then add all the remaining\r\n * <code>argument<\/code> values to the processed tokens list.\r\n *\r\n * @param value The current token\r\n *\/\r\n","code_no_comment":"private void processNonOptionToken(String value) {\r\n    eatTheRest = true;\r\n    tokens.add(\"--\");\r\n    tokens.add(value);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6842847075,"fo":-0.3333333333,"r":2.2631578947,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-843_65390f8c","label":3,"code":"@Override\r\npublic void clearLocatorCache(String tableName) throws TableNotFoundException {\r\n    throw new NotImplementedException();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void clearLocatorCache(String tableName) throws TableNotFoundException {\r\n    throw new NotImplementedException();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.4,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8951374207,"fo":-0.5,"r":1.9736842105,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1662_3efb5cbf","label":0,"code":"\/**\r\n * Get the revision of the latest change made to this node.\r\n *\r\n * @param context the revision context\r\n * @param changeRev the revision of the current change\r\n * @param handler the conflict handler, which is called for concurrent changes\r\n *                preceding <code>changeRev<\/code>.\r\n * @return the revision, or null if deleted\r\n *\/\r\n@CheckForNull\r\npublic Revision getNewestRevision(RevisionContext context, Revision changeRev, CollisionHandler handler) {\r\n    \/\/ no need to look at all commits. the primary document\r\n    \/\/ always contains at least one commit, including all\r\n    \/\/ branch commits which are not yet merged\r\n    SortedMap<Revision, String> revisions = getLocalRevisions();\r\n    SortedMap<Revision, String> commitRoots = getLocalCommitRoot();\r\n    Revision newestRev = null;\r\n    for (Revision r : Iterables.mergeSorted(Arrays.asList(revisions.keySet(), commitRoots.keySet()), revisions.comparator())) {\r\n        if (!r.equals(changeRev)) {\r\n            if (isValidRevision(context, r, null, changeRev, new HashMap<Revision, String>())) {\r\n                newestRev = r;\r\n                \/\/ revisions are sorted newest first\r\n                break;\r\n            } else {\r\n                handler.concurrentModification(r);\r\n            }\r\n        }\r\n    }\r\n    if (newestRev == null) {\r\n        return null;\r\n    }\r\n    \/\/ the local deleted map contains the most recent revisions\r\n    SortedMap<Revision, String> deleted = getLocalDeleted();\r\n    String value = deleted.get(newestRev);\r\n    if (value == null && deleted.headMap(newestRev).isEmpty()) {\r\n        \/\/ no need to check previous docs\r\n        return newestRev;\r\n    }\r\n    if (value == null) {\r\n        \/\/ get from complete map\r\n        value = getDeleted().get(newestRev);\r\n    }\r\n    if (\"true\".equals(value)) {\r\n        \/\/ deleted in the newest revision\r\n        return null;\r\n    }\r\n    return newestRev;\r\n}","code_comment":"\/**\r\n * Get the revision of the latest change made to this node.\r\n *\r\n * @param context the revision context\r\n * @param changeRev the revision of the current change\r\n * @param handler the conflict handler, which is called for concurrent changes\r\n *                preceding <code>changeRev<\/code>.\r\n * @return the revision, or null if deleted\r\n *\/\r\n","code_no_comment":"@CheckForNull\r\npublic Revision getNewestRevision(RevisionContext context, Revision changeRev, CollisionHandler handler) {\r\n                SortedMap<Revision, String> revisions = getLocalRevisions();\r\n    SortedMap<Revision, String> commitRoots = getLocalCommitRoot();\r\n    Revision newestRev = null;\r\n    for (Revision r : Iterables.mergeSorted(Arrays.asList(revisions.keySet(), commitRoots.keySet()), revisions.comparator())) {\r\n        if (!r.equals(changeRev)) {\r\n            if (isValidRevision(context, r, null, changeRev, new HashMap<Revision, String>())) {\r\n                newestRev = r;\r\n                                break;\r\n            } else {\r\n                handler.concurrentModification(r);\r\n            }\r\n        }\r\n    }\r\n    if (newestRev == null) {\r\n        return null;\r\n    }\r\n        SortedMap<Revision, String> deleted = getLocalDeleted();\r\n    String value = deleted.get(newestRev);\r\n    if (value == null && deleted.headMap(newestRev).isEmpty()) {\r\n                return newestRev;\r\n    }\r\n    if (value == null) {\r\n                value = getDeleted().get(newestRev);\r\n    }\r\n    if (\"true\".equals(value)) {\r\n                return null;\r\n    }\r\n    return newestRev;\r\n}","lc":0.7727272727,"pi":0.6746411483,"ma":1.0,"nbd":0.5,"ml":0.9166666667,"d":0.5396825397,"mi":-0.5599718111,"fo":0.9166666667,"r":-0.0263157895,"e":0.8878892135}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1916_705ce1d1","label":1,"code":"@Override\r\n@CheckForNull\r\npublic PropertyState getProperty(String name) {\r\n    checkNotNull(name);\r\n    Template template = getTemplate();\r\n    if (JCR_PRIMARYTYPE.equals(name)) {\r\n        return template.getPrimaryType();\r\n    } else if (JCR_MIXINTYPES.equals(name)) {\r\n        return template.getMixinTypes();\r\n    }\r\n    PropertyTemplate propertyTemplate = template.getPropertyTemplate(name);\r\n    if (propertyTemplate != null) {\r\n        Segment segment = getSegment();\r\n        int ids = 1 + propertyTemplate.getIndex();\r\n        if (template.getChildName() != Template.ZERO_CHILD_NODES) {\r\n            ids++;\r\n        }\r\n        return new SegmentPropertyState(segment.readRecordId(getOffset(0, ids)), propertyTemplate);\r\n    } else {\r\n        return null;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\n@CheckForNull\r\npublic PropertyState getProperty(String name) {\r\n    checkNotNull(name);\r\n    Template template = getTemplate();\r\n    if (JCR_PRIMARYTYPE.equals(name)) {\r\n        return template.getPrimaryType();\r\n    } else if (JCR_MIXINTYPES.equals(name)) {\r\n        return template.getMixinTypes();\r\n    }\r\n    PropertyTemplate propertyTemplate = template.getPropertyTemplate(name);\r\n    if (propertyTemplate != null) {\r\n        Segment segment = getSegment();\r\n        int ids = 1 + propertyTemplate.getIndex();\r\n        if (template.getChildName() != Template.ZERO_CHILD_NODES) {\r\n            ids++;\r\n        }\r\n        return new SegmentPropertyState(segment.readRecordId(getOffset(0, ids)), propertyTemplate);\r\n    } else {\r\n        return null;\r\n    }\r\n}","lc":0.3636363636,"pi":0.1148325359,"ma":0.2,"nbd":0.0,"ml":0.3333333333,"d":0.2420634921,"mi":-0.2997885835,"fo":0.5,"r":-0.0263157895,"e":0.2532805449}
{"project_name":"Closure","project_version":"118","label":2,"code":"\/**\r\n * Processes a OBJECTLIT node.\r\n *\/\r\nprivate void handleObjectLit(NodeTraversal t, Node n) {\r\n    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\r\n        \/\/ Maybe STRING, GET, SET\r\n        \/\/ We should never see a mix of numbers and strings.\r\n        String name = child.getString();\r\n        T type = typeSystem.getType(getScope(), n, name);\r\n        Property prop = getProperty(name);\r\n        if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) {\r\n            \/\/ case right now.\r\n            if (propertiesToErrorFor.containsKey(name)) {\r\n                compiler.report(JSError.make(t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Processes a OBJECTLIT node.\r\n *\/\r\n","code_no_comment":"private void handleObjectLit(NodeTraversal t, Node n) {\r\n    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\r\n                        String name = child.getString();\r\n        T type = typeSystem.getType(getScope(), n, name);\r\n        Property prop = getProperty(name);\r\n        if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) {\r\n                        if (propertiesToErrorFor.containsKey(name)) {\r\n                compiler.report(JSError.make(t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\r\n            }\r\n        }\r\n    }\r\n}","lc":-0.0909090909,"pi":0.7559808612,"ma":0.2,"nbd":0.5,"ml":0.5833333333,"d":0.3373015873,"mi":-0.0565186751,"fo":0.75,"r":-0.0263157895,"e":0.4415207206}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7146_b6981cfd","label":3,"code":"\/**\r\n * Removes the exchange with the given correlation key, which should happen\r\n * when an {@link Exchange} is completed\r\n *\r\n * @param camelContext   the current CamelContext\r\n * @param key            the correlation key\r\n * @param exchange       the exchange to remove\r\n *\/\r\nvoid remove(CamelContext camelContext, String key, Exchange exchange);","code_comment":"\/**\r\n * Removes the exchange with the given correlation key, which should happen\r\n * when an {@link Exchange} is completed\r\n *\r\n * @param camelContext   the current CamelContext\r\n * @param key            the correlation key\r\n * @param exchange       the exchange to remove\r\n *\/\r\n","code_no_comment":"void remove(CamelContext camelContext, String key, Exchange exchange);","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.5051444679,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3475_7651b777","label":1,"code":"public static void main(String[] args) throws IOException {\r\n    Shell shell = new Shell();\r\n    shell.config(args);\r\n    System.exit(shell.start());\r\n}","code_comment":null,"code_no_comment":"public static void main(String[] args) throws IOException {\r\n    Shell shell = new Shell();\r\n    shell.config(args);\r\n    System.exit(shell.start());\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6425651868,"fo":-0.25,"r":1.1578947368,"e":-0.1627934049}
{"project_name":"Math","project_version":"22","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic boolean isSupportUpperBoundInclusive() {\r\n    return false;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public boolean isSupportUpperBoundInclusive() {\r\n    return false;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.2407329105,"fo":-0.5,"r":2.5,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5209_ed651a4d","label":3,"code":"public List<String> getCompileClasspathElements() throws DependencyResolutionRequiredException {\r\n    List<String> list = new ArrayList<String>(getArtifacts().size() + 1);\r\n    list.add(getBuild().getOutputDirectory());\r\n    for (Artifact a : getArtifacts()) {\r\n        if (a.getArtifactHandler().isAddedToClasspath()) {\r\n            \/\/ TODO: let the scope handler deal with this\r\n            if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_PROVIDED.equals(a.getScope()) || Artifact.SCOPE_SYSTEM.equals(a.getScope())) {\r\n                addArtifactPath(a, list);\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}","code_comment":null,"code_no_comment":"public List<String> getCompileClasspathElements() throws DependencyResolutionRequiredException {\r\n    List<String> list = new ArrayList<String>(getArtifacts().size() + 1);\r\n    list.add(getBuild().getOutputDirectory());\r\n    for (Artifact a : getArtifacts()) {\r\n        if (a.getArtifactHandler().isAddedToClasspath()) {\r\n                        if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_PROVIDED.equals(a.getScope()) || Artifact.SCOPE_SYSTEM.equals(a.getScope())) {\r\n                addArtifactPath(a, list);\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}","lc":-0.0909090909,"pi":0.8421052632,"ma":0.0,"nbd":0.5,"ml":0.3333333333,"d":-0.001984127,"mi":0.0319943622,"fo":0.75,"r":0.0,"e":0.0152809714}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8584_dd0f74c0","label":1,"code":"private boolean rejectExchange(final Exchange exchange, final AsyncCallback callback) {\r\n    exchange.setException(new RejectedExecutionException(\"CircuitBreaker Open: failures: \" + failures + \", lastFailure: \" + lastFailure));\r\n    \/*\r\n         * If the circuit opens, we have to prevent the execution of any\r\n         * processor. The failures count can be set to 0.\r\n         *\/\r\n    failures.set(0);\r\n    callback.done(true);\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"private boolean rejectExchange(final Exchange exchange, final AsyncCallback callback) {\r\n    exchange.setException(new RejectedExecutionException(\"CircuitBreaker Open: failures: \" + failures + \", lastFailure: \" + lastFailure));\r\n        failures.set(0);\r\n    callback.done(true);\r\n    return true;\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5002114165,"fo":-0.25,"r":1.2368421053,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-43_668f08f2","label":1,"code":"static void addNode(LinkedList<AddNodeOperation> list, String path, String name, JsopTokenizer t) throws Exception {\r\n    AddNodeOperation op = new AddNodeOperation();\r\n    op.path = path;\r\n    op.name = name;\r\n    list.add(op);\r\n    if (!t.matches('}')) {\r\n        do {\r\n            String key = t.readString();\r\n            t.read(':');\r\n            if (t.matches('{')) {\r\n                addNode(list, PathUtils.concat(path, name), key, t);\r\n            } else {\r\n                op.props.put(key, t.readRawValue().trim());\r\n            }\r\n        } while (t.matches(','));\r\n        t.read('}');\r\n    }\r\n}","code_comment":null,"code_no_comment":"static void addNode(LinkedList<AddNodeOperation> list, String path, String name, JsopTokenizer t) throws Exception {\r\n    AddNodeOperation op = new AddNodeOperation();\r\n    op.path = path;\r\n    op.name = name;\r\n    list.add(op);\r\n    if (!t.matches('}')) {\r\n        do {\r\n            String key = t.readString();\r\n            t.read(':');\r\n            if (t.matches('{')) {\r\n                addNode(list, PathUtils.concat(path, name), key, t);\r\n            } else {\r\n                op.props.put(key, t.readRawValue().trim());\r\n            }\r\n        } while (t.matches(','));\r\n        t.read('}');\r\n    }\r\n}","lc":0.1818181818,"pi":0.9090909091,"ma":0.0,"nbd":0.5,"ml":0.0833333333,"d":0.0615079365,"mi":-0.207329105,"fo":0.5,"r":-0.0263157895,"e":0.1403133879}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2427_e6d4f9a6","label":1,"code":"@Override\r\npublic String toString() {\r\n    StringBuilder buff = new StringBuilder();\r\n    buff.append(s1).append(\" union \").append(s2);\r\n    \/\/ order by ...\r\n    if (orderList != null && !orderList.isEmpty()) {\r\n        buff.append(\" order by \");\r\n        for (int i = 0; i < orderList.size(); i++) {\r\n            if (i > 0) {\r\n                buff.append(\", \");\r\n            }\r\n            buff.append(orderList.get(i));\r\n        }\r\n    }\r\n    \/\/ leave original xpath string as a comment\r\n    if (xpathQuery != null) {\r\n        buff.append(\" \/* xpath: \");\r\n        buff.append(xpathQuery);\r\n        buff.append(\" *\/\");\r\n    }\r\n    return buff.toString();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String toString() {\r\n    StringBuilder buff = new StringBuilder();\r\n    buff.append(s1).append(\" union \").append(s2);\r\n        if (orderList != null && !orderList.isEmpty()) {\r\n        buff.append(\" order by \");\r\n        for (int i = 0; i < orderList.size(); i++) {\r\n            if (i > 0) {\r\n                buff.append(\", \");\r\n            }\r\n            buff.append(orderList.get(i));\r\n        }\r\n    }\r\n        if (xpathQuery != null) {\r\n        buff.append(\" \/* xpath: \");\r\n        buff.append(xpathQuery);\r\n        buff.append(\" *\/\");\r\n    }\r\n    return buff.toString();\r\n}","lc":0.2727272727,"pi":0.6124401914,"ma":0.2,"nbd":0.5,"ml":0.4166666667,"d":0.9880952381,"mi":-0.252149401,"fo":0.5833333333,"r":0.0526315789,"e":0.7381730376}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5565_44f4782a","label":1,"code":"@Override\r\npublic int getCompatibilityScore(Request request) {\r\n    \/\/ always return 0 here so that the mounts have higher priority\r\n    return 0;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int getCompatibilityScore(Request request) {\r\n        return 0;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9362931642,"fo":-0.5,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"Lang","project_version":"60","label":1,"code":"\/\/ -----------------------------------------------------------------------\r\n\/**\r\n * Checks if the string builder contains the specified char.\r\n *\r\n * @param ch  the character to find\r\n * @return true if the builder contains the character\r\n *\/\r\npublic boolean contains(char ch) {\r\n    char[] thisBuf = buffer;\r\n    for (int i = 0; i < thisBuf.length; i++) {\r\n        if (thisBuf[i] == ch) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":"\/**\r\n * Checks if the string builder contains the specified char.\r\n *\r\n * @param ch  the character to find\r\n * @return true if the builder contains the character\r\n *\/\r\n","code_no_comment":"public boolean contains(char ch) {\r\n    char[] thisBuf = buffer;\r\n    for (int i = 0; i < thisBuf.length; i++) {\r\n        if (thisBuf[i] == ch) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","lc":-0.2272727273,"pi":0.3205741627,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":0.2698412698,"mi":0.3124735729,"fo":-0.5,"r":2.4473684211,"e":-0.0448378601}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5418_e350f19e","label":1,"code":"@Override\r\npublic void onConfigure(Component component) {\r\n    super.onConfigure(component);\r\n    if (requiredFlagSet == false) {\r\n        \/\/ \"Required\" flag is calculated upon component's model property, so we must ensure,\r\n        \/\/ that model object is accessible (i.e. component is already added in a page).\r\n        requiredFlagSet = true;\r\n        setComponentRequiredFlag();\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void onConfigure(Component component) {\r\n    super.onConfigure(component);\r\n    if (requiredFlagSet == false) {\r\n                        requiredFlagSet = true;\r\n        setComponentRequiredFlag();\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1011904762,"mi":0.4463706836,"fo":-0.3333333333,"r":1.0263157895,"e":-0.1330198302}
{"project_name":"Time","project_version":"15","label":2,"code":"\/**\r\n * Multiply two values throwing an exception if overflow occurs.\r\n *\r\n * @param val1  the first value\r\n * @param val2  the second value\r\n * @return the new total\r\n * @throws ArithmeticException if the value is too big or too small\r\n * @since 1.2\r\n *\/\r\npublic static long safeMultiply(long val1, int val2) {\r\n    switch(val2) {\r\n        case -1:\r\n            return -val1;\r\n        case 0:\r\n            return 0L;\r\n        case 1:\r\n            return val1;\r\n    }\r\n    long total = val1 * val2;\r\n    if (total \/ val2 != val1) {\r\n        throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\r\n    }\r\n    return total;\r\n}","code_comment":"\/**\r\n * Multiply two values throwing an exception if overflow occurs.\r\n *\r\n * @param val1  the first value\r\n * @param val2  the second value\r\n * @return the new total\r\n * @throws ArithmeticException if the value is too big or too small\r\n * @since 1.2\r\n *\/\r\n","code_no_comment":"public static long safeMultiply(long val1, int val2) {\r\n    switch(val2) {\r\n        case -1:\r\n            return -val1;\r\n        case 0:\r\n            return 0L;\r\n        case 1:\r\n            return val1;\r\n    }\r\n    long total = val1 * val2;\r\n    if (total \/ val2 != val1) {\r\n        throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\r\n    }\r\n    return total;\r\n}","lc":0.0454545455,"pi":0.4019138756,"ma":0.4,"nbd":0.0,"ml":0.1666666667,"d":0.878968254,"mi":-0.0029598309,"fo":-0.5,"r":1.6842105263,"e":0.1918293252}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7429_43956f93","label":1,"code":"private int findTokenPosition(String uri, int pivot, String token) {\r\n    int idx = uri.indexOf(token, pivot);\r\n    while (idx > 0) {\r\n        \/\/ grab part as the previous char + token + next char, to test if the token is quoted\r\n        String part = null;\r\n        int len = idx + token.length() + 1;\r\n        if (uri.length() >= len) {\r\n            part = uri.substring(idx - 1, len);\r\n        }\r\n        if (StringHelper.isQuoted(part)) {\r\n            \/\/ the token was quoted, so regard it as a literal\r\n            \/\/ and then try to find from next position\r\n            pivot = idx + token.length() + 1;\r\n            idx = uri.indexOf(token, pivot);\r\n        } else {\r\n            \/\/ found token\r\n            return idx;\r\n        }\r\n    }\r\n    return idx;\r\n}","code_comment":null,"code_no_comment":"private int findTokenPosition(String uri, int pivot, String token) {\r\n    int idx = uri.indexOf(token, pivot);\r\n    while (idx > 0) {\r\n                String part = null;\r\n        int len = idx + token.length() + 1;\r\n        if (uri.length() >= len) {\r\n            part = uri.substring(idx - 1, len);\r\n        }\r\n        if (StringHelper.isQuoted(part)) {\r\n                                    pivot = idx + token.length() + 1;\r\n            idx = uri.indexOf(token, pivot);\r\n        } else {\r\n                        return idx;\r\n        }\r\n    }\r\n    return idx;\r\n}","lc":0.1363636364,"pi":0.3684210526,"ma":0.0,"nbd":0.0,"ml":0.25,"d":0.7083333333,"mi":-0.1540521494,"fo":0.0833333333,"r":-0.0263157895,"e":0.4714049434}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4138_50db442b","label":1,"code":"@Override\r\npublic Options getOptions() {\r\n    final Options o = new Options();\r\n    scanOptAuths = new Option(\"s\", \"scan-authorizations\", true, \"scan authorizations (all user auths are used if this argument is not specified)\");\r\n    optStartRowExclusive = new Option(\"be\", \"begin-exclusive\", false, \"make start row exclusive (by default it's inclusive)\");\r\n    optStartRowExclusive.setArgName(\"begin-exclusive\");\r\n    optEndRowExclusive = new Option(\"ee\", \"end-exclusive\", false, \"make end row exclusive (by default it's inclusive)\");\r\n    optEndRowExclusive.setArgName(\"end-exclusive\");\r\n    scanOptRow = new Option(\"r\", \"row\", true, \"row to scan\");\r\n    scanOptColumns = new Option(\"c\", \"columns\", true, \"comma-separated columns\");\r\n    timestampOpt = new Option(\"st\", \"show-timestamps\", false, \"display timestamps\");\r\n    disablePaginationOpt = new Option(\"np\", \"no-pagination\", false, \"disable pagination of output\");\r\n    showFewOpt = new Option(\"f\", \"show-few\", true, \"show only a specified number of characters\");\r\n    formatterOpt = new Option(\"fm\", \"formatter\", true, \"fully qualified name of the formatter class to use\");\r\n    interpreterOpt = new Option(\"i\", \"interpreter\", true, \"fully qualified name of the interpreter class to use\");\r\n    formatterInterpeterOpt = new Option(\"fi\", \"fmt-interpreter\", true, \"fully qualified name of a class that is a formatter and interpreter\");\r\n    timeoutOption = new Option(null, \"timeout\", true, \"time before scan should fail if no data is returned. If no unit is given assumes seconds.  Units d,h,m,s,and ms are supported.  e.g. 30s or 100ms\");\r\n    outputFileOpt = new Option(\"o\", \"output\", true, \"local file to write the scan output to\");\r\n    scanOptAuths.setArgName(\"comma-separated-authorizations\");\r\n    scanOptRow.setArgName(\"row\");\r\n    scanOptColumns.setArgName(\"<columnfamily>[:<columnqualifier>]{,<columnfamily>[:<columnqualifier>]}\");\r\n    showFewOpt.setRequired(false);\r\n    showFewOpt.setArgName(\"int\");\r\n    formatterOpt.setArgName(\"className\");\r\n    timeoutOption.setArgName(\"timeout\");\r\n    outputFileOpt.setArgName(\"file\");\r\n    profileOpt = new Option(\"pn\", \"profile\", true, \"iterator profile name\");\r\n    profileOpt.setArgName(\"profile\");\r\n    o.addOption(scanOptAuths);\r\n    o.addOption(scanOptRow);\r\n    o.addOption(OptUtil.startRowOpt());\r\n    o.addOption(OptUtil.endRowOpt());\r\n    o.addOption(optStartRowExclusive);\r\n    o.addOption(optEndRowExclusive);\r\n    o.addOption(scanOptColumns);\r\n    o.addOption(timestampOpt);\r\n    o.addOption(disablePaginationOpt);\r\n    o.addOption(OptUtil.tableOpt(\"table to be scanned\"));\r\n    o.addOption(showFewOpt);\r\n    o.addOption(formatterOpt);\r\n    o.addOption(interpreterOpt);\r\n    o.addOption(formatterInterpeterOpt);\r\n    o.addOption(timeoutOption);\r\n    o.addOption(outputFileOpt);\r\n    o.addOption(profileOpt);\r\n    return o;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Options getOptions() {\r\n    final Options o = new Options();\r\n    scanOptAuths = new Option(\"s\", \"scan-authorizations\", true, \"scan authorizations (all user auths are used if this argument is not specified)\");\r\n    optStartRowExclusive = new Option(\"be\", \"begin-exclusive\", false, \"make start row exclusive (by default it's inclusive)\");\r\n    optStartRowExclusive.setArgName(\"begin-exclusive\");\r\n    optEndRowExclusive = new Option(\"ee\", \"end-exclusive\", false, \"make end row exclusive (by default it's inclusive)\");\r\n    optEndRowExclusive.setArgName(\"end-exclusive\");\r\n    scanOptRow = new Option(\"r\", \"row\", true, \"row to scan\");\r\n    scanOptColumns = new Option(\"c\", \"columns\", true, \"comma-separated columns\");\r\n    timestampOpt = new Option(\"st\", \"show-timestamps\", false, \"display timestamps\");\r\n    disablePaginationOpt = new Option(\"np\", \"no-pagination\", false, \"disable pagination of output\");\r\n    showFewOpt = new Option(\"f\", \"show-few\", true, \"show only a specified number of characters\");\r\n    formatterOpt = new Option(\"fm\", \"formatter\", true, \"fully qualified name of the formatter class to use\");\r\n    interpreterOpt = new Option(\"i\", \"interpreter\", true, \"fully qualified name of the interpreter class to use\");\r\n    formatterInterpeterOpt = new Option(\"fi\", \"fmt-interpreter\", true, \"fully qualified name of a class that is a formatter and interpreter\");\r\n    timeoutOption = new Option(null, \"timeout\", true, \"time before scan should fail if no data is returned. If no unit is given assumes seconds.  Units d,h,m,s,and ms are supported.  e.g. 30s or 100ms\");\r\n    outputFileOpt = new Option(\"o\", \"output\", true, \"local file to write the scan output to\");\r\n    scanOptAuths.setArgName(\"comma-separated-authorizations\");\r\n    scanOptRow.setArgName(\"row\");\r\n    scanOptColumns.setArgName(\"<columnfamily>[:<columnqualifier>]{,<columnfamily>[:<columnqualifier>]}\");\r\n    showFewOpt.setRequired(false);\r\n    showFewOpt.setArgName(\"int\");\r\n    formatterOpt.setArgName(\"className\");\r\n    timeoutOption.setArgName(\"timeout\");\r\n    outputFileOpt.setArgName(\"file\");\r\n    profileOpt = new Option(\"pn\", \"profile\", true, \"iterator profile name\");\r\n    profileOpt.setArgName(\"profile\");\r\n    o.addOption(scanOptAuths);\r\n    o.addOption(scanOptRow);\r\n    o.addOption(OptUtil.startRowOpt());\r\n    o.addOption(OptUtil.endRowOpt());\r\n    o.addOption(optStartRowExclusive);\r\n    o.addOption(optEndRowExclusive);\r\n    o.addOption(scanOptColumns);\r\n    o.addOption(timestampOpt);\r\n    o.addOption(disablePaginationOpt);\r\n    o.addOption(OptUtil.tableOpt(\"table to be scanned\"));\r\n    o.addOption(showFewOpt);\r\n    o.addOption(formatterOpt);\r\n    o.addOption(interpreterOpt);\r\n    o.addOption(formatterInterpeterOpt);\r\n    o.addOption(timeoutOption);\r\n    o.addOption(outputFileOpt);\r\n    o.addOption(profileOpt);\r\n    return o;\r\n}","lc":1.5,"pi":-0.961722488,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.8291754757,"fo":2.0833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, LongValue reusable) {\r\n    long val = 0;\r\n    boolean neg = false;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    this.result = reusable;\r\n    if (bytes[startPos] == '-') {\r\n        neg = true;\r\n        startPos++;\r\n        \/\/ check for empty field with only the sign\r\n        if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\r\n            return -1;\r\n        }\r\n    }\r\n    for (int i = startPos; i < limit; i++) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            reusable.setValue(neg ? -val : val);\r\n            return i + delimiter.length;\r\n        }\r\n        if (bytes[i] < 48 || bytes[i] > 57) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\r\n            return -1;\r\n        }\r\n        val *= 10;\r\n        val += bytes[i] - 48;\r\n        \/\/ check for overflow \/ underflow\r\n        if (val < 0) {\r\n            \/\/ this is an overflow\/underflow, unless we hit exactly the Long.MIN_VALUE\r\n            if (neg && val == Long.MIN_VALUE) {\r\n                reusable.setValue(Long.MIN_VALUE);\r\n                if (i + 1 >= limit) {\r\n                    return limit;\r\n                } else if (i + 1 < delimLimit && delimiterNext(bytes, i + 1, delimiter)) {\r\n                    return i + 1 + delimiter.length;\r\n                } else {\r\n                    setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\r\n                    return -1;\r\n                }\r\n            } else {\r\n                setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\r\n                return -1;\r\n            }\r\n        }\r\n    }\r\n    reusable.setValue(neg ? -val : val);\r\n    return limit;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, LongValue reusable) {\r\n    long val = 0;\r\n    boolean neg = false;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    this.result = reusable;\r\n    if (bytes[startPos] == '-') {\r\n        neg = true;\r\n        startPos++;\r\n                if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\r\n            return -1;\r\n        }\r\n    }\r\n    for (int i = startPos; i < limit; i++) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            reusable.setValue(neg ? -val : val);\r\n            return i + delimiter.length;\r\n        }\r\n        if (bytes[i] < 48 || bytes[i] > 57) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\r\n            return -1;\r\n        }\r\n        val *= 10;\r\n        val += bytes[i] - 48;\r\n                if (val < 0) {\r\n                        if (neg && val == Long.MIN_VALUE) {\r\n                reusable.setValue(Long.MIN_VALUE);\r\n                if (i + 1 >= limit) {\r\n                    return limit;\r\n                } else if (i + 1 < delimLimit && delimiterNext(bytes, i + 1, delimiter)) {\r\n                    return i + 1 + delimiter.length;\r\n                } else {\r\n                    setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\r\n                    return -1;\r\n                }\r\n            } else {\r\n                setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\r\n                return -1;\r\n            }\r\n        }\r\n    }\r\n    reusable.setValue(neg ? -val : val);\r\n    return limit;\r\n}","lc":1.4090909091,"pi":1.2296650718,"ma":1.6,"nbd":1.5,"ml":1.9166666667,"d":3.8392857143,"mi":-0.8257928118,"fo":0.3333333333,"r":-0.0263157895,"e":8.0498078065}
{"project_name":"Closure","project_version":"173","label":2,"code":"\/**\r\n * Tries apply our various peephole minimizations on the passed in node.\r\n *\/\r\n@Override\r\n@SuppressWarnings(\"fallthrough\")\r\npublic Node optimizeSubtree(Node node) {\r\n    switch(node.getType()) {\r\n        case Token.TRUE:\r\n        case Token.FALSE:\r\n            return reduceTrueFalse(node);\r\n        case Token.NEW:\r\n            node = tryFoldStandardConstructors(node);\r\n            if (!node.isCall()) {\r\n                return node;\r\n            }\r\n        \/\/ convert a NEW node into a CALL node\r\n        case Token.CALL:\r\n            Node result = tryFoldLiteralConstructor(node);\r\n            if (result == node) {\r\n                result = tryFoldSimpleFunctionCall(node);\r\n                if (result == node) {\r\n                    result = tryFoldImmediateCallToBoundFunction(node);\r\n                }\r\n            }\r\n            return result;\r\n        case Token.RETURN:\r\n            return tryReduceReturn(node);\r\n        case Token.COMMA:\r\n            return trySplitComma(node);\r\n        case Token.NAME:\r\n            return tryReplaceUndefined(node);\r\n        case Token.ARRAYLIT:\r\n            return tryMinimizeArrayLiteral(node);\r\n        default:\r\n            \/\/ Nothing changed\r\n            return node;\r\n    }\r\n}","code_comment":"\/**\r\n * Tries apply our various peephole minimizations on the passed in node.\r\n *\/\r\n","code_no_comment":"@Override\r\n@SuppressWarnings(\"fallthrough\")\r\npublic Node optimizeSubtree(Node node) {\r\n    switch(node.getType()) {\r\n        case Token.TRUE:\r\n        case Token.FALSE:\r\n            return reduceTrueFalse(node);\r\n        case Token.NEW:\r\n            node = tryFoldStandardConstructors(node);\r\n            if (!node.isCall()) {\r\n                return node;\r\n            }\r\n                case Token.CALL:\r\n            Node result = tryFoldLiteralConstructor(node);\r\n            if (result == node) {\r\n                result = tryFoldSimpleFunctionCall(node);\r\n                if (result == node) {\r\n                    result = tryFoldImmediateCallToBoundFunction(node);\r\n                }\r\n            }\r\n            return result;\r\n        case Token.RETURN:\r\n            return tryReduceReturn(node);\r\n        case Token.COMMA:\r\n            return trySplitComma(node);\r\n        case Token.NAME:\r\n            return tryReplaceUndefined(node);\r\n        case Token.ARRAYLIT:\r\n            return tryMinimizeArrayLiteral(node);\r\n        default:\r\n                        return node;\r\n    }\r\n}","lc":0.8636363636,"pi":0.9282296651,"ma":1.8,"nbd":1.0,"ml":0.8333333333,"d":0.0456349206,"mi":-0.5498238196,"fo":0.4166666667,"r":-0.0263157895,"e":0.1447393141}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2235_29d3d8f1","label":3,"code":"@Override\r\npublic void enter(NodeState before, NodeState after) throws CommitFailedException {\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void enter(NodeState before, NodeState after) throws CommitFailedException {\r\n}","lc":-0.5,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0132487667,"fo":-0.5,"r":0.2894736842,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4121_8967eb2b","label":1,"code":"\/**\r\n *  @see org.apache.wicket.extensions.wizard.IWizardModel#reset()\r\n *\/\r\npublic void reset() {\r\n    history.clear();\r\n    activeStep = null;\r\n    setActiveStep(findNextVisibleStep());\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.extensions.wizard.IWizardModel#reset()\r\n *\/\r\n","code_no_comment":"public void reset() {\r\n    history.clear();\r\n    activeStep = null;\r\n    setActiveStep(findNextVisibleStep());\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7448907681,"fo":-0.25,"r":2.4210526316,"e":-0.1627934049}
{"project_name":"Compress","project_version":"47","label":1,"code":"@Override\r\npublic int read(final byte[] buffer, final int offset, final int length) throws IOException {\r\n    if (closed) {\r\n        throw new IOException(\"The stream is closed\");\r\n    }\r\n    if (current == null) {\r\n        return -1;\r\n    }\r\n    \/\/ avoid int overflow, check null buffer\r\n    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\r\n        throw new ArrayIndexOutOfBoundsException();\r\n    }\r\n    ZipUtil.checkRequestedFeatures(current.entry);\r\n    if (!supportsDataDescriptorFor(current.entry)) {\r\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\r\n    }\r\n    int read;\r\n    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\r\n        read = readStored(buffer, offset, length);\r\n    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\r\n        read = readDeflated(buffer, offset, length);\r\n    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\r\n        read = current.in.read(buffer, offset, length);\r\n    } else {\r\n        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\r\n    }\r\n    if (read >= 0) {\r\n        current.crc.update(buffer, offset, read);\r\n    }\r\n    return read;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int read(final byte[] buffer, final int offset, final int length) throws IOException {\r\n    if (closed) {\r\n        throw new IOException(\"The stream is closed\");\r\n    }\r\n    if (current == null) {\r\n        return -1;\r\n    }\r\n        if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\r\n        throw new ArrayIndexOutOfBoundsException();\r\n    }\r\n    ZipUtil.checkRequestedFeatures(current.entry);\r\n    if (!supportsDataDescriptorFor(current.entry)) {\r\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\r\n    }\r\n    int read;\r\n    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\r\n        read = readStored(buffer, offset, length);\r\n    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\r\n        read = readDeflated(buffer, offset, length);\r\n    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\r\n        read = current.in.read(buffer, offset, length);\r\n    } else {\r\n        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\r\n    }\r\n    if (read >= 0) {\r\n        current.crc.update(buffer, offset, read);\r\n    }\r\n    return read;\r\n}","lc":0.7272727273,"pi":-0.2822966507,"ma":1.8,"nbd":0.5,"ml":1.8333333333,"d":1.9305555556,"mi":-0.6242424242,"fo":1.0,"r":-0.0263157895,"e":3.6739729027}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3028_89317b28","label":0,"code":"\/**\r\n * Creates an update operation for the document with the given id. The\r\n * changes are shared with the this update operation.\r\n *\r\n * @param id the primary key.\r\n *\/\r\npublic UpdateOp shallowCopy(String id) {\r\n    return new UpdateOp(id, isNew, isDelete, changes);\r\n}","code_comment":"\/**\r\n * Creates an update operation for the document with the given id. The\r\n * changes are shared with the this update operation.\r\n *\r\n * @param id the primary key.\r\n *\/\r\n","code_no_comment":"public UpdateOp shallowCopy(String id) {\r\n    return new UpdateOp(id, isNew, isDelete, changes);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9709654686,"fo":-0.5,"r":2.3947368421,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1153_9f924f10","label":1,"code":"@Override\r\npublic PropertiesConfiguration getConfiguration(ConfigurationSource source) {\r\n    final InputStream configStream = source.getInputStream();\r\n    Properties properties = new Properties();\r\n    try {\r\n        properties.load(configStream);\r\n    } catch (IOException ioe) {\r\n        throw new ConfigurationException(\"Unable to load \" + source.toString(), ioe);\r\n    }\r\n    ConfigurationBuilder<PropertiesConfiguration> builder = newConfigurationBuilder(PropertiesConfiguration.class);\r\n    String value = properties.getProperty(STATUS_KEY);\r\n    if (value != null) {\r\n        builder.setStatusLevel(Level.toLevel(value, Level.ERROR));\r\n    } else {\r\n        builder.setStatusLevel(Level.ERROR);\r\n    }\r\n    value = properties.getProperty(SHUTDOWN_HOOK);\r\n    if (value != null) {\r\n        builder.setShutdownHook(value);\r\n    }\r\n    value = properties.getProperty(VERBOSE);\r\n    if (value != null) {\r\n        builder.setVerbosity(value);\r\n    }\r\n    value = properties.getProperty(PACKAGES);\r\n    if (value != null) {\r\n        builder.setPackages(value);\r\n    }\r\n    value = properties.getProperty(CONFIG_NAME);\r\n    if (value != null) {\r\n        builder.setConfigurationName(value);\r\n    }\r\n    value = properties.getProperty(MONITOR_INTERVAL);\r\n    if (value != null) {\r\n        builder.setMonitorInterval(value);\r\n    }\r\n    value = properties.getProperty(ADVERTISER_KEY);\r\n    if (value != null) {\r\n        builder.setAdvertiser(value);\r\n    }\r\n    Properties props = PropertiesUtil.extractSubset(properties, \"property\");\r\n    for (String key : props.stringPropertyNames()) {\r\n        builder.addProperty(key, props.getProperty(key));\r\n    }\r\n    Properties levelProps = PropertiesUtil.extractSubset(properties, \"customLevel\");\r\n    if (levelProps.size() > 0) {\r\n        for (String key : levelProps.stringPropertyNames()) {\r\n            builder.add(builder.newCustomLevel(key, Integer.parseInt(props.getProperty(key))));\r\n        }\r\n    }\r\n    String filterProp = properties.getProperty(\"filters\");\r\n    if (filterProp != null) {\r\n        String[] filterNames = filterProp.split(\",\");\r\n        for (String filterName : filterNames) {\r\n            String name = filterName.trim();\r\n            builder.add(createFilter(builder, name, PropertiesUtil.extractSubset(properties, \"filter.\" + name)));\r\n        }\r\n    }\r\n    String appenderProp = properties.getProperty(\"appenders\");\r\n    if (appenderProp != null) {\r\n        String[] appenderNames = appenderProp.split(\",\");\r\n        for (String appenderName : appenderNames) {\r\n            String name = appenderName.trim();\r\n            builder.add(createAppender(builder, name, PropertiesUtil.extractSubset(properties, \"appender.\" + name)));\r\n        }\r\n    }\r\n    String loggerProp = properties.getProperty(\"loggers\");\r\n    if (appenderProp != null) {\r\n        String[] loggerNames = loggerProp.split(\",\");\r\n        for (String loggerName : loggerNames) {\r\n            String name = loggerName.trim();\r\n            if (!name.equals(LoggerConfig.ROOT)) {\r\n                builder.add(createLogger(builder, name, PropertiesUtil.extractSubset(properties, \"logger.\" + name)));\r\n            }\r\n        }\r\n    }\r\n    props = PropertiesUtil.extractSubset(properties, \"rootLogger\");\r\n    if (props.size() > 0) {\r\n        builder.add(createRootLogger(builder, props));\r\n    }\r\n    return builder.build();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic PropertiesConfiguration getConfiguration(ConfigurationSource source) {\r\n    final InputStream configStream = source.getInputStream();\r\n    Properties properties = new Properties();\r\n    try {\r\n        properties.load(configStream);\r\n    } catch (IOException ioe) {\r\n        throw new ConfigurationException(\"Unable to load \" + source.toString(), ioe);\r\n    }\r\n    ConfigurationBuilder<PropertiesConfiguration> builder = newConfigurationBuilder(PropertiesConfiguration.class);\r\n    String value = properties.getProperty(STATUS_KEY);\r\n    if (value != null) {\r\n        builder.setStatusLevel(Level.toLevel(value, Level.ERROR));\r\n    } else {\r\n        builder.setStatusLevel(Level.ERROR);\r\n    }\r\n    value = properties.getProperty(SHUTDOWN_HOOK);\r\n    if (value != null) {\r\n        builder.setShutdownHook(value);\r\n    }\r\n    value = properties.getProperty(VERBOSE);\r\n    if (value != null) {\r\n        builder.setVerbosity(value);\r\n    }\r\n    value = properties.getProperty(PACKAGES);\r\n    if (value != null) {\r\n        builder.setPackages(value);\r\n    }\r\n    value = properties.getProperty(CONFIG_NAME);\r\n    if (value != null) {\r\n        builder.setConfigurationName(value);\r\n    }\r\n    value = properties.getProperty(MONITOR_INTERVAL);\r\n    if (value != null) {\r\n        builder.setMonitorInterval(value);\r\n    }\r\n    value = properties.getProperty(ADVERTISER_KEY);\r\n    if (value != null) {\r\n        builder.setAdvertiser(value);\r\n    }\r\n    Properties props = PropertiesUtil.extractSubset(properties, \"property\");\r\n    for (String key : props.stringPropertyNames()) {\r\n        builder.addProperty(key, props.getProperty(key));\r\n    }\r\n    Properties levelProps = PropertiesUtil.extractSubset(properties, \"customLevel\");\r\n    if (levelProps.size() > 0) {\r\n        for (String key : levelProps.stringPropertyNames()) {\r\n            builder.add(builder.newCustomLevel(key, Integer.parseInt(props.getProperty(key))));\r\n        }\r\n    }\r\n    String filterProp = properties.getProperty(\"filters\");\r\n    if (filterProp != null) {\r\n        String[] filterNames = filterProp.split(\",\");\r\n        for (String filterName : filterNames) {\r\n            String name = filterName.trim();\r\n            builder.add(createFilter(builder, name, PropertiesUtil.extractSubset(properties, \"filter.\" + name)));\r\n        }\r\n    }\r\n    String appenderProp = properties.getProperty(\"appenders\");\r\n    if (appenderProp != null) {\r\n        String[] appenderNames = appenderProp.split(\",\");\r\n        for (String appenderName : appenderNames) {\r\n            String name = appenderName.trim();\r\n            builder.add(createAppender(builder, name, PropertiesUtil.extractSubset(properties, \"appender.\" + name)));\r\n        }\r\n    }\r\n    String loggerProp = properties.getProperty(\"loggers\");\r\n    if (appenderProp != null) {\r\n        String[] loggerNames = loggerProp.split(\",\");\r\n        for (String loggerName : loggerNames) {\r\n            String name = loggerName.trim();\r\n            if (!name.equals(LoggerConfig.ROOT)) {\r\n                builder.add(createLogger(builder, name, PropertiesUtil.extractSubset(properties, \"logger.\" + name)));\r\n            }\r\n        }\r\n    }\r\n    props = PropertiesUtil.extractSubset(properties, \"rootLogger\");\r\n    if (props.size() > 0) {\r\n        builder.add(createRootLogger(builder, props));\r\n    }\r\n    return builder.build();\r\n}","lc":3.0909090909,"pi":0.038277512,"ma":3.4,"nbd":0.5,"ml":1.1666666667,"d":0.7916666667,"mi":-1.2728682171,"fo":4.0833333333,"r":-0.0263157895,"e":4.7832391095}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-296_5449bf39","label":1,"code":"\/**\r\n * Check if a path is a (direct or indirect) ancestor of another path.\r\n *\r\n * @param ancestor the ancestor path\r\n * @param path the potential offspring path\r\n * @return true if the path is an offspring of the ancestor\r\n *\/\r\npublic static boolean isAncestor(String ancestor, String path) {\r\n    assert isValid(ancestor);\r\n    assert isValid(path);\r\n    if (ancestor.isEmpty() || path.isEmpty()) {\r\n        return false;\r\n    }\r\n    if (!denotesRoot(ancestor)) {\r\n        ancestor += \"\/\";\r\n    }\r\n    return path.startsWith(ancestor);\r\n}","code_comment":"\/**\r\n * Check if a path is a (direct or indirect) ancestor of another path.\r\n *\r\n * @param ancestor the ancestor path\r\n * @param path the potential offspring path\r\n * @return true if the path is an offspring of the ancestor\r\n *\/\r\n","code_no_comment":"public static boolean isAncestor(String ancestor, String path) {\r\n    assert isValid(ancestor);\r\n    assert isValid(path);\r\n    if (ancestor.isEmpty() || path.isEmpty()) {\r\n        return false;\r\n    }\r\n    if (!denotesRoot(ancestor)) {\r\n        ancestor += \"\/\";\r\n    }\r\n    return path.startsWith(ancestor);\r\n}","lc":-0.1363636364,"pi":-0.2775119617,"ma":-0.2,"nbd":-0.5,"ml":0.1666666667,"d":-0.3650793651,"mi":0.4770965469,"fo":0.0,"r":0.3421052632,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-846_7acb091a","label":3,"code":"@Override\r\nvoid uncommittedModification(Revision uncommitted) {\r\n\/\/ do nothing\r\n}","code_comment":null,"code_no_comment":"@Override\r\nvoid uncommittedModification(Revision uncommitted) {\r\n}","lc":-0.5,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.5,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-548_717186d6","label":1,"code":"@Override\r\npublic void childNodeAdded(String name, NodeState after) {\r\n    if (addedNodes.containsKey(after)) {\r\n        \/\/ moved node, will be processed separately\r\n        return;\r\n    }\r\n    String p = PathUtils.concat(getCurrentPath(), name);\r\n    if (p.startsWith(pathFilter)) {\r\n        buff.tag('+').key(p).object();\r\n        toJson(buff, after);\r\n        buff.endObject().newline();\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void childNodeAdded(String name, NodeState after) {\r\n    if (addedNodes.containsKey(after)) {\r\n                return;\r\n    }\r\n    String p = PathUtils.concat(getCurrentPath(), name);\r\n    if (p.startsWith(pathFilter)) {\r\n        buff.tag('+').key(p).object();\r\n        toJson(buff, after);\r\n        buff.endObject().newline();\r\n    }\r\n}","lc":-0.0909090909,"pi":0.023923445,"ma":-0.2,"nbd":-0.5,"ml":0.0833333333,"d":-0.3650793651,"mi":0.0920366455,"fo":0.3333333333,"r":0.1315789474,"e":-0.1627934049}
{"project_name":"Closure","project_version":"166","label":2,"code":"@Override\r\npublic void matchConstraint(JSType constraint) {\r\n    \/\/ We only want to match constraints on anonymous types.\r\n    if (hasReferenceName()) {\r\n        return;\r\n    }\r\n    \/\/ properties on this object.\r\n    if (constraint.isRecordType()) {\r\n        matchRecordTypeConstraint(constraint.toObjectType());\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void matchConstraint(JSType constraint) {\r\n        if (hasReferenceName()) {\r\n        return;\r\n    }\r\n        if (constraint.isRecordType()) {\r\n        matchRecordTypeConstraint(constraint.toObjectType());\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.4342494715,"fo":-0.1666666667,"r":1.9210526316,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3281_f7dd2fff","label":1,"code":"\/**\r\n * <a href=\"http:\/\/camel.apache.org\/oncompletion.html\">On completion<\/a>\r\n * callback for doing custom routing when the {@link org.apache.camel.Exchange} is complete.\r\n *\r\n * @return the builder\r\n *\/\r\npublic OnCompletionDefinition onCompletion() {\r\n    routeCollection.setCamelContext(getContext());\r\n    return routeCollection.onCompletion();\r\n}","code_comment":"\/**\r\n * <a href=\"http:\/\/camel.apache.org\/oncompletion.html\">On completion<\/a>\r\n * callback for doing custom routing when the {@link org.apache.camel.Exchange} is complete.\r\n *\r\n * @return the builder\r\n *\/\r\n","code_no_comment":"public OnCompletionDefinition onCompletion() {\r\n    routeCollection.setCamelContext(getContext());\r\n    return routeCollection.onCompletion();\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8940098661,"fo":-0.25,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3530_4d231938","label":1,"code":"public int getType(Tree tree) {\r\n    if (tree.isRoot()) {\r\n        return TYPE_DEFAULT;\r\n    } else {\r\n        return getType(tree, getType(tree.getParent()));\r\n    }\r\n}","code_comment":null,"code_no_comment":"public int getType(Tree tree) {\r\n    if (tree.isRoot()) {\r\n        return TYPE_DEFAULT;\r\n    } else {\r\n        return getType(tree, getType(tree.getParent()));\r\n    }\r\n}","lc":-0.3181818182,"pi":0.014354067,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.5605355884,"fo":-0.1666666667,"r":0.3947368421,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3534_734ba01d","label":0,"code":"public void fail(Throwable t) {\r\n    while (true) {\r\n        JobStatus current = state;\r\n        if (current == JobStatus.FAILED || current == JobStatus.FAILING) {\r\n            return;\r\n        } else if (transitionState(current, JobStatus.FAILING, t)) {\r\n            this.failureCause = t;\r\n            if (!verticesInCreationOrder.isEmpty()) {\r\n                \/\/ cancel all. what is failed will not cancel but stay failed\r\n                for (ExecutionJobVertex ejv : verticesInCreationOrder) {\r\n                    ejv.cancel();\r\n                }\r\n            } else {\r\n                \/\/ set the state of the job to failed\r\n                transitionState(JobStatus.FAILING, JobStatus.FAILED, t);\r\n            }\r\n            return;\r\n        }\r\n    \/\/ no need to treat other states\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void fail(Throwable t) {\r\n    while (true) {\r\n        JobStatus current = state;\r\n        if (current == JobStatus.FAILED || current == JobStatus.FAILING) {\r\n            return;\r\n        } else if (transitionState(current, JobStatus.FAILING, t)) {\r\n            this.failureCause = t;\r\n            if (!verticesInCreationOrder.isEmpty()) {\r\n                                for (ExecutionJobVertex ejv : verticesInCreationOrder) {\r\n                    ejv.cancel();\r\n                }\r\n            } else {\r\n                                transitionState(JobStatus.FAILING, JobStatus.FAILED, t);\r\n            }\r\n            return;\r\n        }\r\n        }\r\n}","lc":0.1818181818,"pi":1.1387559809,"ma":0.4,"nbd":1.5,"ml":0.3333333333,"d":0.4285714286,"mi":-0.1388301621,"fo":-0.1666666667,"r":0.0263157895,"e":0.161207448}
{"project_name":"Math","project_version":"97","label":3,"code":"\/**\r\n * Find a zero in the given interval.\r\n * <p>\r\n * Requires that the values of the function at the endpoints have opposite\r\n * signs. An <code>IllegalArgumentException<\/code> is thrown if this is not\r\n * the case.<\/p>\r\n *\r\n * @param min the lower bound for the interval.\r\n * @param max the upper bound for the interval.\r\n * @return the value where the function is zero\r\n * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\r\n * @throws FunctionEvaluationException if an error occurs evaluating the\r\n * function\r\n * @throws IllegalArgumentException if min is not less than max or the\r\n * signs of the values of the function at the endpoints are not opposites\r\n *\/\r\npublic double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    clearResult();\r\n    verifyInterval(min, max);\r\n    double ret = Double.NaN;\r\n    double yMin = f.value(min);\r\n    double yMax = f.value(max);\r\n    \/\/ Verify bracketing\r\n    double sign = yMin * yMax;\r\n    if (sign >= 0) {\r\n        \/\/ neither value is close to zero and min and max do not bracket root.\r\n        throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\r\n    } else {\r\n        \/\/ solve using only the first endpoint as initial guess\r\n        ret = solve(min, yMin, max, yMax, min, yMin);\r\n    \/\/ either min or max is a root\r\n    }\r\n    return ret;\r\n}","code_comment":"\/**\r\n * Find a zero in the given interval.\r\n * <p>\r\n * Requires that the values of the function at the endpoints have opposite\r\n * signs. An <code>IllegalArgumentException<\/code> is thrown if this is not\r\n * the case.<\/p>\r\n *\r\n * @param min the lower bound for the interval.\r\n * @param max the upper bound for the interval.\r\n * @return the value where the function is zero\r\n * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\r\n * @throws FunctionEvaluationException if an error occurs evaluating the\r\n * function\r\n * @throws IllegalArgumentException if min is not less than max or the\r\n * signs of the values of the function at the endpoints are not opposites\r\n *\/\r\n","code_no_comment":"public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    clearResult();\r\n    verifyInterval(min, max);\r\n    double ret = Double.NaN;\r\n    double yMin = f.value(min);\r\n    double yMax = f.value(max);\r\n        double sign = yMin * yMax;\r\n    if (sign >= 0) {\r\n                throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\r\n    } else {\r\n                ret = solve(min, yMin, max, yMax, min, yMin);\r\n        }\r\n    return ret;\r\n}","lc":0.0,"pi":-0.4066985646,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":0.4464285714,"mi":-0.0655391121,"fo":-0.0833333333,"r":-0.0263157895,"e":0.3389268281}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2121_03340919","label":3,"code":"protected FileBaseStatistics getFileStats(FileBaseStatistics cachedStats, Path filePath, FileSystem fs, ArrayList<FileStatus> files) throws IOException {\r\n    \/\/ get the file info and check whether the cached statistics are still valid.\r\n    final FileStatus file = fs.getFileStatus(filePath);\r\n    long totalLength = 0;\r\n    \/\/ enumerate all files\r\n    if (file.isDir()) {\r\n        totalLength += addFilesInDir(file.getPath(), files, totalLength, false);\r\n    } else {\r\n        files.add(file);\r\n        testForUnsplittable(file);\r\n        totalLength += file.getLen();\r\n    }\r\n    \/\/ check the modification time stamp\r\n    long latestModTime = 0;\r\n    for (FileStatus f : files) {\r\n        latestModTime = Math.max(f.getModificationTime(), latestModTime);\r\n    }\r\n    \/\/ check whether the cached statistics are still valid, if we have any\r\n    if (cachedStats != null && latestModTime <= cachedStats.getLastModificationTime()) {\r\n        return cachedStats;\r\n    }\r\n    \/\/ sanity check\r\n    if (totalLength <= 0) {\r\n        totalLength = BaseStatistics.SIZE_UNKNOWN;\r\n    }\r\n    return new FileBaseStatistics(latestModTime, totalLength, BaseStatistics.AVG_RECORD_BYTES_UNKNOWN);\r\n}","code_comment":null,"code_no_comment":"protected FileBaseStatistics getFileStats(FileBaseStatistics cachedStats, Path filePath, FileSystem fs, ArrayList<FileStatus> files) throws IOException {\r\n        final FileStatus file = fs.getFileStatus(filePath);\r\n    long totalLength = 0;\r\n        if (file.isDir()) {\r\n        totalLength += addFilesInDir(file.getPath(), files, totalLength, false);\r\n    } else {\r\n        files.add(file);\r\n        testForUnsplittable(file);\r\n        totalLength += file.getLen();\r\n    }\r\n        long latestModTime = 0;\r\n    for (FileStatus f : files) {\r\n        latestModTime = Math.max(f.getModificationTime(), latestModTime);\r\n    }\r\n        if (cachedStats != null && latestModTime <= cachedStats.getLastModificationTime()) {\r\n        return cachedStats;\r\n    }\r\n        if (totalLength <= 0) {\r\n        totalLength = BaseStatistics.SIZE_UNKNOWN;\r\n    }\r\n    return new FileBaseStatistics(latestModTime, totalLength, BaseStatistics.AVG_RECORD_BYTES_UNKNOWN);\r\n}","lc":0.3636363636,"pi":-0.2870813397,"ma":0.2,"nbd":-0.5,"ml":0.3333333333,"d":0.4047619048,"mi":-0.3423537703,"fo":0.3333333333,"r":-0.0263157895,"e":0.5410533474}
{"project_name":"Csv","project_version":"6","label":1,"code":"\/**\r\n * Puts all values of this record into the given Map.\r\n *\r\n * @param map The Map to populate.\r\n * @return the given map.\r\n *\/\r\n<M extends Map<String, String>> M putIn(final M map) {\r\n    for (final Entry<String, Integer> entry : mapping.entrySet()) {\r\n        final int col = entry.getValue().intValue();\r\n        map.put(entry.getKey(), values[col]);\r\n    }\r\n    return map;\r\n}","code_comment":"\/**\r\n * Puts all values of this record into the given Map.\r\n *\r\n * @param map The Map to populate.\r\n * @return the given map.\r\n *\/\r\n","code_no_comment":"<M extends Map<String, String>> M putIn(final M map) {\r\n    for (final Entry<String, Integer> entry : mapping.entrySet()) {\r\n        final int col = entry.getValue().intValue();\r\n        map.put(entry.getKey(), values[col]);\r\n    }\r\n    return map;\r\n}","lc":-0.3181818182,"pi":0.014354067,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.3835095137,"fo":-0.0833333333,"r":0.7894736842,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5209_87884c7b","label":3,"code":"\/\/ TODO: this checking for file == null happens because the resolver has been confused about the root\r\n\/\/ artifact or not. things like the stupid dummy artifact coming from surefire.\r\npublic List<String> getTestClasspathElements() throws DependencyResolutionRequiredException {\r\n    List<String> list = new ArrayList<String>(getArtifacts().size() + 2);\r\n    list.add(getBuild().getTestOutputDirectory());\r\n    list.add(getBuild().getOutputDirectory());\r\n    for (Artifact a : getArtifacts()) {\r\n        if (a.getArtifactHandler().isAddedToClasspath()) {\r\n            addArtifactPath(a, list);\r\n        }\r\n    }\r\n    return list;\r\n}","code_comment":null,"code_no_comment":"public List<String> getTestClasspathElements() throws DependencyResolutionRequiredException {\r\n    List<String> list = new ArrayList<String>(getArtifacts().size() + 2);\r\n    list.add(getBuild().getTestOutputDirectory());\r\n    list.add(getBuild().getOutputDirectory());\r\n    for (Artifact a : getArtifacts()) {\r\n        if (a.getArtifactHandler().isAddedToClasspath()) {\r\n            addArtifactPath(a, list);\r\n        }\r\n    }\r\n    return list;\r\n}","lc":-0.1363636364,"pi":0.1626794258,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.0416666667,"mi":0.1337561663,"fo":0.5,"r":0.0,"e":-0.053763478}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public removeTableProperty_result getResult(I iface, removeTableProperty_args args) throws org.apache.thrift.TException {\r\n    removeTableProperty_result result = new removeTableProperty_result();\r\n    try {\r\n        iface.removeTableProperty(args.login, args.tableName, args.property);\r\n    } catch (AccumuloException ouch1) {\r\n        result.ouch1 = ouch1;\r\n    } catch (AccumuloSecurityException ouch2) {\r\n        result.ouch2 = ouch2;\r\n    }\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"public removeTableProperty_result getResult(I iface, removeTableProperty_args args) throws org.apache.thrift.TException {\r\n    removeTableProperty_result result = new removeTableProperty_result();\r\n    try {\r\n        iface.removeTableProperty(args.login, args.tableName, args.property);\r\n    } catch (AccumuloException ouch1) {\r\n        result.ouch1 = ouch1;\r\n    } catch (AccumuloSecurityException ouch2) {\r\n        result.ouch2 = ouch2;\r\n    }\r\n    return result;\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.1207892882,"fo":-0.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3099_25850476","label":3,"code":"private void disconnect(NodeDocument splitDoc) {\r\n    String splitId = splitDoc.getId();\r\n    String mainId = Utils.getIdFromPath(splitDoc.getMainPath());\r\n    NodeDocument doc = store.find(NODES, mainId);\r\n    if (doc == null) {\r\n        LOG.warn(\"Main document {} already removed. Split document is {}\", mainId, splitId);\r\n        return;\r\n    }\r\n    int slashIdx = splitId.lastIndexOf('\/');\r\n    int height = Integer.parseInt(splitId.substring(slashIdx + 1));\r\n    Revision rev = Revision.fromString(splitId.substring(splitId.lastIndexOf('\/', slashIdx - 1) + 1, slashIdx));\r\n    doc = doc.findPrevReferencingDoc(rev, height);\r\n    if (doc == null) {\r\n        LOG.warn(\"Split document {} not referenced anymore. Main document is {}\", splitId, mainId);\r\n        return;\r\n    }\r\n    \/\/ remove reference\r\n    if (doc.getSplitDocType() == INTERMEDIATE) {\r\n        disconnectFromIntermediate(doc, rev);\r\n    } else {\r\n        markStaleOnMain(doc, rev, height);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void disconnect(NodeDocument splitDoc) {\r\n    String splitId = splitDoc.getId();\r\n    String mainId = Utils.getIdFromPath(splitDoc.getMainPath());\r\n    NodeDocument doc = store.find(NODES, mainId);\r\n    if (doc == null) {\r\n        LOG.warn(\"Main document {} already removed. Split document is {}\", mainId, splitId);\r\n        return;\r\n    }\r\n    int slashIdx = splitId.lastIndexOf('\/');\r\n    int height = Integer.parseInt(splitId.substring(slashIdx + 1));\r\n    Revision rev = Revision.fromString(splitId.substring(splitId.lastIndexOf('\/', slashIdx - 1) + 1, slashIdx));\r\n    doc = doc.findPrevReferencingDoc(rev, height);\r\n    if (doc == null) {\r\n        LOG.warn(\"Split document {} not referenced anymore. Main document is {}\", splitId, mainId);\r\n        return;\r\n    }\r\n        if (doc.getSplitDocType() == INTERMEDIATE) {\r\n        disconnectFromIntermediate(doc, rev);\r\n    } else {\r\n        markStaleOnMain(doc, rev, height);\r\n    }\r\n}","lc":0.3636363636,"pi":-0.3301435407,"ma":0.0,"nbd":-0.5,"ml":0.0,"d":0.4404761905,"mi":-0.3578576462,"fo":0.8333333333,"r":-0.0263157895,"e":0.6929640451}
{"project_name":"Closure","project_version":"104","label":2,"code":"JSType meet(JSType that) {\r\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\r\n    for (JSType alternate : alternates) {\r\n        if (alternate.isSubtype(that)) {\r\n            builder.addAlternate(alternate);\r\n        }\r\n    }\r\n    if (that instanceof UnionType) {\r\n        for (JSType otherAlternate : ((UnionType) that).alternates) {\r\n            if (otherAlternate.isSubtype(this)) {\r\n                builder.addAlternate(otherAlternate);\r\n            }\r\n        }\r\n    } else if (that.isSubtype(this)) {\r\n        builder.addAlternate(that);\r\n    }\r\n    JSType result = builder.build();\r\n    if (result != null) {\r\n        return result;\r\n    } else if (this.isObject() && that.isObject()) {\r\n        return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\r\n    } else {\r\n        return getNativeType(JSTypeNative.NO_TYPE);\r\n    }\r\n}","code_comment":null,"code_no_comment":"JSType meet(JSType that) {\r\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\r\n    for (JSType alternate : alternates) {\r\n        if (alternate.isSubtype(that)) {\r\n            builder.addAlternate(alternate);\r\n        }\r\n    }\r\n    if (that instanceof UnionType) {\r\n        for (JSType otherAlternate : ((UnionType) that).alternates) {\r\n            if (otherAlternate.isSubtype(this)) {\r\n                builder.addAlternate(otherAlternate);\r\n            }\r\n        }\r\n    } else if (that.isSubtype(this)) {\r\n        builder.addAlternate(that);\r\n    }\r\n    JSType result = builder.build();\r\n    if (result != null) {\r\n        return result;\r\n    } else if (this.isObject() && that.isObject()) {\r\n        return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\r\n    } else {\r\n        return getNativeType(JSTypeNative.NO_TYPE);\r\n    }\r\n}","lc":0.5,"pi":0.3636363636,"ma":1.0,"nbd":0.5,"ml":0.75,"d":0.1170634921,"mi":-0.3612403101,"fo":0.4166666667,"r":-0.0263157895,"e":0.1195530276}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-776_dc9f23d9","label":3,"code":"\/**\r\n * A convenience method for setting the end timestamp accepted by the timestamp filter.\r\n *\r\n * @param is\r\n *          the iterator setting object to configure\r\n * @param end\r\n *          the end timestamp\r\n * @param endInclusive\r\n *          boolean indicating whether the end is inclusive\r\n *\/\r\npublic static void setEnd(IteratorSetting is, long end, boolean endInclusive) {\r\n    SimpleDateFormat dateParser = initDateParser();\r\n    is.addOption(END, dateParser.format(new Date(end)));\r\n    is.addOption(END_INCL, Boolean.toString(endInclusive));\r\n}","code_comment":"\/**\r\n * A convenience method for setting the end timestamp accepted by the timestamp filter.\r\n *\r\n * @param is\r\n *          the iterator setting object to configure\r\n * @param end\r\n *          the end timestamp\r\n * @param endInclusive\r\n *          boolean indicating whether the end is inclusive\r\n *\/\r\n","code_no_comment":"public static void setEnd(IteratorSetting is, long end, boolean endInclusive) {\r\n    SimpleDateFormat dateParser = initDateParser();\r\n    is.addOption(END, dateParser.format(new Date(end)));\r\n    is.addOption(END_INCL, Boolean.toString(endInclusive));\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5701198027,"fo":-0.0833333333,"r":1.8421052632,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-428_d906576c","label":3,"code":"public Iterator iterator() {\r\n    return new Iterator() {\r\n\r\n        public boolean hasNext() {\r\n            return index < MicroMap.this.size();\r\n        }\r\n\r\n        public Object next() {\r\n            index++;\r\n            return key;\r\n        }\r\n\r\n        public void remove() {\r\n            MicroMap.this.clear();\r\n        }\r\n\r\n        int index;\r\n    };\r\n}","code_comment":null,"code_no_comment":"public Iterator iterator() {\r\n    return new Iterator() {\r\n\r\n        public boolean hasNext() {\r\n            return index < MicroMap.this.size();\r\n        }\r\n\r\n        public Object next() {\r\n            index++;\r\n            return key;\r\n        }\r\n\r\n        public void remove() {\r\n            MicroMap.this.clear();\r\n        }\r\n\r\n        int index;\r\n    };\r\n}","lc":0.0454545455,"pi":0.4019138756,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.1011904762,"mi":0.1148696265,"fo":-0.3333333333,"r":2.1578947368,"e":-0.1206641195}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2047_ca63fdf3","label":0,"code":"\/**\r\n * Copies the full content from the source to the target repository.\r\n * <p>\r\n * The source repository <strong>must not be modified<\/strong> while\r\n * the copy operation is running to avoid an inconsistent copy.\r\n * <p>\r\n * Note that both the source and the target repository must be closed\r\n * during the copy operation as this method requires exclusive access\r\n * to the repositories.\r\n *\r\n * @param initializer optional extra repository initializer to use\r\n * @throws RepositoryException if the copy operation fails\r\n *\/\r\npublic void copy(RepositoryInitializer initializer) throws RepositoryException {\r\n    RepositoryConfig config = source.getRepositoryConfig();\r\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\r\n    try {\r\n        NodeState base = target.getRoot();\r\n        NodeBuilder builder = base.builder();\r\n        String workspaceName = source.getRepositoryConfig().getDefaultWorkspaceName();\r\n        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\r\n        \/\/ init target repository first\r\n        new InitialContent().initialize(builder);\r\n        if (initializer != null) {\r\n            initializer.initialize(builder);\r\n        }\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            sc.getWorkspaceInitializer().initialize(builder, workspaceName);\r\n        }\r\n        HashBiMap<String, String> uriToPrefix = HashBiMap.create();\r\n        Map<Integer, String> idxToPrefix = newHashMap();\r\n        copyNamespaces(builder, uriToPrefix, idxToPrefix);\r\n        copyNodeTypes(builder, uriToPrefix.inverse());\r\n        copyPrivileges(builder);\r\n        \/\/ Triggers compilation of type information, which we need for\r\n        \/\/ the type predicates used by the bulk  copy operations below.\r\n        new TypeEditorProvider(false).getRootEditor(base, builder.getNodeState(), builder, null);\r\n        Map<String, String> versionablePaths = newHashMap();\r\n        NodeState root = builder.getNodeState();\r\n        copyWorkspace(builder, root, workspaceName, uriToPrefix, idxToPrefix, versionablePaths);\r\n        copyVersionStore(builder, root, workspaceName, uriToPrefix, idxToPrefix, versionablePaths);\r\n        logger.info(\"Applying default commit hooks\");\r\n        \/\/ TODO: default hooks?\r\n        List<CommitHook> hooks = newArrayList();\r\n        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);\r\n        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\r\n        \/\/ hooks specific to the upgrade, need to run first\r\n        hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath))));\r\n        \/\/ security-related hooks\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            hooks.addAll(sc.getCommitHooks(workspaceName));\r\n        }\r\n        \/\/ type validation, reference and indexing hooks\r\n        hooks.add(new EditorHook(new CompositeEditorProvider(createTypeEditorProvider(), createIndexEditorProvider())));\r\n        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);\r\n    } catch (Exception e) {\r\n        throw new RepositoryException(\"Failed to copy content\", e);\r\n    }\r\n}","code_comment":"\/**\r\n * Copies the full content from the source to the target repository.\r\n * <p>\r\n * The source repository <strong>must not be modified<\/strong> while\r\n * the copy operation is running to avoid an inconsistent copy.\r\n * <p>\r\n * Note that both the source and the target repository must be closed\r\n * during the copy operation as this method requires exclusive access\r\n * to the repositories.\r\n *\r\n * @param initializer optional extra repository initializer to use\r\n * @throws RepositoryException if the copy operation fails\r\n *\/\r\n","code_no_comment":"public void copy(RepositoryInitializer initializer) throws RepositoryException {\r\n    RepositoryConfig config = source.getRepositoryConfig();\r\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\r\n    try {\r\n        NodeState base = target.getRoot();\r\n        NodeBuilder builder = base.builder();\r\n        String workspaceName = source.getRepositoryConfig().getDefaultWorkspaceName();\r\n        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\r\n                new InitialContent().initialize(builder);\r\n        if (initializer != null) {\r\n            initializer.initialize(builder);\r\n        }\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            sc.getWorkspaceInitializer().initialize(builder, workspaceName);\r\n        }\r\n        HashBiMap<String, String> uriToPrefix = HashBiMap.create();\r\n        Map<Integer, String> idxToPrefix = newHashMap();\r\n        copyNamespaces(builder, uriToPrefix, idxToPrefix);\r\n        copyNodeTypes(builder, uriToPrefix.inverse());\r\n        copyPrivileges(builder);\r\n                        new TypeEditorProvider(false).getRootEditor(base, builder.getNodeState(), builder, null);\r\n        Map<String, String> versionablePaths = newHashMap();\r\n        NodeState root = builder.getNodeState();\r\n        copyWorkspace(builder, root, workspaceName, uriToPrefix, idxToPrefix, versionablePaths);\r\n        copyVersionStore(builder, root, workspaceName, uriToPrefix, idxToPrefix, versionablePaths);\r\n        logger.info(\"Applying default commit hooks\");\r\n                List<CommitHook> hooks = newArrayList();\r\n        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);\r\n        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\r\n                hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath))));\r\n                for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            hooks.addAll(sc.getCommitHooks(workspaceName));\r\n        }\r\n                hooks.add(new EditorHook(new CompositeEditorProvider(createTypeEditorProvider(), createIndexEditorProvider())));\r\n        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);\r\n    } catch (Exception e) {\r\n        throw new RepositoryException(\"Failed to copy content\", e);\r\n    }\r\n}","lc":1.1363636364,"pi":-0.2392344498,"ma":0.4,"nbd":0.0,"ml":-0.25,"d":0.0119047619,"mi":-0.7603946441,"fo":2.8333333333,"r":-0.0263157895,"e":0.7990940682}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4658_ef3adb12","label":3,"code":"private void setCurrentTab(int index) {\r\n    if (this.currentTab == index) {\r\n        \/\/ already current\r\n        return;\r\n    }\r\n    this.currentTab = index;\r\n    final Component component;\r\n    if (currentTab == -1 || (tabs.size() == 0) || !isTabVisible(currentTab)) {\r\n        \/\/ no tabs or the current tab is not visible\r\n        component = newPanel();\r\n    } else {\r\n        \/\/ show panel from selected tab\r\n        T tab = tabs.get(currentTab);\r\n        component = tab.getPanel(TAB_PANEL_ID);\r\n        if (component == null) {\r\n            throw new WicketRuntimeException(\"ITab.getPanel() returned null. TabbedPanel [\" + getPath() + \"] ITab index [\" + currentTab + \"]\");\r\n        }\r\n    }\r\n    if (!component.getId().equals(TAB_PANEL_ID)) {\r\n        throw new WicketRuntimeException(\"ITab.getPanel() returned a panel with invalid id [\" + component.getId() + \"]. You must always return a panel with id equal to the provided panelId parameter. TabbedPanel [\" + getPath() + \"] ITab index [\" + currentTab + \"]\");\r\n    }\r\n    addOrReplace(component);\r\n}","code_comment":null,"code_no_comment":"private void setCurrentTab(int index) {\r\n    if (this.currentTab == index) {\r\n                return;\r\n    }\r\n    this.currentTab = index;\r\n    final Component component;\r\n    if (currentTab == -1 || (tabs.size() == 0) || !isTabVisible(currentTab)) {\r\n                component = newPanel();\r\n    } else {\r\n                T tab = tabs.get(currentTab);\r\n        component = tab.getPanel(TAB_PANEL_ID);\r\n        if (component == null) {\r\n            throw new WicketRuntimeException(\"ITab.getPanel() returned null. TabbedPanel [\" + getPath() + \"] ITab index [\" + currentTab + \"]\");\r\n        }\r\n    }\r\n    if (!component.getId().equals(TAB_PANEL_ID)) {\r\n        throw new WicketRuntimeException(\"ITab.getPanel() returned a panel with invalid id [\" + component.getId() + \"]. You must always return a panel with id equal to the provided panelId parameter. TabbedPanel [\" + getPath() + \"] ITab index [\" + currentTab + \"]\");\r\n    }\r\n    addOrReplace(component);\r\n}","lc":0.2727272727,"pi":-0.038277512,"ma":0.6,"nbd":0.0,"ml":0.6666666667,"d":0.6984126984,"mi":-0.2862579281,"fo":0.4166666667,"r":0.0263157895,"e":0.6539421287}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1235_1beb2a50","label":1,"code":"\/**\r\n * Copies the full content from the source to the target repository.\r\n * <p>\r\n * The source repository <strong>must not be modified<\/strong> while\r\n * the copy operation is running to avoid an inconsistent copy.\r\n * <p>\r\n * This method leaves the search indexes of the target repository in\r\n * an\r\n * Note that both the source and the target repository must be closed\r\n * during the copy operation as this method requires exclusive access\r\n * to the repositories.\r\n *\r\n * @throws RepositoryException if the copy operation fails\r\n *\/\r\npublic void copy() throws RepositoryException {\r\n    logger.info(\"Copying repository content from {} to Oak\", source.getRepositoryConfig().getHomeDir());\r\n    try {\r\n        NodeBuilder builder = target.getRoot().builder();\r\n        Map<Integer, String> idxToPrefix = copyNamespaces(builder);\r\n        copyNodeTypes(builder);\r\n        copyVersionStore(builder, idxToPrefix);\r\n        copyWorkspaces(builder, idxToPrefix);\r\n        \/\/ TODO: default hooks?\r\n        CommitHook hook = new CompositeHook(new EditorHook(new RegistrationEditorProvider()), new EditorHook(new ReferenceEditorProvider()), new EditorHook(new GroupEditorProvider()));\r\n        target.merge(builder, hook, null);\r\n    } catch (Exception e) {\r\n        throw new RepositoryException(\"Failed to copy content\", e);\r\n    }\r\n}","code_comment":"\/**\r\n * Copies the full content from the source to the target repository.\r\n * <p>\r\n * The source repository <strong>must not be modified<\/strong> while\r\n * the copy operation is running to avoid an inconsistent copy.\r\n * <p>\r\n * This method leaves the search indexes of the target repository in\r\n * an\r\n * Note that both the source and the target repository must be closed\r\n * during the copy operation as this method requires exclusive access\r\n * to the repositories.\r\n *\r\n * @throws RepositoryException if the copy operation fails\r\n *\/\r\n","code_no_comment":"public void copy() throws RepositoryException {\r\n    logger.info(\"Copying repository content from {} to Oak\", source.getRepositoryConfig().getHomeDir());\r\n    try {\r\n        NodeBuilder builder = target.getRoot().builder();\r\n        Map<Integer, String> idxToPrefix = copyNamespaces(builder);\r\n        copyNodeTypes(builder);\r\n        copyVersionStore(builder, idxToPrefix);\r\n        copyWorkspaces(builder, idxToPrefix);\r\n                CommitHook hook = new CompositeHook(new EditorHook(new RegistrationEditorProvider()), new EditorHook(new ReferenceEditorProvider()), new EditorHook(new GroupEditorProvider()));\r\n        target.merge(builder, hook, null);\r\n    } catch (Exception e) {\r\n        throw new RepositoryException(\"Failed to copy content\", e);\r\n    }\r\n}","lc":0.0,"pi":-0.038277512,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.0587737844,"fo":0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4138_4d23d784","label":1,"code":"public static Option startRowOpt() {\r\n    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (NOT) inclusive\");\r\n    o.setArgName(\"begin-row\");\r\n    return o;\r\n}","code_comment":null,"code_no_comment":"public static Option startRowOpt() {\r\n    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (NOT) inclusive\");\r\n    o.setArgName(\"begin-row\");\r\n    return o;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6631430585,"fo":-0.4166666667,"r":0.2894736842,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-843_65390f8c","label":3,"code":"@Override\r\npublic void online(String tableName) throws AccumuloSecurityException, AccumuloException {\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void online(String tableName) throws AccumuloSecurityException, AccumuloException {\r\n}","lc":-0.5,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0329809725,"fo":-0.5,"r":1.6578947368,"e":-0.1627934049}
{"project_name":"Closure","project_version":"141","label":2,"code":"\/**\r\n * Query the DefinitionProvider for the list of definitions that\r\n * correspond to a given qualified name subtree.  Return null if\r\n * DefinitionProvider does not contain an entry for a given name,\r\n * one or more of the values returned by getDeclarations is not\r\n * callable, or the \"name\" node is not a GETPROP or NAME.\r\n *\r\n * @param definitionProvider The name reference graph\r\n * @param name Query node\r\n * @return non-empty definition list or null\r\n *\/\r\nprivate static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\r\n    List<Definition> result = Lists.newArrayList();\r\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\r\n        return null;\r\n    }\r\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\r\n    if (decls == null) {\r\n        return null;\r\n    }\r\n    for (Definition current : decls) {\r\n        Node rValue = current.getRValue();\r\n        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\r\n            result.add(current);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n * Query the DefinitionProvider for the list of definitions that\r\n * correspond to a given qualified name subtree.  Return null if\r\n * DefinitionProvider does not contain an entry for a given name,\r\n * one or more of the values returned by getDeclarations is not\r\n * callable, or the \"name\" node is not a GETPROP or NAME.\r\n *\r\n * @param definitionProvider The name reference graph\r\n * @param name Query node\r\n * @return non-empty definition list or null\r\n *\/\r\n","code_no_comment":"private static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) {\r\n    List<Definition> result = Lists.newArrayList();\r\n    if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\r\n        return null;\r\n    }\r\n    Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name);\r\n    if (decls == null) {\r\n        return null;\r\n    }\r\n    for (Definition current : decls) {\r\n        Node rValue = current.getRValue();\r\n        if ((rValue != null) && NodeUtil.isFunction(rValue)) {\r\n            result.add(current);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    return result;\r\n}","lc":0.2272727273,"pi":0.1291866029,"ma":0.2,"nbd":0.0,"ml":0.5,"d":0.4285714286,"mi":-0.2169133192,"fo":0.0833333333,"r":-0.0263157895,"e":0.3248053572}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-579_7d72e6ed","label":3,"code":"Iterator<ResultRowImpl> getRows() {\r\n    prepare();\r\n    Iterator<ResultRowImpl> it;\r\n    if (explain) {\r\n        String plan = source.getPlan(rootState);\r\n        columns = new ColumnImpl[] { new ColumnImpl(\"explain\", \"plan\", \"plan\") };\r\n        ResultRowImpl r = new ResultRowImpl(this, new String[0], new PropertyValue[] { PropertyValues.newString(plan) }, null);\r\n        it = Arrays.asList(r).iterator();\r\n    } else {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"plan: \" + source.getPlan(rootState));\r\n        }\r\n        if (orderings == null) {\r\n            \/\/ can apply limit and offset directly\r\n            it = new RowIterator(rootState, limit, offset);\r\n        } else {\r\n            \/\/ read and order first; skip and limit afterwards\r\n            it = new RowIterator(rootState, Long.MAX_VALUE, 0);\r\n        }\r\n        long readCount = 0;\r\n        if (orderings != null) {\r\n            \/\/ TODO \"order by\" is not necessary if the used index returns\r\n            \/\/ rows in the same order\r\n            \/\/ avoid overflow (both offset and limit could be Long.MAX_VALUE)\r\n            int keep = (int) Math.min(Integer.MAX_VALUE, Math.min(Integer.MAX_VALUE, offset) + Math.min(Integer.MAX_VALUE, limit));\r\n            ArrayList<ResultRowImpl> list = new ArrayList<ResultRowImpl>();\r\n            while (it.hasNext()) {\r\n                readCount++;\r\n                ResultRowImpl r = it.next();\r\n                list.add(r);\r\n                \/\/ which is close to the optimum O(n*log(keep))\r\n                if (list.size() > keep * 2) {\r\n                    \/\/ remove tail entries right now, to save memory\r\n                    Collections.sort(list);\r\n                    keepFirst(list, keep);\r\n                }\r\n            }\r\n            Collections.sort(list);\r\n            keepFirst(list, keep);\r\n            it = list.iterator();\r\n            \/\/ if there are many entries)\r\n            for (int i = 0; i < offset && it.hasNext(); i++) {\r\n                it.next();\r\n            }\r\n            size = list.size() - offset;\r\n        } else if (measure) {\r\n            while (it.hasNext()) {\r\n                readCount++;\r\n                it.next();\r\n            }\r\n        }\r\n        if (measure) {\r\n            columns = new ColumnImpl[] { new ColumnImpl(\"measure\", \"selector\", \"selector\"), new ColumnImpl(\"measure\", \"scanCount\", \"scanCount\") };\r\n            ArrayList<ResultRowImpl> list = new ArrayList<ResultRowImpl>();\r\n            ResultRowImpl r = new ResultRowImpl(this, new String[0], new PropertyValue[] { PropertyValues.newString(\"query\"), PropertyValues.newLong(readCount) }, null);\r\n            list.add(r);\r\n            for (SelectorImpl selector : selectors) {\r\n                r = new ResultRowImpl(this, new String[0], new PropertyValue[] { PropertyValues.newString(selector.getSelectorName()), PropertyValues.newLong(selector.getScanCount()) }, null);\r\n                list.add(r);\r\n            }\r\n            it = list.iterator();\r\n        }\r\n    }\r\n    return it;\r\n}","code_comment":null,"code_no_comment":"Iterator<ResultRowImpl> getRows() {\r\n    prepare();\r\n    Iterator<ResultRowImpl> it;\r\n    if (explain) {\r\n        String plan = source.getPlan(rootState);\r\n        columns = new ColumnImpl[] { new ColumnImpl(\"explain\", \"plan\", \"plan\") };\r\n        ResultRowImpl r = new ResultRowImpl(this, new String[0], new PropertyValue[] { PropertyValues.newString(plan) }, null);\r\n        it = Arrays.asList(r).iterator();\r\n    } else {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"plan: \" + source.getPlan(rootState));\r\n        }\r\n        if (orderings == null) {\r\n                        it = new RowIterator(rootState, limit, offset);\r\n        } else {\r\n                        it = new RowIterator(rootState, Long.MAX_VALUE, 0);\r\n        }\r\n        long readCount = 0;\r\n        if (orderings != null) {\r\n                                                int keep = (int) Math.min(Integer.MAX_VALUE, Math.min(Integer.MAX_VALUE, offset) + Math.min(Integer.MAX_VALUE, limit));\r\n            ArrayList<ResultRowImpl> list = new ArrayList<ResultRowImpl>();\r\n            while (it.hasNext()) {\r\n                readCount++;\r\n                ResultRowImpl r = it.next();\r\n                list.add(r);\r\n                                if (list.size() > keep * 2) {\r\n                                        Collections.sort(list);\r\n                    keepFirst(list, keep);\r\n                }\r\n            }\r\n            Collections.sort(list);\r\n            keepFirst(list, keep);\r\n            it = list.iterator();\r\n                        for (int i = 0; i < offset && it.hasNext(); i++) {\r\n                it.next();\r\n            }\r\n            size = list.size() - offset;\r\n        } else if (measure) {\r\n            while (it.hasNext()) {\r\n                readCount++;\r\n                it.next();\r\n            }\r\n        }\r\n        if (measure) {\r\n            columns = new ColumnImpl[] { new ColumnImpl(\"measure\", \"selector\", \"selector\"), new ColumnImpl(\"measure\", \"scanCount\", \"scanCount\") };\r\n            ArrayList<ResultRowImpl> list = new ArrayList<ResultRowImpl>();\r\n            ResultRowImpl r = new ResultRowImpl(this, new String[0], new PropertyValue[] { PropertyValues.newString(\"query\"), PropertyValues.newLong(readCount) }, null);\r\n            list.add(r);\r\n            for (SelectorImpl selector : selectors) {\r\n                r = new ResultRowImpl(this, new String[0], new PropertyValue[] { PropertyValues.newString(selector.getSelectorName()), PropertyValues.newLong(selector.getScanCount()) }, null);\r\n                list.add(r);\r\n            }\r\n            it = list.iterator();\r\n        }\r\n    }\r\n    return it;\r\n}","lc":1.9545454545,"pi":0.6698564593,"ma":1.6,"nbd":1.0,"ml":1.25,"d":2.7817460317,"mi":-0.9977448908,"fo":2.3333333333,"r":-0.0263157895,"e":9.3639160227}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2839_15477252","label":1,"code":"\/**\r\n *  @see org.apache.wicket.util.watch.IModifiable#lastModifiedTime()\r\n *  @return The last time this resource was modified\r\n *\/\r\n@Override\r\npublic Time lastModifiedTime() {\r\n    if (file != null) {\r\n        \/\/ in case the file has been removed by now\r\n        if (file.exists() == false) {\r\n            return null;\r\n        }\r\n        long lastModified = file.lastModified();\r\n        \/\/ if last modified changed update content length and last modified date\r\n        if (lastModified != this.lastModified) {\r\n            this.lastModified = lastModified;\r\n            contentLength = (int) file.length();\r\n        }\r\n    } else {\r\n        try {\r\n            long lastModified = Connections.getLastModified(url);\r\n            \/\/ if last modified changed update content length and last modified date\r\n            if (lastModified != this.lastModified) {\r\n                this.lastModified = lastModified;\r\n                URLConnection connection = url.openConnection();\r\n                contentLength = connection.getContentLength();\r\n                Connections.close(connection);\r\n            }\r\n        } catch (IOException e) {\r\n            if (url.toString().indexOf(\".jar!\") >= 0) {\r\n                if (log.isDebugEnabled()) {\r\n                    log.debug(\"getLastModified for \" + url + \" failed: \" + e.getMessage());\r\n                }\r\n            } else {\r\n                log.warn(\"getLastModified for \" + url + \" failed: \" + e.getMessage());\r\n            }\r\n            \/\/ allow modification watcher to detect the problem\r\n            return null;\r\n        }\r\n    }\r\n    return Time.milliseconds(lastModified);\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.util.watch.IModifiable#lastModifiedTime()\r\n *  @return The last time this resource was modified\r\n *\/\r\n","code_no_comment":"@Override\r\npublic Time lastModifiedTime() {\r\n    if (file != null) {\r\n                if (file.exists() == false) {\r\n            return null;\r\n        }\r\n        long lastModified = file.lastModified();\r\n                if (lastModified != this.lastModified) {\r\n            this.lastModified = lastModified;\r\n            contentLength = (int) file.length();\r\n        }\r\n    } else {\r\n        try {\r\n            long lastModified = Connections.getLastModified(url);\r\n                        if (lastModified != this.lastModified) {\r\n                this.lastModified = lastModified;\r\n                URLConnection connection = url.openConnection();\r\n                contentLength = connection.getContentLength();\r\n                Connections.close(connection);\r\n            }\r\n        } catch (IOException e) {\r\n            if (url.toString().indexOf(\".jar!\") >= 0) {\r\n                if (log.isDebugEnabled()) {\r\n                    log.debug(\"getLastModified for \" + url + \" failed: \" + e.getMessage());\r\n                }\r\n            } else {\r\n                log.warn(\"getLastModified for \" + url + \" failed: \" + e.getMessage());\r\n            }\r\n                        return null;\r\n        }\r\n    }\r\n    return Time.milliseconds(lastModified);\r\n}","lc":0.8636363636,"pi":1.023923445,"ma":0.8,"nbd":1.0,"ml":0.5833333333,"d":0.4166666667,"mi":-0.5546159267,"fo":0.75,"r":-0.0263157895,"e":0.5901765184}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5572_cd414fa5","label":1,"code":"\/**\r\n *  Checks if this container can dequeue a child represented by the specified tag. This method\r\n *  should be overridden when containers can dequeue components represented by non-standard tags.\r\n *  For example, borders override this method and dequeue their body container when processing\r\n *  the body tag.\r\n *\r\n *  By default all {@link ComponentTag}s are supported as well as {@link WicketTag}s that return\r\n *  a non-null value from {@link WicketTag#getAutoComponentFactory()} method.\r\n *\r\n *  @param tag\r\n *\/\r\nprotected DequeueTagAction canDequeueTag(ComponentTag tag) {\r\n    if (tag instanceof WicketTag) {\r\n        WicketTag wicketTag = (WicketTag) tag;\r\n        if (wicketTag.isContainerTag()) {\r\n            return DequeueTagAction.DEQUEUE;\r\n        } else if (wicketTag.getAutoComponentFactory() != null) {\r\n            return DequeueTagAction.DEQUEUE;\r\n        } else if (wicketTag.isFragmentTag()) {\r\n            return DequeueTagAction.SKIP;\r\n        } else {\r\n            \/\/ dont know\r\n            return null;\r\n        }\r\n    }\r\n    return DequeueTagAction.DEQUEUE;\r\n}","code_comment":"\/**\r\n *  Checks if this container can dequeue a child represented by the specified tag. This method\r\n *  should be overridden when containers can dequeue components represented by non-standard tags.\r\n *  For example, borders override this method and dequeue their body container when processing\r\n *  the body tag.\r\n *\r\n *  By default all {@link ComponentTag}s are supported as well as {@link WicketTag}s that return\r\n *  a non-null value from {@link WicketTag#getAutoComponentFactory()} method.\r\n *\r\n *  @param tag\r\n *\/\r\n","code_no_comment":"protected DequeueTagAction canDequeueTag(ComponentTag tag) {\r\n    if (tag instanceof WicketTag) {\r\n        WicketTag wicketTag = (WicketTag) tag;\r\n        if (wicketTag.isContainerTag()) {\r\n            return DequeueTagAction.DEQUEUE;\r\n        } else if (wicketTag.getAutoComponentFactory() != null) {\r\n            return DequeueTagAction.DEQUEUE;\r\n        } else if (wicketTag.isFragmentTag()) {\r\n            return DequeueTagAction.SKIP;\r\n        } else {\r\n                        return null;\r\n        }\r\n    }\r\n    return DequeueTagAction.DEQUEUE;\r\n}","lc":0.0454545455,"pi":0.4449760766,"ma":0.2,"nbd":1.0,"ml":0.25,"d":0.0476190476,"mi":0.015081043,"fo":-0.25,"r":0.3157894737,"e":-0.0543028878}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-855_ac597cc1","label":3,"code":"\/**\r\n * Selects the best of two points.\r\n *\r\n * @param a Point and value.\r\n * @param b Point and value.\r\n * @param isMinim {@code true} if the selected point must be the one with\r\n * the lowest value.\r\n * @return the best point, or {@code null} if {@code a} and {@code b} are\r\n * both {@code null}.\r\n *\/\r\nprivate UnivariatePointValuePair best(UnivariatePointValuePair a, UnivariatePointValuePair b, boolean isMinim) {\r\n    if (a == null) {\r\n        return b;\r\n    }\r\n    if (b == null) {\r\n        return a;\r\n    }\r\n    if (isMinim) {\r\n        return a.getValue() < b.getValue() ? a : b;\r\n    } else {\r\n        return a.getValue() > b.getValue() ? a : b;\r\n    }\r\n}","code_comment":"\/**\r\n * Selects the best of two points.\r\n *\r\n * @param a Point and value.\r\n * @param b Point and value.\r\n * @param isMinim {@code true} if the selected point must be the one with\r\n * the lowest value.\r\n * @return the best point, or {@code null} if {@code a} and {@code b} are\r\n * both {@code null}.\r\n *\/\r\n","code_no_comment":"private UnivariatePointValuePair best(UnivariatePointValuePair a, UnivariatePointValuePair b, boolean isMinim) {\r\n    if (a == null) {\r\n        return b;\r\n    }\r\n    if (b == null) {\r\n        return a;\r\n    }\r\n    if (isMinim) {\r\n        return a.getValue() < b.getValue() ? a : b;\r\n    } else {\r\n        return a.getValue() > b.getValue() ? a : b;\r\n    }\r\n}","lc":-0.0454545455,"pi":-0.1626794258,"ma":0.4,"nbd":-0.5,"ml":0.4166666667,"d":0.3055555556,"mi":0.0821705426,"fo":-0.1666666667,"r":1.5263157895,"e":0.0040732352}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-891_2b852d79","label":1,"code":"\/**\r\n * Computes the Spearman's rank correlation matrix for the columns of the\r\n * input rectangular array.  The columns of the array represent values\r\n * of variables to be correlated.\r\n *\r\n * @param matrix matrix with columns representing variables to correlate\r\n * @return correlation matrix\r\n *\/\r\npublic RealMatrix computeCorrelationMatrix(double[][] matrix) {\r\n    return computeCorrelationMatrix(new BlockRealMatrix(matrix));\r\n}","code_comment":"\/**\r\n * Computes the Spearman's rank correlation matrix for the columns of the\r\n * input rectangular array.  The columns of the array represent values\r\n * of variables to be correlated.\r\n *\r\n * @param matrix matrix with columns representing variables to correlate\r\n * @return correlation matrix\r\n *\/\r\n","code_no_comment":"public RealMatrix computeCorrelationMatrix(double[][] matrix) {\r\n    return computeCorrelationMatrix(new BlockRealMatrix(matrix));\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0606060606,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-329_6dd3724b","label":3,"code":"\/\/ -------------------------------------------------------------\r\n\/**\r\n * Returns the percentage of values that are equal to v\r\n * (as a proportion between 0 and 1).\r\n * <p>\r\n * Returns <code>Double.NaN<\/code> if no values have been added.<\/p>\r\n *\r\n * @param v the value to lookup\r\n * @return the proportion of values equal to v\r\n * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\r\n *\/\r\n@Deprecated\r\npublic double getPct(Object v) {\r\n    return getCumPct((Comparable<?>) v);\r\n}","code_comment":"\/**\r\n * Returns the percentage of values that are equal to v\r\n * (as a proportion between 0 and 1).\r\n * <p>\r\n * Returns <code>Double.NaN<\/code> if no values have been added.<\/p>\r\n *\r\n * @param v the value to lookup\r\n * @return the proportion of values equal to v\r\n * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\r\n *\/\r\n","code_no_comment":"@Deprecated\r\npublic double getPct(Object v) {\r\n    return getCumPct((Comparable<?>) v);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.881888654,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Provides <em>direct<\/em> access to the internal storage array.\r\n * Please note that this method returns a reference to this object's\r\n * storage array, not a copy.\r\n * <br\/>\r\n * To correctly address elements of the array, the \"start index\" is\r\n * required (available via the {@link #getStartIndex() getStartIndex}\r\n * method.\r\n * <br\/>\r\n * This method should only be used to avoid copying the internal array.\r\n * The returned value <em>must<\/em> be used for reading only; other\r\n * uses could lead to this object becoming inconsistent.\r\n * <br\/>\r\n * The {@link #getElements} method has no such limitation since it\r\n * returns a copy of this array's addressable elements.\r\n *\r\n * @return the internal storage array used by this object.\r\n * @since 3.1\r\n *\/\r\nprotected double[] getArrayRef() {\r\n    return internalArray;\r\n}","code_comment":"\/**\r\n * Provides <em>direct<\/em> access to the internal storage array.\r\n * Please note that this method returns a reference to this object's\r\n * storage array, not a copy.\r\n * <br\/>\r\n * To correctly address elements of the array, the \"start index\" is\r\n * required (available via the {@link #getStartIndex() getStartIndex}\r\n * method.\r\n * <br\/>\r\n * This method should only be used to avoid copying the internal array.\r\n * The returned value <em>must<\/em> be used for reading only; other\r\n * uses could lead to this object becoming inconsistent.\r\n * <br\/>\r\n * The {@link #getElements} method has no such limitation since it\r\n * returns a copy of this array's addressable elements.\r\n *\r\n * @return the internal storage array used by this object.\r\n * @since 3.1\r\n *\/\r\n","code_no_comment":"protected double[] getArrayRef() {\r\n    return internalArray;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.2407329105,"fo":-0.5,"r":1.5526315789,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-208_daf9a4ef","label":1,"code":"@Override\r\npublic void setRoot(NodeState newRoot) {\r\n    currentRoot = newRoot;\r\n    commit(buildJsop());\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void setRoot(NodeState newRoot) {\r\n    currentRoot = newRoot;\r\n    commit(buildJsop());\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7293868922,"fo":-0.3333333333,"r":2.2105263158,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5261_55c2e2d8","label":1,"code":"@Override\r\nprotected void doShutdown() throws Exception {\r\n    \/\/ notify component we are shutting down this endpoint\r\n    if (getComponent() != null) {\r\n        getComponent().onShutdownEndpoint(this);\r\n    }\r\n    \/\/ shutdown thread pool if it was in use\r\n    if (multicastExecutor != null) {\r\n        getCamelContext().getExecutorServiceManager().shutdownNow(multicastExecutor);\r\n        multicastExecutor = null;\r\n    }\r\n    super.doShutdown();\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void doShutdown() throws Exception {\r\n        if (getComponent() != null) {\r\n        getComponent().onShutdownEndpoint(this);\r\n    }\r\n        if (multicastExecutor != null) {\r\n        getCamelContext().getExecutorServiceManager().shutdownNow(multicastExecutor);\r\n        multicastExecutor = null;\r\n    }\r\n    super.doShutdown();\r\n}","lc":-0.1363636364,"pi":-0.019138756,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0575396825,"mi":0.2321353066,"fo":0.0833333333,"r":1.7368421053,"e":-0.1100603378}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2713_63d9800e","label":1,"code":"@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic S value() throws IOException {\r\n    if (currentInput == null) {\r\n        throw new IllegalStateException(\"Need a valid input for accessing the state.\");\r\n    } else {\r\n        Serializable key;\r\n        try {\r\n            key = keySelector.getKey(currentInput);\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"User-defined key selector threw an exception.\", e);\r\n        }\r\n        if (stateStore.containsKey(key)) {\r\n            return stateStore.getStateForKey(key);\r\n        } else {\r\n            try {\r\n                return (S) checkpointer.restoreState((C) InstantiationUtil.deserializeObject(defaultState, cl));\r\n            } catch (ClassNotFoundException e) {\r\n                throw new RuntimeException(\"Could not deserialize default state value.\", e);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic S value() throws IOException {\r\n    if (currentInput == null) {\r\n        throw new IllegalStateException(\"Need a valid input for accessing the state.\");\r\n    } else {\r\n        Serializable key;\r\n        try {\r\n            key = keySelector.getKey(currentInput);\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"User-defined key selector threw an exception.\", e);\r\n        }\r\n        if (stateStore.containsKey(key)) {\r\n            return stateStore.getStateForKey(key);\r\n        } else {\r\n            try {\r\n                return (S) checkpointer.restoreState((C) InstantiationUtil.deserializeObject(defaultState, cl));\r\n            } catch (ClassNotFoundException e) {\r\n                throw new RuntimeException(\"Could not deserialize default state value.\", e);\r\n            }\r\n        }\r\n    }\r\n}","lc":0.4090909091,"pi":0.8612440191,"ma":0.8,"nbd":0.5,"ml":0.0,"d":-0.1031746032,"mi":-0.2947145877,"fo":-0.0833333333,"r":-0.0263157895,"e":-0.0305319756}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7275_44cad623","label":1,"code":"public void done(boolean doneSync) {\r\n    \/\/ we only have to handle async completion of the pipeline\r\n    if (doneSync) {\r\n        return;\r\n    }\r\n    \/\/ continue processing the try .. catch .. finally asynchronously\r\n    while (continueRouting(processors, exchange)) {\r\n        ExchangeHelper.prepareOutToIn(exchange);\r\n        \/\/ process the next processor\r\n        AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());\r\n        doneSync = process(exchange, callback, processors, processor, lastHandled);\r\n        if (!doneSync) {\r\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\r\n            \/\/ so we break out now, then the callback will be invoked which then continue routing from where we left here\r\n            return;\r\n        }\r\n    }\r\n    ExchangeHelper.prepareOutToIn(exchange);\r\n    exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled);\r\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n    callback.done(false);\r\n}","code_comment":null,"code_no_comment":"public void done(boolean doneSync) {\r\n        if (doneSync) {\r\n        return;\r\n    }\r\n        while (continueRouting(processors, exchange)) {\r\n        ExchangeHelper.prepareOutToIn(exchange);\r\n                AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());\r\n        doneSync = process(exchange, callback, processors, processor, lastHandled);\r\n        if (!doneSync) {\r\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\r\n                        return;\r\n        }\r\n    }\r\n    ExchangeHelper.prepareOutToIn(exchange);\r\n    exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled);\r\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n    callback.done(false);\r\n}","lc":0.1818181818,"pi":0.1626794258,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":0.0,"mi":-0.1673009161,"fo":0.5,"r":-0.0263157895,"e":0.034851864}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-846_7acb091a","label":3,"code":"\/**\r\n * Try to create or update the node. If there was a conflict, this method\r\n * throws an exception, even though the change is still applied.\r\n *\r\n * @param store the store\r\n * @param op the operation\r\n *\/\r\nprivate void createOrUpdateNode(DocumentStore store, UpdateOp op) {\r\n    Map<String, Object> map = store.createOrUpdate(Collection.NODES, op);\r\n    if (baseRevision != null) {\r\n        final AtomicReference<List<Revision>> collisions = new AtomicReference<List<Revision>>();\r\n        Revision newestRev = mk.getNewestRevision(map, revision, new CollisionHandler() {\r\n\r\n            @Override\r\n            void uncommittedModification(Revision uncommitted) {\r\n                if (collisions.get() == null) {\r\n                    collisions.set(new ArrayList<Revision>());\r\n                }\r\n                collisions.get().add(uncommitted);\r\n            }\r\n        });\r\n        String conflictMessage = null;\r\n        if (newestRev == null) {\r\n            if (op.isDelete || !op.isNew) {\r\n                conflictMessage = \"The node \" + op.path + \" does not exist or is already deleted\";\r\n            }\r\n        } else {\r\n            if (op.isNew) {\r\n                conflictMessage = \"The node \" + op.path + \" was already added in revision\\n\" + newestRev;\r\n            } else if (mk.isRevisionNewer(newestRev, baseRevision) && (op.isDelete || isConflicting(map, op))) {\r\n                conflictMessage = \"The node \" + op.path + \" was changed in revision\\n\" + newestRev + \", which was applied after the base revision\\n\" + baseRevision;\r\n            }\r\n        }\r\n        if (conflictMessage != null) {\r\n            conflictMessage += \", before\\n\" + revision + \"; document:\\n\" + map.toString().replaceAll(\", _\", \",\\n_\").replaceAll(\"}, \", \"},\\n\") + \",\\nrevision order:\\n\" + mk.getRevisionComparator();\r\n            throw new MicroKernelException(conflictMessage);\r\n        }\r\n        \/\/ on a node are possible if property updates do not overlap)\r\n        if (collisions.get() != null && isConflicting(map, op)) {\r\n            for (Revision r : collisions.get()) {\r\n                \/\/ mark collisions on commit root\r\n                Collision c = new Collision(map, r, op, revision);\r\n                boolean success = c.mark(store);\r\n                if (!success) {\r\n                \/\/ TODO: fail this commit\r\n                }\r\n            }\r\n        }\r\n    }\r\n    int size = Utils.estimateMemoryUsage(map);\r\n    if (size > MAX_DOCUMENT_SIZE) {\r\n        UpdateOp[] split = splitDocument(map);\r\n        \/\/ TODO check if the new main document is actually smaller;\r\n        \/\/ otherwise, splitting doesn't make sense\r\n        \/\/ the old version\r\n        UpdateOp old = split[0];\r\n        if (old != null) {\r\n            store.createOrUpdate(Collection.NODES, old);\r\n        }\r\n        \/\/ the (shrunken) main document\r\n        UpdateOp main = split[1];\r\n        if (main != null) {\r\n            store.createOrUpdate(Collection.NODES, main);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Try to create or update the node. If there was a conflict, this method\r\n * throws an exception, even though the change is still applied.\r\n *\r\n * @param store the store\r\n * @param op the operation\r\n *\/\r\n","code_no_comment":"private void createOrUpdateNode(DocumentStore store, UpdateOp op) {\r\n    Map<String, Object> map = store.createOrUpdate(Collection.NODES, op);\r\n    if (baseRevision != null) {\r\n        final AtomicReference<List<Revision>> collisions = new AtomicReference<List<Revision>>();\r\n        Revision newestRev = mk.getNewestRevision(map, revision, new CollisionHandler() {\r\n\r\n            @Override\r\n            void uncommittedModification(Revision uncommitted) {\r\n                if (collisions.get() == null) {\r\n                    collisions.set(new ArrayList<Revision>());\r\n                }\r\n                collisions.get().add(uncommitted);\r\n            }\r\n        });\r\n        String conflictMessage = null;\r\n        if (newestRev == null) {\r\n            if (op.isDelete || !op.isNew) {\r\n                conflictMessage = \"The node \" + op.path + \" does not exist or is already deleted\";\r\n            }\r\n        } else {\r\n            if (op.isNew) {\r\n                conflictMessage = \"The node \" + op.path + \" was already added in revision\\n\" + newestRev;\r\n            } else if (mk.isRevisionNewer(newestRev, baseRevision) && (op.isDelete || isConflicting(map, op))) {\r\n                conflictMessage = \"The node \" + op.path + \" was changed in revision\\n\" + newestRev + \", which was applied after the base revision\\n\" + baseRevision;\r\n            }\r\n        }\r\n        if (conflictMessage != null) {\r\n            conflictMessage += \", before\\n\" + revision + \"; document:\\n\" + map.toString().replaceAll(\", _\", \",\\n_\").replaceAll(\"}, \", \"},\\n\") + \",\\nrevision order:\\n\" + mk.getRevisionComparator();\r\n            throw new MicroKernelException(conflictMessage);\r\n        }\r\n                if (collisions.get() != null && isConflicting(map, op)) {\r\n            for (Revision r : collisions.get()) {\r\n                                Collision c = new Collision(map, r, op, revision);\r\n                boolean success = c.mark(store);\r\n                if (!success) {\r\n                                }\r\n            }\r\n        }\r\n    }\r\n    int size = Utils.estimateMemoryUsage(map);\r\n    if (size > MAX_DOCUMENT_SIZE) {\r\n        UpdateOp[] split = splitDocument(map);\r\n                                UpdateOp old = split[0];\r\n        if (old != null) {\r\n            store.createOrUpdate(Collection.NODES, old);\r\n        }\r\n                UpdateOp main = split[1];\r\n        if (main != null) {\r\n            store.createOrUpdate(Collection.NODES, main);\r\n        }\r\n    }\r\n}","lc":1.6818181818,"pi":0.6937799043,"ma":2.2,"nbd":1.0,"ml":2.0833333333,"d":1.4781746032,"mi":-0.9532064834,"fo":1.1666666667,"r":-0.0263157895,"e":4.9391976856}
{"project_name":"Closure","project_version":"82","label":2,"code":"public final boolean isEmptyType() {\r\n    return isNoType() || isNoObjectType() || isNoResolvedType();\r\n}","code_comment":null,"code_no_comment":"public final boolean isEmptyType() {\r\n    return isNoType() || isNoObjectType() || isNoResolvedType();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.067653277,"fo":-0.25,"r":2.3684210526,"e":-0.1627934049}
{"project_name":"Math","project_version":"93","label":3,"code":"\/**\r\n * Returns the natural logarithm of n!.\r\n * <p>\r\n * <Strong>Preconditions<\/strong>:\r\n * <ul>\r\n * <li> <code>n >= 0<\/code> (otherwise\r\n * <code>IllegalArgumentException<\/code> is thrown)<\/li>\r\n * <\/ul><\/p>\r\n *\r\n * @param n argument\r\n * @return <code>n!<\/code>\r\n * @throws IllegalArgumentException if preconditions are not met.\r\n *\/\r\npublic static double factorialLog(final int n) {\r\n    if (n < 0) {\r\n        throw new IllegalArgumentException(\"must have n > 0 for n!\");\r\n    }\r\n    double logSum = 0;\r\n    for (int i = 2; i <= n; i++) {\r\n        logSum += Math.log((double) i);\r\n    }\r\n    return logSum;\r\n}","code_comment":"\/**\r\n * Returns the natural logarithm of n!.\r\n * <p>\r\n * <Strong>Preconditions<\/strong>:\r\n * <ul>\r\n * <li> <code>n >= 0<\/code> (otherwise\r\n * <code>IllegalArgumentException<\/code> is thrown)<\/li>\r\n * <\/ul><\/p>\r\n *\r\n * @param n argument\r\n * @return <code>n!<\/code>\r\n * @throws IllegalArgumentException if preconditions are not met.\r\n *\/\r\n","code_no_comment":"public static double factorialLog(final int n) {\r\n    if (n < 0) {\r\n        throw new IllegalArgumentException(\"must have n > 0 for n!\");\r\n    }\r\n    double logSum = 0;\r\n    for (int i = 2; i <= n; i++) {\r\n        logSum += Math.log((double) i);\r\n    }\r\n    return logSum;\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":0.3194444444,"mi":0.2250880902,"fo":-0.4166666667,"r":1.8684210526,"e":-0.0035292151}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-349_4cc9a49d","label":3,"code":"\/**\r\n * Set the mean for the distribution.\r\n * The parameter value must be positive; otherwise an\r\n * <code>IllegalArgument<\/code> is thrown.\r\n *\r\n * @param p the mean\r\n * @throws IllegalArgumentException if p &le; 0\r\n * @deprecated as of v2.1\r\n *\/\r\n@Deprecated\r\nvoid setMean(double p);","code_comment":"\/**\r\n * Set the mean for the distribution.\r\n * The parameter value must be positive; otherwise an\r\n * <code>IllegalArgument<\/code> is thrown.\r\n *\r\n * @param p the mean\r\n * @throws IllegalArgumentException if p &le; 0\r\n * @deprecated as of v2.1\r\n *\/\r\n","code_no_comment":"@Deprecated\r\nvoid setMean(double p);","lc":-0.5454545455,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.3498238196,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2434_8159fc21","label":1,"code":"@Override\r\npublic boolean visit(FullTextAnd and) {\r\n    BooleanQuery q = new BooleanQuery();\r\n    for (FullTextExpression e : and.list) {\r\n        Query x = getFullTextQuery(plan, e, analyzer);\r\n        \/\/ Lucene can't deal with \"must(must_not(x))\"\r\n        if (x instanceof BooleanQuery) {\r\n            BooleanQuery bq = (BooleanQuery) x;\r\n            for (BooleanClause c : bq.clauses()) {\r\n                q.add(c);\r\n            }\r\n        } else {\r\n            q.add(x, MUST);\r\n        }\r\n    }\r\n    result.set(q);\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean visit(FullTextAnd and) {\r\n    BooleanQuery q = new BooleanQuery();\r\n    for (FullTextExpression e : and.list) {\r\n        Query x = getFullTextQuery(plan, e, analyzer);\r\n                if (x instanceof BooleanQuery) {\r\n            BooleanQuery bq = (BooleanQuery) x;\r\n            for (BooleanClause c : bq.clauses()) {\r\n                q.add(c);\r\n            }\r\n        } else {\r\n            q.add(x, MUST);\r\n        }\r\n    }\r\n    result.set(q);\r\n    return true;\r\n}","lc":0.1363636364,"pi":0.8229665072,"ma":0.0,"nbd":0.5,"ml":-0.25,"d":-0.3650793651,"mi":-0.1151515152,"fo":-0.0833333333,"r":0.1315789474,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-795_9453bcfa","label":3,"code":"public int execute(final String fullCommand, final CommandLine cl, final Shell shellState) throws AccumuloException, AccumuloSecurityException, TableExistsException, TableNotFoundException, IOException, ClassNotFoundException {\r\n    final String testTableName = cl.getArgs()[0];\r\n    if (!testTableName.matches(Constants.VALID_TABLE_NAME_REGEX)) {\r\n        shellState.getReader().printString(\"Only letters, numbers and underscores are allowed for use in table names. \\n\");\r\n        throw new IllegalArgumentException();\r\n    }\r\n    final String tableName = cl.getArgs()[0];\r\n    if (shellState.getConnector().tableOperations().exists(tableName)) {\r\n        throw new TableExistsException(null, tableName, null);\r\n    }\r\n    final SortedSet<Text> partitions = new TreeSet<Text>();\r\n    final boolean decode = cl.hasOption(base64Opt.getOpt());\r\n    if (cl.hasOption(createTableOptSplit.getOpt())) {\r\n        final String f = cl.getOptionValue(createTableOptSplit.getOpt());\r\n        String line;\r\n        Scanner file = new Scanner(new File(f));\r\n        while (file.hasNextLine()) {\r\n            line = file.nextLine();\r\n            if (!line.isEmpty()) {\r\n                partitions.add(decode ? new Text(Base64.decodeBase64(line.getBytes())) : new Text(line));\r\n            }\r\n        }\r\n    } else if (cl.hasOption(createTableOptCopySplits.getOpt())) {\r\n        final String oldTable = cl.getOptionValue(createTableOptCopySplits.getOpt());\r\n        if (!shellState.getConnector().tableOperations().exists(oldTable)) {\r\n            throw new TableNotFoundException(null, oldTable, null);\r\n        }\r\n        partitions.addAll(shellState.getConnector().tableOperations().getSplits(oldTable));\r\n    }\r\n    if (cl.hasOption(createTableOptCopyConfig.getOpt())) {\r\n        final String oldTable = cl.getOptionValue(createTableOptCopyConfig.getOpt());\r\n        if (!shellState.getConnector().tableOperations().exists(oldTable)) {\r\n            throw new TableNotFoundException(null, oldTable, null);\r\n        }\r\n    }\r\n    TimeType timeType = TimeType.MILLIS;\r\n    if (cl.hasOption(createTableOptTimeLogical.getOpt())) {\r\n        timeType = TimeType.LOGICAL;\r\n    }\r\n    \/\/ create table\r\n    shellState.getConnector().tableOperations().create(tableName, true, timeType);\r\n    if (partitions.size() > 0) {\r\n        shellState.getConnector().tableOperations().addSplits(tableName, partitions);\r\n    }\r\n    \/\/ switch shell to new table\r\n    shellState.setTableName(tableName);\r\n    if (cl.hasOption(createTableNoDefaultIters.getOpt())) {\r\n        for (String key : IteratorUtil.generateInitialTableProperties().keySet()) {\r\n            shellState.getConnector().tableOperations().removeProperty(tableName, key);\r\n        }\r\n    }\r\n    \/\/ Copy options if flag was set\r\n    if (cl.hasOption(createTableOptCopyConfig.getOpt())) {\r\n        if (shellState.getConnector().tableOperations().exists(tableName)) {\r\n            final Iterable<Entry<String, String>> configuration = shellState.getConnector().tableOperations().getProperties(cl.getOptionValue(createTableOptCopyConfig.getOpt()));\r\n            for (Entry<String, String> entry : configuration) {\r\n                if (Property.isValidTablePropertyKey(entry.getKey())) {\r\n                    shellState.getConnector().tableOperations().setProperty(tableName, entry.getKey(), entry.getValue());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (cl.hasOption(createTableOptEVC.getOpt())) {\r\n        try {\r\n            shellState.getConnector().tableOperations().addConstraint(tableName, VisibilityConstraint.class.getName());\r\n        } catch (AccumuloException e) {\r\n            Shell.log.warn(e.getMessage() + \" while setting visibility constraint, but table was created\");\r\n        }\r\n    }\r\n    \/\/ Load custom formatter if set\r\n    if (cl.hasOption(createTableOptFormatter.getOpt())) {\r\n        final String formatterClass = cl.getOptionValue(createTableOptFormatter.getOpt());\r\n        shellState.getConnector().tableOperations().setProperty(tableName, Property.TABLE_FORMATTER_CLASS.toString(), formatterClass);\r\n    }\r\n    return 0;\r\n}","code_comment":null,"code_no_comment":"public int execute(final String fullCommand, final CommandLine cl, final Shell shellState) throws AccumuloException, AccumuloSecurityException, TableExistsException, TableNotFoundException, IOException, ClassNotFoundException {\r\n    final String testTableName = cl.getArgs()[0];\r\n    if (!testTableName.matches(Constants.VALID_TABLE_NAME_REGEX)) {\r\n        shellState.getReader().printString(\"Only letters, numbers and underscores are allowed for use in table names. \\n\");\r\n        throw new IllegalArgumentException();\r\n    }\r\n    final String tableName = cl.getArgs()[0];\r\n    if (shellState.getConnector().tableOperations().exists(tableName)) {\r\n        throw new TableExistsException(null, tableName, null);\r\n    }\r\n    final SortedSet<Text> partitions = new TreeSet<Text>();\r\n    final boolean decode = cl.hasOption(base64Opt.getOpt());\r\n    if (cl.hasOption(createTableOptSplit.getOpt())) {\r\n        final String f = cl.getOptionValue(createTableOptSplit.getOpt());\r\n        String line;\r\n        Scanner file = new Scanner(new File(f));\r\n        while (file.hasNextLine()) {\r\n            line = file.nextLine();\r\n            if (!line.isEmpty()) {\r\n                partitions.add(decode ? new Text(Base64.decodeBase64(line.getBytes())) : new Text(line));\r\n            }\r\n        }\r\n    } else if (cl.hasOption(createTableOptCopySplits.getOpt())) {\r\n        final String oldTable = cl.getOptionValue(createTableOptCopySplits.getOpt());\r\n        if (!shellState.getConnector().tableOperations().exists(oldTable)) {\r\n            throw new TableNotFoundException(null, oldTable, null);\r\n        }\r\n        partitions.addAll(shellState.getConnector().tableOperations().getSplits(oldTable));\r\n    }\r\n    if (cl.hasOption(createTableOptCopyConfig.getOpt())) {\r\n        final String oldTable = cl.getOptionValue(createTableOptCopyConfig.getOpt());\r\n        if (!shellState.getConnector().tableOperations().exists(oldTable)) {\r\n            throw new TableNotFoundException(null, oldTable, null);\r\n        }\r\n    }\r\n    TimeType timeType = TimeType.MILLIS;\r\n    if (cl.hasOption(createTableOptTimeLogical.getOpt())) {\r\n        timeType = TimeType.LOGICAL;\r\n    }\r\n        shellState.getConnector().tableOperations().create(tableName, true, timeType);\r\n    if (partitions.size() > 0) {\r\n        shellState.getConnector().tableOperations().addSplits(tableName, partitions);\r\n    }\r\n        shellState.setTableName(tableName);\r\n    if (cl.hasOption(createTableNoDefaultIters.getOpt())) {\r\n        for (String key : IteratorUtil.generateInitialTableProperties().keySet()) {\r\n            shellState.getConnector().tableOperations().removeProperty(tableName, key);\r\n        }\r\n    }\r\n        if (cl.hasOption(createTableOptCopyConfig.getOpt())) {\r\n        if (shellState.getConnector().tableOperations().exists(tableName)) {\r\n            final Iterable<Entry<String, String>> configuration = shellState.getConnector().tableOperations().getProperties(cl.getOptionValue(createTableOptCopyConfig.getOpt()));\r\n            for (Entry<String, String> entry : configuration) {\r\n                if (Property.isValidTablePropertyKey(entry.getKey())) {\r\n                    shellState.getConnector().tableOperations().setProperty(tableName, entry.getKey(), entry.getValue());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (cl.hasOption(createTableOptEVC.getOpt())) {\r\n        try {\r\n            shellState.getConnector().tableOperations().addConstraint(tableName, VisibilityConstraint.class.getName());\r\n        } catch (AccumuloException e) {\r\n            Shell.log.warn(e.getMessage() + \" while setting visibility constraint, but table was created\");\r\n        }\r\n    }\r\n        if (cl.hasOption(createTableOptFormatter.getOpt())) {\r\n        final String formatterClass = cl.getOptionValue(createTableOptFormatter.getOpt());\r\n        shellState.getConnector().tableOperations().setProperty(tableName, Property.TABLE_FORMATTER_CLASS.toString(), formatterClass);\r\n    }\r\n    return 0;\r\n}","lc":2.6363636364,"pi":0.4114832536,"ma":4.4,"nbd":1.0,"ml":3.1666666667,"d":0.7003968254,"mi":-1.2441155743,"fo":6.8333333333,"r":-0.0263157895,"e":4.3329472174}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-867_bfbb156d","label":1,"code":"\/**\r\n * @param x Normalized objective variables.\r\n * @return the original objective variables, possibly repaired.\r\n *\/\r\npublic double[] repairAndDecode(final double[] x) {\r\n    return boundaries != null && isRepairMode ? decode(repair(x)) : decode(x);\r\n}","code_comment":"\/**\r\n * @param x Normalized objective variables.\r\n * @return the original objective variables, possibly repaired.\r\n *\/\r\n","code_no_comment":"public double[] repairAndDecode(final double[] x) {\r\n    return boundaries != null && isRepairMode ? decode(repair(x)) : decode(x);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.0833333333,"d":-0.0912698413,"mi":0.9109231853,"fo":-0.25,"r":2.6052631579,"e":-0.1354172069}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1153_9f924f10","label":1,"code":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nprivate void processRemainingProperties(ComponentBuilder<?> builder, String name, Properties properties) {\r\n    while (properties.size() > 0) {\r\n        String propertyName = properties.stringPropertyNames().iterator().next();\r\n        int index = propertyName.indexOf('.');\r\n        if (index > 0) {\r\n            String prefix = propertyName.substring(0, index);\r\n            Properties componentProperties = PropertiesUtil.extractSubset(properties, prefix);\r\n            builder.addComponent(createComponent(builder, prefix, componentProperties));\r\n        } else {\r\n            builder.addAttribute(propertyName, properties.getProperty(propertyName));\r\n            properties.remove(propertyName);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nprivate void processRemainingProperties(ComponentBuilder<?> builder, String name, Properties properties) {\r\n    while (properties.size() > 0) {\r\n        String propertyName = properties.stringPropertyNames().iterator().next();\r\n        int index = propertyName.indexOf('.');\r\n        if (index > 0) {\r\n            String prefix = propertyName.substring(0, index);\r\n            Properties componentProperties = PropertiesUtil.extractSubset(properties, prefix);\r\n            builder.addComponent(createComponent(builder, prefix, componentProperties));\r\n        } else {\r\n            builder.addAttribute(propertyName, properties.getProperty(propertyName));\r\n            properties.remove(propertyName);\r\n        }\r\n    }\r\n}","lc":0.0454545455,"pi":0.6889952153,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0138888889,"mi":-0.11205074,"fo":0.5,"r":-0.0263157895,"e":0.0774836765}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1096_faf99727","label":0,"code":"\/**\r\n * Compute enclosing ball using G\u00e4rtner's pivoting heuristic.\r\n * @param points points to be enclosed\r\n * @return enclosing ball\r\n *\/\r\nprivate EnclosingBall<S, P> pivotingBall(final List<P> points) {\r\n    List<P> extreme = new ArrayList<P>(max);\r\n    List<P> support = new ArrayList<P>(max);\r\n    \/\/ start with only first point selected as a candidate support\r\n    extreme.add(points.get(0));\r\n    EnclosingBall<S, P> ball = moveToFrontBall(extreme, support);\r\n    while (true) {\r\n        \/\/ select the point farthest to current ball\r\n        final P farthest = selectFarthest(points, ball);\r\n        if (ball.contains(farthest, tolerance)) {\r\n            \/\/ we have found a ball containing all points\r\n            return ball;\r\n        }\r\n        \/\/ recurse search, restricted to the small subset containing support and farthest point\r\n        support.clear();\r\n        support.add(farthest);\r\n        EnclosingBall<S, P> savedBall = ball;\r\n        ball = moveToFrontBall(extreme, support);\r\n        if (ball.getRadius() < savedBall.getRadius()) {\r\n            \/\/ TODO: fix this, it should never happen but it does!\r\n            throw new MathInternalError();\r\n        }\r\n        \/\/ it was an interesting point, move it to the front\r\n        \/\/ according to G\u00e4rtner's heuristic\r\n        extreme.add(0, farthest);\r\n        \/\/ prune the least interesting points\r\n        extreme.subList(ball.getSupportSize(), extreme.size()).clear();\r\n    }\r\n}","code_comment":"\/**\r\n * Compute enclosing ball using G\u00e4rtner's pivoting heuristic.\r\n * @param points points to be enclosed\r\n * @return enclosing ball\r\n *\/\r\n","code_no_comment":"private EnclosingBall<S, P> pivotingBall(final List<P> points) {\r\n    List<P> extreme = new ArrayList<P>(max);\r\n    List<P> support = new ArrayList<P>(max);\r\n        extreme.add(points.get(0));\r\n    EnclosingBall<S, P> ball = moveToFrontBall(extreme, support);\r\n    while (true) {\r\n                final P farthest = selectFarthest(points, ball);\r\n        if (ball.contains(farthest, tolerance)) {\r\n                        return ball;\r\n        }\r\n                support.clear();\r\n        support.add(farthest);\r\n        EnclosingBall<S, P> savedBall = ball;\r\n        ball = moveToFrontBall(extreme, support);\r\n        if (ball.getRadius() < savedBall.getRadius()) {\r\n                        throw new MathInternalError();\r\n        }\r\n                        extreme.add(0, farthest);\r\n                extreme.subList(ball.getSupportSize(), extreme.size()).clear();\r\n    }\r\n}","lc":0.3181818182,"pi":0.0717703349,"ma":0.2,"nbd":0.0,"ml":0.25,"d":0.1527777778,"mi":-0.3206483439,"fo":0.75,"r":-0.0263157895,"e":0.3090472156}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4050_52ca008c","label":1,"code":"\/**\r\n * Collect _revisions and _commitRoot entries that can be moved to a\r\n * previous document.\r\n *\/\r\nprivate void collectRevisionsAndCommitRoot() {\r\n    NavigableMap<Revision, String> revisions = new TreeMap<Revision, String>(StableRevisionComparator.INSTANCE);\r\n    for (Map.Entry<Revision, String> entry : doc.getLocalRevisions().entrySet()) {\r\n        if (splitRevs.contains(entry.getKey())) {\r\n            revisions.put(entry.getKey(), entry.getValue());\r\n            numValues++;\r\n        } else {\r\n            \/\/ local changes\r\n            if (context.getClusterId() != entry.getKey().getClusterId()) {\r\n                \/\/ only consider local changes\r\n                continue;\r\n            }\r\n            if (doc.isCommitted(entry.getKey()) && !mostRecentRevs.contains(entry.getKey())) {\r\n                \/\/ this is a commit root for changes in other documents\r\n                revisions.put(entry.getKey(), entry.getValue());\r\n                numValues++;\r\n                trackHigh(entry.getKey());\r\n                trackLow(entry.getKey());\r\n            }\r\n        }\r\n    }\r\n    committedChanges.put(REVISIONS, revisions);\r\n    NavigableMap<Revision, String> commitRoot = new TreeMap<Revision, String>(StableRevisionComparator.INSTANCE);\r\n    boolean mostRecent = true;\r\n    for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {\r\n        Revision r = entry.getKey();\r\n        if (splitRevs.contains(r)) {\r\n            commitRoot.put(r, entry.getValue());\r\n            numValues++;\r\n        } else if (r.getClusterId() == context.getClusterId() && !changes.contains(r)) {\r\n            \/\/ consider all but most recent as garbage (OAK-3333)\r\n            if (mostRecent) {\r\n                mostRecent = false;\r\n            } else {\r\n                addGarbage(r, COMMIT_ROOT);\r\n            }\r\n        }\r\n    }\r\n    committedChanges.put(COMMIT_ROOT, commitRoot);\r\n}","code_comment":"\/**\r\n * Collect _revisions and _commitRoot entries that can be moved to a\r\n * previous document.\r\n *\/\r\n","code_no_comment":"private void collectRevisionsAndCommitRoot() {\r\n    NavigableMap<Revision, String> revisions = new TreeMap<Revision, String>(StableRevisionComparator.INSTANCE);\r\n    for (Map.Entry<Revision, String> entry : doc.getLocalRevisions().entrySet()) {\r\n        if (splitRevs.contains(entry.getKey())) {\r\n            revisions.put(entry.getKey(), entry.getValue());\r\n            numValues++;\r\n        } else {\r\n                        if (context.getClusterId() != entry.getKey().getClusterId()) {\r\n                                continue;\r\n            }\r\n            if (doc.isCommitted(entry.getKey()) && !mostRecentRevs.contains(entry.getKey())) {\r\n                                revisions.put(entry.getKey(), entry.getValue());\r\n                numValues++;\r\n                trackHigh(entry.getKey());\r\n                trackLow(entry.getKey());\r\n            }\r\n        }\r\n    }\r\n    committedChanges.put(REVISIONS, revisions);\r\n    NavigableMap<Revision, String> commitRoot = new TreeMap<Revision, String>(StableRevisionComparator.INSTANCE);\r\n    boolean mostRecent = true;\r\n    for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {\r\n        Revision r = entry.getKey();\r\n        if (splitRevs.contains(r)) {\r\n            commitRoot.put(r, entry.getValue());\r\n            numValues++;\r\n        } else if (r.getClusterId() == context.getClusterId() && !changes.contains(r)) {\r\n                        if (mostRecent) {\r\n                mostRecent = false;\r\n            } else {\r\n                addGarbage(r, COMMIT_ROOT);\r\n            }\r\n        }\r\n    }\r\n    committedChanges.put(COMMIT_ROOT, commitRoot);\r\n}","lc":1.0,"pi":0.8708133971,"ma":1.2,"nbd":1.0,"ml":1.1666666667,"d":1.3432539683,"mi":-0.6778012685,"fo":2.25,"r":-0.0263157895,"e":2.5013006921}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1115_2a6c6409","label":1,"code":"\/**\r\n * Build a parallellepipedic box boundary.\r\n * @param xMin low bound along the x direction\r\n * @param xMax high bound along the x direction\r\n * @param yMin low bound along the y direction\r\n * @param yMax high bound along the y direction\r\n * @param zMin low bound along the z direction\r\n * @param zMax high bound along the z direction\r\n * @param tolerance tolerance below which points are considered identical\r\n * @return boundary tree\r\n * @since 3.3\r\n *\/\r\nprivate static BSPTree<Euclidean3D> buildBoundary(final double xMin, final double xMax, final double yMin, final double yMax, final double zMin, final double zMax, final double tolerance) {\r\n    final Plane pxMin = new Plane(new Vector3D(xMin, 0, 0), Vector3D.MINUS_I, tolerance);\r\n    final Plane pxMax = new Plane(new Vector3D(xMax, 0, 0), Vector3D.PLUS_I, tolerance);\r\n    final Plane pyMin = new Plane(new Vector3D(0, yMin, 0), Vector3D.MINUS_J, tolerance);\r\n    final Plane pyMax = new Plane(new Vector3D(0, yMax, 0), Vector3D.PLUS_J, tolerance);\r\n    final Plane pzMin = new Plane(new Vector3D(0, 0, zMin), Vector3D.MINUS_K, tolerance);\r\n    final Plane pzMax = new Plane(new Vector3D(0, 0, zMax), Vector3D.PLUS_K, tolerance);\r\n    @SuppressWarnings(\"unchecked\")\r\n    final Region<Euclidean3D> boundary = new RegionFactory<Euclidean3D>().buildConvex(pxMin, pxMax, pyMin, pyMax, pzMin, pzMax);\r\n    return boundary.getTree(false);\r\n}","code_comment":"\/**\r\n * Build a parallellepipedic box boundary.\r\n * @param xMin low bound along the x direction\r\n * @param xMax high bound along the x direction\r\n * @param yMin low bound along the y direction\r\n * @param yMax high bound along the y direction\r\n * @param zMin low bound along the z direction\r\n * @param zMax high bound along the z direction\r\n * @param tolerance tolerance below which points are considered identical\r\n * @return boundary tree\r\n * @since 3.3\r\n *\/\r\n","code_no_comment":"private static BSPTree<Euclidean3D> buildBoundary(final double xMin, final double xMax, final double yMin, final double yMax, final double zMin, final double zMax, final double tolerance) {\r\n    final Plane pxMin = new Plane(new Vector3D(xMin, 0, 0), Vector3D.MINUS_I, tolerance);\r\n    final Plane pxMax = new Plane(new Vector3D(xMax, 0, 0), Vector3D.PLUS_I, tolerance);\r\n    final Plane pyMin = new Plane(new Vector3D(0, yMin, 0), Vector3D.MINUS_J, tolerance);\r\n    final Plane pyMax = new Plane(new Vector3D(0, yMax, 0), Vector3D.PLUS_J, tolerance);\r\n    final Plane pzMin = new Plane(new Vector3D(0, 0, zMin), Vector3D.MINUS_K, tolerance);\r\n    final Plane pzMax = new Plane(new Vector3D(0, 0, zMax), Vector3D.PLUS_K, tolerance);\r\n    @SuppressWarnings(\"unchecked\")\r\n    final Region<Euclidean3D> boundary = new RegionFactory<Euclidean3D>().buildConvex(pxMin, pxMax, pyMin, pyMax, pzMin, pzMax);\r\n    return boundary.getTree(false);\r\n}","lc":-0.1363636364,"pi":-0.6937799043,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.0311486963,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-286_dbdff075","label":1,"code":"\/**\r\n * Checks whether the given column is basic.\r\n * @param col index of the column to check\r\n * @return the row that the variable is basic in.  null if the column is not basic\r\n *\/\r\nprivate Integer getBasicRow(final int col) {\r\n    Integer row = null;\r\n    for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\r\n        if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\r\n            row = i;\r\n        } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\r\n            return null;\r\n        }\r\n    }\r\n    return row;\r\n}","code_comment":"\/**\r\n * Checks whether the given column is basic.\r\n * @param col index of the column to check\r\n * @return the row that the variable is basic in.  null if the column is not basic\r\n *\/\r\n","code_no_comment":"private Integer getBasicRow(final int col) {\r\n    Integer row = null;\r\n    for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\r\n        if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\r\n            row = i;\r\n        } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\r\n            return null;\r\n        }\r\n    }\r\n    return row;\r\n}","lc":-0.1363636364,"pi":0.4593301435,"ma":0.0,"nbd":0.5,"ml":0.5833333333,"d":0.9047619048,"mi":0.0990838619,"fo":0.0,"r":0.3947368421,"e":0.3556070377}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3143_ddd2c3bc","label":0,"code":"\/**\r\n * Writes the state for the current object out to the specified {@link DataOutput}\r\n *\r\n * @param dataOutput\r\n *          the output for which to write the object's state\r\n *\/\r\n@Override\r\npublic void write(DataOutput dataOutput) throws IOException {\r\n    if (iterators != null) {\r\n        dataOutput.writeInt(iterators.size());\r\n        for (IteratorSetting setting : iterators) setting.write(dataOutput);\r\n    } else {\r\n        dataOutput.writeInt(0);\r\n    }\r\n    if (ranges != null) {\r\n        dataOutput.writeInt(ranges.size());\r\n        for (Range range : ranges) range.write(dataOutput);\r\n    } else {\r\n        dataOutput.writeInt(0);\r\n    }\r\n    if (columns != null) {\r\n        dataOutput.writeInt(columns.size());\r\n        for (Pair<Text, Text> column : columns) {\r\n            if (column.getSecond() == null) {\r\n                dataOutput.writeInt(1);\r\n                column.getFirst().write(dataOutput);\r\n            } else {\r\n                dataOutput.writeInt(2);\r\n                column.getFirst().write(dataOutput);\r\n                column.getSecond().write(dataOutput);\r\n            }\r\n        }\r\n    } else {\r\n        dataOutput.writeInt(0);\r\n    }\r\n    dataOutput.writeBoolean(autoAdjustRanges);\r\n    dataOutput.writeBoolean(useLocalIterators);\r\n    dataOutput.writeBoolean(useIsolatedScanners);\r\n}","code_comment":"\/**\r\n * Writes the state for the current object out to the specified {@link DataOutput}\r\n *\r\n * @param dataOutput\r\n *          the output for which to write the object's state\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void write(DataOutput dataOutput) throws IOException {\r\n    if (iterators != null) {\r\n        dataOutput.writeInt(iterators.size());\r\n        for (IteratorSetting setting : iterators) setting.write(dataOutput);\r\n    } else {\r\n        dataOutput.writeInt(0);\r\n    }\r\n    if (ranges != null) {\r\n        dataOutput.writeInt(ranges.size());\r\n        for (Range range : ranges) range.write(dataOutput);\r\n    } else {\r\n        dataOutput.writeInt(0);\r\n    }\r\n    if (columns != null) {\r\n        dataOutput.writeInt(columns.size());\r\n        for (Pair<Text, Text> column : columns) {\r\n            if (column.getSecond() == null) {\r\n                dataOutput.writeInt(1);\r\n                column.getFirst().write(dataOutput);\r\n            } else {\r\n                dataOutput.writeInt(2);\r\n                column.getFirst().write(dataOutput);\r\n                column.getSecond().write(dataOutput);\r\n            }\r\n        }\r\n    } else {\r\n        dataOutput.writeInt(0);\r\n    }\r\n    dataOutput.writeBoolean(autoAdjustRanges);\r\n    dataOutput.writeBoolean(useLocalIterators);\r\n    dataOutput.writeBoolean(useIsolatedScanners);\r\n}","lc":0.8636363636,"pi":0.8373205742,"ma":0.8,"nbd":0.5,"ml":0.25,"d":0.2023809524,"mi":-0.5534883721,"fo":1.4166666667,"r":-0.0263157895,"e":0.3801432663}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1985_495a5c3c","label":0,"code":"public JobGraph createJobGraph(String jobName) {\r\n    jobGraph = new JobGraph(jobName);\r\n    \/\/ make sure that all vertices start immediately\r\n    jobGraph.setScheduleMode(ScheduleMode.ALL);\r\n    init();\r\n    setChaining();\r\n    setPhysicalEdges();\r\n    setSlotSharing();\r\n    configureCheckpointing();\r\n    return jobGraph;\r\n}","code_comment":null,"code_no_comment":"public JobGraph createJobGraph(String jobName) {\r\n    jobGraph = new JobGraph(jobName);\r\n        jobGraph.setScheduleMode(ScheduleMode.ALL);\r\n    init();\r\n    setChaining();\r\n    setPhysicalEdges();\r\n    setSlotSharing();\r\n    configureCheckpointing();\r\n    return jobGraph;\r\n}","lc":-0.1818181818,"pi":-0.6650717703,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.2882311487,"fo":0.0,"r":1.8684210526,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1133_27e40205","label":1,"code":"private <IN1, IN2> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> returnTypeHierarchy, TypeInformation<IN1> in1TypeInfo, TypeInformation<IN2> in2TypeInfo) {\r\n    Type matReturnTypeVar = materializeTypeVariable(returnTypeHierarchy, returnTypeVar);\r\n    \/\/ variable could be resolved\r\n    if (!(matReturnTypeVar instanceof TypeVariable)) {\r\n        return createTypeInfoWithTypeHierarchy(returnTypeHierarchy, matReturnTypeVar, in1TypeInfo, in2TypeInfo);\r\n    } else {\r\n        returnTypeVar = (TypeVariable<?>) matReturnTypeVar;\r\n    }\r\n    TypeInformation<?> info = null;\r\n    if (in1TypeInfo != null) {\r\n        \/\/ find the deepest type variable that describes the type of input 1\r\n        ParameterizedType baseClass = (ParameterizedType) returnTypeHierarchy.get(returnTypeHierarchy.size() - 1);\r\n        Type in1Type = baseClass.getActualTypeArguments()[0];\r\n        if (in1Type instanceof TypeVariable) {\r\n            in1Type = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) in1Type);\r\n            info = findCorrespondingInfo(returnTypeVar, in1Type, in1TypeInfo);\r\n        }\r\n    }\r\n    if (info == null && in2TypeInfo != null) {\r\n        \/\/ find the deepest type variable that describes the type of input 2\r\n        ParameterizedType baseClass = (ParameterizedType) returnTypeHierarchy.get(returnTypeHierarchy.size() - 1);\r\n        Type in2Type = baseClass.getActualTypeArguments()[1];\r\n        if (in2Type instanceof TypeVariable) {\r\n            in2Type = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) in2Type);\r\n            info = findCorrespondingInfo(returnTypeVar, in2Type, in2TypeInfo);\r\n        }\r\n    }\r\n    if (info != null) {\r\n        return info;\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"private <IN1, IN2> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> returnTypeHierarchy, TypeInformation<IN1> in1TypeInfo, TypeInformation<IN2> in2TypeInfo) {\r\n    Type matReturnTypeVar = materializeTypeVariable(returnTypeHierarchy, returnTypeVar);\r\n        if (!(matReturnTypeVar instanceof TypeVariable)) {\r\n        return createTypeInfoWithTypeHierarchy(returnTypeHierarchy, matReturnTypeVar, in1TypeInfo, in2TypeInfo);\r\n    } else {\r\n        returnTypeVar = (TypeVariable<?>) matReturnTypeVar;\r\n    }\r\n    TypeInformation<?> info = null;\r\n    if (in1TypeInfo != null) {\r\n                ParameterizedType baseClass = (ParameterizedType) returnTypeHierarchy.get(returnTypeHierarchy.size() - 1);\r\n        Type in1Type = baseClass.getActualTypeArguments()[0];\r\n        if (in1Type instanceof TypeVariable) {\r\n            in1Type = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) in1Type);\r\n            info = findCorrespondingInfo(returnTypeVar, in1Type, in1TypeInfo);\r\n        }\r\n    }\r\n    if (info == null && in2TypeInfo != null) {\r\n                ParameterizedType baseClass = (ParameterizedType) returnTypeHierarchy.get(returnTypeHierarchy.size() - 1);\r\n        Type in2Type = baseClass.getActualTypeArguments()[1];\r\n        if (in2Type instanceof TypeVariable) {\r\n            in2Type = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) in2Type);\r\n            info = findCorrespondingInfo(returnTypeVar, in2Type, in2TypeInfo);\r\n        }\r\n    }\r\n    if (info != null) {\r\n        return info;\r\n    }\r\n    return null;\r\n}","lc":0.6818181818,"pi":0.1196172249,"ma":0.6,"nbd":0.0,"ml":0.6666666667,"d":1.7063492063,"mi":-0.5357293869,"fo":0.5,"r":-0.0263157895,"e":2.581977029}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-811_7bb1ad47","label":1,"code":"@Override\r\npublic void logMessage(final String fqcn, final Level level, final Marker marker, final Message msg, final Throwable throwable) {\r\n    final StringBuilder sb = new StringBuilder();\r\n    \/\/ Append date-time if so configured\r\n    if (showDateTime) {\r\n        final Date now = new Date();\r\n        String dateText;\r\n        synchronized (dateFormatter) {\r\n            dateText = dateFormatter.format(now);\r\n        }\r\n        sb.append(dateText);\r\n        sb.append(SPACE);\r\n    }\r\n    sb.append(level.toString());\r\n    sb.append(SPACE);\r\n    if (logName != null && logName.length() > 0) {\r\n        sb.append(logName);\r\n        sb.append(SPACE);\r\n    }\r\n    sb.append(msg.getFormattedMessage());\r\n    if (showContextMap) {\r\n        final Map<String, String> mdc = ThreadContext.getContext();\r\n        if (mdc.size() > 0) {\r\n            sb.append(SPACE);\r\n            sb.append(mdc.toString());\r\n            sb.append(SPACE);\r\n        }\r\n    }\r\n    final Object[] params = msg.getParameters();\r\n    Throwable t;\r\n    if (throwable == null && params != null && params[params.length - 1] instanceof Throwable) {\r\n        t = (Throwable) params[params.length - 1];\r\n    } else {\r\n        t = throwable;\r\n    }\r\n    if (t != null) {\r\n        sb.append(SPACE);\r\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n        t.printStackTrace(new PrintStream(baos));\r\n        sb.append(baos.toString());\r\n    }\r\n    stream.println(sb.toString());\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void logMessage(final String fqcn, final Level level, final Marker marker, final Message msg, final Throwable throwable) {\r\n    final StringBuilder sb = new StringBuilder();\r\n        if (showDateTime) {\r\n        final Date now = new Date();\r\n        String dateText;\r\n        synchronized (dateFormatter) {\r\n            dateText = dateFormatter.format(now);\r\n        }\r\n        sb.append(dateText);\r\n        sb.append(SPACE);\r\n    }\r\n    sb.append(level.toString());\r\n    sb.append(SPACE);\r\n    if (logName != null && logName.length() > 0) {\r\n        sb.append(logName);\r\n        sb.append(SPACE);\r\n    }\r\n    sb.append(msg.getFormattedMessage());\r\n    if (showContextMap) {\r\n        final Map<String, String> mdc = ThreadContext.getContext();\r\n        if (mdc.size() > 0) {\r\n            sb.append(SPACE);\r\n            sb.append(mdc.toString());\r\n            sb.append(SPACE);\r\n        }\r\n    }\r\n    final Object[] params = msg.getParameters();\r\n    Throwable t;\r\n    if (throwable == null && params != null && params[params.length - 1] instanceof Throwable) {\r\n        t = (Throwable) params[params.length - 1];\r\n    } else {\r\n        t = throwable;\r\n    }\r\n    if (t != null) {\r\n        sb.append(SPACE);\r\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n        t.printStackTrace(new PrintStream(baos));\r\n        sb.append(baos.toString());\r\n    }\r\n    stream.println(sb.toString());\r\n}","lc":1.2727272727,"pi":0.028708134,"ma":0.6,"nbd":0.0,"ml":1.0,"d":1.1626984127,"mi":-0.7508104299,"fo":1.5,"r":-0.0263157895,"e":2.6080208387}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-47_b62f1c26","label":1,"code":"private void moveNode(String sourcePath, String targetPath, String lastRevision) {\r\n    if (isInIndex(sourcePath)) {\r\n        \/\/ don't index the index\r\n        return;\r\n    }\r\n    if (!mk.nodeExists(sourcePath, lastRevision)) {\r\n        return;\r\n    }\r\n    \/\/ TODO move: support large trees\r\n    String node = mk.getNodes(sourcePath, lastRevision, Integer.MAX_VALUE, 0, Integer.MAX_VALUE, null);\r\n    JsopTokenizer t = new JsopTokenizer(node);\r\n    NodeMap map = new NodeMap();\r\n    t.read('{');\r\n    NodeImpl n = NodeImpl.parse(map, t, 0, sourcePath);\r\n    addOrRemoveRecursive(n, true, false);\r\n    if (targetPath != null) {\r\n        t = new JsopTokenizer(node);\r\n        map = new NodeMap();\r\n        t.read('{');\r\n        n = NodeImpl.parse(map, t, 0, targetPath);\r\n        addOrRemoveRecursive(n, false, true);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void moveNode(String sourcePath, String targetPath, String lastRevision) {\r\n    if (isInIndex(sourcePath)) {\r\n                return;\r\n    }\r\n    if (!mk.nodeExists(sourcePath, lastRevision)) {\r\n        return;\r\n    }\r\n        String node = mk.getNodes(sourcePath, lastRevision, Integer.MAX_VALUE, 0, Integer.MAX_VALUE, null);\r\n    JsopTokenizer t = new JsopTokenizer(node);\r\n    NodeMap map = new NodeMap();\r\n    t.read('{');\r\n    NodeImpl n = NodeImpl.parse(map, t, 0, sourcePath);\r\n    addOrRemoveRecursive(n, true, false);\r\n    if (targetPath != null) {\r\n        t = new JsopTokenizer(node);\r\n        map = new NodeMap();\r\n        t.read('{');\r\n        n = NodeImpl.parse(map, t, 0, targetPath);\r\n        addOrRemoveRecursive(n, false, true);\r\n    }\r\n}","lc":0.3181818182,"pi":-0.2631578947,"ma":0.0,"nbd":-0.5,"ml":0.25,"d":0.1428571429,"mi":-0.3105003524,"fo":0.25,"r":-0.0263157895,"e":0.2881485451}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3757_c1b2f2f8","label":3,"code":"public Endpoint registerEndpoint(String uri, Endpoint endpoint) {\r\n    if (endpoint instanceof InterceptSendToEndpoint) {\r\n        \/\/ endpoint already decorated\r\n        return endpoint;\r\n    } else if (endpoint instanceof MockEndpoint) {\r\n        \/\/ we should not intercept mock endpoints\r\n        return endpoint;\r\n    } else if (uri == null || pattern == null || EndpointHelper.matchEndpoint(uri, pattern)) {\r\n        \/\/ if pattern is null then it mean to match all\r\n        \/\/ only proxy if the uri is matched decorate endpoint with our proxy\r\n        \/\/ should be false by default\r\n        InterceptSendToEndpoint proxy = new InterceptSendToEndpoint(endpoint, false);\r\n        \/\/ create mock endpoint which we will use as interceptor\r\n        \/\/ replace :\/\/ from scheme to make it easy to lookup the mock endpoint without having double :\/\/ in uri\r\n        String key = \"mock:\" + endpoint.getEndpointKey().replaceFirst(\":\/\/\", \":\");\r\n        LOG.info(\"Adviced endpoint [\" + uri + \"] with mock endpoint [\" + key + \"]\");\r\n        MockEndpoint mock = endpoint.getCamelContext().getEndpoint(key, MockEndpoint.class);\r\n        Processor producer;\r\n        try {\r\n            producer = mock.createProducer();\r\n        } catch (Exception e) {\r\n            throw wrapRuntimeCamelException(e);\r\n        }\r\n        proxy.setDetour(producer);\r\n        return proxy;\r\n    } else {\r\n        \/\/ no proxy so return regular endpoint\r\n        return endpoint;\r\n    }\r\n}","code_comment":null,"code_no_comment":"public Endpoint registerEndpoint(String uri, Endpoint endpoint) {\r\n    if (endpoint instanceof InterceptSendToEndpoint) {\r\n                return endpoint;\r\n    } else if (endpoint instanceof MockEndpoint) {\r\n                return endpoint;\r\n    } else if (uri == null || pattern == null || EndpointHelper.matchEndpoint(uri, pattern)) {\r\n                                InterceptSendToEndpoint proxy = new InterceptSendToEndpoint(endpoint, false);\r\n                        String key = \"mock:\" + endpoint.getEndpointKey().replaceFirst(\":\/\/\", \":\");\r\n        LOG.info(\"Adviced endpoint [\" + uri + \"] with mock endpoint [\" + key + \"]\");\r\n        MockEndpoint mock = endpoint.getCamelContext().getEndpoint(key, MockEndpoint.class);\r\n        Processor producer;\r\n        try {\r\n            producer = mock.createProducer();\r\n        } catch (Exception e) {\r\n            throw wrapRuntimeCamelException(e);\r\n        }\r\n        proxy.setDetour(producer);\r\n        return proxy;\r\n    } else {\r\n                return endpoint;\r\n    }\r\n}","lc":0.3636363636,"pi":0.028708134,"ma":0.4,"nbd":1.0,"ml":0.3333333333,"d":0.3373015873,"mi":-0.3437632135,"fo":0.25,"r":-0.0263157895,"e":0.4587864433}
{"project_name":"Codec","project_version":"11","label":1,"code":"\/**\r\n * Encodes byte into its quoted-printable representation.\r\n *\r\n * @param b\r\n *            byte to encode\r\n * @param buffer\r\n *            the buffer to write to\r\n * @return The number of bytes written to the <code>buffer<\/code>\r\n *\/\r\nprivate static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\r\n    buffer.write(ESCAPE_CHAR);\r\n    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\r\n    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\r\n    buffer.write(hex1);\r\n    buffer.write(hex2);\r\n}","code_comment":"\/**\r\n * Encodes byte into its quoted-printable representation.\r\n *\r\n * @param b\r\n *            byte to encode\r\n * @param buffer\r\n *            the buffer to write to\r\n * @return The number of bytes written to the <code>buffer<\/code>\r\n *\/\r\n","code_no_comment":"private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\r\n    buffer.write(ESCAPE_CHAR);\r\n    char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\r\n    char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\r\n    buffer.write(hex1);\r\n    buffer.write(hex2);\r\n}","lc":-0.3181818182,"pi":-0.5645933014,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":0.0456349206,"mi":0.3479915433,"fo":0.0833333333,"r":0.4736842105,"e":-0.0197622217}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2817_5dfc897b","label":3,"code":"private List<String> listNewFiles(FileSystem fileSystem) throws IOException {\r\n    List<String> files = new ArrayList<String>();\r\n    FileStatus[] statuses = fileSystem.listStatus(new Path(path));\r\n    for (FileStatus status : statuses) {\r\n        Path filePath = status.getPath();\r\n        String fileName = filePath.getName();\r\n        long modificationTime = status.getModificationTime();\r\n        if (!isFiltered(fileName, modificationTime)) {\r\n            files.add(filePath.toString());\r\n            modificationTimes.put(fileName, modificationTime);\r\n        }\r\n    }\r\n    return files;\r\n}","code_comment":null,"code_no_comment":"private List<String> listNewFiles(FileSystem fileSystem) throws IOException {\r\n    List<String> files = new ArrayList<String>();\r\n    FileStatus[] statuses = fileSystem.listStatus(new Path(path));\r\n    for (FileStatus status : statuses) {\r\n        Path filePath = status.getPath();\r\n        String fileName = filePath.getName();\r\n        long modificationTime = status.getModificationTime();\r\n        if (!isFiltered(fileName, modificationTime)) {\r\n            files.add(filePath.toString());\r\n            modificationTimes.put(fileName, modificationTime);\r\n        }\r\n    }\r\n    return files;\r\n}","lc":0.0,"pi":0.3062200957,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0297619048,"mi":-0.0505990134,"fo":0.1666666667,"r":0.0263157895,"e":0.0247459991}
{"project_name":"Math","project_version":"43","label":3,"code":"\/**\r\n * Add a value to the data\r\n * @param value the value to add\r\n *\/\r\npublic void addValue(double value) {\r\n    sumImpl.increment(value);\r\n    sumsqImpl.increment(value);\r\n    minImpl.increment(value);\r\n    maxImpl.increment(value);\r\n    sumLogImpl.increment(value);\r\n    secondMoment.increment(value);\r\n    \/\/ need to increment these\r\n    if (!(meanImpl instanceof Mean)) {\r\n        meanImpl.increment(value);\r\n    }\r\n    if (!(varianceImpl instanceof Variance)) {\r\n        varianceImpl.increment(value);\r\n    }\r\n    if (!(geoMeanImpl instanceof GeometricMean)) {\r\n        geoMeanImpl.increment(value);\r\n    }\r\n    n++;\r\n}","code_comment":"\/**\r\n * Add a value to the data\r\n * @param value the value to add\r\n *\/\r\n","code_no_comment":"public void addValue(double value) {\r\n    sumImpl.increment(value);\r\n    sumsqImpl.increment(value);\r\n    minImpl.increment(value);\r\n    maxImpl.increment(value);\r\n    sumLogImpl.increment(value);\r\n    secondMoment.increment(value);\r\n        if (!(meanImpl instanceof Mean)) {\r\n        meanImpl.increment(value);\r\n    }\r\n    if (!(varianceImpl instanceof Variance)) {\r\n        varianceImpl.increment(value);\r\n    }\r\n    if (!(geoMeanImpl instanceof GeometricMean)) {\r\n        geoMeanImpl.increment(value);\r\n    }\r\n    n++;\r\n}","lc":0.1818181818,"pi":-0.4258373206,"ma":0.0,"nbd":-0.5,"ml":0.0833333333,"d":0.0674603175,"mi":-0.1247357294,"fo":0.25,"r":-0.0263157895,"e":0.0119707474}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-9444_baece126","label":1,"code":"@Override\r\npublic Processor createProcessor(RouteContext routeContext) throws Exception {\r\n    Processor childProcessor = this.createChildProcessor(routeContext, true);\r\n    aggregationStrategy = createAggregationStrategy(routeContext);\r\n    boolean isParallelProcessing = getParallelProcessing() != null && getParallelProcessing();\r\n    boolean isStreaming = getStreaming() != null && getStreaming();\r\n    boolean isShareUnitOfWork = getShareUnitOfWork() != null && getShareUnitOfWork();\r\n    boolean isParallelAggregate = getParallelAggregate() != null && getParallelAggregate();\r\n    boolean shutdownThreadPool = ProcessorDefinitionHelper.willCreateNewThreadPool(routeContext, this, isParallelProcessing);\r\n    ExecutorService threadPool = ProcessorDefinitionHelper.getConfiguredExecutorService(routeContext, \"Split\", this, isParallelProcessing);\r\n    long timeout = getTimeout() != null ? getTimeout() : 0;\r\n    if (timeout > 0 && !isParallelProcessing) {\r\n        throw new IllegalArgumentException(\"Timeout is used but ParallelProcessing has not been enabled.\");\r\n    }\r\n    if (onPrepareRef != null) {\r\n        onPrepare = CamelContextHelper.mandatoryLookup(routeContext.getCamelContext(), onPrepareRef, Processor.class);\r\n    }\r\n    Expression exp = getExpression().createExpression(routeContext);\r\n    Splitter answer = new Splitter(routeContext.getCamelContext(), exp, childProcessor, aggregationStrategy, isParallelProcessing, threadPool, shutdownThreadPool, isStreaming, isStopOnException(), timeout, onPrepare, isShareUnitOfWork, isParallelAggregate);\r\n    return answer;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Processor createProcessor(RouteContext routeContext) throws Exception {\r\n    Processor childProcessor = this.createChildProcessor(routeContext, true);\r\n    aggregationStrategy = createAggregationStrategy(routeContext);\r\n    boolean isParallelProcessing = getParallelProcessing() != null && getParallelProcessing();\r\n    boolean isStreaming = getStreaming() != null && getStreaming();\r\n    boolean isShareUnitOfWork = getShareUnitOfWork() != null && getShareUnitOfWork();\r\n    boolean isParallelAggregate = getParallelAggregate() != null && getParallelAggregate();\r\n    boolean shutdownThreadPool = ProcessorDefinitionHelper.willCreateNewThreadPool(routeContext, this, isParallelProcessing);\r\n    ExecutorService threadPool = ProcessorDefinitionHelper.getConfiguredExecutorService(routeContext, \"Split\", this, isParallelProcessing);\r\n    long timeout = getTimeout() != null ? getTimeout() : 0;\r\n    if (timeout > 0 && !isParallelProcessing) {\r\n        throw new IllegalArgumentException(\"Timeout is used but ParallelProcessing has not been enabled.\");\r\n    }\r\n    if (onPrepareRef != null) {\r\n        onPrepare = CamelContextHelper.mandatoryLookup(routeContext.getCamelContext(), onPrepareRef, Processor.class);\r\n    }\r\n    Expression exp = getExpression().createExpression(routeContext);\r\n    Splitter answer = new Splitter(routeContext.getCamelContext(), exp, childProcessor, aggregationStrategy, isParallelProcessing, threadPool, shutdownThreadPool, isStreaming, isStopOnException(), timeout, onPrepare, isShareUnitOfWork, isParallelAggregate);\r\n    return answer;\r\n}","lc":0.3181818182,"pi":-0.5023923445,"ma":0.2,"nbd":-0.5,"ml":0.25,"d":0.3849206349,"mi":-0.3877378436,"fo":1.1666666667,"r":-0.0263157895,"e":0.918488039}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-581_bb02fa15","label":1,"code":"@Override\r\nprotected void createFileAfterRollover() throws IOException {\r\n    this.randomAccessFile = new RandomAccessFile(getFileName(), \"rw\");\r\n    if (isAppend()) {\r\n        randomAccessFile.seek(randomAccessFile.length());\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void createFileAfterRollover() throws IOException {\r\n    this.randomAccessFile = new RandomAccessFile(getFileName(), \"rw\");\r\n    if (isAppend()) {\r\n        randomAccessFile.seek(randomAccessFile.length());\r\n    }\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.5019027484,"fo":-0.1666666667,"r":0.3157894737,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-579_7d72e6ed","label":3,"code":"@Override\r\npublic void restrict(FilterImpl f) {\r\n    if (f.getSelector() == selector1) {\r\n        PropertyValue p2 = selector2.currentProperty(property2Name);\r\n        if (p2 != null) {\r\n            if (!p2.isArray()) {\r\n                \/\/ TODO support join on multi-valued properties\r\n                f.restrictProperty(property1Name, Operator.EQUAL, p2);\r\n            }\r\n        }\r\n    }\r\n    if (f.getSelector() == selector2) {\r\n        PropertyValue p1 = selector1.currentProperty(property1Name);\r\n        if (p1 != null) {\r\n            if (!p1.isArray()) {\r\n                \/\/ TODO support join on multi-valued properties\r\n                f.restrictProperty(property2Name, Operator.EQUAL, p1);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void restrict(FilterImpl f) {\r\n    if (f.getSelector() == selector1) {\r\n        PropertyValue p2 = selector2.currentProperty(property2Name);\r\n        if (p2 != null) {\r\n            if (!p2.isArray()) {\r\n                                f.restrictProperty(property1Name, Operator.EQUAL, p2);\r\n            }\r\n        }\r\n    }\r\n    if (f.getSelector() == selector2) {\r\n        PropertyValue p1 = selector1.currentProperty(property1Name);\r\n        if (p1 != null) {\r\n            if (!p1.isArray()) {\r\n                                f.restrictProperty(property2Name, Operator.EQUAL, p1);\r\n            }\r\n        }\r\n    }\r\n}","lc":0.2272727273,"pi":0.8851674641,"ma":0.6,"nbd":0.5,"ml":0.6666666667,"d":0.4920634921,"mi":-0.2042283298,"fo":0.1666666667,"r":0.0263157895,"e":0.2782363145}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-414_ebf22df0","label":1,"code":"\/**\r\n * Advances to the next K,V pair.\r\n *\r\n * @throws IOException\r\n *           if an I\/O error occurs.\r\n * @exception IllegalStateException\r\n *              if called before seek.\r\n * @exception NoSuchElementException\r\n *              if next element doesn't exist.\r\n *\/\r\nvoid next() throws IOException;","code_comment":"\/**\r\n * Advances to the next K,V pair.\r\n *\r\n * @throws IOException\r\n *           if an I\/O error occurs.\r\n * @exception IllegalStateException\r\n *              if called before seek.\r\n * @exception NoSuchElementException\r\n *              if next element doesn't exist.\r\n *\/\r\n","code_no_comment":"void next() throws IOException;","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.7424947146,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-988_d270055e","label":1,"code":"\/**\r\n * Get the intersection of the instance and another sub-line.\r\n * <p>\r\n * This method is related to the {@link Line#intersection(Line)\r\n * intersection} method in the {@link Line Line} class, but in addition\r\n * to compute the point along infinite lines, it also checks the point\r\n * lies on both sub-line ranges.\r\n * <\/p>\r\n * @param subLine other sub-line which may intersect instance\r\n * @param includeEndPoints if true, endpoints are considered to belong to\r\n * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\r\n * are considered to not belong to instance (i.e. they are open sets) and intersection\r\n * occurring on endpoints lead to null being returned\r\n * @return the intersection point if there is one, null if the sub-lines don't intersect\r\n *\/\r\npublic Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\r\n    \/\/ retrieve the underlying lines\r\n    Line line1 = (Line) getHyperplane();\r\n    Line line2 = (Line) subLine.getHyperplane();\r\n    \/\/ compute the intersection on infinite line\r\n    Vector2D v2D = line1.intersection(line2);\r\n    \/\/ check location of point with respect to first sub-line\r\n    Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\r\n    \/\/ check location of point with respect to second sub-line\r\n    Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\r\n    if (includeEndPoints) {\r\n        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\r\n    } else {\r\n        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\r\n    }\r\n}","code_comment":"\/**\r\n * Get the intersection of the instance and another sub-line.\r\n * <p>\r\n * This method is related to the {@link Line#intersection(Line)\r\n * intersection} method in the {@link Line Line} class, but in addition\r\n * to compute the point along infinite lines, it also checks the point\r\n * lies on both sub-line ranges.\r\n * <\/p>\r\n * @param subLine other sub-line which may intersect instance\r\n * @param includeEndPoints if true, endpoints are considered to belong to\r\n * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\r\n * are considered to not belong to instance (i.e. they are open sets) and intersection\r\n * occurring on endpoints lead to null being returned\r\n * @return the intersection point if there is one, null if the sub-lines don't intersect\r\n *\/\r\n","code_no_comment":"public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\r\n        Line line1 = (Line) getHyperplane();\r\n    Line line2 = (Line) subLine.getHyperplane();\r\n        Vector2D v2D = line1.intersection(line2);\r\n        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\r\n        Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\r\n    if (includeEndPoints) {\r\n        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\r\n    } else {\r\n        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\r\n    }\r\n}","lc":-0.0909090909,"pi":-0.3253588517,"ma":0.0,"nbd":-0.5,"ml":0.25,"d":0.6666666667,"mi":-0.0136715997,"fo":0.25,"r":-0.0263157895,"e":0.52969347}
{"project_name":"Closure","project_version":"51","label":2,"code":"void addNumber(double x) {\r\n    \/\/ This is not pretty printing. This is to prevent misparsing of x- -4 as\r\n    \/\/ x--4 (which is a syntax error).\r\n    char prev = getLastChar();\r\n    if (x < 0 && prev == '-') {\r\n        add(\" \");\r\n    }\r\n    if ((long) x == x) {\r\n        long value = (long) x;\r\n        long mantissa = value;\r\n        int exp = 0;\r\n        if (Math.abs(x) >= 100) {\r\n            while (mantissa \/ 10 * Math.pow(10, exp + 1) == value) {\r\n                mantissa \/= 10;\r\n                exp++;\r\n            }\r\n        }\r\n        if (exp > 2) {\r\n            add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\r\n        } else {\r\n            add(Long.toString(value));\r\n        }\r\n    } else {\r\n        add(String.valueOf(x));\r\n    }\r\n}","code_comment":null,"code_no_comment":"void addNumber(double x) {\r\n            char prev = getLastChar();\r\n    if (x < 0 && prev == '-') {\r\n        add(\" \");\r\n    }\r\n    if ((long) x == x) {\r\n        long value = (long) x;\r\n        long mantissa = value;\r\n        int exp = 0;\r\n        if (Math.abs(x) >= 100) {\r\n            while (mantissa \/ 10 * Math.pow(10, exp + 1) == value) {\r\n                mantissa \/= 10;\r\n                exp++;\r\n            }\r\n        }\r\n        if (exp > 2) {\r\n            add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\r\n        } else {\r\n            add(Long.toString(value));\r\n        }\r\n    } else {\r\n        add(String.valueOf(x));\r\n    }\r\n}","lc":0.4545454545,"pi":0.5550239234,"ma":0.4,"nbd":0.5,"ml":0.6666666667,"d":1.6984126984,"mi":-0.3739252995,"fo":0.4166666667,"r":0.5263157895,"e":1.5476150136}
{"project_name":"Cli","project_version":"31","label":3,"code":"\/**\r\n * Resets the member variables to their default values.\r\n *\/\r\nprivate static void reset() {\r\n    description = null;\r\n    argName = \"arg\";\r\n    longopt = null;\r\n    type = null;\r\n    required = false;\r\n    numberOfArgs = Option.UNINITIALIZED;\r\n    optionalArg = false;\r\n    valuesep = (char) 0;\r\n}","code_comment":"\/**\r\n * Resets the member variables to their default values.\r\n *\/\r\n","code_no_comment":"private static void reset() {\r\n    description = null;\r\n    argName = \"arg\";\r\n    longopt = null;\r\n    type = null;\r\n    required = false;\r\n    numberOfArgs = Option.UNINITIALIZED;\r\n    optionalArg = false;\r\n    valuesep = (char) 0;\r\n}","lc":-0.1818181818,"pi":-0.6650717703,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.230162086,"fo":-0.5,"r":2.5,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-318_83f18d52","label":1,"code":"\/**\r\n * Flip qd array if warranted.\r\n * @param n number of rows in the block\r\n * @param step within the array (1 for flipping all elements, 2 for flipping\r\n * only every other element)\r\n * @return true if qd array was flipped\r\n *\/\r\nprivate boolean flipIfWarranted(final int n, final int step) {\r\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\r\n        \/\/ flip array\r\n        int j = 4 * n - 1;\r\n        for (int i = 0; i < j; i += 4) {\r\n            for (int k = 0; k < 4; k += step) {\r\n                final double tmp = work[i + k];\r\n                work[i + k] = work[j - k];\r\n                work[j - k] = tmp;\r\n            }\r\n            j -= 4;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}","code_comment":"\/**\r\n * Flip qd array if warranted.\r\n * @param n number of rows in the block\r\n * @param step within the array (1 for flipping all elements, 2 for flipping\r\n * only every other element)\r\n * @return true if qd array was flipped\r\n *\/\r\n","code_no_comment":"private boolean flipIfWarranted(final int n, final int step) {\r\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\r\n                int j = 4 * n - 1;\r\n        for (int i = 0; i < j; i += 4) {\r\n            for (int k = 0; k < 4; k += step) {\r\n                final double tmp = work[i + k];\r\n                work[i + k] = work[j - k];\r\n                work[j - k] = tmp;\r\n            }\r\n            j -= 4;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}","lc":0.0454545455,"pi":1.0765550239,"ma":0.0,"nbd":0.5,"ml":0.0833333333,"d":1.3452380952,"mi":-0.1247357294,"fo":-0.5,"r":0.9736842105,"e":1.0603620269}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-834_d3989b40","label":1,"code":"\/**\r\n * Loads classes not located via Reflection.getCallerClass.\r\n *\r\n * @param lastLoader\r\n *        The ClassLoader that loaded the Class that called this Class.\r\n * @param className\r\n *        The name of the Class.\r\n * @return The Class object for the Class or null if it could not be located.\r\n *\/\r\nprivate Class<?> loadClass(final ClassLoader lastLoader, final String className) {\r\n    \/\/ XXX: this is overly complicated\r\n    Class<?> clazz;\r\n    if (lastLoader != null) {\r\n        try {\r\n            clazz = Loader.initializeClass(className, lastLoader);\r\n            if (clazz != null) {\r\n                return clazz;\r\n            }\r\n        } catch (final Throwable ignore) {\r\n        \/\/ Ignore exception.\r\n        }\r\n    }\r\n    try {\r\n        clazz = Loader.loadClass(className);\r\n    } catch (final ClassNotFoundException ignored) {\r\n        try {\r\n            clazz = Loader.initializeClass(className, this.getClass().getClassLoader());\r\n        } catch (final ClassNotFoundException ignore) {\r\n            return null;\r\n        }\r\n    }\r\n    return clazz;\r\n}","code_comment":"\/**\r\n * Loads classes not located via Reflection.getCallerClass.\r\n *\r\n * @param lastLoader\r\n *        The ClassLoader that loaded the Class that called this Class.\r\n * @param className\r\n *        The name of the Class.\r\n * @return The Class object for the Class or null if it could not be located.\r\n *\/\r\n","code_no_comment":"private Class<?> loadClass(final ClassLoader lastLoader, final String className) {\r\n        Class<?> clazz;\r\n    if (lastLoader != null) {\r\n        try {\r\n            clazz = Loader.initializeClass(className, lastLoader);\r\n            if (clazz != null) {\r\n                return clazz;\r\n            }\r\n        } catch (final Throwable ignore) {\r\n                }\r\n    }\r\n    try {\r\n        clazz = Loader.loadClass(className);\r\n    } catch (final ClassNotFoundException ignored) {\r\n        try {\r\n            clazz = Loader.initializeClass(className, this.getClass().getClassLoader());\r\n        } catch (final ClassNotFoundException ignore) {\r\n            return null;\r\n        }\r\n    }\r\n    return clazz;\r\n}","lc":0.3636363636,"pi":0.5358851675,"ma":0.4,"nbd":0.5,"ml":-0.0833333333,"d":0.0674603175,"mi":-0.2326990839,"fo":-0.0833333333,"r":0.1052631579,"e":0.0162307014}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7100_00a9b02b","label":1,"code":"@Override\r\npublic void close() throws IOException {\r\n    if (value instanceof Closeable) {\r\n        IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\r\n    } else if (value instanceof Scanner) {\r\n        \/\/ special for Scanner as it does not implement Closeable\r\n        Scanner scanner = (Scanner) value;\r\n        scanner.close();\r\n        IOException ioException = scanner.ioException();\r\n        if (ioException != null) {\r\n            throw ioException;\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void close() throws IOException {\r\n    if (value instanceof Closeable) {\r\n        IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\r\n    } else if (value instanceof Scanner) {\r\n                Scanner scanner = (Scanner) value;\r\n        scanner.close();\r\n        IOException ioException = scanner.ioException();\r\n        if (ioException != null) {\r\n            throw ioException;\r\n        }\r\n    }\r\n}","lc":-0.0454545455,"pi":0.3349282297,"ma":0.2,"nbd":0.5,"ml":0.0,"d":0.0456349206,"mi":0.0627202255,"fo":-0.0833333333,"r":0.1315789474,"e":-0.0405548544}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-377_c640932d","label":1,"code":"\/**\r\n * Get the Chi-Square value.\r\n * @return chi-square value\r\n *\/\r\npublic double getChiSquare() {\r\n    double chiSquare = 0;\r\n    for (int i = 0; i < rows; ++i) {\r\n        final double residual = residuals[i];\r\n        chiSquare += residual * residual \/ residualsWeights[i];\r\n    }\r\n    return chiSquare;\r\n}","code_comment":"\/**\r\n * Get the Chi-Square value.\r\n * @return chi-square value\r\n *\/\r\n","code_no_comment":"public double getChiSquare() {\r\n    double chiSquare = 0;\r\n    for (int i = 0; i < rows; ++i) {\r\n        final double residual = residuals[i];\r\n        chiSquare += residual * residual \/ residualsWeights[i];\r\n    }\r\n    return chiSquare;\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":0.8253968254,"mi":0.3375616631,"fo":-0.5,"r":2.5526315789,"e":0.1181929773}
{"project_name":"Closure","project_version":"100","label":2,"code":"private boolean shouldReportThis(Node n, Node parent) {\r\n    if (assignLhsChild != null) {\r\n        \/\/ Always report a THIS on the left side of an assign.\r\n        return true;\r\n    }\r\n    \/\/ Also report a THIS with a property access.\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"private boolean shouldReportThis(Node n, Node parent) {\r\n    if (assignLhsChild != null) {\r\n                return true;\r\n    }\r\n        return false;\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.6188865398,"fo":-0.5,"r":2.4473684211,"e":-0.1627934049}
{"project_name":"Math","project_version":"6","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected PointVectorValuePair doOptimize() {\r\n    checkParameters();\r\n    \/\/ Number of observed data.\r\n    final int nR = getTarget().length;\r\n    final double[] currentPoint = getStartPoint();\r\n    \/\/ Number of parameters.\r\n    final int nC = currentPoint.length;\r\n    \/\/ arrays shared with the other private methods\r\n    solvedCols = FastMath.min(nR, nC);\r\n    diagR = new double[nC];\r\n    jacNorm = new double[nC];\r\n    beta = new double[nC];\r\n    permutation = new int[nC];\r\n    lmDir = new double[nC];\r\n    \/\/ local point\r\n    double delta = 0;\r\n    double xNorm = 0;\r\n    double[] diag = new double[nC];\r\n    double[] oldX = new double[nC];\r\n    double[] oldRes = new double[nR];\r\n    double[] oldObj = new double[nR];\r\n    double[] qtf = new double[nR];\r\n    double[] work1 = new double[nC];\r\n    double[] work2 = new double[nC];\r\n    double[] work3 = new double[nC];\r\n    final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\r\n    \/\/ Evaluate the function at the starting point and calculate its norm.\r\n    double[] currentObjective = computeObjectiveValue(currentPoint);\r\n    double[] currentResiduals = computeResiduals(currentObjective);\r\n    PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);\r\n    double currentCost = computeCost(currentResiduals);\r\n    \/\/ Outer loop.\r\n    lmPar = 0;\r\n    boolean firstIteration = true;\r\n    int iter = 0;\r\n    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\r\n    while (true) {\r\n        ++iter;\r\n        final PointVectorValuePair previous = current;\r\n        \/\/ QR decomposition of the jacobian matrix\r\n        qrDecomposition(computeWeightedJacobian(currentPoint));\r\n        weightedResidual = weightMatrixSqrt.operate(currentResiduals);\r\n        for (int i = 0; i < nR; i++) {\r\n            qtf[i] = weightedResidual[i];\r\n        }\r\n        \/\/ compute Qt.res\r\n        qTy(qtf);\r\n        \/\/ so let jacobian contain the R matrix with its diagonal elements\r\n        for (int k = 0; k < solvedCols; ++k) {\r\n            int pk = permutation[k];\r\n            weightedJacobian[k][pk] = diagR[pk];\r\n        }\r\n        if (firstIteration) {\r\n            \/\/ scale the point according to the norms of the columns\r\n            \/\/ of the initial jacobian\r\n            xNorm = 0;\r\n            for (int k = 0; k < nC; ++k) {\r\n                double dk = jacNorm[k];\r\n                if (dk == 0) {\r\n                    dk = 1.0;\r\n                }\r\n                double xk = dk * currentPoint[k];\r\n                xNorm += xk * xk;\r\n                diag[k] = dk;\r\n            }\r\n            xNorm = FastMath.sqrt(xNorm);\r\n            \/\/ initialize the step bound delta\r\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\r\n        }\r\n        \/\/ check orthogonality between function vector and jacobian columns\r\n        double maxCosine = 0;\r\n        if (currentCost != 0) {\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                double s = jacNorm[pj];\r\n                if (s != 0) {\r\n                    double sum = 0;\r\n                    for (int i = 0; i <= j; ++i) {\r\n                        sum += weightedJacobian[i][pj] * qtf[i];\r\n                    }\r\n                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) \/ (s * currentCost));\r\n                }\r\n            }\r\n        }\r\n        if (maxCosine <= orthoTolerance) {\r\n            \/\/ Convergence has been reached.\r\n            setCost(currentCost);\r\n            return current;\r\n        }\r\n        \/\/ rescale if necessary\r\n        for (int j = 0; j < nC; ++j) {\r\n            diag[j] = FastMath.max(diag[j], jacNorm[j]);\r\n        }\r\n        \/\/ Inner loop.\r\n        for (double ratio = 0; ratio < 1.0e-4; ) {\r\n            \/\/ save the state\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                oldX[pj] = currentPoint[pj];\r\n            }\r\n            final double previousCost = currentCost;\r\n            double[] tmpVec = weightedResidual;\r\n            weightedResidual = oldRes;\r\n            oldRes = tmpVec;\r\n            tmpVec = currentObjective;\r\n            currentObjective = oldObj;\r\n            oldObj = tmpVec;\r\n            \/\/ determine the Levenberg-Marquardt parameter\r\n            determineLMParameter(qtf, delta, diag, work1, work2, work3);\r\n            \/\/ compute the new point and the norm of the evolution direction\r\n            double lmNorm = 0;\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                lmDir[pj] = -lmDir[pj];\r\n                currentPoint[pj] = oldX[pj] + lmDir[pj];\r\n                double s = diag[pj] * lmDir[pj];\r\n                lmNorm += s * s;\r\n            }\r\n            lmNorm = FastMath.sqrt(lmNorm);\r\n            \/\/ on the first iteration, adjust the initial step bound.\r\n            if (firstIteration) {\r\n                delta = FastMath.min(delta, lmNorm);\r\n            }\r\n            \/\/ Evaluate the function at x + p and calculate its norm.\r\n            currentObjective = computeObjectiveValue(currentPoint);\r\n            currentResiduals = computeResiduals(currentObjective);\r\n            current = new PointVectorValuePair(currentPoint, currentObjective);\r\n            currentCost = computeCost(currentResiduals);\r\n            \/\/ compute the scaled actual reduction\r\n            double actRed = -1.0;\r\n            if (0.1 * currentCost < previousCost) {\r\n                double r = currentCost \/ previousCost;\r\n                actRed = 1.0 - r * r;\r\n            }\r\n            \/\/ and the scaled directional derivative\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                double dirJ = lmDir[pj];\r\n                work1[j] = 0;\r\n                for (int i = 0; i <= j; ++i) {\r\n                    work1[i] += weightedJacobian[i][pj] * dirJ;\r\n                }\r\n            }\r\n            double coeff1 = 0;\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                coeff1 += work1[j] * work1[j];\r\n            }\r\n            double pc2 = previousCost * previousCost;\r\n            coeff1 = coeff1 \/ pc2;\r\n            double coeff2 = lmPar * lmNorm * lmNorm \/ pc2;\r\n            double preRed = coeff1 + 2 * coeff2;\r\n            double dirDer = -(coeff1 + coeff2);\r\n            \/\/ ratio of the actual to the predicted reduction\r\n            ratio = (preRed == 0) ? 0 : (actRed \/ preRed);\r\n            \/\/ update the step bound\r\n            if (ratio <= 0.25) {\r\n                double tmp = (actRed < 0) ? (0.5 * dirDer \/ (dirDer + 0.5 * actRed)) : 0.5;\r\n                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\r\n                    tmp = 0.1;\r\n                }\r\n                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\r\n                lmPar \/= tmp;\r\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\r\n                delta = 2 * lmNorm;\r\n                lmPar *= 0.5;\r\n            }\r\n            \/\/ test for successful iteration.\r\n            if (ratio >= 1.0e-4) {\r\n                \/\/ successful iteration, update the norm\r\n                firstIteration = false;\r\n                xNorm = 0;\r\n                for (int k = 0; k < nC; ++k) {\r\n                    double xK = diag[k] * currentPoint[k];\r\n                    xNorm += xK * xK;\r\n                }\r\n                xNorm = FastMath.sqrt(xNorm);\r\n                \/\/ tests for convergence.\r\n                if (checker != null) {\r\n                    \/\/ we use the vectorial convergence checker\r\n                    if (checker.converged(iter, previous, current)) {\r\n                        setCost(currentCost);\r\n                        return current;\r\n                    }\r\n                }\r\n            } else {\r\n                \/\/ failed iteration, reset the previous values\r\n                currentCost = previousCost;\r\n                for (int j = 0; j < solvedCols; ++j) {\r\n                    int pj = permutation[j];\r\n                    currentPoint[pj] = oldX[pj];\r\n                }\r\n                tmpVec = weightedResidual;\r\n                weightedResidual = oldRes;\r\n                oldRes = tmpVec;\r\n                tmpVec = currentObjective;\r\n                currentObjective = oldObj;\r\n                oldObj = tmpVec;\r\n                \/\/ Reset \"current\" to previous values.\r\n                current = new PointVectorValuePair(currentPoint, currentObjective);\r\n            }\r\n            \/\/ Default convergence criteria.\r\n            if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {\r\n                setCost(currentCost);\r\n                return current;\r\n            }\r\n            \/\/ (2.2204e-16 is the machine epsilon for IEEE754)\r\n            if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\r\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\r\n            } else if (delta <= 2.2204e-16 * xNorm) {\r\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\r\n            } else if (maxCosine <= 2.2204e-16) {\r\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected PointVectorValuePair doOptimize() {\r\n    checkParameters();\r\n        final int nR = getTarget().length;\r\n    final double[] currentPoint = getStartPoint();\r\n        final int nC = currentPoint.length;\r\n        solvedCols = FastMath.min(nR, nC);\r\n    diagR = new double[nC];\r\n    jacNorm = new double[nC];\r\n    beta = new double[nC];\r\n    permutation = new int[nC];\r\n    lmDir = new double[nC];\r\n        double delta = 0;\r\n    double xNorm = 0;\r\n    double[] diag = new double[nC];\r\n    double[] oldX = new double[nC];\r\n    double[] oldRes = new double[nR];\r\n    double[] oldObj = new double[nR];\r\n    double[] qtf = new double[nR];\r\n    double[] work1 = new double[nC];\r\n    double[] work2 = new double[nC];\r\n    double[] work3 = new double[nC];\r\n    final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\r\n        double[] currentObjective = computeObjectiveValue(currentPoint);\r\n    double[] currentResiduals = computeResiduals(currentObjective);\r\n    PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);\r\n    double currentCost = computeCost(currentResiduals);\r\n        lmPar = 0;\r\n    boolean firstIteration = true;\r\n    int iter = 0;\r\n    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\r\n    while (true) {\r\n        ++iter;\r\n        final PointVectorValuePair previous = current;\r\n                qrDecomposition(computeWeightedJacobian(currentPoint));\r\n        weightedResidual = weightMatrixSqrt.operate(currentResiduals);\r\n        for (int i = 0; i < nR; i++) {\r\n            qtf[i] = weightedResidual[i];\r\n        }\r\n                qTy(qtf);\r\n                for (int k = 0; k < solvedCols; ++k) {\r\n            int pk = permutation[k];\r\n            weightedJacobian[k][pk] = diagR[pk];\r\n        }\r\n        if (firstIteration) {\r\n                                    xNorm = 0;\r\n            for (int k = 0; k < nC; ++k) {\r\n                double dk = jacNorm[k];\r\n                if (dk == 0) {\r\n                    dk = 1.0;\r\n                }\r\n                double xk = dk * currentPoint[k];\r\n                xNorm += xk * xk;\r\n                diag[k] = dk;\r\n            }\r\n            xNorm = FastMath.sqrt(xNorm);\r\n                        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\r\n        }\r\n                double maxCosine = 0;\r\n        if (currentCost != 0) {\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                double s = jacNorm[pj];\r\n                if (s != 0) {\r\n                    double sum = 0;\r\n                    for (int i = 0; i <= j; ++i) {\r\n                        sum += weightedJacobian[i][pj] * qtf[i];\r\n                    }\r\n                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) \/ (s * currentCost));\r\n                }\r\n            }\r\n        }\r\n        if (maxCosine <= orthoTolerance) {\r\n                        setCost(currentCost);\r\n            return current;\r\n        }\r\n                for (int j = 0; j < nC; ++j) {\r\n            diag[j] = FastMath.max(diag[j], jacNorm[j]);\r\n        }\r\n                for (double ratio = 0; ratio < 1.0e-4; ) {\r\n                        for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                oldX[pj] = currentPoint[pj];\r\n            }\r\n            final double previousCost = currentCost;\r\n            double[] tmpVec = weightedResidual;\r\n            weightedResidual = oldRes;\r\n            oldRes = tmpVec;\r\n            tmpVec = currentObjective;\r\n            currentObjective = oldObj;\r\n            oldObj = tmpVec;\r\n                        determineLMParameter(qtf, delta, diag, work1, work2, work3);\r\n                        double lmNorm = 0;\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                lmDir[pj] = -lmDir[pj];\r\n                currentPoint[pj] = oldX[pj] + lmDir[pj];\r\n                double s = diag[pj] * lmDir[pj];\r\n                lmNorm += s * s;\r\n            }\r\n            lmNorm = FastMath.sqrt(lmNorm);\r\n                        if (firstIteration) {\r\n                delta = FastMath.min(delta, lmNorm);\r\n            }\r\n                        currentObjective = computeObjectiveValue(currentPoint);\r\n            currentResiduals = computeResiduals(currentObjective);\r\n            current = new PointVectorValuePair(currentPoint, currentObjective);\r\n            currentCost = computeCost(currentResiduals);\r\n                        double actRed = -1.0;\r\n            if (0.1 * currentCost < previousCost) {\r\n                double r = currentCost \/ previousCost;\r\n                actRed = 1.0 - r * r;\r\n            }\r\n                        for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                double dirJ = lmDir[pj];\r\n                work1[j] = 0;\r\n                for (int i = 0; i <= j; ++i) {\r\n                    work1[i] += weightedJacobian[i][pj] * dirJ;\r\n                }\r\n            }\r\n            double coeff1 = 0;\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                coeff1 += work1[j] * work1[j];\r\n            }\r\n            double pc2 = previousCost * previousCost;\r\n            coeff1 = coeff1 \/ pc2;\r\n            double coeff2 = lmPar * lmNorm * lmNorm \/ pc2;\r\n            double preRed = coeff1 + 2 * coeff2;\r\n            double dirDer = -(coeff1 + coeff2);\r\n                        ratio = (preRed == 0) ? 0 : (actRed \/ preRed);\r\n                        if (ratio <= 0.25) {\r\n                double tmp = (actRed < 0) ? (0.5 * dirDer \/ (dirDer + 0.5 * actRed)) : 0.5;\r\n                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\r\n                    tmp = 0.1;\r\n                }\r\n                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\r\n                lmPar \/= tmp;\r\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\r\n                delta = 2 * lmNorm;\r\n                lmPar *= 0.5;\r\n            }\r\n                        if (ratio >= 1.0e-4) {\r\n                                firstIteration = false;\r\n                xNorm = 0;\r\n                for (int k = 0; k < nC; ++k) {\r\n                    double xK = diag[k] * currentPoint[k];\r\n                    xNorm += xK * xK;\r\n                }\r\n                xNorm = FastMath.sqrt(xNorm);\r\n                                if (checker != null) {\r\n                                        if (checker.converged(iter, previous, current)) {\r\n                        setCost(currentCost);\r\n                        return current;\r\n                    }\r\n                }\r\n            } else {\r\n                                currentCost = previousCost;\r\n                for (int j = 0; j < solvedCols; ++j) {\r\n                    int pj = permutation[j];\r\n                    currentPoint[pj] = oldX[pj];\r\n                }\r\n                tmpVec = weightedResidual;\r\n                weightedResidual = oldRes;\r\n                oldRes = tmpVec;\r\n                tmpVec = currentObjective;\r\n                currentObjective = oldObj;\r\n                oldObj = tmpVec;\r\n                                current = new PointVectorValuePair(currentPoint, currentObjective);\r\n            }\r\n                        if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {\r\n                setCost(currentCost);\r\n                return current;\r\n            }\r\n                        if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\r\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\r\n            } else if (delta <= 2.2204e-16 * xNorm) {\r\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\r\n            } else if (maxCosine <= 2.2204e-16) {\r\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\r\n            }\r\n        }\r\n    }\r\n}","lc":7.7272727273,"pi":1.033492823,"ma":7.0,"nbd":1.5,"ml":5.4166666667,"d":7.2242063492,"mi":-1.9040169133,"fo":2.0833333333,"r":-0.0263157895,"e":87.3136748443}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4070_d450acb0","label":1,"code":"\/**\r\n *  Process the form. Though you can override this method to provide your own algorithm, it is\r\n *  not recommended to do so.\r\n *\r\n *  <p>\r\n *  See the class documentation for further details on the form processing\r\n *  <\/p>\r\n *\r\n *  @param submittingComponent\r\n *             component responsible for submitting the form, or <code>null<\/code> if none (eg\r\n *             the form has been submitted via the enter key or javascript calling\r\n *             form.onsubmit())\r\n *\r\n *  @see #delegateSubmit(IFormSubmitter) for an easy way to process submitting component in the\r\n *       default manner\r\n *\/\r\npublic void process(IFormSubmitter submittingComponent) {\r\n    \/\/ save the page in case the component is removed during submit\r\n    final Page page = getPage();\r\n    String hiddenFieldId = getHiddenFieldId();\r\n    if (!isEnabledInHierarchy() || !isVisibleInHierarchy()) {\r\n        \/\/ FIXME throw listener exception\r\n        return;\r\n    }\r\n    \/\/ run validation\r\n    validate();\r\n    \/\/ If a validation error occurred\r\n    if (hasError()) {\r\n        \/\/ mark all children as invalid\r\n        markFormComponentsInvalid();\r\n        \/\/ let subclass handle error\r\n        callOnError(submittingComponent);\r\n    } else {\r\n        \/\/ mark all children as valid\r\n        markFormComponentsValid();\r\n        \/\/ before updating, call the interception method for clients\r\n        beforeUpdateFormComponentModels();\r\n        \/\/ Update model using form data\r\n        updateFormComponentModels();\r\n        \/\/ validate model objects after input values have been bound\r\n        onValidateModelObjects();\r\n        if (hasError()) {\r\n            callOnError(submittingComponent);\r\n        }\r\n        \/\/ Form has no error\r\n        delegateSubmit(submittingComponent);\r\n    }\r\n    \/\/ If the form is stateless page parameters contain all form component\r\n    \/\/ values. We need to remove those otherwise they get appended to action URL\r\n    final PageParameters parameters = page.getPageParameters();\r\n    if (parameters != null) {\r\n        visitFormComponents(new IVisitor<FormComponent<?>, Void>() {\r\n\r\n            public void component(final FormComponent<?> formComponent, final IVisit<Void> visit) {\r\n                parameters.remove(formComponent.getInputName());\r\n            }\r\n        });\r\n        parameters.remove(hiddenFieldId);\r\n        if (submittingComponent instanceof AbstractSubmitLink) {\r\n            AbstractSubmitLink submitLink = (AbstractSubmitLink) submittingComponent;\r\n            parameters.remove(submitLink.getInputName());\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  Process the form. Though you can override this method to provide your own algorithm, it is\r\n *  not recommended to do so.\r\n *\r\n *  <p>\r\n *  See the class documentation for further details on the form processing\r\n *  <\/p>\r\n *\r\n *  @param submittingComponent\r\n *             component responsible for submitting the form, or <code>null<\/code> if none (eg\r\n *             the form has been submitted via the enter key or javascript calling\r\n *             form.onsubmit())\r\n *\r\n *  @see #delegateSubmit(IFormSubmitter) for an easy way to process submitting component in the\r\n *       default manner\r\n *\/\r\n","code_no_comment":"public void process(IFormSubmitter submittingComponent) {\r\n        final Page page = getPage();\r\n    String hiddenFieldId = getHiddenFieldId();\r\n    if (!isEnabledInHierarchy() || !isVisibleInHierarchy()) {\r\n                return;\r\n    }\r\n        validate();\r\n        if (hasError()) {\r\n                markFormComponentsInvalid();\r\n                callOnError(submittingComponent);\r\n    } else {\r\n                markFormComponentsValid();\r\n                beforeUpdateFormComponentModels();\r\n                updateFormComponentModels();\r\n                onValidateModelObjects();\r\n        if (hasError()) {\r\n            callOnError(submittingComponent);\r\n        }\r\n                delegateSubmit(submittingComponent);\r\n    }\r\n            final PageParameters parameters = page.getPageParameters();\r\n    if (parameters != null) {\r\n        visitFormComponents(new IVisitor<FormComponent<?>, Void>() {\r\n\r\n            public void component(final FormComponent<?> formComponent, final IVisit<Void> visit) {\r\n                parameters.remove(formComponent.getInputName());\r\n            }\r\n        });\r\n        parameters.remove(hiddenFieldId);\r\n        if (submittingComponent instanceof AbstractSubmitLink) {\r\n            AbstractSubmitLink submitLink = (AbstractSubmitLink) submittingComponent;\r\n            parameters.remove(submitLink.getInputName());\r\n        }\r\n    }\r\n}","lc":0.9090909091,"pi":0.2488038278,"ma":0.4,"nbd":0.0,"ml":0.5,"d":0.2678571429,"mi":-0.534038055,"fo":1.3333333333,"r":-0.0263157895,"e":0.3649890793}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2839_15477252","label":1,"code":"\/**\r\n *  Convenience method to write an {@link InputStream} to response.\r\n *\r\n *  @param attributes\r\n *  @param stream\r\n *\/\r\nprotected final void writeStream(Attributes attributes, InputStream stream) {\r\n    final Response response = attributes.getResponse();\r\n    OutputStream s = new OutputStream() {\r\n\r\n        @Override\r\n        public void write(int b) throws IOException {\r\n            response.write(new byte[] { (byte) b });\r\n        }\r\n\r\n        @Override\r\n        public void write(byte[] b) throws IOException {\r\n            response.write(b);\r\n        }\r\n\r\n        @Override\r\n        public void write(byte[] b, int off, int len) throws IOException {\r\n            if (off == 0 || len == b.length) {\r\n                write(b);\r\n            } else {\r\n                byte[] copy = new byte[len];\r\n                System.arraycopy(b, off, copy, 0, len);\r\n                write(copy);\r\n            }\r\n        }\r\n    };\r\n    try {\r\n        Streams.copy(stream, s);\r\n    } catch (IOException e) {\r\n        throw new WicketRuntimeException(e);\r\n    }\r\n}","code_comment":"\/**\r\n *  Convenience method to write an {@link InputStream} to response.\r\n *\r\n *  @param attributes\r\n *  @param stream\r\n *\/\r\n","code_no_comment":"protected final void writeStream(Attributes attributes, InputStream stream) {\r\n    final Response response = attributes.getResponse();\r\n    OutputStream s = new OutputStream() {\r\n\r\n        @Override\r\n        public void write(int b) throws IOException {\r\n            response.write(new byte[] { (byte) b });\r\n        }\r\n\r\n        @Override\r\n        public void write(byte[] b) throws IOException {\r\n            response.write(b);\r\n        }\r\n\r\n        @Override\r\n        public void write(byte[] b, int off, int len) throws IOException {\r\n            if (off == 0 || len == b.length) {\r\n                write(b);\r\n            } else {\r\n                byte[] copy = new byte[len];\r\n                System.arraycopy(b, off, copy, 0, len);\r\n                write(copy);\r\n            }\r\n        }\r\n    };\r\n    try {\r\n        Streams.copy(stream, s);\r\n    } catch (IOException e) {\r\n        throw new WicketRuntimeException(e);\r\n    }\r\n}","lc":0.6363636364,"pi":0.6985645933,"ma":0.0,"nbd":0.0,"ml":0.0,"d":0.1031746032,"mi":-0.4119802678,"fo":0.0833333333,"r":0.0263157895,"e":0.1771961066}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5853_b80f6640","label":3,"code":"\/**\r\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)\r\n *\/\r\n@Override\r\npublic Float convertToObject(final String value, final Locale locale) {\r\n    final Number number = parse(value, -Float.MAX_VALUE, Float.MAX_VALUE, locale);\r\n    if (number == null) {\r\n        return null;\r\n    }\r\n    return number.floatValue();\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)\r\n *\/\r\n","code_no_comment":"@Override\r\npublic Float convertToObject(final String value, final Locale locale) {\r\n    final Number number = parse(value, -Float.MAX_VALUE, Float.MAX_VALUE, locale);\r\n    if (number == null) {\r\n        return null;\r\n    }\r\n    return number.floatValue();\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0535714286,"mi":0.3367159972,"fo":-0.3333333333,"r":0.2894736842,"e":-0.0887605678}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-209_76d727f0","label":1,"code":"private boolean matches(Matcher matcher, ByteSequence bs) {\r\n    if (matcher != null) {\r\n        babcs.set(bs);\r\n        matcher.reset(babcs);\r\n        return matcher.matches();\r\n    }\r\n    return !orFields;\r\n}","code_comment":null,"code_no_comment":"private boolean matches(Matcher matcher, ByteSequence bs) {\r\n    if (matcher != null) {\r\n        babcs.set(bs);\r\n        matcher.reset(babcs);\r\n        return matcher.matches();\r\n    }\r\n    return !orFields;\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0575396825,"mi":0.3916842847,"fo":-0.25,"r":0.5,"e":-0.1126974522}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3872_3feb0e3a","label":1,"code":"\/**\r\n *  Removes all children from this container.\r\n *  <p>\r\n *  Note: implementation does not call {@link MarkupContainer#remove(Component) } for each\r\n *  component.\r\n *\r\n *  @return {@code this} for method chaining\r\n *\/\r\npublic MarkupContainer removeAll() {\r\n    if (children != null) {\r\n        addStateChange();\r\n        \/\/ Loop through child components\r\n        int size = children_size();\r\n        for (int i = 0; i < size; i++) {\r\n            Object childObject = children_get(i, false);\r\n            if (childObject instanceof Component) {\r\n                \/\/ Get next child\r\n                final Component child = (Component) childObject;\r\n                \/\/ Do not call remove() because the state change would than be\r\n                \/\/ recorded twice.\r\n                child.internalOnRemove();\r\n                child.detachModel();\r\n                child.setParent(null);\r\n            }\r\n        }\r\n        children = null;\r\n    }\r\n    return this;\r\n}","code_comment":"\/**\r\n *  Removes all children from this container.\r\n *  <p>\r\n *  Note: implementation does not call {@link MarkupContainer#remove(Component) } for each\r\n *  component.\r\n *\r\n *  @return {@code this} for method chaining\r\n *\/\r\n","code_no_comment":"public MarkupContainer removeAll() {\r\n    if (children != null) {\r\n        addStateChange();\r\n                int size = children_size();\r\n        for (int i = 0; i < size; i++) {\r\n            Object childObject = children_get(i, false);\r\n            if (childObject instanceof Component) {\r\n                                final Component child = (Component) childObject;\r\n                                                child.internalOnRemove();\r\n                child.detachModel();\r\n                child.setParent(null);\r\n            }\r\n        }\r\n        children = null;\r\n    }\r\n    return this;\r\n}","lc":0.1363636364,"pi":1.0717703349,"ma":0.0,"nbd":0.5,"ml":0.1666666667,"d":0.3234126984,"mi":-0.1078224101,"fo":0.0,"r":1.0526315789,"e":0.1342277393}
{"project_name":"Lang","project_version":"7","label":1,"code":"\/**\r\n * <p>Convert a <code>String<\/code> to a <code>BigDecimal<\/code>.<\/p>\r\n *\r\n * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\r\n *\r\n * @param str  a <code>String<\/code> to convert, may be null\r\n * @return converted <code>BigDecimal<\/code> (or null if the input is null)\r\n * @throws NumberFormatException if the value cannot be converted\r\n *\/\r\npublic static BigDecimal createBigDecimal(String str) {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    \/\/ handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\r\n    if (StringUtils.isBlank(str)) {\r\n        throw new NumberFormatException(\"A blank string is not a valid number\");\r\n    }\r\n    \/\/ a wrong value.\r\n    return new BigDecimal(str);\r\n}","code_comment":"\/**\r\n * <p>Convert a <code>String<\/code> to a <code>BigDecimal<\/code>.<\/p>\r\n *\r\n * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\r\n *\r\n * @param str  a <code>String<\/code> to convert, may be null\r\n * @return converted <code>BigDecimal<\/code> (or null if the input is null)\r\n * @throws NumberFormatException if the value cannot be converted\r\n *\/\r\n","code_no_comment":"public static BigDecimal createBigDecimal(String str) {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n        if (StringUtils.isBlank(str)) {\r\n        throw new NumberFormatException(\"A blank string is not a valid number\");\r\n    }\r\n        return new BigDecimal(str);\r\n}","lc":-0.2272727273,"pi":-0.1531100478,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.3598308668,"fo":-0.4166666667,"r":0.0,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1215_a9efe3c4","label":0,"code":"@Override\r\npublic PropertyValue currentProperty() {\r\n    boolean asterisk = PathUtils.getName(propertyName).equals(\"*\");\r\n    if (!asterisk) {\r\n        PropertyValue p = selector.currentProperty(propertyName);\r\n        return matchesPropertyType(p) ? p : null;\r\n    }\r\n    Tree tree = selector.currentTree();\r\n    if (tree == null || !tree.exists()) {\r\n        return null;\r\n    }\r\n    if (!asterisk) {\r\n        String name = PathUtils.getName(propertyName);\r\n        name = normalizePropertyName(name);\r\n        PropertyState p = tree.getProperty(name);\r\n        if (p == null) {\r\n            return null;\r\n        }\r\n        return matchesPropertyType(p) ? PropertyValues.create(p) : null;\r\n    }\r\n    \/\/ asterisk - create a multi-value property\r\n    \/\/ warning: the returned property state may have a mixed type\r\n    \/\/ (not all values may have the same type)\r\n    \/\/ TODO currently all property values are converted to strings -\r\n    \/\/ this doesn't play well with the idea that the types may be different\r\n    List<String> values = new ArrayList<String>();\r\n    for (PropertyState p : tree.getProperties()) {\r\n        if (matchesPropertyType(p)) {\r\n            Iterables.addAll(values, p.getValue(Type.STRINGS));\r\n        }\r\n    }\r\n    \/\/ \"*\"\r\n    return PropertyValues.newString(values);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic PropertyValue currentProperty() {\r\n    boolean asterisk = PathUtils.getName(propertyName).equals(\"*\");\r\n    if (!asterisk) {\r\n        PropertyValue p = selector.currentProperty(propertyName);\r\n        return matchesPropertyType(p) ? p : null;\r\n    }\r\n    Tree tree = selector.currentTree();\r\n    if (tree == null || !tree.exists()) {\r\n        return null;\r\n    }\r\n    if (!asterisk) {\r\n        String name = PathUtils.getName(propertyName);\r\n        name = normalizePropertyName(name);\r\n        PropertyState p = tree.getProperty(name);\r\n        if (p == null) {\r\n            return null;\r\n        }\r\n        return matchesPropertyType(p) ? PropertyValues.create(p) : null;\r\n    }\r\n                        List<String> values = new ArrayList<String>();\r\n    for (PropertyState p : tree.getProperties()) {\r\n        if (matchesPropertyType(p)) {\r\n            Iterables.addAll(values, p.getValue(Type.STRINGS));\r\n        }\r\n    }\r\n        return PropertyValues.newString(values);\r\n}","lc":0.6363636364,"pi":0.0526315789,"ma":1.0,"nbd":0.0,"ml":0.6666666667,"d":0.4623015873,"mi":-0.4993657505,"fo":0.8333333333,"r":-0.0263157895,"e":0.7113731321}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-492_24a3bed4","label":3,"code":"\/**\r\n * Either returns the specified name as is, or returns a quoted value\r\n * containing the specified name with the special characters (comma, equals,\r\n * colon, quote, asterisk, or question mark) preceded with a backslash.\r\n *\r\n * @param name the name to escape so it can be used as a value in an\r\n *            {@link ObjectName}.\r\n * @return the escaped name\r\n *\/\r\npublic static String escape(final String name) {\r\n    final StringBuilder sb = new StringBuilder(name.length() * 2);\r\n    boolean needsQuotes = false;\r\n    for (int i = 0; i < name.length(); i++) {\r\n        final char c = name.charAt(i);\r\n        switch(c) {\r\n            case '\\\\':\r\n            case '*':\r\n            case '?':\r\n            case '\\\"':\r\n                \/\/ quote, star, question & backslash must be escaped\r\n                sb.append('\\\\');\r\n                \/\/ ... and can only appear in quoted value\r\n                needsQuotes = true;\r\n                break;\r\n            case ',':\r\n            case '=':\r\n            case ':':\r\n                \/\/ no need to escape these, but value must be quoted\r\n                needsQuotes = true;\r\n                break;\r\n        }\r\n        sb.append(c);\r\n    }\r\n    if (needsQuotes) {\r\n        sb.insert(0, '\\\"');\r\n        sb.append('\\\"');\r\n    }\r\n    return sb.toString();\r\n}","code_comment":"\/**\r\n * Either returns the specified name as is, or returns a quoted value\r\n * containing the specified name with the special characters (comma, equals,\r\n * colon, quote, asterisk, or question mark) preceded with a backslash.\r\n *\r\n * @param name the name to escape so it can be used as a value in an\r\n *            {@link ObjectName}.\r\n * @return the escaped name\r\n *\/\r\n","code_no_comment":"public static String escape(final String name) {\r\n    final StringBuilder sb = new StringBuilder(name.length() * 2);\r\n    boolean needsQuotes = false;\r\n    for (int i = 0; i < name.length(); i++) {\r\n        final char c = name.charAt(i);\r\n        switch(c) {\r\n            case '\\\\':\r\n            case '*':\r\n            case '?':\r\n            case '\\\"':\r\n                                sb.append('\\\\');\r\n                                needsQuotes = true;\r\n                break;\r\n            case ',':\r\n            case '=':\r\n            case ':':\r\n                                needsQuotes = true;\r\n                break;\r\n        }\r\n        sb.append(c);\r\n    }\r\n    if (needsQuotes) {\r\n        sb.insert(0, '\\\"');\r\n        sb.append('\\\"');\r\n    }\r\n    return sb.toString();\r\n}","lc":0.5909090909,"pi":0.9186602871,"ma":1.6,"nbd":0.5,"ml":0.6666666667,"d":0.4444444444,"mi":-0.437068358,"fo":0.1666666667,"r":-0.0263157895,"e":0.3854820398}
{"project_name":"Closure","project_version":"55","label":2,"code":"private static boolean isReduceableFunctionExpression(Node n) {\r\n    return NodeUtil.isFunctionExpression(n);\r\n}","code_comment":null,"code_no_comment":"private static boolean isReduceableFunctionExpression(Node n) {\r\n    return NodeUtil.isFunctionExpression(n);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0451021846,"fo":-0.4166666667,"r":2.2105263158,"e":-0.1627934049}
{"project_name":"Closure","project_version":"72","label":2,"code":"\/**\r\n * Fix-up all local names to be unique for this subtree.\r\n * @param fnNode A mutable instance of the function to be inlined.\r\n *\/\r\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\r\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\r\n    \/\/ Make variable names unique to this instance.\r\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\r\n\/\/ Make label names unique to this instance.\r\n}","code_comment":"\/**\r\n * Fix-up all local names to be unique for this subtree.\r\n * @param fnNode A mutable instance of the function to be inlined.\r\n *\/\r\n","code_no_comment":"private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\r\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\r\n        NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6958421424,"fo":-0.3333333333,"r":1.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2368_fae1601b","label":1,"code":"\/**\r\n *  Throw an exception if not all components rendered.\r\n *\r\n *  @param renderedContainer\r\n *             The page itself if it was a full page render or the container that was rendered\r\n *             standalone\r\n *\/\r\nprivate final void checkRendering(final MarkupContainer renderedContainer) {\r\n    \/\/ If the application wants component uses checked and\r\n    \/\/ the response is not a redirect\r\n    final IDebugSettings debugSettings = Application.get().getDebugSettings();\r\n    if (debugSettings.getComponentUseCheck() && !getResponse().isRedirect()) {\r\n        final List<Component> unrenderedComponents = new ArrayList<Component>();\r\n        final StringBuffer buffer = new StringBuffer();\r\n        renderedContainer.visitChildren(new IVisitor<Component>() {\r\n\r\n            public Object component(final Component component) {\r\n                \/\/ If component never rendered\r\n                if (renderedComponents == null || !renderedComponents.contains(component)) {\r\n                    \/\/ If auto component ...\r\n                    if (!component.isAuto() && component.isVisibleInHierarchy()) {\r\n                        \/\/ Increase number of unrendered components\r\n                        unrenderedComponents.add(component);\r\n                        \/\/ Add to explanatory string to buffer\r\n                        buffer.append(Integer.toString(unrenderedComponents.size()) + \". \" + component + \"\\n\");\r\n                        String metadata = component.getMetaData(Component.CONSTRUCTED_AT_KEY);\r\n                        if (metadata != null) {\r\n                            buffer.append(metadata);\r\n                        }\r\n                        metadata = component.getMetaData(Component.ADDED_AT_KEY);\r\n                        if (metadata != null) {\r\n                            buffer.append(metadata);\r\n                        }\r\n                    } else {\r\n                        \/\/ not visible\r\n                        return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;\r\n                    }\r\n                }\r\n                return CONTINUE_TRAVERSAL;\r\n            }\r\n        });\r\n        \/\/ Throw exception if any errors were found\r\n        if (unrenderedComponents.size() > 0) {\r\n            \/\/ Get rid of set\r\n            renderedComponents = null;\r\n            Iterator<Component> iterator = unrenderedComponents.iterator();\r\n            while (iterator.hasNext()) {\r\n                Component component = iterator.next();\r\n                \/\/ Now first test if the component has a sibling that is a transparent resolver.\r\n                Iterator<? extends Component> iterator2 = component.getParent().iterator();\r\n                while (iterator2.hasNext()) {\r\n                    Component sibling = iterator2.next();\r\n                    if (!sibling.isVisible()) {\r\n                        boolean isTransparentMarkupContainer = sibling instanceof MarkupContainer && ((MarkupContainer) sibling).isTransparentResolver();\r\n                        boolean isComponentResolver = sibling instanceof IComponentResolver;\r\n                        if (isTransparentMarkupContainer || isComponentResolver) {\r\n                            \/\/ we found a transparent container that isn't visible\r\n                            \/\/ then ignore this component and only do a debug statement here.\r\n                            log.debug(\"Component {} wasn't rendered but most likely it has a transparent parent: {}\", component, sibling);\r\n                            iterator.remove();\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                \/\/ Check if this component is a child of a border whose body is invisible and if\r\n                \/\/ so ignore it\r\n                Border border = component.findParent(Border.class);\r\n                if (border != null && !border.getBodyContainer().isVisibleInHierarchy()) {\r\n                    \/\/ Suppose:\r\n                    \/\/ \r\n                    \/\/ <div wicket:id=\"border\"><div wicket:id=\"label\"><\/div> suppose\r\n                    \/\/ border->label and border's body is hidden.\r\n                    \/\/ \r\n                    \/\/ The label is added to border not to its hidden body so as far as wicket\r\n                    \/\/ is concerned label is visible in hierarchy, but when rendering label wont\r\n                    \/\/ be rendered because in the markup it is inside the border's hidden body.\r\n                    \/\/ Thus component use check will fail even though it shouldnt - make sure it\r\n                    \/\/ doesnt.\r\n                    \/\/ \r\n                    \/\/ TODO it would be more accurate to determine that this component is inside\r\n                    \/\/ the border parent's markup not the border's itself\r\n                    iterator.remove();\r\n                }\r\n            }\r\n            \/\/ if still > 0\r\n            if (unrenderedComponents.size() > 0) {\r\n                \/\/ Throw exception\r\n                throw new WicketRuntimeException(\"The component(s) below failed to render. A common problem is that you have added a component in code but forgot to reference it in the markup (thus the component will never be rendered).\\n\\n\" + buffer.toString());\r\n            }\r\n        }\r\n    }\r\n    \/\/ Get rid of set\r\n    renderedComponents = null;\r\n}","code_comment":"\/**\r\n *  Throw an exception if not all components rendered.\r\n *\r\n *  @param renderedContainer\r\n *             The page itself if it was a full page render or the container that was rendered\r\n *             standalone\r\n *\/\r\n","code_no_comment":"private final void checkRendering(final MarkupContainer renderedContainer) {\r\n            final IDebugSettings debugSettings = Application.get().getDebugSettings();\r\n    if (debugSettings.getComponentUseCheck() && !getResponse().isRedirect()) {\r\n        final List<Component> unrenderedComponents = new ArrayList<Component>();\r\n        final StringBuffer buffer = new StringBuffer();\r\n        renderedContainer.visitChildren(new IVisitor<Component>() {\r\n\r\n            public Object component(final Component component) {\r\n                                if (renderedComponents == null || !renderedComponents.contains(component)) {\r\n                                        if (!component.isAuto() && component.isVisibleInHierarchy()) {\r\n                                                unrenderedComponents.add(component);\r\n                                                buffer.append(Integer.toString(unrenderedComponents.size()) + \". \" + component + \"\\n\");\r\n                        String metadata = component.getMetaData(Component.CONSTRUCTED_AT_KEY);\r\n                        if (metadata != null) {\r\n                            buffer.append(metadata);\r\n                        }\r\n                        metadata = component.getMetaData(Component.ADDED_AT_KEY);\r\n                        if (metadata != null) {\r\n                            buffer.append(metadata);\r\n                        }\r\n                    } else {\r\n                                                return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;\r\n                    }\r\n                }\r\n                return CONTINUE_TRAVERSAL;\r\n            }\r\n        });\r\n                if (unrenderedComponents.size() > 0) {\r\n                        renderedComponents = null;\r\n            Iterator<Component> iterator = unrenderedComponents.iterator();\r\n            while (iterator.hasNext()) {\r\n                Component component = iterator.next();\r\n                                Iterator<? extends Component> iterator2 = component.getParent().iterator();\r\n                while (iterator2.hasNext()) {\r\n                    Component sibling = iterator2.next();\r\n                    if (!sibling.isVisible()) {\r\n                        boolean isTransparentMarkupContainer = sibling instanceof MarkupContainer && ((MarkupContainer) sibling).isTransparentResolver();\r\n                        boolean isComponentResolver = sibling instanceof IComponentResolver;\r\n                        if (isTransparentMarkupContainer || isComponentResolver) {\r\n                                                                                    log.debug(\"Component {} wasn't rendered but most likely it has a transparent parent: {}\", component, sibling);\r\n                            iterator.remove();\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                                                Border border = component.findParent(Border.class);\r\n                if (border != null && !border.getBodyContainer().isVisibleInHierarchy()) {\r\n                                                                                                                                                                                                                                                                                        iterator.remove();\r\n                }\r\n            }\r\n                        if (unrenderedComponents.size() > 0) {\r\n                                throw new WicketRuntimeException(\"The component(s) below failed to render. A common problem is that you have added a component in code but forgot to reference it in the markup (thus the component will never be rendered).\\n\\n\" + buffer.toString());\r\n            }\r\n        }\r\n    }\r\n        renderedComponents = null;\r\n}","lc":1.9090909091,"pi":2.2105263158,"ma":2.2,"nbd":2.0,"ml":2.3333333333,"d":1.3968253968,"mi":-0.9816772375,"fo":2.4166666667,"r":-0.0263157895,"e":4.2551385119}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1899_b6f89048","label":1,"code":"\/**\r\n * return the 'next' value at the provided position\r\n *\r\n * @param nodeState the node state to inspect\r\n * @return the next value\r\n *\/\r\nstatic String getPropertyNext(@Nonnull final NodeState state, final int lane) {\r\n    String next = \"\";\r\n    PropertyState ps = state.getProperty(NEXT);\r\n    if (ps != null) {\r\n        next = (lane < OrderedIndex.LANES) ? ps.getValue(Type.STRING, lane) : \"\";\r\n    }\r\n    return next;\r\n}","code_comment":"\/**\r\n * return the 'next' value at the provided position\r\n *\r\n * @param nodeState the node state to inspect\r\n * @return the next value\r\n *\/\r\n","code_no_comment":"static String getPropertyNext(@Nonnull final NodeState state, final int lane) {\r\n    String next = \"\";\r\n    PropertyState ps = state.getProperty(NEXT);\r\n    if (ps != null) {\r\n        next = (lane < OrderedIndex.LANES) ? ps.getValue(Type.STRING, lane) : \"\";\r\n    }\r\n    return next;\r\n}","lc":-0.2727272727,"pi":-0.2822966507,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0734126984,"mi":0.2769556025,"fo":-0.3333333333,"r":2.1315789474,"e":-0.0628089648}
{"project_name":"Lang","project_version":"30","label":3,"code":"\/\/ IndexOfAnyBut chars\r\n\/\/ -----------------------------------------------------------------------\r\n\/**\r\n * <p>Searches a CharSequence to find the first index of any\r\n * character not in the given set of characters.<\/p>\r\n *\r\n * <p>A <code>null<\/code> CharSequence will return <code>-1<\/code>.\r\n * A <code>null<\/code> or zero length search array will return <code>-1<\/code>.<\/p>\r\n *\r\n * <pre>\r\n * StringUtils.indexOfAnyBut(null, *)           = -1\r\n * StringUtils.indexOfAnyBut(\"\", *)             = -1\r\n * StringUtils.indexOfAnyBut(*, null)           = -1\r\n * StringUtils.indexOfAnyBut(*, [])             = -1\r\n * StringUtils.indexOfAnyBut(\"zzabyycdxx\",'za') = 3\r\n * StringUtils.indexOfAnyBut(\"zzabyycdxx\", '')  = 0\r\n * StringUtils.indexOfAnyBut(\"aba\", 'ab')       = -1\r\n * <\/pre>\r\n *\r\n * @param cs  the CharSequence to check, may be null\r\n * @param searchChars  the chars to search for, may be null\r\n * @return the index of any of the chars, -1 if no match or null input\r\n * @since 2.0\r\n *\/\r\npublic static int indexOfAnyBut(CharSequence cs, char[] searchChars) {\r\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\r\n        return INDEX_NOT_FOUND;\r\n    }\r\n    int csLen = cs.length();\r\n    int searchLen = searchChars.length;\r\n    outer: for (int i = 0; i < csLen; i++) {\r\n        char ch = cs.charAt(i);\r\n        for (int j = 0; j < searchLen; j++) {\r\n            if (searchChars[j] == ch) {\r\n                continue outer;\r\n            }\r\n        }\r\n        return i;\r\n    }\r\n    return INDEX_NOT_FOUND;\r\n}","code_comment":"\/**\r\n * <p>Searches a CharSequence to find the first index of any\r\n * character not in the given set of characters.<\/p>\r\n *\r\n * <p>A <code>null<\/code> CharSequence will return <code>-1<\/code>.\r\n * A <code>null<\/code> or zero length search array will return <code>-1<\/code>.<\/p>\r\n *\r\n * <pre>\r\n * StringUtils.indexOfAnyBut(null, *)           = -1\r\n * StringUtils.indexOfAnyBut(\"\", *)             = -1\r\n * StringUtils.indexOfAnyBut(*, null)           = -1\r\n * StringUtils.indexOfAnyBut(*, [])             = -1\r\n * StringUtils.indexOfAnyBut(\"zzabyycdxx\",'za') = 3\r\n * StringUtils.indexOfAnyBut(\"zzabyycdxx\", '')  = 0\r\n * StringUtils.indexOfAnyBut(\"aba\", 'ab')       = -1\r\n * <\/pre>\r\n *\r\n * @param cs  the CharSequence to check, may be null\r\n * @param searchChars  the chars to search for, may be null\r\n * @return the index of any of the chars, -1 if no match or null input\r\n * @since 2.0\r\n *\/\r\n","code_no_comment":"public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {\r\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\r\n        return INDEX_NOT_FOUND;\r\n    }\r\n    int csLen = cs.length();\r\n    int searchLen = searchChars.length;\r\n    outer: for (int i = 0; i < csLen; i++) {\r\n        char ch = cs.charAt(i);\r\n        for (int j = 0; j < searchLen; j++) {\r\n            if (searchChars[j] == ch) {\r\n                continue outer;\r\n            }\r\n        }\r\n        return i;\r\n    }\r\n    return INDEX_NOT_FOUND;\r\n}","lc":0.1363636364,"pi":0.5454545455,"ma":0.4,"nbd":0.5,"ml":0.75,"d":0.5218253968,"mi":-0.1447498238,"fo":-0.1666666667,"r":0.1315789474,"e":0.2875814733}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1290_45fb6d82","label":1,"code":"@Override\r\nprotected List<GlobalPropertiesPair> createPossibleGlobalProperties() {\r\n    ArrayList<GlobalPropertiesPair> pairs = new ArrayList<GlobalPropertiesPair>();\r\n    if (repartitionAllowed) {\r\n        \/\/ partition both (hash or custom)\r\n        RequestedGlobalProperties partitioned1 = new RequestedGlobalProperties();\r\n        if (customPartitioner == null) {\r\n            partitioned1.setAnyPartitioning(this.keys1);\r\n        } else {\r\n            partitioned1.setCustomPartitioned(this.keys1, this.customPartitioner);\r\n        }\r\n        RequestedGlobalProperties partitioned2 = new RequestedGlobalProperties();\r\n        if (customPartitioner == null) {\r\n            partitioned2.setAnyPartitioning(this.keys2);\r\n        } else {\r\n            partitioned2.setCustomPartitioned(this.keys2, this.customPartitioner);\r\n        }\r\n        pairs.add(new GlobalPropertiesPair(partitioned1, partitioned2));\r\n    }\r\n    if (broadcastSecondAllowed) {\r\n        \/\/ replicate second\r\n        RequestedGlobalProperties any1 = new RequestedGlobalProperties();\r\n        RequestedGlobalProperties replicated2 = new RequestedGlobalProperties();\r\n        replicated2.setFullyReplicated();\r\n        pairs.add(new GlobalPropertiesPair(any1, replicated2));\r\n    }\r\n    if (broadcastFirstAllowed) {\r\n        \/\/ replicate first\r\n        RequestedGlobalProperties replicated1 = new RequestedGlobalProperties();\r\n        replicated1.setFullyReplicated();\r\n        RequestedGlobalProperties any2 = new RequestedGlobalProperties();\r\n        pairs.add(new GlobalPropertiesPair(replicated1, any2));\r\n    }\r\n    return pairs;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected List<GlobalPropertiesPair> createPossibleGlobalProperties() {\r\n    ArrayList<GlobalPropertiesPair> pairs = new ArrayList<GlobalPropertiesPair>();\r\n    if (repartitionAllowed) {\r\n                RequestedGlobalProperties partitioned1 = new RequestedGlobalProperties();\r\n        if (customPartitioner == null) {\r\n            partitioned1.setAnyPartitioning(this.keys1);\r\n        } else {\r\n            partitioned1.setCustomPartitioned(this.keys1, this.customPartitioner);\r\n        }\r\n        RequestedGlobalProperties partitioned2 = new RequestedGlobalProperties();\r\n        if (customPartitioner == null) {\r\n            partitioned2.setAnyPartitioning(this.keys2);\r\n        } else {\r\n            partitioned2.setCustomPartitioned(this.keys2, this.customPartitioner);\r\n        }\r\n        pairs.add(new GlobalPropertiesPair(partitioned1, partitioned2));\r\n    }\r\n    if (broadcastSecondAllowed) {\r\n                RequestedGlobalProperties any1 = new RequestedGlobalProperties();\r\n        RequestedGlobalProperties replicated2 = new RequestedGlobalProperties();\r\n        replicated2.setFullyReplicated();\r\n        pairs.add(new GlobalPropertiesPair(any1, replicated2));\r\n    }\r\n    if (broadcastFirstAllowed) {\r\n                RequestedGlobalProperties replicated1 = new RequestedGlobalProperties();\r\n        replicated1.setFullyReplicated();\r\n        RequestedGlobalProperties any2 = new RequestedGlobalProperties();\r\n        pairs.add(new GlobalPropertiesPair(replicated1, any2));\r\n    }\r\n    return pairs;\r\n}","lc":0.8181818182,"pi":0.1148325359,"ma":0.4,"nbd":0.0,"ml":0.3333333333,"d":0.1825396825,"mi":-0.511205074,"fo":0.25,"r":-0.0263157895,"e":0.3091348121}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2506_0f8a2990","label":1,"code":"private void checkChildComponent(Component controller) {\r\n    if (controller == null) {\r\n        throw new WicketRuntimeException(\"Could not find child with id: \" + childId + \" in the wicket:enclosure\");\r\n    } else if (controller == this) {\r\n        throw new WicketRuntimeException(\"Programming error: childComponent == enclose component; endless loop\");\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void checkChildComponent(Component controller) {\r\n    if (controller == null) {\r\n        throw new WicketRuntimeException(\"Could not find child with id: \" + childId + \" in the wicket:enclosure\");\r\n    } else if (controller == this) {\r\n        throw new WicketRuntimeException(\"Programming error: childComponent == enclose component; endless loop\");\r\n    }\r\n}","lc":-0.3181818182,"pi":0.014354067,"ma":0.2,"nbd":0.0,"ml":-0.1666666667,"d":-0.1071428571,"mi":0.4630021142,"fo":-0.5,"r":2.4210526316,"e":-0.1284141007}
{"project_name":"JxPath","project_version":"8","label":1,"code":"private boolean compute(Object left, Object right) {\r\n    left = reduce(left);\r\n    right = reduce(right);\r\n    if (left instanceof InitialContext) {\r\n        ((InitialContext) left).reset();\r\n    }\r\n    if (right instanceof InitialContext) {\r\n        ((InitialContext) right).reset();\r\n    }\r\n    if (left instanceof Iterator && right instanceof Iterator) {\r\n        return findMatch((Iterator) left, (Iterator) right);\r\n    }\r\n    if (left instanceof Iterator) {\r\n        return containsMatch((Iterator) left, right);\r\n    }\r\n    if (right instanceof Iterator) {\r\n        return containsMatch((Iterator) right, left);\r\n    }\r\n    double ld = InfoSetUtil.doubleValue(left);\r\n    double rd = InfoSetUtil.doubleValue(right);\r\n    return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\r\n}","code_comment":null,"code_no_comment":"private boolean compute(Object left, Object right) {\r\n    left = reduce(left);\r\n    right = reduce(right);\r\n    if (left instanceof InitialContext) {\r\n        ((InitialContext) left).reset();\r\n    }\r\n    if (right instanceof InitialContext) {\r\n        ((InitialContext) right).reset();\r\n    }\r\n    if (left instanceof Iterator && right instanceof Iterator) {\r\n        return findMatch((Iterator) left, (Iterator) right);\r\n    }\r\n    if (left instanceof Iterator) {\r\n        return containsMatch((Iterator) left, right);\r\n    }\r\n    if (right instanceof Iterator) {\r\n        return containsMatch((Iterator) right, left);\r\n    }\r\n    double ld = InfoSetUtil.doubleValue(left);\r\n    double rd = InfoSetUtil.doubleValue(right);\r\n    return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\r\n}","lc":0.3636363636,"pi":-0.3827751196,"ma":0.8,"nbd":-0.5,"ml":0.5833333333,"d":0.9365079365,"mi":-0.3234672304,"fo":0.3333333333,"r":-0.0263157895,"e":0.7532119661}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2799_3979fa8d","label":1,"code":"@Override\r\npublic void close() {\r\n    file.blob = null;\r\n    file.data = null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void close() {\r\n    file.blob = null;\r\n    file.data = null;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7237491191,"fo":-0.5,"r":2.0526315789,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-366_db4a291f","label":1,"code":"@Override\r\npublic void readFields(DataInput in) throws IOException {\r\n    Path file = new Path(in.readUTF());\r\n    long start = in.readLong();\r\n    long length = in.readLong();\r\n    int numHosts = in.readInt();\r\n    String[] hosts = new String[numHosts];\r\n    for (int i = 0; i < numHosts; i++) hosts[i] = in.readUTF();\r\n    fileSplit = new FileSplit(file, start, length, hosts);\r\n    partition = in.readInt();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void readFields(DataInput in) throws IOException {\r\n    Path file = new Path(in.readUTF());\r\n    long start = in.readLong();\r\n    long length = in.readLong();\r\n    int numHosts = in.readInt();\r\n    String[] hosts = new String[numHosts];\r\n    for (int i = 0; i < numHosts; i++) hosts[i] = in.readUTF();\r\n    fileSplit = new FileSplit(file, start, length, hosts);\r\n    partition = in.readInt();\r\n}","lc":-0.1363636364,"pi":-0.5789473684,"ma":-0.4,"nbd":-1.0,"ml":-0.1666666667,"d":0.0317460317,"mi":0.0644115574,"fo":0.0,"r":0.0,"e":0.0612737216}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5784_b6259e5f","label":3,"code":"\/**\r\n *  Copies all request data into {@code copy} such that the oldest request is in slot 0 and the\r\n *  most recent request is in slot {@code copy.length}\r\n *\r\n *  @param copy\r\n *             the target, has to have a capacity of at least {@code requestWindow.length}\r\n *\/\r\nprivate void copyRequestsInOrder(RequestData[] copy) {\r\n    if (hasBufferRolledOver()) {\r\n        \/\/ first copy the oldest requests stored behind the cursor into the copy\r\n        int oldestPos = indexInWindow + 1;\r\n        if (oldestPos < requestWindow.length)\r\n            arraycopy(requestWindow, oldestPos, copy, 0, requestWindow.length - oldestPos);\r\n        \/\/ then append the newer requests stored from index 0 til the cursor position.\r\n        arraycopy(requestWindow, 0, copy, requestWindow.length - oldestPos, indexInWindow);\r\n    } else {\r\n        arraycopy(requestWindow, 0, copy, 0, indexInWindow);\r\n    }\r\n}","code_comment":"\/**\r\n *  Copies all request data into {@code copy} such that the oldest request is in slot 0 and the\r\n *  most recent request is in slot {@code copy.length}\r\n *\r\n *  @param copy\r\n *             the target, has to have a capacity of at least {@code requestWindow.length}\r\n *\/\r\n","code_no_comment":"private void copyRequestsInOrder(RequestData[] copy) {\r\n    if (hasBufferRolledOver()) {\r\n                int oldestPos = indexInWindow + 1;\r\n        if (oldestPos < requestWindow.length)\r\n            arraycopy(requestWindow, oldestPos, copy, 0, requestWindow.length - oldestPos);\r\n                arraycopy(requestWindow, 0, copy, requestWindow.length - oldestPos, indexInWindow);\r\n    } else {\r\n        arraycopy(requestWindow, 0, copy, 0, indexInWindow);\r\n    }\r\n}","lc":-0.1818181818,"pi":0.3253588517,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":0.7261904762,"mi":0.1701198027,"fo":-0.1666666667,"r":-0.0263157895,"e":0.2226310057}
{"project_name":"Compress","project_version":"43","label":3,"code":"private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\r\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\r\n    if (oldAlignmentEx != null) {\r\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\r\n    }\r\n    int alignment = ze.getAlignment();\r\n    if (alignment <= 0 && oldAlignmentEx != null) {\r\n        alignment = oldAlignmentEx.getAlignment();\r\n    }\r\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\r\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\r\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\r\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\r\n    }\r\n    final byte[] extra = ze.getLocalFileDataExtra();\r\n    final int nameLen = name.limit() - name.position();\r\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\r\n    final byte[] buf = new byte[len];\r\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\r\n    \/\/ store method in local variable to prevent multiple method calls\r\n    final int zipMethod = ze.getMethod();\r\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\r\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\r\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\r\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\r\n    \/\/ compression method\r\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\r\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\r\n    \/\/ CRC\r\n    if (phased) {\r\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\r\n    } else if (zipMethod == DEFLATED || channel != null) {\r\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\r\n    } else {\r\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\r\n    }\r\n    \/\/ uncompressed length\r\n    if (hasZip64Extra(entry.entry)) {\r\n        \/\/ point to ZIP64 extended information extra field for\r\n        \/\/ sizes, may get rewritten once sizes are known if\r\n        \/\/ stream is seekable\r\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\r\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\r\n    } else if (phased) {\r\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\r\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\r\n    } else if (zipMethod == DEFLATED || channel != null) {\r\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\r\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\r\n    } else {\r\n        \/\/ Stored\r\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\r\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\r\n    }\r\n    \/\/ file name length\r\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\r\n    \/\/ extra field length\r\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\r\n    \/\/ file name\r\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\r\n    \/\/ extra fields\r\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\r\n    return buf;\r\n}","code_comment":null,"code_no_comment":"private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\r\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\r\n    if (oldAlignmentEx != null) {\r\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\r\n    }\r\n    int alignment = ze.getAlignment();\r\n    if (alignment <= 0 && oldAlignmentEx != null) {\r\n        alignment = oldAlignmentEx.getAlignment();\r\n    }\r\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\r\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\r\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\r\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\r\n    }\r\n    final byte[] extra = ze.getLocalFileDataExtra();\r\n    final int nameLen = name.limit() - name.position();\r\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\r\n    final byte[] buf = new byte[len];\r\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\r\n        final int zipMethod = ze.getMethod();\r\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\r\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\r\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\r\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\r\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\r\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\r\n        if (phased) {\r\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\r\n    } else if (zipMethod == DEFLATED || channel != null) {\r\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\r\n    } else {\r\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\r\n    }\r\n        if (hasZip64Extra(entry.entry)) {\r\n                                ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\r\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\r\n    } else if (phased) {\r\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\r\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\r\n    } else if (zipMethod == DEFLATED || channel != null) {\r\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\r\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\r\n    } else {\r\n                putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\r\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\r\n    }\r\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\r\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\r\n        System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\r\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\r\n    return buf;\r\n}","lc":1.7272727273,"pi":-0.4306220096,"ma":1.0,"nbd":0.5,"ml":1.3333333333,"d":2.496031746,"mi":-0.9774489077,"fo":3.5,"r":-0.0263157895,"e":11.2913193064}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"public void getResult() throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException {\r\n    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\r\n        throw new IllegalStateException(\"Method call not finished!\");\r\n    }\r\n    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());\r\n    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\r\n    (new Client(prot)).recv_update();\r\n}","code_comment":null,"code_no_comment":"public void getResult() throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException {\r\n    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\r\n        throw new IllegalStateException(\"Method call not finished!\");\r\n    }\r\n    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());\r\n    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\r\n    (new Client(prot)).recv_update();\r\n}","lc":-0.2727272727,"pi":-0.2822966507,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0535714286,"mi":0.2109936575,"fo":0.0,"r":-0.0263157895,"e":0.0042899212}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3945_36225565","label":3,"code":"public ClientConfiguration getClientConfiguration() throws ConfigurationException, FileNotFoundException {\r\n    ClientConfiguration clientConfig = clientConfigFile == null ? ClientConfiguration.loadDefault() : new ClientConfiguration(getClientConfigFile());\r\n    if (useSsl()) {\r\n        clientConfig.setProperty(ClientProperty.INSTANCE_RPC_SSL_ENABLED, \"true\");\r\n    }\r\n    if (useSasl()) {\r\n        clientConfig.setProperty(ClientProperty.INSTANCE_RPC_SASL_ENABLED, \"true\");\r\n    }\r\n    \/\/ Automatically try to add in the proper ZK from accumulo-site for backwards compat.\r\n    if (!clientConfig.containsKey(ClientProperty.INSTANCE_ZK_HOST.getKey())) {\r\n        AccumuloConfiguration siteConf = SiteConfiguration.getInstance(ClientContext.convertClientConfig(clientConfig));\r\n        clientConfig.withZkHosts(siteConf.get(Property.INSTANCE_ZK_HOST));\r\n    }\r\n    return clientConfig;\r\n}","code_comment":null,"code_no_comment":"public ClientConfiguration getClientConfiguration() throws ConfigurationException, FileNotFoundException {\r\n    ClientConfiguration clientConfig = clientConfigFile == null ? ClientConfiguration.loadDefault() : new ClientConfiguration(getClientConfigFile());\r\n    if (useSsl()) {\r\n        clientConfig.setProperty(ClientProperty.INSTANCE_RPC_SSL_ENABLED, \"true\");\r\n    }\r\n    if (useSasl()) {\r\n        clientConfig.setProperty(ClientProperty.INSTANCE_RPC_SASL_ENABLED, \"true\");\r\n    }\r\n        if (!clientConfig.containsKey(ClientProperty.INSTANCE_ZK_HOST.getKey())) {\r\n        AccumuloConfiguration siteConf = SiteConfiguration.getInstance(ClientContext.convertClientConfig(clientConfig));\r\n        clientConfig.withZkHosts(siteConf.get(Property.INSTANCE_ZK_HOST));\r\n    }\r\n    return clientConfig;\r\n}","lc":0.0,"pi":-0.2057416268,"ma":0.2,"nbd":-0.5,"ml":0.3333333333,"d":-0.0634920635,"mi":-0.0632840028,"fo":0.5,"r":-0.0263157895,"e":0.00508751}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2506_0f8a2990","label":1,"code":"private void restoreOriginalChildVisibility() {\r\n    if (changes != null) {\r\n        MarkupContainer container = getEnclosureParent();\r\n        \/\/ restore original visibility statuses\r\n        for (Map.Entry<Component, Boolean> entry : changes.entrySet()) {\r\n            entry.getKey().setVisibilityAllowed(entry.getValue());\r\n        }\r\n        changes = null;\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void restoreOriginalChildVisibility() {\r\n    if (changes != null) {\r\n        MarkupContainer container = getEnclosureParent();\r\n                for (Map.Entry<Component, Boolean> entry : changes.entrySet()) {\r\n            entry.getKey().setVisibilityAllowed(entry.getValue());\r\n        }\r\n        changes = null;\r\n    }\r\n}","lc":-0.2272727273,"pi":0.3971291866,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.1051587302,"mi":0.2794926004,"fo":-0.0833333333,"r":0.7368421053,"e":-0.1022365911}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1364_05c89637","label":1,"code":"@Override\r\npublic ConcurrentMap<K, V> asMap() {\r\n    return new ConcurrentMap<K, V>() {\r\n\r\n        @Override\r\n        public int size() {\r\n            long size = CacheLIRS.this.size();\r\n            return (int) Math.min(size, Integer.MAX_VALUE);\r\n        }\r\n\r\n        @Override\r\n        public boolean isEmpty() {\r\n            return CacheLIRS.this.size() == 0;\r\n        }\r\n\r\n        @Override\r\n        public boolean containsKey(Object key) {\r\n            return CacheLIRS.this.containsKey(key);\r\n        }\r\n\r\n        @Override\r\n        public boolean containsValue(Object value) {\r\n            return CacheLIRS.this.containsValue(value);\r\n        }\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public V get(Object key) {\r\n            return CacheLIRS.this.getUnchecked((K) key);\r\n        }\r\n\r\n        @Override\r\n        public V put(K key, V value) {\r\n            return CacheLIRS.this.put(key, value, sizeOf(key, value));\r\n        }\r\n\r\n        @Override\r\n        public V remove(Object key) {\r\n            @SuppressWarnings(\"unchecked\")\r\n            V old = CacheLIRS.this.getUnchecked((K) key);\r\n            CacheLIRS.this.invalidate(key);\r\n            return old;\r\n        }\r\n\r\n        @Override\r\n        public void putAll(Map<? extends K, ? extends V> m) {\r\n            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\r\n                put(e.getKey(), e.getValue());\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void clear() {\r\n            CacheLIRS.this.clear();\r\n        }\r\n\r\n        @Override\r\n        public Set<K> keySet() {\r\n            return CacheLIRS.this.keySet();\r\n        }\r\n\r\n        @Override\r\n        public Collection<V> values() {\r\n            return CacheLIRS.this.values();\r\n        }\r\n\r\n        @Override\r\n        public Set<java.util.Map.Entry<K, V>> entrySet() {\r\n            return CacheLIRS.this.entrySet();\r\n        }\r\n\r\n        @Override\r\n        public V putIfAbsent(K key, V value) {\r\n            return CacheLIRS.this.putIfAbsent(key, value);\r\n        }\r\n\r\n        @Override\r\n        public boolean remove(Object key, Object value) {\r\n            return CacheLIRS.this.remove(key, value);\r\n        }\r\n\r\n        @Override\r\n        public boolean replace(K key, V oldValue, V newValue) {\r\n            return CacheLIRS.this.replace(key, oldValue, newValue);\r\n        }\r\n\r\n        @Override\r\n        public V replace(K key, V value) {\r\n            return CacheLIRS.this.replace(key, value);\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic ConcurrentMap<K, V> asMap() {\r\n    return new ConcurrentMap<K, V>() {\r\n\r\n        @Override\r\n        public int size() {\r\n            long size = CacheLIRS.this.size();\r\n            return (int) Math.min(size, Integer.MAX_VALUE);\r\n        }\r\n\r\n        @Override\r\n        public boolean isEmpty() {\r\n            return CacheLIRS.this.size() == 0;\r\n        }\r\n\r\n        @Override\r\n        public boolean containsKey(Object key) {\r\n            return CacheLIRS.this.containsKey(key);\r\n        }\r\n\r\n        @Override\r\n        public boolean containsValue(Object value) {\r\n            return CacheLIRS.this.containsValue(value);\r\n        }\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public V get(Object key) {\r\n            return CacheLIRS.this.getUnchecked((K) key);\r\n        }\r\n\r\n        @Override\r\n        public V put(K key, V value) {\r\n            return CacheLIRS.this.put(key, value, sizeOf(key, value));\r\n        }\r\n\r\n        @Override\r\n        public V remove(Object key) {\r\n            @SuppressWarnings(\"unchecked\")\r\n            V old = CacheLIRS.this.getUnchecked((K) key);\r\n            CacheLIRS.this.invalidate(key);\r\n            return old;\r\n        }\r\n\r\n        @Override\r\n        public void putAll(Map<? extends K, ? extends V> m) {\r\n            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\r\n                put(e.getKey(), e.getValue());\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void clear() {\r\n            CacheLIRS.this.clear();\r\n        }\r\n\r\n        @Override\r\n        public Set<K> keySet() {\r\n            return CacheLIRS.this.keySet();\r\n        }\r\n\r\n        @Override\r\n        public Collection<V> values() {\r\n            return CacheLIRS.this.values();\r\n        }\r\n\r\n        @Override\r\n        public Set<java.util.Map.Entry<K, V>> entrySet() {\r\n            return CacheLIRS.this.entrySet();\r\n        }\r\n\r\n        @Override\r\n        public V putIfAbsent(K key, V value) {\r\n            return CacheLIRS.this.putIfAbsent(key, value);\r\n        }\r\n\r\n        @Override\r\n        public boolean remove(Object key, Object value) {\r\n            return CacheLIRS.this.remove(key, value);\r\n        }\r\n\r\n        @Override\r\n        public boolean replace(K key, V oldValue, V newValue) {\r\n            return CacheLIRS.this.replace(key, oldValue, newValue);\r\n        }\r\n\r\n        @Override\r\n        public V replace(K key, V value) {\r\n            return CacheLIRS.this.replace(key, value);\r\n        }\r\n    };\r\n}","lc":2.8181818182,"pi":-0.1148325359,"ma":-0.4,"nbd":0.0,"ml":-0.4166666667,"d":0.3531746032,"mi":-1.0214235377,"fo":1.3333333333,"r":-0.0263157895,"e":1.4569895633}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-579_7d72e6ed","label":3,"code":"private Filter createFilter() {\r\n    FilterImpl f = new FilterImpl(this, query.getStatement());\r\n    validateNodeType(nodeTypeName);\r\n    f.setNodeType(nodeTypeName);\r\n    if (joinCondition != null) {\r\n        joinCondition.restrict(f);\r\n    }\r\n    \/\/ (\".. is null\" must be written as \"not .. is not null\").\r\n    if (queryConstraint != null) {\r\n        queryConstraint.restrict(f);\r\n    }\r\n    return f;\r\n}","code_comment":null,"code_no_comment":"private Filter createFilter() {\r\n    FilterImpl f = new FilterImpl(this, query.getStatement());\r\n    validateNodeType(nodeTypeName);\r\n    f.setNodeType(nodeTypeName);\r\n    if (joinCondition != null) {\r\n        joinCondition.restrict(f);\r\n    }\r\n        if (queryConstraint != null) {\r\n        queryConstraint.restrict(f);\r\n    }\r\n    return f;\r\n}","lc":-0.0909090909,"pi":-0.3253588517,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0257936508,"mi":0.1371388302,"fo":-0.0833333333,"r":0.3157894737,"e":-0.0774375731}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1096_19c1c3bb","label":0,"code":"\/**\r\n * Compute enclosing ball using G\u00e4rtner's pivoting heuristic.\r\n * @param points points to be enclosed\r\n * @return enclosing ball\r\n *\/\r\nprivate EnclosingBall<S, P> pivotingBall(final Iterable<P> points) {\r\n    final P first = points.iterator().next();\r\n    final List<P> extreme = new ArrayList<P>(first.getSpace().getDimension() + 1);\r\n    final List<P> support = new ArrayList<P>(first.getSpace().getDimension() + 1);\r\n    \/\/ start with only first point selected as a candidate support\r\n    extreme.add(first);\r\n    EnclosingBall<S, P> ball = moveToFrontBall(extreme, extreme.size(), support);\r\n    while (true) {\r\n        \/\/ select the point farthest to current ball\r\n        final P farthest = selectFarthest(points, ball);\r\n        if (ball.contains(farthest, tolerance)) {\r\n            \/\/ we have found a ball containing all points\r\n            return ball;\r\n        }\r\n        \/\/ recurse search, restricted to the small subset containing support and farthest point\r\n        support.clear();\r\n        support.add(farthest);\r\n        EnclosingBall<S, P> savedBall = ball;\r\n        ball = moveToFrontBall(extreme, extreme.size(), support);\r\n        if (ball.getRadius() < savedBall.getRadius()) {\r\n            \/\/ TODO: fix this, it should never happen but it does!\r\n            throw new MathInternalError();\r\n        }\r\n        \/\/ it was an interesting point, move it to the front\r\n        \/\/ according to G\u00e4rtner's heuristic\r\n        extreme.add(0, farthest);\r\n        \/\/ prune the least interesting points\r\n        extreme.subList(ball.getSupportSize(), extreme.size()).clear();\r\n    }\r\n}","code_comment":"\/**\r\n * Compute enclosing ball using G\u00e4rtner's pivoting heuristic.\r\n * @param points points to be enclosed\r\n * @return enclosing ball\r\n *\/\r\n","code_no_comment":"private EnclosingBall<S, P> pivotingBall(final Iterable<P> points) {\r\n    final P first = points.iterator().next();\r\n    final List<P> extreme = new ArrayList<P>(first.getSpace().getDimension() + 1);\r\n    final List<P> support = new ArrayList<P>(first.getSpace().getDimension() + 1);\r\n        extreme.add(first);\r\n    EnclosingBall<S, P> ball = moveToFrontBall(extreme, extreme.size(), support);\r\n    while (true) {\r\n                final P farthest = selectFarthest(points, ball);\r\n        if (ball.contains(farthest, tolerance)) {\r\n                        return ball;\r\n        }\r\n                support.clear();\r\n        support.add(farthest);\r\n        EnclosingBall<S, P> savedBall = ball;\r\n        ball = moveToFrontBall(extreme, extreme.size(), support);\r\n        if (ball.getRadius() < savedBall.getRadius()) {\r\n                        throw new MathInternalError();\r\n        }\r\n                        extreme.add(0, farthest);\r\n                extreme.subList(ball.getSupportSize(), extreme.size()).clear();\r\n    }\r\n}","lc":0.3636363636,"pi":0.0574162679,"ma":0.2,"nbd":0.0,"ml":0.25,"d":0.1527777778,"mi":-0.3761804087,"fo":1.3333333333,"r":-0.0263157895,"e":0.4335171706}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"@Override\r\npublic void read(org.apache.thrift.protocol.TProtocol prot, removeTableProperty_result struct) throws org.apache.thrift.TException {\r\n    TTupleProtocol iprot = (TTupleProtocol) prot;\r\n    BitSet incoming = iprot.readBitSet(2);\r\n    if (incoming.get(0)) {\r\n        struct.ouch1 = new AccumuloException();\r\n        struct.ouch1.read(iprot);\r\n        struct.setOuch1IsSet(true);\r\n    }\r\n    if (incoming.get(1)) {\r\n        struct.ouch2 = new AccumuloSecurityException();\r\n        struct.ouch2.read(iprot);\r\n        struct.setOuch2IsSet(true);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void read(org.apache.thrift.protocol.TProtocol prot, removeTableProperty_result struct) throws org.apache.thrift.TException {\r\n    TTupleProtocol iprot = (TTupleProtocol) prot;\r\n    BitSet incoming = iprot.readBitSet(2);\r\n    if (incoming.get(0)) {\r\n        struct.ouch1 = new AccumuloException();\r\n        struct.ouch1.read(iprot);\r\n        struct.setOuch1IsSet(true);\r\n    }\r\n    if (incoming.get(1)) {\r\n        struct.ouch2 = new AccumuloSecurityException();\r\n        struct.ouch2.read(iprot);\r\n        struct.setOuch2IsSet(true);\r\n    }\r\n}","lc":0.0454545455,"pi":0.0,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":-0.0948555321,"fo":0.0833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-43_668f08f2","label":1,"code":"public void addNode(String parentNodePath, String nodeName) throws Exception {\r\n    addNode(parentNodePath, nodeName, Collections.<String, String>emptyMap());\r\n}","code_comment":null,"code_no_comment":"public void addNode(String parentNodePath, String nodeName) throws Exception {\r\n    addNode(parentNodePath, nodeName, Collections.<String, String>emptyMap());\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9216349542,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5157_961f2477","label":1,"code":"\/**\r\n *  @param qp\r\n *  @param charset\r\n *  @return query parameters\r\n *\/\r\nprivate static QueryParameter parseQueryParameter(final String qp, final Charset charset) {\r\n    if (qp.indexOf('=') == -1) {\r\n        \/\/ name => empty value\r\n        return new QueryParameter(decodeParameter(qp, charset), \"\");\r\n    }\r\n    String[] parts = Strings.split(qp, '=');\r\n    return new QueryParameter(decodeParameter(parts[0], charset), decodeParameter(parts[1], charset));\r\n}","code_comment":"\/**\r\n *  @param qp\r\n *  @param charset\r\n *  @return query parameters\r\n *\/\r\n","code_no_comment":"private static QueryParameter parseQueryParameter(final String qp, final Charset charset) {\r\n    if (qp.indexOf('=') == -1) {\r\n                return new QueryParameter(decodeParameter(qp, charset), \"\");\r\n    }\r\n    String[] parts = Strings.split(qp, '=');\r\n    return new QueryParameter(decodeParameter(parts[0], charset), decodeParameter(parts[1], charset));\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.0198412698,"mi":0.3471458774,"fo":-0.0833333333,"r":1.2631578947,"e":-0.0337822652}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2695_0598498e","label":0,"code":"private boolean dispatch(@Nonnull String jsonDiff, @Nonnull DocumentNodeState node, @Nonnull DocumentNodeState base, @Nonnull NodeStateDiff diff, boolean useReadRevision) {\r\n    if (jsonDiff.trim().isEmpty()) {\r\n        return true;\r\n    }\r\n    Revision nodeRev = useReadRevision ? node.getRevision() : node.getLastRevision();\r\n    Revision baseRev = useReadRevision ? base.getRevision() : base.getLastRevision();\r\n    JsopTokenizer t = new JsopTokenizer(jsonDiff);\r\n    boolean continueComparison = true;\r\n    while (continueComparison) {\r\n        int r = t.read();\r\n        if (r == JsopReader.END) {\r\n            break;\r\n        }\r\n        switch(r) {\r\n            case '+':\r\n                {\r\n                    String name = unshareString(t.readString());\r\n                    t.read(':');\r\n                    t.read('{');\r\n                    while (t.read() != '}') {\r\n                    \/\/ skip properties\r\n                    }\r\n                    NodeState child = getNode(concat(node.getPath(), name), nodeRev);\r\n                    continueComparison = diff.childNodeAdded(name, child);\r\n                    break;\r\n                }\r\n            case '-':\r\n                {\r\n                    String name = unshareString(t.readString());\r\n                    NodeState child = getNode(concat(base.getPath(), name), baseRev);\r\n                    continueComparison = diff.childNodeDeleted(name, child);\r\n                    break;\r\n                }\r\n            case '^':\r\n                {\r\n                    String name = unshareString(t.readString());\r\n                    t.read(':');\r\n                    if (t.matches('{')) {\r\n                        t.read('}');\r\n                        NodeState nodeChild = getNode(concat(node.getPath(), name), nodeRev);\r\n                        NodeState baseChild = getNode(concat(base.getPath(), name), baseRev);\r\n                        continueComparison = diff.childNodeChanged(name, baseChild, nodeChild);\r\n                    } else if (t.matches('[')) {\r\n                        \/\/ ignore multi valued property\r\n                        while (t.read() != ']') {\r\n                        \/\/ skip values\r\n                        }\r\n                    } else {\r\n                        \/\/ ignore single valued property\r\n                        t.read();\r\n                    }\r\n                    break;\r\n                }\r\n            default:\r\n                throw new IllegalArgumentException(\"jsonDiff: illegal token '\" + t.getToken() + \"' at pos: \" + t.getLastPos() + ' ' + jsonDiff);\r\n        }\r\n    }\r\n    return continueComparison;\r\n}","code_comment":null,"code_no_comment":"private boolean dispatch(@Nonnull String jsonDiff, @Nonnull DocumentNodeState node, @Nonnull DocumentNodeState base, @Nonnull NodeStateDiff diff, boolean useReadRevision) {\r\n    if (jsonDiff.trim().isEmpty()) {\r\n        return true;\r\n    }\r\n    Revision nodeRev = useReadRevision ? node.getRevision() : node.getLastRevision();\r\n    Revision baseRev = useReadRevision ? base.getRevision() : base.getLastRevision();\r\n    JsopTokenizer t = new JsopTokenizer(jsonDiff);\r\n    boolean continueComparison = true;\r\n    while (continueComparison) {\r\n        int r = t.read();\r\n        if (r == JsopReader.END) {\r\n            break;\r\n        }\r\n        switch(r) {\r\n            case '+':\r\n                {\r\n                    String name = unshareString(t.readString());\r\n                    t.read(':');\r\n                    t.read('{');\r\n                    while (t.read() != '}') {\r\n                                        }\r\n                    NodeState child = getNode(concat(node.getPath(), name), nodeRev);\r\n                    continueComparison = diff.childNodeAdded(name, child);\r\n                    break;\r\n                }\r\n            case '-':\r\n                {\r\n                    String name = unshareString(t.readString());\r\n                    NodeState child = getNode(concat(base.getPath(), name), baseRev);\r\n                    continueComparison = diff.childNodeDeleted(name, child);\r\n                    break;\r\n                }\r\n            case '^':\r\n                {\r\n                    String name = unshareString(t.readString());\r\n                    t.read(':');\r\n                    if (t.matches('{')) {\r\n                        t.read('}');\r\n                        NodeState nodeChild = getNode(concat(node.getPath(), name), nodeRev);\r\n                        NodeState baseChild = getNode(concat(base.getPath(), name), baseRev);\r\n                        continueComparison = diff.childNodeChanged(name, baseChild, nodeChild);\r\n                    } else if (t.matches('[')) {\r\n                                                while (t.read() != ']') {\r\n                                                }\r\n                    } else {\r\n                                                t.read();\r\n                    }\r\n                    break;\r\n                }\r\n            default:\r\n                throw new IllegalArgumentException(\"jsonDiff: illegal token '\" + t.getToken() + \"' at pos: \" + t.getLastPos() + ' ' + jsonDiff);\r\n        }\r\n    }\r\n    return continueComparison;\r\n}","lc":1.8636363636,"pi":2.0574162679,"ma":3.0,"nbd":2.0,"ml":1.1666666667,"d":0.7301587302,"mi":-0.9859055673,"fo":2.75,"r":-0.0263157895,"e":2.341082162}
{"project_name":"Closure","project_version":"157","label":2,"code":"\/**\r\n * Processes the parent of a GETPROP prototype, which can either be\r\n * another GETPROP (in the case of Foo.prototype.bar), or can be\r\n * an assignment (in the case of Foo.prototype = ...).\r\n *\/\r\nprivate void processPrototypeParent(Node n, CompilerInput input) {\r\n    switch(n.getType()) {\r\n        \/\/ Foo.prototype.getBar = function() { ... }\r\n        case Token.GETPROP:\r\n        case Token.GETELEM:\r\n            Node dest = n.getFirstChild().getNext();\r\n            if (dest.getType() == Token.STRING) {\r\n                markPrototypePropertyCandidate(dest, input);\r\n            }\r\n            break;\r\n        \/\/ Foo.prototype = { \"getBar\" : function() { ... } }\r\n        case Token.ASSIGN:\r\n        case Token.CALL:\r\n            Node map;\r\n            if (n.getType() == Token.ASSIGN) {\r\n                map = n.getFirstChild().getNext();\r\n            } else {\r\n                map = n.getLastChild();\r\n            }\r\n            if (map.getType() == Token.OBJECTLIT) {\r\n                \/\/ Remember this node so that we can avoid processing it again when\r\n                \/\/ the traversal reaches it.\r\n                prototypeObjLits.add(map);\r\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\r\n                    if (key.getType() != Token.NUMBER) {\r\n                        \/\/ May be STRING, GET, or SET\r\n                        markPrototypePropertyCandidate(key, input);\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n    }\r\n}","code_comment":"\/**\r\n * Processes the parent of a GETPROP prototype, which can either be\r\n * another GETPROP (in the case of Foo.prototype.bar), or can be\r\n * an assignment (in the case of Foo.prototype = ...).\r\n *\/\r\n","code_no_comment":"private void processPrototypeParent(Node n, CompilerInput input) {\r\n    switch(n.getType()) {\r\n                case Token.GETPROP:\r\n        case Token.GETELEM:\r\n            Node dest = n.getFirstChild().getNext();\r\n            if (dest.getType() == Token.STRING) {\r\n                markPrototypePropertyCandidate(dest, input);\r\n            }\r\n            break;\r\n                case Token.ASSIGN:\r\n        case Token.CALL:\r\n            Node map;\r\n            if (n.getType() == Token.ASSIGN) {\r\n                map = n.getFirstChild().getNext();\r\n            } else {\r\n                map = n.getLastChild();\r\n            }\r\n            if (map.getType() == Token.OBJECTLIT) {\r\n                                                prototypeObjLits.add(map);\r\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\r\n                    if (key.getType() != Token.NUMBER) {\r\n                                                markPrototypePropertyCandidate(key, input);\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n    }\r\n}","lc":0.6363636364,"pi":1.2009569378,"ma":1.6,"nbd":1.5,"ml":0.75,"d":0.1428571429,"mi":-0.4830162086,"fo":0.75,"r":-0.0263157895,"e":0.2570748546}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1174_342809f7","label":3,"code":"public static boolean parse(String jcrPath, Listener listener) {\r\n    \/\/ check for length\r\n    int len = jcrPath == null ? 0 : jcrPath.length();\r\n    \/\/ shortcut for root path\r\n    if (len == 1 && jcrPath.charAt(0) == '\/') {\r\n        listener.root();\r\n        return true;\r\n    }\r\n    \/\/ short cut for empty path\r\n    if (len == 0) {\r\n        return true;\r\n    }\r\n    \/\/ check if absolute path\r\n    int pos = 0;\r\n    if (jcrPath.charAt(0) == '\/') {\r\n        if (!listener.root()) {\r\n            return false;\r\n        }\r\n        pos++;\r\n    }\r\n    \/\/ parse the path\r\n    int state = STATE_PREFIX_START;\r\n    int lastPos = pos;\r\n    String name = null;\r\n    int index = 0;\r\n    boolean wasSlash = false;\r\n    while (pos <= len) {\r\n        char c = pos == len ? EOF : jcrPath.charAt(pos);\r\n        pos++;\r\n        \/\/ special check for whitespace\r\n        if (c != ' ' && Character.isWhitespace(c)) {\r\n            c = '\\t';\r\n        }\r\n        switch(c) {\r\n            case '\/':\r\n            case EOF:\r\n                if (state == STATE_PREFIX_START && c != EOF) {\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. \" + \"double slash '\/\/' not allowed.\");\r\n                    return false;\r\n                }\r\n                if (state == STATE_PREFIX || state == STATE_NAME || state == STATE_INDEX_END || state == STATE_URI_END) {\r\n                    \/\/ eof path element\r\n                    if (name == null) {\r\n                        if (wasSlash) {\r\n                            listener.error('\\'' + jcrPath + \"' is not a valid path: \" + \"Trailing slashes not allowed in prefixes and names.\");\r\n                            return false;\r\n                        }\r\n                        name = jcrPath.substring(lastPos, pos - 1);\r\n                    }\r\n                    if (!JcrNameParser.parse(name, listener, index)) {\r\n                        return false;\r\n                    }\r\n                    state = STATE_PREFIX_START;\r\n                    lastPos = pos;\r\n                    name = null;\r\n                    index = 0;\r\n                } else if (state == STATE_DOT) {\r\n                    if (!listener.current()) {\r\n                        return false;\r\n                    }\r\n                    lastPos = pos;\r\n                    state = STATE_PREFIX_START;\r\n                } else if (state == STATE_DOTDOT) {\r\n                    if (!listener.parent()) {\r\n                        return false;\r\n                    }\r\n                    lastPos = pos;\r\n                    state = STATE_PREFIX_START;\r\n                } else if (state != STATE_URI && !(state == STATE_PREFIX_START && c == EOF)) {\r\n                    \/\/ ignore trailing slash\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not a valid name character.\");\r\n                    return false;\r\n                }\r\n                break;\r\n            case '.':\r\n                if (state == STATE_PREFIX_START) {\r\n                    state = STATE_DOT;\r\n                } else if (state == STATE_DOT) {\r\n                    state = STATE_DOTDOT;\r\n                } else if (state == STATE_DOTDOT) {\r\n                    state = STATE_PREFIX;\r\n                } else if (state == STATE_INDEX_END) {\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid after index. '\/' expected.\");\r\n                    return false;\r\n                }\r\n                break;\r\n            case ':':\r\n                if (state == STATE_PREFIX_START) {\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. Prefix \" + \"must not be empty\");\r\n                    return false;\r\n                } else if (state == STATE_PREFIX) {\r\n                    if (wasSlash) {\r\n                        listener.error('\\'' + jcrPath + \"' is not a valid path: \" + \"Trailing slashes not allowed in prefixes and names.\");\r\n                        return false;\r\n                    }\r\n                    state = STATE_NAME_START;\r\n                \/\/ don't reset the lastPos\/pos since prefix+name are passed together to the NameResolver\r\n                } else if (state != STATE_URI) {\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid name character\");\r\n                    return false;\r\n                }\r\n                break;\r\n            case '[':\r\n                if (state == STATE_PREFIX || state == STATE_NAME) {\r\n                    if (wasSlash) {\r\n                        listener.error('\\'' + jcrPath + \"' is not a valid path: \" + \"Trailing slashes not allowed in prefixes and names.\");\r\n                        return false;\r\n                    }\r\n                    state = STATE_INDEX;\r\n                    name = jcrPath.substring(lastPos, pos - 1);\r\n                    lastPos = pos;\r\n                }\r\n                break;\r\n            case ']':\r\n                if (state == STATE_INDEX) {\r\n                    try {\r\n                        index = Integer.parseInt(jcrPath.substring(lastPos, pos - 1));\r\n                    } catch (NumberFormatException e) {\r\n                        listener.error('\\'' + jcrPath + \"' is not a valid path. \" + \"NumberFormatException in index: \" + jcrPath.substring(lastPos, pos - 1));\r\n                        return false;\r\n                    }\r\n                    if (index < 0) {\r\n                        listener.error('\\'' + jcrPath + \"' is not a valid path. \" + \"Index number invalid: \" + index);\r\n                        return false;\r\n                    }\r\n                    state = STATE_INDEX_END;\r\n                } else {\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not a valid name character.\");\r\n                    return false;\r\n                }\r\n                break;\r\n            case ' ':\r\n                if (state == STATE_PREFIX_START || state == STATE_NAME_START) {\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid name start\");\r\n                    return false;\r\n                } else if (state == STATE_INDEX_END) {\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid after index. '\/' expected.\");\r\n                    return false;\r\n                } else if (state == STATE_DOT || state == STATE_DOTDOT) {\r\n                    state = STATE_PREFIX;\r\n                }\r\n                break;\r\n            case '\\t':\r\n                listener.error('\\'' + jcrPath + \"' is not a valid path. \" + \"Whitespace not a allowed in name.\");\r\n                return false;\r\n            case '*':\r\n            case '|':\r\n                listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not a valid name character.\");\r\n                return false;\r\n            case '{':\r\n                if (state == STATE_PREFIX_START && lastPos == pos - 1) {\r\n                    \/\/ '{' marks the start of a uri enclosed in an expanded name\r\n                    \/\/ instead of the usual namespace prefix, if it is\r\n                    \/\/ located at the beginning of a new segment.\r\n                    state = STATE_URI;\r\n                } else if (state == STATE_NAME_START || state == STATE_DOT || state == STATE_DOTDOT) {\r\n                    \/\/ otherwise it's part of the local name\r\n                    state = STATE_NAME;\r\n                }\r\n                break;\r\n            case '}':\r\n                if (state == STATE_URI) {\r\n                    state = STATE_URI_END;\r\n                }\r\n                break;\r\n            default:\r\n                if (state == STATE_PREFIX_START || state == STATE_DOT || state == STATE_DOTDOT) {\r\n                    state = STATE_PREFIX;\r\n                } else if (state == STATE_NAME_START) {\r\n                    state = STATE_NAME;\r\n                } else if (state == STATE_INDEX_END) {\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid after index. '\/' expected.\");\r\n                    return false;\r\n                }\r\n        }\r\n        wasSlash = c == ' ';\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"public static boolean parse(String jcrPath, Listener listener) {\r\n        int len = jcrPath == null ? 0 : jcrPath.length();\r\n        if (len == 1 && jcrPath.charAt(0) == '\/') {\r\n        listener.root();\r\n        return true;\r\n    }\r\n        if (len == 0) {\r\n        return true;\r\n    }\r\n        int pos = 0;\r\n    if (jcrPath.charAt(0) == '\/') {\r\n        if (!listener.root()) {\r\n            return false;\r\n        }\r\n        pos++;\r\n    }\r\n        int state = STATE_PREFIX_START;\r\n    int lastPos = pos;\r\n    String name = null;\r\n    int index = 0;\r\n    boolean wasSlash = false;\r\n    while (pos <= len) {\r\n        char c = pos == len ? EOF : jcrPath.charAt(pos);\r\n        pos++;\r\n                if (c != ' ' && Character.isWhitespace(c)) {\r\n            c = '\\t';\r\n        }\r\n        switch(c) {\r\n            case '\/':\r\n            case EOF:\r\n                if (state == STATE_PREFIX_START && c != EOF) {\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. \" + \"double slash '\/\/' not allowed.\");\r\n                    return false;\r\n                }\r\n                if (state == STATE_PREFIX || state == STATE_NAME || state == STATE_INDEX_END || state == STATE_URI_END) {\r\n                                        if (name == null) {\r\n                        if (wasSlash) {\r\n                            listener.error('\\'' + jcrPath + \"' is not a valid path: \" + \"Trailing slashes not allowed in prefixes and names.\");\r\n                            return false;\r\n                        }\r\n                        name = jcrPath.substring(lastPos, pos - 1);\r\n                    }\r\n                    if (!JcrNameParser.parse(name, listener, index)) {\r\n                        return false;\r\n                    }\r\n                    state = STATE_PREFIX_START;\r\n                    lastPos = pos;\r\n                    name = null;\r\n                    index = 0;\r\n                } else if (state == STATE_DOT) {\r\n                    if (!listener.current()) {\r\n                        return false;\r\n                    }\r\n                    lastPos = pos;\r\n                    state = STATE_PREFIX_START;\r\n                } else if (state == STATE_DOTDOT) {\r\n                    if (!listener.parent()) {\r\n                        return false;\r\n                    }\r\n                    lastPos = pos;\r\n                    state = STATE_PREFIX_START;\r\n                } else if (state != STATE_URI && !(state == STATE_PREFIX_START && c == EOF)) {\r\n                                        listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not a valid name character.\");\r\n                    return false;\r\n                }\r\n                break;\r\n            case '.':\r\n                if (state == STATE_PREFIX_START) {\r\n                    state = STATE_DOT;\r\n                } else if (state == STATE_DOT) {\r\n                    state = STATE_DOTDOT;\r\n                } else if (state == STATE_DOTDOT) {\r\n                    state = STATE_PREFIX;\r\n                } else if (state == STATE_INDEX_END) {\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid after index. '\/' expected.\");\r\n                    return false;\r\n                }\r\n                break;\r\n            case ':':\r\n                if (state == STATE_PREFIX_START) {\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. Prefix \" + \"must not be empty\");\r\n                    return false;\r\n                } else if (state == STATE_PREFIX) {\r\n                    if (wasSlash) {\r\n                        listener.error('\\'' + jcrPath + \"' is not a valid path: \" + \"Trailing slashes not allowed in prefixes and names.\");\r\n                        return false;\r\n                    }\r\n                    state = STATE_NAME_START;\r\n                                } else if (state != STATE_URI) {\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid name character\");\r\n                    return false;\r\n                }\r\n                break;\r\n            case '[':\r\n                if (state == STATE_PREFIX || state == STATE_NAME) {\r\n                    if (wasSlash) {\r\n                        listener.error('\\'' + jcrPath + \"' is not a valid path: \" + \"Trailing slashes not allowed in prefixes and names.\");\r\n                        return false;\r\n                    }\r\n                    state = STATE_INDEX;\r\n                    name = jcrPath.substring(lastPos, pos - 1);\r\n                    lastPos = pos;\r\n                }\r\n                break;\r\n            case ']':\r\n                if (state == STATE_INDEX) {\r\n                    try {\r\n                        index = Integer.parseInt(jcrPath.substring(lastPos, pos - 1));\r\n                    } catch (NumberFormatException e) {\r\n                        listener.error('\\'' + jcrPath + \"' is not a valid path. \" + \"NumberFormatException in index: \" + jcrPath.substring(lastPos, pos - 1));\r\n                        return false;\r\n                    }\r\n                    if (index < 0) {\r\n                        listener.error('\\'' + jcrPath + \"' is not a valid path. \" + \"Index number invalid: \" + index);\r\n                        return false;\r\n                    }\r\n                    state = STATE_INDEX_END;\r\n                } else {\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not a valid name character.\");\r\n                    return false;\r\n                }\r\n                break;\r\n            case ' ':\r\n                if (state == STATE_PREFIX_START || state == STATE_NAME_START) {\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid name start\");\r\n                    return false;\r\n                } else if (state == STATE_INDEX_END) {\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid after index. '\/' expected.\");\r\n                    return false;\r\n                } else if (state == STATE_DOT || state == STATE_DOTDOT) {\r\n                    state = STATE_PREFIX;\r\n                }\r\n                break;\r\n            case '\\t':\r\n                listener.error('\\'' + jcrPath + \"' is not a valid path. \" + \"Whitespace not a allowed in name.\");\r\n                return false;\r\n            case '*':\r\n            case '|':\r\n                listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not a valid name character.\");\r\n                return false;\r\n            case '{':\r\n                if (state == STATE_PREFIX_START && lastPos == pos - 1) {\r\n                                                                                state = STATE_URI;\r\n                } else if (state == STATE_NAME_START || state == STATE_DOT || state == STATE_DOTDOT) {\r\n                                        state = STATE_NAME;\r\n                }\r\n                break;\r\n            case '}':\r\n                if (state == STATE_URI) {\r\n                    state = STATE_URI_END;\r\n                }\r\n                break;\r\n            default:\r\n                if (state == STATE_PREFIX_START || state == STATE_DOT || state == STATE_DOTDOT) {\r\n                    state = STATE_PREFIX;\r\n                } else if (state == STATE_NAME_START) {\r\n                    state = STATE_NAME;\r\n                } else if (state == STATE_INDEX_END) {\r\n                    listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c + \"' not valid after index. '\/' expected.\");\r\n                    return false;\r\n                }\r\n        }\r\n        wasSlash = c == ' ';\r\n    }\r\n    return true;\r\n}","lc":6.9090909091,"pi":1.4593301435,"ma":11.6,"nbd":2.5,"ml":6.5,"d":4.7797619048,"mi":-1.9372797745,"fo":2.0833333333,"r":-0.0263157895,"e":36.8966903523}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3520_d1b62639","label":1,"code":"private IRequestHandler internalMap(Exception e) {\r\n    final Application application = Application.get();\r\n    \/\/ check if we are processing an Ajax request and if we want to invoke the failure handler\r\n    if (isProcessingAjaxRequest()) {\r\n        switch(application.getExceptionSettings().getAjaxErrorHandlingStrategy()) {\r\n            case INVOKE_FAILURE_HANDLER:\r\n                return new ErrorCodeRequestHandler(500);\r\n        }\r\n    }\r\n    if (e instanceof StalePageException) {\r\n        \/\/ (the url should always be updated by an redirect in that case)\r\n        return new RenderPageRequestHandler(new PageProvider(((StalePageException) e).getPage()));\r\n    } else if (e instanceof PageExpiredException) {\r\n        return createPageRequestHandler(new PageProvider(Application.get().getApplicationSettings().getPageExpiredErrorPage()));\r\n    } else if (e instanceof AuthorizationException || e instanceof ListenerInvocationNotAllowedException) {\r\n        return createPageRequestHandler(new PageProvider(Application.get().getApplicationSettings().getAccessDeniedPage()));\r\n    } else if (e instanceof ResponseIOException) {\r\n        logger.error(\"Connection lost, give up responding.\", e);\r\n        return new EmptyRequestHandler();\r\n    } else {\r\n        final UnexpectedExceptionDisplay unexpectedExceptionDisplay = application.getExceptionSettings().getUnexpectedExceptionDisplay();\r\n        logger.error(\"Unexpected error occurred\", e);\r\n        if (IExceptionSettings.SHOW_EXCEPTION_PAGE.equals(unexpectedExceptionDisplay)) {\r\n            Page currentPage = extractCurrentPage();\r\n            return createPageRequestHandler(new PageProvider(new ExceptionErrorPage(e, currentPage)));\r\n        } else if (IExceptionSettings.SHOW_INTERNAL_ERROR_PAGE.equals(unexpectedExceptionDisplay)) {\r\n            return createPageRequestHandler(new PageProvider(application.getApplicationSettings().getInternalErrorPage()));\r\n        } else {\r\n            \/\/ IExceptionSettings.SHOW_NO_EXCEPTION_PAGE\r\n            return new EmptyRequestHandler();\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private IRequestHandler internalMap(Exception e) {\r\n    final Application application = Application.get();\r\n        if (isProcessingAjaxRequest()) {\r\n        switch(application.getExceptionSettings().getAjaxErrorHandlingStrategy()) {\r\n            case INVOKE_FAILURE_HANDLER:\r\n                return new ErrorCodeRequestHandler(500);\r\n        }\r\n    }\r\n    if (e instanceof StalePageException) {\r\n                return new RenderPageRequestHandler(new PageProvider(((StalePageException) e).getPage()));\r\n    } else if (e instanceof PageExpiredException) {\r\n        return createPageRequestHandler(new PageProvider(Application.get().getApplicationSettings().getPageExpiredErrorPage()));\r\n    } else if (e instanceof AuthorizationException || e instanceof ListenerInvocationNotAllowedException) {\r\n        return createPageRequestHandler(new PageProvider(Application.get().getApplicationSettings().getAccessDeniedPage()));\r\n    } else if (e instanceof ResponseIOException) {\r\n        logger.error(\"Connection lost, give up responding.\", e);\r\n        return new EmptyRequestHandler();\r\n    } else {\r\n        final UnexpectedExceptionDisplay unexpectedExceptionDisplay = application.getExceptionSettings().getUnexpectedExceptionDisplay();\r\n        logger.error(\"Unexpected error occurred\", e);\r\n        if (IExceptionSettings.SHOW_EXCEPTION_PAGE.equals(unexpectedExceptionDisplay)) {\r\n            Page currentPage = extractCurrentPage();\r\n            return createPageRequestHandler(new PageProvider(new ExceptionErrorPage(e, currentPage)));\r\n        } else if (IExceptionSettings.SHOW_INTERNAL_ERROR_PAGE.equals(unexpectedExceptionDisplay)) {\r\n            return createPageRequestHandler(new PageProvider(application.getApplicationSettings().getInternalErrorPage()));\r\n        } else {\r\n                        return new EmptyRequestHandler();\r\n        }\r\n    }\r\n}","lc":0.7272727273,"pi":0.3110047847,"ma":1.0,"nbd":2.0,"ml":0.8333333333,"d":0.0,"mi":-0.5312191684,"fo":1.5,"r":-0.0263157895,"e":0.2232948946}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-209_76d727f0","label":1,"code":"private boolean matches(Matcher matcher, byte[] data, int offset, int len) {\r\n    if (matcher != null) {\r\n        babcs.set(data, offset, len);\r\n        matcher.reset(babcs);\r\n        return matcher.matches();\r\n    }\r\n    return !orFields;\r\n}","code_comment":null,"code_no_comment":"private boolean matches(Matcher matcher, byte[] data, int offset, int len) {\r\n    if (matcher != null) {\r\n        babcs.set(data, offset, len);\r\n        matcher.reset(babcs);\r\n        return matcher.matches();\r\n    }\r\n    return !orFields;\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0337301587,"mi":0.3660324172,"fo":-0.25,"r":0.0,"e":-0.0984330607}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-326_ce185345","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic double getL1Norm() {\r\n    double sum = 0;\r\n    for (double a : data) {\r\n        sum += Math.abs(a);\r\n    }\r\n    return sum;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public double getL1Norm() {\r\n    double sum = 0;\r\n    for (double a : data) {\r\n        sum += Math.abs(a);\r\n    }\r\n    return sum;\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.0912698413,"mi":0.5241719521,"fo":-0.4166666667,"r":2.5526315789,"e":-0.1354172069}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-56_3eb44094","label":3,"code":"\/**\r\n * Convert the string passed as argument to a level. If the\r\n * conversion fails, then this method returns the value of\r\n * <code>defaultLevel<\/code>.\r\n *\r\n * @param sArg The name of the desired Level.\r\n * @param defaultLevel The Level to use if the String is invalid.\r\n * @return The LEvel associated with the String.\r\n *\/\r\npublic static Level toLevel(String sArg, Level defaultLevel) {\r\n    if (sArg == null) {\r\n        return defaultLevel;\r\n    }\r\n    Level level = valueOf(sArg);\r\n    return (level == null) ? defaultLevel : level;\r\n}","code_comment":"\/**\r\n * Convert the string passed as argument to a level. If the\r\n * conversion fails, then this method returns the value of\r\n * <code>defaultLevel<\/code>.\r\n *\r\n * @param sArg The name of the desired Level.\r\n * @param defaultLevel The Level to use if the String is invalid.\r\n * @return The LEvel associated with the String.\r\n *\/\r\n","code_no_comment":"public static Level toLevel(String sArg, Level defaultLevel) {\r\n    if (sArg == null) {\r\n        return defaultLevel;\r\n    }\r\n    Level level = valueOf(sArg);\r\n    return (level == null) ? defaultLevel : level;\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":0.0317460317,"mi":0.4412966878,"fo":-0.4166666667,"r":1.3684210526,"e":-0.095805167}
{"project_name":"Lang","project_version":"42","label":3,"code":"\/**\r\n * <p>\r\n * Escapes the characters in the <code>String<\/code> passed and writes the result to the <code>Writer<\/code>\r\n * passed.\r\n * <\/p>\r\n *\r\n * @param writer\r\n *            The <code>Writer<\/code> to write the results of the escaping to. Assumed to be a non-null value.\r\n * @param str\r\n *            The <code>String<\/code> to escape. Assumed to be a non-null value.\r\n * @throws IOException\r\n *             when <code>Writer<\/code> passed throws the exception from calls to the {@link Writer#write(int)}\r\n *             methods.\r\n *\r\n * @see #escape(String)\r\n * @see Writer\r\n *\/\r\npublic void escape(Writer writer, String str) throws IOException {\r\n    int len = str.length();\r\n    for (int i = 0; i < len; i++) {\r\n        char c = str.charAt(i);\r\n        String entityName = this.entityName(c);\r\n        if (entityName == null) {\r\n            if (c > 0x7F) {\r\n                writer.write(\"&#\");\r\n                writer.write(Integer.toString(c, 10));\r\n                writer.write(';');\r\n            } else {\r\n                writer.write(c);\r\n            }\r\n        } else {\r\n            writer.write('&');\r\n            writer.write(entityName);\r\n            writer.write(';');\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * <p>\r\n * Escapes the characters in the <code>String<\/code> passed and writes the result to the <code>Writer<\/code>\r\n * passed.\r\n * <\/p>\r\n *\r\n * @param writer\r\n *            The <code>Writer<\/code> to write the results of the escaping to. Assumed to be a non-null value.\r\n * @param str\r\n *            The <code>String<\/code> to escape. Assumed to be a non-null value.\r\n * @throws IOException\r\n *             when <code>Writer<\/code> passed throws the exception from calls to the {@link Writer#write(int)}\r\n *             methods.\r\n *\r\n * @see #escape(String)\r\n * @see Writer\r\n *\/\r\n","code_no_comment":"public void escape(Writer writer, String str) throws IOException {\r\n    int len = str.length();\r\n    for (int i = 0; i < len; i++) {\r\n        char c = str.charAt(i);\r\n        String entityName = this.entityName(c);\r\n        if (entityName == null) {\r\n            if (c > 0x7F) {\r\n                writer.write(\"&#\");\r\n                writer.write(Integer.toString(c, 10));\r\n                writer.write(';');\r\n            } else {\r\n                writer.write(c);\r\n            }\r\n        } else {\r\n            writer.write('&');\r\n            writer.write(entityName);\r\n            writer.write(';');\r\n        }\r\n    }\r\n}","lc":0.2727272727,"pi":0.9330143541,"ma":0.0,"nbd":0.5,"ml":0.1666666667,"d":0.5138888889,"mi":-0.2442565187,"fo":0.4166666667,"r":-0.0263157895,"e":0.4171181918}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3448_b345dd82","label":0,"code":"public static ExceptionPolicyKey newInstance(Class exceptionClass) {\r\n    return new ExceptionPolicyKey(exceptionClass, null);\r\n}","code_comment":null,"code_no_comment":"public static ExceptionPolicyKey newInstance(Class exceptionClass) {\r\n    return new ExceptionPolicyKey(exceptionClass, null);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0253699789,"fo":-0.5,"r":1.1052631579,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-358_061f5017","label":0,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\r\n    final int n = y0.length;\r\n    sanityChecks(equations, t0, y0, t, y);\r\n    setEquations(equations);\r\n    resetEvaluations();\r\n    final boolean forward = t > t0;\r\n    \/\/ initialize working arrays\r\n    if (y != y0) {\r\n        System.arraycopy(y0, 0, y, 0, n);\r\n    }\r\n    final double[] yDot = new double[n];\r\n    final double[] yTmp = new double[y0.length];\r\n    \/\/ set up an interpolator sharing the integrator arrays\r\n    final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\r\n    interpolator.reinitialize(y, forward);\r\n    final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\r\n    interpolatorTmp.reinitialize(yTmp, forward);\r\n    \/\/ set up integration control objects\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.reset();\r\n    }\r\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\r\n    \/\/ compute the initial Nordsieck vector using the configured starter integrator\r\n    start(t0, y, t);\r\n    interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\r\n    interpolator.storeTime(stepStart);\r\n    final int lastRow = nordsieck.getRowDimension() - 1;\r\n    \/\/ reuse the step that was chosen by the starter integrator\r\n    double hNew = stepSize;\r\n    interpolator.rescale(hNew);\r\n    boolean lastStep = false;\r\n    while (!lastStep) {\r\n        \/\/ shift all data\r\n        interpolator.shift();\r\n        double error = 0;\r\n        for (boolean loop = true; loop; ) {\r\n            stepSize = hNew;\r\n            \/\/ evaluate error using the last term of the Taylor expansion\r\n            error = 0;\r\n            for (int i = 0; i < y0.length; ++i) {\r\n                final double yScale = Math.abs(y[i]);\r\n                final double tol = (vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);\r\n                final double ratio = nordsieck.getEntry(lastRow, i) \/ tol;\r\n                error += ratio * ratio;\r\n            }\r\n            error = Math.sqrt(error \/ y0.length);\r\n            if (error <= 1.0) {\r\n                \/\/ predict a first estimate of the state at step end\r\n                final double stepEnd = stepStart + stepSize;\r\n                interpolator.setInterpolatedTime(stepEnd);\r\n                System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\r\n                \/\/ evaluate the derivative\r\n                computeDerivatives(stepEnd, yTmp, yDot);\r\n                \/\/ update Nordsieck vector\r\n                final double[] predictedScaled = new double[y0.length];\r\n                for (int j = 0; j < y0.length; ++j) {\r\n                    predictedScaled[j] = stepSize * yDot[j];\r\n                }\r\n                final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\r\n                updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\r\n                \/\/ discrete events handling\r\n                interpolatorTmp.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp);\r\n                interpolatorTmp.storeTime(stepStart);\r\n                interpolatorTmp.shift();\r\n                interpolatorTmp.storeTime(stepEnd);\r\n                if (manager.evaluateStep(interpolatorTmp)) {\r\n                    final double dt = manager.getEventTime() - stepStart;\r\n                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\r\n                        \/\/ rejecting the step would lead to a too small next step, we accept it\r\n                        loop = false;\r\n                    } else {\r\n                        \/\/ reject the step to match exactly the next switch time\r\n                        hNew = dt;\r\n                        interpolator.rescale(hNew);\r\n                    }\r\n                } else {\r\n                    \/\/ accept the step\r\n                    scaled = predictedScaled;\r\n                    nordsieck = nordsieckTmp;\r\n                    interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\r\n                    loop = false;\r\n                }\r\n            } else {\r\n                \/\/ reject the step and attempt to reduce error by stepsize control\r\n                final double factor = computeStepGrowShrinkFactor(error);\r\n                hNew = filterStep(stepSize * factor, forward, false);\r\n                interpolator.rescale(hNew);\r\n            }\r\n        }\r\n        \/\/ the step has been accepted (may have been truncated)\r\n        final double nextStep = stepStart + stepSize;\r\n        System.arraycopy(yTmp, 0, y, 0, n);\r\n        interpolator.storeTime(nextStep);\r\n        manager.stepAccepted(nextStep, y);\r\n        lastStep = manager.stop();\r\n        \/\/ provide the step data to the step handler\r\n        for (StepHandler handler : stepHandlers) {\r\n            interpolator.setInterpolatedTime(nextStep);\r\n            handler.handleStep(interpolator, lastStep);\r\n        }\r\n        stepStart = nextStep;\r\n        if (!lastStep && manager.reset(stepStart, y)) {\r\n            \/\/ some events handler has triggered changes that\r\n            \/\/ invalidate the derivatives, we need to restart from scratch\r\n            start(stepStart, y, t);\r\n            interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\r\n        }\r\n        if (!lastStep) {\r\n            \/\/ in some rare cases we may get here with stepSize = 0, for example\r\n            \/\/ when an event occurs at integration start, reducing the first step\r\n            \/\/ to zero; we have to reset the step to some safe non zero value\r\n            stepSize = filterStep(stepSize, forward, true);\r\n            \/\/ stepsize control for next step\r\n            final double factor = computeStepGrowShrinkFactor(error);\r\n            final double scaledH = stepSize * factor;\r\n            final double nextT = stepStart + scaledH;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            hNew = filterStep(scaledH, forward, nextIsLast);\r\n            interpolator.rescale(hNew);\r\n        }\r\n    }\r\n    final double stopTime = stepStart;\r\n    stepStart = Double.NaN;\r\n    stepSize = Double.NaN;\r\n    return stopTime;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\r\n    final int n = y0.length;\r\n    sanityChecks(equations, t0, y0, t, y);\r\n    setEquations(equations);\r\n    resetEvaluations();\r\n    final boolean forward = t > t0;\r\n        if (y != y0) {\r\n        System.arraycopy(y0, 0, y, 0, n);\r\n    }\r\n    final double[] yDot = new double[n];\r\n    final double[] yTmp = new double[y0.length];\r\n        final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\r\n    interpolator.reinitialize(y, forward);\r\n    final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\r\n    interpolatorTmp.reinitialize(yTmp, forward);\r\n        for (StepHandler handler : stepHandlers) {\r\n        handler.reset();\r\n    }\r\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\r\n        start(t0, y, t);\r\n    interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\r\n    interpolator.storeTime(stepStart);\r\n    final int lastRow = nordsieck.getRowDimension() - 1;\r\n        double hNew = stepSize;\r\n    interpolator.rescale(hNew);\r\n    boolean lastStep = false;\r\n    while (!lastStep) {\r\n                interpolator.shift();\r\n        double error = 0;\r\n        for (boolean loop = true; loop; ) {\r\n            stepSize = hNew;\r\n                        error = 0;\r\n            for (int i = 0; i < y0.length; ++i) {\r\n                final double yScale = Math.abs(y[i]);\r\n                final double tol = (vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);\r\n                final double ratio = nordsieck.getEntry(lastRow, i) \/ tol;\r\n                error += ratio * ratio;\r\n            }\r\n            error = Math.sqrt(error \/ y0.length);\r\n            if (error <= 1.0) {\r\n                                final double stepEnd = stepStart + stepSize;\r\n                interpolator.setInterpolatedTime(stepEnd);\r\n                System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\r\n                                computeDerivatives(stepEnd, yTmp, yDot);\r\n                                final double[] predictedScaled = new double[y0.length];\r\n                for (int j = 0; j < y0.length; ++j) {\r\n                    predictedScaled[j] = stepSize * yDot[j];\r\n                }\r\n                final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\r\n                updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\r\n                                interpolatorTmp.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp);\r\n                interpolatorTmp.storeTime(stepStart);\r\n                interpolatorTmp.shift();\r\n                interpolatorTmp.storeTime(stepEnd);\r\n                if (manager.evaluateStep(interpolatorTmp)) {\r\n                    final double dt = manager.getEventTime() - stepStart;\r\n                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\r\n                                                loop = false;\r\n                    } else {\r\n                                                hNew = dt;\r\n                        interpolator.rescale(hNew);\r\n                    }\r\n                } else {\r\n                                        scaled = predictedScaled;\r\n                    nordsieck = nordsieckTmp;\r\n                    interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\r\n                    loop = false;\r\n                }\r\n            } else {\r\n                                final double factor = computeStepGrowShrinkFactor(error);\r\n                hNew = filterStep(stepSize * factor, forward, false);\r\n                interpolator.rescale(hNew);\r\n            }\r\n        }\r\n                final double nextStep = stepStart + stepSize;\r\n        System.arraycopy(yTmp, 0, y, 0, n);\r\n        interpolator.storeTime(nextStep);\r\n        manager.stepAccepted(nextStep, y);\r\n        lastStep = manager.stop();\r\n                for (StepHandler handler : stepHandlers) {\r\n            interpolator.setInterpolatedTime(nextStep);\r\n            handler.handleStep(interpolator, lastStep);\r\n        }\r\n        stepStart = nextStep;\r\n        if (!lastStep && manager.reset(stepStart, y)) {\r\n                                    start(stepStart, y, t);\r\n            interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\r\n        }\r\n        if (!lastStep) {\r\n                                                stepSize = filterStep(stepSize, forward, true);\r\n                        final double factor = computeStepGrowShrinkFactor(error);\r\n            final double scaledH = stepSize * factor;\r\n            final double nextT = stepStart + scaledH;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            hNew = filterStep(scaledH, forward, nextIsLast);\r\n            interpolator.rescale(hNew);\r\n        }\r\n    }\r\n    final double stopTime = stepStart;\r\n    stepStart = Double.NaN;\r\n    stepSize = Double.NaN;\r\n    return stopTime;\r\n}","lc":4.0909090909,"pi":1.4497607656,"ma":2.2,"nbd":1.5,"ml":2.0833333333,"d":4.5257936508,"mi":-1.3980267794,"fo":3.5833333333,"r":-0.0263157895,"e":30.40861442}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3475_7651b777","label":1,"code":"\/\/ Not for client use\r\npublic boolean config(String... args) {\r\n    CommandLine cl;\r\n    try {\r\n        cl = new BasicParser().parse(opts, args);\r\n        if (cl.getArgs().length > 0)\r\n            throw new ParseException(\"Unrecognized arguments: \" + cl.getArgList());\r\n        if (cl.hasOption(helpOpt.getOpt())) {\r\n            configError = true;\r\n            printHelp(\"shell\", SHELL_DESCRIPTION, opts);\r\n            return true;\r\n        }\r\n        setDebugging(cl.hasOption(debugOption.getLongOpt()));\r\n        authTimeout = TimeUnit.MINUTES.toNanos(Integer.parseInt(cl.getOptionValue(authTimeoutOpt.getLongOpt(), DEFAULT_AUTH_TIMEOUT)));\r\n        disableAuthTimeout = cl.hasOption(disableAuthTimeoutOpt.getLongOpt());\r\n        if (cl.hasOption(zooKeeperInstance.getOpt()) && cl.getOptionValues(zooKeeperInstance.getOpt()).length != 2)\r\n            throw new MissingArgumentException(zooKeeperInstance);\r\n    } catch (Exception e) {\r\n        configError = true;\r\n        printException(e);\r\n        printHelp(\"shell\", SHELL_DESCRIPTION, opts);\r\n        return true;\r\n    }\r\n    \/\/ get the options that were parsed\r\n    String sysUser = System.getProperty(\"user.name\");\r\n    if (sysUser == null)\r\n        sysUser = \"root\";\r\n    String user = cl.getOptionValue(usernameOption.getOpt(), sysUser);\r\n    String passw = cl.getOptionValue(passwOption.getOpt(), null);\r\n    tabCompletion = !cl.hasOption(tabCompleteOption.getLongOpt());\r\n    String[] loginOptions = cl.getOptionValues(loginOption.getOpt());\r\n    \/\/ Use a fake (Mock), ZK, or HdfsZK Accumulo instance\r\n    setInstance(cl);\r\n    \/\/ process default parameters if unspecified\r\n    try {\r\n        if (loginOptions != null && !cl.hasOption(tokenOption.getOpt()))\r\n            throw new IllegalArgumentException(\"Must supply '-\" + tokenOption.getOpt() + \"' option with '-\" + loginOption.getOpt() + \"' option\");\r\n        if (loginOptions == null && cl.hasOption(tokenOption.getOpt()))\r\n            throw new IllegalArgumentException(\"Must supply '-\" + loginOption.getOpt() + \"' option with '-\" + tokenOption.getOpt() + \"' option\");\r\n        if (passw != null && cl.hasOption(tokenOption.getOpt()))\r\n            throw new IllegalArgumentException(\"Can not supply '-\" + passwOption.getOpt() + \"' option with '-\" + tokenOption.getOpt() + \"' option\");\r\n        if (user == null)\r\n            throw new MissingArgumentException(usernameOption);\r\n        if (loginOptions != null && cl.hasOption(tokenOption.getOpt())) {\r\n            Properties props = new Properties();\r\n            for (String loginOption : loginOptions) for (String lo : loginOption.split(\",\")) {\r\n                String[] split = lo.split(\"=\");\r\n                props.put(split[0], split[1]);\r\n            }\r\n            this.token = Class.forName(cl.getOptionValue(tokenOption.getOpt())).asSubclass(AuthenticationToken.class).newInstance();\r\n            this.token.init(props);\r\n        }\r\n        if (!cl.hasOption(fakeOption.getLongOpt())) {\r\n            DistributedTrace.enable(instance, new ZooReader(instance.getZooKeepers(), instance.getZooKeepersSessionTimeOut()), \"shell\", InetAddress.getLocalHost().getHostName());\r\n        }\r\n        Runtime.getRuntime().addShutdownHook(new Thread() {\r\n\r\n            @Override\r\n            public void start() {\r\n                reader.getTerminal().enableEcho();\r\n            }\r\n        });\r\n        if (passw != null) {\r\n            this.token = new PasswordToken(passw);\r\n        }\r\n        if (this.token == null) {\r\n            passw = readMaskedLine(\"Password: \", '*');\r\n            if (passw != null)\r\n                this.token = new PasswordToken(passw);\r\n        }\r\n        if (this.token == null) {\r\n            reader.printNewline();\r\n            throw new MissingArgumentException(\"No password or token option supplied\");\r\n        }\r\n        \/\/ user canceled\r\n        this.setTableName(\"\");\r\n        this.principal = user;\r\n        connector = instance.getConnector(this.principal, token);\r\n    } catch (Exception e) {\r\n        printException(e);\r\n        configError = true;\r\n    }\r\n    \/\/ decide whether to execute commands from a file and quit\r\n    if (cl.hasOption(execfileOption.getOpt())) {\r\n        execFile = cl.getOptionValue(execfileOption.getOpt());\r\n        verbose = false;\r\n    } else if (cl.hasOption(execfileVerboseOption.getOpt())) {\r\n        execFile = cl.getOptionValue(execfileVerboseOption.getOpt());\r\n    }\r\n    if (cl.hasOption(execCommandOpt.getOpt())) {\r\n        execCommand = cl.getOptionValue(execCommandOpt.getOpt());\r\n        verbose = false;\r\n    }\r\n    rootToken = new Token();\r\n    Command[] dataCommands = { new DeleteCommand(), new DeleteManyCommand(), new DeleteRowsCommand(), new EGrepCommand(), new FormatterCommand(), new InterpreterCommand(), new GrepCommand(), new ImportDirectoryCommand(), new InsertCommand(), new MaxRowCommand(), new ScanCommand() };\r\n    Command[] debuggingCommands = { new ClasspathCommand(), new DebugCommand(), new ListScansCommand(), new ListCompactionsCommand(), new TraceCommand(), new PingCommand() };\r\n    Command[] execCommands = { new ExecfileCommand(), new HistoryCommand() };\r\n    Command[] exitCommands = { new ByeCommand(), new ExitCommand(), new QuitCommand() };\r\n    Command[] helpCommands = { new AboutCommand(), new HelpCommand(), new InfoCommand(), new QuestionCommand() };\r\n    Command[] iteratorCommands = { new DeleteIterCommand(), new DeleteScanIterCommand(), new ListIterCommand(), new SetIterCommand(), new SetScanIterCommand(), new SetShellIterCommand(), new ListShellIterCommand(), new DeleteShellIterCommand() };\r\n    Command[] otherCommands = { new HiddenCommand() };\r\n    Command[] permissionsCommands = { new GrantCommand(), new RevokeCommand(), new SystemPermissionsCommand(), new TablePermissionsCommand(), new UserPermissionsCommand() };\r\n    Command[] stateCommands = { new AuthenticateCommand(), new ClsCommand(), new ClearCommand(), new NoTableCommand(), new SleepCommand(), new TableCommand(), new UserCommand(), new WhoAmICommand() };\r\n    Command[] tableCommands = { new CloneTableCommand(), new ConfigCommand(), new CreateTableCommand(), new DeleteTableCommand(), new DropTableCommand(), new DUCommand(), new ExportTableCommand(), new ImportTableCommand(), new OfflineCommand(), new OnlineCommand(), new RenameTableCommand(), new TablesCommand() };\r\n    Command[] tableControlCommands = { new AddSplitsCommand(), new CompactCommand(), new ConstraintCommand(), new FlushCommand(), new GetGroupsCommand(), new GetSplitsCommand(), new MergeCommand(), new SetGroupsCommand() };\r\n    Command[] userCommands = { new AddAuthsCommand(), new CreateUserCommand(), new DeleteUserCommand(), new DropUserCommand(), new GetAuthsCommand(), new PasswdCommand(), new SetAuthsCommand(), new UsersCommand() };\r\n    commandGrouping.put(\"-- Writing, Reading, and Removing Data --\", dataCommands);\r\n    commandGrouping.put(\"-- Debugging Commands -------------------\", debuggingCommands);\r\n    commandGrouping.put(\"-- Shell Execution Commands -------------\", execCommands);\r\n    commandGrouping.put(\"-- Exiting Commands ---------------------\", exitCommands);\r\n    commandGrouping.put(\"-- Help Commands ------------------------\", helpCommands);\r\n    commandGrouping.put(\"-- Iterator Configuration ---------------\", iteratorCommands);\r\n    commandGrouping.put(\"-- Permissions Administration Commands --\", permissionsCommands);\r\n    commandGrouping.put(\"-- Shell State Commands -----------------\", stateCommands);\r\n    commandGrouping.put(\"-- Table Administration Commands --------\", tableCommands);\r\n    commandGrouping.put(\"-- Table Control Commands ---------------\", tableControlCommands);\r\n    commandGrouping.put(\"-- User Administration Commands ---------\", userCommands);\r\n    for (Command[] cmds : commandGrouping.values()) {\r\n        for (Command cmd : cmds) commandFactory.put(cmd.getName(), cmd);\r\n    }\r\n    for (Command cmd : otherCommands) {\r\n        commandFactory.put(cmd.getName(), cmd);\r\n    }\r\n    return configError;\r\n}","code_comment":null,"code_no_comment":"public boolean config(String... args) {\r\n    CommandLine cl;\r\n    try {\r\n        cl = new BasicParser().parse(opts, args);\r\n        if (cl.getArgs().length > 0)\r\n            throw new ParseException(\"Unrecognized arguments: \" + cl.getArgList());\r\n        if (cl.hasOption(helpOpt.getOpt())) {\r\n            configError = true;\r\n            printHelp(\"shell\", SHELL_DESCRIPTION, opts);\r\n            return true;\r\n        }\r\n        setDebugging(cl.hasOption(debugOption.getLongOpt()));\r\n        authTimeout = TimeUnit.MINUTES.toNanos(Integer.parseInt(cl.getOptionValue(authTimeoutOpt.getLongOpt(), DEFAULT_AUTH_TIMEOUT)));\r\n        disableAuthTimeout = cl.hasOption(disableAuthTimeoutOpt.getLongOpt());\r\n        if (cl.hasOption(zooKeeperInstance.getOpt()) && cl.getOptionValues(zooKeeperInstance.getOpt()).length != 2)\r\n            throw new MissingArgumentException(zooKeeperInstance);\r\n    } catch (Exception e) {\r\n        configError = true;\r\n        printException(e);\r\n        printHelp(\"shell\", SHELL_DESCRIPTION, opts);\r\n        return true;\r\n    }\r\n        String sysUser = System.getProperty(\"user.name\");\r\n    if (sysUser == null)\r\n        sysUser = \"root\";\r\n    String user = cl.getOptionValue(usernameOption.getOpt(), sysUser);\r\n    String passw = cl.getOptionValue(passwOption.getOpt(), null);\r\n    tabCompletion = !cl.hasOption(tabCompleteOption.getLongOpt());\r\n    String[] loginOptions = cl.getOptionValues(loginOption.getOpt());\r\n        setInstance(cl);\r\n        try {\r\n        if (loginOptions != null && !cl.hasOption(tokenOption.getOpt()))\r\n            throw new IllegalArgumentException(\"Must supply '-\" + tokenOption.getOpt() + \"' option with '-\" + loginOption.getOpt() + \"' option\");\r\n        if (loginOptions == null && cl.hasOption(tokenOption.getOpt()))\r\n            throw new IllegalArgumentException(\"Must supply '-\" + loginOption.getOpt() + \"' option with '-\" + tokenOption.getOpt() + \"' option\");\r\n        if (passw != null && cl.hasOption(tokenOption.getOpt()))\r\n            throw new IllegalArgumentException(\"Can not supply '-\" + passwOption.getOpt() + \"' option with '-\" + tokenOption.getOpt() + \"' option\");\r\n        if (user == null)\r\n            throw new MissingArgumentException(usernameOption);\r\n        if (loginOptions != null && cl.hasOption(tokenOption.getOpt())) {\r\n            Properties props = new Properties();\r\n            for (String loginOption : loginOptions) for (String lo : loginOption.split(\",\")) {\r\n                String[] split = lo.split(\"=\");\r\n                props.put(split[0], split[1]);\r\n            }\r\n            this.token = Class.forName(cl.getOptionValue(tokenOption.getOpt())).asSubclass(AuthenticationToken.class).newInstance();\r\n            this.token.init(props);\r\n        }\r\n        if (!cl.hasOption(fakeOption.getLongOpt())) {\r\n            DistributedTrace.enable(instance, new ZooReader(instance.getZooKeepers(), instance.getZooKeepersSessionTimeOut()), \"shell\", InetAddress.getLocalHost().getHostName());\r\n        }\r\n        Runtime.getRuntime().addShutdownHook(new Thread() {\r\n\r\n            @Override\r\n            public void start() {\r\n                reader.getTerminal().enableEcho();\r\n            }\r\n        });\r\n        if (passw != null) {\r\n            this.token = new PasswordToken(passw);\r\n        }\r\n        if (this.token == null) {\r\n            passw = readMaskedLine(\"Password: \", '*');\r\n            if (passw != null)\r\n                this.token = new PasswordToken(passw);\r\n        }\r\n        if (this.token == null) {\r\n            reader.printNewline();\r\n            throw new MissingArgumentException(\"No password or token option supplied\");\r\n        }\r\n                this.setTableName(\"\");\r\n        this.principal = user;\r\n        connector = instance.getConnector(this.principal, token);\r\n    } catch (Exception e) {\r\n        printException(e);\r\n        configError = true;\r\n    }\r\n        if (cl.hasOption(execfileOption.getOpt())) {\r\n        execFile = cl.getOptionValue(execfileOption.getOpt());\r\n        verbose = false;\r\n    } else if (cl.hasOption(execfileVerboseOption.getOpt())) {\r\n        execFile = cl.getOptionValue(execfileVerboseOption.getOpt());\r\n    }\r\n    if (cl.hasOption(execCommandOpt.getOpt())) {\r\n        execCommand = cl.getOptionValue(execCommandOpt.getOpt());\r\n        verbose = false;\r\n    }\r\n    rootToken = new Token();\r\n    Command[] dataCommands = { new DeleteCommand(), new DeleteManyCommand(), new DeleteRowsCommand(), new EGrepCommand(), new FormatterCommand(), new InterpreterCommand(), new GrepCommand(), new ImportDirectoryCommand(), new InsertCommand(), new MaxRowCommand(), new ScanCommand() };\r\n    Command[] debuggingCommands = { new ClasspathCommand(), new DebugCommand(), new ListScansCommand(), new ListCompactionsCommand(), new TraceCommand(), new PingCommand() };\r\n    Command[] execCommands = { new ExecfileCommand(), new HistoryCommand() };\r\n    Command[] exitCommands = { new ByeCommand(), new ExitCommand(), new QuitCommand() };\r\n    Command[] helpCommands = { new AboutCommand(), new HelpCommand(), new InfoCommand(), new QuestionCommand() };\r\n    Command[] iteratorCommands = { new DeleteIterCommand(), new DeleteScanIterCommand(), new ListIterCommand(), new SetIterCommand(), new SetScanIterCommand(), new SetShellIterCommand(), new ListShellIterCommand(), new DeleteShellIterCommand() };\r\n    Command[] otherCommands = { new HiddenCommand() };\r\n    Command[] permissionsCommands = { new GrantCommand(), new RevokeCommand(), new SystemPermissionsCommand(), new TablePermissionsCommand(), new UserPermissionsCommand() };\r\n    Command[] stateCommands = { new AuthenticateCommand(), new ClsCommand(), new ClearCommand(), new NoTableCommand(), new SleepCommand(), new TableCommand(), new UserCommand(), new WhoAmICommand() };\r\n    Command[] tableCommands = { new CloneTableCommand(), new ConfigCommand(), new CreateTableCommand(), new DeleteTableCommand(), new DropTableCommand(), new DUCommand(), new ExportTableCommand(), new ImportTableCommand(), new OfflineCommand(), new OnlineCommand(), new RenameTableCommand(), new TablesCommand() };\r\n    Command[] tableControlCommands = { new AddSplitsCommand(), new CompactCommand(), new ConstraintCommand(), new FlushCommand(), new GetGroupsCommand(), new GetSplitsCommand(), new MergeCommand(), new SetGroupsCommand() };\r\n    Command[] userCommands = { new AddAuthsCommand(), new CreateUserCommand(), new DeleteUserCommand(), new DropUserCommand(), new GetAuthsCommand(), new PasswdCommand(), new SetAuthsCommand(), new UsersCommand() };\r\n    commandGrouping.put(\"-- Writing, Reading, and Removing Data --\", dataCommands);\r\n    commandGrouping.put(\"-- Debugging Commands -------------------\", debuggingCommands);\r\n    commandGrouping.put(\"-- Shell Execution Commands -------------\", execCommands);\r\n    commandGrouping.put(\"-- Exiting Commands ---------------------\", exitCommands);\r\n    commandGrouping.put(\"-- Help Commands ------------------------\", helpCommands);\r\n    commandGrouping.put(\"-- Iterator Configuration ---------------\", iteratorCommands);\r\n    commandGrouping.put(\"-- Permissions Administration Commands --\", permissionsCommands);\r\n    commandGrouping.put(\"-- Shell State Commands -----------------\", stateCommands);\r\n    commandGrouping.put(\"-- Table Administration Commands --------\", tableCommands);\r\n    commandGrouping.put(\"-- Table Control Commands ---------------\", tableControlCommands);\r\n    commandGrouping.put(\"-- User Administration Commands ---------\", userCommands);\r\n    for (Command[] cmds : commandGrouping.values()) {\r\n        for (Command cmd : cmds) commandFactory.put(cmd.getName(), cmd);\r\n    }\r\n    for (Command cmd : otherCommands) {\r\n        commandFactory.put(cmd.getName(), cmd);\r\n    }\r\n    return configError;\r\n}","lc":4.7272727273,"pi":0.2535885167,"ma":5.6,"nbd":1.0,"ml":3.1666666667,"d":0.8432539683,"mi":-1.6269203665,"fo":7.6666666667,"r":-0.0263157895,"e":11.2940808999}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-139_50e19247","label":1,"code":"\/**\r\n * @param host The name of the host to connect to.\r\n * @param portNum The port to connect to on the target host.\r\n * @param protocol The Protocol to use.\r\n * @param delay The interval in which failed writes should be retried.\r\n * @param immediateFail True if the write should fail if no socket is immediately available.\r\n * @param name The name of the Appender.\r\n * @param immediateFlush \"true\" if data should be flushed on each write.\r\n * @param suppress \"true\" if exceptions should be hidden from the application, \"false\" otherwise.\r\n * The default is \"true\".\r\n * @param layout The layout to use (defaults to SerializedLayout).\r\n * @param filter The Filter or null.\r\n * @param advertise \"true\" if the appender configuration should be advertised, \"false\" otherwise.\r\n * @param config The Configuration\r\n * @return A SocketAppender.\r\n *\/\r\n@PluginFactory\r\npublic static <S extends Serializable> SocketAppender<S> createAppender(@PluginAttr(\"host\") final String host, @PluginAttr(\"port\") final String portNum, @PluginAttr(\"protocol\") final String protocol, @PluginAttr(\"reconnectionDelay\") final String delay, @PluginAttr(\"immediateFail\") final String immediateFail, @PluginAttr(\"name\") final String name, @PluginAttr(\"immediateFlush\") final String immediateFlush, @PluginAttr(\"suppressExceptions\") final String suppress, @PluginElement(\"layout\") Layout<S> layout, @PluginElement(\"filters\") final Filter filter, @PluginAttr(\"advertise\") final String advertise, @PluginConfiguration final Configuration config) {\r\n    boolean isFlush = immediateFlush == null ? true : Boolean.valueOf(immediateFlush);\r\n    boolean isAdvertise = advertise == null ? false : Boolean.valueOf(advertise);\r\n    final boolean handleExceptions = suppress == null ? true : Boolean.valueOf(suppress);\r\n    final boolean fail = immediateFail == null ? true : Boolean.valueOf(immediateFail);\r\n    final int reconnectDelay = delay == null ? 0 : Integer.parseInt(delay);\r\n    final int port = portNum == null ? 0 : Integer.parseInt(portNum);\r\n    if (layout == null) {\r\n        @SuppressWarnings({ \"unchecked\", \"UnnecessaryLocalVariable\" })\r\n        Layout<S> l = (Layout<S>) SerializedLayout.createLayout();\r\n        layout = l;\r\n    }\r\n    if (name == null) {\r\n        LOGGER.error(\"No name provided for SocketAppender\");\r\n        return null;\r\n    }\r\n    final String prot = protocol != null ? protocol : Protocol.TCP.name();\r\n    final Protocol p = EnglishEnums.valueOf(Protocol.class, protocol);\r\n    if (p.equals(Protocol.UDP)) {\r\n        isFlush = true;\r\n    }\r\n    final AbstractSocketManager manager = createSocketManager(p, host, port, reconnectDelay, fail, layout);\r\n    if (manager == null) {\r\n        return null;\r\n    }\r\n    return new SocketAppender<S>(name, layout, filter, manager, handleExceptions, isFlush, isAdvertise ? config.getAdvertiser() : null);\r\n}","code_comment":"\/**\r\n * @param host The name of the host to connect to.\r\n * @param portNum The port to connect to on the target host.\r\n * @param protocol The Protocol to use.\r\n * @param delay The interval in which failed writes should be retried.\r\n * @param immediateFail True if the write should fail if no socket is immediately available.\r\n * @param name The name of the Appender.\r\n * @param immediateFlush \"true\" if data should be flushed on each write.\r\n * @param suppress \"true\" if exceptions should be hidden from the application, \"false\" otherwise.\r\n * The default is \"true\".\r\n * @param layout The layout to use (defaults to SerializedLayout).\r\n * @param filter The Filter or null.\r\n * @param advertise \"true\" if the appender configuration should be advertised, \"false\" otherwise.\r\n * @param config The Configuration\r\n * @return A SocketAppender.\r\n *\/\r\n","code_no_comment":"@PluginFactory\r\npublic static <S extends Serializable> SocketAppender<S> createAppender(@PluginAttr(\"host\") final String host, @PluginAttr(\"port\") final String portNum, @PluginAttr(\"protocol\") final String protocol, @PluginAttr(\"reconnectionDelay\") final String delay, @PluginAttr(\"immediateFail\") final String immediateFail, @PluginAttr(\"name\") final String name, @PluginAttr(\"immediateFlush\") final String immediateFlush, @PluginAttr(\"suppressExceptions\") final String suppress, @PluginElement(\"layout\") Layout<S> layout, @PluginElement(\"filters\") final Filter filter, @PluginAttr(\"advertise\") final String advertise, @PluginConfiguration final Configuration config) {\r\n    boolean isFlush = immediateFlush == null ? true : Boolean.valueOf(immediateFlush);\r\n    boolean isAdvertise = advertise == null ? false : Boolean.valueOf(advertise);\r\n    final boolean handleExceptions = suppress == null ? true : Boolean.valueOf(suppress);\r\n    final boolean fail = immediateFail == null ? true : Boolean.valueOf(immediateFail);\r\n    final int reconnectDelay = delay == null ? 0 : Integer.parseInt(delay);\r\n    final int port = portNum == null ? 0 : Integer.parseInt(portNum);\r\n    if (layout == null) {\r\n        @SuppressWarnings({ \"unchecked\", \"UnnecessaryLocalVariable\" })\r\n        Layout<S> l = (Layout<S>) SerializedLayout.createLayout();\r\n        layout = l;\r\n    }\r\n    if (name == null) {\r\n        LOGGER.error(\"No name provided for SocketAppender\");\r\n        return null;\r\n    }\r\n    final String prot = protocol != null ? protocol : Protocol.TCP.name();\r\n    final Protocol p = EnglishEnums.valueOf(Protocol.class, protocol);\r\n    if (p.equals(Protocol.UDP)) {\r\n        isFlush = true;\r\n    }\r\n    final AbstractSocketManager manager = createSocketManager(p, host, port, reconnectDelay, fail, layout);\r\n    if (manager == null) {\r\n        return null;\r\n    }\r\n    return new SocketAppender<S>(name, layout, filter, manager, handleExceptions, isFlush, isAdvertise ? config.getAdvertiser() : null);\r\n}","lc":0.6363636364,"pi":-0.3205741627,"ma":1.8,"nbd":-0.5,"ml":1.5833333333,"d":0.1507936508,"mi":-0.6552501762,"fo":0.5833333333,"r":-0.0263157895,"e":1.1566351435}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2033_420ac965","label":3,"code":"\/**\r\n *  @see org.apache.wicket.ajax.AbstractDefaultAjaxBehavior#getPreconditionScript()\r\n *\/\r\n@Override\r\nprotected CharSequence getPreconditionScript() {\r\n    return \"return Wicket.$$(this)&amp;&amp;Wicket.$$('\" + getForm().getMarkupId() + \"')\";\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.ajax.AbstractDefaultAjaxBehavior#getPreconditionScript()\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected CharSequence getPreconditionScript() {\r\n    return \"return Wicket.$$(this)&amp;&amp;Wicket.$$('\" + getForm().getMarkupId() + \"')\";\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8469344609,"fo":-0.3333333333,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2857_9fcca2ed","label":1,"code":"public void createTable(String username, String tableName, boolean useVersions, TimeType timeType) {\r\n    MockTable t = new MockTable(useVersions, timeType);\r\n    t.userPermissions.put(username, EnumSet.allOf(TablePermission.class));\r\n    tables.put(tableName, t);\r\n}","code_comment":null,"code_no_comment":"public void createTable(String username, String tableName, boolean useVersions, TimeType timeType) {\r\n    MockTable t = new MockTable(useVersions, timeType);\r\n    t.userPermissions.put(username, EnumSet.allOf(TablePermission.class));\r\n    tables.put(tableName, t);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5520789288,"fo":-0.25,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"\/**\r\n *  Static utility to parse a field of type float from a byte sequence that represents text characters\r\n *  (such as when read from a file stream).\r\n *\r\n *  @param bytes The bytes containing the text data that should be parsed.\r\n *  @param startPos The offset to start the parsing.\r\n *  @param length The length of the byte sequence (counting from the offset).\r\n *\r\n *  @return The parsed value.\r\n *\r\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\r\n *\/\r\npublic static final float parseField(byte[] bytes, int startPos, int length) {\r\n    return parseField(bytes, startPos, length, (char) 0xffff);\r\n}","code_comment":"\/**\r\n *  Static utility to parse a field of type float from a byte sequence that represents text characters\r\n *  (such as when read from a file stream).\r\n *\r\n *  @param bytes The bytes containing the text data that should be parsed.\r\n *  @param startPos The offset to start the parsing.\r\n *  @param length The length of the byte sequence (counting from the offset).\r\n *\r\n *  @return The parsed value.\r\n *\r\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\r\n *\/\r\n","code_no_comment":"public static final float parseField(byte[] bytes, int startPos, int length) {\r\n    return parseField(bytes, startPos, length, (char) 0xffff);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.992670895,"fo":-0.4166666667,"r":1.9210526316,"e":-0.1627934049}
{"project_name":"Lang","project_version":"8","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\r\n    if (zone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\r\n        buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));\r\n    } else {\r\n        buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void appendTo(StringBuffer buffer, Calendar calendar) {\r\n    if (zone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\r\n        buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));\r\n    } else {\r\n        buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0555555556,"mi":0.3020436927,"fo":0.0,"r":0.2105263158,"e":-0.0698074607}
{"project_name":"Lang","project_version":"24","label":1,"code":"\/**\r\n * <p>Checks whether the String a valid Java number.<\/p>\r\n *\r\n * <p>Valid numbers include hexadecimal marked with the <code>0x<\/code>\r\n * qualifier, scientific notation and numbers marked with a type\r\n * qualifier (e.g. 123L).<\/p>\r\n *\r\n * <p><code>Null<\/code> and empty String will return\r\n * <code>false<\/code>.<\/p>\r\n *\r\n * @param str  the <code>String<\/code> to check\r\n * @return <code>true<\/code> if the string is a correctly formatted number\r\n *\/\r\npublic static boolean isNumber(String str) {\r\n    if (StringUtils.isEmpty(str)) {\r\n        return false;\r\n    }\r\n    char[] chars = str.toCharArray();\r\n    int sz = chars.length;\r\n    boolean hasExp = false;\r\n    boolean hasDecPoint = false;\r\n    boolean allowSigns = false;\r\n    boolean foundDigit = false;\r\n    \/\/ deal with any possible sign up front\r\n    int start = (chars[0] == '-') ? 1 : 0;\r\n    if (sz > start + 1) {\r\n        if (chars[start] == '0' && chars[start + 1] == 'x') {\r\n            int i = start + 2;\r\n            if (i == sz) {\r\n                \/\/ str == \"0x\"\r\n                return false;\r\n            }\r\n            \/\/ checking hex (it can't be anything else)\r\n            for (; i < chars.length; i++) {\r\n                if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    \/\/ don't want to loop to the last char, check it afterwords\r\n    sz--;\r\n    \/\/ for type qualifiers\r\n    int i = start;\r\n    \/\/ make a valid number (e.g. chars[0..5] = \"1234E\")\r\n    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\r\n        if (chars[i] >= '0' && chars[i] <= '9') {\r\n            foundDigit = true;\r\n            allowSigns = false;\r\n        } else if (chars[i] == '.') {\r\n            if (hasDecPoint || hasExp) {\r\n                \/\/ two decimal points or dec in exponent\r\n                return false;\r\n            }\r\n            hasDecPoint = true;\r\n        } else if (chars[i] == 'e' || chars[i] == 'E') {\r\n            \/\/ we've already taken care of hex.\r\n            if (hasExp) {\r\n                \/\/ two E's\r\n                return false;\r\n            }\r\n            if (!foundDigit) {\r\n                return false;\r\n            }\r\n            hasExp = true;\r\n            allowSigns = true;\r\n        } else if (chars[i] == '+' || chars[i] == '-') {\r\n            if (!allowSigns) {\r\n                return false;\r\n            }\r\n            allowSigns = false;\r\n            \/\/ we need a digit after the E\r\n            foundDigit = false;\r\n        } else {\r\n            return false;\r\n        }\r\n        i++;\r\n    }\r\n    if (i < chars.length) {\r\n        if (chars[i] >= '0' && chars[i] <= '9') {\r\n            \/\/ no type qualifier, OK\r\n            return true;\r\n        }\r\n        if (chars[i] == 'e' || chars[i] == 'E') {\r\n            \/\/ can't have an E at the last byte\r\n            return false;\r\n        }\r\n        if (chars[i] == '.') {\r\n            if (hasDecPoint || hasExp) {\r\n                \/\/ two decimal points or dec in exponent\r\n                return false;\r\n            }\r\n            \/\/ single trailing decimal point after non-exponent is ok\r\n            return foundDigit;\r\n        }\r\n        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {\r\n            return foundDigit;\r\n        }\r\n        if (chars[i] == 'l' || chars[i] == 'L') {\r\n            \/\/ not allowing L with an exponent or decimal point\r\n            return foundDigit && !hasExp;\r\n        }\r\n        \/\/ last character is illegal\r\n        return false;\r\n    }\r\n    \/\/ found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\r\n    return !allowSigns && foundDigit;\r\n}","code_comment":"\/**\r\n * <p>Checks whether the String a valid Java number.<\/p>\r\n *\r\n * <p>Valid numbers include hexadecimal marked with the <code>0x<\/code>\r\n * qualifier, scientific notation and numbers marked with a type\r\n * qualifier (e.g. 123L).<\/p>\r\n *\r\n * <p><code>Null<\/code> and empty String will return\r\n * <code>false<\/code>.<\/p>\r\n *\r\n * @param str  the <code>String<\/code> to check\r\n * @return <code>true<\/code> if the string is a correctly formatted number\r\n *\/\r\n","code_no_comment":"public static boolean isNumber(String str) {\r\n    if (StringUtils.isEmpty(str)) {\r\n        return false;\r\n    }\r\n    char[] chars = str.toCharArray();\r\n    int sz = chars.length;\r\n    boolean hasExp = false;\r\n    boolean hasDecPoint = false;\r\n    boolean allowSigns = false;\r\n    boolean foundDigit = false;\r\n        int start = (chars[0] == '-') ? 1 : 0;\r\n    if (sz > start + 1) {\r\n        if (chars[start] == '0' && chars[start + 1] == 'x') {\r\n            int i = start + 2;\r\n            if (i == sz) {\r\n                                return false;\r\n            }\r\n                        for (; i < chars.length; i++) {\r\n                if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n        sz--;\r\n        int i = start;\r\n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\r\n        if (chars[i] >= '0' && chars[i] <= '9') {\r\n            foundDigit = true;\r\n            allowSigns = false;\r\n        } else if (chars[i] == '.') {\r\n            if (hasDecPoint || hasExp) {\r\n                                return false;\r\n            }\r\n            hasDecPoint = true;\r\n        } else if (chars[i] == 'e' || chars[i] == 'E') {\r\n                        if (hasExp) {\r\n                                return false;\r\n            }\r\n            if (!foundDigit) {\r\n                return false;\r\n            }\r\n            hasExp = true;\r\n            allowSigns = true;\r\n        } else if (chars[i] == '+' || chars[i] == '-') {\r\n            if (!allowSigns) {\r\n                return false;\r\n            }\r\n            allowSigns = false;\r\n                        foundDigit = false;\r\n        } else {\r\n            return false;\r\n        }\r\n        i++;\r\n    }\r\n    if (i < chars.length) {\r\n        if (chars[i] >= '0' && chars[i] <= '9') {\r\n                        return true;\r\n        }\r\n        if (chars[i] == 'e' || chars[i] == 'E') {\r\n                        return false;\r\n        }\r\n        if (chars[i] == '.') {\r\n            if (hasDecPoint || hasExp) {\r\n                                return false;\r\n            }\r\n                        return foundDigit;\r\n        }\r\n        if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) {\r\n            return foundDigit;\r\n        }\r\n        if (chars[i] == 'l' || chars[i] == 'L') {\r\n                        return foundDigit && !hasExp;\r\n        }\r\n                return false;\r\n    }\r\n        return !allowSigns && foundDigit;\r\n}","lc":2.9545454545,"pi":0.5837320574,"ma":4.0,"nbd":2.0,"ml":4.0833333333,"d":5.3551587302,"mi":-1.2387596899,"fo":-0.3333333333,"r":-0.0263157895,"e":18.9173285386}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"\/**\r\n *  Static utility to parse a field of type byte from a byte sequence that represents text characters\r\n *  (such as when read from a file stream).\r\n *\r\n *  @param bytes The bytes containing the text data that should be parsed.\r\n *  @param startPos The offset to start the parsing.\r\n *  @param length The length of the byte sequence (counting from the offset).\r\n *\r\n *  @return The parsed value.\r\n *\r\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\r\n *\/\r\npublic static final byte parseField(byte[] bytes, int startPos, int length) {\r\n    return parseField(bytes, startPos, length, (char) 0xffff);\r\n}","code_comment":"\/**\r\n *  Static utility to parse a field of type byte from a byte sequence that represents text characters\r\n *  (such as when read from a file stream).\r\n *\r\n *  @param bytes The bytes containing the text data that should be parsed.\r\n *  @param startPos The offset to start the parsing.\r\n *  @param length The length of the byte sequence (counting from the offset).\r\n *\r\n *  @return The parsed value.\r\n *\r\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\r\n *\/\r\n","code_no_comment":"public static final byte parseField(byte[] bytes, int startPos, int length) {\r\n    return parseField(bytes, startPos, length, (char) 0xffff);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.992670895,"fo":-0.4166666667,"r":1.8421052632,"e":-0.1627934049}
{"project_name":"Closure","project_version":"153","label":2,"code":"public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\r\n    \/\/ Don't allow multiple variables to be declared at the top level scope\r\n    if (scope.isGlobal()) {\r\n        Scope.Var origVar = scope.getVar(name);\r\n        Node origParent = origVar.getParentNode();\r\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\r\n            \/\/ Okay, both are 'catch(x)' variables.\r\n            return;\r\n        }\r\n        boolean allowDupe = false;\r\n        JSDocInfo info = n.getJSDocInfo();\r\n        if (info == null) {\r\n            info = parent.getJSDocInfo();\r\n        }\r\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\r\n        if (!allowDupe) {\r\n            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\r\n        }\r\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\r\n        \/\/ Disallow shadowing \"arguments\" as we can't handle with our current\r\n        \/\/ scope modeling.\r\n        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\r\n        if (scope.isGlobal()) {\r\n        Scope.Var origVar = scope.getVar(name);\r\n        Node origParent = origVar.getParentNode();\r\n        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\r\n                        return;\r\n        }\r\n        boolean allowDupe = false;\r\n        JSDocInfo info = n.getJSDocInfo();\r\n        if (info == null) {\r\n            info = parent.getJSDocInfo();\r\n        }\r\n        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\r\n        if (!allowDupe) {\r\n            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\r\n        }\r\n    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\r\n                        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\r\n    }\r\n}","lc":0.2727272727,"pi":0.1244019139,"ma":0.6,"nbd":0.0,"ml":1.0,"d":0.3650793651,"mi":-0.3592670895,"fo":0.8333333333,"r":-0.0263157895,"e":0.7616811604}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1051_25cf3ccd","label":3,"code":"@Override\r\npublic String toString() {\r\n    StringBuilder sb = new StringBuilder();\r\n    String sep = \"\";\r\n    for (ByteSequence auth : auths) {\r\n        sb.append(sep);\r\n        sep = \",\";\r\n        sb.append(new String(auth.toArray()));\r\n    }\r\n    return sb.toString();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String toString() {\r\n    StringBuilder sb = new StringBuilder();\r\n    String sep = \"\";\r\n    for (ByteSequence auth : auths) {\r\n        sb.append(sep);\r\n        sep = \",\";\r\n        sb.append(new String(auth.toArray()));\r\n    }\r\n    return sb.toString();\r\n}","lc":-0.1363636364,"pi":-0.019138756,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.1813953488,"fo":-0.1666666667,"r":0.5789473684,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3965_6051019b","label":1,"code":"\/**\r\n *  Gets a URL for the listener interface (e.g. ILinkListener).\r\n *\r\n *  @see RequestCycle#urlFor(IRequestHandler)\r\n *\r\n *  @param listener\r\n *             The listener interface that the URL should call\r\n *  @return The URL\r\n *\/\r\npublic final CharSequence urlFor(final RequestListenerInterface listener) {\r\n    PageAndComponentProvider provider = new PageAndComponentProvider(getPage(), this);\r\n    IRequestHandler handler;\r\n    if (getPage().isPageStateless()) {\r\n        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener);\r\n    } else {\r\n        handler = new ListenerInterfaceRequestHandler(provider, listener);\r\n    }\r\n    return getRequestCycle().urlFor(handler);\r\n}","code_comment":"\/**\r\n *  Gets a URL for the listener interface (e.g. ILinkListener).\r\n *\r\n *  @see RequestCycle#urlFor(IRequestHandler)\r\n *\r\n *  @param listener\r\n *             The listener interface that the URL should call\r\n *  @return The URL\r\n *\/\r\n","code_no_comment":"public final CharSequence urlFor(final RequestListenerInterface listener) {\r\n    PageAndComponentProvider provider = new PageAndComponentProvider(getPage(), this);\r\n    IRequestHandler handler;\r\n    if (getPage().isPageStateless()) {\r\n        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener);\r\n    } else {\r\n        handler = new ListenerInterfaceRequestHandler(provider, listener);\r\n    }\r\n    return getRequestCycle().urlFor(handler);\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.230162086,"fo":-0.0833333333,"r":0.5263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-370_495f04bc","label":3,"code":"\/**\r\n * Checks that the given array is sorted.\r\n *\r\n * @param val Values\r\n * @param dir Order direction (-1 for decreasing, 1 for increasing)\r\n * @param strict Whether the order should be strict\r\n * @throws NonMonotonousSequenceException if the array is not sorted.\r\n * @deprecated as of 2.2 (please use the new {@link #checkOrder(double[],OrderDirection,boolean)\r\n * checkOrder} method). To be removed in 3.0.\r\n *\/\r\npublic static void checkOrder(double[] val, int dir, boolean strict) {\r\n    if (dir > 0) {\r\n        checkOrder(val, OrderDirection.INCREASING, strict);\r\n    } else {\r\n        checkOrder(val, OrderDirection.DECREASING, strict);\r\n    }\r\n}","code_comment":"\/**\r\n * Checks that the given array is sorted.\r\n *\r\n * @param val Values\r\n * @param dir Order direction (-1 for decreasing, 1 for increasing)\r\n * @param strict Whether the order should be strict\r\n * @throws NonMonotonousSequenceException if the array is not sorted.\r\n * @deprecated as of 2.2 (please use the new {@link #checkOrder(double[],OrderDirection,boolean)\r\n * checkOrder} method). To be removed in 3.0.\r\n *\/\r\n","code_no_comment":"public static void checkOrder(double[] val, int dir, boolean strict) {\r\n    if (dir > 0) {\r\n        checkOrder(val, OrderDirection.INCREASING, strict);\r\n    } else {\r\n        checkOrder(val, OrderDirection.DECREASING, strict);\r\n    }\r\n}","lc":-0.3181818182,"pi":0.014354067,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.4762508809,"fo":-0.3333333333,"r":0.2105263158,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3077_17654199","label":0,"code":"\/**\r\n * For testing purposes only -- should not be called by server code\r\n * <p>\r\n * Allows mocking of a Writer for testing\r\n *\r\n * @param creds\r\n *          Credentials\r\n * @param writer\r\n *          A Writer to use for the given credentials\r\n *\/\r\nprotected static synchronized void addWriter(Credentials creds, Writer writer) {\r\n    writers.put(creds, writer);\r\n}","code_comment":"\/**\r\n * For testing purposes only -- should not be called by server code\r\n * <p>\r\n * Allows mocking of a Writer for testing\r\n *\r\n * @param creds\r\n *          Credentials\r\n * @param writer\r\n *          A Writer to use for the given credentials\r\n *\/\r\n","code_no_comment":"protected static synchronized void addWriter(Credentials creds, Writer writer) {\r\n    writers.put(creds, writer);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9709654686,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"Closure","project_version":"23","label":2,"code":"private Node tryFoldArrayAccess(Node n, Node left, Node right) {\r\n    Node parent = n.getParent();\r\n    \/\/ \"[][0] += 1\"\r\n    if (isAssignmentTarget(n)) {\r\n        return n;\r\n    }\r\n    if (!right.isNumber()) {\r\n        \/\/ arrays, or strings to index into array methods.\r\n        return n;\r\n    }\r\n    double index = right.getDouble();\r\n    int intIndex = (int) index;\r\n    if (intIndex != index) {\r\n        error(INVALID_GETELEM_INDEX_ERROR, right);\r\n        return n;\r\n    }\r\n    if (intIndex < 0) {\r\n        error(INDEX_OUT_OF_BOUNDS_ERROR, right);\r\n        return n;\r\n    }\r\n    Node current = left.getFirstChild();\r\n    Node elem = null;\r\n    for (int i = 0; current != null && i < intIndex; i++) {\r\n        elem = current;\r\n        current = current.getNext();\r\n    }\r\n    if (elem == null) {\r\n        error(INDEX_OUT_OF_BOUNDS_ERROR, right);\r\n        return n;\r\n    }\r\n    if (elem.isEmpty()) {\r\n        elem = NodeUtil.newUndefinedNode(elem);\r\n    } else {\r\n        left.removeChild(elem);\r\n    }\r\n    \/\/ Replace the entire GETELEM with the value\r\n    n.getParent().replaceChild(n, elem);\r\n    reportCodeChange();\r\n    return elem;\r\n}","code_comment":null,"code_no_comment":"private Node tryFoldArrayAccess(Node n, Node left, Node right) {\r\n    Node parent = n.getParent();\r\n        if (isAssignmentTarget(n)) {\r\n        return n;\r\n    }\r\n    if (!right.isNumber()) {\r\n                return n;\r\n    }\r\n    double index = right.getDouble();\r\n    int intIndex = (int) index;\r\n    if (intIndex != index) {\r\n        error(INVALID_GETELEM_INDEX_ERROR, right);\r\n        return n;\r\n    }\r\n    if (intIndex < 0) {\r\n        error(INDEX_OUT_OF_BOUNDS_ERROR, right);\r\n        return n;\r\n    }\r\n    Node current = left.getFirstChild();\r\n    Node elem = null;\r\n    for (int i = 0; current != null && i < intIndex; i++) {\r\n        elem = current;\r\n        current = current.getNext();\r\n    }\r\n    if (elem == null) {\r\n        error(INDEX_OUT_OF_BOUNDS_ERROR, right);\r\n        return n;\r\n    }\r\n    if (elem.isEmpty()) {\r\n        elem = NodeUtil.newUndefinedNode(elem);\r\n    } else {\r\n        left.removeChild(elem);\r\n    }\r\n        n.getParent().replaceChild(n, elem);\r\n    reportCodeChange();\r\n    return elem;\r\n}","lc":1.0454545455,"pi":-0.3732057416,"ma":0.8,"nbd":-0.5,"ml":1.0,"d":1.2162698413,"mi":-0.6298801973,"fo":0.75,"r":-0.0263157895,"e":1.621882978}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-373_bfe4623c","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic double getResult() {\r\n    if (n > 0) {\r\n        return value;\r\n    } else {\r\n        return Double.NaN;\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic double getResult() {\r\n    if (n > 0) {\r\n        return value;\r\n    } else {\r\n        return Double.NaN;\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.5238900634,"fo":-0.5,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6810_6b210169","label":3,"code":"protected Expression createParametersExpression() {\r\n    final int size = parameters.size();\r\n    LOG.trace(\"Creating parameters expression for {} parameters\", size);\r\n    final Expression[] expressions = new Expression[size];\r\n    for (int i = 0; i < size; i++) {\r\n        Expression parameterExpression = parameters.get(i).getExpression();\r\n        expressions[i] = parameterExpression;\r\n        LOG.trace(\"Parameter #{} has expression: {}\", i, parameterExpression);\r\n    }\r\n    return new Expression() {\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        public <T> T evaluate(Exchange exchange, Class<T> type) {\r\n            Object[] answer = new Object[size];\r\n            Object body = exchange.getIn().getBody();\r\n            boolean multiParameterArray = false;\r\n            if (exchange.getIn().getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY) != null) {\r\n                multiParameterArray = exchange.getIn().getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY, Boolean.class);\r\n            }\r\n            \/\/ if there was an explicit method name to invoke, then we should support using\r\n            \/\/ any provided parameter values in the method name\r\n            String methodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, \"\", String.class);\r\n            \/\/ the parameter values is between the parenthesis\r\n            String methodParameters = ObjectHelper.between(methodName, \"(\", \")\");\r\n            \/\/ use an iterator to walk the parameter values\r\n            Iterator<?> it = null;\r\n            if (methodParameters != null) {\r\n                \/\/ split the parameters safely separated by comma, but beware that we can have\r\n                \/\/ quoted parameters which contains comma as well, so do a safe quote split\r\n                String[] parameters = StringQuoteHelper.splitSafeQuote(methodParameters, ',', true);\r\n                it = ObjectHelper.createIterator(parameters, \",\", true);\r\n            }\r\n            \/\/ remove headers as they should not be propagated\r\n            \/\/ we need to do this before the expressions gets evaluated as it may contain\r\n            \/\/ a @Bean expression which would by mistake read these headers. So the headers\r\n            \/\/ must be removed at this point of time\r\n            exchange.getIn().removeHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY);\r\n            exchange.getIn().removeHeader(Exchange.BEAN_METHOD_NAME);\r\n            for (int i = 0; i < size; i++) {\r\n                \/\/ grab the parameter value for the given index\r\n                Object parameterValue = it != null && it.hasNext() ? it.next() : null;\r\n                \/\/ and the expected parameter type\r\n                Class<?> parameterType = parameters.get(i).getType();\r\n                \/\/ the value for the parameter to use\r\n                Object value = null;\r\n                if (multiParameterArray) {\r\n                    \/\/ get the value from the array\r\n                    value = ((Object[]) body)[i];\r\n                } else {\r\n                    \/\/ we should skip * as its a type placeholder to indicate any type\r\n                    if (parameterValue != null && !parameterValue.equals(\"*\")) {\r\n                        \/\/ evaluate the parameter value binding\r\n                        value = evaluateParameterValue(exchange, i, parameterValue, parameterType);\r\n                    }\r\n                    \/\/ use bean parameter binding, if still no value\r\n                    Expression expression = expressions[i];\r\n                    if (value == null && expression != null) {\r\n                        value = evaluateParameterBinding(exchange, expression, i, parameterType);\r\n                    }\r\n                }\r\n                \/\/ remember the value to use\r\n                if (value != Void.TYPE) {\r\n                    answer[i] = value;\r\n                }\r\n            }\r\n            return (T) answer;\r\n        }\r\n\r\n        \/**\r\n         * Evaluate using parameter values where the values can be provided in the method name syntax.\r\n         * <p\/>\r\n         * This methods returns accordingly:\r\n         * <ul>\r\n         *     <li><tt>null<\/tt> - if not a parameter value<\/li>\r\n         *     <li><tt>Void.TYPE<\/tt> - if an explicit null, forcing Camel to pass in <tt>null<\/tt> for that given parameter<\/li>\r\n         *     <li>a non <tt>null<\/tt> value - if the parameter was a parameter value, and to be used<\/li>\r\n         * <\/ul>\r\n         *\r\n         * @since 2.9\r\n         *\/\r\n        private Object evaluateParameterValue(Exchange exchange, int index, Object parameterValue, Class<?> parameterType) {\r\n            Object answer = null;\r\n            \/\/ convert the parameter value to a String\r\n            String exp = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, parameterValue);\r\n            if (exp != null) {\r\n                \/\/ check if its a valid parameter value\r\n                boolean valid = BeanHelper.isValidParameterValue(exp);\r\n                if (!valid) {\r\n                    \/\/ it may be a parameter type instead, and if so, then we should return null,\r\n                    \/\/ as this method is only for evaluating parameter values\r\n                    Boolean isClass = BeanHelper.isAssignableToExpectedType(exchange.getContext().getClassResolver(), exp, parameterType);\r\n                    \/\/ the method will return a non null value if exp is a class\r\n                    if (isClass != null) {\r\n                        return null;\r\n                    }\r\n                }\r\n                \/\/ use simple language to evaluate the expression, as it may use the simple language to refer to message body, headers etc.\r\n                Expression expression = null;\r\n                try {\r\n                    expression = exchange.getContext().resolveLanguage(\"simple\").createExpression(exp);\r\n                    parameterValue = expression.evaluate(exchange, Object.class);\r\n                    \/\/ use \"null\" to indicate the expression returned a null value which is a valid response we need to honor\r\n                    if (parameterValue == null) {\r\n                        parameterValue = \"null\";\r\n                    }\r\n                } catch (Exception e) {\r\n                    throw new ExpressionEvaluationException(expression, \"Cannot create\/evaluate simple expression: \" + exp + \" to be bound to parameter at index: \" + index + \" on method: \" + getMethod(), exchange, e);\r\n                }\r\n                \/\/ see method javadoc for details\r\n                if (\"null\".equals(parameterValue)) {\r\n                    return Void.TYPE;\r\n                }\r\n                \/\/ the parameter value was not already valid, but since the simple language have evaluated the expression\r\n                \/\/ which may change the parameterValue, so we have to check it again to see if its now valid\r\n                exp = exchange.getContext().getTypeConverter().convertTo(String.class, parameterValue);\r\n                \/\/ String values from the simple language is always valid\r\n                if (!valid) {\r\n                    \/\/ re validate if the parameter was not valid the first time (String values should be accepted)\r\n                    valid = parameterValue instanceof String || BeanHelper.isValidParameterValue(exp);\r\n                }\r\n                if (valid) {\r\n                    \/\/ we need to unquote String parameters, as the enclosing quotes is there to denote a parameter value\r\n                    if (parameterValue instanceof String) {\r\n                        parameterValue = StringHelper.removeLeadingAndEndingQuotes((String) parameterValue);\r\n                    }\r\n                    if (parameterValue != null) {\r\n                        try {\r\n                            \/\/ its a valid parameter value, so convert it to the expected type of the parameter\r\n                            answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, exchange, parameterValue);\r\n                            if (LOG.isTraceEnabled()) {\r\n                                LOG.trace(\"Parameter #{} evaluated as: {} type: \", new Object[] { index, answer, ObjectHelper.type(answer) });\r\n                            }\r\n                        } catch (Exception e) {\r\n                            if (LOG.isDebugEnabled()) {\r\n                                LOG.debug(\"Cannot convert from type: {} to type: {} for parameter #{}\", new Object[] { ObjectHelper.type(parameterValue), parameterType, index });\r\n                            }\r\n                            throw new ParameterBindingException(e, method, index, parameterType, parameterValue);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return answer;\r\n        }\r\n\r\n        \/**\r\n         * Evaluate using classic parameter binding using the pre compute expression\r\n         *\/\r\n        private Object evaluateParameterBinding(Exchange exchange, Expression expression, int index, Class<?> parameterType) {\r\n            Object answer = null;\r\n            \/\/ use object first to avoid type conversion so we know if there is a value or not\r\n            Object result = expression.evaluate(exchange, Object.class);\r\n            if (result != null) {\r\n                \/\/ we got a value now try to convert it to the expected type\r\n                try {\r\n                    answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, result);\r\n                    if (LOG.isTraceEnabled()) {\r\n                        LOG.trace(\"Parameter #{} evaluated as: {} type: \", new Object[] { index, answer, ObjectHelper.type(answer) });\r\n                    }\r\n                } catch (NoTypeConversionAvailableException e) {\r\n                    if (LOG.isDebugEnabled()) {\r\n                        LOG.debug(\"Cannot convert from type: {} to type: {} for parameter #{}\", new Object[] { ObjectHelper.type(result), parameterType, index });\r\n                    }\r\n                    throw new ParameterBindingException(e, method, index, parameterType, result);\r\n                }\r\n            } else {\r\n                LOG.trace(\"Parameter #{} evaluated as null\", index);\r\n            }\r\n            return answer;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"ParametersExpression: \" + Arrays.asList(expressions);\r\n        }\r\n    };\r\n}","code_comment":"\/**\r\n * Evaluate using parameter values where the values can be provided in the method name syntax.\r\n * <p\/>\r\n * This methods returns accordingly:\r\n * <ul>\r\n *     <li><tt>null<\/tt> - if not a parameter value<\/li>\r\n *     <li><tt>Void.TYPE<\/tt> - if an explicit null, forcing Camel to pass in <tt>null<\/tt> for that given parameter<\/li>\r\n *     <li>a non <tt>null<\/tt> value - if the parameter was a parameter value, and to be used<\/li>\r\n * <\/ul>\r\n *\r\n * @since 2.9\r\n *\/\r\n\/**\r\n * Evaluate using classic parameter binding using the pre compute expression\r\n *\/\r\n","code_no_comment":"protected Expression createParametersExpression() {\r\n    final int size = parameters.size();\r\n    LOG.trace(\"Creating parameters expression for {} parameters\", size);\r\n    final Expression[] expressions = new Expression[size];\r\n    for (int i = 0; i < size; i++) {\r\n        Expression parameterExpression = parameters.get(i).getExpression();\r\n        expressions[i] = parameterExpression;\r\n        LOG.trace(\"Parameter #{} has expression: {}\", i, parameterExpression);\r\n    }\r\n    return new Expression() {\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        public <T> T evaluate(Exchange exchange, Class<T> type) {\r\n            Object[] answer = new Object[size];\r\n            Object body = exchange.getIn().getBody();\r\n            boolean multiParameterArray = false;\r\n            if (exchange.getIn().getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY) != null) {\r\n                multiParameterArray = exchange.getIn().getHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY, Boolean.class);\r\n            }\r\n                                    String methodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, \"\", String.class);\r\n                        String methodParameters = ObjectHelper.between(methodName, \"(\", \")\");\r\n                        Iterator<?> it = null;\r\n            if (methodParameters != null) {\r\n                                                String[] parameters = StringQuoteHelper.splitSafeQuote(methodParameters, ',', true);\r\n                it = ObjectHelper.createIterator(parameters, \",\", true);\r\n            }\r\n                                                            exchange.getIn().removeHeader(Exchange.BEAN_MULTI_PARAMETER_ARRAY);\r\n            exchange.getIn().removeHeader(Exchange.BEAN_METHOD_NAME);\r\n            for (int i = 0; i < size; i++) {\r\n                                Object parameterValue = it != null && it.hasNext() ? it.next() : null;\r\n                                Class<?> parameterType = parameters.get(i).getType();\r\n                                Object value = null;\r\n                if (multiParameterArray) {\r\n                                        value = ((Object[]) body)[i];\r\n                } else {\r\n                                        if (parameterValue != null && !parameterValue.equals(\"*\")) {\r\n                                                value = evaluateParameterValue(exchange, i, parameterValue, parameterType);\r\n                    }\r\n                                        Expression expression = expressions[i];\r\n                    if (value == null && expression != null) {\r\n                        value = evaluateParameterBinding(exchange, expression, i, parameterType);\r\n                    }\r\n                }\r\n                                if (value != Void.TYPE) {\r\n                    answer[i] = value;\r\n                }\r\n            }\r\n            return (T) answer;\r\n        }\r\n\r\n        \/**\r\n         * Evaluate using parameter values where the values can be provided in the method name syntax.\r\n         * <p\/>\r\n         * This methods returns accordingly:\r\n         * <ul>\r\n         *     <li><tt>null<\/tt> - if not a parameter value<\/li>\r\n         *     <li><tt>Void.TYPE<\/tt> - if an explicit null, forcing Camel to pass in <tt>null<\/tt> for that given parameter<\/li>\r\n         *     <li>a non <tt>null<\/tt> value - if the parameter was a parameter value, and to be used<\/li>\r\n         * <\/ul>\r\n         *\r\n         * @since 2.9\r\n         *\/\r\n        private Object evaluateParameterValue(Exchange exchange, int index, Object parameterValue, Class<?> parameterType) {\r\n            Object answer = null;\r\n                        String exp = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, parameterValue);\r\n            if (exp != null) {\r\n                                boolean valid = BeanHelper.isValidParameterValue(exp);\r\n                if (!valid) {\r\n                                                            Boolean isClass = BeanHelper.isAssignableToExpectedType(exchange.getContext().getClassResolver(), exp, parameterType);\r\n                                        if (isClass != null) {\r\n                        return null;\r\n                    }\r\n                }\r\n                                Expression expression = null;\r\n                try {\r\n                    expression = exchange.getContext().resolveLanguage(\"simple\").createExpression(exp);\r\n                    parameterValue = expression.evaluate(exchange, Object.class);\r\n                                        if (parameterValue == null) {\r\n                        parameterValue = \"null\";\r\n                    }\r\n                } catch (Exception e) {\r\n                    throw new ExpressionEvaluationException(expression, \"Cannot create\/evaluate simple expression: \" + exp + \" to be bound to parameter at index: \" + index + \" on method: \" + getMethod(), exchange, e);\r\n                }\r\n                                if (\"null\".equals(parameterValue)) {\r\n                    return Void.TYPE;\r\n                }\r\n                                                exp = exchange.getContext().getTypeConverter().convertTo(String.class, parameterValue);\r\n                                if (!valid) {\r\n                                        valid = parameterValue instanceof String || BeanHelper.isValidParameterValue(exp);\r\n                }\r\n                if (valid) {\r\n                                        if (parameterValue instanceof String) {\r\n                        parameterValue = StringHelper.removeLeadingAndEndingQuotes((String) parameterValue);\r\n                    }\r\n                    if (parameterValue != null) {\r\n                        try {\r\n                                                        answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, exchange, parameterValue);\r\n                            if (LOG.isTraceEnabled()) {\r\n                                LOG.trace(\"Parameter #{} evaluated as: {} type: \", new Object[] { index, answer, ObjectHelper.type(answer) });\r\n                            }\r\n                        } catch (Exception e) {\r\n                            if (LOG.isDebugEnabled()) {\r\n                                LOG.debug(\"Cannot convert from type: {} to type: {} for parameter #{}\", new Object[] { ObjectHelper.type(parameterValue), parameterType, index });\r\n                            }\r\n                            throw new ParameterBindingException(e, method, index, parameterType, parameterValue);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return answer;\r\n        }\r\n\r\n        \/**\r\n         * Evaluate using classic parameter binding using the pre compute expression\r\n         *\/\r\n        private Object evaluateParameterBinding(Exchange exchange, Expression expression, int index, Class<?> parameterType) {\r\n            Object answer = null;\r\n                        Object result = expression.evaluate(exchange, Object.class);\r\n            if (result != null) {\r\n                                try {\r\n                    answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, result);\r\n                    if (LOG.isTraceEnabled()) {\r\n                        LOG.trace(\"Parameter #{} evaluated as: {} type: \", new Object[] { index, answer, ObjectHelper.type(answer) });\r\n                    }\r\n                } catch (NoTypeConversionAvailableException e) {\r\n                    if (LOG.isDebugEnabled()) {\r\n                        LOG.debug(\"Cannot convert from type: {} to type: {} for parameter #{}\", new Object[] { ObjectHelper.type(result), parameterType, index });\r\n                    }\r\n                    throw new ParameterBindingException(e, method, index, parameterType, result);\r\n                }\r\n            } else {\r\n                LOG.trace(\"Parameter #{} evaluated as null\", index);\r\n            }\r\n            return answer;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"ParametersExpression: \" + Arrays.asList(expressions);\r\n        }\r\n    };\r\n}","lc":5.6363636364,"pi":1.6842105263,"ma":5.2,"nbd":2.0,"ml":3.25,"d":2.5714285714,"mi":-1.6415785765,"fo":5.0,"r":-0.0263157895,"e":20.4549921336}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-546_b6bf8f41","label":3,"code":"\/**\r\n * Use K-means++ to choose the initial centers.\r\n *\r\n * @param <T> type of the points to cluster\r\n * @param points the points to choose the initial centers from\r\n * @param k the number of centers to choose\r\n * @param random random generator to use\r\n * @return the initial centers\r\n *\/\r\nprivate static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\r\n    final List<T> pointSet = new ArrayList<T>(points);\r\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\r\n    \/\/ Choose one center uniformly at random from among the data points.\r\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\r\n    resultSet.add(new Cluster<T>(firstPoint));\r\n    final double[] dx2 = new double[pointSet.size()];\r\n    while (resultSet.size() < k) {\r\n        \/\/ For each data point x, compute D(x), the distance between x and\r\n        \/\/ the nearest center that has already been chosen.\r\n        int sum = 0;\r\n        for (int i = 0; i < pointSet.size(); i++) {\r\n            final T p = pointSet.get(i);\r\n            final Cluster<T> nearest = getNearestCluster(resultSet, p);\r\n            final double d = p.distanceFrom(nearest.getCenter());\r\n            sum += d * d;\r\n            dx2[i] = sum;\r\n        }\r\n        \/\/ Add one new data point as a center. Each point x is chosen with\r\n        \/\/ probability proportional to D(x)2\r\n        final double r = random.nextDouble() * sum;\r\n        for (int i = 0; i < dx2.length; i++) {\r\n            if (dx2[i] >= r) {\r\n                final T p = pointSet.remove(i);\r\n                resultSet.add(new Cluster<T>(p));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return resultSet;\r\n}","code_comment":"\/**\r\n * Use K-means++ to choose the initial centers.\r\n *\r\n * @param <T> type of the points to cluster\r\n * @param points the points to choose the initial centers from\r\n * @param k the number of centers to choose\r\n * @param random random generator to use\r\n * @return the initial centers\r\n *\/\r\n","code_no_comment":"private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\r\n    final List<T> pointSet = new ArrayList<T>(points);\r\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\r\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\r\n    resultSet.add(new Cluster<T>(firstPoint));\r\n    final double[] dx2 = new double[pointSet.size()];\r\n    while (resultSet.size() < k) {\r\n                        int sum = 0;\r\n        for (int i = 0; i < pointSet.size(); i++) {\r\n            final T p = pointSet.get(i);\r\n            final Cluster<T> nearest = getNearestCluster(resultSet, p);\r\n            final double d = p.distanceFrom(nearest.getCenter());\r\n            sum += d * d;\r\n            dx2[i] = sum;\r\n        }\r\n                        final double r = random.nextDouble() * sum;\r\n        for (int i = 0; i < dx2.length; i++) {\r\n            if (dx2[i] >= r) {\r\n                final T p = pointSet.remove(i);\r\n                resultSet.add(new Cluster<T>(p));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return resultSet;\r\n}","lc":0.5454545455,"pi":0.7894736842,"ma":0.4,"nbd":0.5,"ml":0.4166666667,"d":1.4384920635,"mi":-0.49739253,"fo":0.6666666667,"r":-0.0263157895,"e":2.5397831988}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-519_26a61077","label":1,"code":"\/**\r\n * Finds index of point in specified points with the largest Y.\r\n *\r\n * @param points points to search\r\n *\r\n * @return index in specified points array\r\n *\/\r\nprivate int findMaxY(WeightedObservedPoint[] points) {\r\n    int maxYIdx = 0;\r\n    for (int i = 1; i < points.length; i++) {\r\n        if (points[i].getY() > points[maxYIdx].getY()) {\r\n            maxYIdx = i;\r\n        }\r\n    }\r\n    return maxYIdx;\r\n}","code_comment":"\/**\r\n * Finds index of point in specified points with the largest Y.\r\n *\r\n * @param points points to search\r\n *\r\n * @return index in specified points array\r\n *\/\r\n","code_no_comment":"private int findMaxY(WeightedObservedPoint[] points) {\r\n    int maxYIdx = 0;\r\n    for (int i = 1; i < points.length; i++) {\r\n        if (points[i].getY() > points[maxYIdx].getY()) {\r\n            maxYIdx = i;\r\n        }\r\n    }\r\n    return maxYIdx;\r\n}","lc":-0.2272727273,"pi":0.3205741627,"ma":-0.2,"nbd":0.0,"ml":0.0833333333,"d":0.4682539683,"mi":0.2755461593,"fo":-0.3333333333,"r":1.5526315789,"e":0.0362580177}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1155_f64e8adc","label":1,"code":"\/**\r\n * The number of estimated matches. This value might be higher than the\r\n * number of counted matches, if the maximum number of matches has been\r\n * reached. It is based on the average depth of matches, and the average\r\n * number of child nodes.\r\n *\r\n * @return the estimated matches\r\n *\/\r\nint getEstimatedCount() {\r\n    if (count < maxCount) {\r\n        return count;\r\n    }\r\n    double averageDepth = (int) (depthTotal \/ count);\r\n    double averageWidth = 2;\r\n    if (widthCount > 0) {\r\n        averageWidth = (int) (widthTotal \/ widthCount);\r\n    }\r\n    \/\/ calculate with an average width of at least 2\r\n    averageWidth = Math.max(2, averageWidth);\r\n    \/\/ the number of estimated matches is calculated as the\r\n    \/\/ of a estimated\r\n    long estimatedNodes = (long) Math.pow(averageWidth, 2 * averageDepth);\r\n    estimatedNodes = Math.min(estimatedNodes, Integer.MAX_VALUE);\r\n    return Math.max(count, (int) estimatedNodes);\r\n}","code_comment":"\/**\r\n * The number of estimated matches. This value might be higher than the\r\n * number of counted matches, if the maximum number of matches has been\r\n * reached. It is based on the average depth of matches, and the average\r\n * number of child nodes.\r\n *\r\n * @return the estimated matches\r\n *\/\r\n","code_no_comment":"int getEstimatedCount() {\r\n    if (count < maxCount) {\r\n        return count;\r\n    }\r\n    double averageDepth = (int) (depthTotal \/ count);\r\n    double averageWidth = 2;\r\n    if (widthCount > 0) {\r\n        averageWidth = (int) (widthTotal \/ widthCount);\r\n    }\r\n        averageWidth = Math.max(2, averageWidth);\r\n            long estimatedNodes = (long) Math.pow(averageWidth, 2 * averageDepth);\r\n    estimatedNodes = Math.min(estimatedNodes, Integer.MAX_VALUE);\r\n    return Math.max(count, (int) estimatedNodes);\r\n}","lc":0.0,"pi":-0.4066985646,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":0.4285714286,"mi":-0.0325581395,"fo":-0.1666666667,"r":0.0263157895,"e":0.2292837261}
{"project_name":"Math","project_version":"36","label":1,"code":"\/**\r\n * <p>\r\n * Gets the fraction as a <tt>double<\/tt>. This calculates the fraction as\r\n * the numerator divided by denominator.\r\n * <\/p>\r\n *\r\n * @return the fraction as a <tt>double<\/tt>\r\n * @see java.lang.Number#doubleValue()\r\n *\/\r\n@Override\r\npublic double doubleValue() {\r\n    double result = numerator.doubleValue() \/ denominator.doubleValue();\r\n    \/\/ Calculate how far to shift them to put them in range.\r\n    return result;\r\n}","code_comment":"\/**\r\n * <p>\r\n * Gets the fraction as a <tt>double<\/tt>. This calculates the fraction as\r\n * the numerator divided by denominator.\r\n * <\/p>\r\n *\r\n * @return the fraction as a <tt>double<\/tt>\r\n * @see java.lang.Number#doubleValue()\r\n *\/\r\n","code_no_comment":"@Override\r\npublic double doubleValue() {\r\n    double result = numerator.doubleValue() \/ denominator.doubleValue();\r\n        return result;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.0674603175,"mi":0.7237491191,"fo":-0.3333333333,"r":2.4736842105,"e":-0.1399722227}
{"project_name":"JxPath","project_version":"7","label":1,"code":"public Object computeValue(EvalContext context) {\r\n    double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\r\n    double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\r\n    return l > r ? Boolean.TRUE : Boolean.FALSE;\r\n}","code_comment":null,"code_no_comment":"public Object computeValue(EvalContext context) {\r\n    double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\r\n    double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\r\n    return l > r ? Boolean.TRUE : Boolean.FALSE;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.4,"nbd":-1.0,"ml":-0.1666666667,"d":-0.0337301587,"mi":0.5348837209,"fo":-0.1666666667,"r":0.1315789474,"e":-0.0748511725}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2603_77d2d3b0","label":1,"code":"private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision, long oldestRevTimeStamp) {\r\n    List<String> docIdsToDelete = new ArrayList<String>();\r\n    Iterable<NodeDocument> itr = versionStore.getPossiblyDeletedDocs(oldestRevTimeStamp);\r\n    try {\r\n        for (NodeDocument doc : itr) {\r\n            \/\/ So deleting it is safe\r\n            if (doc.getNodeAtRevision(nodeStore, headRevision, null) == null) {\r\n                docIdsToDelete.add(doc.getId());\r\n                \/\/ Collect id of all previous docs also\r\n                for (NodeDocument prevDoc : ImmutableList.copyOf(doc.getAllPreviousDocs())) {\r\n                    docIdsToDelete.add(prevDoc.getId());\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        Utils.closeIfCloseable(itr);\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        StringBuilder sb = new StringBuilder(\"Deleted document with following ids were deleted as part of GC \\n\");\r\n        Joiner.on(StandardSystemProperty.LINE_SEPARATOR.value()).appendTo(sb, docIdsToDelete);\r\n        log.debug(sb.toString());\r\n    }\r\n    nodeStore.getDocumentStore().remove(Collection.NODES, docIdsToDelete);\r\n    nodeStore.invalidateDocChildrenCache();\r\n    stats.deletedDocGCCount += docIdsToDelete.size();\r\n}","code_comment":null,"code_no_comment":"private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision, long oldestRevTimeStamp) {\r\n    List<String> docIdsToDelete = new ArrayList<String>();\r\n    Iterable<NodeDocument> itr = versionStore.getPossiblyDeletedDocs(oldestRevTimeStamp);\r\n    try {\r\n        for (NodeDocument doc : itr) {\r\n                        if (doc.getNodeAtRevision(nodeStore, headRevision, null) == null) {\r\n                docIdsToDelete.add(doc.getId());\r\n                                for (NodeDocument prevDoc : ImmutableList.copyOf(doc.getAllPreviousDocs())) {\r\n                    docIdsToDelete.add(prevDoc.getId());\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        Utils.closeIfCloseable(itr);\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        StringBuilder sb = new StringBuilder(\"Deleted document with following ids were deleted as part of GC \\n\");\r\n        Joiner.on(StandardSystemProperty.LINE_SEPARATOR.value()).appendTo(sb, docIdsToDelete);\r\n        log.debug(sb.toString());\r\n    }\r\n    nodeStore.getDocumentStore().remove(Collection.NODES, docIdsToDelete);\r\n    nodeStore.invalidateDocChildrenCache();\r\n    stats.deletedDocGCCount += docIdsToDelete.size();\r\n}","lc":0.4545454545,"pi":1.0574162679,"ma":0.2,"nbd":1.0,"ml":0.0833333333,"d":-0.0595238095,"mi":-0.4009866103,"fo":1.0833333333,"r":-0.0263157895,"e":0.1557119229}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-795_9453bcfa","label":3,"code":"public static Map<String, String> generateInitialTableProperties() {\r\n    TreeMap<String, String> props = new TreeMap<String, String>();\r\n    for (IteratorScope iterScope : IteratorScope.values()) {\r\n        props.put(Property.TABLE_ITERATOR_PREFIX + iterScope.name() + \".vers\", \"20,\" + VersioningIterator.class.getName());\r\n        props.put(Property.TABLE_ITERATOR_PREFIX + iterScope.name() + \".vers.opt.maxVersions\", \"1\");\r\n    }\r\n    return props;\r\n}","code_comment":null,"code_no_comment":"public static Map<String, String> generateInitialTableProperties() {\r\n    TreeMap<String, String> props = new TreeMap<String, String>();\r\n    for (IteratorScope iterScope : IteratorScope.values()) {\r\n        props.put(Property.TABLE_ITERATOR_PREFIX + iterScope.name() + \".vers\", \"20,\" + VersioningIterator.class.getName());\r\n        props.put(Property.TABLE_ITERATOR_PREFIX + iterScope.name() + \".vers.opt.maxVersions\", \"1\");\r\n    }\r\n    return props;\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":0.0,"mi":0.2611698379,"fo":0.0,"r":-0.0263157895,"e":-0.0173141313}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3383_97f16db4","label":3,"code":"public static FileSystemManager generateVfs() throws FileSystemException {\r\n    DefaultFileSystemManager vfs = new DefaultFileSystemManager();\r\n    vfs.addProvider(\"res\", new org.apache.commons.vfs2.provider.res.ResourceFileProvider());\r\n    vfs.addProvider(\"zip\", new org.apache.commons.vfs2.provider.zip.ZipFileProvider());\r\n    vfs.addProvider(\"gz\", new org.apache.commons.vfs2.provider.gzip.GzipFileProvider());\r\n    vfs.addProvider(\"ram\", new org.apache.commons.vfs2.provider.ram.RamFileProvider());\r\n    vfs.addProvider(\"file\", new org.apache.commons.vfs2.provider.local.DefaultLocalFileProvider());\r\n    vfs.addProvider(\"jar\", new org.apache.commons.vfs2.provider.jar.JarFileProvider());\r\n    vfs.addProvider(\"http\", new org.apache.commons.vfs2.provider.http.HttpFileProvider());\r\n    vfs.addProvider(\"https\", new org.apache.commons.vfs2.provider.https.HttpsFileProvider());\r\n    vfs.addProvider(\"ftp\", new org.apache.commons.vfs2.provider.ftp.FtpFileProvider());\r\n    vfs.addProvider(\"ftps\", new org.apache.commons.vfs2.provider.ftps.FtpsFileProvider());\r\n    vfs.addProvider(\"war\", new org.apache.commons.vfs2.provider.jar.JarFileProvider());\r\n    vfs.addProvider(\"par\", new org.apache.commons.vfs2.provider.jar.JarFileProvider());\r\n    vfs.addProvider(\"ear\", new org.apache.commons.vfs2.provider.jar.JarFileProvider());\r\n    vfs.addProvider(\"sar\", new org.apache.commons.vfs2.provider.jar.JarFileProvider());\r\n    vfs.addProvider(\"ejb3\", new org.apache.commons.vfs2.provider.jar.JarFileProvider());\r\n    vfs.addProvider(\"tmp\", new org.apache.commons.vfs2.provider.temp.TemporaryFileProvider());\r\n    vfs.addProvider(\"tar\", new org.apache.commons.vfs2.provider.tar.TarFileProvider());\r\n    vfs.addProvider(\"tbz2\", new org.apache.commons.vfs2.provider.tar.TarFileProvider());\r\n    vfs.addProvider(\"tgz\", new org.apache.commons.vfs2.provider.tar.TarFileProvider());\r\n    vfs.addProvider(\"bz2\", new org.apache.commons.vfs2.provider.bzip2.Bzip2FileProvider());\r\n    vfs.addProvider(\"hdfs\", new HdfsFileProvider());\r\n    vfs.addExtensionMap(\"jar\", \"jar\");\r\n    vfs.addExtensionMap(\"zip\", \"zip\");\r\n    vfs.addExtensionMap(\"gz\", \"gz\");\r\n    vfs.addExtensionMap(\"tar\", \"tar\");\r\n    vfs.addExtensionMap(\"tbz2\", \"tar\");\r\n    vfs.addExtensionMap(\"tgz\", \"tar\");\r\n    vfs.addExtensionMap(\"bz2\", \"bz2\");\r\n    vfs.addMimeTypeMap(\"application\/x-tar\", \"tar\");\r\n    vfs.addMimeTypeMap(\"application\/x-gzip\", \"gz\");\r\n    vfs.addMimeTypeMap(\"application\/zip\", \"zip\");\r\n    vfs.setFileContentInfoFactory(new FileContentInfoFilenameFactory());\r\n    vfs.setFilesCache(new SoftRefFilesCache());\r\n    String cacheDirPath = AccumuloClassLoader.getAccumuloString(VFS_CACHE_DIR, \"\");\r\n    File cacheDir = computeTopCacheDir();\r\n    if (!cacheDirPath.isEmpty())\r\n        cacheDir = new File(cacheDirPath, \"\" + uniqueDirectoryGenerator.getAndIncrement());\r\n    vfs.setReplicator(new UniqueFileReplicator(cacheDir));\r\n    vfs.setCacheStrategy(CacheStrategy.ON_RESOLVE);\r\n    vfs.init();\r\n    vfsInstances.add(new WeakReference<DefaultFileSystemManager>(vfs));\r\n    return vfs;\r\n}","code_comment":null,"code_no_comment":"public static FileSystemManager generateVfs() throws FileSystemException {\r\n    DefaultFileSystemManager vfs = new DefaultFileSystemManager();\r\n    vfs.addProvider(\"res\", new org.apache.commons.vfs2.provider.res.ResourceFileProvider());\r\n    vfs.addProvider(\"zip\", new org.apache.commons.vfs2.provider.zip.ZipFileProvider());\r\n    vfs.addProvider(\"gz\", new org.apache.commons.vfs2.provider.gzip.GzipFileProvider());\r\n    vfs.addProvider(\"ram\", new org.apache.commons.vfs2.provider.ram.RamFileProvider());\r\n    vfs.addProvider(\"file\", new org.apache.commons.vfs2.provider.local.DefaultLocalFileProvider());\r\n    vfs.addProvider(\"jar\", new org.apache.commons.vfs2.provider.jar.JarFileProvider());\r\n    vfs.addProvider(\"http\", new org.apache.commons.vfs2.provider.http.HttpFileProvider());\r\n    vfs.addProvider(\"https\", new org.apache.commons.vfs2.provider.https.HttpsFileProvider());\r\n    vfs.addProvider(\"ftp\", new org.apache.commons.vfs2.provider.ftp.FtpFileProvider());\r\n    vfs.addProvider(\"ftps\", new org.apache.commons.vfs2.provider.ftps.FtpsFileProvider());\r\n    vfs.addProvider(\"war\", new org.apache.commons.vfs2.provider.jar.JarFileProvider());\r\n    vfs.addProvider(\"par\", new org.apache.commons.vfs2.provider.jar.JarFileProvider());\r\n    vfs.addProvider(\"ear\", new org.apache.commons.vfs2.provider.jar.JarFileProvider());\r\n    vfs.addProvider(\"sar\", new org.apache.commons.vfs2.provider.jar.JarFileProvider());\r\n    vfs.addProvider(\"ejb3\", new org.apache.commons.vfs2.provider.jar.JarFileProvider());\r\n    vfs.addProvider(\"tmp\", new org.apache.commons.vfs2.provider.temp.TemporaryFileProvider());\r\n    vfs.addProvider(\"tar\", new org.apache.commons.vfs2.provider.tar.TarFileProvider());\r\n    vfs.addProvider(\"tbz2\", new org.apache.commons.vfs2.provider.tar.TarFileProvider());\r\n    vfs.addProvider(\"tgz\", new org.apache.commons.vfs2.provider.tar.TarFileProvider());\r\n    vfs.addProvider(\"bz2\", new org.apache.commons.vfs2.provider.bzip2.Bzip2FileProvider());\r\n    vfs.addProvider(\"hdfs\", new HdfsFileProvider());\r\n    vfs.addExtensionMap(\"jar\", \"jar\");\r\n    vfs.addExtensionMap(\"zip\", \"zip\");\r\n    vfs.addExtensionMap(\"gz\", \"gz\");\r\n    vfs.addExtensionMap(\"tar\", \"tar\");\r\n    vfs.addExtensionMap(\"tbz2\", \"tar\");\r\n    vfs.addExtensionMap(\"tgz\", \"tar\");\r\n    vfs.addExtensionMap(\"bz2\", \"bz2\");\r\n    vfs.addMimeTypeMap(\"application\/x-tar\", \"tar\");\r\n    vfs.addMimeTypeMap(\"application\/x-gzip\", \"gz\");\r\n    vfs.addMimeTypeMap(\"application\/zip\", \"zip\");\r\n    vfs.setFileContentInfoFactory(new FileContentInfoFilenameFactory());\r\n    vfs.setFilesCache(new SoftRefFilesCache());\r\n    String cacheDirPath = AccumuloClassLoader.getAccumuloString(VFS_CACHE_DIR, \"\");\r\n    File cacheDir = computeTopCacheDir();\r\n    if (!cacheDirPath.isEmpty())\r\n        cacheDir = new File(cacheDirPath, \"\" + uniqueDirectoryGenerator.getAndIncrement());\r\n    vfs.setReplicator(new UniqueFileReplicator(cacheDir));\r\n    vfs.setCacheStrategy(CacheStrategy.ON_RESOLVE);\r\n    vfs.init();\r\n    vfsInstances.add(new WeakReference<DefaultFileSystemManager>(vfs));\r\n    return vfs;\r\n}","lc":1.4090909091,"pi":-0.9377990431,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":0.3452380952,"mi":-0.8796335447,"fo":2.9166666667,"r":-0.0263157895,"e":2.960379892}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5147_184e51e9","label":1,"code":"\/**\r\n *  @see org.apache.wicket.page.IPageManager#touchPage(org.apache.wicket.page.IManageablePage)\r\n *\/\r\n@Override\r\npublic void touchPage(IManageablePage page) {\r\n    if (!page.isPageStateless()) {\r\n        getContext().bind();\r\n    }\r\n    getRequestAdapter().touch(page);\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.page.IPageManager#touchPage(org.apache.wicket.page.IManageablePage)\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void touchPage(IManageablePage page) {\r\n    if (!page.isPageStateless()) {\r\n        getContext().bind();\r\n    }\r\n    getRequestAdapter().touch(page);\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.5179704017,"fo":-0.0833333333,"r":0.3421052632,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3280_295e73bd","label":1,"code":"\/**\r\n *  @see org.apache.wicket.request.handler.IPageRequestHandler#respond(org.apache.wicket.request.IRequestCycle)\r\n *\/\r\npublic final void respond(final IRequestCycle requestCycle) {\r\n    \/\/ do not increment page id during ajax processing\r\n    boolean frozen = page.setFreezePageId(true);\r\n    try {\r\n        RequestCycle rc = (RequestCycle) requestCycle;\r\n        final WebResponse response = (WebResponse) requestCycle.getResponse();\r\n        if (markupIdToComponent.values().contains(page)) {\r\n            \/\/ the page itself has been added to the request target, we simply issue a redirect\r\n            \/\/ back to the page\r\n            IRequestHandler handler = new RenderPageRequestHandler(new PageProvider(page));\r\n            final String url = rc.urlFor(handler).toString();\r\n            response.sendRedirect(url);\r\n            return;\r\n        }\r\n        for (ITargetRespondListener listener : respondListeners) {\r\n            listener.onTargetRespond(this);\r\n        }\r\n        final Application app = Application.get();\r\n        page.send(app, Broadcast.BREADTH, this);\r\n        \/\/ Determine encoding\r\n        final String encoding = app.getRequestCycleSettings().getResponseRequestEncoding();\r\n        \/\/ Set content type based on markup type for page\r\n        response.setContentType(\"text\/xml; charset=\" + encoding);\r\n        \/\/ Make sure it is not cached by a client\r\n        response.disableCaching();\r\n        response.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\r\n        response.write(encoding);\r\n        response.write(\"\\\"?>\");\r\n        response.write(\"<ajax-response>\");\r\n        \/\/ invoke onbeforerespond event on listeners\r\n        fireOnBeforeRespondListeners();\r\n        \/\/ normal behavior\r\n        Iterator<CharSequence> it = prependJavaScripts.iterator();\r\n        while (it.hasNext()) {\r\n            CharSequence js = it.next();\r\n            respondInvocation(response, js);\r\n        }\r\n        \/\/ process added components\r\n        respondComponents(response);\r\n        fireOnAfterRespondListeners(response);\r\n        \/\/ execute the dom ready javascripts as first javascripts\r\n        \/\/ after component replacement\r\n        it = domReadyJavaScripts.iterator();\r\n        while (it.hasNext()) {\r\n            CharSequence js = it.next();\r\n            respondInvocation(response, js);\r\n        }\r\n        it = appendJavaScripts.iterator();\r\n        while (it.hasNext()) {\r\n            CharSequence js = it.next();\r\n            respondInvocation(response, js);\r\n        }\r\n        response.write(\"<\/ajax-response>\");\r\n    } finally {\r\n        page.setFreezePageId(frozen);\r\n    }\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.request.handler.IPageRequestHandler#respond(org.apache.wicket.request.IRequestCycle)\r\n *\/\r\n","code_no_comment":"public final void respond(final IRequestCycle requestCycle) {\r\n        boolean frozen = page.setFreezePageId(true);\r\n    try {\r\n        RequestCycle rc = (RequestCycle) requestCycle;\r\n        final WebResponse response = (WebResponse) requestCycle.getResponse();\r\n        if (markupIdToComponent.values().contains(page)) {\r\n                                    IRequestHandler handler = new RenderPageRequestHandler(new PageProvider(page));\r\n            final String url = rc.urlFor(handler).toString();\r\n            response.sendRedirect(url);\r\n            return;\r\n        }\r\n        for (ITargetRespondListener listener : respondListeners) {\r\n            listener.onTargetRespond(this);\r\n        }\r\n        final Application app = Application.get();\r\n        page.send(app, Broadcast.BREADTH, this);\r\n                final String encoding = app.getRequestCycleSettings().getResponseRequestEncoding();\r\n                response.setContentType(\"text\/xml; charset=\" + encoding);\r\n                response.disableCaching();\r\n        response.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\r\n        response.write(encoding);\r\n        response.write(\"\\\"?>\");\r\n        response.write(\"<ajax-response>\");\r\n                fireOnBeforeRespondListeners();\r\n                Iterator<CharSequence> it = prependJavaScripts.iterator();\r\n        while (it.hasNext()) {\r\n            CharSequence js = it.next();\r\n            respondInvocation(response, js);\r\n        }\r\n                respondComponents(response);\r\n        fireOnAfterRespondListeners(response);\r\n                        it = domReadyJavaScripts.iterator();\r\n        while (it.hasNext()) {\r\n            CharSequence js = it.next();\r\n            respondInvocation(response, js);\r\n        }\r\n        it = appendJavaScripts.iterator();\r\n        while (it.hasNext()) {\r\n            CharSequence js = it.next();\r\n            respondInvocation(response, js);\r\n        }\r\n        response.write(\"<\/ajax-response>\");\r\n    } finally {\r\n        page.setFreezePageId(frozen);\r\n    }\r\n}","lc":1.4545454545,"pi":-0.0813397129,"ma":0.4,"nbd":0.0,"ml":0.1666666667,"d":0.0357142857,"mi":-0.7902748414,"fo":2.4166666667,"r":-0.0263157895,"e":0.5845565141}
{"project_name":"Time","project_version":"26","label":2,"code":"public long add(long instant, long value) {\r\n    if (iTimeField) {\r\n        int offset = getOffsetToAdd(instant);\r\n        long localInstant = iField.add(instant + offset, value);\r\n        return localInstant - offset;\r\n    } else {\r\n        long localInstant = iZone.convertUTCToLocal(instant);\r\n        localInstant = iField.add(localInstant, value);\r\n        return iZone.convertLocalToUTC(localInstant, false);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public long add(long instant, long value) {\r\n    if (iTimeField) {\r\n        int offset = getOffsetToAdd(instant);\r\n        long localInstant = iField.add(instant + offset, value);\r\n        return localInstant - offset;\r\n    } else {\r\n        long localInstant = iZone.convertUTCToLocal(instant);\r\n        localInstant = iField.add(localInstant, value);\r\n        return iZone.convertLocalToUTC(localInstant, false);\r\n    }\r\n}","lc":-0.1363636364,"pi":0.04784689,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.0773809524,"mi":0.1453136011,"fo":-0.0833333333,"r":0.0263157895,"e":-0.0188078814}
{"project_name":"Closure","project_version":"148","label":2,"code":"private void addCharEntry(String id) throws IOException {\r\n    if (firstChar) {\r\n        firstChar = false;\r\n    } else {\r\n        out.append(\",\");\r\n    }\r\n    out.append(id);\r\n}","code_comment":null,"code_no_comment":"private void addCharEntry(String id) throws IOException {\r\n    if (firstChar) {\r\n        firstChar = false;\r\n    } else {\r\n        out.append(\",\");\r\n    }\r\n    out.append(id);\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.436222692,"fo":-0.3333333333,"r":1.6315789474,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-114_afcf92eb","label":1,"code":"@Override\r\nprotected void validate(String key, String value) {\r\n    if (value.length() > MAX_LENGTH) {\r\n        throw new IllegalArgumentException(\"Structured data values are limited to 32 characters. key: \" + key + \" value: \" + value);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void validate(String key, String value) {\r\n    if (value.length() > MAX_LENGTH) {\r\n        throw new IllegalArgumentException(\"Structured data values are limited to 32 characters. key: \" + key + \" value: \" + value);\r\n    }\r\n}","lc":-0.3636363636,"pi":-0.004784689,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0952380952,"mi":0.5329105004,"fo":-0.4166666667,"r":0.4736842105,"e":-0.1232459098}
{"project_name":"Closure","project_version":"49","label":3,"code":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    switch(n.getType()) {\r\n        case Token.NAME:\r\n            String newName = getReplacementName(n.getString());\r\n            if (newName != null) {\r\n                Renamer renamer = nameStack.peek();\r\n                if (renamer.stripConstIfReplaced()) {\r\n                    \/\/ TODO(johnlenz): Do we need to do anything about the javadoc?\r\n                    n.removeProp(Node.IS_CONSTANT_NAME);\r\n                }\r\n                n.setString(newName);\r\n                t.getCompiler().reportCodeChange();\r\n            }\r\n            break;\r\n        case Token.FUNCTION:\r\n            \/\/ Remove the function body scope\r\n            \/\/ Remove function recursive name (if any).\r\n            nameStack.pop();\r\n            break;\r\n        case Token.CATCH:\r\n            \/\/ Remove catch except name from the stack of names.\r\n            nameStack.pop();\r\n            break;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    switch(n.getType()) {\r\n        case Token.NAME:\r\n            String newName = getReplacementName(n.getString());\r\n            if (newName != null) {\r\n                Renamer renamer = nameStack.peek();\r\n                if (renamer.stripConstIfReplaced()) {\r\n                                        n.removeProp(Node.IS_CONSTANT_NAME);\r\n                }\r\n                n.setString(newName);\r\n                t.getCompiler().reportCodeChange();\r\n            }\r\n            break;\r\n        case Token.FUNCTION:\r\n                                    nameStack.pop();\r\n            break;\r\n        case Token.CATCH:\r\n                        nameStack.pop();\r\n            break;\r\n    }\r\n}","lc":0.3636363636,"pi":1.2535885167,"ma":1.0,"nbd":1.0,"ml":0.25,"d":-0.0634920635,"mi":-0.2913319239,"fo":0.4166666667,"r":0.1052631579,"e":0.0000852913}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_add180fb","label":1,"code":"@Override\r\npublic void setLocalityGroups(String tableName, Map<String, Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void setLocalityGroups(String tableName, Map<String, Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n}","lc":-0.5,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9064129669,"fo":-0.5,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4520_ccb8fc9e","label":1,"code":"@Override\r\npublic Component resolve(final MarkupContainer container, final MarkupStream markupStream, final ComponentTag tag) {\r\n    String inlineEnclosureChildId = getInlineEnclosureAttribute(tag);\r\n    if (Strings.isEmpty(inlineEnclosureChildId) == false) {\r\n        String id = tag.getId();\r\n        if (id.equals(INLINE_ENCLOSURE_ID_PREFIX)) {\r\n            id = id + container.getPage().getAutoIndex();\r\n        }\r\n        \/\/ Yes, we handled the tag\r\n        return new InlineEnclosure(id, inlineEnclosureChildId);\r\n    }\r\n    \/\/ We were not able to handle the tag\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Component resolve(final MarkupContainer container, final MarkupStream markupStream, final ComponentTag tag) {\r\n    String inlineEnclosureChildId = getInlineEnclosureAttribute(tag);\r\n    if (Strings.isEmpty(inlineEnclosureChildId) == false) {\r\n        String id = tag.getId();\r\n        if (id.equals(INLINE_ENCLOSURE_ID_PREFIX)) {\r\n            id = id + container.getPage().getAutoIndex();\r\n        }\r\n                return new InlineEnclosure(id, inlineEnclosureChildId);\r\n    }\r\n        return null;\r\n}","lc":-0.0909090909,"pi":0.3397129187,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":-0.0833333333,"mi":0.0579281184,"fo":0.0,"r":0.3684210526,"e":-0.041675167}
{"project_name":"Cli","project_version":"16","label":3,"code":"public void addOption(Option option) {\r\n    options.add(option);\r\n    nameToOption.put(option.getPreferredName(), option);\r\n    for (Iterator i = option.getTriggers().iterator(); i.hasNext(); ) {\r\n        nameToOption.put(i.next(), option);\r\n    }\r\n\/\/ ensure that all parent options are also added\r\n}","code_comment":null,"code_no_comment":"public void addOption(Option option) {\r\n    options.add(option);\r\n    nameToOption.put(option.getPreferredName(), option);\r\n    for (Iterator i = option.getTriggers().iterator(); i.hasNext(); ) {\r\n        nameToOption.put(i.next(), option);\r\n    }\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.4009866103,"fo":0.1666666667,"r":0.0,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4353_b0014b7d","label":1,"code":"public int getGcGen() {\r\n    return getGcGen(data);\r\n}","code_comment":null,"code_no_comment":"public int getGcGen() {\r\n    return getGcGen(data);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1987315011,"fo":-0.4166666667,"r":2.2631578947,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1106_e2dc384d","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic Optimum optimize(final LeastSquaresProblem problem) {\r\n    \/\/ pull in relevant data from the problem as locals\r\n    \/\/ Number of observed data.\r\n    final int nR = problem.getObservationSize();\r\n    \/\/ Number of parameters.\r\n    final int nC = problem.getParameterSize();\r\n    final double[] currentPoint = problem.getStart().toArray();\r\n    \/\/ counters\r\n    final Incrementor iterationCounter = problem.getIterationCounter();\r\n    final Incrementor evaluationCounter = problem.getEvaluationCounter();\r\n    \/\/ convergence criterion\r\n    final ConvergenceChecker<Evaluation> checker = problem.getConvergenceChecker();\r\n    \/\/ arrays shared with the other private methods\r\n    final int solvedCols = FastMath.min(nR, nC);\r\n    \/* Parameters evolution direction associated with lmPar. *\/\r\n    double[] lmDir = new double[nC];\r\n    \/* Levenberg-Marquardt parameter. *\/\r\n    double lmPar = 0;\r\n    \/\/ local point\r\n    double delta = 0;\r\n    double xNorm = 0;\r\n    double[] diag = new double[nC];\r\n    double[] oldX = new double[nC];\r\n    double[] oldRes = new double[nR];\r\n    double[] qtf = new double[nR];\r\n    double[] work1 = new double[nC];\r\n    double[] work2 = new double[nC];\r\n    double[] work3 = new double[nC];\r\n    \/\/ Evaluate the function at the starting point and calculate its norm.\r\n    evaluationCounter.incrementCount();\r\n    \/\/ value will be reassigned in the loop\r\n    Evaluation current = problem.evaluate(new ArrayRealVector(currentPoint));\r\n    double[] currentResiduals = current.getResiduals().toArray();\r\n    double currentCost = current.getCost();\r\n    \/\/ Outer loop.\r\n    boolean firstIteration = true;\r\n    while (true) {\r\n        iterationCounter.incrementCount();\r\n        final Evaluation previous = current;\r\n        \/\/ QR decomposition of the jacobian matrix\r\n        final InternalData internalData = qrDecomposition(current.getJacobian(), solvedCols);\r\n        final double[][] weightedJacobian = internalData.weightedJacobian;\r\n        final int[] permutation = internalData.permutation;\r\n        final double[] diagR = internalData.diagR;\r\n        final double[] jacNorm = internalData.jacNorm;\r\n        \/\/ residuals already have weights applied\r\n        double[] weightedResidual = currentResiduals;\r\n        for (int i = 0; i < nR; i++) {\r\n            qtf[i] = weightedResidual[i];\r\n        }\r\n        \/\/ compute Qt.res\r\n        qTy(qtf, internalData);\r\n        \/\/ so let jacobian contain the R matrix with its diagonal elements\r\n        for (int k = 0; k < solvedCols; ++k) {\r\n            int pk = permutation[k];\r\n            weightedJacobian[k][pk] = diagR[pk];\r\n        }\r\n        if (firstIteration) {\r\n            \/\/ scale the point according to the norms of the columns\r\n            \/\/ of the initial jacobian\r\n            xNorm = 0;\r\n            for (int k = 0; k < nC; ++k) {\r\n                double dk = jacNorm[k];\r\n                if (dk == 0) {\r\n                    dk = 1.0;\r\n                }\r\n                double xk = dk * currentPoint[k];\r\n                xNorm += xk * xk;\r\n                diag[k] = dk;\r\n            }\r\n            xNorm = FastMath.sqrt(xNorm);\r\n            \/\/ initialize the step bound delta\r\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\r\n        }\r\n        \/\/ check orthogonality between function vector and jacobian columns\r\n        double maxCosine = 0;\r\n        if (currentCost != 0) {\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                double s = jacNorm[pj];\r\n                if (s != 0) {\r\n                    double sum = 0;\r\n                    for (int i = 0; i <= j; ++i) {\r\n                        sum += weightedJacobian[i][pj] * qtf[i];\r\n                    }\r\n                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) \/ (s * currentCost));\r\n                }\r\n            }\r\n        }\r\n        if (maxCosine <= orthoTolerance) {\r\n            \/\/ Convergence has been reached.\r\n            return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());\r\n        }\r\n        \/\/ rescale if necessary\r\n        for (int j = 0; j < nC; ++j) {\r\n            diag[j] = FastMath.max(diag[j], jacNorm[j]);\r\n        }\r\n        \/\/ Inner loop.\r\n        for (double ratio = 0; ratio < 1.0e-4; ) {\r\n            \/\/ save the state\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                oldX[pj] = currentPoint[pj];\r\n            }\r\n            final double previousCost = currentCost;\r\n            double[] tmpVec = weightedResidual;\r\n            weightedResidual = oldRes;\r\n            oldRes = tmpVec;\r\n            \/\/ determine the Levenberg-Marquardt parameter\r\n            lmPar = determineLMParameter(qtf, delta, diag, internalData, solvedCols, work1, work2, work3, lmDir, lmPar);\r\n            \/\/ compute the new point and the norm of the evolution direction\r\n            double lmNorm = 0;\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                lmDir[pj] = -lmDir[pj];\r\n                currentPoint[pj] = oldX[pj] + lmDir[pj];\r\n                double s = diag[pj] * lmDir[pj];\r\n                lmNorm += s * s;\r\n            }\r\n            lmNorm = FastMath.sqrt(lmNorm);\r\n            \/\/ on the first iteration, adjust the initial step bound.\r\n            if (firstIteration) {\r\n                delta = FastMath.min(delta, lmNorm);\r\n            }\r\n            \/\/ Evaluate the function at x + p and calculate its norm.\r\n            evaluationCounter.incrementCount();\r\n            current = problem.evaluate(new ArrayRealVector(currentPoint));\r\n            currentResiduals = current.getResiduals().toArray();\r\n            currentCost = current.getCost();\r\n            \/\/ compute the scaled actual reduction\r\n            double actRed = -1.0;\r\n            if (0.1 * currentCost < previousCost) {\r\n                double r = currentCost \/ previousCost;\r\n                actRed = 1.0 - r * r;\r\n            }\r\n            \/\/ and the scaled directional derivative\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                double dirJ = lmDir[pj];\r\n                work1[j] = 0;\r\n                for (int i = 0; i <= j; ++i) {\r\n                    work1[i] += weightedJacobian[i][pj] * dirJ;\r\n                }\r\n            }\r\n            double coeff1 = 0;\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                coeff1 += work1[j] * work1[j];\r\n            }\r\n            double pc2 = previousCost * previousCost;\r\n            coeff1 \/= pc2;\r\n            double coeff2 = lmPar * lmNorm * lmNorm \/ pc2;\r\n            double preRed = coeff1 + 2 * coeff2;\r\n            double dirDer = -(coeff1 + coeff2);\r\n            \/\/ ratio of the actual to the predicted reduction\r\n            ratio = (preRed == 0) ? 0 : (actRed \/ preRed);\r\n            \/\/ update the step bound\r\n            if (ratio <= 0.25) {\r\n                double tmp = (actRed < 0) ? (0.5 * dirDer \/ (dirDer + 0.5 * actRed)) : 0.5;\r\n                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\r\n                    tmp = 0.1;\r\n                }\r\n                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\r\n                lmPar \/= tmp;\r\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\r\n                delta = 2 * lmNorm;\r\n                lmPar *= 0.5;\r\n            }\r\n            \/\/ test for successful iteration.\r\n            if (ratio >= 1.0e-4) {\r\n                \/\/ successful iteration, update the norm\r\n                firstIteration = false;\r\n                xNorm = 0;\r\n                for (int k = 0; k < nC; ++k) {\r\n                    double xK = diag[k] * currentPoint[k];\r\n                    xNorm += xK * xK;\r\n                }\r\n                xNorm = FastMath.sqrt(xNorm);\r\n                \/\/ tests for convergence.\r\n                if (checker != null && checker.converged(iterationCounter.getCount(), previous, current)) {\r\n                    return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());\r\n                }\r\n            } else {\r\n                \/\/ failed iteration, reset the previous values\r\n                currentCost = previousCost;\r\n                for (int j = 0; j < solvedCols; ++j) {\r\n                    int pj = permutation[j];\r\n                    currentPoint[pj] = oldX[pj];\r\n                }\r\n                tmpVec = weightedResidual;\r\n                weightedResidual = oldRes;\r\n                oldRes = tmpVec;\r\n                \/\/ Reset \"current\" to previous values.\r\n                current = previous;\r\n            }\r\n            \/\/ Default convergence criteria.\r\n            if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {\r\n                return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());\r\n            }\r\n            \/\/ tests for termination and stringent tolerances\r\n            if (FastMath.abs(actRed) <= TWO_EPS && preRed <= TWO_EPS && ratio <= 2.0) {\r\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\r\n            } else if (delta <= TWO_EPS * xNorm) {\r\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\r\n            } else if (maxCosine <= TWO_EPS) {\r\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public Optimum optimize(final LeastSquaresProblem problem) {\r\n            final int nR = problem.getObservationSize();\r\n        final int nC = problem.getParameterSize();\r\n    final double[] currentPoint = problem.getStart().toArray();\r\n        final Incrementor iterationCounter = problem.getIterationCounter();\r\n    final Incrementor evaluationCounter = problem.getEvaluationCounter();\r\n        final ConvergenceChecker<Evaluation> checker = problem.getConvergenceChecker();\r\n        final int solvedCols = FastMath.min(nR, nC);\r\n        double[] lmDir = new double[nC];\r\n        double lmPar = 0;\r\n        double delta = 0;\r\n    double xNorm = 0;\r\n    double[] diag = new double[nC];\r\n    double[] oldX = new double[nC];\r\n    double[] oldRes = new double[nR];\r\n    double[] qtf = new double[nR];\r\n    double[] work1 = new double[nC];\r\n    double[] work2 = new double[nC];\r\n    double[] work3 = new double[nC];\r\n        evaluationCounter.incrementCount();\r\n        Evaluation current = problem.evaluate(new ArrayRealVector(currentPoint));\r\n    double[] currentResiduals = current.getResiduals().toArray();\r\n    double currentCost = current.getCost();\r\n        boolean firstIteration = true;\r\n    while (true) {\r\n        iterationCounter.incrementCount();\r\n        final Evaluation previous = current;\r\n                final InternalData internalData = qrDecomposition(current.getJacobian(), solvedCols);\r\n        final double[][] weightedJacobian = internalData.weightedJacobian;\r\n        final int[] permutation = internalData.permutation;\r\n        final double[] diagR = internalData.diagR;\r\n        final double[] jacNorm = internalData.jacNorm;\r\n                double[] weightedResidual = currentResiduals;\r\n        for (int i = 0; i < nR; i++) {\r\n            qtf[i] = weightedResidual[i];\r\n        }\r\n                qTy(qtf, internalData);\r\n                for (int k = 0; k < solvedCols; ++k) {\r\n            int pk = permutation[k];\r\n            weightedJacobian[k][pk] = diagR[pk];\r\n        }\r\n        if (firstIteration) {\r\n                                    xNorm = 0;\r\n            for (int k = 0; k < nC; ++k) {\r\n                double dk = jacNorm[k];\r\n                if (dk == 0) {\r\n                    dk = 1.0;\r\n                }\r\n                double xk = dk * currentPoint[k];\r\n                xNorm += xk * xk;\r\n                diag[k] = dk;\r\n            }\r\n            xNorm = FastMath.sqrt(xNorm);\r\n                        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\r\n        }\r\n                double maxCosine = 0;\r\n        if (currentCost != 0) {\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                double s = jacNorm[pj];\r\n                if (s != 0) {\r\n                    double sum = 0;\r\n                    for (int i = 0; i <= j; ++i) {\r\n                        sum += weightedJacobian[i][pj] * qtf[i];\r\n                    }\r\n                    maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) \/ (s * currentCost));\r\n                }\r\n            }\r\n        }\r\n        if (maxCosine <= orthoTolerance) {\r\n                        return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());\r\n        }\r\n                for (int j = 0; j < nC; ++j) {\r\n            diag[j] = FastMath.max(diag[j], jacNorm[j]);\r\n        }\r\n                for (double ratio = 0; ratio < 1.0e-4; ) {\r\n                        for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                oldX[pj] = currentPoint[pj];\r\n            }\r\n            final double previousCost = currentCost;\r\n            double[] tmpVec = weightedResidual;\r\n            weightedResidual = oldRes;\r\n            oldRes = tmpVec;\r\n                        lmPar = determineLMParameter(qtf, delta, diag, internalData, solvedCols, work1, work2, work3, lmDir, lmPar);\r\n                        double lmNorm = 0;\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                lmDir[pj] = -lmDir[pj];\r\n                currentPoint[pj] = oldX[pj] + lmDir[pj];\r\n                double s = diag[pj] * lmDir[pj];\r\n                lmNorm += s * s;\r\n            }\r\n            lmNorm = FastMath.sqrt(lmNorm);\r\n                        if (firstIteration) {\r\n                delta = FastMath.min(delta, lmNorm);\r\n            }\r\n                        evaluationCounter.incrementCount();\r\n            current = problem.evaluate(new ArrayRealVector(currentPoint));\r\n            currentResiduals = current.getResiduals().toArray();\r\n            currentCost = current.getCost();\r\n                        double actRed = -1.0;\r\n            if (0.1 * currentCost < previousCost) {\r\n                double r = currentCost \/ previousCost;\r\n                actRed = 1.0 - r * r;\r\n            }\r\n                        for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                double dirJ = lmDir[pj];\r\n                work1[j] = 0;\r\n                for (int i = 0; i <= j; ++i) {\r\n                    work1[i] += weightedJacobian[i][pj] * dirJ;\r\n                }\r\n            }\r\n            double coeff1 = 0;\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                coeff1 += work1[j] * work1[j];\r\n            }\r\n            double pc2 = previousCost * previousCost;\r\n            coeff1 \/= pc2;\r\n            double coeff2 = lmPar * lmNorm * lmNorm \/ pc2;\r\n            double preRed = coeff1 + 2 * coeff2;\r\n            double dirDer = -(coeff1 + coeff2);\r\n                        ratio = (preRed == 0) ? 0 : (actRed \/ preRed);\r\n                        if (ratio <= 0.25) {\r\n                double tmp = (actRed < 0) ? (0.5 * dirDer \/ (dirDer + 0.5 * actRed)) : 0.5;\r\n                if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\r\n                    tmp = 0.1;\r\n                }\r\n                delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\r\n                lmPar \/= tmp;\r\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\r\n                delta = 2 * lmNorm;\r\n                lmPar *= 0.5;\r\n            }\r\n                        if (ratio >= 1.0e-4) {\r\n                                firstIteration = false;\r\n                xNorm = 0;\r\n                for (int k = 0; k < nC; ++k) {\r\n                    double xK = diag[k] * currentPoint[k];\r\n                    xNorm += xK * xK;\r\n                }\r\n                xNorm = FastMath.sqrt(xNorm);\r\n                                if (checker != null && checker.converged(iterationCounter.getCount(), previous, current)) {\r\n                    return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());\r\n                }\r\n            } else {\r\n                                currentCost = previousCost;\r\n                for (int j = 0; j < solvedCols; ++j) {\r\n                    int pj = permutation[j];\r\n                    currentPoint[pj] = oldX[pj];\r\n                }\r\n                tmpVec = weightedResidual;\r\n                weightedResidual = oldRes;\r\n                oldRes = tmpVec;\r\n                                current = previous;\r\n            }\r\n                        if ((FastMath.abs(actRed) <= costRelativeTolerance && preRed <= costRelativeTolerance && ratio <= 2.0) || delta <= parRelativeTolerance * xNorm) {\r\n                return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());\r\n            }\r\n                        if (FastMath.abs(actRed) <= TWO_EPS && preRed <= TWO_EPS && ratio <= 2.0) {\r\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\r\n            } else if (delta <= TWO_EPS * xNorm) {\r\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\r\n            } else if (maxCosine <= TWO_EPS) {\r\n                throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\r\n            }\r\n        }\r\n    }\r\n}","lc":7.0909090909,"pi":0.8899521531,"ma":6.8,"nbd":1.5,"ml":5.4166666667,"d":7.1349206349,"mi":-1.8637068358,"fo":2.9166666667,"r":-0.0263157895,"e":87.6003088928}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-366_db4a291f","label":1,"code":"@Override\r\npublic void write(DataOutput out) throws IOException {\r\n    out.writeUTF(fileSplit.getPath().toString());\r\n    out.writeLong(fileSplit.getStart());\r\n    out.writeLong(fileSplit.getLength());\r\n    String[] hosts = fileSplit.getLocations();\r\n    out.writeInt(hosts.length);\r\n    for (String host : hosts) out.writeUTF(host);\r\n    fileSplit.write(out);\r\n    out.writeInt(partition);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void write(DataOutput out) throws IOException {\r\n    out.writeUTF(fileSplit.getPath().toString());\r\n    out.writeLong(fileSplit.getStart());\r\n    out.writeLong(fileSplit.getLength());\r\n    String[] hosts = fileSplit.getLocations();\r\n    out.writeInt(hosts.length);\r\n    for (String host : hosts) out.writeUTF(host);\r\n    fileSplit.write(out);\r\n    out.writeInt(partition);\r\n}","lc":-0.1363636364,"pi":-0.5789473684,"ma":-0.4,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.11205074,"fo":0.5,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Closure","project_version":"144","label":2,"code":"FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {\r\n    return new FunctionType(registry, null, null, new ArrowType(registry, call.parameters, newReturnType, inferred), typeOfThis, null, false, false);\r\n}","code_comment":null,"code_no_comment":"FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {\r\n    return new FunctionType(registry, null, null, new ArrowType(registry, call.parameters, newReturnType, inferred), typeOfThis, null, false, false);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8384778013,"fo":-0.5,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Cli","project_version":"33","label":1,"code":"\/**\r\n * Print the specified text to the specified PrintWriter.\r\n *\r\n * @param pw The printWriter to write the help to\r\n * @param width The number of characters to display per line\r\n * @param nextLineTabStop The position on the next line for the first tab.\r\n * @param text The text to be written to the PrintWriter\r\n *\/\r\npublic void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text) {\r\n    StringBuffer sb = new StringBuffer(text.length());\r\n    renderWrappedText(sb, width, nextLineTabStop, text);\r\n    pw.println(sb.toString());\r\n}","code_comment":"\/**\r\n * Print the specified text to the specified PrintWriter.\r\n *\r\n * @param pw The printWriter to write the help to\r\n * @param width The number of characters to display per line\r\n * @param nextLineTabStop The position on the next line for the first tab.\r\n * @param text The text to be written to the PrintWriter\r\n *\/\r\n","code_no_comment":"public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text) {\r\n    StringBuffer sb = new StringBuffer(text.length());\r\n    renderWrappedText(sb, width, nextLineTabStop, text);\r\n    pw.println(sb.toString());\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5768851304,"fo":-0.1666666667,"r":0.4210526316,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2621_c849f986","label":1,"code":"\/**\r\n *  Set to true to use enctype='multipart\/form-data', and to process file uploads by default\r\n *  multiPart = false\r\n *\r\n *  @param multiPart\r\n *             whether this form should behave as a multipart form\r\n *\/\r\npublic void setMultiPart(boolean multiPart) {\r\n    this.multiPart = multiPart;\r\n}","code_comment":"\/**\r\n *  Set to true to use enctype='multipart\/form-data', and to process file uploads by default\r\n *  multiPart = false\r\n *\r\n *  @param multiPart\r\n *             whether this form should behave as a multipart form\r\n *\/\r\n","code_no_comment":"public void setMultiPart(boolean multiPart) {\r\n    this.multiPart = multiPart;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1051444679,"fo":-0.5,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1640_8f321c72","label":1,"code":"\/**\r\n *  Checks if the provided path string is either null or has zero length and throws\r\n *  a {@link IllegalArgumentException} if any of the two conditions apply.\r\n *\r\n *  @param path\r\n *         the path string to be checked\r\n *\/\r\nprivate void checkPathArg(String path) {\r\n    \/\/ disallow construction of a Path from an empty string\r\n    if (path == null) {\r\n        throw new IllegalArgumentException(\"Can not create a Path from a null string\");\r\n    }\r\n    if (path.length() == 0) {\r\n        throw new IllegalArgumentException(\"Can not create a Path from an empty string\");\r\n    }\r\n}","code_comment":"\/**\r\n *  Checks if the provided path string is either null or has zero length and throws\r\n *  a {@link IllegalArgumentException} if any of the two conditions apply.\r\n *\r\n *  @param path\r\n *         the path string to be checked\r\n *\/\r\n","code_no_comment":"private void checkPathArg(String path) {\r\n        if (path == null) {\r\n        throw new IllegalArgumentException(\"Can not create a Path from a null string\");\r\n    }\r\n    if (path.length() == 0) {\r\n        throw new IllegalArgumentException(\"Can not create a Path from an empty string\");\r\n    }\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.4167723749,"fo":-0.4166666667,"r":2.3947368421,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-612_df9e6913","label":1,"code":"private void internalSetPrimaryType(final String nodeTypeName) throws RepositoryException {\r\n    sessionDelegate.perform(new SessionOperation<Void>() {\r\n\r\n        @Override\r\n        public Void perform() throws RepositoryException {\r\n            \/\/ TODO: figure out the right place for this check\r\n            NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();\r\n            \/\/ throws on not found\r\n            NodeType nt = ntm.getNodeType(nodeTypeName);\r\n            if (nt.isAbstract() || nt.isMixin()) {\r\n                throw new ConstraintViolationException();\r\n            }\r\n            \/\/ TODO: END\r\n            String jcrPrimaryType = sessionDelegate.getOakPath(Property.JCR_PRIMARY_TYPE);\r\n            Value value = sessionDelegate.getValueFactory().createValue(nodeTypeName, PropertyType.NAME);\r\n            dlg.setProperty(jcrPrimaryType, value);\r\n            return null;\r\n        }\r\n    });\r\n}","code_comment":null,"code_no_comment":"private void internalSetPrimaryType(final String nodeTypeName) throws RepositoryException {\r\n    sessionDelegate.perform(new SessionOperation<Void>() {\r\n\r\n        @Override\r\n        public Void perform() throws RepositoryException {\r\n                        NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();\r\n                        NodeType nt = ntm.getNodeType(nodeTypeName);\r\n            if (nt.isAbstract() || nt.isMixin()) {\r\n                throw new ConstraintViolationException();\r\n            }\r\n                        String jcrPrimaryType = sessionDelegate.getOakPath(Property.JCR_PRIMARY_TYPE);\r\n            Value value = sessionDelegate.getValueFactory().createValue(nodeTypeName, PropertyType.NAME);\r\n            dlg.setProperty(jcrPrimaryType, value);\r\n            return null;\r\n        }\r\n    });\r\n}","lc":0.0909090909,"pi":0.7607655502,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0793650794,"mi":-0.1227625088,"fo":0.25,"r":0.0789473684,"e":0.0091584401}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"\/**\r\n * Copy this tree to the parent at {@code destParent} with the name {@code destName}.\r\n *\r\n * @param destParent  parent for the copied tree\r\n * @param destName  name for the copied tree\r\n * @return  {@code true} if successful, {@code false otherwise}. I.e.\r\n * when {@code destName} already exists at {@code destParent}\r\n *\/\r\npublic boolean copy(TreeImpl destParent, String destName) {\r\n    boolean result = builder.copyTo(destParent.builder, destName);\r\n    if (result) {\r\n        if (listener != null) {\r\n            listener.copy(parent, name, destParent.getChild(destName));\r\n        }\r\n        return true;\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n * Copy this tree to the parent at {@code destParent} with the name {@code destName}.\r\n *\r\n * @param destParent  parent for the copied tree\r\n * @param destName  name for the copied tree\r\n * @return  {@code true} if successful, {@code false otherwise}. I.e.\r\n * when {@code destName} already exists at {@code destParent}\r\n *\/\r\n","code_no_comment":"public boolean copy(TreeImpl destParent, String destName) {\r\n    boolean result = builder.copyTo(destParent.builder, destName);\r\n    if (result) {\r\n        if (listener != null) {\r\n            listener.copy(parent, name, destParent.getChild(destName));\r\n        }\r\n        return true;\r\n    }\r\n    return result;\r\n}","lc":-0.1818181818,"pi":0.2918660287,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0476190476,"mi":0.2225510923,"fo":-0.25,"r":0.0789473684,"e":-0.0843991863}
{"project_name":"Lang","project_version":"16","label":1,"code":"\/\/ -----------------------------------------------------------------------\r\n\/\/ must handle Long, Float, Integer, Float, Short,\r\n\/\/ BigDecimal, BigInteger and Byte\r\n\/\/ useful methods:\r\n\/\/ Byte.decode(String)\r\n\/\/ Byte.valueOf(String,int radix)\r\n\/\/ Byte.valueOf(String)\r\n\/\/ Double.valueOf(String)\r\n\/\/ Float.valueOf(String)\r\n\/\/ Float.valueOf(String)\r\n\/\/ Integer.valueOf(String,int radix)\r\n\/\/ Integer.valueOf(String)\r\n\/\/ Integer.decode(String)\r\n\/\/ Integer.getInteger(String)\r\n\/\/ Integer.getInteger(String,int val)\r\n\/\/ Integer.getInteger(String,Integer val)\r\n\/\/ Integer.valueOf(String)\r\n\/\/ Double.valueOf(String)\r\n\/\/ new Byte(String)\r\n\/\/ Long.valueOf(String)\r\n\/\/ Long.getLong(String)\r\n\/\/ Long.getLong(String,int)\r\n\/\/ Long.getLong(String,Integer)\r\n\/\/ Long.valueOf(String,int)\r\n\/\/ Long.valueOf(String)\r\n\/\/ Short.valueOf(String)\r\n\/\/ Short.decode(String)\r\n\/\/ Short.valueOf(String,int)\r\n\/\/ Short.valueOf(String)\r\n\/\/ new BigDecimal(String)\r\n\/\/ new BigInteger(String)\r\n\/\/ new BigInteger(String,int radix)\r\n\/\/ Possible inputs:\r\n\/\/ 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\r\n\/\/ plus minus everything. Prolly more. A lot are not separable.\r\n\/**\r\n * <p>Turns a string value into a java.lang.Number.<\/p>\r\n *\r\n * <p>First, the value is examined for a type qualifier on the end\r\n * (<code>'f','F','d','D','l','L'<\/code>).  If it is found, it starts\r\n * trying to create successively larger types from the type specified\r\n * until one is found that can represent the value.<\/p>\r\n *\r\n * <p>If a type specifier is not found, it will check for a decimal point\r\n * and then try successively larger types from <code>Integer<\/code> to\r\n * <code>BigInteger<\/code> and from <code>Float<\/code> to\r\n * <code>BigDecimal<\/code>.<\/p>\r\n *\r\n * <p>If the string starts with <code>0x<\/code> or <code>-0x<\/code> (lower or upper case), it\r\n * will be interpreted as a hexadecimal integer.  Values with leading\r\n * <code>0<\/code>'s will not be interpreted as octal.<\/p>\r\n *\r\n * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\r\n *\r\n * <p>This method does not trim the input string, i.e., strings with leading\r\n * or trailing spaces will generate NumberFormatExceptions.<\/p>\r\n *\r\n * @param str  String containing a number, may be null\r\n * @return Number created from the string (or null if the input is null)\r\n * @throws NumberFormatException if the value cannot be converted\r\n *\/\r\npublic static Number createNumber(String str) throws NumberFormatException {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    if (StringUtils.isBlank(str)) {\r\n        throw new NumberFormatException(\"A blank string is not a valid number\");\r\n    }\r\n    if (str.startsWith(\"--\")) {\r\n        \/\/ a wrong value.\r\n        return null;\r\n    }\r\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\r\n        return createInteger(str);\r\n    }\r\n    char lastChar = str.charAt(str.length() - 1);\r\n    String mant;\r\n    String dec;\r\n    String exp;\r\n    int decPos = str.indexOf('.');\r\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\r\n    if (decPos > -1) {\r\n        if (expPos > -1) {\r\n            if (expPos < decPos || expPos > str.length()) {\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            }\r\n            dec = str.substring(decPos + 1, expPos);\r\n        } else {\r\n            dec = str.substring(decPos + 1);\r\n        }\r\n        mant = str.substring(0, decPos);\r\n    } else {\r\n        if (expPos > -1) {\r\n            if (expPos > str.length()) {\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            }\r\n            mant = str.substring(0, expPos);\r\n        } else {\r\n            mant = str;\r\n        }\r\n        dec = null;\r\n    }\r\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\r\n        if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length() - 1);\r\n        } else {\r\n            exp = null;\r\n        }\r\n        \/\/ Requesting a specific type..\r\n        String numeric = str.substring(0, str.length() - 1);\r\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n        switch(lastChar) {\r\n            case 'l':\r\n            case 'L':\r\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\r\n                    try {\r\n                        return createLong(numeric);\r\n                    } catch (NumberFormatException nfe) {\r\n                    \/\/ NOPMD\r\n                    \/\/ Too big for a long\r\n                    }\r\n                    return createBigInteger(numeric);\r\n                }\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            case 'f':\r\n            case 'F':\r\n                try {\r\n                    Float f = NumberUtils.createFloat(numeric);\r\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                        \/\/ has non-zeros in it, then float does not have the precision we want\r\n                        return f;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                \/\/ NOPMD\r\n                \/\/ ignore the bad number\r\n                }\r\n            \/\/ $FALL-THROUGH$\r\n            case 'd':\r\n            case 'D':\r\n                try {\r\n                    Double d = NumberUtils.createDouble(numeric);\r\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\r\n                        return d;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                \/\/ NOPMD\r\n                \/\/ ignore the bad number\r\n                }\r\n                try {\r\n                    return createBigDecimal(numeric);\r\n                } catch (NumberFormatException e) {\r\n                \/\/ NOPMD\r\n                \/\/ ignore the bad number\r\n                }\r\n            \/\/ $FALL-THROUGH$\r\n            default:\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n        }\r\n    } else {\r\n        \/\/ small and go from there...\r\n        if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length());\r\n        } else {\r\n            exp = null;\r\n        }\r\n        if (dec == null && exp == null) {\r\n            \/\/ Must be an int,long,bigint\r\n            try {\r\n                return createInteger(str);\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ NOPMD\r\n            \/\/ ignore the bad number\r\n            }\r\n            try {\r\n                return createLong(str);\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ NOPMD\r\n            \/\/ ignore the bad number\r\n            }\r\n            return createBigInteger(str);\r\n        } else {\r\n            \/\/ Must be a float,double,BigDec\r\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n            try {\r\n                Float f = createFloat(str);\r\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                    return f;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ NOPMD\r\n            \/\/ ignore the bad number\r\n            }\r\n            try {\r\n                Double d = createDouble(str);\r\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\r\n                    return d;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ NOPMD\r\n            \/\/ ignore the bad number\r\n            }\r\n            return createBigDecimal(str);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * <p>Turns a string value into a java.lang.Number.<\/p>\r\n *\r\n * <p>First, the value is examined for a type qualifier on the end\r\n * (<code>'f','F','d','D','l','L'<\/code>).  If it is found, it starts\r\n * trying to create successively larger types from the type specified\r\n * until one is found that can represent the value.<\/p>\r\n *\r\n * <p>If a type specifier is not found, it will check for a decimal point\r\n * and then try successively larger types from <code>Integer<\/code> to\r\n * <code>BigInteger<\/code> and from <code>Float<\/code> to\r\n * <code>BigDecimal<\/code>.<\/p>\r\n *\r\n * <p>If the string starts with <code>0x<\/code> or <code>-0x<\/code> (lower or upper case), it\r\n * will be interpreted as a hexadecimal integer.  Values with leading\r\n * <code>0<\/code>'s will not be interpreted as octal.<\/p>\r\n *\r\n * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\r\n *\r\n * <p>This method does not trim the input string, i.e., strings with leading\r\n * or trailing spaces will generate NumberFormatExceptions.<\/p>\r\n *\r\n * @param str  String containing a number, may be null\r\n * @return Number created from the string (or null if the input is null)\r\n * @throws NumberFormatException if the value cannot be converted\r\n *\/\r\n","code_no_comment":"public static Number createNumber(String str) throws NumberFormatException {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    if (StringUtils.isBlank(str)) {\r\n        throw new NumberFormatException(\"A blank string is not a valid number\");\r\n    }\r\n    if (str.startsWith(\"--\")) {\r\n                return null;\r\n    }\r\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\r\n        return createInteger(str);\r\n    }\r\n    char lastChar = str.charAt(str.length() - 1);\r\n    String mant;\r\n    String dec;\r\n    String exp;\r\n    int decPos = str.indexOf('.');\r\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\r\n    if (decPos > -1) {\r\n        if (expPos > -1) {\r\n            if (expPos < decPos || expPos > str.length()) {\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            }\r\n            dec = str.substring(decPos + 1, expPos);\r\n        } else {\r\n            dec = str.substring(decPos + 1);\r\n        }\r\n        mant = str.substring(0, decPos);\r\n    } else {\r\n        if (expPos > -1) {\r\n            if (expPos > str.length()) {\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            }\r\n            mant = str.substring(0, expPos);\r\n        } else {\r\n            mant = str;\r\n        }\r\n        dec = null;\r\n    }\r\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\r\n        if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length() - 1);\r\n        } else {\r\n            exp = null;\r\n        }\r\n                String numeric = str.substring(0, str.length() - 1);\r\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n        switch(lastChar) {\r\n            case 'l':\r\n            case 'L':\r\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\r\n                    try {\r\n                        return createLong(numeric);\r\n                    } catch (NumberFormatException nfe) {\r\n                                                            }\r\n                    return createBigInteger(numeric);\r\n                }\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            case 'f':\r\n            case 'F':\r\n                try {\r\n                    Float f = NumberUtils.createFloat(numeric);\r\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                                                return f;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                                                }\r\n                        case 'd':\r\n            case 'D':\r\n                try {\r\n                    Double d = NumberUtils.createDouble(numeric);\r\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\r\n                        return d;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                                                }\r\n                try {\r\n                    return createBigDecimal(numeric);\r\n                } catch (NumberFormatException e) {\r\n                                                }\r\n                        default:\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n        }\r\n    } else {\r\n                if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length());\r\n        } else {\r\n            exp = null;\r\n        }\r\n        if (dec == null && exp == null) {\r\n                        try {\r\n                return createInteger(str);\r\n            } catch (NumberFormatException nfe) {\r\n                                    }\r\n            try {\r\n                return createLong(str);\r\n            } catch (NumberFormatException nfe) {\r\n                                    }\r\n            return createBigInteger(str);\r\n        } else {\r\n                        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n            try {\r\n                Float f = createFloat(str);\r\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                    return f;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n                                    }\r\n            try {\r\n                Double d = createDouble(str);\r\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\r\n                    return d;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n                                    }\r\n            return createBigDecimal(str);\r\n        }\r\n    }\r\n}","lc":4.8181818182,"pi":1.1818181818,"ma":7.0,"nbd":1.5,"ml":5.0,"d":4.0138888889,"mi":-1.5829457364,"fo":3.8333333333,"r":-0.0263157895,"e":21.2055231871}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-373_bfe4623c","label":1,"code":"\/**\r\n * Returns the product of the entries in the specified portion of\r\n * the input array, or <code>Double.NaN<\/code> if the designated subarray\r\n * is empty.\r\n * <p>\r\n * Throws <code>IllegalArgumentException<\/code> if the array is null.<\/p>\r\n *\r\n * @param values the input array\r\n * @param begin index of the first array element to include\r\n * @param length the number of elements to include\r\n * @return the product of the values or Double.NaN if length = 0\r\n * @throws IllegalArgumentException if the array is null or the array index\r\n *  parameters are not valid\r\n *\/\r\n@Override\r\npublic double evaluate(final double[] values, final int begin, final int length) {\r\n    double product = Double.NaN;\r\n    if (test(values, begin, length)) {\r\n        product = 1.0;\r\n        for (int i = begin; i < begin + length; i++) {\r\n            product *= values[i];\r\n        }\r\n    }\r\n    return product;\r\n}","code_comment":"\/**\r\n * Returns the product of the entries in the specified portion of\r\n * the input array, or <code>Double.NaN<\/code> if the designated subarray\r\n * is empty.\r\n * <p>\r\n * Throws <code>IllegalArgumentException<\/code> if the array is null.<\/p>\r\n *\r\n * @param values the input array\r\n * @param begin index of the first array element to include\r\n * @param length the number of elements to include\r\n * @return the product of the values or Double.NaN if length = 0\r\n * @throws IllegalArgumentException if the array is null or the array index\r\n *  parameters are not valid\r\n *\/\r\n","code_no_comment":"@Override\r\npublic double evaluate(final double[] values, final int begin, final int length) {\r\n    double product = Double.NaN;\r\n    if (test(values, begin, length)) {\r\n        product = 1.0;\r\n        for (int i = begin; i < begin + length; i++) {\r\n            product *= values[i];\r\n        }\r\n    }\r\n    return product;\r\n}","lc":-0.1363636364,"pi":0.3588516746,"ma":-0.2,"nbd":0.0,"ml":0.1666666667,"d":0.4623015873,"mi":0.148696265,"fo":-0.4166666667,"r":0.0,"e":0.0884701164}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1297_73cc2442","label":1,"code":"protected static void annotateSourcePath(NodeBuilder builder, String path) {\r\n    PropertyState base = builder.getBaseState().getProperty(MoveDetector.SOURCE_PATH);\r\n    PropertyState head = builder.getNodeState().getProperty(MoveDetector.SOURCE_PATH);\r\n    if (Objects.equal(base, head)) {\r\n        if (!builder.hasProperty(MoveDetector.SOURCE_PATH)) {\r\n            builder.setProperty(MoveDetector.SOURCE_PATH, path);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"protected static void annotateSourcePath(NodeBuilder builder, String path) {\r\n    PropertyState base = builder.getBaseState().getProperty(MoveDetector.SOURCE_PATH);\r\n    PropertyState head = builder.getNodeState().getProperty(MoveDetector.SOURCE_PATH);\r\n    if (Objects.equal(base, head)) {\r\n        if (!builder.hasProperty(MoveDetector.SOURCE_PATH)) {\r\n            builder.setProperty(MoveDetector.SOURCE_PATH, path);\r\n        }\r\n    }\r\n}","lc":-0.2272727273,"pi":0.3205741627,"ma":-0.2,"nbd":0.0,"ml":0.0833333333,"d":-0.001984127,"mi":0.2149400987,"fo":0.0833333333,"r":-0.0263157895,"e":-0.031283461}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-614_6feacf6b","label":1,"code":"@Nonnull\r\nprivate MutableNodeState write(long newRevision, boolean skipRemovedCheck) {\r\n    \/\/ make sure that all revision numbers up to the root gets updated\r\n    if (!isRoot()) {\r\n        checkState(skipRemovedCheck || !removed());\r\n        parent.write(newRevision, skipRemovedCheck);\r\n    }\r\n    if (writeState == null || revision != root.revision) {\r\n        \/\/ root never gets here since revision == root.revision\r\n        assert (!isRoot());\r\n        \/\/ The builder could have been reset, need to re-get base state\r\n        baseState = parent.getBaseState(name);\r\n        writeState = parent.getWriteState(name);\r\n        if (writeState == null) {\r\n            if (removed()) {\r\n                writeState = new MutableNodeState(null);\r\n            } else {\r\n                writeState = new MutableNodeState(baseState);\r\n            }\r\n            \/\/ guaranteed by called parent.write()\r\n            assert parent.writeState != null;\r\n            parent.writeState.nodes.put(name, writeState);\r\n        }\r\n    }\r\n    revision = newRevision;\r\n    assert classInvariants();\r\n    assert writeState != null;\r\n    return writeState;\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\nprivate MutableNodeState write(long newRevision, boolean skipRemovedCheck) {\r\n        if (!isRoot()) {\r\n        checkState(skipRemovedCheck || !removed());\r\n        parent.write(newRevision, skipRemovedCheck);\r\n    }\r\n    if (writeState == null || revision != root.revision) {\r\n                assert (!isRoot());\r\n                baseState = parent.getBaseState(name);\r\n        writeState = parent.getWriteState(name);\r\n        if (writeState == null) {\r\n            if (removed()) {\r\n                writeState = new MutableNodeState(null);\r\n            } else {\r\n                writeState = new MutableNodeState(baseState);\r\n            }\r\n                        assert parent.writeState != null;\r\n            parent.writeState.nodes.put(name, writeState);\r\n        }\r\n    }\r\n    revision = newRevision;\r\n    assert classInvariants();\r\n    assert writeState != null;\r\n    return writeState;\r\n}","lc":0.5,"pi":0.7368421053,"ma":0.2,"nbd":0.5,"ml":0.4166666667,"d":-0.3650793651,"mi":0.0734319944,"fo":0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3760_5225e6e3","label":3,"code":"public ObjectName getObjectNameForThreadPool(CamelContext context, ThreadPoolExecutor threadPool, String id, String sourceId) throws MalformedObjectNameException {\r\n    StringBuilder buffer = new StringBuilder();\r\n    buffer.append(domainName).append(\":\");\r\n    buffer.append(KEY_CONTEXT + \"=\").append(getContextId(context)).append(\",\");\r\n    buffer.append(KEY_TYPE + \"=\" + TYPE_THREAD_POOL + \",\");\r\n    buffer.append(KEY_NAME + \"=\").append(id);\r\n    if (sourceId != null) {\r\n        \/\/ provide source id if we know it, this helps end user to know where the pool is used\r\n        buffer.append(\"(\").append(sourceId).append(\")\");\r\n    }\r\n    return createObjectName(buffer);\r\n}","code_comment":null,"code_no_comment":"public ObjectName getObjectNameForThreadPool(CamelContext context, ThreadPoolExecutor threadPool, String id, String sourceId) throws MalformedObjectNameException {\r\n    StringBuilder buffer = new StringBuilder();\r\n    buffer.append(domainName).append(\":\");\r\n    buffer.append(KEY_CONTEXT + \"=\").append(getContextId(context)).append(\",\");\r\n    buffer.append(KEY_TYPE + \"=\" + TYPE_THREAD_POOL + \",\");\r\n    buffer.append(KEY_NAME + \"=\").append(id);\r\n    if (sourceId != null) {\r\n                buffer.append(\"(\").append(sourceId).append(\")\");\r\n    }\r\n    return createObjectName(buffer);\r\n}","lc":-0.1363636364,"pi":-0.4449760766,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.0178571429,"mi":0.0438336857,"fo":0.5833333333,"r":-0.0263157895,"e":0.0855517712}
{"project_name":"Closure","project_version":"142","label":2,"code":"\/**\r\n * Extracts the text found on the current line and all subsequent\r\n * until either an annotation, end of comment or end of file is reached.\r\n * Note that if this method detects an end of line as the first token, it\r\n * will quit immediately (indicating that there is no text where it was\r\n * expected).  Note that token = info.token; should be called after this\r\n * method is used to update the token properly in the parser.\r\n *\r\n * @param token The start token.\r\n * @param option How to handle whitespace.\r\n *\r\n * @return The extraction information.\r\n *\/\r\n@SuppressWarnings(\"fallthrough\")\r\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\r\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\r\n        return new ExtractionInfo(\"\", token);\r\n    }\r\n    stream.update();\r\n    int startLineno = stream.getLineno();\r\n    int startCharno = stream.getCharno() + 1;\r\n    \/\/ Read the content from the first line.\r\n    String line = stream.getRemainingJSDocLine();\r\n    if (option != WhitespaceOption.PRESERVE) {\r\n        line = line.trim();\r\n    }\r\n    StringBuilder builder = new StringBuilder();\r\n    builder.append(line);\r\n    state = State.SEARCHING_ANNOTATION;\r\n    token = next();\r\n    boolean ignoreStar = false;\r\n    do {\r\n        switch(token) {\r\n            case STAR:\r\n                if (!ignoreStar) {\r\n                    if (builder.length() > 0) {\r\n                        builder.append(' ');\r\n                    }\r\n                    builder.append('*');\r\n                }\r\n                token = next();\r\n                continue;\r\n            case EOL:\r\n                if (option != WhitespaceOption.SINGLE_LINE) {\r\n                    builder.append(\"\\n\");\r\n                }\r\n                ignoreStar = true;\r\n                token = next();\r\n                continue;\r\n            case ANNOTATION:\r\n            case EOC:\r\n            case EOF:\r\n                \/\/ When we're capturing a license block, annotations\r\n                \/\/ in the block are ok.\r\n                String multilineText = builder.toString();\r\n                if (option != WhitespaceOption.PRESERVE) {\r\n                    multilineText = multilineText.trim();\r\n                }\r\n                int endLineno = stream.getLineno();\r\n                int endCharno = stream.getCharno();\r\n                if (multilineText.length() > 0) {\r\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\r\n                }\r\n                return new ExtractionInfo(multilineText, token);\r\n            default:\r\n                ignoreStar = false;\r\n                state = State.SEARCHING_ANNOTATION;\r\n                if (builder.length() > 0) {\r\n                    builder.append(' ');\r\n                }\r\n                builder.append(toString(token));\r\n                line = stream.getRemainingJSDocLine();\r\n                if (option != WhitespaceOption.PRESERVE) {\r\n                    line = trimEnd(line);\r\n                }\r\n                builder.append(line);\r\n                token = next();\r\n        }\r\n    } while (true);\r\n}","code_comment":"\/**\r\n * Extracts the text found on the current line and all subsequent\r\n * until either an annotation, end of comment or end of file is reached.\r\n * Note that if this method detects an end of line as the first token, it\r\n * will quit immediately (indicating that there is no text where it was\r\n * expected).  Note that token = info.token; should be called after this\r\n * method is used to update the token properly in the parser.\r\n *\r\n * @param token The start token.\r\n * @param option How to handle whitespace.\r\n *\r\n * @return The extraction information.\r\n *\/\r\n","code_no_comment":"@SuppressWarnings(\"fallthrough\")\r\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\r\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\r\n        return new ExtractionInfo(\"\", token);\r\n    }\r\n    stream.update();\r\n    int startLineno = stream.getLineno();\r\n    int startCharno = stream.getCharno() + 1;\r\n        String line = stream.getRemainingJSDocLine();\r\n    if (option != WhitespaceOption.PRESERVE) {\r\n        line = line.trim();\r\n    }\r\n    StringBuilder builder = new StringBuilder();\r\n    builder.append(line);\r\n    state = State.SEARCHING_ANNOTATION;\r\n    token = next();\r\n    boolean ignoreStar = false;\r\n    do {\r\n        switch(token) {\r\n            case STAR:\r\n                if (!ignoreStar) {\r\n                    if (builder.length() > 0) {\r\n                        builder.append(' ');\r\n                    }\r\n                    builder.append('*');\r\n                }\r\n                token = next();\r\n                continue;\r\n            case EOL:\r\n                if (option != WhitespaceOption.SINGLE_LINE) {\r\n                    builder.append(\"\\n\");\r\n                }\r\n                ignoreStar = true;\r\n                token = next();\r\n                continue;\r\n            case ANNOTATION:\r\n            case EOC:\r\n            case EOF:\r\n                                                String multilineText = builder.toString();\r\n                if (option != WhitespaceOption.PRESERVE) {\r\n                    multilineText = multilineText.trim();\r\n                }\r\n                int endLineno = stream.getLineno();\r\n                int endCharno = stream.getCharno();\r\n                if (multilineText.length() > 0) {\r\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\r\n                }\r\n                return new ExtractionInfo(multilineText, token);\r\n            default:\r\n                ignoreStar = false;\r\n                state = State.SEARCHING_ANNOTATION;\r\n                if (builder.length() > 0) {\r\n                    builder.append(' ');\r\n                }\r\n                builder.append(toString(token));\r\n                line = stream.getRemainingJSDocLine();\r\n                if (option != WhitespaceOption.PRESERVE) {\r\n                    line = trimEnd(line);\r\n                }\r\n                builder.append(line);\r\n                token = next();\r\n        }\r\n    } while (true);\r\n}","lc":2.2727272727,"pi":1.5837320574,"ma":3.0,"nbd":1.5,"ml":1.4166666667,"d":1.3015873016,"mi":-1.059478506,"fo":1.75,"r":-0.0263157895,"e":3.7676826703}
{"project_name":"Compress","project_version":"22","label":3,"code":"private int setupNoRandPartC() throws IOException {\r\n    if (this.su_j2 < this.su_z) {\r\n        int su_ch2Shadow = this.su_ch2;\r\n        this.currentChar = su_ch2Shadow;\r\n        this.crc.updateCRC(su_ch2Shadow);\r\n        this.su_j2++;\r\n        this.currentState = NO_RAND_PART_C_STATE;\r\n        return su_ch2Shadow;\r\n    } else {\r\n        this.su_i2++;\r\n        this.su_count = 0;\r\n        return setupNoRandPartA();\r\n    }\r\n}","code_comment":null,"code_no_comment":"private int setupNoRandPartC() throws IOException {\r\n    if (this.su_j2 < this.su_z) {\r\n        int su_ch2Shadow = this.su_ch2;\r\n        this.currentChar = su_ch2Shadow;\r\n        this.crc.updateCRC(su_ch2Shadow);\r\n        this.su_j2++;\r\n        this.currentState = NO_RAND_PART_C_STATE;\r\n        return su_ch2Shadow;\r\n    } else {\r\n        this.su_i2++;\r\n        this.su_count = 0;\r\n        return setupNoRandPartA();\r\n    }\r\n}","lc":0.0,"pi":-0.028708134,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.1170634921,"mi":0.0644115574,"fo":-0.3333333333,"r":0.0,"e":-0.0966949626}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2202_24ac1a35","label":1,"code":"public Object component(final Component component) {\r\n    return visitor.component(component);\r\n}","code_comment":null,"code_no_comment":"public Object component(final Component component) {\r\n    return visitor.component(component);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0411557435,"fo":-0.4166666667,"r":1.0263157895,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-219_ed951c76","label":1,"code":"@SuppressWarnings(\"unchecked\")\r\nprotected void doConfigure() {\r\n    boolean setRoot = false;\r\n    boolean setLoggers = false;\r\n    for (final Node child : rootNode.getChildren()) {\r\n        createConfiguration(child, null);\r\n        if (child.getObject() == null) {\r\n            continue;\r\n        }\r\n        if (child.getName().equalsIgnoreCase(\"properties\")) {\r\n            if (tempLookup == subst.getVariableResolver()) {\r\n                subst.setVariableResolver((StrLookup) child.getObject());\r\n            } else {\r\n                LOGGER.error(\"Properties declaration must be the first element in the configuration\");\r\n            }\r\n            continue;\r\n        } else if (tempLookup == subst.getVariableResolver()) {\r\n            final Map<String, String> map = (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);\r\n            final StrLookup lookup = map == null ? null : new MapLookup(map);\r\n            subst.setVariableResolver(new Interpolator(lookup));\r\n        }\r\n        if (child.getName().equalsIgnoreCase(\"appenders\")) {\r\n            appenders = (ConcurrentMap<String, Appender<?>>) child.getObject();\r\n        } else if (child.getObject() instanceof Filter) {\r\n            addFilter((Filter) child.getObject());\r\n        } else if (child.getName().equalsIgnoreCase(\"loggers\")) {\r\n            final Loggers l = (Loggers) child.getObject();\r\n            loggers = l.getMap();\r\n            setLoggers = true;\r\n            if (l.getRoot() != null) {\r\n                root = l.getRoot();\r\n                setRoot = true;\r\n            }\r\n        } else {\r\n            LOGGER.error(\"Unknown object \\\"\" + child.getName() + \"\\\" of type \" + child.getObject().getClass().getName() + \" is ignored\");\r\n        }\r\n    }\r\n    if (!setLoggers) {\r\n        LOGGER.warn(\"No Loggers were configured, using default. Is the Loggers element missing?\");\r\n        setToDefault();\r\n        return;\r\n    } else if (!setRoot) {\r\n        LOGGER.warn(\"No Root logger was configured, using default\");\r\n        setToDefault();\r\n        return;\r\n    }\r\n    for (final Map.Entry<String, LoggerConfig> entry : loggers.entrySet()) {\r\n        final LoggerConfig l = entry.getValue();\r\n        for (final AppenderRef ref : l.getAppenderRefs()) {\r\n            final Appender app = appenders.get(ref.getRef());\r\n            if (app != null) {\r\n                l.addAppender(app, ref.getLevel(), ref.getFilter());\r\n            } else {\r\n                LOGGER.error(\"Unable to locate appender \" + ref.getRef() + \" for logger \" + l.getName());\r\n            }\r\n        }\r\n    }\r\n    setParents();\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings(\"unchecked\")\r\nprotected void doConfigure() {\r\n    boolean setRoot = false;\r\n    boolean setLoggers = false;\r\n    for (final Node child : rootNode.getChildren()) {\r\n        createConfiguration(child, null);\r\n        if (child.getObject() == null) {\r\n            continue;\r\n        }\r\n        if (child.getName().equalsIgnoreCase(\"properties\")) {\r\n            if (tempLookup == subst.getVariableResolver()) {\r\n                subst.setVariableResolver((StrLookup) child.getObject());\r\n            } else {\r\n                LOGGER.error(\"Properties declaration must be the first element in the configuration\");\r\n            }\r\n            continue;\r\n        } else if (tempLookup == subst.getVariableResolver()) {\r\n            final Map<String, String> map = (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);\r\n            final StrLookup lookup = map == null ? null : new MapLookup(map);\r\n            subst.setVariableResolver(new Interpolator(lookup));\r\n        }\r\n        if (child.getName().equalsIgnoreCase(\"appenders\")) {\r\n            appenders = (ConcurrentMap<String, Appender<?>>) child.getObject();\r\n        } else if (child.getObject() instanceof Filter) {\r\n            addFilter((Filter) child.getObject());\r\n        } else if (child.getName().equalsIgnoreCase(\"loggers\")) {\r\n            final Loggers l = (Loggers) child.getObject();\r\n            loggers = l.getMap();\r\n            setLoggers = true;\r\n            if (l.getRoot() != null) {\r\n                root = l.getRoot();\r\n                setRoot = true;\r\n            }\r\n        } else {\r\n            LOGGER.error(\"Unknown object \\\"\" + child.getName() + \"\\\" of type \" + child.getObject().getClass().getName() + \" is ignored\");\r\n        }\r\n    }\r\n    if (!setLoggers) {\r\n        LOGGER.warn(\"No Loggers were configured, using default. Is the Loggers element missing?\");\r\n        setToDefault();\r\n        return;\r\n    } else if (!setRoot) {\r\n        LOGGER.warn(\"No Root logger was configured, using default\");\r\n        setToDefault();\r\n        return;\r\n    }\r\n    for (final Map.Entry<String, LoggerConfig> entry : loggers.entrySet()) {\r\n        final LoggerConfig l = entry.getValue();\r\n        for (final AppenderRef ref : l.getAppenderRefs()) {\r\n            final Appender app = appenders.get(ref.getRef());\r\n            if (app != null) {\r\n                l.addAppender(app, ref.getLevel(), ref.getFilter());\r\n            } else {\r\n                LOGGER.error(\"Unable to locate appender \" + ref.getRef() + \" for logger \" + l.getName());\r\n            }\r\n        }\r\n    }\r\n    setParents();\r\n}","lc":2.0454545455,"pi":0.5263157895,"ma":2.8,"nbd":1.5,"ml":1.5,"d":0.5198412698,"mi":-1.0287526427,"fo":3.25,"r":-0.0263157895,"e":2.115530506}
{"project_name":"Codec","project_version":"11","label":1,"code":"\/**\r\n * Return the byte at position <code>index<\/code> of the byte array and\r\n * make sure it is unsigned.\r\n *\r\n * @param index\r\n *                  position in the array\r\n * @param bytes\r\n *                  the byte array\r\n * @return the unsigned octet at position <code>index<\/code> from the array\r\n *\/\r\n\/**\r\n * Write a byte to the buffer.\r\n *\r\n * @param b\r\n *                  byte to write\r\n * @param encode\r\n *                  indicates whether the octet shall be encoded\r\n * @param buffer\r\n *                  the buffer to write to\r\n * @return the number of bytes that have been written to the buffer\r\n *\/\r\n\/**\r\n * Checks whether the given byte is whitespace.\r\n *\r\n * @param b\r\n *                  byte to be checked\r\n * @return <code>true<\/code> if the byte is either a space or tab character\r\n *\/\r\n\/**\r\n * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\r\n *\r\n * <p>\r\n * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5)\r\n * as defined in RFC 1521 and is suitable for encoding binary data and unformatted text.\r\n * <\/p>\r\n *\r\n * @param printable\r\n *                  bitset of characters deemed quoted-printable\r\n * @param bytes\r\n *                  array of bytes to be encoded\r\n * @return array of bytes containing quoted-printable data\r\n *\/\r\npublic static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\r\n    if (bytes == null) {\r\n        return null;\r\n    }\r\n    if (printable == null) {\r\n        printable = PRINTABLE_CHARS;\r\n    }\r\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\r\n    \/\/ up to this length it is safe to add any byte, encoded or not\r\n    for (byte c : bytes) {\r\n        int b = c;\r\n        if (b < 0) {\r\n            b = 256 + b;\r\n        }\r\n        if (printable.get(b)) {\r\n            buffer.write(b);\r\n        } else {\r\n            \/\/ rule #3: whitespace at the end of a line *must* be encoded\r\n            \/\/ rule #5: soft line break\r\n            encodeQuotedPrintable(b, buffer);\r\n        }\r\n    }\r\n    return buffer.toByteArray();\r\n}","code_comment":"\/**\r\n * Return the byte at position <code>index<\/code> of the byte array and\r\n * make sure it is unsigned.\r\n *\r\n * @param index\r\n *                  position in the array\r\n * @param bytes\r\n *                  the byte array\r\n * @return the unsigned octet at position <code>index<\/code> from the array\r\n *\/\r\n\/**\r\n * Write a byte to the buffer.\r\n *\r\n * @param b\r\n *                  byte to write\r\n * @param encode\r\n *                  indicates whether the octet shall be encoded\r\n * @param buffer\r\n *                  the buffer to write to\r\n * @return the number of bytes that have been written to the buffer\r\n *\/\r\n\/**\r\n * Checks whether the given byte is whitespace.\r\n *\r\n * @param b\r\n *                  byte to be checked\r\n * @return <code>true<\/code> if the byte is either a space or tab character\r\n *\/\r\n\/**\r\n * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\r\n *\r\n * <p>\r\n * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5)\r\n * as defined in RFC 1521 and is suitable for encoding binary data and unformatted text.\r\n * <\/p>\r\n *\r\n * @param printable\r\n *                  bitset of characters deemed quoted-printable\r\n * @param bytes\r\n *                  array of bytes to be encoded\r\n * @return array of bytes containing quoted-printable data\r\n *\/\r\n","code_no_comment":"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\r\n    if (bytes == null) {\r\n        return null;\r\n    }\r\n    if (printable == null) {\r\n        printable = PRINTABLE_CHARS;\r\n    }\r\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\r\n        for (byte c : bytes) {\r\n        int b = c;\r\n        if (b < 0) {\r\n            b = 256 + b;\r\n        }\r\n        if (printable.get(b)) {\r\n            buffer.write(b);\r\n        } else {\r\n                                    encodeQuotedPrintable(b, buffer);\r\n        }\r\n    }\r\n    return buffer.toByteArray();\r\n}","lc":0.3181818182,"pi":0.1961722488,"ma":0.4,"nbd":0.0,"ml":0.25,"d":0.503968254,"mi":-0.2174770965,"fo":-0.1666666667,"r":-0.0263157895,"e":0.2120548861}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2506_0f8a2990","label":1,"code":"private void applyEnclosureVisibilityToChildren(final MarkupContainer container, final MarkupStream markupStream, ComponentTag enclosureOpenTag) {\r\n    DirectChildTagIterator it = new DirectChildTagIterator(markupStream, enclosureOpenTag);\r\n    while (it.hasNext()) {\r\n        final ComponentTag tag = it.next();\r\n        final Component child = container.get(tag.getId());\r\n        \/\/ record original visiblity allowed value, will restore later\r\n        changes.put(child, child.isVisibilityAllowed());\r\n        child.setVisibilityAllowed(isVisible());\r\n    }\r\n    it.rewind();\r\n}","code_comment":null,"code_no_comment":"private void applyEnclosureVisibilityToChildren(final MarkupContainer container, final MarkupStream markupStream, ComponentTag enclosureOpenTag) {\r\n    DirectChildTagIterator it = new DirectChildTagIterator(markupStream, enclosureOpenTag);\r\n    while (it.hasNext()) {\r\n        final ComponentTag tag = it.next();\r\n        final Component child = container.get(tag.getId());\r\n                changes.put(child, child.isVisibilityAllowed());\r\n        child.setVisibilityAllowed(isVisible());\r\n    }\r\n    it.rewind();\r\n}","lc":-0.1818181818,"pi":0.0,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.1565891473,"fo":0.25,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3394_18e1a142","label":3,"code":"public void done(boolean doneSync) {\r\n    \/\/ we are done with the exchange pair\r\n    pair.done();\r\n    \/\/ we only have to handle async completion of the routing slip\r\n    if (doneSync) {\r\n        return;\r\n    }\r\n    \/\/ continue processing the multicast asynchronously\r\n    Exchange subExchange = exchange;\r\n    \/\/ Decide whether to continue with the multicast or not; similar logic to the Pipeline\r\n    \/\/ remember to test for stop on exception and aggregate before copying back results\r\n    boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Sequential processing failed for number \" + total.get(), LOG);\r\n    if (stopOnException && !continueProcessing) {\r\n        if (subExchange.getException() != null) {\r\n            \/\/ wrap in exception to explain where it failed\r\n            subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, subExchange.getException()));\r\n        } else {\r\n            \/\/ we want to stop on exception, and the exception was handled by the error handler\r\n            \/\/ this is similar to what the pipeline does, so we should do the same to not surprise end users\r\n            \/\/ so we should set the failed exchange as the result and be done\r\n            result.set(subExchange);\r\n        }\r\n        \/\/ and do the done work\r\n        doDone(original, subExchange, callback, false);\r\n        return;\r\n    }\r\n    try {\r\n        doAggregate(getAggregationStrategy(subExchange), result, subExchange);\r\n    } catch (Throwable e) {\r\n        \/\/ wrap in exception to explain where it failed\r\n        subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\r\n        \/\/ and do the done work\r\n        doDone(original, subExchange, callback, false);\r\n        return;\r\n    }\r\n    total.incrementAndGet();\r\n    \/\/ maybe there are more processors to multicast\r\n    while (it.hasNext()) {\r\n        \/\/ prepare and run the next\r\n        ProcessorExchangePair pair = it.next();\r\n        subExchange = pair.getExchange();\r\n        updateNewExchange(subExchange, total.get(), pairs, it);\r\n        boolean sync = doProcessSequential(original, result, pairs, it, pair, callback, total);\r\n        if (!sync) {\r\n            if (LOG.isTraceEnabled()) {\r\n                LOG.trace(\"Processing exchangeId: \" + original.getExchangeId() + \" is continued being processed asynchronously\");\r\n            }\r\n            return;\r\n        }\r\n        \/\/ Decide whether to continue with the multicast or not; similar logic to the Pipeline\r\n        \/\/ remember to test for stop on exception and aggregate before copying back results\r\n        continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Sequential processing failed for number \" + total.get(), LOG);\r\n        if (stopOnException && !continueProcessing) {\r\n            if (subExchange.getException() != null) {\r\n                \/\/ wrap in exception to explain where it failed\r\n                subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, subExchange.getException()));\r\n            } else {\r\n                \/\/ we want to stop on exception, and the exception was handled by the error handler\r\n                \/\/ this is similar to what the pipeline does, so we should do the same to not surprise end users\r\n                \/\/ so we should set the failed exchange as the result and be done\r\n                result.set(subExchange);\r\n            }\r\n            \/\/ and do the done work\r\n            doDone(original, subExchange, callback, false);\r\n            return;\r\n        }\r\n        try {\r\n            doAggregate(getAggregationStrategy(subExchange), result, subExchange);\r\n        } catch (Throwable e) {\r\n            \/\/ wrap in exception to explain where it failed\r\n            subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\r\n            \/\/ and do the done work\r\n            doDone(original, subExchange, callback, false);\r\n            return;\r\n        }\r\n        total.incrementAndGet();\r\n    }\r\n    \/\/ do the done work\r\n    subExchange = result.get() != null ? result.get() : null;\r\n    doDone(original, subExchange, callback, false);\r\n}","code_comment":null,"code_no_comment":"public void done(boolean doneSync) {\r\n        pair.done();\r\n        if (doneSync) {\r\n        return;\r\n    }\r\n        Exchange subExchange = exchange;\r\n            boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Sequential processing failed for number \" + total.get(), LOG);\r\n    if (stopOnException && !continueProcessing) {\r\n        if (subExchange.getException() != null) {\r\n                        subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, subExchange.getException()));\r\n        } else {\r\n                                                result.set(subExchange);\r\n        }\r\n                doDone(original, subExchange, callback, false);\r\n        return;\r\n    }\r\n    try {\r\n        doAggregate(getAggregationStrategy(subExchange), result, subExchange);\r\n    } catch (Throwable e) {\r\n                subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\r\n                doDone(original, subExchange, callback, false);\r\n        return;\r\n    }\r\n    total.incrementAndGet();\r\n        while (it.hasNext()) {\r\n                ProcessorExchangePair pair = it.next();\r\n        subExchange = pair.getExchange();\r\n        updateNewExchange(subExchange, total.get(), pairs, it);\r\n        boolean sync = doProcessSequential(original, result, pairs, it, pair, callback, total);\r\n        if (!sync) {\r\n            if (LOG.isTraceEnabled()) {\r\n                LOG.trace(\"Processing exchangeId: \" + original.getExchangeId() + \" is continued being processed asynchronously\");\r\n            }\r\n            return;\r\n        }\r\n                        continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Sequential processing failed for number \" + total.get(), LOG);\r\n        if (stopOnException && !continueProcessing) {\r\n            if (subExchange.getException() != null) {\r\n                                subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, subExchange.getException()));\r\n            } else {\r\n                                                                result.set(subExchange);\r\n            }\r\n                        doDone(original, subExchange, callback, false);\r\n            return;\r\n        }\r\n        try {\r\n            doAggregate(getAggregationStrategy(subExchange), result, subExchange);\r\n        } catch (Throwable e) {\r\n                        subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\r\n                        doDone(original, subExchange, callback, false);\r\n            return;\r\n        }\r\n        total.incrementAndGet();\r\n    }\r\n        subExchange = result.get() != null ? result.get() : null;\r\n    doDone(original, subExchange, callback, false);\r\n}","lc":1.9545454545,"pi":0.3444976077,"ma":1.6,"nbd":0.5,"ml":1.1666666667,"d":1.0555555556,"mi":-0.9565891473,"fo":2.5833333333,"r":-0.0263157895,"e":3.0832039557}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2246_dcadb0e1","label":1,"code":"@Override\r\npublic void endNode(NodeInfo nodeInfo) throws RepositoryException {\r\n    Tree parent = parents.pop();\r\n    if (parent == null) {\r\n        if (pnImporter != null) {\r\n            pnImporter.endChildInfo();\r\n        }\r\n    } else if (getDefinition(parent).isProtected()) {\r\n        if (pnImporter != null) {\r\n            pnImporter.end(parent);\r\n            \/\/ and reset the pnImporter field waiting for the next protected\r\n            \/\/ parent -> selecting again from available importers\r\n            pnImporter = null;\r\n        }\r\n    }\r\n    collectUUIDs(parent);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void endNode(NodeInfo nodeInfo) throws RepositoryException {\r\n    Tree parent = parents.pop();\r\n    if (parent == null) {\r\n        if (pnImporter != null) {\r\n            pnImporter.endChildInfo();\r\n        }\r\n    } else if (getDefinition(parent).isProtected()) {\r\n        if (pnImporter != null) {\r\n            pnImporter.end(parent);\r\n                                    pnImporter = null;\r\n        }\r\n    }\r\n    collectUUIDs(parent);\r\n}","lc":0.0454545455,"pi":0.5311004785,"ma":0.2,"nbd":0.5,"ml":0.1666666667,"d":-0.0376984127,"mi":-0.0184637068,"fo":0.0,"r":0.3947368421,"e":-0.0544919117}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-428_d906576c","label":3,"code":"\/**\r\n *  @see java.util.Map#entrySet()\r\n *\/\r\npublic Set entrySet() {\r\n    return new AbstractSet() {\r\n\r\n        public Iterator iterator() {\r\n            return new Iterator() {\r\n\r\n                public boolean hasNext() {\r\n                    return index < MicroMap.this.size();\r\n                }\r\n\r\n                public Object next() {\r\n                    index++;\r\n                    return new Map.Entry() {\r\n\r\n                        public Object getKey() {\r\n                            return key;\r\n                        }\r\n\r\n                        public Object getValue() {\r\n                            return value;\r\n                        }\r\n\r\n                        public Object setValue(final Object value) {\r\n                            final Object oldValue = MicroMap.this.value;\r\n                            MicroMap.this.value = value;\r\n                            return oldValue;\r\n                        }\r\n                    };\r\n                }\r\n\r\n                public void remove() {\r\n                    clear();\r\n                }\r\n\r\n                int index = 0;\r\n            };\r\n        }\r\n\r\n        public int size() {\r\n            return MicroMap.this.size();\r\n        }\r\n    };\r\n}","code_comment":"\/**\r\n *  @see java.util.Map#entrySet()\r\n *\/\r\n","code_no_comment":"public Set entrySet() {\r\n    return new AbstractSet() {\r\n\r\n        public Iterator iterator() {\r\n            return new Iterator() {\r\n\r\n                public boolean hasNext() {\r\n                    return index < MicroMap.this.size();\r\n                }\r\n\r\n                public Object next() {\r\n                    index++;\r\n                    return new Map.Entry() {\r\n\r\n                        public Object getKey() {\r\n                            return key;\r\n                        }\r\n\r\n                        public Object getValue() {\r\n                            return value;\r\n                        }\r\n\r\n                        public Object setValue(final Object value) {\r\n                            final Object oldValue = MicroMap.this.value;\r\n                            MicroMap.this.value = value;\r\n                            return oldValue;\r\n                        }\r\n                    };\r\n                }\r\n\r\n                public void remove() {\r\n                    clear();\r\n                }\r\n\r\n                int index = 0;\r\n            };\r\n        }\r\n\r\n        public int size() {\r\n            return MicroMap.this.size();\r\n        }\r\n    };\r\n}","lc":0.9090909091,"pi":2.4736842105,"ma":-0.6,"nbd":0.5,"ml":-0.4166666667,"d":-0.0119047619,"mi":-0.4272022551,"fo":-0.25,"r":0.1842105263,"e":0.0149075339}
{"project_name":"Compress","project_version":"14","label":1,"code":"\/**\r\n * Parse an octal string from a buffer.\r\n *\r\n * <p>Leading spaces are ignored.\r\n * The buffer must contain a trailing space or NUL,\r\n * and may contain an additional trailing space or NUL.<\/p>\r\n *\r\n * <p>The input buffer is allowed to contain all NULs,\r\n * in which case the method returns 0L\r\n * (this allows for missing fields).<\/p>\r\n *\r\n * <p>To work-around some tar implementations that insert a\r\n * leading NUL this method returns 0 if it detects a leading NUL\r\n * since Commons Compress 1.4.<\/p>\r\n *\r\n * @param buffer The buffer from which to parse.\r\n * @param offset The offset into the buffer from which to parse.\r\n * @param length The maximum number of bytes to parse - must be at least 2 bytes.\r\n * @return The long value of the octal string.\r\n * @throws IllegalArgumentException if the trailing space\/NUL is missing or if a invalid byte is detected.\r\n *\/\r\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\r\n    long result = 0;\r\n    int end = offset + length;\r\n    int start = offset;\r\n    if (length < 2) {\r\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\r\n    }\r\n    boolean allNUL = true;\r\n    for (int i = start; i < end; i++) {\r\n        if (buffer[i] != 0) {\r\n            allNUL = false;\r\n            break;\r\n        }\r\n    }\r\n    if (allNUL) {\r\n        return 0L;\r\n    }\r\n    \/\/ Skip leading spaces\r\n    while (start < end) {\r\n        if (buffer[start] == ' ') {\r\n            start++;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    \/\/ Must have trailing NUL or space\r\n    byte trailer;\r\n    trailer = buffer[end - 1];\r\n    if (trailer == 0 || trailer == ' ') {\r\n        end--;\r\n    } else {\r\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));\r\n    }\r\n    \/\/ May have additional NUL or space\r\n    trailer = buffer[end - 1];\r\n    if (trailer == 0 || trailer == ' ') {\r\n        end--;\r\n    }\r\n    for (; start < end; start++) {\r\n        final byte currentByte = buffer[start];\r\n        \/\/ CheckStyle:MagicNumber OFF\r\n        if (currentByte < '0' || currentByte > '7') {\r\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\r\n        }\r\n        \/\/ convert from ASCII\r\n        result = (result << 3) + (currentByte - '0');\r\n    \/\/ CheckStyle:MagicNumber ON\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n * Parse an octal string from a buffer.\r\n *\r\n * <p>Leading spaces are ignored.\r\n * The buffer must contain a trailing space or NUL,\r\n * and may contain an additional trailing space or NUL.<\/p>\r\n *\r\n * <p>The input buffer is allowed to contain all NULs,\r\n * in which case the method returns 0L\r\n * (this allows for missing fields).<\/p>\r\n *\r\n * <p>To work-around some tar implementations that insert a\r\n * leading NUL this method returns 0 if it detects a leading NUL\r\n * since Commons Compress 1.4.<\/p>\r\n *\r\n * @param buffer The buffer from which to parse.\r\n * @param offset The offset into the buffer from which to parse.\r\n * @param length The maximum number of bytes to parse - must be at least 2 bytes.\r\n * @return The long value of the octal string.\r\n * @throws IllegalArgumentException if the trailing space\/NUL is missing or if a invalid byte is detected.\r\n *\/\r\n","code_no_comment":"public static long parseOctal(final byte[] buffer, final int offset, final int length) {\r\n    long result = 0;\r\n    int end = offset + length;\r\n    int start = offset;\r\n    if (length < 2) {\r\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\r\n    }\r\n    boolean allNUL = true;\r\n    for (int i = start; i < end; i++) {\r\n        if (buffer[i] != 0) {\r\n            allNUL = false;\r\n            break;\r\n        }\r\n    }\r\n    if (allNUL) {\r\n        return 0L;\r\n    }\r\n        while (start < end) {\r\n        if (buffer[start] == ' ') {\r\n            start++;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n        byte trailer;\r\n    trailer = buffer[end - 1];\r\n    if (trailer == 0 || trailer == ' ') {\r\n        end--;\r\n    } else {\r\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));\r\n    }\r\n        trailer = buffer[end - 1];\r\n    if (trailer == 0 || trailer == ' ') {\r\n        end--;\r\n    }\r\n    for (; start < end; start++) {\r\n        final byte currentByte = buffer[start];\r\n                if (currentByte < '0' || currentByte > '7') {\r\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\r\n        }\r\n                result = (result << 3) + (currentByte - '0');\r\n        }\r\n    return result;\r\n}","lc":1.3636363636,"pi":0.014354067,"ma":2.4,"nbd":0.0,"ml":1.25,"d":3.126984127,"mi":-0.8040873855,"fo":-0.3333333333,"r":-0.0263157895,"e":5.1228828455}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3740_f2f5bd5b","label":1,"code":"@Override\r\npublic final void trigger(long time) throws Exception {\r\n    boolean fire;\r\n    do {\r\n        Timer<K, W> timer = processingTimeTimersQueue.peek();\r\n        if (timer != null && timer.timestamp <= time) {\r\n            fire = true;\r\n            processingTimeTimers.remove(timer);\r\n            processingTimeTimersQueue.remove();\r\n            context.key = timer.key;\r\n            context.window = timer.window;\r\n            setKeyContext(timer.key);\r\n            TriggerResult triggerResult = context.onProcessingTime(timer.timestamp);\r\n            processTriggerResult(triggerResult, context.key, context.window);\r\n        } else {\r\n            fire = false;\r\n        }\r\n    } while (fire);\r\n    \/\/ Also check any watermark timers. We might have some in here since\r\n    \/\/ Context.registerEventTimeTimer sets a trigger if an event-time trigger is registered\r\n    \/\/ that is already behind the watermark.\r\n    processTriggersFor(new Watermark(currentWatermark));\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic final void trigger(long time) throws Exception {\r\n    boolean fire;\r\n    do {\r\n        Timer<K, W> timer = processingTimeTimersQueue.peek();\r\n        if (timer != null && timer.timestamp <= time) {\r\n            fire = true;\r\n            processingTimeTimers.remove(timer);\r\n            processingTimeTimersQueue.remove();\r\n            context.key = timer.key;\r\n            context.window = timer.window;\r\n            setKeyContext(timer.key);\r\n            TriggerResult triggerResult = context.onProcessingTime(timer.timestamp);\r\n            processTriggerResult(triggerResult, context.key, context.window);\r\n        } else {\r\n            fire = false;\r\n        }\r\n    } while (fire);\r\n                processTriggersFor(new Watermark(currentWatermark));\r\n}","lc":0.2727272727,"pi":0.7081339713,"ma":-0.2,"nbd":0.0,"ml":0.1666666667,"d":0.3611111111,"mi":-0.252149401,"fo":0.0833333333,"r":-0.0263157895,"e":0.3642422042}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3514_2b6da516","label":1,"code":"private Url encryptUrl(final Url url) {\r\n    if (url.getSegments().isEmpty() && url.getQueryParameters().isEmpty()) {\r\n        return url;\r\n    }\r\n    String encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());\r\n    Url encryptedUrl = new Url(url.getCharset());\r\n    encryptedUrl.getSegments().add(encryptedUrlString);\r\n    int numberOfSegments = url.getSegments().size();\r\n    if (numberOfSegments == 0 && !url.getQueryParameters().isEmpty()) {\r\n        numberOfSegments = 1;\r\n    }\r\n    char[] encryptedChars = encryptedUrlString.toCharArray();\r\n    int hash = 0;\r\n    for (int segNo = 0; segNo < numberOfSegments; segNo++) {\r\n        char a = encryptedChars[Math.abs(hash % encryptedChars.length)];\r\n        hash++;\r\n        char b = encryptedChars[Math.abs(hash % encryptedChars.length)];\r\n        hash++;\r\n        char c = encryptedChars[Math.abs(hash % encryptedChars.length)];\r\n        String segment = \"\" + a + b + c;\r\n        hash = hashString(segment);\r\n        segment += String.format(\"%02x\", Math.abs(hash % 256));\r\n        encryptedUrl.getSegments().add(segment);\r\n        hash = hashString(segment);\r\n    }\r\n    return encryptedUrl;\r\n}","code_comment":null,"code_no_comment":"private Url encryptUrl(final Url url) {\r\n    if (url.getSegments().isEmpty() && url.getQueryParameters().isEmpty()) {\r\n        return url;\r\n    }\r\n    String encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());\r\n    Url encryptedUrl = new Url(url.getCharset());\r\n    encryptedUrl.getSegments().add(encryptedUrlString);\r\n    int numberOfSegments = url.getSegments().size();\r\n    if (numberOfSegments == 0 && !url.getQueryParameters().isEmpty()) {\r\n        numberOfSegments = 1;\r\n    }\r\n    char[] encryptedChars = encryptedUrlString.toCharArray();\r\n    int hash = 0;\r\n    for (int segNo = 0; segNo < numberOfSegments; segNo++) {\r\n        char a = encryptedChars[Math.abs(hash % encryptedChars.length)];\r\n        hash++;\r\n        char b = encryptedChars[Math.abs(hash % encryptedChars.length)];\r\n        hash++;\r\n        char c = encryptedChars[Math.abs(hash % encryptedChars.length)];\r\n        String segment = \"\" + a + b + c;\r\n        hash = hashString(segment);\r\n        segment += String.format(\"%02x\", Math.abs(hash % 256));\r\n        encryptedUrl.getSegments().add(segment);\r\n        hash = hashString(segment);\r\n    }\r\n    return encryptedUrl;\r\n}","lc":0.5909090909,"pi":-0.2488038278,"ma":0.0,"nbd":-0.5,"ml":0.3333333333,"d":1.8115079365,"mi":-0.5075405215,"fo":1.5,"r":-0.0263157895,"e":3.2338375893}
{"project_name":"Math","project_version":"56","label":3,"code":"\/**\r\n * Convert to multidimensional counter.\r\n *\r\n * @param index Index in unidimensional counter.\r\n * @return the multidimensional counts.\r\n * @throws OutOfRangeException if {@code index} is not between\r\n * {@code 0} and the value returned by {@link #getSize()} (excluded).\r\n *\/\r\npublic int[] getCounts(int index) {\r\n    if (index < 0 || index >= totalSize) {\r\n        throw new OutOfRangeException(index, 0, totalSize);\r\n    }\r\n    final int[] indices = new int[dimension];\r\n    int count = 0;\r\n    for (int i = 0; i < last; i++) {\r\n        int idx = 0;\r\n        final int offset = uniCounterOffset[i];\r\n        while (count <= index) {\r\n            count += offset;\r\n            ++idx;\r\n        }\r\n        --idx;\r\n        count -= offset;\r\n        indices[i] = idx;\r\n    }\r\n    int idx = 1;\r\n    while (count < index) {\r\n        count += idx;\r\n        ++idx;\r\n    }\r\n    --idx;\r\n    indices[last] = idx;\r\n    return indices;\r\n}","code_comment":"\/**\r\n * Convert to multidimensional counter.\r\n *\r\n * @param index Index in unidimensional counter.\r\n * @return the multidimensional counts.\r\n * @throws OutOfRangeException if {@code index} is not between\r\n * {@code 0} and the value returned by {@link #getSize()} (excluded).\r\n *\/\r\n","code_no_comment":"public int[] getCounts(int index) {\r\n    if (index < 0 || index >= totalSize) {\r\n        throw new OutOfRangeException(index, 0, totalSize);\r\n    }\r\n    final int[] indices = new int[dimension];\r\n    int count = 0;\r\n    for (int i = 0; i < last; i++) {\r\n        int idx = 0;\r\n        final int offset = uniCounterOffset[i];\r\n        while (count <= index) {\r\n            count += offset;\r\n            ++idx;\r\n        }\r\n        --idx;\r\n        count -= offset;\r\n        indices[i] = idx;\r\n    }\r\n    int idx = 1;\r\n    while (count < index) {\r\n        count += idx;\r\n        ++idx;\r\n    }\r\n    --idx;\r\n    indices[last] = idx;\r\n    return indices;\r\n}","lc":0.5454545455,"pi":-0.004784689,"ma":0.4,"nbd":0.0,"ml":0.4166666667,"d":2.1746031746,"mi":-0.3950669486,"fo":-0.5,"r":0.0263157895,"e":1.7311941356}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"public update_result setOuch2(MutationsRejectedException ouch2) {\r\n    this.ouch2 = ouch2;\r\n    return this;\r\n}","code_comment":null,"code_no_comment":"public update_result setOuch2(MutationsRejectedException ouch2) {\r\n    this.ouch2 = ouch2;\r\n    return this;\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8940098661,"fo":-0.5,"r":1.8684210526,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"@Override\r\npublic void write(org.apache.thrift.protocol.TProtocol prot, removeTableProperty_result struct) throws org.apache.thrift.TException {\r\n    TTupleProtocol oprot = (TTupleProtocol) prot;\r\n    BitSet optionals = new BitSet();\r\n    if (struct.isSetOuch1()) {\r\n        optionals.set(0);\r\n    }\r\n    if (struct.isSetOuch2()) {\r\n        optionals.set(1);\r\n    }\r\n    oprot.writeBitSet(optionals, 2);\r\n    if (struct.isSetOuch1()) {\r\n        struct.ouch1.write(oprot);\r\n    }\r\n    if (struct.isSetOuch2()) {\r\n        struct.ouch2.write(oprot);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void write(org.apache.thrift.protocol.TProtocol prot, removeTableProperty_result struct) throws org.apache.thrift.TException {\r\n    TTupleProtocol oprot = (TTupleProtocol) prot;\r\n    BitSet optionals = new BitSet();\r\n    if (struct.isSetOuch1()) {\r\n        optionals.set(0);\r\n    }\r\n    if (struct.isSetOuch2()) {\r\n        optionals.set(1);\r\n    }\r\n    oprot.writeBitSet(optionals, 2);\r\n    if (struct.isSetOuch1()) {\r\n        struct.ouch1.write(oprot);\r\n    }\r\n    if (struct.isSetOuch2()) {\r\n        struct.ouch2.write(oprot);\r\n    }\r\n}","lc":0.1818181818,"pi":-0.2440191388,"ma":0.2,"nbd":-0.5,"ml":0.0833333333,"d":-0.3650793651,"mi":-0.1749119098,"fo":0.25,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1081_4ce4e3c9","label":3,"code":"\/**\r\n * Returns an iterator for traversing all the children of this node.\r\n * If the node is orderable then the iterator will return child nodes in the\r\n * specified order. Otherwise the ordering of the iterator is undefined.\r\n *\r\n * @return child nodes of the node\r\n *\/\r\n@Nonnull\r\npublic Iterator<NodeDelegate> getChildren() throws InvalidItemStateException {\r\n    Iterator<Tree> iterator = getTree().getChildren().iterator();\r\n    return transform(filter(iterator, new Predicate<Tree>() {\r\n\r\n        @Override\r\n        public boolean apply(Tree tree) {\r\n            return !tree.getName().startsWith(\":\");\r\n        }\r\n    }), new Function<Tree, NodeDelegate>() {\r\n\r\n        @Override\r\n        public NodeDelegate apply(Tree tree) {\r\n            return new NodeDelegate(sessionDelegate, tree);\r\n        }\r\n    });\r\n}","code_comment":"\/**\r\n * Returns an iterator for traversing all the children of this node.\r\n * If the node is orderable then the iterator will return child nodes in the\r\n * specified order. Otherwise the ordering of the iterator is undefined.\r\n *\r\n * @return child nodes of the node\r\n *\/\r\n","code_no_comment":"@Nonnull\r\npublic Iterator<NodeDelegate> getChildren() throws InvalidItemStateException {\r\n    Iterator<Tree> iterator = getTree().getChildren().iterator();\r\n    return transform(filter(iterator, new Predicate<Tree>() {\r\n\r\n        @Override\r\n        public boolean apply(Tree tree) {\r\n            return !tree.getName().startsWith(\":\");\r\n        }\r\n    }), new Function<Tree, NodeDelegate>() {\r\n\r\n        @Override\r\n        public NodeDelegate apply(Tree tree) {\r\n            return new NodeDelegate(sessionDelegate, tree);\r\n        }\r\n    });\r\n}","lc":0.0454545455,"pi":0.4019138756,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.0079365079,"mi":-0.0178999295,"fo":0.0833333333,"r":0.0,"e":-0.0221642088}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4431_7441a3d5","label":1,"code":"public Directory wrapForWrite(IndexDefinition definition, Directory remote, boolean reindexMode) throws IOException {\r\n    Directory local = createLocalDirForIndexWriter(definition);\r\n    return new CopyOnWriteDirectory(remote, local, reindexMode, getIndexPathForLogging(definition), getSharedWorkingSet(definition));\r\n}","code_comment":null,"code_no_comment":"public Directory wrapForWrite(IndexDefinition definition, Directory remote, boolean reindexMode) throws IOException {\r\n    Directory local = createLocalDirForIndexWriter(definition);\r\n    return new CopyOnWriteDirectory(remote, local, reindexMode, getIndexPathForLogging(definition), getSharedWorkingSet(definition));\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6890768147,"fo":-0.25,"r":0.0,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-492_61ccbb95","label":3,"code":"\/**\r\n * Either returns the specified name as is, or returns a quoted value\r\n * containing the specified name with the special characters (comma, equals,\r\n * colon, quote, asterisk, or question mark) preceded with a backslash.\r\n *\r\n * @param name the name to escape so it can be used as a value in an\r\n *            {@link ObjectName}.\r\n * @return the escaped name\r\n *\/\r\npublic static String escape(final String name) {\r\n    final StringBuilder sb = new StringBuilder(name.length() * 2);\r\n    boolean needsQuotes = false;\r\n    for (int i = 0; i < name.length(); i++) {\r\n        final char c = name.charAt(i);\r\n        switch(c) {\r\n            case '\\\\':\r\n            case '*':\r\n            case '?':\r\n            case '\\\"':\r\n                \/\/ quote, star, question & backslash must be escaped\r\n                sb.append('\\\\');\r\n                \/\/ ... and can only appear in quoted value\r\n                needsQuotes = true;\r\n                break;\r\n            case ',':\r\n            case '=':\r\n            case ':':\r\n                \/\/ no need to escape these, but value must be quoted\r\n                needsQuotes = true;\r\n                break;\r\n            case '\\r':\r\n                \/\/ replace by \\\\r, no need to quote\r\n                sb.append(\"\\\\r\");\r\n                continue;\r\n            case '\\n':\r\n                \/\/ replace by \\\\n, no need to quote\r\n                sb.append(\"\\\\n\");\r\n                continue;\r\n        }\r\n        sb.append(c);\r\n    }\r\n    if (needsQuotes) {\r\n        sb.insert(0, '\\\"');\r\n        sb.append('\\\"');\r\n    }\r\n    return sb.toString();\r\n}","code_comment":"\/**\r\n * Either returns the specified name as is, or returns a quoted value\r\n * containing the specified name with the special characters (comma, equals,\r\n * colon, quote, asterisk, or question mark) preceded with a backslash.\r\n *\r\n * @param name the name to escape so it can be used as a value in an\r\n *            {@link ObjectName}.\r\n * @return the escaped name\r\n *\/\r\n","code_no_comment":"public static String escape(final String name) {\r\n    final StringBuilder sb = new StringBuilder(name.length() * 2);\r\n    boolean needsQuotes = false;\r\n    for (int i = 0; i < name.length(); i++) {\r\n        final char c = name.charAt(i);\r\n        switch(c) {\r\n            case '\\\\':\r\n            case '*':\r\n            case '?':\r\n            case '\\\"':\r\n                                sb.append('\\\\');\r\n                                needsQuotes = true;\r\n                break;\r\n            case ',':\r\n            case '=':\r\n            case ':':\r\n                                needsQuotes = true;\r\n                break;\r\n            case '\\r':\r\n                                sb.append(\"\\\\r\");\r\n                continue;\r\n            case '\\n':\r\n                                sb.append(\"\\\\n\");\r\n                continue;\r\n        }\r\n        sb.append(c);\r\n    }\r\n    if (needsQuotes) {\r\n        sb.insert(0, '\\\"');\r\n        sb.append('\\\"');\r\n    }\r\n    return sb.toString();\r\n}","lc":0.8636363636,"pi":0.976076555,"ma":2.4,"nbd":0.5,"ml":0.8333333333,"d":0.4424603175,"mi":-0.5785764623,"fo":0.3333333333,"r":-0.0263157895,"e":0.4806855575}
{"project_name":"Math","project_version":"67","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic double getResult() {\r\n    return optimizer.getResult();\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public double getResult() {\r\n    return optimizer.getResult();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1987315011,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5085_581c7306","label":1,"code":"@Override\r\nprotected MarkupElement onComponentTag(final ComponentTag tag) throws ParseException {\r\n    \/\/ We only need ComponentTags\r\n    if (tag instanceof WicketTag) {\r\n        return tag;\r\n    }\r\n    \/\/ Has wicket:enclosure attribute?\r\n    String enclosureAttr = getAttribute(tag, null);\r\n    if (enclosureAttr != null) {\r\n        if (tag.isOpen()) {\r\n            \/\/ Make sure 'wicket:id' and 'id' are consistent\r\n            String htmlId = tag.getAttribute(\"id\");\r\n            if ((tag.getId() != null) && !Strings.isEmpty(htmlId) && !htmlId.equals(tag.getId())) {\r\n                throw new ParseException(\"Make sure that 'id' and 'wicket:id' are the same if both are provided. Tag:\" + tag.toString(), tag.getPos());\r\n            }\r\n            \/\/ if it doesn't have a wicket-id already, then assign one now.\r\n            if (Strings.isEmpty(tag.getId())) {\r\n                if (Strings.isEmpty(htmlId)) {\r\n                    String id = getWicketNamespace() + \"_\" + INLINE_ENCLOSURE_ID_PREFIX;\r\n                    tag.setId(id);\r\n                } else {\r\n                    tag.setId(htmlId);\r\n                }\r\n                tag.setAutoComponentTag(true);\r\n                tag.setModified(true);\r\n            }\r\n            \/\/ Put the enclosure on the stack. The most current one will be on top\r\n            if (enclosures == null) {\r\n                enclosures = new Stack<ComponentTag>();\r\n            }\r\n            enclosures.push(tag);\r\n        } else {\r\n            throw new ParseException(\"Open-close tags don't make sense for InlineEnclosure. Tag:\" + tag.toString(), tag.getPos());\r\n        }\r\n    } else \/\/ Are we within an enclosure?\r\n    if ((enclosures != null) && (enclosures.size() > 0)) {\r\n        \/\/ first ComponentTag's id found as the controlling child to the enclosure.\r\n        if (tag.isOpen() && (tag.getId() != null) && !(tag instanceof WicketTag) && !tag.isAutoComponentTag()) {\r\n            for (int i = enclosures.size() - 1; i >= 0; i--) {\r\n                ComponentTag lastEnclosure = enclosures.get(i);\r\n                String attr = getAttribute(lastEnclosure, null);\r\n                if (Strings.isEmpty(attr) == true) {\r\n                    lastEnclosure.getAttributes().put(getInlineEnclosureAttributeName(null), tag.getId());\r\n                    lastEnclosure.setModified(true);\r\n                }\r\n            }\r\n        } else if (tag.isClose() && tag.closes(enclosures.peek())) {\r\n            ComponentTag lastEnclosure = enclosures.pop();\r\n            String attr = getAttribute(lastEnclosure, null);\r\n            if (Strings.isEmpty(attr) == true) {\r\n                throw new ParseException(\"Did not find any child for InlineEnclosure. Tag:\" + lastEnclosure.toString(), tag.getPos());\r\n            }\r\n        }\r\n    }\r\n    return tag;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected MarkupElement onComponentTag(final ComponentTag tag) throws ParseException {\r\n        if (tag instanceof WicketTag) {\r\n        return tag;\r\n    }\r\n        String enclosureAttr = getAttribute(tag, null);\r\n    if (enclosureAttr != null) {\r\n        if (tag.isOpen()) {\r\n                        String htmlId = tag.getAttribute(\"id\");\r\n            if ((tag.getId() != null) && !Strings.isEmpty(htmlId) && !htmlId.equals(tag.getId())) {\r\n                throw new ParseException(\"Make sure that 'id' and 'wicket:id' are the same if both are provided. Tag:\" + tag.toString(), tag.getPos());\r\n            }\r\n                        if (Strings.isEmpty(tag.getId())) {\r\n                if (Strings.isEmpty(htmlId)) {\r\n                    String id = getWicketNamespace() + \"_\" + INLINE_ENCLOSURE_ID_PREFIX;\r\n                    tag.setId(id);\r\n                } else {\r\n                    tag.setId(htmlId);\r\n                }\r\n                tag.setAutoComponentTag(true);\r\n                tag.setModified(true);\r\n            }\r\n                        if (enclosures == null) {\r\n                enclosures = new Stack<ComponentTag>();\r\n            }\r\n            enclosures.push(tag);\r\n        } else {\r\n            throw new ParseException(\"Open-close tags don't make sense for InlineEnclosure. Tag:\" + tag.toString(), tag.getPos());\r\n        }\r\n    } else     if ((enclosures != null) && (enclosures.size() > 0)) {\r\n                if (tag.isOpen() && (tag.getId() != null) && !(tag instanceof WicketTag) && !tag.isAutoComponentTag()) {\r\n            for (int i = enclosures.size() - 1; i >= 0; i--) {\r\n                ComponentTag lastEnclosure = enclosures.get(i);\r\n                String attr = getAttribute(lastEnclosure, null);\r\n                if (Strings.isEmpty(attr) == true) {\r\n                    lastEnclosure.getAttributes().put(getInlineEnclosureAttributeName(null), tag.getId());\r\n                    lastEnclosure.setModified(true);\r\n                }\r\n            }\r\n        } else if (tag.isClose() && tag.closes(enclosures.peek())) {\r\n            ComponentTag lastEnclosure = enclosures.pop();\r\n            String attr = getAttribute(lastEnclosure, null);\r\n            if (Strings.isEmpty(attr) == true) {\r\n                throw new ParseException(\"Did not find any child for InlineEnclosure. Tag:\" + lastEnclosure.toString(), tag.getPos());\r\n            }\r\n        }\r\n    }\r\n    return tag;\r\n}","lc":1.6363636364,"pi":1.2200956938,"ma":2.6,"nbd":1.5,"ml":2.6666666667,"d":2.6507936508,"mi":-0.9408033827,"fo":2.9166666667,"r":-0.0263157895,"e":7.3007336203}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1505_b082fc1e","label":1,"code":"@Override\r\npublic void addMutation(Mutation m) throws MutationsRejectedException {\r\n    acu.addMutation(tablename, m);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void addMutation(Mutation m) throws MutationsRejectedException {\r\n    acu.addMutation(tablename, m);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8396053559,"fo":-0.4166666667,"r":1.1052631579,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_add180fb","label":1,"code":"@Override\r\npublic void delete(String tableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n    acu.tables.remove(tableName);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void delete(String tableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n    acu.tables.remove(tableName);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7919661734,"fo":-0.4166666667,"r":0.1842105263,"e":-0.1627934049}
{"project_name":"Codec","project_version":"2","label":1,"code":"\/**\r\n * <p>\r\n * Encodes all of the provided data, starting at inPos, for inAvail bytes.\r\n * Must be called at least twice:  once with the data to encode, and once\r\n * with inAvail set to \"-1\" to alert encoder that EOF has been reached,\r\n * so flush last remaining bytes (if not multiple of 3).\r\n * <\/p><p>\r\n * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\r\n * and general approach.\r\n * http:\/\/svn.apache.org\/repos\/asf\/webservices\/commons\/trunk\/modules\/util\/\r\n * <\/p>\r\n *\r\n * @param in byte[] array of binary data to base64 encode.\r\n * @param inPos Position to start reading data from.\r\n * @param inAvail Amount of bytes available from input for encoding.\r\n *\/\r\nvoid encode(byte[] in, int inPos, int inAvail) {\r\n    if (eof) {\r\n        return;\r\n    }\r\n    \/\/ encoding.\r\n    if (inAvail < 0) {\r\n        eof = true;\r\n        if (buf == null || buf.length - pos < encodeSize) {\r\n            resizeBuf();\r\n        }\r\n        switch(modulus) {\r\n            case 1:\r\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\r\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\r\n                \/\/ URL-SAFE skips the padding to further reduce size.\r\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\r\n                    buf[pos++] = PAD;\r\n                    buf[pos++] = PAD;\r\n                }\r\n                break;\r\n            case 2:\r\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\r\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\r\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\r\n                \/\/ URL-SAFE skips the padding to further reduce size.\r\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\r\n                    buf[pos++] = PAD;\r\n                }\r\n                break;\r\n        }\r\n        if (lineLength > 0) {\r\n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\r\n            pos += lineSeparator.length;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < inAvail; i++) {\r\n            if (buf == null || buf.length - pos < encodeSize) {\r\n                resizeBuf();\r\n            }\r\n            modulus = (++modulus) % 3;\r\n            int b = in[inPos++];\r\n            if (b < 0) {\r\n                b += 256;\r\n            }\r\n            x = (x << 8) + b;\r\n            if (0 == modulus) {\r\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\r\n                buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\r\n                buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\r\n                buf[pos++] = encodeTable[x & MASK_6BITS];\r\n                currentLinePos += 4;\r\n                if (lineLength > 0 && lineLength <= currentLinePos) {\r\n                    System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\r\n                    pos += lineSeparator.length;\r\n                    currentLinePos = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * <p>\r\n * Encodes all of the provided data, starting at inPos, for inAvail bytes.\r\n * Must be called at least twice:  once with the data to encode, and once\r\n * with inAvail set to \"-1\" to alert encoder that EOF has been reached,\r\n * so flush last remaining bytes (if not multiple of 3).\r\n * <\/p><p>\r\n * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\r\n * and general approach.\r\n * http:\/\/svn.apache.org\/repos\/asf\/webservices\/commons\/trunk\/modules\/util\/\r\n * <\/p>\r\n *\r\n * @param in byte[] array of binary data to base64 encode.\r\n * @param inPos Position to start reading data from.\r\n * @param inAvail Amount of bytes available from input for encoding.\r\n *\/\r\n","code_no_comment":"void encode(byte[] in, int inPos, int inAvail) {\r\n    if (eof) {\r\n        return;\r\n    }\r\n        if (inAvail < 0) {\r\n        eof = true;\r\n        if (buf == null || buf.length - pos < encodeSize) {\r\n            resizeBuf();\r\n        }\r\n        switch(modulus) {\r\n            case 1:\r\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\r\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\r\n                                if (encodeTable == STANDARD_ENCODE_TABLE) {\r\n                    buf[pos++] = PAD;\r\n                    buf[pos++] = PAD;\r\n                }\r\n                break;\r\n            case 2:\r\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\r\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\r\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\r\n                                if (encodeTable == STANDARD_ENCODE_TABLE) {\r\n                    buf[pos++] = PAD;\r\n                }\r\n                break;\r\n        }\r\n        if (lineLength > 0) {\r\n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\r\n            pos += lineSeparator.length;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < inAvail; i++) {\r\n            if (buf == null || buf.length - pos < encodeSize) {\r\n                resizeBuf();\r\n            }\r\n            modulus = (++modulus) % 3;\r\n            int b = in[inPos++];\r\n            if (b < 0) {\r\n                b += 256;\r\n            }\r\n            x = (x << 8) + b;\r\n            if (0 == modulus) {\r\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\r\n                buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\r\n                buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\r\n                buf[pos++] = encodeTable[x & MASK_6BITS];\r\n                currentLinePos += 4;\r\n                if (lineLength > 0 && lineLength <= currentLinePos) {\r\n                    System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\r\n                    pos += lineSeparator.length;\r\n                    currentLinePos = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","lc":1.9545454545,"pi":0.990430622,"ma":2.4,"nbd":1.0,"ml":1.9166666667,"d":5.1150793651,"mi":-1.0188865398,"fo":-0.1666666667,"r":-0.0263157895,"e":15.880101197}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3763_ab1a0cc2","label":1,"code":"public boolean equals(Object object) {\r\n    if (object == EMPTY_NODE || object == MISSING_NODE) {\r\n        return exists == (object == EMPTY_NODE);\r\n    } else if (object instanceof NodeState) {\r\n        NodeState that = (NodeState) object;\r\n        return that.getPropertyCount() == 0 && that.getChildNodeCount(1) == 0;\r\n    } else {\r\n        return false;\r\n    }\r\n}","code_comment":null,"code_no_comment":"public boolean equals(Object object) {\r\n    if (object == EMPTY_NODE || object == MISSING_NODE) {\r\n        return exists == (object == EMPTY_NODE);\r\n    } else if (object instanceof NodeState) {\r\n        NodeState that = (NodeState) object;\r\n        return that.getPropertyCount() == 0 && that.getChildNodeCount(1) == 0;\r\n    } else {\r\n        return false;\r\n    }\r\n}","lc":-0.1818181818,"pi":0.0,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":0.3432539683,"mi":0.1805496829,"fo":-0.3333333333,"r":0.9210526316,"e":0.0706511529}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5261_55c2e2d8","label":1,"code":"public synchronized BlockingQueue<Exchange> createQueue(String uri, Map<String, Object> parameters) {\r\n    String key = getQueueKey(uri);\r\n    QueueReference ref = getQueues().get(key);\r\n    if (ref != null) {\r\n        \/\/ add the reference before returning queue\r\n        ref.addReference();\r\n        return ref.getQueue();\r\n    }\r\n    \/\/ create queue\r\n    BlockingQueue<Exchange> queue;\r\n    Integer size = getAndRemoveParameter(parameters, \"size\", Integer.class);\r\n    if (size != null && size > 0) {\r\n        queue = new LinkedBlockingQueue<Exchange>(size);\r\n    } else {\r\n        if (getQueueSize() > 0) {\r\n            queue = new LinkedBlockingQueue<Exchange>(getQueueSize());\r\n        } else {\r\n            queue = new LinkedBlockingQueue<Exchange>();\r\n        }\r\n    }\r\n    \/\/ create and add a new reference queue\r\n    ref = new QueueReference(queue);\r\n    ref.addReference();\r\n    getQueues().put(key, ref);\r\n    return queue;\r\n}","code_comment":null,"code_no_comment":"public synchronized BlockingQueue<Exchange> createQueue(String uri, Map<String, Object> parameters) {\r\n    String key = getQueueKey(uri);\r\n    QueueReference ref = getQueues().get(key);\r\n    if (ref != null) {\r\n                ref.addReference();\r\n        return ref.getQueue();\r\n    }\r\n        BlockingQueue<Exchange> queue;\r\n    Integer size = getAndRemoveParameter(parameters, \"size\", Integer.class);\r\n    if (size != null && size > 0) {\r\n        queue = new LinkedBlockingQueue<Exchange>(size);\r\n    } else {\r\n        if (getQueueSize() > 0) {\r\n            queue = new LinkedBlockingQueue<Exchange>(getQueueSize());\r\n        } else {\r\n            queue = new LinkedBlockingQueue<Exchange>();\r\n        }\r\n    }\r\n        ref = new QueueReference(queue);\r\n    ref.addReference();\r\n    getQueues().put(key, ref);\r\n    return queue;\r\n}","lc":0.4090909091,"pi":0.019138756,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":0.5654761905,"mi":-0.3423537703,"fo":0.4166666667,"r":-0.0263157895,"e":0.6121125153}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5965_31c88569","label":1,"code":"\/**\r\n *  Handle tag &lt;wicket:header-items&gt;\r\n *\r\n *  @param tag\r\n *\/\r\nprivate void handleHeaderItemsTag(ComponentTag tag) {\r\n    if (foundHeaderItemsTag) {\r\n        throw new MarkupException(new MarkupStream(markup), \"More than one <wicket:header-items\/> detected in the <head> element. Only one is allowed.\");\r\n    } else if (foundClosingHead) {\r\n        throw new MarkupException(new MarkupStream(markup), \"Detected <wicket:header-items\/> after the closing <\/head> element.\");\r\n    }\r\n    foundHeaderItemsTag = true;\r\n    tag.setId(HEADER_ID);\r\n    tag.setAutoComponentTag(true);\r\n    tag.setModified(true);\r\n}","code_comment":"\/**\r\n *  Handle tag &lt;wicket:header-items&gt;\r\n *\r\n *  @param tag\r\n *\/\r\n","code_no_comment":"private void handleHeaderItemsTag(ComponentTag tag) {\r\n    if (foundHeaderItemsTag) {\r\n        throw new MarkupException(new MarkupStream(markup), \"More than one <wicket:header-items\/> detected in the <head> element. Only one is allowed.\");\r\n    } else if (foundClosingHead) {\r\n        throw new MarkupException(new MarkupStream(markup), \"Detected <wicket:header-items\/> after the closing <\/head> element.\");\r\n    }\r\n    foundHeaderItemsTag = true;\r\n    tag.setId(HEADER_ID);\r\n    tag.setAutoComponentTag(true);\r\n    tag.setModified(true);\r\n}","lc":-0.1363636364,"pi":-0.2775119617,"ma":0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.1661733615,"fo":-0.25,"r":0.1578947368,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"\/**\r\n *  @param detailed\r\n *             True if a detailed string is desired\r\n *  @return String representation of this container\r\n *\/\r\n@Override\r\npublic String toString(final boolean detailed) {\r\n    final StringBuffer buffer = new StringBuffer();\r\n    buffer.append(\"[MarkupContainer \");\r\n    buffer.append(super.toString(true));\r\n    if (detailed) {\r\n        if (getMarkupStream() != null) {\r\n            buffer.append(\", markupStream = \" + getMarkupStream());\r\n        }\r\n        if (children_size() != 0) {\r\n            buffer.append(\", children = \");\r\n            \/\/ Loop through child components\r\n            final int size = children_size();\r\n            for (int i = 0; i < size; i++) {\r\n                \/\/ Get next child\r\n                final Component child = children_get(i);\r\n                if (i != 0) {\r\n                    buffer.append(' ');\r\n                }\r\n                buffer.append(child.toString());\r\n            }\r\n        }\r\n    }\r\n    buffer.append(']');\r\n    return buffer.toString();\r\n}","code_comment":"\/**\r\n *  @param detailed\r\n *             True if a detailed string is desired\r\n *  @return String representation of this container\r\n *\/\r\n","code_no_comment":"@Override\r\npublic String toString(final boolean detailed) {\r\n    final StringBuffer buffer = new StringBuffer();\r\n    buffer.append(\"[MarkupContainer \");\r\n    buffer.append(super.toString(true));\r\n    if (detailed) {\r\n        if (getMarkupStream() != null) {\r\n            buffer.append(\", markupStream = \" + getMarkupStream());\r\n        }\r\n        if (children_size() != 0) {\r\n            buffer.append(\", children = \");\r\n                        final int size = children_size();\r\n            for (int i = 0; i < size; i++) {\r\n                                final Component child = children_get(i);\r\n                if (i != 0) {\r\n                    buffer.append(' ');\r\n                }\r\n                buffer.append(child.toString());\r\n            }\r\n        }\r\n    }\r\n    buffer.append(']');\r\n    return buffer.toString();\r\n}","lc":0.4545454545,"pi":1.2918660287,"ma":0.4,"nbd":1.0,"ml":0.4166666667,"d":0.5317460317,"mi":-0.3477096547,"fo":0.75,"r":0.0526315789,"e":0.4585559263}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4116_4624ab3d","label":1,"code":"\/**\r\n *  Looks up a page by id from the {@link IPageStore}. <br\/>\r\n *  If {@linkplain #pageClass} is specified then compares it against the stored instance class\r\n *  and returns the found instance only if they match.\r\n *\r\n *  @param pageId\r\n *             the id of the page to look for.\r\n *  @return the found page instance by id.\r\n *\/\r\nprivate IRequestablePage getStoredPage(final int pageId) {\r\n    IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);\r\n    if (storedPageInstance != null && (pageClass == null || pageClass.equals(storedPageInstance.getClass()))) {\r\n        pageInstance = storedPageInstance;\r\n    }\r\n    return storedPageInstance;\r\n}","code_comment":"\/**\r\n *  Looks up a page by id from the {@link IPageStore}. <br\/>\r\n *  If {@linkplain #pageClass} is specified then compares it against the stored instance class\r\n *  and returns the found instance only if they match.\r\n *\r\n *  @param pageId\r\n *             the id of the page to look for.\r\n *  @return the found page instance by id.\r\n *\/\r\n","code_no_comment":"private IRequestablePage getStoredPage(final int pageId) {\r\n    IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);\r\n    if (storedPageInstance != null && (pageClass == null || pageClass.equals(storedPageInstance.getClass()))) {\r\n        pageInstance = storedPageInstance;\r\n    }\r\n    return storedPageInstance;\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":0.1666666667,"d":0.2956349206,"mi":0.3919661734,"fo":-0.1666666667,"r":1.8947368421,"e":0.0005278839}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1877_716e1237","label":0,"code":"private static NodeBuilder postAsyncRunNodeStatus(NodeBuilder builder, String name) {\r\n    String now = now();\r\n    builder.getChildNode(INDEX_DEFINITIONS_NAME).setProperty(name + \"-status\", STATUS_DONE).setProperty(name + \"-done\", now, Type.DATE).removeProperty(name + \"-start\");\r\n    return builder;\r\n}","code_comment":null,"code_no_comment":"private static NodeBuilder postAsyncRunNodeStatus(NodeBuilder builder, String name) {\r\n    String now = now();\r\n    builder.getChildNode(INDEX_DEFINITIONS_NAME).setProperty(name + \"-status\", STATUS_DONE).setProperty(name + \"-done\", now, Type.DATE).removeProperty(name + \"-start\");\r\n    return builder;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.0496031746,"mi":0.5207892882,"fo":-0.0833333333,"r":0.0,"e":-0.0663681472}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2695_0598498e","label":0,"code":"@Nonnull\r\n@Override\r\npublic NodeState getChildNode(@Nonnull String name) {\r\n    if (!hasChildren) {\r\n        checkValidName(name);\r\n        return EmptyNodeState.MISSING_NODE;\r\n    }\r\n    String p = PathUtils.concat(getPath(), name);\r\n    DocumentNodeState child = store.getNode(p, lastRevision);\r\n    if (child == null) {\r\n        checkValidName(name);\r\n        return EmptyNodeState.MISSING_NODE;\r\n    } else {\r\n        return child;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\n@Override\r\npublic NodeState getChildNode(@Nonnull String name) {\r\n    if (!hasChildren) {\r\n        checkValidName(name);\r\n        return EmptyNodeState.MISSING_NODE;\r\n    }\r\n    String p = PathUtils.concat(getPath(), name);\r\n    DocumentNodeState child = store.getNode(p, lastRevision);\r\n    if (child == null) {\r\n        checkValidName(name);\r\n        return EmptyNodeState.MISSING_NODE;\r\n    } else {\r\n        return child;\r\n    }\r\n}","lc":0.0909090909,"pi":0.0,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0634920635,"mi":-0.0565186751,"fo":-0.0833333333,"r":0.3684210526,"e":-0.0468341373}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-510_f63d745a","label":1,"code":"\/**\r\n * Create a single value property state given a {@code name}, a {@code type}, a\r\n * {@code value} and a property {@code definition}. If the type does not match the\r\n * property definition it is converted accordingly\r\n *\r\n * @param name\r\n * @param type\r\n * @param values\r\n * @param definition\r\n * @return  array valued property state\r\n * @throws ValueFormatException  if {@code definition} does not define a multi valued property\r\n * @throws RepositoryException  if value conversion fails\r\n *\/\r\nPropertyState createMultiState(String name, int type, Value[] values, PropertyDefinition definition) throws RepositoryException {\r\n    if (!definition.isMultiple()) {\r\n        throw new ValueFormatException(\"Cannot set value array to single value property\");\r\n    }\r\n    Value[] nonNullValues = compact(values);\r\n    int targetType = getType(definition, type);\r\n    if (nonNullValues.length == 0) {\r\n        return MemoryPropertyBuilder.array(Type.fromTag(type, false), name).getPropertyState();\r\n    } else if (targetType == type) {\r\n        return PropertyStates.createProperty(name, Arrays.asList(nonNullValues));\r\n    } else {\r\n        return PropertyStates.createProperty(name, Arrays.asList(ValueHelper.convert(values, targetType, getValueFactory())));\r\n    }\r\n}","code_comment":"\/**\r\n * Create a single value property state given a {@code name}, a {@code type}, a\r\n * {@code value} and a property {@code definition}. If the type does not match the\r\n * property definition it is converted accordingly\r\n *\r\n * @param name\r\n * @param type\r\n * @param values\r\n * @param definition\r\n * @return  array valued property state\r\n * @throws ValueFormatException  if {@code definition} does not define a multi valued property\r\n * @throws RepositoryException  if value conversion fails\r\n *\/\r\n","code_no_comment":"PropertyState createMultiState(String name, int type, Value[] values, PropertyDefinition definition) throws RepositoryException {\r\n    if (!definition.isMultiple()) {\r\n        throw new ValueFormatException(\"Cannot set value array to single value property\");\r\n    }\r\n    Value[] nonNullValues = compact(values);\r\n    int targetType = getType(definition, type);\r\n    if (nonNullValues.length == 0) {\r\n        return MemoryPropertyBuilder.array(Type.fromTag(type, false), name).getPropertyState();\r\n    } else if (targetType == type) {\r\n        return PropertyStates.createProperty(name, Arrays.asList(nonNullValues));\r\n    } else {\r\n        return PropertyStates.createProperty(name, Arrays.asList(ValueHelper.convert(values, targetType, getValueFactory())));\r\n    }\r\n}","lc":0.0,"pi":-0.2057416268,"ma":0.2,"nbd":0.0,"ml":0.1666666667,"d":-0.0515873016,"mi":-0.0934460888,"fo":0.5,"r":-0.0263157895,"e":0.0512877255}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-846_7acb091a","label":3,"code":"@Override\r\nvoid uncommittedModification(Revision uncommitted) {\r\n    if (collisions.get() == null) {\r\n        collisions.set(new ArrayList<Revision>());\r\n    }\r\n    collisions.get().add(uncommitted);\r\n}","code_comment":null,"code_no_comment":"@Override\r\nvoid uncommittedModification(Revision uncommitted) {\r\n    if (collisions.get() == null) {\r\n        collisions.set(new ArrayList<Revision>());\r\n    }\r\n    collisions.get().add(uncommitted);\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.4734319944,"fo":-0.1666666667,"r":0.4473684211,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-4542_c408c3ed","label":1,"code":"@Override\r\npublic Expression createExpression(CamelContext camelContext) {\r\n    Expression answer;\r\n    if (beanType == null && beanTypeName != null) {\r\n        try {\r\n            beanType = camelContext.getClassResolver().resolveMandatoryClass(beanTypeName);\r\n        } catch (ClassNotFoundException e) {\r\n            throw ObjectHelper.wrapRuntimeCamelException(e);\r\n        }\r\n    }\r\n    if (beanType != null) {\r\n        \/\/ create a bean if there is a default public no-arg constructor\r\n        if (ObjectHelper.hasDefaultPublicNoArgConstructor(beanType)) {\r\n            instance = camelContext.getInjector().newInstance(beanType);\r\n            answer = new BeanExpression(instance, getMethod());\r\n        } else {\r\n            answer = new BeanExpression(beanType, getMethod());\r\n        }\r\n    } else if (instance != null) {\r\n        answer = new BeanExpression(instance, getMethod());\r\n    } else {\r\n        String ref = beanName();\r\n        \/\/ if its a ref then check that the ref exists\r\n        BeanHolder holder = new RegistryBean(camelContext, ref);\r\n        \/\/ get the bean which will check that it exists\r\n        instance = holder.getBean();\r\n        answer = new BeanExpression(ref, getMethod());\r\n    }\r\n    validateHasMethod(camelContext, instance, beanType, getMethod());\r\n    return answer;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Expression createExpression(CamelContext camelContext) {\r\n    Expression answer;\r\n    if (beanType == null && beanTypeName != null) {\r\n        try {\r\n            beanType = camelContext.getClassResolver().resolveMandatoryClass(beanTypeName);\r\n        } catch (ClassNotFoundException e) {\r\n            throw ObjectHelper.wrapRuntimeCamelException(e);\r\n        }\r\n    }\r\n    if (beanType != null) {\r\n                if (ObjectHelper.hasDefaultPublicNoArgConstructor(beanType)) {\r\n            instance = camelContext.getInjector().newInstance(beanType);\r\n            answer = new BeanExpression(instance, getMethod());\r\n        } else {\r\n            answer = new BeanExpression(beanType, getMethod());\r\n        }\r\n    } else if (instance != null) {\r\n        answer = new BeanExpression(instance, getMethod());\r\n    } else {\r\n        String ref = beanName();\r\n                BeanHolder holder = new RegistryBean(camelContext, ref);\r\n                instance = holder.getBean();\r\n        answer = new BeanExpression(ref, getMethod());\r\n    }\r\n    validateHasMethod(camelContext, instance, beanType, getMethod());\r\n    return answer;\r\n}","lc":0.6363636364,"pi":0.2822966507,"ma":0.6,"nbd":0.0,"ml":0.3333333333,"d":0.5218253968,"mi":-0.4720225511,"fo":0.6666666667,"r":-0.0263157895,"e":0.6858041873}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3333_ddf7e8a2","label":0,"code":"\/**\r\n *  Handles this link's tag. OVERRIDES MUST CALL SUPER.\r\n *\r\n *  @param tag\r\n *             the component tag\r\n *  @see org.apache.wicket.Component#onComponentTag(ComponentTag)\r\n *\/\r\n@Override\r\nprotected void onComponentTag(final ComponentTag tag) {\r\n    \/\/ Default handling for tag\r\n    super.onComponentTag(tag);\r\n    \/\/ Set href to link to this link's linkClicked method\r\n    CharSequence url = getURL();\r\n    \/\/ append any anchor\r\n    url = appendAnchor(tag, url);\r\n    \/\/ If we're disabled\r\n    if (!isLinkEnabled()) {\r\n        disableLink(tag);\r\n    } else {\r\n        \/\/ if the tag is an anchor proper\r\n        if (tag.getName().equalsIgnoreCase(\"a\") || tag.getName().equalsIgnoreCase(\"link\") || tag.getName().equalsIgnoreCase(\"area\")) {\r\n            \/\/ generate the href attribute\r\n            tag.put(\"href\", Strings.replaceAll(url, \"&\", \"&amp;\"));\r\n            \/\/ Add any popup script\r\n            if (popupSettings != null) {\r\n                \/\/ NOTE: don't encode to HTML as that is not valid\r\n                \/\/ JavaScript\r\n                tag.put(\"onclick\", popupSettings.getPopupJavaScript());\r\n            }\r\n        } else if (tag.getName().equalsIgnoreCase(\"script\") || tag.getName().equalsIgnoreCase(\"style\")) {\r\n            tag.put(\"src\", Strings.replaceAll(url, \"&\", \"&amp;\"));\r\n        } else {\r\n            \/\/ generate a popup script by asking popup settings for one\r\n            if (popupSettings != null) {\r\n                popupSettings.setTarget(\"'\" + url + \"'\");\r\n                String popupScript = popupSettings.getPopupJavaScript();\r\n                tag.put(\"onclick\", popupScript);\r\n            } else {\r\n                \/\/ or generate an onclick JS handler directly\r\n                \/\/ in firefox when the element is quickly clicked 3 times a second request is\r\n                \/\/ generated during page load. This check ensures that the click is ignored\r\n                tag.put(\"onclick\", \"var win = this.ownerDocument.defaultView || this.ownerDocument.parentWindow; \" + \"if (win == window) { window.location.href='\" + Strings.replaceAll(url, \"&\", \"&amp;\") + \"'; } ;return false\");\r\n            }\r\n        }\r\n        \/\/ If the subclass specified javascript, use that\r\n        final CharSequence onClickJavaScript = getOnClickScript(url);\r\n        if (onClickJavaScript != null) {\r\n            tag.put(\"onclick\", onClickJavaScript);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  Handles this link's tag. OVERRIDES MUST CALL SUPER.\r\n *\r\n *  @param tag\r\n *             the component tag\r\n *  @see org.apache.wicket.Component#onComponentTag(ComponentTag)\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void onComponentTag(final ComponentTag tag) {\r\n        super.onComponentTag(tag);\r\n        CharSequence url = getURL();\r\n        url = appendAnchor(tag, url);\r\n        if (!isLinkEnabled()) {\r\n        disableLink(tag);\r\n    } else {\r\n                if (tag.getName().equalsIgnoreCase(\"a\") || tag.getName().equalsIgnoreCase(\"link\") || tag.getName().equalsIgnoreCase(\"area\")) {\r\n                        tag.put(\"href\", Strings.replaceAll(url, \"&\", \"&amp;\"));\r\n                        if (popupSettings != null) {\r\n                                                tag.put(\"onclick\", popupSettings.getPopupJavaScript());\r\n            }\r\n        } else if (tag.getName().equalsIgnoreCase(\"script\") || tag.getName().equalsIgnoreCase(\"style\")) {\r\n            tag.put(\"src\", Strings.replaceAll(url, \"&\", \"&amp;\"));\r\n        } else {\r\n                        if (popupSettings != null) {\r\n                popupSettings.setTarget(\"'\" + url + \"'\");\r\n                String popupScript = popupSettings.getPopupJavaScript();\r\n                tag.put(\"onclick\", popupScript);\r\n            } else {\r\n                                                                tag.put(\"onclick\", \"var win = this.ownerDocument.defaultView || this.ownerDocument.parentWindow; \" + \"if (win == window) { window.location.href='\" + Strings.replaceAll(url, \"&\", \"&amp;\") + \"'; } ;return false\");\r\n            }\r\n        }\r\n                final CharSequence onClickJavaScript = getOnClickScript(url);\r\n        if (onClickJavaScript != null) {\r\n            tag.put(\"onclick\", onClickJavaScript);\r\n        }\r\n    }\r\n}","lc":0.7272727273,"pi":0.9090909091,"ma":0.6,"nbd":1.0,"ml":1.0,"d":0.6369047619,"mi":-0.5565891473,"fo":1.8333333333,"r":-0.0263157895,"e":1.2149789941}
{"project_name":"Lang","project_version":"15","label":1,"code":"\/**\r\n * <p> Return a map of the type arguments of a class in the context of <code>toClass<\/code>. <\/p>\r\n *\r\n * @param cls the class in question\r\n * @param toClass the context class\r\n * @param subtypeVarAssigns a map with type variables\r\n * @return the map with type arguments\r\n *\/\r\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns) {\r\n    \/\/ make sure they're assignable\r\n    if (!isAssignable(cls, toClass)) {\r\n        return null;\r\n    }\r\n    \/\/ can't work with primitives\r\n    if (cls.isPrimitive()) {\r\n        \/\/ both classes are primitives?\r\n        if (toClass.isPrimitive()) {\r\n            \/\/ harvested with these two types.\r\n            return new HashMap<TypeVariable<?>, Type>();\r\n        }\r\n        \/\/ work with wrapper the wrapper class instead of the primitive\r\n        cls = ClassUtils.primitiveToWrapper(cls);\r\n    }\r\n    \/\/ create a copy of the incoming map, or an empty one if it's null\r\n    HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\r\n    \/\/ has target class been reached?\r\n    if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\r\n        return typeVarAssigns;\r\n    }\r\n    \/\/ walk the inheritance hierarchy until the target class is reached\r\n    return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\r\n}","code_comment":"\/**\r\n * <p> Return a map of the type arguments of a class in the context of <code>toClass<\/code>. <\/p>\r\n *\r\n * @param cls the class in question\r\n * @param toClass the context class\r\n * @param subtypeVarAssigns a map with type variables\r\n * @return the map with type arguments\r\n *\/\r\n","code_no_comment":"private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns) {\r\n        if (!isAssignable(cls, toClass)) {\r\n        return null;\r\n    }\r\n        if (cls.isPrimitive()) {\r\n                if (toClass.isPrimitive()) {\r\n                        return new HashMap<TypeVariable<?>, Type>();\r\n        }\r\n                cls = ClassUtils.primitiveToWrapper(cls);\r\n    }\r\n        HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\r\n        if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\r\n        return typeVarAssigns;\r\n    }\r\n        return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\r\n}","lc":0.0909090909,"pi":0.038277512,"ma":0.4,"nbd":0.0,"ml":0.75,"d":0.6746031746,"mi":-0.1568710359,"fo":0.1666666667,"r":-0.0263157895,"e":0.5296335356}
{"project_name":"Closure","project_version":"76","label":2,"code":"\/**\r\n * Given a variable, node n in the tree and a sub-tree denoted by exprRoot as\r\n * the root, this function returns true if there exists a read of that\r\n * variable before a write to that variable that is on the right side of n.\r\n *\r\n * For example, suppose the node is x = 1:\r\n *\r\n * y = 1, x = 1; \/\/ false, there is no reads at all.\r\n * y = 1, x = 1, print(x) \/\/ true, there is a read right of n.\r\n * y = 1, x = 1, x = 2, print(x) \/\/ false, there is a read right of n but\r\n *                               \/\/ it is after a write.\r\n *\r\n * @param n The current node we should look at.\r\n * @param exprRoot The node\r\n *\/\r\nprivate boolean isVariableStillLiveWithinExpression(Node n, Node exprRoot, String variable) {\r\n    while (n != exprRoot) {\r\n        VariableLiveness state = VariableLiveness.MAYBE_LIVE;\r\n        switch(n.getParent().getType()) {\r\n            case Token.OR:\r\n            case Token.AND:\r\n            case Token.HOOK:\r\n            default:\r\n                for (Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) {\r\n                    if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\r\n                        state = isVariableReadBeforeKill(sibling, variable);\r\n                        \/\/ If we see a READ or KILL there is no need to continue.\r\n                        if (state == VariableLiveness.READ) {\r\n                            return true;\r\n                        } else if (state == VariableLiveness.KILL) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n        }\r\n        n = n.getParent();\r\n    }\r\n    return false;\r\n}","code_comment":"\/**\r\n * Given a variable, node n in the tree and a sub-tree denoted by exprRoot as\r\n * the root, this function returns true if there exists a read of that\r\n * variable before a write to that variable that is on the right side of n.\r\n *\r\n * For example, suppose the node is x = 1:\r\n *\r\n * y = 1, x = 1; \/\/ false, there is no reads at all.\r\n * y = 1, x = 1, print(x) \/\/ true, there is a read right of n.\r\n * y = 1, x = 1, x = 2, print(x) \/\/ false, there is a read right of n but\r\n *                               \/\/ it is after a write.\r\n *\r\n * @param n The current node we should look at.\r\n * @param exprRoot The node\r\n *\/\r\n","code_no_comment":"private boolean isVariableStillLiveWithinExpression(Node n, Node exprRoot, String variable) {\r\n    while (n != exprRoot) {\r\n        VariableLiveness state = VariableLiveness.MAYBE_LIVE;\r\n        switch(n.getParent().getType()) {\r\n            case Token.OR:\r\n            case Token.AND:\r\n            case Token.HOOK:\r\n            default:\r\n                for (Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) {\r\n                    if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\r\n                        state = isVariableReadBeforeKill(sibling, variable);\r\n                                                if (state == VariableLiveness.READ) {\r\n                            return true;\r\n                        } else if (state == VariableLiveness.KILL) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n        }\r\n        n = n.getParent();\r\n    }\r\n    return false;\r\n}","lc":0.4090909091,"pi":2.7081339713,"ma":1.2,"nbd":2.5,"ml":0.75,"d":0.4126984127,"mi":-0.354756871,"fo":0.0833333333,"r":-0.0263157895,"e":0.3785803611}
{"project_name":"Codec","project_version":"3","label":3,"code":"\/**\r\n * Handles 'G' cases\r\n *\/\r\nprivate int handleG(String value, DoubleMetaphoneResult result, int index, boolean slavoGermanic) {\r\n    if (charAt(value, index + 1) == 'H') {\r\n        index = handleGH(value, result, index);\r\n    } else if (charAt(value, index + 1) == 'N') {\r\n        if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\r\n            result.append(\"KN\", \"N\");\r\n        } else if (!contains(value, index + 2, 2, \"EY\") && charAt(value, index + 1) != 'Y' && !slavoGermanic) {\r\n            result.append(\"N\", \"KN\");\r\n        } else {\r\n            result.append(\"KN\");\r\n        }\r\n        index = index + 2;\r\n    } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\r\n        result.append(\"KL\", \"L\");\r\n        index += 2;\r\n    } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\r\n        \/\/ -- -ges-, -gep-, -gel-, -gie- at beginning --\/\/\r\n        result.append('K', 'J');\r\n        index += 2;\r\n    } else if ((contains(value, index + 1, 2, \"ER\") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") && !contains(value, index - 1, 1, \"E\", \"I\") && !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\r\n        \/\/ -- -ger-, -gy- --\/\/\r\n        result.append('K', 'J');\r\n        index += 2;\r\n    } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\r\n        \/\/ -- Italian \"biaggi\" --\/\/\r\n        if ((contains(value, 0, 4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\r\n            \/\/ -- obvious germanic --\/\/\r\n            result.append('K');\r\n        } else if (contains(value, index + 1, 4, \"IER\")) {\r\n            result.append('J');\r\n        } else {\r\n            result.append('J', 'K');\r\n        }\r\n        index += 2;\r\n    } else if (charAt(value, index + 1) == 'G') {\r\n        index += 2;\r\n        result.append('K');\r\n    } else {\r\n        index++;\r\n        result.append('K');\r\n    }\r\n    return index;\r\n}","code_comment":"\/**\r\n * Handles 'G' cases\r\n *\/\r\n","code_no_comment":"private int handleG(String value, DoubleMetaphoneResult result, int index, boolean slavoGermanic) {\r\n    if (charAt(value, index + 1) == 'H') {\r\n        index = handleGH(value, result, index);\r\n    } else if (charAt(value, index + 1) == 'N') {\r\n        if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\r\n            result.append(\"KN\", \"N\");\r\n        } else if (!contains(value, index + 2, 2, \"EY\") && charAt(value, index + 1) != 'Y' && !slavoGermanic) {\r\n            result.append(\"N\", \"KN\");\r\n        } else {\r\n            result.append(\"KN\");\r\n        }\r\n        index = index + 2;\r\n    } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\r\n        result.append(\"KL\", \"L\");\r\n        index += 2;\r\n    } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\r\n                result.append('K', 'J');\r\n        index += 2;\r\n    } else if ((contains(value, index + 1, 2, \"ER\") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") && !contains(value, index - 1, 1, \"E\", \"I\") && !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\r\n                result.append('K', 'J');\r\n        index += 2;\r\n    } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\r\n                if ((contains(value, 0, 4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\r\n                        result.append('K');\r\n        } else if (contains(value, index + 1, 4, \"IER\")) {\r\n            result.append('J');\r\n        } else {\r\n            result.append('J', 'K');\r\n        }\r\n        index += 2;\r\n    } else if (charAt(value, index + 1) == 'G') {\r\n        index += 2;\r\n        result.append('K');\r\n    } else {\r\n        index++;\r\n        result.append('K');\r\n    }\r\n    return index;\r\n}","lc":1.1363636364,"pi":0.019138756,"ma":1.6,"nbd":3.0,"ml":3.25,"d":3.753968254,"mi":-0.836222692,"fo":2.25,"r":-0.0263157895,"e":13.3443359094}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-847_65aa40dd","label":3,"code":"private static boolean checkConditions(Map<String, Object> target, UpdateOp update) {\r\n    for (Map.Entry<String, Operation> change : update.changes.entrySet()) {\r\n        Operation op = change.getValue();\r\n        if (op.type == Operation.Type.CONTAINS_MAP_ENTRY) {\r\n            String k = change.getKey();\r\n            String[] kv = k.split(\"\\\\.\");\r\n            Object value = target.get(kv[0]);\r\n            if (value == null) {\r\n                if (Boolean.TRUE.equals(op.value)) {\r\n                    return false;\r\n                }\r\n            } else {\r\n                if (value instanceof java.util.Collection) {\r\n                    java.util.Collection<?> col = (java.util.Collection<?>) value;\r\n                    if (Boolean.TRUE.equals(op.value)) {\r\n                        if (!col.contains(kv[1])) {\r\n                            return false;\r\n                        }\r\n                    } else {\r\n                        if (col.contains(kv[1])) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                } else {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"private static boolean checkConditions(Map<String, Object> target, UpdateOp update) {\r\n    for (Map.Entry<String, Operation> change : update.changes.entrySet()) {\r\n        Operation op = change.getValue();\r\n        if (op.type == Operation.Type.CONTAINS_MAP_ENTRY) {\r\n            String k = change.getKey();\r\n            String[] kv = k.split(\"\\\\.\");\r\n            Object value = target.get(kv[0]);\r\n            if (value == null) {\r\n                if (Boolean.TRUE.equals(op.value)) {\r\n                    return false;\r\n                }\r\n            } else {\r\n                if (value instanceof java.util.Collection) {\r\n                    java.util.Collection<?> col = (java.util.Collection<?>) value;\r\n                    if (Boolean.TRUE.equals(op.value)) {\r\n                        if (!col.contains(kv[1])) {\r\n                            return false;\r\n                        }\r\n                    } else {\r\n                        if (col.contains(kv[1])) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                } else {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}","lc":0.7727272727,"pi":2.2440191388,"ma":1.0,"nbd":2.0,"ml":0.5833333333,"d":0.0376984127,"mi":-0.5461592671,"fo":0.25,"r":-0.0263157895,"e":0.2626349245}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"public void recv_update() throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException {\r\n    update_result result = new update_result();\r\n    receiveBase(result, \"update\");\r\n    if (result.ouch1 != null) {\r\n        throw result.ouch1;\r\n    }\r\n    if (result.ouch2 != null) {\r\n        throw result.ouch2;\r\n    }\r\n    return;\r\n}","code_comment":null,"code_no_comment":"public void recv_update() throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException {\r\n    update_result result = new update_result();\r\n    receiveBase(result, \"update\");\r\n    if (result.ouch1 != null) {\r\n        throw result.ouch1;\r\n    }\r\n    if (result.ouch2 != null) {\r\n        throw result.ouch2;\r\n    }\r\n    return;\r\n}","lc":-0.1363636364,"pi":-0.2775119617,"ma":0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0476190476,"mi":0.1605355884,"fo":-0.4166666667,"r":0.0,"e":-0.081384024}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3388_0919a0f6","label":1,"code":"\/**\r\n * Returns an expression for the outbound message headers\r\n *\r\n * @return an expression object which will return the headers\r\n *\/\r\npublic static Expression outHeadersExpression() {\r\n    return new ExpressionAdapter() {\r\n\r\n        public Object evaluate(Exchange exchange) {\r\n            return exchange.getOut().getHeaders();\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"outHeaders\";\r\n        }\r\n    };\r\n}","code_comment":"\/**\r\n * Returns an expression for the outbound message headers\r\n *\r\n * @return an expression object which will return the headers\r\n *\/\r\n","code_no_comment":"public static Expression outHeadersExpression() {\r\n    return new ExpressionAdapter() {\r\n\r\n        public Object evaluate(Exchange exchange) {\r\n            return exchange.getOut().getHeaders();\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"outHeaders\";\r\n        }\r\n    };\r\n}","lc":-0.1363636364,"pi":0.4449760766,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.2831571529,"fo":-0.3333333333,"r":2.1052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-498_f2a2edec","label":1,"code":"public static boolean validate(String jcrPath) {\r\n    Listener listener = new Listener() {\r\n\r\n        boolean hasRoot;\r\n\r\n        @Override\r\n        public boolean root() {\r\n            if (hasRoot) {\r\n                return false;\r\n            } else {\r\n                hasRoot = true;\r\n                return true;\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public boolean current() {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean parent() {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public void error(String message) {\r\n        }\r\n\r\n        @Override\r\n        public boolean name(String name, int index) {\r\n            return true;\r\n        }\r\n    };\r\n    return parse(jcrPath, listener);\r\n}","code_comment":null,"code_no_comment":"public static boolean validate(String jcrPath) {\r\n    Listener listener = new Listener() {\r\n\r\n        boolean hasRoot;\r\n\r\n        @Override\r\n        public boolean root() {\r\n            if (hasRoot) {\r\n                return false;\r\n            } else {\r\n                hasRoot = true;\r\n                return true;\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public boolean current() {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean parent() {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public void error(String message) {\r\n        }\r\n\r\n        @Override\r\n        public boolean name(String name, int index) {\r\n            return true;\r\n        }\r\n    };\r\n    return parse(jcrPath, listener);\r\n}","lc":0.7272727273,"pi":0.4258373206,"ma":-0.4,"nbd":0.0,"ml":-0.25,"d":-0.3650793651,"mi":-0.3260042283,"fo":-0.4166666667,"r":0.5526315789,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1705_5308ac83","label":1,"code":"\/**\r\n *  Returns the host name of the instance. If the host name could not be determined, the return value will be a\r\n *  textual representation of the instance's IP address.\r\n *\r\n *  @return the host name of the instance\r\n *\/\r\npublic String getFQDNHostname() {\r\n    return this.fqdnHostName;\r\n}","code_comment":"\/**\r\n *  Returns the host name of the instance. If the host name could not be determined, the return value will be a\r\n *  textual representation of the instance's IP address.\r\n *\r\n *  @return the host name of the instance\r\n *\/\r\n","code_no_comment":"public String getFQDNHostname() {\r\n    return this.fqdnHostName;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1646229739,"fo":-0.5,"r":2.4210526316,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3104_38f5ef13","label":3,"code":"public static void setDeleted(@Nonnull UpdateOp op, @Nonnull Revision revision, boolean deleted) {\r\n    if (deleted) {\r\n        \/\/ DELETED_ONCE would be set upon every delete.\r\n        \/\/ possibly we can avoid that\r\n        checkNotNull(op).set(DELETED_ONCE, Boolean.TRUE);\r\n    }\r\n    checkNotNull(op).setMapEntry(DELETED, checkNotNull(revision), String.valueOf(deleted));\r\n}","code_comment":null,"code_no_comment":"public static void setDeleted(@Nonnull UpdateOp op, @Nonnull Revision revision, boolean deleted) {\r\n    if (deleted) {\r\n                        checkNotNull(op).set(DELETED_ONCE, Boolean.TRUE);\r\n    }\r\n    checkNotNull(op).setMapEntry(DELETED, checkNotNull(revision), String.valueOf(deleted));\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.4680761099,"fo":0.0,"r":0.1315789474,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2434_8159fc21","label":1,"code":"static Query getFullTextQuery(FullTextExpression ft, final Analyzer analyzer, final IndexReader reader) {\r\n    \/\/ a reference to the query, so it can be set in the visitor\r\n    \/\/ (a \"non-local return\")\r\n    final AtomicReference<Query> result = new AtomicReference<Query>();\r\n    ft.accept(new FullTextVisitor() {\r\n\r\n        @Override\r\n        public boolean visit(FullTextContains contains) {\r\n            return contains.getBase().accept(this);\r\n        }\r\n\r\n        @Override\r\n        public boolean visit(FullTextOr or) {\r\n            BooleanQuery q = new BooleanQuery();\r\n            for (FullTextExpression e : or.list) {\r\n                Query x = getFullTextQuery(e, analyzer, reader);\r\n                q.add(x, SHOULD);\r\n            }\r\n            result.set(q);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean visit(FullTextAnd and) {\r\n            BooleanQuery q = new BooleanQuery();\r\n            for (FullTextExpression e : and.list) {\r\n                Query x = getFullTextQuery(e, analyzer, reader);\r\n                \/\/ Lucene can't deal with \"must(must_not(x))\"\r\n                if (x instanceof BooleanQuery) {\r\n                    BooleanQuery bq = (BooleanQuery) x;\r\n                    for (BooleanClause c : bq.clauses()) {\r\n                        q.add(c);\r\n                    }\r\n                } else {\r\n                    q.add(x, MUST);\r\n                }\r\n            }\r\n            result.set(q);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean visit(FullTextTerm term) {\r\n            return visitTerm(term.getPropertyName(), term.getText(), term.getBoost(), term.isNot());\r\n        }\r\n\r\n        private boolean visitTerm(String propertyName, String text, String boost, boolean not) {\r\n            String p = propertyName;\r\n            if (p != null && p.indexOf('\/') >= 0) {\r\n                p = getName(p);\r\n            }\r\n            Query q = tokenToQuery(text, p, analyzer, reader);\r\n            if (q == null) {\r\n                return false;\r\n            }\r\n            if (boost != null) {\r\n                q.setBoost(Float.parseFloat(boost));\r\n            }\r\n            if (not) {\r\n                BooleanQuery bq = new BooleanQuery();\r\n                bq.add(q, MUST_NOT);\r\n                result.set(bq);\r\n            } else {\r\n                result.set(q);\r\n            }\r\n            return true;\r\n        }\r\n    });\r\n    return result.get();\r\n}","code_comment":null,"code_no_comment":"static Query getFullTextQuery(FullTextExpression ft, final Analyzer analyzer, final IndexReader reader) {\r\n            final AtomicReference<Query> result = new AtomicReference<Query>();\r\n    ft.accept(new FullTextVisitor() {\r\n\r\n        @Override\r\n        public boolean visit(FullTextContains contains) {\r\n            return contains.getBase().accept(this);\r\n        }\r\n\r\n        @Override\r\n        public boolean visit(FullTextOr or) {\r\n            BooleanQuery q = new BooleanQuery();\r\n            for (FullTextExpression e : or.list) {\r\n                Query x = getFullTextQuery(e, analyzer, reader);\r\n                q.add(x, SHOULD);\r\n            }\r\n            result.set(q);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean visit(FullTextAnd and) {\r\n            BooleanQuery q = new BooleanQuery();\r\n            for (FullTextExpression e : and.list) {\r\n                Query x = getFullTextQuery(e, analyzer, reader);\r\n                                if (x instanceof BooleanQuery) {\r\n                    BooleanQuery bq = (BooleanQuery) x;\r\n                    for (BooleanClause c : bq.clauses()) {\r\n                        q.add(c);\r\n                    }\r\n                } else {\r\n                    q.add(x, MUST);\r\n                }\r\n            }\r\n            result.set(q);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean visit(FullTextTerm term) {\r\n            return visitTerm(term.getPropertyName(), term.getText(), term.getBoost(), term.isNot());\r\n        }\r\n\r\n        private boolean visitTerm(String propertyName, String text, String boost, boolean not) {\r\n            String p = propertyName;\r\n            if (p != null && p.indexOf('\/') >= 0) {\r\n                p = getName(p);\r\n            }\r\n            Query q = tokenToQuery(text, p, analyzer, reader);\r\n            if (q == null) {\r\n                return false;\r\n            }\r\n            if (boost != null) {\r\n                q.setBoost(Float.parseFloat(boost));\r\n            }\r\n            if (not) {\r\n                BooleanQuery bq = new BooleanQuery();\r\n                bq.add(q, MUST_NOT);\r\n                result.set(bq);\r\n            } else {\r\n                result.set(q);\r\n            }\r\n            return true;\r\n        }\r\n    });\r\n    return result.get();\r\n}","lc":2.1818181818,"pi":0.8181818182,"ma":1.0,"nbd":1.0,"ml":0.5833333333,"d":0.6369047619,"mi":-0.9811134602,"fo":1.5833333333,"r":-0.0263157895,"e":2.2151046259}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5212_712c4fff","label":1,"code":"protected static PluginDescriptor clone(PluginDescriptor original) {\r\n    PluginDescriptor clone = null;\r\n    if (original != null) {\r\n        clone = new PluginDescriptor();\r\n        clone.setGroupId(original.getGroupId());\r\n        clone.setArtifactId(original.getArtifactId());\r\n        clone.setVersion(original.getVersion());\r\n        clone.setGoalPrefix(original.getGoalPrefix());\r\n        clone.setInheritedByDefault(original.isInheritedByDefault());\r\n        clone.setName(original.getName());\r\n        clone.setDescription(original.getDescription());\r\n        clone.setRequiredMavenVersion(original.getRequiredMavenVersion());\r\n        clone.setPluginArtifact(ArtifactUtils.copyArtifactSafe(original.getPluginArtifact()));\r\n        clone.setComponents(clone(original.getMojos(), clone));\r\n        clone.setId(original.getId());\r\n        clone.setIsolatedRealm(original.isIsolatedRealm());\r\n        clone.setSource(original.getSource());\r\n    }\r\n    return clone;\r\n}","code_comment":null,"code_no_comment":"protected static PluginDescriptor clone(PluginDescriptor original) {\r\n    PluginDescriptor clone = null;\r\n    if (original != null) {\r\n        clone = new PluginDescriptor();\r\n        clone.setGroupId(original.getGroupId());\r\n        clone.setArtifactId(original.getArtifactId());\r\n        clone.setVersion(original.getVersion());\r\n        clone.setGoalPrefix(original.getGoalPrefix());\r\n        clone.setInheritedByDefault(original.isInheritedByDefault());\r\n        clone.setName(original.getName());\r\n        clone.setDescription(original.getDescription());\r\n        clone.setRequiredMavenVersion(original.getRequiredMavenVersion());\r\n        clone.setPluginArtifact(ArtifactUtils.copyArtifactSafe(original.getPluginArtifact()));\r\n        clone.setComponents(clone(original.getMojos(), clone));\r\n        clone.setId(original.getId());\r\n        clone.setIsolatedRealm(original.isIsolatedRealm());\r\n        clone.setSource(original.getSource());\r\n    }\r\n    return clone;\r\n}","lc":0.2727272727,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.0496031746,"mi":-0.2699083862,"fo":1.8333333333,"r":-0.0263157895,"e":0.1932124272}
{"project_name":"JxPath","project_version":"19","label":1,"code":"\/**\r\n * Get relative position of this among like-named siblings.\r\n * @return 1..n\r\n *\/\r\nprivate int getRelativePositionByQName() {\r\n    int count = 1;\r\n    Node n = node.getPreviousSibling();\r\n    while (n != null) {\r\n        if (n.getNodeType() == Node.ELEMENT_NODE) {\r\n            String nm = n.getNodeName();\r\n            if (nm.equals(node.getNodeName())) {\r\n                count++;\r\n            }\r\n        }\r\n        n = n.getPreviousSibling();\r\n    }\r\n    return count;\r\n}","code_comment":"\/**\r\n * Get relative position of this among like-named siblings.\r\n * @return 1..n\r\n *\/\r\n","code_no_comment":"private int getRelativePositionByQName() {\r\n    int count = 1;\r\n    Node n = node.getPreviousSibling();\r\n    while (n != null) {\r\n        if (n.getNodeType() == Node.ELEMENT_NODE) {\r\n            String nm = n.getNodeName();\r\n            if (nm.equals(node.getNodeName())) {\r\n                count++;\r\n            }\r\n        }\r\n        n = n.getPreviousSibling();\r\n    }\r\n    return count;\r\n}","lc":0.0,"pi":0.7894736842,"ma":0.0,"nbd":0.5,"ml":0.1666666667,"d":0.3492063492,"mi":0.0176180409,"fo":0.0,"r":1.8157894737,"e":0.0769212151}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-193_c831e44d","label":3,"code":"public static String toPrintableString(byte[] ba, int offset, int len, int maxLen) {\r\n    StringBuilder sb = new StringBuilder();\r\n    int plen = Math.min(len, maxLen);\r\n    for (int i = 0; i < plen; i++) {\r\n        int c = 0xff & ba[offset + i];\r\n        if (c >= 32 && c <= 126)\r\n            sb.append((char) c);\r\n        else\r\n            sb.append(\"%\" + String.format(\"%02x;\", c));\r\n    }\r\n    if (len > maxLen) {\r\n        sb.append(\"... TRUNCATED\");\r\n    }\r\n    return sb.toString();\r\n}","code_comment":null,"code_no_comment":"public static String toPrintableString(byte[] ba, int offset, int len, int maxLen) {\r\n    StringBuilder sb = new StringBuilder();\r\n    int plen = Math.min(len, maxLen);\r\n    for (int i = 0; i < plen; i++) {\r\n        int c = 0xff & ba[offset + i];\r\n        if (c >= 32 && c <= 126)\r\n            sb.append((char) c);\r\n        else\r\n            sb.append(\"%\" + String.format(\"%02x;\", c));\r\n    }\r\n    if (len > maxLen) {\r\n        sb.append(\"... TRUNCATED\");\r\n    }\r\n    return sb.toString();\r\n}","lc":0.0454545455,"pi":0.2535885167,"ma":0.0,"nbd":-0.5,"ml":0.3333333333,"d":1.1567460317,"mi":-0.1199436223,"fo":0.0,"r":-0.0263157895,"e":0.889170888}
{"project_name":"Math","project_version":"88","label":1,"code":"\/**\r\n * Get the current solution.\r\n * <p>\r\n * {@link #solve} should be called first for this to be the optimal solution.\r\n * <\/p>\r\n * @return current solution\r\n *\/\r\nprotected RealPointValuePair getSolution() {\r\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\r\n    Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\r\n    double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\r\n    for (int i = 0; i < coefficients.length; i++) {\r\n        basicRow = getBasicRow(getNumObjectiveFunctions() + i);\r\n        \/\/ if multiple variables can take a given value\r\n        \/\/ then we choose the first and set the rest equal to 0\r\n        coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\r\n        if (basicRow != null) {\r\n            for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\r\n                if (tableau.getEntry(basicRow, j) == 1) {\r\n                    coefficients[i] = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\r\n}","code_comment":"\/**\r\n * Get the current solution.\r\n * <p>\r\n * {@link #solve} should be called first for this to be the optimal solution.\r\n * <\/p>\r\n * @return current solution\r\n *\/\r\n","code_no_comment":"protected RealPointValuePair getSolution() {\r\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\r\n    Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\r\n    double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\r\n    for (int i = 0; i < coefficients.length; i++) {\r\n        basicRow = getBasicRow(getNumObjectiveFunctions() + i);\r\n                        coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\r\n        if (basicRow != null) {\r\n            for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\r\n                if (tableau.getEntry(basicRow, j) == 1) {\r\n                    coefficients[i] = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\r\n}","lc":0.1363636364,"pi":1.2344497608,"ma":0.8,"nbd":1.0,"ml":0.75,"d":1.2321428571,"mi":-0.2403100775,"fo":0.6666666667,"r":0.0526315789,"e":1.260736617}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4933_469d0096","label":1,"code":"public String unalignFromBaseDirectory(String directory, File basedir) {\r\n    String path = basedir.getPath();\r\n    if (directory.startsWith(path)) {\r\n        directory = directory.substring(path.length() + 1).replace('\\\\', '\/');\r\n    }\r\n    return directory;\r\n}","code_comment":null,"code_no_comment":"public String unalignFromBaseDirectory(String directory, File basedir) {\r\n    String path = basedir.getPath();\r\n    if (directory.startsWith(path)) {\r\n        directory = directory.substring(path.length() + 1).replace('\\\\', '\/');\r\n    }\r\n    return directory;\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0476190476,"mi":0.3866102889,"fo":-0.0833333333,"r":0.0526315789,"e":-0.081384024}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2065_9da430fb","label":1,"code":"@Override\r\nprotected void appendParameters(AppendingStringBuffer url, Map parameters) {\r\n    int i = 0;\r\n    while (parameters.containsKey(String.valueOf(i))) {\r\n        String value = null;\r\n        Object parameter = parameters.get(String.valueOf(i));\r\n        if (parameter instanceof String[] && ((String[]) parameter).length > 0) {\r\n            value = ((String[]) parameter)[0];\r\n        } else {\r\n            value = parameter.toString();\r\n        }\r\n        if (!url.endsWith(\"\/\")) {\r\n            url.append(\"\/\");\r\n        }\r\n        url.append(urlEncodePathComponent(value)).append(\"\/\");\r\n        i++;\r\n    }\r\n    String pageMap = (String) parameters.get(WebRequestCodingStrategy.PAGEMAP);\r\n    if (pageMap != null) {\r\n        i++;\r\n        pageMap = WebRequestCodingStrategy.encodePageMapName(pageMap);\r\n        if (!url.endsWith(\"\/\")) {\r\n            url.append(\"\/\");\r\n        }\r\n        url.append(WebRequestCodingStrategy.PAGEMAP).append(\"\/\").append(urlEncodePathComponent(pageMap)).append(\"\/\");\r\n    }\r\n    String intface = (String) parameters.get(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);\r\n    if (intface != null) {\r\n        i++;\r\n        if (!url.endsWith(\"\/\")) {\r\n            url.append(\"\/\");\r\n        }\r\n        url.append(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME).append(\"\/\").append(urlEncodePathComponent(intface)).append(\"\/\");\r\n    }\r\n    if (i != parameters.size()) {\r\n        throw new WicketRuntimeException(\"Not all parameters were encoded. Make sure all parameter names are integers in consecutive order starting with zero. Current parameter names are: \" + parameters.keySet().toString());\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void appendParameters(AppendingStringBuffer url, Map parameters) {\r\n    int i = 0;\r\n    while (parameters.containsKey(String.valueOf(i))) {\r\n        String value = null;\r\n        Object parameter = parameters.get(String.valueOf(i));\r\n        if (parameter instanceof String[] && ((String[]) parameter).length > 0) {\r\n            value = ((String[]) parameter)[0];\r\n        } else {\r\n            value = parameter.toString();\r\n        }\r\n        if (!url.endsWith(\"\/\")) {\r\n            url.append(\"\/\");\r\n        }\r\n        url.append(urlEncodePathComponent(value)).append(\"\/\");\r\n        i++;\r\n    }\r\n    String pageMap = (String) parameters.get(WebRequestCodingStrategy.PAGEMAP);\r\n    if (pageMap != null) {\r\n        i++;\r\n        pageMap = WebRequestCodingStrategy.encodePageMapName(pageMap);\r\n        if (!url.endsWith(\"\/\")) {\r\n            url.append(\"\/\");\r\n        }\r\n        url.append(WebRequestCodingStrategy.PAGEMAP).append(\"\/\").append(urlEncodePathComponent(pageMap)).append(\"\/\");\r\n    }\r\n    String intface = (String) parameters.get(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);\r\n    if (intface != null) {\r\n        i++;\r\n        if (!url.endsWith(\"\/\")) {\r\n            url.append(\"\/\");\r\n        }\r\n        url.append(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME).append(\"\/\").append(urlEncodePathComponent(intface)).append(\"\/\");\r\n    }\r\n    if (i != parameters.size()) {\r\n        throw new WicketRuntimeException(\"Not all parameters were encoded. Make sure all parameter names are integers in consecutive order starting with zero. Current parameter names are: \" + parameters.keySet().toString());\r\n    }\r\n}","lc":1.0909090909,"pi":0.0956937799,"ma":1.2,"nbd":0.0,"ml":1.0833333333,"d":1.7281746032,"mi":-0.7136011276,"fo":2.0,"r":-0.0263157895,"e":3.3560991915}
{"project_name":"Math","project_version":"92","label":1,"code":"\/**\r\n * Returns the natural <code>log<\/code> of the <a\r\n * href=\"http:\/\/mathworld.wolfram.com\/BinomialCoefficient.html\"> Binomial\r\n * Coefficient<\/a>, \"<code>n choose k<\/code>\", the number of\r\n * <code>k<\/code>-element subsets that can be selected from an\r\n * <code>n<\/code>-element set.\r\n * <p>\r\n * <Strong>Preconditions<\/strong>:\r\n * <ul>\r\n * <li> <code>0 <= k <= n <\/code> (otherwise\r\n * <code>IllegalArgumentException<\/code> is thrown)<\/li>\r\n * <\/ul><\/p>\r\n *\r\n * @param n the size of the set\r\n * @param k the size of the subsets to be counted\r\n * @return <code>n choose k<\/code>\r\n * @throws IllegalArgumentException if preconditions are not met.\r\n *\/\r\npublic static double binomialCoefficientLog(final int n, final int k) {\r\n    if (n < k) {\r\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\r\n    }\r\n    if (n < 0) {\r\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\r\n    }\r\n    if ((n == k) || (k == 0)) {\r\n        return 0;\r\n    }\r\n    if ((k == 1) || (k == n - 1)) {\r\n        return Math.log((double) n);\r\n    }\r\n    \/*\r\n         * For values small enough to do exact integer computation,\r\n         * return the log of the exact value \r\n         *\/\r\n    \/*\r\n         * Return the log of binomialCoefficientDouble for values that will not\r\n         * overflow binomialCoefficientDouble\r\n         *\/\r\n    \/*\r\n         * Sum logs for values that could overflow\r\n         *\/\r\n    double logSum = 0;\r\n    \/\/ n!\/k!\r\n    for (int i = k + 1; i <= n; i++) {\r\n        logSum += Math.log((double) i);\r\n    }\r\n    \/\/ divide by (n-k)!\r\n    for (int i = 2; i <= n - k; i++) {\r\n        logSum -= Math.log((double) i);\r\n    }\r\n    return logSum;\r\n}","code_comment":"\/**\r\n * Returns the natural <code>log<\/code> of the <a\r\n * href=\"http:\/\/mathworld.wolfram.com\/BinomialCoefficient.html\"> Binomial\r\n * Coefficient<\/a>, \"<code>n choose k<\/code>\", the number of\r\n * <code>k<\/code>-element subsets that can be selected from an\r\n * <code>n<\/code>-element set.\r\n * <p>\r\n * <Strong>Preconditions<\/strong>:\r\n * <ul>\r\n * <li> <code>0 <= k <= n <\/code> (otherwise\r\n * <code>IllegalArgumentException<\/code> is thrown)<\/li>\r\n * <\/ul><\/p>\r\n *\r\n * @param n the size of the set\r\n * @param k the size of the subsets to be counted\r\n * @return <code>n choose k<\/code>\r\n * @throws IllegalArgumentException if preconditions are not met.\r\n *\/\r\n","code_no_comment":"public static double binomialCoefficientLog(final int n, final int k) {\r\n    if (n < k) {\r\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\r\n    }\r\n    if (n < 0) {\r\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\r\n    }\r\n    if ((n == k) || (k == 0)) {\r\n        return 0;\r\n    }\r\n    if ((k == 1) || (k == n - 1)) {\r\n        return Math.log((double) n);\r\n    }\r\n                double logSum = 0;\r\n        for (int i = k + 1; i <= n; i++) {\r\n        logSum += Math.log((double) i);\r\n    }\r\n        for (int i = 2; i <= n - k; i++) {\r\n        logSum -= Math.log((double) i);\r\n    }\r\n    return logSum;\r\n}","lc":0.3636363636,"pi":-0.3301435407,"ma":1.0,"nbd":-0.5,"ml":0.5,"d":3.0357142857,"mi":-0.3338971106,"fo":-0.25,"r":-0.0263157895,"e":2.3013225912}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5441_8ccb1f6d","label":1,"code":"@Override\r\npublic void decorateResponse(AbstractResource.ResourceResponse response, IStaticCacheableResource resource) {\r\n    response.setCacheDurationToMaximum();\r\n    response.setCacheScope(WebResponse.CacheScope.PUBLIC);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void decorateResponse(AbstractResource.ResourceResponse response, IStaticCacheableResource resource) {\r\n    response.setCacheDurationToMaximum();\r\n    response.setCacheScope(WebResponse.CacheScope.PUBLIC);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6473572939,"fo":-0.3333333333,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5326_ded3c583","label":1,"code":"protected Url encryptUrl(final Url url) {\r\n    if (url.getSegments().isEmpty()) {\r\n        return url;\r\n    }\r\n    String encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());\r\n    Url encryptedUrl = new Url(url.getCharset());\r\n    encryptedUrl.getSegments().add(encryptedUrlString);\r\n    int numberOfSegments = url.getSegments().size();\r\n    HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\r\n    for (int segNo = 0; segNo < numberOfSegments; segNo++) {\r\n        encryptedUrl.getSegments().add(generator.next());\r\n    }\r\n    return encryptedUrl;\r\n}","code_comment":null,"code_no_comment":"protected Url encryptUrl(final Url url) {\r\n    if (url.getSegments().isEmpty()) {\r\n        return url;\r\n    }\r\n    String encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());\r\n    Url encryptedUrl = new Url(url.getCharset());\r\n    encryptedUrl.getSegments().add(encryptedUrlString);\r\n    int numberOfSegments = url.getSegments().size();\r\n    HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\r\n    for (int segNo = 0; segNo < numberOfSegments; segNo++) {\r\n        encryptedUrl.getSegments().add(generator.next());\r\n    }\r\n    return encryptedUrl;\r\n}","lc":0.0,"pi":-0.4066985646,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":0.0416666667,"mi":-0.043551797,"fo":0.5833333333,"r":-0.0263157895,"e":0.0536205575}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3740_f2f5bd5b","label":1,"code":"@Override\r\n@SuppressWarnings(\"unchecked,rawtypes\")\r\nprotected void processTriggerResult(TriggerResult triggerResult, K key, W window) throws Exception {\r\n    if (!triggerResult.isFire() && !triggerResult.isPurge()) {\r\n        \/\/ do nothing\r\n        return;\r\n    }\r\n    ListState<StreamRecord<IN>> windowState;\r\n    MergingWindowSet<W> mergingWindows = null;\r\n    if (windowAssigner instanceof MergingWindowAssigner) {\r\n        mergingWindows = mergingWindowsByKey.get(key);\r\n        W stateWindow = mergingWindows.getStateWindow(window);\r\n        windowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\r\n    } else {\r\n        windowState = getPartitionedState(window, windowSerializer, windowStateDescriptor);\r\n    }\r\n    if (triggerResult.isFire()) {\r\n        timestampedCollector.setAbsoluteTimestamp(window.maxTimestamp());\r\n        Iterable<StreamRecord<IN>> contents = windowState.get();\r\n        \/\/ Work around type system restrictions...\r\n        int toEvict = evictor.evict((Iterable) contents, Iterables.size(contents), context.window);\r\n        FluentIterable<IN> projectedContents = FluentIterable.from(contents).skip(toEvict).transform(new Function<StreamRecord<IN>, IN>() {\r\n\r\n            @Override\r\n            public IN apply(StreamRecord<IN> input) {\r\n                return input.getValue();\r\n            }\r\n        });\r\n        userFunction.apply(context.key, context.window, projectedContents, timestampedCollector);\r\n    }\r\n    if (triggerResult.isPurge()) {\r\n        windowState.clear();\r\n        if (mergingWindows != null) {\r\n            mergingWindows.retireWindow(window);\r\n        }\r\n        context.clear();\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\n@SuppressWarnings(\"unchecked,rawtypes\")\r\nprotected void processTriggerResult(TriggerResult triggerResult, K key, W window) throws Exception {\r\n    if (!triggerResult.isFire() && !triggerResult.isPurge()) {\r\n                return;\r\n    }\r\n    ListState<StreamRecord<IN>> windowState;\r\n    MergingWindowSet<W> mergingWindows = null;\r\n    if (windowAssigner instanceof MergingWindowAssigner) {\r\n        mergingWindows = mergingWindowsByKey.get(key);\r\n        W stateWindow = mergingWindows.getStateWindow(window);\r\n        windowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\r\n    } else {\r\n        windowState = getPartitionedState(window, windowSerializer, windowStateDescriptor);\r\n    }\r\n    if (triggerResult.isFire()) {\r\n        timestampedCollector.setAbsoluteTimestamp(window.maxTimestamp());\r\n        Iterable<StreamRecord<IN>> contents = windowState.get();\r\n                int toEvict = evictor.evict((Iterable) contents, Iterables.size(contents), context.window);\r\n        FluentIterable<IN> projectedContents = FluentIterable.from(contents).skip(toEvict).transform(new Function<StreamRecord<IN>, IN>() {\r\n\r\n            @Override\r\n            public IN apply(StreamRecord<IN> input) {\r\n                return input.getValue();\r\n            }\r\n        });\r\n        userFunction.apply(context.key, context.window, projectedContents, timestampedCollector);\r\n    }\r\n    if (triggerResult.isPurge()) {\r\n        windowState.clear();\r\n        if (mergingWindows != null) {\r\n            mergingWindows.retireWindow(window);\r\n        }\r\n        context.clear();\r\n    }\r\n}","lc":0.9545454545,"pi":0.3444976077,"ma":0.4,"nbd":0.0,"ml":0.4166666667,"d":0.4365079365,"mi":-0.64397463,"fo":1.25,"r":-0.0263157895,"e":1.1293234903}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4548_9a6a06be","label":1,"code":"@Override\r\npublic String toString() {\r\n    return \"ValidationErrorFeedback{\" + \"message=\" + message + '}';\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String toString() {\r\n    return \"ValidationErrorFeedback{\" + \"message=\" + message + '}';\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8314305849,"fo":-0.5,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1008_0c20bfd8","label":1,"code":"\/**\r\n * Test for a resource.\r\n * @param resource The URI to the resource.\r\n * @return true if the resource matches.\r\n *\/\r\nboolean matches(URI resource);","code_comment":"\/**\r\n * Test for a resource.\r\n * @param resource The URI to the resource.\r\n * @return true if the resource matches.\r\n *\/\r\n","code_no_comment":"boolean matches(URI resource);","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.666384778,"fo":-0.5,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4358_74cbba24","label":1,"code":"\/**\r\n * Returns all changes for the given property back to {@code min} revision\r\n * (exclusive). The revisions include committed as well as uncommitted\r\n * changes.\r\n *\r\n * @param property the name of the property.\r\n * @param min the lower bound revision (exclusive).\r\n * @return changes back to {@code min} revision.\r\n *\/\r\n@Nonnull\r\nIterable<Revision> getChanges(@Nonnull final String property, @Nonnull final RevisionVector min) {\r\n    return new Iterable<Revision>() {\r\n\r\n        @Override\r\n        public Iterator<Revision> iterator() {\r\n            final Set<Revision> changes = getValueMap(property).keySet();\r\n            final Set<Integer> clusterIds = Sets.newHashSet();\r\n            for (Revision r : getLocalMap(property).keySet()) {\r\n                clusterIds.add(r.getClusterId());\r\n            }\r\n            for (Range r : getPreviousRanges().values()) {\r\n                if (min.isRevisionNewer(r.high)) {\r\n                    clusterIds.add(r.high.getClusterId());\r\n                }\r\n            }\r\n            final Iterator<Revision> unfiltered = changes.iterator();\r\n            return new AbstractIterator<Revision>() {\r\n\r\n                @Override\r\n                protected Revision computeNext() {\r\n                    while (unfiltered.hasNext()) {\r\n                        Revision next = unfiltered.next();\r\n                        if (min.isRevisionNewer(next)) {\r\n                            return next;\r\n                        } else {\r\n                            \/\/ further revisions with this clusterId\r\n                            \/\/ are older than min revision\r\n                            clusterIds.remove(next.getClusterId());\r\n                            \/\/ no more revisions to check\r\n                            if (clusterIds.isEmpty()) {\r\n                                return endOfData();\r\n                            }\r\n                        }\r\n                    }\r\n                    return endOfData();\r\n                }\r\n            };\r\n        }\r\n    };\r\n}","code_comment":"\/**\r\n * Returns all changes for the given property back to {@code min} revision\r\n * (exclusive). The revisions include committed as well as uncommitted\r\n * changes.\r\n *\r\n * @param property the name of the property.\r\n * @param min the lower bound revision (exclusive).\r\n * @return changes back to {@code min} revision.\r\n *\/\r\n","code_no_comment":"@Nonnull\r\nIterable<Revision> getChanges(@Nonnull final String property, @Nonnull final RevisionVector min) {\r\n    return new Iterable<Revision>() {\r\n\r\n        @Override\r\n        public Iterator<Revision> iterator() {\r\n            final Set<Revision> changes = getValueMap(property).keySet();\r\n            final Set<Integer> clusterIds = Sets.newHashSet();\r\n            for (Revision r : getLocalMap(property).keySet()) {\r\n                clusterIds.add(r.getClusterId());\r\n            }\r\n            for (Range r : getPreviousRanges().values()) {\r\n                if (min.isRevisionNewer(r.high)) {\r\n                    clusterIds.add(r.high.getClusterId());\r\n                }\r\n            }\r\n            final Iterator<Revision> unfiltered = changes.iterator();\r\n            return new AbstractIterator<Revision>() {\r\n\r\n                @Override\r\n                protected Revision computeNext() {\r\n                    while (unfiltered.hasNext()) {\r\n                        Revision next = unfiltered.next();\r\n                        if (min.isRevisionNewer(next)) {\r\n                            return next;\r\n                        } else {\r\n                                                                                    clusterIds.remove(next.getClusterId());\r\n                                                        if (clusterIds.isEmpty()) {\r\n                                return endOfData();\r\n                            }\r\n                        }\r\n                    }\r\n                    return endOfData();\r\n                }\r\n            };\r\n        }\r\n    };\r\n}","lc":1.0,"pi":2.5837320574,"ma":0.6,"nbd":1.5,"ml":0.4166666667,"d":-0.3650793651,"mi":-0.5932346723,"fo":1.25,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7163_5f726d0b","label":1,"code":"@ManagedOperation(description = \"Updates\/adds the message header on the suspended breakpoint at the given node id\")\r\nvoid setMessageHeaderOnBreakpoint(String nodeId, String headerName, String value);","code_comment":null,"code_no_comment":"@ManagedOperation(description = \"Updates\/adds the message header on the suspended breakpoint at the given node id\")\r\nvoid setMessageHeaderOnBreakpoint(String nodeId, String headerName, String value);","lc":-0.5454545455,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1338971106,"fo":-0.5,"r":0.6315789474,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4572_dfc56674","label":0,"code":"\/**\r\n *  Creates and returns a new page window for given page.\r\n *\r\n *  @param pageId\r\n *  @param size\r\n *  @return page window\r\n *\/\r\npublic PageWindow createPageWindow(int pageId, int size) {\r\n    int index = getWindowIndex(pageId);\r\n    \/\/ if we found the page window, mark it as invalid\r\n    if (index != -1) {\r\n        removeWindowIndex(pageId);\r\n        (windows.get(index)).pageId = -1;\r\n    }\r\n    \/\/ indexPointer\r\n    if (index == -1 || index != indexPointer) {\r\n        index = incrementIndexPointer();\r\n    }\r\n    PageWindowInternal window = allocatePageWindow(index, size);\r\n    window.pageId = pageId;\r\n    putWindowIndex(pageId, index);\r\n    return new PageWindow(window);\r\n}","code_comment":"\/**\r\n *  Creates and returns a new page window for given page.\r\n *\r\n *  @param pageId\r\n *  @param size\r\n *  @return page window\r\n *\/\r\n","code_no_comment":"public PageWindow createPageWindow(int pageId, int size) {\r\n    int index = getWindowIndex(pageId);\r\n        if (index != -1) {\r\n        removeWindowIndex(pageId);\r\n        (windows.get(index)).pageId = -1;\r\n    }\r\n        if (index == -1 || index != indexPointer) {\r\n        index = incrementIndexPointer();\r\n    }\r\n    PageWindowInternal window = allocatePageWindow(index, size);\r\n    window.pageId = pageId;\r\n    putWindowIndex(pageId, index);\r\n    return new PageWindow(window);\r\n}","lc":0.0,"pi":-0.2966507177,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":0.4761904762,"mi":-0.0336856942,"fo":0.0,"r":0.4473684211,"e":0.2551707843}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6557_2c5a42db","label":1,"code":"\/**\r\n * This method will aggregate the old and new exchange and return the result.\r\n *\r\n * @param oldExchange The oldest exchange, can be null\r\n * @param newExchange The newest exchange, can be null\r\n * @return a composite exchange of the old and\/or new exchanges\r\n *\/\r\npublic Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\r\n    List<V> list;\r\n    Exchange answer = oldExchange;\r\n    if (oldExchange == null) {\r\n        answer = new DefaultExchange(newExchange);\r\n        list = getList(answer);\r\n    } else {\r\n        list = getList(oldExchange);\r\n    }\r\n    if (newExchange != null) {\r\n        V value = getValue(newExchange);\r\n        if (value != null) {\r\n            list.add(value);\r\n        }\r\n    }\r\n    return answer;\r\n}","code_comment":"\/**\r\n * This method will aggregate the old and new exchange and return the result.\r\n *\r\n * @param oldExchange The oldest exchange, can be null\r\n * @param newExchange The newest exchange, can be null\r\n * @return a composite exchange of the old and\/or new exchanges\r\n *\/\r\n","code_no_comment":"public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\r\n    List<V> list;\r\n    Exchange answer = oldExchange;\r\n    if (oldExchange == null) {\r\n        answer = new DefaultExchange(newExchange);\r\n        list = getList(answer);\r\n    } else {\r\n        list = getList(oldExchange);\r\n    }\r\n    if (newExchange != null) {\r\n        V value = getValue(newExchange);\r\n        if (value != null) {\r\n            list.add(value);\r\n        }\r\n    }\r\n    return answer;\r\n}","lc":0.1363636364,"pi":0.028708134,"ma":0.0,"nbd":0.0,"ml":0.0833333333,"d":0.1111111111,"mi":-0.1061310782,"fo":-0.1666666667,"r":0.8684210526,"e":0.0402182996}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2494_0dc92ca1","label":1,"code":"public void clear() {\r\n    sum = 0;\r\n    count = 0;\r\n    partialStdDev = 0;\r\n}","code_comment":null,"code_no_comment":"public void clear() {\r\n    sum = 0;\r\n    count = 0;\r\n    partialStdDev = 0;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7333333333,"fo":-0.5,"r":2.3947368421,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Substitutes <code>value<\/code> for the most recently added value.\r\n * Returns the value that has been replaced. If the array is empty (i.e.\r\n * if {@link #numElements} is zero), an IllegalStateException is thrown.\r\n *\r\n * @param value New value to substitute for the most recently added value\r\n * @return the value that has been replaced in the array.\r\n * @throws MathIllegalStateException if the array is empty\r\n * @since 2.0\r\n *\/\r\npublic synchronized double substituteMostRecentElement(double value) throws MathIllegalStateException {\r\n    if (numElements < 1) {\r\n        throw new MathIllegalStateException(LocalizedFormats.CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY);\r\n    }\r\n    final int substIndex = startIndex + (numElements - 1);\r\n    final double discarded = internalArray[substIndex];\r\n    internalArray[substIndex] = value;\r\n    return discarded;\r\n}","code_comment":"\/**\r\n * Substitutes <code>value<\/code> for the most recently added value.\r\n * Returns the value that has been replaced. If the array is empty (i.e.\r\n * if {@link #numElements} is zero), an IllegalStateException is thrown.\r\n *\r\n * @param value New value to substitute for the most recently added value\r\n * @return the value that has been replaced in the array.\r\n * @throws MathIllegalStateException if the array is empty\r\n * @since 2.0\r\n *\/\r\n","code_no_comment":"public synchronized double substituteMostRecentElement(double value) throws MathIllegalStateException {\r\n    if (numElements < 1) {\r\n        throw new MathIllegalStateException(LocalizedFormats.CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY);\r\n    }\r\n    final int substIndex = startIndex + (numElements - 1);\r\n    final double discarded = internalArray[substIndex];\r\n    internalArray[substIndex] = value;\r\n    return discarded;\r\n}","lc":-0.2272727273,"pi":-0.3444976077,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":0.2956349206,"mi":0.2738548273,"fo":-0.5,"r":0.1052631579,"e":-0.0029667537}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-189_cd7feb4d","label":3,"code":"@Override\r\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\r\n    RegExFilter result = new RegExFilter();\r\n    result.setSource(getSource().deepCopy(env));\r\n    result.rowMatcher = rowMatcher.pattern().matcher(\"\");\r\n    result.colfMatcher = colfMatcher.pattern().matcher(\"\");\r\n    result.colqMatcher = colqMatcher.pattern().matcher(\"\");\r\n    result.valueMatcher = valueMatcher.pattern().matcher(\"\");\r\n    result.orFields = orFields;\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\r\n    RegExFilter result = new RegExFilter();\r\n    result.setSource(getSource().deepCopy(env));\r\n    result.rowMatcher = rowMatcher.pattern().matcher(\"\");\r\n    result.colfMatcher = colfMatcher.pattern().matcher(\"\");\r\n    result.colqMatcher = colqMatcher.pattern().matcher(\"\");\r\n    result.valueMatcher = valueMatcher.pattern().matcher(\"\");\r\n    result.orFields = orFields;\r\n    return result;\r\n}","lc":-0.1363636364,"pi":-0.5789473684,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.0858350951,"fo":0.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"@Override\r\npublic void write(org.apache.thrift.protocol.TProtocol prot, removeConstraint_result struct) throws org.apache.thrift.TException {\r\n    TTupleProtocol oprot = (TTupleProtocol) prot;\r\n    BitSet optionals = new BitSet();\r\n    if (struct.isSetOuch1()) {\r\n        optionals.set(0);\r\n    }\r\n    if (struct.isSetOuch2()) {\r\n        optionals.set(1);\r\n    }\r\n    oprot.writeBitSet(optionals, 2);\r\n    if (struct.isSetOuch1()) {\r\n        struct.ouch1.write(oprot);\r\n    }\r\n    if (struct.isSetOuch2()) {\r\n        struct.ouch2.write(oprot);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void write(org.apache.thrift.protocol.TProtocol prot, removeConstraint_result struct) throws org.apache.thrift.TException {\r\n    TTupleProtocol oprot = (TTupleProtocol) prot;\r\n    BitSet optionals = new BitSet();\r\n    if (struct.isSetOuch1()) {\r\n        optionals.set(0);\r\n    }\r\n    if (struct.isSetOuch2()) {\r\n        optionals.set(1);\r\n    }\r\n    oprot.writeBitSet(optionals, 2);\r\n    if (struct.isSetOuch1()) {\r\n        struct.ouch1.write(oprot);\r\n    }\r\n    if (struct.isSetOuch2()) {\r\n        struct.ouch2.write(oprot);\r\n    }\r\n}","lc":0.1818181818,"pi":-0.2440191388,"ma":0.2,"nbd":-0.5,"ml":0.0833333333,"d":-0.3650793651,"mi":-0.1749119098,"fo":0.25,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-939_49444ee6","label":1,"code":"\/**\r\n * Compute a covariance matrix from a rectangular array whose columns represent\r\n * covariates.\r\n * @param data input array (must have at least two columns and two rows)\r\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\r\n * @return covariance matrix\r\n * @throws MathIllegalArgumentException if the data array does not contain sufficient\r\n * data\r\n *\/\r\nprotected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected) throws MathIllegalArgumentException {\r\n    return computeCovarianceMatrix(new BlockRealMatrix(data), biasCorrected);\r\n}","code_comment":"\/**\r\n * Compute a covariance matrix from a rectangular array whose columns represent\r\n * covariates.\r\n * @param data input array (must have at least two columns and two rows)\r\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\r\n * @return covariance matrix\r\n * @throws MathIllegalArgumentException if the data array does not contain sufficient\r\n * data\r\n *\/\r\n","code_no_comment":"protected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected) throws MathIllegalArgumentException {\r\n    return computeCovarianceMatrix(new BlockRealMatrix(data), biasCorrected);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9805496829,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"Time","project_version":"26","label":2,"code":"public long set(long instant, String text, Locale locale) {\r\n    \/\/ cannot verify that new value stuck because set may be lenient\r\n    long localInstant = iZone.convertUTCToLocal(instant);\r\n    localInstant = iField.set(localInstant, text, locale);\r\n    return iZone.convertLocalToUTC(localInstant, false);\r\n}","code_comment":null,"code_no_comment":"public long set(long instant, String text, Locale locale) {\r\n        long localInstant = iZone.convertUTCToLocal(instant);\r\n    localInstant = iField.set(localInstant, text, locale);\r\n    return iZone.convertLocalToUTC(localInstant, false);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5805496829,"fo":-0.25,"r":0.0526315789,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-548_717186d6","label":1,"code":"private void toJson(JsopBuilder builder, NodeState node) {\r\n    for (PropertyState property : node.getProperties()) {\r\n        builder.key(property.getName()).encodedValue(property.getEncodedValue());\r\n    }\r\n    for (ChildNode entry : node.getChildNodeEntries(0, -1)) {\r\n        builder.key(entry.getName()).object();\r\n        toJson(builder, entry.getNode());\r\n        builder.endObject();\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void toJson(JsopBuilder builder, NodeState node) {\r\n    for (PropertyState property : node.getProperties()) {\r\n        builder.key(property.getName()).encodedValue(property.getEncodedValue());\r\n    }\r\n    for (ChildNode entry : node.getChildNodeEntries(0, -1)) {\r\n        builder.key(entry.getName()).object();\r\n        toJson(builder, entry.getNode());\r\n        builder.endObject();\r\n    }\r\n}","lc":-0.1818181818,"pi":0.0,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.1664552502,"fo":0.5,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1211_a06a1584","label":1,"code":"\/**\r\n * Get the first sub-hyperplane crossed by a semi-infinite line.\r\n * @param point start point of the part of the line considered\r\n * @param line line to consider (contains point)\r\n * @return the first sub-hyperplaned crossed by the line after the\r\n * given point, or null if the line does not intersect any\r\n * sub-hyperplaned\r\n *\/\r\npublic SubHyperplane<Euclidean3D> firstIntersection(final Vector3D point, final Line line) {\r\n    return recurseFirstIntersection(getTree(true), point, line);\r\n}","code_comment":"\/**\r\n * Get the first sub-hyperplane crossed by a semi-infinite line.\r\n * @param point start point of the part of the line considered\r\n * @param line line to consider (contains point)\r\n * @return the first sub-hyperplaned crossed by the line after the\r\n * given point, or null if the line does not intersect any\r\n * sub-hyperplaned\r\n *\/\r\n","code_no_comment":"public SubHyperplane<Euclidean3D> firstIntersection(final Vector3D point, final Line line) {\r\n    return recurseFirstIntersection(getTree(true), point, line);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9114869626,"fo":-0.3333333333,"r":1.8421052632,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1364_b481a14c","label":1,"code":"\/**\r\n * Remove an entry. Both resident and non-resident entries can be\r\n * removed.\r\n *\r\n * @param key the key (may not be null)\r\n * @param hash the hash\r\n *\/\r\nsynchronized void invalidate(Object key, int hash) {\r\n    int index = hash & mask;\r\n    Entry<K, V> e = entries[index];\r\n    if (e == null) {\r\n        return;\r\n    }\r\n    if (e.key.equals(key)) {\r\n        entries[index] = e.mapNext;\r\n    } else {\r\n        Entry<K, V> last;\r\n        do {\r\n            last = e;\r\n            e = e.mapNext;\r\n            if (e == null) {\r\n                return;\r\n            }\r\n        } while (!e.key.equals(key));\r\n        last.mapNext = e.mapNext;\r\n    }\r\n    mapSize--;\r\n    usedMemory -= e.memory;\r\n    if (e.stackNext != null) {\r\n        removeFromStack(e);\r\n    }\r\n    if (e.isHot()) {\r\n        \/\/ when removing a hot entry, the newest cold entry gets hot,\r\n        \/\/ so the number of hot entries does not change\r\n        e = queue.queueNext;\r\n        if (e != queue) {\r\n            removeFromQueue(e);\r\n            if (e.stackNext == null) {\r\n                addToStackBottom(e);\r\n            }\r\n        }\r\n    } else {\r\n        removeFromQueue(e);\r\n    }\r\n    pruneStack();\r\n}","code_comment":"\/**\r\n * Remove an entry. Both resident and non-resident entries can be\r\n * removed.\r\n *\r\n * @param key the key (may not be null)\r\n * @param hash the hash\r\n *\/\r\n","code_no_comment":"synchronized void invalidate(Object key, int hash) {\r\n    int index = hash & mask;\r\n    Entry<K, V> e = entries[index];\r\n    if (e == null) {\r\n        return;\r\n    }\r\n    if (e.key.equals(key)) {\r\n        entries[index] = e.mapNext;\r\n    } else {\r\n        Entry<K, V> last;\r\n        do {\r\n            last = e;\r\n            e = e.mapNext;\r\n            if (e == null) {\r\n                return;\r\n            }\r\n        } while (!e.key.equals(key));\r\n        last.mapNext = e.mapNext;\r\n    }\r\n    mapSize--;\r\n    usedMemory -= e.memory;\r\n    if (e.stackNext != null) {\r\n        removeFromStack(e);\r\n    }\r\n    if (e.isHot()) {\r\n                        e = queue.queueNext;\r\n        if (e != queue) {\r\n            removeFromQueue(e);\r\n            if (e.stackNext == null) {\r\n                addToStackBottom(e);\r\n            }\r\n        }\r\n    } else {\r\n        removeFromQueue(e);\r\n    }\r\n    pruneStack();\r\n}","lc":1.0454545455,"pi":0.4641148325,"ma":1.0,"nbd":0.5,"ml":0.75,"d":1.1567460317,"mi":-0.6194503171,"fo":0.1666666667,"r":-0.0263157895,"e":1.3656863932}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3324_5f863af6","label":1,"code":"@Override\r\npublic boolean isGranted(@Nonnull String path, long permissions) {\r\n    Iterator<PermissionEntry> it = getEntryIterator(new EntryPredicate(path, Permissions.respectParentPermissions(permissions)));\r\n    return hasPermissions(it, permissions, path);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean isGranted(@Nonnull String path, long permissions) {\r\n    Iterator<PermissionEntry> it = getEntryIterator(new EntryPredicate(path, Permissions.respectParentPermissions(permissions)));\r\n    return hasPermissions(it, permissions, path);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5867512333,"fo":-0.25,"r":0.0526315789,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5359_61122bab","label":3,"code":"\/**\r\n *  Convert to duration, returning default value if text is inconvertible.\r\n *\r\n *  @param defaultValue\r\n *             the default value\r\n *  @return the converted text as a duration or the default value if text is empty or inconvertible\r\n *  @see Duration#valueOf(String, java.util.Locale)\r\n *\/\r\npublic final Duration toDuration(final Duration defaultValue) {\r\n    if (text != null) {\r\n        try {\r\n            return toDuration();\r\n        } catch (Exception x) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a Duration: %s\", text, x.getMessage()), x);\r\n            }\r\n        }\r\n    }\r\n    return defaultValue;\r\n}","code_comment":"\/**\r\n *  Convert to duration, returning default value if text is inconvertible.\r\n *\r\n *  @param defaultValue\r\n *             the default value\r\n *  @return the converted text as a duration or the default value if text is empty or inconvertible\r\n *  @see Duration#valueOf(String, java.util.Locale)\r\n *\/\r\n","code_no_comment":"public final Duration toDuration(final Duration defaultValue) {\r\n    if (text != null) {\r\n        try {\r\n            return toDuration();\r\n        } catch (Exception x) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a Duration: %s\", text, x.getMessage()), x);\r\n            }\r\n        }\r\n    }\r\n    return defaultValue;\r\n}","lc":-0.0909090909,"pi":0.8899521531,"ma":0.0,"nbd":0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.1540521494,"fo":-0.0833333333,"r":0.7105263158,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1800_8ec4cb84","label":0,"code":"private void addUpdatesToMutation(HashMap<Text, ColumnVisibility> vizMap, Mutation m, List<ColumnUpdate> cu) {\r\n    for (ColumnUpdate update : cu) {\r\n        ColumnVisibility viz = EMPTY_VIS;\r\n        if (update.isSetColVisibility()) {\r\n            viz = getCahcedCV(vizMap, update.getColVisibility());\r\n        }\r\n        byte[] value = new byte[0];\r\n        if (update.isSetValue())\r\n            value = update.getValue();\r\n        if (update.isSetTimestamp()) {\r\n            if (update.isSetDeleteCell()) {\r\n                m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\r\n            } else {\r\n                if (update.isSetDeleteCell()) {\r\n                    m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\r\n                } else {\r\n                    m.put(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp(), value);\r\n                }\r\n            }\r\n        } else {\r\n            m.put(update.getColFamily(), update.getColQualifier(), viz, value);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void addUpdatesToMutation(HashMap<Text, ColumnVisibility> vizMap, Mutation m, List<ColumnUpdate> cu) {\r\n    for (ColumnUpdate update : cu) {\r\n        ColumnVisibility viz = EMPTY_VIS;\r\n        if (update.isSetColVisibility()) {\r\n            viz = getCahcedCV(vizMap, update.getColVisibility());\r\n        }\r\n        byte[] value = new byte[0];\r\n        if (update.isSetValue())\r\n            value = update.getValue();\r\n        if (update.isSetTimestamp()) {\r\n            if (update.isSetDeleteCell()) {\r\n                m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\r\n            } else {\r\n                if (update.isSetDeleteCell()) {\r\n                    m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\r\n                } else {\r\n                    m.put(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp(), value);\r\n                }\r\n            }\r\n        } else {\r\n            m.put(update.getColFamily(), update.getColQualifier(), viz, value);\r\n        }\r\n    }\r\n}","lc":0.4545454545,"pi":1.0956937799,"ma":0.6,"nbd":1.0,"ml":0.3333333333,"d":-0.3650793651,"mi":-0.3874559549,"fo":1.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-537_a8493efc","label":3,"code":"\/**\r\n * Get the node with the index definition node for the given property.\r\n *\r\n * @param name the property name\r\n * @return the node where the index definition is stored, or null if no\r\n *         index definition node was found\r\n *\/\r\n@Nullable\r\nprivate NodeState getIndexDefinitionNode(String name) {\r\n    NodeState state = root.getChildNode(INDEX_DEFINITIONS_NAME);\r\n    if (state != null) {\r\n        for (ChildNodeEntry entry : state.getChildNodeEntries()) {\r\n            PropertyState type = entry.getNodeState().getProperty(IndexConstants.TYPE_PROPERTY_NAME);\r\n            if (type == null || type.isArray() || !Property2Index.TYPE.equals(type.getValue(Type.STRING))) {\r\n                continue;\r\n            }\r\n            PropertyState names = entry.getNodeState().getProperty(\"propertyNames\");\r\n            if (names != null) {\r\n                for (int i = 0; i < names.count(); i++) {\r\n                    if (name.equals(names.getValue(Type.STRING, i))) {\r\n                        return entry.getNodeState();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":"\/**\r\n * Get the node with the index definition node for the given property.\r\n *\r\n * @param name the property name\r\n * @return the node where the index definition is stored, or null if no\r\n *         index definition node was found\r\n *\/\r\n","code_no_comment":"@Nullable\r\nprivate NodeState getIndexDefinitionNode(String name) {\r\n    NodeState state = root.getChildNode(INDEX_DEFINITIONS_NAME);\r\n    if (state != null) {\r\n        for (ChildNodeEntry entry : state.getChildNodeEntries()) {\r\n            PropertyState type = entry.getNodeState().getProperty(IndexConstants.TYPE_PROPERTY_NAME);\r\n            if (type == null || type.isArray() || !Property2Index.TYPE.equals(type.getValue(Type.STRING))) {\r\n                continue;\r\n            }\r\n            PropertyState names = entry.getNodeState().getProperty(\"propertyNames\");\r\n            if (names != null) {\r\n                for (int i = 0; i < names.count(); i++) {\r\n                    if (name.equals(names.getValue(Type.STRING, i))) {\r\n                        return entry.getNodeState();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}","lc":0.3181818182,"pi":1.8373205742,"ma":0.8,"nbd":1.5,"ml":1.0,"d":0.7321428571,"mi":-0.3333333333,"fo":0.5833333333,"r":0.0,"e":0.7941656149}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-43_668f08f2","label":1,"code":"public String getJournal(String fromRevision, String toRevision, String filter) throws MicroKernelException {\r\n    if (rep == null) {\r\n        throw new IllegalStateException(\"this instance has already been disposed\");\r\n    }\r\n    Id fromRevisionId = Id.fromString(fromRevision);\r\n    Id toRevisionId = toRevision == null ? getHeadRevisionId() : Id.fromString(toRevision);\r\n    List<StoredCommit> commits = new ArrayList<StoredCommit>();\r\n    try {\r\n        StoredCommit toCommit = rep.getCommit(toRevisionId);\r\n        Commit fromCommit;\r\n        if (toRevisionId.equals(fromRevisionId)) {\r\n            fromCommit = toCommit;\r\n        } else {\r\n            fromCommit = rep.getCommit(fromRevisionId);\r\n            if (fromCommit.getCommitTS() > toCommit.getCommitTS()) {\r\n                \/\/ negative range, return empty array\r\n                return \"[]\";\r\n            }\r\n        }\r\n        \/\/ collect commits, starting with toRevisionId\r\n        \/\/ and traversing parent commit links until we've reached\r\n        \/\/ fromRevisionId\r\n        StoredCommit commit = toCommit;\r\n        while (commit != null) {\r\n            commits.add(commit);\r\n            if (commit.getId().equals(fromRevisionId)) {\r\n                break;\r\n            }\r\n            Id commitId = commit.getParentId();\r\n            if (commitId == null) {\r\n                break;\r\n            }\r\n            commit = rep.getCommit(commitId);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new MicroKernelException(e);\r\n    }\r\n    JsopBuilder commitBuff = new JsopBuilder().array();\r\n    \/\/ starting with oldest commit\r\n    for (int i = commits.size() - 1; i >= 0; i--) {\r\n        StoredCommit commit = commits.get(i);\r\n        if (commit.getParentId() == null) {\r\n            continue;\r\n        }\r\n        commitBuff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).key(\"msg\").value(commit.getMsg());\r\n        String diff = diffCache.get(commit.getId());\r\n        if (diff == null) {\r\n            diff = diff(commit.getParentId(), commit.getId(), filter);\r\n            diffCache.put(commit.getId(), diff);\r\n        }\r\n        commitBuff.key(\"changes\").value(diff).endObject();\r\n    }\r\n    return commitBuff.endArray().toString();\r\n}","code_comment":null,"code_no_comment":"public String getJournal(String fromRevision, String toRevision, String filter) throws MicroKernelException {\r\n    if (rep == null) {\r\n        throw new IllegalStateException(\"this instance has already been disposed\");\r\n    }\r\n    Id fromRevisionId = Id.fromString(fromRevision);\r\n    Id toRevisionId = toRevision == null ? getHeadRevisionId() : Id.fromString(toRevision);\r\n    List<StoredCommit> commits = new ArrayList<StoredCommit>();\r\n    try {\r\n        StoredCommit toCommit = rep.getCommit(toRevisionId);\r\n        Commit fromCommit;\r\n        if (toRevisionId.equals(fromRevisionId)) {\r\n            fromCommit = toCommit;\r\n        } else {\r\n            fromCommit = rep.getCommit(fromRevisionId);\r\n            if (fromCommit.getCommitTS() > toCommit.getCommitTS()) {\r\n                                return \"[]\";\r\n            }\r\n        }\r\n                                StoredCommit commit = toCommit;\r\n        while (commit != null) {\r\n            commits.add(commit);\r\n            if (commit.getId().equals(fromRevisionId)) {\r\n                break;\r\n            }\r\n            Id commitId = commit.getParentId();\r\n            if (commitId == null) {\r\n                break;\r\n            }\r\n            commit = rep.getCommit(commitId);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new MicroKernelException(e);\r\n    }\r\n    JsopBuilder commitBuff = new JsopBuilder().array();\r\n        for (int i = commits.size() - 1; i >= 0; i--) {\r\n        StoredCommit commit = commits.get(i);\r\n        if (commit.getParentId() == null) {\r\n            continue;\r\n        }\r\n        commitBuff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).key(\"msg\").value(commit.getMsg());\r\n        String diff = diffCache.get(commit.getId());\r\n        if (diff == null) {\r\n            diff = diff(commit.getParentId(), commit.getId(), filter);\r\n            diffCache.put(commit.getId(), diff);\r\n        }\r\n        commitBuff.key(\"changes\").value(diff).endObject();\r\n    }\r\n    return commitBuff.endArray().toString();\r\n}","lc":1.5909090909,"pi":0.4162679426,"ma":2.6,"nbd":0.5,"ml":1.4166666667,"d":1.1765873016,"mi":-0.9238900634,"fo":2.8333333333,"r":-0.0263157895,"e":3.4548388398}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4927_8c827e33","label":1,"code":"@Override\r\npublic boolean isRedirect() {\r\n    return bufferedResponse.isRedirect();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean isRedirect() {\r\n    return bufferedResponse.isRedirect();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0005637773,"fo":-0.4166666667,"r":1.1842105263,"e":-0.1627934049}
{"project_name":"Compress","project_version":"37","label":1,"code":"\/\/ NOTE, using a Map here makes it impossible to ever support GNU\r\n\/\/ sparse files using the PAX Format 0.0, see\r\n\/\/ https:\/\/www.gnu.org\/software\/tar\/manual\/html_section\/tar_92.html#SEC188\r\nMap<String, String> parsePaxHeaders(final InputStream i) throws IOException {\r\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\r\n    \/\/ Format is \"length keyword=value\\n\";\r\n    while (true) {\r\n        \/\/ get length\r\n        int ch;\r\n        int len = 0;\r\n        int read = 0;\r\n        while ((ch = i.read()) != -1) {\r\n            read++;\r\n            if (ch == ' ') {\r\n                \/\/ Get keyword\r\n                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\r\n                while ((ch = i.read()) != -1) {\r\n                    read++;\r\n                    if (ch == '=') {\r\n                        \/\/ end of keyword\r\n                        final String keyword = coll.toString(CharsetNames.UTF_8);\r\n                        \/\/ Get rest of entry\r\n                        final int restLen = len - read;\r\n                        if (restLen == 1) {\r\n                            \/\/ only NL\r\n                            headers.remove(keyword);\r\n                        } else {\r\n                            final byte[] rest = new byte[restLen];\r\n                            final int got = IOUtils.readFully(i, rest);\r\n                            if (got != restLen) {\r\n                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\r\n                            }\r\n                            \/\/ Drop trailing NL\r\n                            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\r\n                            headers.put(keyword, value);\r\n                        }\r\n                        break;\r\n                    }\r\n                    coll.write((byte) ch);\r\n                }\r\n                \/\/ Processed single header\r\n                break;\r\n            }\r\n            len *= 10;\r\n            len += ch - '0';\r\n        }\r\n        if (ch == -1) {\r\n            \/\/ EOF\r\n            break;\r\n        }\r\n    }\r\n    return headers;\r\n}","code_comment":null,"code_no_comment":"Map<String, String> parsePaxHeaders(final InputStream i) throws IOException {\r\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\r\n        while (true) {\r\n                int ch;\r\n        int len = 0;\r\n        int read = 0;\r\n        while ((ch = i.read()) != -1) {\r\n            read++;\r\n            if (ch == ' ') {\r\n                                final ByteArrayOutputStream coll = new ByteArrayOutputStream();\r\n                while ((ch = i.read()) != -1) {\r\n                    read++;\r\n                    if (ch == '=') {\r\n                                                final String keyword = coll.toString(CharsetNames.UTF_8);\r\n                                                final int restLen = len - read;\r\n                        if (restLen == 1) {\r\n                                                        headers.remove(keyword);\r\n                        } else {\r\n                            final byte[] rest = new byte[restLen];\r\n                            final int got = IOUtils.readFully(i, rest);\r\n                            if (got != restLen) {\r\n                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \" + restLen + \" bytes, read \" + got);\r\n                            }\r\n                                                        final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\r\n                            headers.put(keyword, value);\r\n                        }\r\n                        break;\r\n                    }\r\n                    coll.write((byte) ch);\r\n                }\r\n                                break;\r\n            }\r\n            len *= 10;\r\n            len += ch - '0';\r\n        }\r\n        if (ch == -1) {\r\n                        break;\r\n        }\r\n    }\r\n    return headers;\r\n}","lc":1.2272727273,"pi":2.8899521531,"ma":1.8,"nbd":2.5,"ml":0.5,"d":1.6091269841,"mi":-0.756448203,"fo":0.0833333333,"r":-0.0263157895,"e":2.9094632988}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-218_15476a0d","label":1,"code":"@Override\r\npublic int compareTo(Key o) {\r\n    int compare = super.compareTo(o);\r\n    if (compare != 0)\r\n        return compare;\r\n    if (o instanceof MockMemKey) {\r\n        MockMemKey other = (MockMemKey) o;\r\n        if (count < other.count)\r\n            return -1;\r\n        if (count > other.count)\r\n            return 1;\r\n    } else {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int compareTo(Key o) {\r\n    int compare = super.compareTo(o);\r\n    if (compare != 0)\r\n        return compare;\r\n    if (o instanceof MockMemKey) {\r\n        MockMemKey other = (MockMemKey) o;\r\n        if (count < other.count)\r\n            return -1;\r\n        if (count > other.count)\r\n            return 1;\r\n    } else {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}","lc":0.0909090909,"pi":0.3444976077,"ma":0.2,"nbd":-0.5,"ml":0.25,"d":0.6091269841,"mi":-0.0367864693,"fo":-0.4166666667,"r":0.3157894737,"e":0.1359566167}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3110_d10362c0","label":1,"code":"@Override\r\npublic void close() throws IOException {\r\n    int pendingCopies = queue.size();\r\n    addTask(STOP);\r\n    \/\/ Wait for all pending copy task to finish\r\n    try {\r\n        long start = PERF_LOGGER.start();\r\n        \/\/ prevent any bug causing the thread to wait indefinitely\r\n        while (!copyDone.await(10, TimeUnit.SECONDS)) {\r\n            if (closed) {\r\n                throw new IndexCopierClosedException(\"IndexCopier found to be closed \" + \"while processing copy task for\" + remote.toString());\r\n            }\r\n        }\r\n        PERF_LOGGER.end(start, -1, \"[COW][{}] Completed pending copying task {}\", indexPathForLogging, pendingCopies);\r\n    } catch (InterruptedException e) {\r\n        Thread.currentThread().interrupt();\r\n        throw new IOException(e);\r\n    }\r\n    Throwable t = errorInCopy.get();\r\n    if (t != null) {\r\n        throw new IOException(\"Error occurred while copying files for \" + indexPathForLogging, t);\r\n    }\r\n    \/\/ Sanity check\r\n    checkArgument(queue.isEmpty(), \"Copy queue still \" + \"has pending task left [%d]. %s\", queue.size(), queue);\r\n    long skippedFilesSize = getSkippedFilesSize();\r\n    for (String fileName : deletedFilesLocal) {\r\n        deleteLocalFile(fileName);\r\n    }\r\n    skippedFromUploadSize.addAndGet(skippedFilesSize);\r\n    String msg = \"[COW][{}] CopyOnWrite stats : Skipped copying {} files with total size {}\";\r\n    if (reindexMode || skippedFilesSize > 10 * FileUtils.ONE_MB) {\r\n        log.info(msg, indexPathForLogging, skippedFiles.size(), humanReadableByteCount(skippedFilesSize));\r\n    } else {\r\n        log.debug(msg, indexPathForLogging, skippedFiles.size(), humanReadableByteCount(skippedFilesSize));\r\n    }\r\n    if (log.isTraceEnabled()) {\r\n        log.trace(\"[COW][{}] File listing - Upon completion {}\", indexPathForLogging, Arrays.toString(remote.listAll()));\r\n    }\r\n    local.close();\r\n    remote.close();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void close() throws IOException {\r\n    int pendingCopies = queue.size();\r\n    addTask(STOP);\r\n        try {\r\n        long start = PERF_LOGGER.start();\r\n                while (!copyDone.await(10, TimeUnit.SECONDS)) {\r\n            if (closed) {\r\n                throw new IndexCopierClosedException(\"IndexCopier found to be closed \" + \"while processing copy task for\" + remote.toString());\r\n            }\r\n        }\r\n        PERF_LOGGER.end(start, -1, \"[COW][{}] Completed pending copying task {}\", indexPathForLogging, pendingCopies);\r\n    } catch (InterruptedException e) {\r\n        Thread.currentThread().interrupt();\r\n        throw new IOException(e);\r\n    }\r\n    Throwable t = errorInCopy.get();\r\n    if (t != null) {\r\n        throw new IOException(\"Error occurred while copying files for \" + indexPathForLogging, t);\r\n    }\r\n        checkArgument(queue.isEmpty(), \"Copy queue still \" + \"has pending task left [%d]. %s\", queue.size(), queue);\r\n    long skippedFilesSize = getSkippedFilesSize();\r\n    for (String fileName : deletedFilesLocal) {\r\n        deleteLocalFile(fileName);\r\n    }\r\n    skippedFromUploadSize.addAndGet(skippedFilesSize);\r\n    String msg = \"[COW][{}] CopyOnWrite stats : Skipped copying {} files with total size {}\";\r\n    if (reindexMode || skippedFilesSize > 10 * FileUtils.ONE_MB) {\r\n        log.info(msg, indexPathForLogging, skippedFiles.size(), humanReadableByteCount(skippedFilesSize));\r\n    } else {\r\n        log.debug(msg, indexPathForLogging, skippedFiles.size(), humanReadableByteCount(skippedFilesSize));\r\n    }\r\n    if (log.isTraceEnabled()) {\r\n        log.trace(\"[COW][{}] File listing - Upon completion {}\", indexPathForLogging, Arrays.toString(remote.listAll()));\r\n    }\r\n    local.close();\r\n    remote.close();\r\n}","lc":1.0909090909,"pi":0.1244019139,"ma":1.4,"nbd":0.5,"ml":0.5833333333,"d":0.8928571429,"mi":-0.7200845666,"fo":1.75,"r":-0.0263157895,"e":1.9535231641}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5898_ffdd0864","label":1,"code":"\/**\r\n *  Get the markup for the child component, which is assumed to be a child of 'container'.\r\n *\/\r\n@Override\r\npublic IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {\r\n    \/\/ If the sourcing strategy did not provide one, than ask the component.\r\n    \/\/ Get the markup for the container\r\n    IMarkupFragment markup = container.getMarkup();\r\n    if (markup == null) {\r\n        return null;\r\n    }\r\n    if (child == null) {\r\n        return markup;\r\n    }\r\n    \/\/ Find the child's markup\r\n    markup = markup.find(child.getId());\r\n    if (markup != null) {\r\n        return markup;\r\n    }\r\n    markup = searchMarkupInTransparentResolvers(container, child);\r\n    return markup;\r\n}","code_comment":"\/**\r\n *  Get the markup for the child component, which is assumed to be a child of 'container'.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {\r\n            IMarkupFragment markup = container.getMarkup();\r\n    if (markup == null) {\r\n        return null;\r\n    }\r\n    if (child == null) {\r\n        return markup;\r\n    }\r\n        markup = markup.find(child.getId());\r\n    if (markup != null) {\r\n        return markup;\r\n    }\r\n    markup = searchMarkupInTransparentResolvers(container, child);\r\n    return markup;\r\n}","lc":0.0909090909,"pi":-0.2583732057,"ma":0.0,"nbd":-0.5,"ml":0.0,"d":0.1071428571,"mi":-0.0469344609,"fo":-0.1666666667,"r":0.0,"e":-0.0000852913}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4353_b0014b7d","label":1,"code":"@Override\r\npublic void writeSegment(SegmentId id, byte[] data, int offset, int length) throws IOException {\r\n    fileStoreLock.writeLock().lock();\r\n    try {\r\n        int generation = Segment.getGcGen(wrap(data, offset, length));\r\n        long size = writer.writeEntry(id.getMostSignificantBits(), id.getLeastSignificantBits(), data, offset, length, generation);\r\n        if (size >= maxFileSize) {\r\n            newWriter();\r\n        }\r\n        approximateSize.addAndGet(TarWriter.BLOCK_SIZE + length + TarWriter.getPaddingSize(length));\r\n    } finally {\r\n        fileStoreLock.writeLock().unlock();\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void writeSegment(SegmentId id, byte[] data, int offset, int length) throws IOException {\r\n    fileStoreLock.writeLock().lock();\r\n    try {\r\n        int generation = Segment.getGcGen(wrap(data, offset, length));\r\n        long size = writer.writeEntry(id.getMostSignificantBits(), id.getLeastSignificantBits(), data, offset, length, generation);\r\n        if (size >= maxFileSize) {\r\n            newWriter();\r\n        }\r\n        approximateSize.addAndGet(TarWriter.BLOCK_SIZE + length + TarWriter.getPaddingSize(length));\r\n    } finally {\r\n        fileStoreLock.writeLock().unlock();\r\n    }\r\n}","lc":0.0,"pi":0.2822966507,"ma":-0.4,"nbd":0.0,"ml":-0.1666666667,"d":-0.0634920635,"mi":-0.0438336857,"fo":0.5,"r":-0.0263157895,"e":0.00508751}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3618_fbfd17e6","label":1,"code":"\/**\r\n *  Writes the content of the buffer to the specified response. Also sets the properties and and\r\n *  headers.\r\n *\r\n *  @param response\r\n *\/\r\npublic void writeTo(final WebResponse response) {\r\n    Args.notNull(response, \"response\");\r\n    for (Action action : actions) {\r\n        action.invoke(response);\r\n    }\r\n}","code_comment":"\/**\r\n *  Writes the content of the buffer to the specified response. Also sets the properties and and\r\n *  headers.\r\n *\r\n *  @param response\r\n *\/\r\n","code_no_comment":"public void writeTo(final WebResponse response) {\r\n    Args.notNull(response, \"response\");\r\n    for (Action action : actions) {\r\n        action.invoke(response);\r\n    }\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5836504581,"fo":-0.3333333333,"r":1.9473684211,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7213_336663c9","label":1,"code":"@Converter\r\npublic static ByteBuffer toByteBuffer(Short value) {\r\n    ByteBuffer buf = ByteBuffer.allocate(2);\r\n    buf.putShort(value);\r\n    return buf;\r\n}","code_comment":null,"code_no_comment":"@Converter\r\npublic static ByteBuffer toByteBuffer(Short value) {\r\n    ByteBuffer buf = ByteBuffer.allocate(2);\r\n    buf.putShort(value);\r\n    return buf;\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5644820296,"fo":-0.3333333333,"r":1.2105263158,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2172_ea4a3f8a","label":3,"code":"\/**\r\n *  @see IValueMap#getAsDuration(String)\r\n *\/\r\npublic Duration getAsDuration(String key) {\r\n    return getAsDuration(key, null);\r\n}","code_comment":"\/**\r\n *  @see IValueMap#getAsDuration(String)\r\n *\/\r\n","code_no_comment":"public Duration getAsDuration(String key) {\r\n    return getAsDuration(key, null);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0253699789,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-478_a7f0e808","label":1,"code":"@Override\r\npublic void childNodeAdded(String name, NodeState after) {\r\n    childNodeChanged(name, EMPTY_NODE, after);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void childNodeAdded(String name, NodeState after) {\r\n    childNodeChanged(name, EMPTY_NODE, after);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8173361522,"fo":-0.4166666667,"r":0.2105263158,"e":-0.1627934049}
{"project_name":"Closure","project_version":"149","label":2,"code":"\/**\r\n * Parses command-line arguments and runs the compiler.\r\n *\r\n * @return system exit status\r\n *\/\r\nprotected int doRun() throws FlagUsageException, IOException {\r\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\r\n    List<JSSourceFile> externsList = createExterns();\r\n    JSSourceFile[] externs = new JSSourceFile[externsList.size()];\r\n    externsList.toArray(externs);\r\n    compiler = createCompiler();\r\n    B options = createOptions();\r\n    JSModule[] modules = null;\r\n    Result result;\r\n    setRunOptions(options);\r\n    if (inputCharset == Charsets.UTF_8) {\r\n        options.outputCharset = Charsets.US_ASCII;\r\n    } else {\r\n        options.outputCharset = inputCharset;\r\n    }\r\n    boolean writeOutputToFile = !options.jsOutputFile.isEmpty();\r\n    if (writeOutputToFile) {\r\n        out = toWriter(options.jsOutputFile, inputCharset.name());\r\n    }\r\n    List<String> jsFiles = config.js;\r\n    List<String> moduleSpecs = config.module;\r\n    if (!moduleSpecs.isEmpty()) {\r\n        modules = createJsModules(moduleSpecs, jsFiles);\r\n        result = compiler.compile(externs, modules, options);\r\n    } else {\r\n        List<JSSourceFile> inputList = createSourceInputs(jsFiles);\r\n        JSSourceFile[] inputs = new JSSourceFile[inputList.size()];\r\n        inputList.toArray(inputs);\r\n        result = compiler.compile(externs, inputs, options);\r\n    }\r\n    int errCode = processResults(result, modules, options);\r\n    \/\/ Close the output if we are writing to a file.\r\n    if (writeOutputToFile) {\r\n        ((Writer) out).close();\r\n    }\r\n    return errCode;\r\n}","code_comment":"\/**\r\n * Parses command-line arguments and runs the compiler.\r\n *\r\n * @return system exit status\r\n *\/\r\n","code_no_comment":"protected int doRun() throws FlagUsageException, IOException {\r\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\r\n    List<JSSourceFile> externsList = createExterns();\r\n    JSSourceFile[] externs = new JSSourceFile[externsList.size()];\r\n    externsList.toArray(externs);\r\n    compiler = createCompiler();\r\n    B options = createOptions();\r\n    JSModule[] modules = null;\r\n    Result result;\r\n    setRunOptions(options);\r\n    if (inputCharset == Charsets.UTF_8) {\r\n        options.outputCharset = Charsets.US_ASCII;\r\n    } else {\r\n        options.outputCharset = inputCharset;\r\n    }\r\n    boolean writeOutputToFile = !options.jsOutputFile.isEmpty();\r\n    if (writeOutputToFile) {\r\n        out = toWriter(options.jsOutputFile, inputCharset.name());\r\n    }\r\n    List<String> jsFiles = config.js;\r\n    List<String> moduleSpecs = config.module;\r\n    if (!moduleSpecs.isEmpty()) {\r\n        modules = createJsModules(moduleSpecs, jsFiles);\r\n        result = compiler.compile(externs, modules, options);\r\n    } else {\r\n        List<JSSourceFile> inputList = createSourceInputs(jsFiles);\r\n        JSSourceFile[] inputs = new JSSourceFile[inputList.size()];\r\n        inputList.toArray(inputs);\r\n        result = compiler.compile(externs, inputs, options);\r\n    }\r\n    int errCode = processResults(result, modules, options);\r\n        if (writeOutputToFile) {\r\n        ((Writer) out).close();\r\n    }\r\n    return errCode;\r\n}","lc":1.0,"pi":-0.4114832536,"ma":0.2,"nbd":-0.5,"ml":0.1666666667,"d":0.0317460317,"mi":-0.6580690627,"fo":1.1666666667,"r":-0.0263157895,"e":0.5119067789}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4933_469d0096","label":1,"code":"public String alignToBaseDirectory(String path, File basedir) {\r\n    if (path == null) {\r\n        return null;\r\n    }\r\n    String s = stripBasedirToken(path);\r\n    File file = new File(s);\r\n    if (file.isAbsolute()) {\r\n        \/\/ path was already absolute, just normalize file separator and we're done\r\n        s = file.getPath();\r\n    } else if (file.getPath().startsWith(File.separator)) {\r\n        \/\/ drive-relative Windows path, don't align with project directory but with drive root\r\n        s = file.getAbsolutePath();\r\n    } else {\r\n        \/\/ an ordinary relative path, align with project directory\r\n        s = new File(new File(basedir, s).toURI().normalize()).getAbsolutePath();\r\n    }\r\n    return s;\r\n}","code_comment":null,"code_no_comment":"public String alignToBaseDirectory(String path, File basedir) {\r\n    if (path == null) {\r\n        return null;\r\n    }\r\n    String s = stripBasedirToken(path);\r\n    File file = new File(s);\r\n    if (file.isAbsolute()) {\r\n                s = file.getPath();\r\n    } else if (file.getPath().startsWith(File.separator)) {\r\n                s = file.getAbsolutePath();\r\n    } else {\r\n                s = new File(new File(basedir, s).toURI().normalize()).getAbsolutePath();\r\n    }\r\n    return s;\r\n}","lc":0.0454545455,"pi":-0.2488038278,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":0.1011904762,"mi":-0.058210007,"fo":0.25,"r":0.0526315789,"e":0.0491808002}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1308_69ba2a54","label":1,"code":"private Expression.Property readProperty() throws ParseException {\r\n    if (readIf(\"*\")) {\r\n        return new Expression.Property(currentSelector, \"*\");\r\n    }\r\n    return new Expression.Property(currentSelector, readIdentifier());\r\n}","code_comment":null,"code_no_comment":"private Expression.Property readProperty() throws ParseException {\r\n    if (readIf(\"*\")) {\r\n        return new Expression.Property(currentSelector, \"*\");\r\n    }\r\n    return new Expression.Property(currentSelector, readIdentifier());\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.5802677942,"fo":-0.3333333333,"r":0.0789473684,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4520_b91154ea","label":1,"code":"@Override\r\npublic Component resolve(MarkupContainer container, MarkupStream markupStream, ComponentTag tag) {\r\n    \/\/ localize any raw markup that has wicket:message attrs\r\n    if ((tag != null) && (tag.getId().startsWith(WICKET_MESSAGE_CONTAINER_ID))) {\r\n        Component wc = null;\r\n        int autoIndex = container.getPage().getAutoIndex();\r\n        String id = WICKET_MESSAGE_CONTAINER_ID + autoIndex;\r\n        if (tag.isOpenClose()) {\r\n            wc = new WebComponent(id);\r\n        } else {\r\n            wc = new TransparentWebMarkupContainer(id);\r\n        }\r\n        return wc;\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Component resolve(MarkupContainer container, MarkupStream markupStream, ComponentTag tag) {\r\n        if ((tag != null) && (tag.getId().startsWith(WICKET_MESSAGE_CONTAINER_ID))) {\r\n        Component wc = null;\r\n        int autoIndex = container.getPage().getAutoIndex();\r\n        String id = WICKET_MESSAGE_CONTAINER_ID + autoIndex;\r\n        if (tag.isOpenClose()) {\r\n            wc = new WebComponent(id);\r\n        } else {\r\n            wc = new TransparentWebMarkupContainer(id);\r\n        }\r\n        return wc;\r\n    }\r\n    return null;\r\n}","lc":0.0454545455,"pi":0.4019138756,"ma":-0.2,"nbd":0.0,"ml":0.0833333333,"d":0.2738095238,"mi":-0.0649753347,"fo":-0.0833333333,"r":0.9736842105,"e":0.1545962207}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2318_1d08cbd3","label":3,"code":"\/**\r\n * Returns the minimum timestamp of the most recent revisions from all\r\n * active cluster nodes as seen from the given {@code revision}.\r\n *\r\n * @param revision a revision.\r\n * @param inactive map of cluster nodes considered inactive.\r\n * @return the minimum timestamp.\r\n *\/\r\npublic long getMinimumTimestamp(@Nonnull Revision revision, @Nonnull Map<Integer, Long> inactive) {\r\n    long timestamp = checkNotNull(revision).getTimestamp();\r\n    Revision seenAt = getRevisionSeen(revision);\r\n    if (seenAt == null) {\r\n        \/\/ already purged\r\n        return timestamp;\r\n    }\r\n    \/\/ go through all known cluster nodes\r\n    for (List<RevisionRange> list : map.values()) {\r\n        RevisionRange range;\r\n        for (int i = list.size() - 1; i >= 0; i--) {\r\n            range = list.get(i);\r\n            if (range.seenAt.compareRevisionTimeThenClusterId(seenAt) <= 0) {\r\n                \/\/ found newest range older or equal the given seenAt\r\n                \/\/ check if the cluster node is still active\r\n                Long inactiveSince = inactive.get(range.revision.getClusterId());\r\n                if (inactiveSince != null && revision.getTimestamp() > inactiveSince && range.revision.getTimestamp() < inactiveSince) {\r\n                \/\/ ignore, because the revision is after the\r\n                \/\/ cluster node became inactive and the most recent\r\n                \/\/ range is before it became inactive\r\n                } else {\r\n                    timestamp = Math.min(timestamp, range.revision.getTimestamp());\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return timestamp;\r\n}","code_comment":"\/**\r\n * Returns the minimum timestamp of the most recent revisions from all\r\n * active cluster nodes as seen from the given {@code revision}.\r\n *\r\n * @param revision a revision.\r\n * @param inactive map of cluster nodes considered inactive.\r\n * @return the minimum timestamp.\r\n *\/\r\n","code_no_comment":"public long getMinimumTimestamp(@Nonnull Revision revision, @Nonnull Map<Integer, Long> inactive) {\r\n    long timestamp = checkNotNull(revision).getTimestamp();\r\n    Revision seenAt = getRevisionSeen(revision);\r\n    if (seenAt == null) {\r\n                return timestamp;\r\n    }\r\n        for (List<RevisionRange> list : map.values()) {\r\n        RevisionRange range;\r\n        for (int i = list.size() - 1; i >= 0; i--) {\r\n            range = list.get(i);\r\n            if (range.seenAt.compareRevisionTimeThenClusterId(seenAt) <= 0) {\r\n                                                Long inactiveSince = inactive.get(range.revision.getClusterId());\r\n                if (inactiveSince != null && revision.getTimestamp() > inactiveSince && range.revision.getTimestamp() < inactiveSince) {\r\n                                                                } else {\r\n                    timestamp = Math.min(timestamp, range.revision.getTimestamp());\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return timestamp;\r\n}","lc":0.3636363636,"pi":1.3349282297,"ma":0.6,"nbd":1.0,"ml":0.5833333333,"d":1.8115079365,"mi":-0.3747709655,"fo":0.5833333333,"r":-0.0263157895,"e":2.1128057952}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1668_63070cf9","label":1,"code":"\/**\r\n * Get the Lucene query for the given filter.\r\n *\r\n * @param filter the filter, including full-text constraint\r\n * @param reader the Lucene reader\r\n * @param nonFullTextConstraints whether non-full-text constraints (such a\r\n *            path, node type, and so on) should be added to the Lucene\r\n *            query\r\n * @param analyzer the Lucene analyzer used for building the fulltext query\r\n * @return the Lucene query\r\n *\/\r\nprivate static Query getQuery(Filter filter, IndexReader reader, boolean nonFullTextConstraints, Analyzer analyzer) {\r\n    List<Query> qs = new ArrayList<Query>();\r\n    FullTextExpression ft = filter.getFullTextConstraint();\r\n    if (ft == null) {\r\n    \/\/ there might be no full-text constraint\r\n    \/\/ when using the LowCostLuceneIndexProvider\r\n    \/\/ which is used for testing\r\n    } else {\r\n        qs.add(getFullTextQuery(ft, analyzer, reader));\r\n    }\r\n    PropertyRestriction pr = filter.getPropertyRestriction(NATIVE_QUERY_FUNCTION);\r\n    if (pr != null) {\r\n        String query = String.valueOf(pr.first.getValue(pr.first.getType()));\r\n        QueryParser queryParser = new QueryParser(VERSION, \"\", analyzer);\r\n        if (query.startsWith(\"mlt?\")) {\r\n            String mltQueryString = query.replace(\"mlt?\", \"\");\r\n            if (reader != null) {\r\n                Query moreLikeThis = MoreLikeThisHelper.getMoreLikeThis(reader, analyzer, mltQueryString);\r\n                if (moreLikeThis != null) {\r\n                    qs.add(moreLikeThis);\r\n                }\r\n            }\r\n        } else {\r\n            try {\r\n                qs.add(queryParser.parse(query));\r\n            } catch (ParseException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    } else if (nonFullTextConstraints) {\r\n        addNonFullTextConstraints(qs, filter, reader, analyzer);\r\n    }\r\n    if (qs.size() == 0) {\r\n        return new MatchAllDocsQuery();\r\n    }\r\n    if (qs.size() == 1) {\r\n        return qs.get(0);\r\n    }\r\n    BooleanQuery bq = new BooleanQuery();\r\n    for (Query q : qs) {\r\n        bq.add(q, MUST);\r\n    }\r\n    return bq;\r\n}","code_comment":"\/**\r\n * Get the Lucene query for the given filter.\r\n *\r\n * @param filter the filter, including full-text constraint\r\n * @param reader the Lucene reader\r\n * @param nonFullTextConstraints whether non-full-text constraints (such a\r\n *            path, node type, and so on) should be added to the Lucene\r\n *            query\r\n * @param analyzer the Lucene analyzer used for building the fulltext query\r\n * @return the Lucene query\r\n *\/\r\n","code_no_comment":"private static Query getQuery(Filter filter, IndexReader reader, boolean nonFullTextConstraints, Analyzer analyzer) {\r\n    List<Query> qs = new ArrayList<Query>();\r\n    FullTextExpression ft = filter.getFullTextConstraint();\r\n    if (ft == null) {\r\n                } else {\r\n        qs.add(getFullTextQuery(ft, analyzer, reader));\r\n    }\r\n    PropertyRestriction pr = filter.getPropertyRestriction(NATIVE_QUERY_FUNCTION);\r\n    if (pr != null) {\r\n        String query = String.valueOf(pr.first.getValue(pr.first.getType()));\r\n        QueryParser queryParser = new QueryParser(VERSION, \"\", analyzer);\r\n        if (query.startsWith(\"mlt?\")) {\r\n            String mltQueryString = query.replace(\"mlt?\", \"\");\r\n            if (reader != null) {\r\n                Query moreLikeThis = MoreLikeThisHelper.getMoreLikeThis(reader, analyzer, mltQueryString);\r\n                if (moreLikeThis != null) {\r\n                    qs.add(moreLikeThis);\r\n                }\r\n            }\r\n        } else {\r\n            try {\r\n                qs.add(queryParser.parse(query));\r\n            } catch (ParseException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    } else if (nonFullTextConstraints) {\r\n        addNonFullTextConstraints(qs, filter, reader, analyzer);\r\n    }\r\n    if (qs.size() == 0) {\r\n        return new MatchAllDocsQuery();\r\n    }\r\n    if (qs.size() == 1) {\r\n        return qs.get(0);\r\n    }\r\n    BooleanQuery bq = new BooleanQuery();\r\n    for (Query q : qs) {\r\n        bq.add(q, MUST);\r\n    }\r\n    return bq;\r\n}","lc":1.2272727273,"pi":0.8803827751,"ma":1.6,"nbd":1.0,"ml":0.8333333333,"d":0.0357142857,"mi":-0.7598308668,"fo":1.0,"r":-0.0263157895,"e":0.50486679}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3760_494212b3","label":0,"code":"\/**\r\n *  Initializes the serializer, unless it has been initialized before.\r\n *\r\n *  @param executionConfig The execution config to use when creating the serializer.\r\n *\/\r\npublic void initializeSerializerUnlessSet(ExecutionConfig executionConfig) {\r\n    if (serializer == null) {\r\n        if (typeInfo != null) {\r\n            serializer = typeInfo.createSerializer(executionConfig);\r\n        } else {\r\n            throw new IllegalStateException(\"Cannot initialize serializer after TypeInformation was dropped during serialization\");\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  Initializes the serializer, unless it has been initialized before.\r\n *\r\n *  @param executionConfig The execution config to use when creating the serializer.\r\n *\/\r\n","code_no_comment":"public void initializeSerializerUnlessSet(ExecutionConfig executionConfig) {\r\n    if (serializer == null) {\r\n        if (typeInfo != null) {\r\n            serializer = typeInfo.createSerializer(executionConfig);\r\n        } else {\r\n            throw new IllegalStateException(\"Cannot initialize serializer after TypeInformation was dropped during serialization\");\r\n        }\r\n    }\r\n}","lc":-0.2272727273,"pi":0.6076555024,"ma":0.0,"nbd":0.0,"ml":-0.0833333333,"d":-0.0873015873,"mi":0.3412262156,"fo":-0.4166666667,"r":1.3684210526,"e":-0.1221901419}
{"project_name":"Closure","project_version":"126","label":2,"code":"\/**\r\n * Attempts to minimize the number of explicit exit points in a control\r\n * structure to take advantage of the implied exit at the end of the\r\n * structure.  This is accomplished by removing redundant statements, and\r\n * moving statements following a qualifying IF node into that node.\r\n * For example:\r\n *\r\n * function () {\r\n *   if (x) return;\r\n *   else blah();\r\n *   foo();\r\n * }\r\n *\r\n * becomes:\r\n *\r\n * function () {\r\n *  if (x) ;\r\n *  else {\r\n *    blah();\r\n *    foo();\r\n *  }\r\n *\r\n * @param n The execution node of a parent to inspect.\r\n * @param exitType The type of exit to look for.\r\n * @param labelName If parent is a label the name of the label to look for,\r\n *   null otherwise.\r\n * @nullable labelName non-null only for breaks within labels.\r\n *\/\r\nvoid tryMinimizeExits(Node n, int exitType, String labelName) {\r\n    \/\/ Just an 'exit'.\r\n    if (matchingExitNode(n, exitType, labelName)) {\r\n        NodeUtil.removeChild(n.getParent(), n);\r\n        compiler.reportCodeChange();\r\n        return;\r\n    }\r\n    \/\/ Just an 'if'.\r\n    if (n.isIf()) {\r\n        Node ifBlock = n.getFirstChild().getNext();\r\n        tryMinimizeExits(ifBlock, exitType, labelName);\r\n        Node elseBlock = ifBlock.getNext();\r\n        if (elseBlock != null) {\r\n            tryMinimizeExits(elseBlock, exitType, labelName);\r\n        }\r\n        return;\r\n    }\r\n    \/\/ Just a 'try\/catch\/finally'.\r\n    if (n.isTry()) {\r\n        Node tryBlock = n.getFirstChild();\r\n        tryMinimizeExits(tryBlock, exitType, labelName);\r\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\r\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\r\n            Preconditions.checkState(allCatchNodes.hasOneChild());\r\n            Node catchNode = allCatchNodes.getFirstChild();\r\n            Node catchCodeBlock = catchNode.getLastChild();\r\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\r\n        }\r\n        \/* Don't try to minimize the exits of finally blocks, as this\r\n       * can cause problems if it changes the completion type of the finally\r\n       * block. See ECMA 262 Sections 8.9 & 12.14\r\n       *\/\r\n        if (NodeUtil.hasFinally(n)) {\r\n            Node finallyBlock = n.getLastChild();\r\n            tryMinimizeExits(finallyBlock, exitType, labelName);\r\n        }\r\n    }\r\n    \/\/ Just a 'label'.\r\n    if (n.isLabel()) {\r\n        Node labelBlock = n.getLastChild();\r\n        tryMinimizeExits(labelBlock, exitType, labelName);\r\n    }\r\n    \/\/ The rest assumes a block with at least one child, bail on anything else.\r\n    if (!n.isBlock() || n.getLastChild() == null) {\r\n        return;\r\n    }\r\n    \/\/ which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\r\n    for (Node c : n.children()) {\r\n        \/\/ An 'if' block to process below.\r\n        if (c.isIf()) {\r\n            Node ifTree = c;\r\n            Node trueBlock, falseBlock;\r\n            \/\/ First, the true condition block.\r\n            trueBlock = ifTree.getFirstChild().getNext();\r\n            falseBlock = trueBlock.getNext();\r\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\r\n            \/\/ Now the else block.\r\n            \/\/ The if blocks may have changed, get them again.\r\n            trueBlock = ifTree.getFirstChild().getNext();\r\n            falseBlock = trueBlock.getNext();\r\n            if (falseBlock != null) {\r\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\r\n            }\r\n        }\r\n        if (c == n.getLastChild()) {\r\n            break;\r\n        }\r\n    }\r\n    \/\/ look at what has become the last child.\r\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\r\n        tryMinimizeExits(c, exitType, labelName);\r\n        \/\/ If the node is still the last child, we are done.\r\n        if (c == n.getLastChild()) {\r\n            break;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Attempts to minimize the number of explicit exit points in a control\r\n * structure to take advantage of the implied exit at the end of the\r\n * structure.  This is accomplished by removing redundant statements, and\r\n * moving statements following a qualifying IF node into that node.\r\n * For example:\r\n *\r\n * function () {\r\n *   if (x) return;\r\n *   else blah();\r\n *   foo();\r\n * }\r\n *\r\n * becomes:\r\n *\r\n * function () {\r\n *  if (x) ;\r\n *  else {\r\n *    blah();\r\n *    foo();\r\n *  }\r\n *\r\n * @param n The execution node of a parent to inspect.\r\n * @param exitType The type of exit to look for.\r\n * @param labelName If parent is a label the name of the label to look for,\r\n *   null otherwise.\r\n * @nullable labelName non-null only for breaks within labels.\r\n *\/\r\n","code_no_comment":"void tryMinimizeExits(Node n, int exitType, String labelName) {\r\n        if (matchingExitNode(n, exitType, labelName)) {\r\n        NodeUtil.removeChild(n.getParent(), n);\r\n        compiler.reportCodeChange();\r\n        return;\r\n    }\r\n        if (n.isIf()) {\r\n        Node ifBlock = n.getFirstChild().getNext();\r\n        tryMinimizeExits(ifBlock, exitType, labelName);\r\n        Node elseBlock = ifBlock.getNext();\r\n        if (elseBlock != null) {\r\n            tryMinimizeExits(elseBlock, exitType, labelName);\r\n        }\r\n        return;\r\n    }\r\n        if (n.isTry()) {\r\n        Node tryBlock = n.getFirstChild();\r\n        tryMinimizeExits(tryBlock, exitType, labelName);\r\n        Node allCatchNodes = NodeUtil.getCatchBlock(n);\r\n        if (NodeUtil.hasCatchHandler(allCatchNodes)) {\r\n            Preconditions.checkState(allCatchNodes.hasOneChild());\r\n            Node catchNode = allCatchNodes.getFirstChild();\r\n            Node catchCodeBlock = catchNode.getLastChild();\r\n            tryMinimizeExits(catchCodeBlock, exitType, labelName);\r\n        }\r\n                if (NodeUtil.hasFinally(n)) {\r\n            Node finallyBlock = n.getLastChild();\r\n            tryMinimizeExits(finallyBlock, exitType, labelName);\r\n        }\r\n    }\r\n        if (n.isLabel()) {\r\n        Node labelBlock = n.getLastChild();\r\n        tryMinimizeExits(labelBlock, exitType, labelName);\r\n    }\r\n        if (!n.isBlock() || n.getLastChild() == null) {\r\n        return;\r\n    }\r\n        for (Node c : n.children()) {\r\n                if (c.isIf()) {\r\n            Node ifTree = c;\r\n            Node trueBlock, falseBlock;\r\n                        trueBlock = ifTree.getFirstChild().getNext();\r\n            falseBlock = trueBlock.getNext();\r\n            tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\r\n                                    trueBlock = ifTree.getFirstChild().getNext();\r\n            falseBlock = trueBlock.getNext();\r\n            if (falseBlock != null) {\r\n                tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\r\n            }\r\n        }\r\n        if (c == n.getLastChild()) {\r\n            break;\r\n        }\r\n    }\r\n        for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\r\n        tryMinimizeExits(c, exitType, labelName);\r\n                if (c == n.getLastChild()) {\r\n            break;\r\n        }\r\n    }\r\n}","lc":2.1363636364,"pi":0.1913875598,"ma":2.6,"nbd":0.5,"ml":2.0833333333,"d":1.1646825397,"mi":-1.0225510923,"fo":3.0833333333,"r":-0.0263157895,"e":3.3897039586}
{"project_name":"Lang","project_version":"60","label":1,"code":"\/**\r\n * Searches the string builder to find the first reference to the specified char.\r\n *\r\n * @param ch  the character to find\r\n * @param startIndex  the index to start at, invalid index rounded to edge\r\n * @return the first index of the character, or -1 if not found\r\n *\/\r\npublic int indexOf(char ch, int startIndex) {\r\n    startIndex = (startIndex < 0 ? 0 : startIndex);\r\n    if (startIndex >= size) {\r\n        return -1;\r\n    }\r\n    char[] thisBuf = buffer;\r\n    for (int i = startIndex; i < thisBuf.length; i++) {\r\n        if (thisBuf[i] == ch) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}","code_comment":"\/**\r\n * Searches the string builder to find the first reference to the specified char.\r\n *\r\n * @param ch  the character to find\r\n * @param startIndex  the index to start at, invalid index rounded to edge\r\n * @return the first index of the character, or -1 if not found\r\n *\/\r\n","code_no_comment":"public int indexOf(char ch, int startIndex) {\r\n    startIndex = (startIndex < 0 ? 0 : startIndex);\r\n    if (startIndex >= size) {\r\n        return -1;\r\n    }\r\n    char[] thisBuf = buffer;\r\n    for (int i = startIndex; i < thisBuf.length; i++) {\r\n        if (thisBuf[i] == ch) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}","lc":-0.0454545455,"pi":0.1004784689,"ma":0.2,"nbd":0.0,"ml":0.3333333333,"d":0.9880952381,"mi":0.0463706836,"fo":-0.5,"r":0.5526315789,"e":0.2869083637}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-778_5b9302d5","label":1,"code":"\/**\r\n * Multiply this by a single digit 0&lt;=x&lt;radix.\r\n * There are speed advantages in this special case\r\n * @param x multiplicand\r\n * @return product of this and x\r\n *\/\r\npublic Dfp multiply(final int x) {\r\n    Dfp result = newInstance(this);\r\n    \/* handle special cases *\/\r\n    if (nans != FINITE) {\r\n        if (isNaN()) {\r\n            return this;\r\n        }\r\n        if (nans == INFINITE && x != 0) {\r\n            result = newInstance(this);\r\n            return result;\r\n        }\r\n        if (nans == INFINITE && x == 0) {\r\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\r\n            result = newInstance(getZero());\r\n            result.nans = QNAN;\r\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\r\n            return result;\r\n        }\r\n    }\r\n    \/* range check x *\/\r\n    if (x < 0 || x >= RADIX) {\r\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\r\n        result = newInstance(getZero());\r\n        result.nans = QNAN;\r\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\r\n        return result;\r\n    }\r\n    int rh = 0;\r\n    for (int i = 0; i < mant.length; i++) {\r\n        final int r = mant[i] * x + rh;\r\n        rh = r \/ RADIX;\r\n        result.mant[i] = r - rh * RADIX;\r\n    }\r\n    int lostdigit = 0;\r\n    if (rh != 0) {\r\n        lostdigit = result.mant[0];\r\n        result.shiftRight();\r\n        result.mant[mant.length - 1] = rh;\r\n    }\r\n    if (result.mant[mant.length - 1] == 0) {\r\n        \/\/ if result is zero, set exp to zero\r\n        result.exp = 0;\r\n    }\r\n    final int excp = result.round(lostdigit);\r\n    if (excp != 0) {\r\n        result = dotrap(excp, MULTIPLY_TRAP, result, result);\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n * Multiply this by a single digit 0&lt;=x&lt;radix.\r\n * There are speed advantages in this special case\r\n * @param x multiplicand\r\n * @return product of this and x\r\n *\/\r\n","code_no_comment":"public Dfp multiply(final int x) {\r\n    Dfp result = newInstance(this);\r\n        if (nans != FINITE) {\r\n        if (isNaN()) {\r\n            return this;\r\n        }\r\n        if (nans == INFINITE && x != 0) {\r\n            result = newInstance(this);\r\n            return result;\r\n        }\r\n        if (nans == INFINITE && x == 0) {\r\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\r\n            result = newInstance(getZero());\r\n            result.nans = QNAN;\r\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\r\n            return result;\r\n        }\r\n    }\r\n        if (x < 0 || x >= RADIX) {\r\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\r\n        result = newInstance(getZero());\r\n        result.nans = QNAN;\r\n        result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\r\n        return result;\r\n    }\r\n    int rh = 0;\r\n    for (int i = 0; i < mant.length; i++) {\r\n        final int r = mant[i] * x + rh;\r\n        rh = r \/ RADIX;\r\n        result.mant[i] = r - rh * RADIX;\r\n    }\r\n    int lostdigit = 0;\r\n    if (rh != 0) {\r\n        lostdigit = result.mant[0];\r\n        result.shiftRight();\r\n        result.mant[mant.length - 1] = rh;\r\n    }\r\n    if (result.mant[mant.length - 1] == 0) {\r\n                result.exp = 0;\r\n    }\r\n    final int excp = result.round(lostdigit);\r\n    if (excp != 0) {\r\n        result = dotrap(excp, MULTIPLY_TRAP, result, result);\r\n    }\r\n    return result;\r\n}","lc":1.4545454545,"pi":0.0956937799,"ma":1.2,"nbd":0.0,"ml":1.1666666667,"d":4.3194444444,"mi":-0.8303030303,"fo":0.8333333333,"r":-0.0263157895,"e":9.465979726}
{"project_name":"Closure","project_version":"68","label":2,"code":"\/**\r\n * FunctionType := 'function' FunctionSignatureType\r\n * FunctionSignatureType :=\r\n *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\r\n *\/\r\nprivate Node parseFunctionType(JsDocToken token) {\r\n    \/\/ just throw out TypeParameters.\r\n    if (token != JsDocToken.LP) {\r\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\r\n    }\r\n    Node functionType = newNode(Token.FUNCTION);\r\n    Node parameters = null;\r\n    skipEOLs();\r\n    if (!match(JsDocToken.RP)) {\r\n        token = next();\r\n        boolean hasParams = true;\r\n        if (token == JsDocToken.STRING) {\r\n            String tokenStr = stream.getString();\r\n            boolean isThis = \"this\".equals(tokenStr);\r\n            boolean isNew = \"new\".equals(tokenStr);\r\n            if (isThis || isNew) {\r\n                if (match(JsDocToken.COLON)) {\r\n                    next();\r\n                    skipEOLs();\r\n                    Node contextType = wrapNode(isThis ? Token.THIS : Token.NEW, parseTypeName(next()));\r\n                    if (contextType == null) {\r\n                        return null;\r\n                    }\r\n                    functionType.addChildToFront(contextType);\r\n                } else {\r\n                    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\r\n                }\r\n                if (match(JsDocToken.COMMA)) {\r\n                    next();\r\n                    skipEOLs();\r\n                    token = next();\r\n                } else {\r\n                    hasParams = false;\r\n                }\r\n            }\r\n        }\r\n        if (hasParams) {\r\n            parameters = parseParametersType(token);\r\n            if (parameters == null) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    if (parameters != null) {\r\n        functionType.addChildToBack(parameters);\r\n    }\r\n    skipEOLs();\r\n    if (!match(JsDocToken.RP)) {\r\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\r\n    }\r\n    skipEOLs();\r\n    Node resultType = parseResultType(next());\r\n    if (resultType == null) {\r\n        return null;\r\n    } else {\r\n        functionType.addChildToBack(resultType);\r\n    }\r\n    return functionType;\r\n}","code_comment":"\/**\r\n * FunctionType := 'function' FunctionSignatureType\r\n * FunctionSignatureType :=\r\n *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\r\n *\/\r\n","code_no_comment":"private Node parseFunctionType(JsDocToken token) {\r\n        if (token != JsDocToken.LP) {\r\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\r\n    }\r\n    Node functionType = newNode(Token.FUNCTION);\r\n    Node parameters = null;\r\n    skipEOLs();\r\n    if (!match(JsDocToken.RP)) {\r\n        token = next();\r\n        boolean hasParams = true;\r\n        if (token == JsDocToken.STRING) {\r\n            String tokenStr = stream.getString();\r\n            boolean isThis = \"this\".equals(tokenStr);\r\n            boolean isNew = \"new\".equals(tokenStr);\r\n            if (isThis || isNew) {\r\n                if (match(JsDocToken.COLON)) {\r\n                    next();\r\n                    skipEOLs();\r\n                    Node contextType = wrapNode(isThis ? Token.THIS : Token.NEW, parseTypeName(next()));\r\n                    if (contextType == null) {\r\n                        return null;\r\n                    }\r\n                    functionType.addChildToFront(contextType);\r\n                } else {\r\n                    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\r\n                }\r\n                if (match(JsDocToken.COMMA)) {\r\n                    next();\r\n                    skipEOLs();\r\n                    token = next();\r\n                } else {\r\n                    hasParams = false;\r\n                }\r\n            }\r\n        }\r\n        if (hasParams) {\r\n            parameters = parseParametersType(token);\r\n            if (parameters == null) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    if (parameters != null) {\r\n        functionType.addChildToBack(parameters);\r\n    }\r\n    skipEOLs();\r\n    if (!match(JsDocToken.RP)) {\r\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\r\n    }\r\n    skipEOLs();\r\n    Node resultType = parseResultType(next());\r\n    if (resultType == null) {\r\n        return null;\r\n    } else {\r\n        functionType.addChildToBack(resultType);\r\n    }\r\n    return functionType;\r\n}","lc":2.0,"pi":1.6842105263,"ma":2.0,"nbd":1.5,"ml":1.5833333333,"d":0.5615079365,"mi":-0.9300916138,"fo":1.9166666667,"r":-0.0263157895,"e":1.3671893639}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"\/**\r\n *  Static utility to parse a field of type double from a byte sequence that represents text characters\r\n *  (such as when read from a file stream).\r\n *\r\n *  @param bytes The bytes containing the text data that should be parsed.\r\n *  @param startPos The offset to start the parsing.\r\n *  @param length The length of the byte sequence (counting from the offset).\r\n *\r\n *  @return The parsed value.\r\n *\r\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\r\n *\/\r\npublic static final double parseField(byte[] bytes, int startPos, int length) {\r\n    return parseField(bytes, startPos, length, (char) 0xffff);\r\n}","code_comment":"\/**\r\n *  Static utility to parse a field of type double from a byte sequence that represents text characters\r\n *  (such as when read from a file stream).\r\n *\r\n *  @param bytes The bytes containing the text data that should be parsed.\r\n *  @param startPos The offset to start the parsing.\r\n *  @param length The length of the byte sequence (counting from the offset).\r\n *\r\n *  @return The parsed value.\r\n *\r\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\r\n *\/\r\n","code_no_comment":"public static final double parseField(byte[] bytes, int startPos, int length) {\r\n    return parseField(bytes, startPos, length, (char) 0xffff);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.992670895,"fo":-0.4166666667,"r":1.8684210526,"e":-0.1627934049}
{"project_name":"Closure","project_version":"143","label":2,"code":"\/**\r\n * Attempts to replace the input node with a simpler but functionally\r\n * equivalent set of nodes.\r\n *\/\r\nprivate void trySimplify(Node parent, Node node) {\r\n    if (node.getType() != Token.EXPR_RESULT) {\r\n        return;\r\n    }\r\n    Node exprBody = node.getFirstChild();\r\n    if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody)) {\r\n        changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody));\r\n    }\r\n}","code_comment":"\/**\r\n * Attempts to replace the input node with a simpler but functionally\r\n * equivalent set of nodes.\r\n *\/\r\n","code_no_comment":"private void trySimplify(Node parent, Node node) {\r\n    if (node.getType() != Token.EXPR_RESULT) {\r\n        return;\r\n    }\r\n    Node exprBody = node.getFirstChild();\r\n    if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody)) {\r\n        changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody));\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":-0.0615079365,"mi":0.2679351656,"fo":-0.0833333333,"r":0.7894736842,"e":-0.0861511154}
{"project_name":"Math","project_version":"46","label":3,"code":"\/**\r\n * Returns a {@code Complex} whose value is\r\n * {@code (this \/ divisor)}.\r\n * Implements the definitional formula\r\n * <pre>\r\n *  <code>\r\n *    a + bi          ac + bd + (bc - ad)i\r\n *    ----------- = -------------------------\r\n *    c + di         c<sup>2<\/sup> + d<sup>2<\/sup>\r\n *  <\/code>\r\n * <\/pre>\r\n * but uses\r\n * <a href=\"http:\/\/doi.acm.org\/10.1145\/1039813.1039814\">\r\n * prescaling of operands<\/a> to limit the effects of overflows and\r\n * underflows in the computation.\r\n * <br\/>\r\n * {@code Infinite} and {@code NaN} values are handled according to the\r\n * following rules, applied in the order presented:\r\n * <ul>\r\n *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\r\n *   in either part, {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},\r\n *   {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} and {@code divisor} are both infinite,\r\n *   {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\r\n *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\r\n *   infinite), {@link #ZERO} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} is infinite and {@code divisor} is finite,\r\n *   {@code NaN} values are returned in the parts of the result if the\r\n *   {@link java.lang.Double} rules applied to the definitional formula\r\n *   force {@code NaN} results.\r\n *  <\/li>\r\n * <\/ul>\r\n *\r\n * @param divisor Value by which this {@code Complex} is to be divided.\r\n * @return {@code this \/ divisor}.\r\n * @throws NullArgumentException if {@code divisor} is {@code null}.\r\n *\/\r\npublic Complex divide(Complex divisor) throws NullArgumentException {\r\n    MathUtils.checkNotNull(divisor);\r\n    if (isNaN || divisor.isNaN) {\r\n        return NaN;\r\n    }\r\n    if (divisor.isZero) {\r\n        \/\/ return isZero ? NaN : INF; \/\/ See MATH-657\r\n        return isZero ? NaN : INF;\r\n    }\r\n    if (divisor.isInfinite() && !isInfinite()) {\r\n        return ZERO;\r\n    }\r\n    final double c = divisor.getReal();\r\n    final double d = divisor.getImaginary();\r\n    if (FastMath.abs(c) < FastMath.abs(d)) {\r\n        double q = c \/ d;\r\n        double denominator = c * q + d;\r\n        return createComplex((real * q + imaginary) \/ denominator, (imaginary * q - real) \/ denominator);\r\n    } else {\r\n        double q = d \/ c;\r\n        double denominator = d * q + c;\r\n        return createComplex((imaginary * q + real) \/ denominator, (imaginary - real * q) \/ denominator);\r\n    }\r\n}","code_comment":"\/**\r\n * Returns a {@code Complex} whose value is\r\n * {@code (this \/ divisor)}.\r\n * Implements the definitional formula\r\n * <pre>\r\n *  <code>\r\n *    a + bi          ac + bd + (bc - ad)i\r\n *    ----------- = -------------------------\r\n *    c + di         c<sup>2<\/sup> + d<sup>2<\/sup>\r\n *  <\/code>\r\n * <\/pre>\r\n * but uses\r\n * <a href=\"http:\/\/doi.acm.org\/10.1145\/1039813.1039814\">\r\n * prescaling of operands<\/a> to limit the effects of overflows and\r\n * underflows in the computation.\r\n * <br\/>\r\n * {@code Infinite} and {@code NaN} values are handled according to the\r\n * following rules, applied in the order presented:\r\n * <ul>\r\n *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\r\n *   in either part, {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},\r\n *   {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} and {@code divisor} are both infinite,\r\n *   {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\r\n *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\r\n *   infinite), {@link #ZERO} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} is infinite and {@code divisor} is finite,\r\n *   {@code NaN} values are returned in the parts of the result if the\r\n *   {@link java.lang.Double} rules applied to the definitional formula\r\n *   force {@code NaN} results.\r\n *  <\/li>\r\n * <\/ul>\r\n *\r\n * @param divisor Value by which this {@code Complex} is to be divided.\r\n * @return {@code this \/ divisor}.\r\n * @throws NullArgumentException if {@code divisor} is {@code null}.\r\n *\/\r\n","code_no_comment":"public Complex divide(Complex divisor) throws NullArgumentException {\r\n    MathUtils.checkNotNull(divisor);\r\n    if (isNaN || divisor.isNaN) {\r\n        return NaN;\r\n    }\r\n    if (divisor.isZero) {\r\n                return isZero ? NaN : INF;\r\n    }\r\n    if (divisor.isInfinite() && !isInfinite()) {\r\n        return ZERO;\r\n    }\r\n    final double c = divisor.getReal();\r\n    final double d = divisor.getImaginary();\r\n    if (FastMath.abs(c) < FastMath.abs(d)) {\r\n        double q = c \/ d;\r\n        double denominator = c * q + d;\r\n        return createComplex((real * q + imaginary) \/ denominator, (imaginary * q - real) \/ denominator);\r\n    } else {\r\n        double q = d \/ c;\r\n        double denominator = d * q + c;\r\n        return createComplex((imaginary * q + real) \/ denominator, (imaginary - real * q) \/ denominator);\r\n    }\r\n}","lc":0.4090909091,"pi":-0.2440191388,"ma":0.4,"nbd":-0.5,"ml":1.0,"d":1.8174603175,"mi":-0.3964763918,"fo":0.25,"r":-0.0263157895,"e":2.2419137521}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"public Component next() {\r\n    return children_get(index++);\r\n}","code_comment":null,"code_no_comment":"public Component next() {\r\n    return children_get(index++);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.067653277,"fo":-0.4166666667,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-548_717186d6","label":1,"code":"@Override\r\npublic void childNodeAdded(String name, NodeState after) {\r\n    String p = PathUtils.concat(getCurrentPath(), name);\r\n    if (p.startsWith(pathFilter)) {\r\n        addedNodes.put(after, p);\r\n        buff.tag('+').key(p).object();\r\n        toJson(buff, after);\r\n        buff.endObject().newline();\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void childNodeAdded(String name, NodeState after) {\r\n    String p = PathUtils.concat(getCurrentPath(), name);\r\n    if (p.startsWith(pathFilter)) {\r\n        addedNodes.put(after, p);\r\n        buff.tag('+').key(p).object();\r\n        toJson(buff, after);\r\n        buff.endObject().newline();\r\n    }\r\n}","lc":-0.1818181818,"pi":0.1578947368,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.1774489077,"fo":0.3333333333,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2249_6dde8e9d","label":1,"code":"@Override\r\npublic String toString() {\r\n    if (alwaysFalse) {\r\n        return \"Filter(always false)\";\r\n    }\r\n    StringBuilder buff = new StringBuilder();\r\n    buff.append(\"Filter(\");\r\n    if (queryStatement != null) {\r\n        buff.append(\"query=\").append(queryStatement);\r\n    }\r\n    if (fullTextConstraint != null) {\r\n        buff.append(\"fullText=\").append(fullTextConstraint);\r\n    }\r\n    buff.append(\", path=\").append(getPathPlan());\r\n    if (!propertyRestrictions.isEmpty()) {\r\n        buff.append(\", property=[\");\r\n        Iterator<Entry<String, PropertyRestriction>> iterator = propertyRestrictions.entrySet().iterator();\r\n        while (iterator.hasNext()) {\r\n            Entry<String, PropertyRestriction> p = iterator.next();\r\n            buff.append(p.getKey()).append(\"=\").append(p.getValue());\r\n            if (iterator.hasNext()) {\r\n                buff.append(\", \");\r\n            }\r\n        }\r\n        buff.append(\"]\");\r\n    }\r\n    buff.append(\")\");\r\n    return buff.toString();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String toString() {\r\n    if (alwaysFalse) {\r\n        return \"Filter(always false)\";\r\n    }\r\n    StringBuilder buff = new StringBuilder();\r\n    buff.append(\"Filter(\");\r\n    if (queryStatement != null) {\r\n        buff.append(\"query=\").append(queryStatement);\r\n    }\r\n    if (fullTextConstraint != null) {\r\n        buff.append(\"fullText=\").append(fullTextConstraint);\r\n    }\r\n    buff.append(\", path=\").append(getPathPlan());\r\n    if (!propertyRestrictions.isEmpty()) {\r\n        buff.append(\", property=[\");\r\n        Iterator<Entry<String, PropertyRestriction>> iterator = propertyRestrictions.entrySet().iterator();\r\n        while (iterator.hasNext()) {\r\n            Entry<String, PropertyRestriction> p = iterator.next();\r\n            buff.append(p.getKey()).append(\"=\").append(p.getValue());\r\n            if (iterator.hasNext()) {\r\n                buff.append(\", \");\r\n            }\r\n        }\r\n        buff.append(\"]\");\r\n    }\r\n    buff.append(\")\");\r\n    return buff.toString();\r\n}","lc":0.6818181818,"pi":0.4210526316,"ma":0.6,"nbd":0.5,"ml":0.5,"d":0.0674603175,"mi":-0.4897815363,"fo":1.5,"r":-0.0263157895,"e":0.2553920806}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-366_db4a291f","label":1,"code":"long getCompactionID() {\r\n    try {\r\n        String zTablePath = Constants.ZROOT + \"\/\" + HdfsZooInstance.getInstance().getInstanceID() + Constants.ZTABLES + \"\/\" + extent.getTableId() + Constants.ZTABLE_COMPACT_ID;\r\n        return Long.parseLong(new String(ZooReaderWriter.getRetryingInstance().getData(zTablePath, null)));\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"long getCompactionID() {\r\n    try {\r\n        String zTablePath = Constants.ZROOT + \"\/\" + HdfsZooInstance.getInstance().getInstanceID() + Constants.ZTABLES + \"\/\" + extent.getTableId() + Constants.ZTABLE_COMPACT_ID;\r\n        return Long.parseLong(new String(ZooReaderWriter.getRetryingInstance().getData(zTablePath, null)));\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.1150793651,"mi":0.2800563777,"fo":0.0,"r":0.1578947368,"e":-0.0791111265}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-843_65390f8c","label":3,"code":"@Override\r\npublic void flush(String tableName, Text start, Text end, boolean wait) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n    throw new NotImplementedException();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void flush(String tableName, Text start, Text end, boolean wait) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n    throw new NotImplementedException();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.4,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7527836505,"fo":-0.5,"r":0.0,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-678_6c54045d","label":1,"code":"\/**\r\n * Update the state of this builder for reading.\r\n * @return  {@code true} is this reader is connected, {@code false} otherwise.\r\n *\/\r\nprivate boolean updateReadState() {\r\n    if (revision != root.revision) {\r\n        \/\/ root never gets here since revision == root.revision\r\n        assert (!isRoot());\r\n        if (!exists()) {\r\n            return false;\r\n        }\r\n        parent.updateReadState();\r\n        \/\/ The builder could have been reset, need to re-get base state\r\n        baseState = parent.getBaseState(name);\r\n        \/\/ ... same for the write state\r\n        writeState = parent.getWriteState(name);\r\n        revision = root.revision;\r\n    }\r\n    return writeState != null || baseState != null;\r\n}","code_comment":"\/**\r\n * Update the state of this builder for reading.\r\n * @return  {@code true} is this reader is connected, {@code false} otherwise.\r\n *\/\r\n","code_no_comment":"private boolean updateReadState() {\r\n    if (revision != root.revision) {\r\n                assert (!isRoot());\r\n        if (!exists()) {\r\n            return false;\r\n        }\r\n        parent.updateReadState();\r\n                baseState = parent.getBaseState(name);\r\n                writeState = parent.getWriteState(name);\r\n        revision = root.revision;\r\n    }\r\n    return writeState != null || baseState != null;\r\n}","lc":-0.0454545455,"pi":0.1818181818,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":0.3234126984,"mi":0.0536997886,"fo":-0.0833333333,"r":0.1315789474,"e":0.0748327311}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3789_9319e139","label":1,"code":"@Override\r\npublic boolean begin(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint, Exchange exchange, GenericFile<T> file) throws Exception {\r\n    \/\/ must invoke super\r\n    boolean result = super.begin(operations, endpoint, exchange, file);\r\n    if (!result) {\r\n        return false;\r\n    }\r\n    if (beginRenamer != null) {\r\n        GenericFile<T> newName = beginRenamer.renameFile(exchange, file);\r\n        GenericFile<T> to = renameFile(operations, file, newName);\r\n        if (to != null) {\r\n            to.bindToExchange(exchange);\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean begin(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint, Exchange exchange, GenericFile<T> file) throws Exception {\r\n        boolean result = super.begin(operations, endpoint, exchange, file);\r\n    if (!result) {\r\n        return false;\r\n    }\r\n    if (beginRenamer != null) {\r\n        GenericFile<T> newName = beginRenamer.renameFile(exchange, file);\r\n        GenericFile<T> to = renameFile(operations, file, newName);\r\n        if (to != null) {\r\n            to.bindToExchange(exchange);\r\n        }\r\n    }\r\n    return true;\r\n}","lc":0.0454545455,"pi":0.2009569378,"ma":0.0,"nbd":0.0,"ml":0.0833333333,"d":0.0416666667,"mi":-0.0863988724,"fo":-0.1666666667,"r":-0.0263157895,"e":0.0605498983}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Sets the expansionFactor.  Throws IllegalArgumentException if the\r\n * the following conditions are not met:\r\n * <ul>\r\n * <li><code>expansionFactor > 1<\/code><\/li>\r\n * <li><code>contractionFactor >= expansionFactor<\/code><\/li>\r\n * <\/ul>\r\n * @param expansionFactor the new expansion factor value.\r\n * @throws MathIllegalArgumentException if expansionFactor is <= 1 or greater\r\n * than contractionFactor\r\n * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\r\n *\/\r\n@Deprecated\r\npublic void setExpansionFactor(float expansionFactor) throws MathIllegalArgumentException {\r\n    checkContractExpand(getContractionCriterion(), expansionFactor);\r\n    \/\/ The check above verifies that the expansion factor is > 1.0;\r\n    synchronized (this) {\r\n        this.expansionFactor = expansionFactor;\r\n    }\r\n}","code_comment":"\/**\r\n * Sets the expansionFactor.  Throws IllegalArgumentException if the\r\n * the following conditions are not met:\r\n * <ul>\r\n * <li><code>expansionFactor > 1<\/code><\/li>\r\n * <li><code>contractionFactor >= expansionFactor<\/code><\/li>\r\n * <\/ul>\r\n * @param expansionFactor the new expansion factor value.\r\n * @throws MathIllegalArgumentException if expansionFactor is <= 1 or greater\r\n * than contractionFactor\r\n * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\r\n *\/\r\n","code_no_comment":"@Deprecated\r\npublic void setExpansionFactor(float expansionFactor) throws MathIllegalArgumentException {\r\n    checkContractExpand(getContractionCriterion(), expansionFactor);\r\n        synchronized (this) {\r\n        this.expansionFactor = expansionFactor;\r\n    }\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.569837914,"fo":-0.3333333333,"r":0.3947368421,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Contracts the storage array to the (size of the element set) + 1 - to\r\n * avoid a zero length array. This function also resets the startIndex to\r\n * zero.\r\n *\/\r\npublic synchronized void contract() {\r\n    final double[] tempArray = new double[numElements + 1];\r\n    \/\/ Copy and swap - copy only the element array from the src array.\r\n    System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);\r\n    internalArray = tempArray;\r\n    \/\/ Reset the start index to zero\r\n    startIndex = 0;\r\n}","code_comment":"\/**\r\n * Contracts the storage array to the (size of the element set) + 1 - to\r\n * avoid a zero length array. This function also resets the startIndex to\r\n * zero.\r\n *\/\r\n","code_no_comment":"public synchronized void contract() {\r\n    final double[] tempArray = new double[numElements + 1];\r\n        System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);\r\n    internalArray = tempArray;\r\n        startIndex = 0;\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.0476190476,"mi":0.52670895,"fo":-0.4166666667,"r":1.2894736842,"e":-0.1099035863}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5655_d558004b","label":3,"code":"\/**\r\n *  Sets the given model.\r\n *  <p>\r\n *  WARNING: DO NOT OVERRIDE THIS METHOD UNLESS YOU HAVE A VERY GOOD REASON FOR IT. OVERRIDING\r\n *  THIS MIGHT OPEN UP SECURITY LEAKS AND BREAK BACK-BUTTON SUPPORT.\r\n *  <\/p>\r\n *\r\n *  @param model\r\n *             The model\r\n *  @return This\r\n *\/\r\npublic Component setDefaultModel(final IModel<?> model) {\r\n    IModel<?> prevModel = getModelImpl();\r\n    IModel<?> wrappedModel = prevModel;\r\n    if (prevModel instanceof IWrapModel) {\r\n        wrappedModel = ((IWrapModel<?>) prevModel).getWrappedModel();\r\n    }\r\n    \/\/ Change model\r\n    if (wrappedModel != model) {\r\n        \/\/ Detach the old\/current model\r\n        if (prevModel != null) {\r\n            prevModel.detach();\r\n        }\r\n        modelChanging();\r\n        setModelImpl(wrap(model));\r\n        modelChanged();\r\n    }\r\n    return this;\r\n}","code_comment":"\/**\r\n *  Sets the given model.\r\n *  <p>\r\n *  WARNING: DO NOT OVERRIDE THIS METHOD UNLESS YOU HAVE A VERY GOOD REASON FOR IT. OVERRIDING\r\n *  THIS MIGHT OPEN UP SECURITY LEAKS AND BREAK BACK-BUTTON SUPPORT.\r\n *  <\/p>\r\n *\r\n *  @param model\r\n *             The model\r\n *  @return This\r\n *\/\r\n","code_no_comment":"public Component setDefaultModel(final IModel<?> model) {\r\n    IModel<?> prevModel = getModelImpl();\r\n    IModel<?> wrappedModel = prevModel;\r\n    if (prevModel instanceof IWrapModel) {\r\n        wrappedModel = ((IWrapModel<?>) prevModel).getWrappedModel();\r\n    }\r\n        if (wrappedModel != model) {\r\n                if (prevModel != null) {\r\n            prevModel.detach();\r\n        }\r\n        modelChanging();\r\n        setModelImpl(wrap(model));\r\n        modelChanged();\r\n    }\r\n    return this;\r\n}","lc":0.0909090909,"pi":0.0622009569,"ma":0.0,"nbd":0.0,"ml":0.0833333333,"d":-0.0178571429,"mi":-0.036222692,"fo":0.0833333333,"r":0.9473684211,"e":-0.0517718112}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2261_089303f4","label":1,"code":"\/**\r\n *  @param cycle\r\n *\/\r\npublic final void postProcessRequestCycle(WebRequestCycle cycle) {\r\n    previousRenderedPage = lastRenderedPage;\r\n    if (cycle.getResponse() instanceof WebResponse) {\r\n        \/\/ handle redirects which are usually managed by the browser\r\n        \/\/ transparently\r\n        final MockHttpServletResponse httpResponse = (MockHttpServletResponse) cycle.getWebResponse().getHttpServletResponse();\r\n        if (httpResponse.isRedirect()) {\r\n            lastRenderedPage = generateLastRenderedPage(cycle);\r\n            MockHttpServletRequest newHttpRequest = new MockHttpServletRequest(application, servletSession, application.getServletContext());\r\n            newHttpRequest.setRequestToRedirectString(httpResponse.getRedirectLocation());\r\n            wicketRequest = application.newWebRequest(newHttpRequest);\r\n            cycle = createRequestCycle();\r\n            cycle.request();\r\n        }\r\n    }\r\n    lastRenderedPage = generateLastRenderedPage(cycle);\r\n    Session.set(getWicketSession());\r\n    if (getLastRenderedPage() instanceof ExceptionErrorPage) {\r\n        throw (RuntimeException) ((ExceptionErrorPage) getLastRenderedPage()).getThrowable();\r\n    }\r\n}","code_comment":"\/**\r\n *  @param cycle\r\n *\/\r\n","code_no_comment":"public final void postProcessRequestCycle(WebRequestCycle cycle) {\r\n    previousRenderedPage = lastRenderedPage;\r\n    if (cycle.getResponse() instanceof WebResponse) {\r\n                        final MockHttpServletResponse httpResponse = (MockHttpServletResponse) cycle.getWebResponse().getHttpServletResponse();\r\n        if (httpResponse.isRedirect()) {\r\n            lastRenderedPage = generateLastRenderedPage(cycle);\r\n            MockHttpServletRequest newHttpRequest = new MockHttpServletRequest(application, servletSession, application.getServletContext());\r\n            newHttpRequest.setRequestToRedirectString(httpResponse.getRedirectLocation());\r\n            wicketRequest = application.newWebRequest(newHttpRequest);\r\n            cycle = createRequestCycle();\r\n            cycle.request();\r\n        }\r\n    }\r\n    lastRenderedPage = generateLastRenderedPage(cycle);\r\n    Session.set(getWicketSession());\r\n    if (getLastRenderedPage() instanceof ExceptionErrorPage) {\r\n        throw (RuntimeException) ((ExceptionErrorPage) getLastRenderedPage()).getThrowable();\r\n    }\r\n}","lc":0.2272727273,"pi":0.5167464115,"ma":0.2,"nbd":0.0,"ml":0.0833333333,"d":-0.3650793651,"mi":-0.2318534179,"fo":0.9166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5844_e775071b","label":3,"code":"public String getTraceLabel() {\r\n    return \"wrap[\" + wrapped + \"]\";\r\n}","code_comment":null,"code_no_comment":"public String getTraceLabel() {\r\n    return \"wrap[\" + wrapped + \"]\";\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0329809725,"fo":-0.5,"r":2.5,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-938_73605560","label":1,"code":"\/**\r\n * Get a line with reversed direction.\r\n * @return a new instance, with reversed direction\r\n *\/\r\npublic Line revert() {\r\n    return new Line(zero, zero.subtract(direction));\r\n}","code_comment":"\/**\r\n * Get a line with reversed direction.\r\n * @return a new instance, with reversed direction\r\n *\/\r\n","code_no_comment":"public Line revert() {\r\n    return new Line(zero, zero.subtract(direction));\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0253699789,"fo":-0.4166666667,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1518_df4b1985","label":1,"code":"private FileOperations findFileFactory(String file) {\r\n    Path p = new Path(file);\r\n    String name = p.getName();\r\n    if (name.startsWith(Constants.MAPFILE_EXTENSION + \"_\")) {\r\n        return new MapFileOperations();\r\n    }\r\n    String[] sp = name.split(\"\\\\.\");\r\n    if (sp.length != 2) {\r\n        throw new IllegalArgumentException(\"File name \" + name + \" has no extension\");\r\n    }\r\n    String extension = sp[1];\r\n    if (extension.equals(Constants.MAPFILE_EXTENSION) || extension.equals(Constants.MAPFILE_EXTENSION + \"_tmp\")) {\r\n        return new MapFileOperations();\r\n    } else if (extension.equals(RFile.EXTENSION) || extension.equals(RFile.EXTENSION + \"_tmp\")) {\r\n        return new RFileOperations();\r\n    } else {\r\n        throw new IllegalArgumentException(\"File type \" + extension + \" not supported\");\r\n    }\r\n}","code_comment":null,"code_no_comment":"private FileOperations findFileFactory(String file) {\r\n    Path p = new Path(file);\r\n    String name = p.getName();\r\n    if (name.startsWith(Constants.MAPFILE_EXTENSION + \"_\")) {\r\n        return new MapFileOperations();\r\n    }\r\n    String[] sp = name.split(\"\\\\.\");\r\n    if (sp.length != 2) {\r\n        throw new IllegalArgumentException(\"File name \" + name + \" has no extension\");\r\n    }\r\n    String extension = sp[1];\r\n    if (extension.equals(Constants.MAPFILE_EXTENSION) || extension.equals(Constants.MAPFILE_EXTENSION + \"_tmp\")) {\r\n        return new MapFileOperations();\r\n    } else if (extension.equals(RFile.EXTENSION) || extension.equals(RFile.EXTENSION + \"_tmp\")) {\r\n        return new RFileOperations();\r\n    } else {\r\n        throw new IllegalArgumentException(\"File type \" + extension + \" not supported\");\r\n    }\r\n}","lc":0.2272727273,"pi":-0.3110047847,"ma":0.6,"nbd":0.0,"ml":0.5833333333,"d":0.3908730159,"mi":-0.2769556025,"fo":0.0833333333,"r":0.0,"e":0.4763057347}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1062_4cf831b6","label":1,"code":"@Override\r\npublic void add(final Marker marker) {\r\n    final Marker m = factory.getMarker(marker.getName());\r\n    this.marker.addParents(((Log4jMarker) m).getLog4jMarker());\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void add(final Marker marker) {\r\n    final Marker m = factory.getMarker(marker.getName());\r\n    this.marker.addParents(((Log4jMarker) m).getLog4jMarker());\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6290345314,"fo":-0.1666666667,"r":0.3157894737,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4099_1dcaec98","label":3,"code":"\/**\r\n *  @see ILinkParser#parse(String)\r\n *\/\r\npublic String parse(final String text) {\r\n    if (Strings.isEmpty(text)) {\r\n        return text;\r\n    }\r\n    String work = text;\r\n    for (String pattern : renderStrategies.keySet()) {\r\n        ILinkRenderStrategy strategy = renderStrategies.get(pattern);\r\n        Matcher matcher = Pattern.compile(pattern, Pattern.DOTALL).matcher(work);\r\n        StringBuffer buffer = new StringBuffer();\r\n        while (matcher.find()) {\r\n            String str = matcher.group();\r\n            matcher.appendReplacement(buffer, strategy.buildLink(str));\r\n        }\r\n        matcher.appendTail(buffer);\r\n        work = buffer.toString();\r\n    }\r\n    return work;\r\n}","code_comment":"\/**\r\n *  @see ILinkParser#parse(String)\r\n *\/\r\n","code_no_comment":"public String parse(final String text) {\r\n    if (Strings.isEmpty(text)) {\r\n        return text;\r\n    }\r\n    String work = text;\r\n    for (String pattern : renderStrategies.keySet()) {\r\n        ILinkRenderStrategy strategy = renderStrategies.get(pattern);\r\n        Matcher matcher = Pattern.compile(pattern, Pattern.DOTALL).matcher(work);\r\n        StringBuffer buffer = new StringBuffer();\r\n        while (matcher.find()) {\r\n            String str = matcher.group();\r\n            matcher.appendReplacement(buffer, strategy.buildLink(str));\r\n        }\r\n        matcher.appendTail(buffer);\r\n        work = buffer.toString();\r\n    }\r\n    return work;\r\n}","lc":0.1818181818,"pi":0.1626794258,"ma":0.0,"nbd":0.0,"ml":0.0,"d":-0.3650793651,"mi":-0.193516561,"fo":0.4166666667,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-763_97203de8","label":1,"code":"\/**\r\n * Returns the formatted object message.\r\n * @return the formatted object message.\r\n *\/\r\n@Override\r\npublic String getFormattedMessage() {\r\n    return obj.toString();\r\n}","code_comment":"\/**\r\n * Returns the formatted object message.\r\n * @return the formatted object message.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic String getFormattedMessage() {\r\n    return obj.toString();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9362931642,"fo":-0.4166666667,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"Compress","project_version":"36","label":3,"code":"private InputStream getCurrentStream() throws IOException {\r\n    if (deferredBlockStreams.isEmpty()) {\r\n        throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\r\n    }\r\n    while (deferredBlockStreams.size() > 1) {\r\n        \/\/ In solid compression mode we need to decompress all leading folder'\r\n        \/\/ streams to get access to an entry. We defer this until really needed\r\n        \/\/ so that entire blocks can be skipped without wasting time for decompression.\r\n        final InputStream stream = deferredBlockStreams.remove(0);\r\n        IOUtils.skip(stream, Long.MAX_VALUE);\r\n        stream.close();\r\n    }\r\n    return deferredBlockStreams.get(0);\r\n}","code_comment":null,"code_no_comment":"private InputStream getCurrentStream() throws IOException {\r\n    if (deferredBlockStreams.isEmpty()) {\r\n        throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\r\n    }\r\n    while (deferredBlockStreams.size() > 1) {\r\n                                final InputStream stream = deferredBlockStreams.remove(0);\r\n        IOUtils.skip(stream, Long.MAX_VALUE);\r\n        stream.close();\r\n    }\r\n    return deferredBlockStreams.get(0);\r\n}","lc":-0.1363636364,"pi":-0.0622009569,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0932539683,"mi":0.1512332629,"fo":0.0,"r":0.0263157895,"e":-0.0852013854}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7163_5f726d0b","label":1,"code":"public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, String value) {\r\n    SuspendedExchange se = suspendedBreakpoints.get(nodeId);\r\n    if (se != null) {\r\n        logger.log(\"Breakpoint at node \" + nodeId + \" is updating message header on exchangeId: \" + se.getExchange().getExchangeId() + \" with header: \" + headerName + \" and value: \" + value);\r\n        if (se.getExchange().hasOut()) {\r\n            se.getExchange().getOut().setHeader(headerName, value);\r\n        } else {\r\n            se.getExchange().getIn().setHeader(headerName, value);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, String value) {\r\n    SuspendedExchange se = suspendedBreakpoints.get(nodeId);\r\n    if (se != null) {\r\n        logger.log(\"Breakpoint at node \" + nodeId + \" is updating message header on exchangeId: \" + se.getExchange().getExchangeId() + \" with header: \" + headerName + \" and value: \" + value);\r\n        if (se.getExchange().hasOut()) {\r\n            se.getExchange().getOut().setHeader(headerName, value);\r\n        } else {\r\n            se.getExchange().getIn().setHeader(headerName, value);\r\n        }\r\n    }\r\n}","lc":-0.1363636364,"pi":0.4593301435,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.001984127,"mi":0.0782241015,"fo":0.5,"r":-0.0263157895,"e":0.0152809714}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5681_78c73502","label":1,"code":"protected boolean doProcessSequential(Exchange original, AtomicExchange result, Iterable<ProcessorExchangePair> pairs, AsyncCallback callback) throws Exception {\r\n    AtomicInteger total = new AtomicInteger();\r\n    Iterator<ProcessorExchangePair> it = pairs.iterator();\r\n    while (it.hasNext()) {\r\n        ProcessorExchangePair pair = it.next();\r\n        Exchange subExchange = pair.getExchange();\r\n        updateNewExchange(subExchange, total.get(), pairs, it);\r\n        boolean sync = doProcessSequential(original, result, pairs, it, pair, callback, total);\r\n        if (!sync) {\r\n            if (LOG.isTraceEnabled()) {\r\n                LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", pair.getExchange().getExchangeId());\r\n            }\r\n            \/\/ so we break out now, then the callback will be invoked which then continue routing from where we left here\r\n            return false;\r\n        }\r\n        if (LOG.isTraceEnabled()) {\r\n            LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", pair.getExchange().getExchangeId());\r\n        }\r\n        \/\/ Decide whether to continue with the multicast or not; similar logic to the Pipeline\r\n        \/\/ remember to test for stop on exception and aggregate before copying back results\r\n        boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Sequential processing failed for number \" + total.get(), LOG);\r\n        if (stopOnException && !continueProcessing) {\r\n            if (subExchange.getException() != null) {\r\n                \/\/ wrap in exception to explain where it failed\r\n                throw new CamelExchangeException(\"Sequential processing failed for number \" + total.get(), subExchange, subExchange.getException());\r\n            } else {\r\n                \/\/ we want to stop on exception, and the exception was handled by the error handler\r\n                \/\/ this is similar to what the pipeline does, so we should do the same to not surprise end users\r\n                \/\/ so we should set the failed exchange as the result and be done\r\n                result.set(subExchange);\r\n                return true;\r\n            }\r\n        }\r\n        LOG.trace(\"Sequential processing complete for number {} exchange: {}\", total, subExchange);\r\n        doAggregate(getAggregationStrategy(subExchange), result, subExchange);\r\n        total.incrementAndGet();\r\n    }\r\n    LOG.debug(\"Done sequential processing {} exchanges\", total);\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"protected boolean doProcessSequential(Exchange original, AtomicExchange result, Iterable<ProcessorExchangePair> pairs, AsyncCallback callback) throws Exception {\r\n    AtomicInteger total = new AtomicInteger();\r\n    Iterator<ProcessorExchangePair> it = pairs.iterator();\r\n    while (it.hasNext()) {\r\n        ProcessorExchangePair pair = it.next();\r\n        Exchange subExchange = pair.getExchange();\r\n        updateNewExchange(subExchange, total.get(), pairs, it);\r\n        boolean sync = doProcessSequential(original, result, pairs, it, pair, callback, total);\r\n        if (!sync) {\r\n            if (LOG.isTraceEnabled()) {\r\n                LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", pair.getExchange().getExchangeId());\r\n            }\r\n                        return false;\r\n        }\r\n        if (LOG.isTraceEnabled()) {\r\n            LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", pair.getExchange().getExchangeId());\r\n        }\r\n                        boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Sequential processing failed for number \" + total.get(), LOG);\r\n        if (stopOnException && !continueProcessing) {\r\n            if (subExchange.getException() != null) {\r\n                                throw new CamelExchangeException(\"Sequential processing failed for number \" + total.get(), subExchange, subExchange.getException());\r\n            } else {\r\n                                                                result.set(subExchange);\r\n                return true;\r\n            }\r\n        }\r\n        LOG.trace(\"Sequential processing complete for number {} exchange: {}\", total, subExchange);\r\n        doAggregate(getAggregationStrategy(subExchange), result, subExchange);\r\n        total.incrementAndGet();\r\n    }\r\n    LOG.debug(\"Done sequential processing {} exchanges\", total);\r\n    return true;\r\n}","lc":0.8636363636,"pi":0.5741626794,"ma":0.8,"nbd":0.5,"ml":0.6666666667,"d":0.5138888889,"mi":-0.622832981,"fo":1.6666666667,"r":-0.0263157895,"e":1.1863718354}
{"project_name":"Compress","project_version":"29","label":1,"code":"\/**\r\n * Create an archive input stream from an input stream, autodetecting\r\n * the archive type from the first few bytes of the stream. The InputStream\r\n * must support marks, like BufferedInputStream.\r\n *\r\n * @param in the input stream\r\n * @return the archive input stream\r\n * @throws ArchiveException if the archiver name is not known\r\n * @throws StreamingNotSupportedException if the format cannot be\r\n * read from a stream\r\n * @throws IllegalArgumentException if the stream is null or does not support mark\r\n *\/\r\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\r\n    if (in == null) {\r\n        throw new IllegalArgumentException(\"Stream must not be null.\");\r\n    }\r\n    if (!in.markSupported()) {\r\n        throw new IllegalArgumentException(\"Mark is not supported.\");\r\n    }\r\n    final byte[] signature = new byte[12];\r\n    in.mark(signature.length);\r\n    try {\r\n        int signatureLength = IOUtils.readFully(in, signature);\r\n        in.reset();\r\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\r\n            if (entryEncoding != null) {\r\n                return new ZipArchiveInputStream(in, entryEncoding);\r\n            } else {\r\n                return new ZipArchiveInputStream(in);\r\n            }\r\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\r\n            if (entryEncoding != null) {\r\n                return new JarArchiveInputStream(in, entryEncoding);\r\n            } else {\r\n                return new JarArchiveInputStream(in);\r\n            }\r\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new ArArchiveInputStream(in);\r\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\r\n            if (entryEncoding != null) {\r\n                return new CpioArchiveInputStream(in, entryEncoding);\r\n            } else {\r\n                return new CpioArchiveInputStream(in);\r\n            }\r\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new ArjArchiveInputStream(in);\r\n        } else if (SevenZFile.matches(signature, signatureLength)) {\r\n            throw new StreamingNotSupportedException(SEVEN_Z);\r\n        }\r\n        \/\/ Dump needs a bigger buffer to check the signature;\r\n        final byte[] dumpsig = new byte[32];\r\n        in.mark(dumpsig.length);\r\n        signatureLength = IOUtils.readFully(in, dumpsig);\r\n        in.reset();\r\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\r\n            return new DumpArchiveInputStream(in, entryEncoding);\r\n        }\r\n        \/\/ Tar needs an even bigger buffer to check the signature; read the first block\r\n        final byte[] tarheader = new byte[512];\r\n        in.mark(tarheader.length);\r\n        signatureLength = IOUtils.readFully(in, tarheader);\r\n        in.reset();\r\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\r\n            return new TarArchiveInputStream(in, entryEncoding);\r\n        }\r\n        \/\/ COMPRESS-117 - improve auto-recognition\r\n        if (signatureLength >= 512) {\r\n            TarArchiveInputStream tais = null;\r\n            try {\r\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\r\n                \/\/ COMPRESS-191 - verify the header checksum\r\n                if (tais.getNextTarEntry().isCheckSumOK()) {\r\n                    return new TarArchiveInputStream(in, encoding);\r\n                }\r\n            } catch (Exception e) {\r\n            \/\/ NOPMD\r\n            \/\/ can generate IllegalArgumentException as well\r\n            \/\/ as IOException\r\n            \/\/ autodetection, simply not a TAR\r\n            \/\/ ignored\r\n            } finally {\r\n                IOUtils.closeQuietly(tais);\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\r\n    }\r\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\r\n}","code_comment":"\/**\r\n * Create an archive input stream from an input stream, autodetecting\r\n * the archive type from the first few bytes of the stream. The InputStream\r\n * must support marks, like BufferedInputStream.\r\n *\r\n * @param in the input stream\r\n * @return the archive input stream\r\n * @throws ArchiveException if the archiver name is not known\r\n * @throws StreamingNotSupportedException if the format cannot be\r\n * read from a stream\r\n * @throws IllegalArgumentException if the stream is null or does not support mark\r\n *\/\r\n","code_no_comment":"public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\r\n    if (in == null) {\r\n        throw new IllegalArgumentException(\"Stream must not be null.\");\r\n    }\r\n    if (!in.markSupported()) {\r\n        throw new IllegalArgumentException(\"Mark is not supported.\");\r\n    }\r\n    final byte[] signature = new byte[12];\r\n    in.mark(signature.length);\r\n    try {\r\n        int signatureLength = IOUtils.readFully(in, signature);\r\n        in.reset();\r\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\r\n            if (entryEncoding != null) {\r\n                return new ZipArchiveInputStream(in, entryEncoding);\r\n            } else {\r\n                return new ZipArchiveInputStream(in);\r\n            }\r\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\r\n            if (entryEncoding != null) {\r\n                return new JarArchiveInputStream(in, entryEncoding);\r\n            } else {\r\n                return new JarArchiveInputStream(in);\r\n            }\r\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new ArArchiveInputStream(in);\r\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\r\n            if (entryEncoding != null) {\r\n                return new CpioArchiveInputStream(in, entryEncoding);\r\n            } else {\r\n                return new CpioArchiveInputStream(in);\r\n            }\r\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new ArjArchiveInputStream(in);\r\n        } else if (SevenZFile.matches(signature, signatureLength)) {\r\n            throw new StreamingNotSupportedException(SEVEN_Z);\r\n        }\r\n                final byte[] dumpsig = new byte[32];\r\n        in.mark(dumpsig.length);\r\n        signatureLength = IOUtils.readFully(in, dumpsig);\r\n        in.reset();\r\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\r\n            return new DumpArchiveInputStream(in, entryEncoding);\r\n        }\r\n                final byte[] tarheader = new byte[512];\r\n        in.mark(tarheader.length);\r\n        signatureLength = IOUtils.readFully(in, tarheader);\r\n        in.reset();\r\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\r\n            return new TarArchiveInputStream(in, entryEncoding);\r\n        }\r\n                if (signatureLength >= 512) {\r\n            TarArchiveInputStream tais = null;\r\n            try {\r\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\r\n                                if (tais.getNextTarEntry().isCheckSumOK()) {\r\n                    return new TarArchiveInputStream(in, encoding);\r\n                }\r\n            } catch (Exception e) {\r\n                                                                        } finally {\r\n                IOUtils.closeQuietly(tais);\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\r\n    }\r\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\r\n}","lc":2.4545454545,"pi":0.5741626794,"ma":3.8,"nbd":2.5,"ml":2.1666666667,"d":0.8849206349,"mi":-1.0958421424,"fo":1.25,"r":-0.0263157895,"e":2.4586412176}
{"project_name":"Compress","project_version":"16","label":3,"code":"\/**\r\n * Create an archive input stream from an input stream, autodetecting\r\n * the archive type from the first few bytes of the stream. The InputStream\r\n * must support marks, like BufferedInputStream.\r\n *\r\n * @param in the input stream\r\n * @return the archive input stream\r\n * @throws ArchiveException if the archiver name is not known\r\n * @throws IllegalArgumentException if the stream is null or does not support mark\r\n *\/\r\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\r\n    if (in == null) {\r\n        throw new IllegalArgumentException(\"Stream must not be null.\");\r\n    }\r\n    if (!in.markSupported()) {\r\n        throw new IllegalArgumentException(\"Mark is not supported.\");\r\n    }\r\n    final byte[] signature = new byte[12];\r\n    in.mark(signature.length);\r\n    try {\r\n        int signatureLength = in.read(signature);\r\n        in.reset();\r\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new ZipArchiveInputStream(in);\r\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new JarArchiveInputStream(in);\r\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new ArArchiveInputStream(in);\r\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new CpioArchiveInputStream(in);\r\n        }\r\n        \/\/ Dump needs a bigger buffer to check the signature;\r\n        final byte[] dumpsig = new byte[32];\r\n        in.mark(dumpsig.length);\r\n        signatureLength = in.read(dumpsig);\r\n        in.reset();\r\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\r\n            return new DumpArchiveInputStream(in);\r\n        }\r\n        \/\/ Tar needs an even bigger buffer to check the signature; read the first block\r\n        final byte[] tarheader = new byte[512];\r\n        in.mark(tarheader.length);\r\n        signatureLength = in.read(tarheader);\r\n        in.reset();\r\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\r\n            return new TarArchiveInputStream(in);\r\n        }\r\n        \/\/ COMPRESS-117 - improve auto-recognition\r\n        if (signatureLength >= 512) {\r\n            try {\r\n                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\r\n                \/\/ COMPRESS-191 - verify the header checksum\r\n                tais.getNextEntry();\r\n                return new TarArchiveInputStream(in);\r\n            } catch (Exception e) {\r\n            \/\/ NOPMD\r\n            \/\/ can generate IllegalArgumentException as well\r\n            \/\/ as IOException\r\n            \/\/ autodetection, simply not a TAR\r\n            \/\/ ignored\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\r\n    }\r\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\r\n}","code_comment":"\/**\r\n * Create an archive input stream from an input stream, autodetecting\r\n * the archive type from the first few bytes of the stream. The InputStream\r\n * must support marks, like BufferedInputStream.\r\n *\r\n * @param in the input stream\r\n * @return the archive input stream\r\n * @throws ArchiveException if the archiver name is not known\r\n * @throws IllegalArgumentException if the stream is null or does not support mark\r\n *\/\r\n","code_no_comment":"public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\r\n    if (in == null) {\r\n        throw new IllegalArgumentException(\"Stream must not be null.\");\r\n    }\r\n    if (!in.markSupported()) {\r\n        throw new IllegalArgumentException(\"Mark is not supported.\");\r\n    }\r\n    final byte[] signature = new byte[12];\r\n    in.mark(signature.length);\r\n    try {\r\n        int signatureLength = in.read(signature);\r\n        in.reset();\r\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new ZipArchiveInputStream(in);\r\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new JarArchiveInputStream(in);\r\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new ArArchiveInputStream(in);\r\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new CpioArchiveInputStream(in);\r\n        }\r\n                final byte[] dumpsig = new byte[32];\r\n        in.mark(dumpsig.length);\r\n        signatureLength = in.read(dumpsig);\r\n        in.reset();\r\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\r\n            return new DumpArchiveInputStream(in);\r\n        }\r\n                final byte[] tarheader = new byte[512];\r\n        in.mark(tarheader.length);\r\n        signatureLength = in.read(tarheader);\r\n        in.reset();\r\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\r\n            return new TarArchiveInputStream(in);\r\n        }\r\n                if (signatureLength >= 512) {\r\n            try {\r\n                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\r\n                                tais.getNextEntry();\r\n                return new TarArchiveInputStream(in);\r\n            } catch (Exception e) {\r\n                                                                        }\r\n        }\r\n    } catch (IOException e) {\r\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\r\n    }\r\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\r\n}","lc":1.5454545455,"pi":0.2918660287,"ma":2.4,"nbd":1.5,"ml":1.3333333333,"d":0.7718253968,"mi":-0.8367864693,"fo":0.9166666667,"r":-0.0263157895,"e":1.4788978983}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1165_596ccd59","label":3,"code":"\/**\r\n * Updates the membership matrix and assigns the points to the cluster with\r\n * the highest membership.\r\n *\/\r\nprivate void updateMembershipMatrix() {\r\n    for (int i = 0; i < points.size(); i++) {\r\n        final T point = points.get(i);\r\n        double maxMembership = 0.0;\r\n        int newCluster = -1;\r\n        for (int j = 0; j < clusters.size(); j++) {\r\n            double sum = 0.0;\r\n            final double distA = FastMath.abs(distance(point, clusters.get(j).getCenter()));\r\n            for (final CentroidCluster<T> c : clusters) {\r\n                final double distB = FastMath.abs(distance(point, c.getCenter()));\r\n                sum += FastMath.pow(distA \/ distB, 2.0 \/ (fuzziness - 1.0));\r\n            }\r\n            membershipMatrix[i][j] = 1.0 \/ sum;\r\n            if (membershipMatrix[i][j] > maxMembership) {\r\n                maxMembership = membershipMatrix[i][j];\r\n                newCluster = j;\r\n            }\r\n        }\r\n        clusters.get(newCluster).addPoint(point);\r\n    }\r\n}","code_comment":"\/**\r\n * Updates the membership matrix and assigns the points to the cluster with\r\n * the highest membership.\r\n *\/\r\n","code_no_comment":"private void updateMembershipMatrix() {\r\n    for (int i = 0; i < points.size(); i++) {\r\n        final T point = points.get(i);\r\n        double maxMembership = 0.0;\r\n        int newCluster = -1;\r\n        for (int j = 0; j < clusters.size(); j++) {\r\n            double sum = 0.0;\r\n            final double distA = FastMath.abs(distance(point, clusters.get(j).getCenter()));\r\n            for (final CentroidCluster<T> c : clusters) {\r\n                final double distB = FastMath.abs(distance(point, c.getCenter()));\r\n                sum += FastMath.pow(distA \/ distB, 2.0 \/ (fuzziness - 1.0));\r\n            }\r\n            membershipMatrix[i][j] = 1.0 \/ sum;\r\n            if (membershipMatrix[i][j] > maxMembership) {\r\n                maxMembership = membershipMatrix[i][j];\r\n                newCluster = j;\r\n            }\r\n        }\r\n        clusters.get(newCluster).addPoint(point);\r\n    }\r\n}","lc":0.3181818182,"pi":0.8229665072,"ma":0.2,"nbd":0.5,"ml":0.25,"d":1.0833333333,"mi":-0.3544749824,"fo":0.5833333333,"r":0.0263157895,"e":1.502811731}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4572_dfc56674","label":0,"code":"\/**\r\n *  @param pageId\r\n *  @param windowIndex\r\n *\/\r\nprivate void putWindowIndex(int pageId, int windowIndex) {\r\n    if (idToWindowIndex != null && pageId != -1 && windowIndex != -1) {\r\n        idToWindowIndex.put(pageId, windowIndex);\r\n    }\r\n}","code_comment":"\/**\r\n *  @param pageId\r\n *  @param windowIndex\r\n *\/\r\n","code_no_comment":"private void putWindowIndex(int pageId, int windowIndex) {\r\n    if (idToWindowIndex != null && pageId != -1 && windowIndex != -1) {\r\n        idToWindowIndex.put(pageId, windowIndex);\r\n    }\r\n}","lc":-0.4090909091,"pi":0.0,"ma":-0.4,"nbd":-0.5,"ml":0.0833333333,"d":-0.0178571429,"mi":0.6014094433,"fo":-0.4166666667,"r":2.4736842105,"e":-0.1041821545}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1104_7ae92779","label":1,"code":"MapEntry getEntry(String key) {\r\n    checkNotNull(key);\r\n    Segment segment = getSegment();\r\n    int head = segment.readInt(getOffset(0));\r\n    int size = getSize(head);\r\n    if (size == 0) {\r\n        \/\/ shortcut\r\n        return null;\r\n    }\r\n    int hash = getHash(key);\r\n    int level = getLevel(head);\r\n    if (isBranch(size, level)) {\r\n        \/\/ this is an intermediate branch record\r\n        \/\/ check if a matching bucket exists, and recurse\r\n        int bitmap = segment.readInt(getOffset(4));\r\n        int mask = BUCKETS_PER_LEVEL - 1;\r\n        int shift = 32 - (level + 1) * LEVEL_BITS;\r\n        int index = (hash >> shift) & mask;\r\n        int bit = 1 << index;\r\n        if ((bitmap & bit) != 0) {\r\n            int ids = bitCount(bitmap & (bit - 1));\r\n            RecordId id = segment.readRecordId(getOffset(8, ids));\r\n            return new MapRecord(segment, id).getEntry(key);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    \/\/ this is a leaf record; scan the list to find a matching entry\r\n    int d = -1;\r\n    for (int i = 0; i < size && d < 0; i++) {\r\n        d = Integer.valueOf(segment.readInt(getOffset(4 + i * 4))).compareTo(Integer.valueOf(hash));\r\n        if (d == 0) {\r\n            RecordId keyId = segment.readRecordId(getOffset(4 + size * 4, i));\r\n            d = segment.readString(keyId).compareTo(key);\r\n            if (d == 0) {\r\n                RecordId valueId = segment.readRecordId(getOffset(4 + size * 4, size + i));\r\n                return new MapEntry(segment, key, keyId, valueId);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"MapEntry getEntry(String key) {\r\n    checkNotNull(key);\r\n    Segment segment = getSegment();\r\n    int head = segment.readInt(getOffset(0));\r\n    int size = getSize(head);\r\n    if (size == 0) {\r\n                return null;\r\n    }\r\n    int hash = getHash(key);\r\n    int level = getLevel(head);\r\n    if (isBranch(size, level)) {\r\n                        int bitmap = segment.readInt(getOffset(4));\r\n        int mask = BUCKETS_PER_LEVEL - 1;\r\n        int shift = 32 - (level + 1) * LEVEL_BITS;\r\n        int index = (hash >> shift) & mask;\r\n        int bit = 1 << index;\r\n        if ((bitmap & bit) != 0) {\r\n            int ids = bitCount(bitmap & (bit - 1));\r\n            RecordId id = segment.readRecordId(getOffset(8, ids));\r\n            return new MapRecord(segment, id).getEntry(key);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n        int d = -1;\r\n    for (int i = 0; i < size && d < 0; i++) {\r\n        d = Integer.valueOf(segment.readInt(getOffset(4 + i * 4))).compareTo(Integer.valueOf(hash));\r\n        if (d == 0) {\r\n            RecordId keyId = segment.readRecordId(getOffset(4 + size * 4, i));\r\n            d = segment.readString(keyId).compareTo(key);\r\n            if (d == 0) {\r\n                RecordId valueId = segment.readRecordId(getOffset(4 + size * 4, size + i));\r\n                return new MapEntry(segment, key, keyId, valueId);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}","lc":1.0909090909,"pi":0.4593301435,"ma":0.6,"nbd":0.5,"ml":0.75,"d":2.9484126984,"mi":-0.7426356589,"fo":1.5833333333,"r":-0.0263157895,"e":7.5927571561}
{"project_name":"Lang","project_version":"30","label":3,"code":"\/\/ ContainsNone\r\n\/\/ -----------------------------------------------------------------------\r\n\/**\r\n * <p>Checks that the CharSequence does not contain certain characters.<\/p>\r\n *\r\n * <p>A <code>null<\/code> CharSequence will return <code>true<\/code>.\r\n * A <code>null<\/code> invalid character array will return <code>true<\/code>.\r\n * An empty CharSequence (length()=0) always returns true.<\/p>\r\n *\r\n * <pre>\r\n * StringUtils.containsNone(null, *)       = true\r\n * StringUtils.containsNone(*, null)       = true\r\n * StringUtils.containsNone(\"\", *)         = true\r\n * StringUtils.containsNone(\"ab\", '')      = true\r\n * StringUtils.containsNone(\"abab\", 'xyz') = true\r\n * StringUtils.containsNone(\"ab1\", 'xyz')  = true\r\n * StringUtils.containsNone(\"abz\", 'xyz')  = false\r\n * <\/pre>\r\n *\r\n * @param cs  the CharSequence to check, may be null\r\n * @param searchChars  an array of invalid chars, may be null\r\n * @return true if it contains none of the invalid chars, or is null\r\n * @since 2.0\r\n *\/\r\npublic static boolean containsNone(CharSequence cs, char[] searchChars) {\r\n    if (cs == null || searchChars == null) {\r\n        return true;\r\n    }\r\n    int csLen = cs.length();\r\n    int searchLen = searchChars.length;\r\n    for (int i = 0; i < csLen; i++) {\r\n        char ch = cs.charAt(i);\r\n        for (int j = 0; j < searchLen; j++) {\r\n            if (searchChars[j] == ch) {\r\n                \/\/ ch is in the Basic Multilingual Plane\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n * <p>Checks that the CharSequence does not contain certain characters.<\/p>\r\n *\r\n * <p>A <code>null<\/code> CharSequence will return <code>true<\/code>.\r\n * A <code>null<\/code> invalid character array will return <code>true<\/code>.\r\n * An empty CharSequence (length()=0) always returns true.<\/p>\r\n *\r\n * <pre>\r\n * StringUtils.containsNone(null, *)       = true\r\n * StringUtils.containsNone(*, null)       = true\r\n * StringUtils.containsNone(\"\", *)         = true\r\n * StringUtils.containsNone(\"ab\", '')      = true\r\n * StringUtils.containsNone(\"abab\", 'xyz') = true\r\n * StringUtils.containsNone(\"ab1\", 'xyz')  = true\r\n * StringUtils.containsNone(\"abz\", 'xyz')  = false\r\n * <\/pre>\r\n *\r\n * @param cs  the CharSequence to check, may be null\r\n * @param searchChars  an array of invalid chars, may be null\r\n * @return true if it contains none of the invalid chars, or is null\r\n * @since 2.0\r\n *\/\r\n","code_no_comment":"public static boolean containsNone(CharSequence cs, char[] searchChars) {\r\n    if (cs == null || searchChars == null) {\r\n        return true;\r\n    }\r\n    int csLen = cs.length();\r\n    int searchLen = searchChars.length;\r\n    for (int i = 0; i < csLen; i++) {\r\n        char ch = cs.charAt(i);\r\n        for (int j = 0; j < searchLen; j++) {\r\n            if (searchChars[j] == ch) {\r\n                                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}","lc":0.0909090909,"pi":0.5980861244,"ma":0.2,"nbd":0.5,"ml":0.5833333333,"d":0.503968254,"mi":-0.1052854123,"fo":-0.3333333333,"r":0.0,"e":0.2624597316}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7418_cabee0e9","label":3,"code":"public <T> Set<T> findByType(Class<T> type) {\r\n    Set<T> answer = new LinkedHashSet<T>();\r\n    try {\r\n        NamingEnumeration<NameClassPair> list = getContext().list(\"\");\r\n        while (list.hasMore()) {\r\n            NameClassPair pair = list.next();\r\n            if (type.isInstance(pair.getClass()) || type.getName().equals(pair.getClassName())) {\r\n                Object instance = context.lookup(pair.getName());\r\n                answer.add(type.cast(instance));\r\n            }\r\n        }\r\n    } catch (NamingException e) {\r\n    \/\/ ignore\r\n    }\r\n    return answer;\r\n}","code_comment":null,"code_no_comment":"public <T> Set<T> findByType(Class<T> type) {\r\n    Set<T> answer = new LinkedHashSet<T>();\r\n    try {\r\n        NamingEnumeration<NameClassPair> list = getContext().list(\"\");\r\n        while (list.hasMore()) {\r\n            NameClassPair pair = list.next();\r\n            if (type.isInstance(pair.getClass()) || type.getName().equals(pair.getClassName())) {\r\n                Object instance = context.lookup(pair.getName());\r\n                answer.add(type.cast(instance));\r\n            }\r\n        }\r\n    } catch (NamingException e) {\r\n        }\r\n    return answer;\r\n}","lc":0.0454545455,"pi":0.976076555,"ma":0.0,"nbd":0.5,"ml":0.25,"d":-0.0357142857,"mi":-0.1016208598,"fo":0.5833333333,"r":0.0526315789,"e":0.0375719645}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1719_c3773d53","label":1,"code":"private String copyWorkspaces(NodeBuilder builder, NodeState root, Map<String, String> uriToPrefix, Map<Integer, String> idxToPrefix) throws RepositoryException, IOException {\r\n    logger.info(\"Copying default workspace\");\r\n    \/\/ Copy all the default workspace content\r\n    RepositoryConfig config = source.getRepositoryConfig();\r\n    String name = config.getDefaultWorkspaceName();\r\n    PersistenceManager pm = source.getWorkspaceInfo(name).getPersistenceManager();\r\n    NodeState state = new JackrabbitNodeState(pm, root, uriToPrefix, ROOT_NODE_ID, \"\/\", copyBinariesByReference);\r\n    for (PropertyState property : state.getProperties()) {\r\n        builder.setProperty(property);\r\n    }\r\n    for (ChildNodeEntry child : state.getChildNodeEntries()) {\r\n        String childName = child.getName();\r\n        if (!JCR_SYSTEM.equals(childName)) {\r\n            builder.setChildNode(childName, child.getNodeState());\r\n        }\r\n    }\r\n    return name;\r\n}","code_comment":null,"code_no_comment":"private String copyWorkspaces(NodeBuilder builder, NodeState root, Map<String, String> uriToPrefix, Map<Integer, String> idxToPrefix) throws RepositoryException, IOException {\r\n    logger.info(\"Copying default workspace\");\r\n        RepositoryConfig config = source.getRepositoryConfig();\r\n    String name = config.getDefaultWorkspaceName();\r\n    PersistenceManager pm = source.getWorkspaceInfo(name).getPersistenceManager();\r\n    NodeState state = new JackrabbitNodeState(pm, root, uriToPrefix, ROOT_NODE_ID, \"\/\", copyBinariesByReference);\r\n    for (PropertyState property : state.getProperties()) {\r\n        builder.setProperty(property);\r\n    }\r\n    for (ChildNodeEntry child : state.getChildNodeEntries()) {\r\n        String childName = child.getName();\r\n        if (!JCR_SYSTEM.equals(childName)) {\r\n            builder.setChildNode(childName, child.getNodeState());\r\n        }\r\n    }\r\n    return name;\r\n}","lc":0.1363636364,"pi":-0.033492823,"ma":0.0,"nbd":0.0,"ml":-0.1666666667,"d":-0.0634920635,"mi":-0.2217054264,"fo":0.5,"r":-0.0263157895,"e":0.1202768509}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3617_7ae109a6","label":1,"code":"\/*\r\n\t * TODO: simplify the code below. See WICKET-3347\r\n\t *\/\r\n@Override\r\npublic void respond(RequestCycle requestCycle) {\r\n    Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();\r\n    Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());\r\n    \/\/ \r\n    \/\/ the code below is little hairy but we have to handle 3 redirect policies,\r\n    \/\/ 3 rendering strategies and two kind of requests (ajax and normal)\r\n    \/\/ \r\n    \/\/ try to get an already rendered buffered response for current URL\r\n    BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);\r\n    boolean isAjax = isAjax(requestCycle);\r\n    boolean shouldPreserveClientUrl = ((WebRequest) requestCycle.getRequest()).shouldPreserveClientUrl();\r\n    if (bufferedResponse != null) {\r\n        logger.warn(\"The Buffered response should be handled by BufferedResponseRequestHandler\");\r\n        \/\/ if there is saved response for this URL render it\r\n        bufferedResponse.writeTo((WebResponse) requestCycle.getResponse());\r\n    } else if (\/\/ \r\n    getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT || isOnePassRender() || (\/\/ \r\n    !isAjax && \/\/ \r\n    (targetUrl.equals(currentUrl) && !getPageProvider().isNewPageInstance() && !getPage().isPageStateless()) || \/\/ \r\n    (targetUrl.equals(currentUrl) && isRedirectToRender())) || \/\/ \r\n    shouldPreserveClientUrl) {\r\n        \/\/ if the policy is never to redirect\r\n        \/\/ or one pass render mode is on\r\n        \/\/ or the targetUrl matches current url and the page is not stateless\r\n        \/\/ or the targetUrl matches current url, page is stateless but it's redirect-to-render\r\n        \/\/ or the request determines that the current url should be preserved\r\n        \/\/ just render the page\r\n        BufferedWebResponse response = renderPage(currentUrl, requestCycle);\r\n        if (response != null) {\r\n            response.writeTo((WebResponse) requestCycle.getResponse());\r\n        }\r\n    } else if (\/\/ \r\n    (!targetUrl.equals(currentUrl) && getRedirectPolicy() == RedirectPolicy.ALWAYS_REDIRECT) || \/\/ \r\n    isRedirectToRender() || (isAjax && targetUrl.equals(currentUrl))) {\r\n        \/\/ if target URL is different\r\n        \/\/ and render policy is always-redirect or it's redirect-to-render\r\n        redirectTo(targetUrl, requestCycle);\r\n    } else if (\/\/ \r\n    !targetUrl.equals(currentUrl) && (getPageProvider().isNewPageInstance() || (isSessionTemporary() && getPage().isPageStateless()))) {\r\n        \/\/ if target URL is different and session is temporary and page is stateless\r\n        \/\/ this is special case when page is stateless but there is no session so we can't\r\n        \/\/ render it to buffer\r\n        \/\/ alternatively if URLs are different and we have a page class and not an instance we\r\n        \/\/ can redirect to the url which will instantiate the instance of us\r\n        \/\/ note: if we had session here we would render the page to buffer and then redirect to\r\n        \/\/ URL generated *after* page has been rendered (the statelessness may change during\r\n        \/\/ render). this would save one redirect because now we have to render to URL generated\r\n        \/\/ *before* page is rendered, render the page, get URL after render and if the URL is\r\n        \/\/ different (meaning page is not stateless), save the buffer and redirect again (which\r\n        \/\/ is pretty much what the next step does)\r\n        redirectTo(targetUrl, requestCycle);\r\n    } else if (isRedirectToBuffer()) {\r\n        \/\/ redirect to buffer\r\n        BufferedWebResponse response = renderPage(targetUrl, requestCycle);\r\n        if (response == null) {\r\n            return;\r\n        }\r\n        \/\/ check if the url hasn't changed after page has been rendered\r\n        \/\/ (i.e. the stateless flag might have changed which could result in different page url)\r\n        Url targetUrl2 = requestCycle.mapUrlFor(getRenderPageRequestHandler());\r\n        if (targetUrl.getSegments().equals(targetUrl2.getSegments()) == false) {\r\n            \/\/ the amount of segments is different - generated relative URLs will not work, we\r\n            \/\/ need to rerender the page. This shouldn't happen, but in theory it can - with\r\n            \/\/ RequestHandlerEncoders that produce different URLs with different amount of\r\n            \/\/ segments for stateless and stateful pages\r\n            response = renderPage(targetUrl2, requestCycle);\r\n        }\r\n        if (currentUrl.equals(targetUrl2)) {\r\n            \/\/ no need to redirect when both urls are exactly the same\r\n            response.writeTo((WebResponse) requestCycle.getResponse());\r\n        } else \/\/ if page is still stateless after render\r\n        if (getPage().isPageStateless() && !enableRedirectForStatelessPage()) {\r\n            \/\/ we don't want the redirect to happen for stateless page\r\n            \/\/ example:\r\n            \/\/ when a normal mounted stateful page is hit at \/mount\/point\r\n            \/\/ wicket renders the page to buffer and redirects to \/mount\/point?12\r\n            \/\/ but for stateless page the redirect is not necessary\r\n            \/\/ also for listener interface on stateful page we want to redirect\r\n            \/\/ after the listener is invoked, but on stateless page the user\r\n            \/\/ must ask for redirect explicitly\r\n            response.writeTo((WebResponse) requestCycle.getResponse());\r\n        } else {\r\n            storeBufferedResponse(targetUrl2, response);\r\n            redirectTo(targetUrl2, requestCycle);\r\n        }\r\n    } else {\r\n        throw new IllegalStateException(\"Unknown RenderStrategy.\");\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void respond(RequestCycle requestCycle) {\r\n    Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();\r\n    Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());\r\n                        BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);\r\n    boolean isAjax = isAjax(requestCycle);\r\n    boolean shouldPreserveClientUrl = ((WebRequest) requestCycle.getRequest()).shouldPreserveClientUrl();\r\n    if (bufferedResponse != null) {\r\n        logger.warn(\"The Buffered response should be handled by BufferedResponseRequestHandler\");\r\n                bufferedResponse.writeTo((WebResponse) requestCycle.getResponse());\r\n    } else if (    getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT || isOnePassRender() || (    !isAjax &&     (targetUrl.equals(currentUrl) && !getPageProvider().isNewPageInstance() && !getPage().isPageStateless()) ||     (targetUrl.equals(currentUrl) && isRedirectToRender())) ||     shouldPreserveClientUrl) {\r\n                                                        BufferedWebResponse response = renderPage(currentUrl, requestCycle);\r\n        if (response != null) {\r\n            response.writeTo((WebResponse) requestCycle.getResponse());\r\n        }\r\n    } else if (    (!targetUrl.equals(currentUrl) && getRedirectPolicy() == RedirectPolicy.ALWAYS_REDIRECT) ||     isRedirectToRender() || (isAjax && targetUrl.equals(currentUrl))) {\r\n                        redirectTo(targetUrl, requestCycle);\r\n    } else if (    !targetUrl.equals(currentUrl) && (getPageProvider().isNewPageInstance() || (isSessionTemporary() && getPage().isPageStateless()))) {\r\n                                                                                                redirectTo(targetUrl, requestCycle);\r\n    } else if (isRedirectToBuffer()) {\r\n                BufferedWebResponse response = renderPage(targetUrl, requestCycle);\r\n        if (response == null) {\r\n            return;\r\n        }\r\n                        Url targetUrl2 = requestCycle.mapUrlFor(getRenderPageRequestHandler());\r\n        if (targetUrl.getSegments().equals(targetUrl2.getSegments()) == false) {\r\n                                                            response = renderPage(targetUrl2, requestCycle);\r\n        }\r\n        if (currentUrl.equals(targetUrl2)) {\r\n                        response.writeTo((WebResponse) requestCycle.getResponse());\r\n        } else         if (getPage().isPageStateless() && !enableRedirectForStatelessPage()) {\r\n                                                                                                            response.writeTo((WebResponse) requestCycle.getResponse());\r\n        } else {\r\n            storeBufferedResponse(targetUrl2, response);\r\n            redirectTo(targetUrl2, requestCycle);\r\n        }\r\n    } else {\r\n        throw new IllegalStateException(\"Unknown RenderStrategy.\");\r\n    }\r\n}","lc":1.5909090909,"pi":0.1052631579,"ma":1.6,"nbd":2.5,"ml":3.25,"d":1.3115079365,"mi":-0.8900634249,"fo":3.9166666667,"r":-0.0263157895,"e":3.7331558352}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Checks the expansion factor and the contraction criterion and throws an\r\n * IllegalArgumentException if the contractionCriteria is less than the\r\n * expansionCriteria\r\n *\r\n * @param expansion factor to be checked\r\n * @param contraction criteria to be checked\r\n * @throws MathIllegalArgumentException if the contractionCriteria is less than\r\n * the expansionCriteria.\r\n * @deprecated As of 3.1. Please use\r\n * {@link #checkContractExpand(double,double)} instead.\r\n *\/\r\n@Deprecated\r\nprotected void checkContractExpand(float contraction, float expansion) throws MathIllegalArgumentException {\r\n    checkContractExpand((double) contraction, (double) expansion);\r\n}","code_comment":"\/**\r\n * Checks the expansion factor and the contraction criterion and throws an\r\n * IllegalArgumentException if the contractionCriteria is less than the\r\n * expansionCriteria\r\n *\r\n * @param expansion factor to be checked\r\n * @param contraction criteria to be checked\r\n * @throws MathIllegalArgumentException if the contractionCriteria is less than\r\n * the expansionCriteria.\r\n * @deprecated As of 3.1. Please use\r\n * {@link #checkContractExpand(double,double)} instead.\r\n *\/\r\n","code_no_comment":"@Deprecated\r\nprotected void checkContractExpand(float contraction, float expansion) throws MathIllegalArgumentException {\r\n    checkContractExpand((double) contraction, (double) expansion);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8768146582,"fo":-0.4166666667,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"\/**\r\n *  This method allows a component to be added by an auto-resolver such as\r\n *  AutoComponentResolver or AutoLinkResolver. While the component is being\r\n *  added, the component's FLAG_AUTO boolean is set. The isAuto() method of\r\n *  Component returns true if a component or any of its parents has this bit\r\n *  set. When a component is added via autoAdd(), the logic in Page that\r\n *  normally (a) checks for modifications during the rendering process, and\r\n *  (b) versions components, is bypassed if Component.isAuto() returns true.\r\n *  <p>\r\n *  The result of all this is that components added with autoAdd() are free\r\n *  from versioning and can add their own children without the usual\r\n *  exception that would normally be thrown when the component hierarchy is\r\n *  modified during rendering.\r\n *\r\n *  @param component\r\n *             The component to add\r\n *\/\r\n\/\/ final void autoAdd(final Component component)\r\n\/\/ {\r\n\/\/ component.setAuto(true);\r\n\/\/ add(component);\r\n\/\/ }\r\n\/**\r\n *  @param component\r\n *             The component to check\r\n *  @param recurse\r\n *             True if all descendents should be considered\r\n *  @return True if the component is contained in this container\r\n *\/\r\npublic final boolean contains(final Component component, final boolean recurse) {\r\n    if (component == null) {\r\n        throw new IllegalArgumentException(\"argument component may not be null\");\r\n    }\r\n    if (recurse) {\r\n        \/\/ Start at component and continue while we're not out of parents\r\n        for (Component current = component; current != null; ) {\r\n            \/\/ Get parent\r\n            final MarkupContainer parent = current.getParent();\r\n            \/\/ recursively contained by this container\r\n            if (parent == this) {\r\n                \/\/ Found it!\r\n                return true;\r\n            }\r\n            \/\/ Move up the chain to the next parent\r\n            current = parent;\r\n        }\r\n        \/\/ Failed to find this container in component's ancestry\r\n        return false;\r\n    } else {\r\n        \/\/ Is the component contained in this container?\r\n        return component.getParent() == this;\r\n    }\r\n}","code_comment":"\/**\r\n *  This method allows a component to be added by an auto-resolver such as\r\n *  AutoComponentResolver or AutoLinkResolver. While the component is being\r\n *  added, the component's FLAG_AUTO boolean is set. The isAuto() method of\r\n *  Component returns true if a component or any of its parents has this bit\r\n *  set. When a component is added via autoAdd(), the logic in Page that\r\n *  normally (a) checks for modifications during the rendering process, and\r\n *  (b) versions components, is bypassed if Component.isAuto() returns true.\r\n *  <p>\r\n *  The result of all this is that components added with autoAdd() are free\r\n *  from versioning and can add their own children without the usual\r\n *  exception that would normally be thrown when the component hierarchy is\r\n *  modified during rendering.\r\n *\r\n *  @param component\r\n *             The component to add\r\n *\/\r\n\/**\r\n *  @param component\r\n *             The component to check\r\n *  @param recurse\r\n *             True if all descendents should be considered\r\n *  @return True if the component is contained in this container\r\n *\/\r\n","code_no_comment":"public final boolean contains(final Component component, final boolean recurse) {\r\n    if (component == null) {\r\n        throw new IllegalArgumentException(\"argument component may not be null\");\r\n    }\r\n    if (recurse) {\r\n                for (Component current = component; current != null; ) {\r\n                        final MarkupContainer parent = current.getParent();\r\n                        if (parent == this) {\r\n                                return true;\r\n            }\r\n                        current = parent;\r\n        }\r\n                return false;\r\n    } else {\r\n                return component.getParent() == this;\r\n    }\r\n}","lc":0.1363636364,"pi":0.6698564593,"ma":0.4,"nbd":0.5,"ml":0.25,"d":0.003968254,"mi":-0.0739957717,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.0473043919}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-716_faa77857","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected double doSolve() {\r\n    \/\/ prepare arrays with the first points\r\n    final double[] x = new double[maximalOrder + 1];\r\n    final double[] y = new double[maximalOrder + 1];\r\n    x[0] = getMin();\r\n    x[1] = getStartValue();\r\n    x[2] = getMax();\r\n    verifySequence(x[0], x[1], x[2]);\r\n    \/\/ evaluate initial guess\r\n    y[1] = computeObjectiveValue(x[1]);\r\n    if (Precision.equals(y[1], 0.0, 1)) {\r\n        \/\/ return the initial guess if it is a perfect root.\r\n        return x[1];\r\n    }\r\n    \/\/ evaluate first  endpoint\r\n    y[0] = computeObjectiveValue(x[0]);\r\n    if (Precision.equals(y[0], 0.0, 1)) {\r\n        \/\/ return the first endpoint if it is a perfect root.\r\n        return x[0];\r\n    }\r\n    int nbPoints;\r\n    int signChangeIndex;\r\n    if (y[0] * y[1] < 0) {\r\n        \/\/ reduce interval if it brackets the root\r\n        nbPoints = 2;\r\n        signChangeIndex = 1;\r\n    } else {\r\n        \/\/ evaluate second endpoint\r\n        y[2] = computeObjectiveValue(x[2]);\r\n        if (Precision.equals(y[2], 0.0, 1)) {\r\n            \/\/ return the second endpoint if it is a perfect root.\r\n            return x[2];\r\n        }\r\n        if (y[1] * y[2] < 0) {\r\n            \/\/ use all computed point as a start sampling array for solving\r\n            nbPoints = 3;\r\n            signChangeIndex = 2;\r\n        } else {\r\n            throw new NoBracketingException(x[0], x[2], y[0], y[2]);\r\n        }\r\n    }\r\n    \/\/ prepare a work array for inverse polynomial interpolation\r\n    final double[] tmpX = new double[x.length];\r\n    \/\/ current tightest bracketing of the root\r\n    double xA = x[signChangeIndex - 1];\r\n    double yA = y[signChangeIndex - 1];\r\n    double absYA = FastMath.abs(yA);\r\n    int agingA = 0;\r\n    double xB = x[signChangeIndex];\r\n    double yB = y[signChangeIndex];\r\n    double absYB = FastMath.abs(yB);\r\n    int agingB = 0;\r\n    \/\/ search loop\r\n    while (true) {\r\n        \/\/ check convergence of bracketing interval\r\n        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\r\n        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\r\n            switch(allowed) {\r\n                case ANY_SIDE:\r\n                    return absYA < absYB ? xA : xB;\r\n                case LEFT_SIDE:\r\n                    return xA;\r\n                case RIGHT_SIDE:\r\n                    return xB;\r\n                case BELOW_SIDE:\r\n                    return (yA <= 0) ? xA : xB;\r\n                case ABOVE_SIDE:\r\n                    return (yA < 0) ? xB : xA;\r\n                default:\r\n                    \/\/ this should never happen\r\n                    throw new MathInternalError(null);\r\n            }\r\n        }\r\n        \/\/ target for the next evaluation point\r\n        double targetY;\r\n        if (agingA >= MAXIMAL_AGING) {\r\n            \/\/ we keep updating the high bracket, try to compensate this\r\n            targetY = -REDUCTION_FACTOR * yB;\r\n        } else if (agingB >= MAXIMAL_AGING) {\r\n            \/\/ we keep updating the low bracket, try to compensate this\r\n            targetY = -REDUCTION_FACTOR * yA;\r\n        } else {\r\n            \/\/ bracketing is balanced, try to find the root itself\r\n            targetY = 0;\r\n        }\r\n        \/\/ make a few attempts to guess a root,\r\n        double nextX;\r\n        int start = 0;\r\n        int end = nbPoints;\r\n        do {\r\n            \/\/ guess a value for current target, using inverse polynomial interpolation\r\n            System.arraycopy(x, start, tmpX, start, end - start);\r\n            nextX = guessX(targetY, tmpX, y, start, end);\r\n            if (!((nextX > xA) && (nextX < xB))) {\r\n                \/\/ we try again with a lower interpolation order\r\n                if (signChangeIndex - start >= end - signChangeIndex) {\r\n                    \/\/ we have more points before the sign change, drop the lowest point\r\n                    ++start;\r\n                } else {\r\n                    \/\/ we have more points after sign change, drop the highest point\r\n                    --end;\r\n                }\r\n                \/\/ we need to do one more attempt\r\n                nextX = Double.NaN;\r\n            }\r\n        } while (Double.isNaN(nextX) && (end - start > 1));\r\n        if (Double.isNaN(nextX)) {\r\n            \/\/ fall back to bisection\r\n            nextX = xA + 0.5 * (xB - xA);\r\n            start = signChangeIndex - 1;\r\n            end = signChangeIndex;\r\n        }\r\n        \/\/ evaluate the function at the guessed root\r\n        final double nextY = computeObjectiveValue(nextX);\r\n        if (Precision.equals(nextY, 0.0, 1)) {\r\n            \/\/ we don't need to bother about the allowed solutions setting\r\n            return nextX;\r\n        }\r\n        if ((nbPoints > 2) && (end - start != nbPoints)) {\r\n            \/\/ we have been forced to ignore some points to keep bracketing,\r\n            \/\/ they are probably too far from the root, drop them from now on\r\n            nbPoints = end - start;\r\n            System.arraycopy(x, start, x, 0, nbPoints);\r\n            System.arraycopy(y, start, y, 0, nbPoints);\r\n            signChangeIndex -= start;\r\n        } else if (nbPoints == x.length) {\r\n            \/\/ we have to drop one point in order to insert the new one\r\n            nbPoints--;\r\n            \/\/ keep the tightest bracketing interval as centered as possible\r\n            if (signChangeIndex >= (x.length + 1) \/ 2) {\r\n                \/\/ we drop the lowest point, we have to shift the arrays and the index\r\n                System.arraycopy(x, 1, x, 0, nbPoints);\r\n                System.arraycopy(y, 1, y, 0, nbPoints);\r\n                --signChangeIndex;\r\n            }\r\n        }\r\n        \/\/ insert the last computed point\r\n        \/\/ (by construction, we know it lies inside the tightest bracketing interval)\r\n        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\r\n        x[signChangeIndex] = nextX;\r\n        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\r\n        y[signChangeIndex] = nextY;\r\n        ++nbPoints;\r\n        \/\/ update the bracketing interval\r\n        if (nextY * yA <= 0) {\r\n            \/\/ the sign change occurs before the inserted point\r\n            xB = nextX;\r\n            yB = nextY;\r\n            absYB = FastMath.abs(yB);\r\n            ++agingA;\r\n            agingB = 0;\r\n        } else {\r\n            \/\/ the sign change occurs after the inserted point\r\n            xA = nextX;\r\n            yA = nextY;\r\n            absYA = FastMath.abs(yA);\r\n            agingA = 0;\r\n            ++agingB;\r\n            \/\/ update the sign change index\r\n            signChangeIndex++;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected double doSolve() {\r\n        final double[] x = new double[maximalOrder + 1];\r\n    final double[] y = new double[maximalOrder + 1];\r\n    x[0] = getMin();\r\n    x[1] = getStartValue();\r\n    x[2] = getMax();\r\n    verifySequence(x[0], x[1], x[2]);\r\n        y[1] = computeObjectiveValue(x[1]);\r\n    if (Precision.equals(y[1], 0.0, 1)) {\r\n                return x[1];\r\n    }\r\n        y[0] = computeObjectiveValue(x[0]);\r\n    if (Precision.equals(y[0], 0.0, 1)) {\r\n                return x[0];\r\n    }\r\n    int nbPoints;\r\n    int signChangeIndex;\r\n    if (y[0] * y[1] < 0) {\r\n                nbPoints = 2;\r\n        signChangeIndex = 1;\r\n    } else {\r\n                y[2] = computeObjectiveValue(x[2]);\r\n        if (Precision.equals(y[2], 0.0, 1)) {\r\n                        return x[2];\r\n        }\r\n        if (y[1] * y[2] < 0) {\r\n                        nbPoints = 3;\r\n            signChangeIndex = 2;\r\n        } else {\r\n            throw new NoBracketingException(x[0], x[2], y[0], y[2]);\r\n        }\r\n    }\r\n        final double[] tmpX = new double[x.length];\r\n        double xA = x[signChangeIndex - 1];\r\n    double yA = y[signChangeIndex - 1];\r\n    double absYA = FastMath.abs(yA);\r\n    int agingA = 0;\r\n    double xB = x[signChangeIndex];\r\n    double yB = y[signChangeIndex];\r\n    double absYB = FastMath.abs(yB);\r\n    int agingB = 0;\r\n        while (true) {\r\n                final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\r\n        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\r\n            switch(allowed) {\r\n                case ANY_SIDE:\r\n                    return absYA < absYB ? xA : xB;\r\n                case LEFT_SIDE:\r\n                    return xA;\r\n                case RIGHT_SIDE:\r\n                    return xB;\r\n                case BELOW_SIDE:\r\n                    return (yA <= 0) ? xA : xB;\r\n                case ABOVE_SIDE:\r\n                    return (yA < 0) ? xB : xA;\r\n                default:\r\n                                        throw new MathInternalError(null);\r\n            }\r\n        }\r\n                double targetY;\r\n        if (agingA >= MAXIMAL_AGING) {\r\n                        targetY = -REDUCTION_FACTOR * yB;\r\n        } else if (agingB >= MAXIMAL_AGING) {\r\n                        targetY = -REDUCTION_FACTOR * yA;\r\n        } else {\r\n                        targetY = 0;\r\n        }\r\n                double nextX;\r\n        int start = 0;\r\n        int end = nbPoints;\r\n        do {\r\n                        System.arraycopy(x, start, tmpX, start, end - start);\r\n            nextX = guessX(targetY, tmpX, y, start, end);\r\n            if (!((nextX > xA) && (nextX < xB))) {\r\n                                if (signChangeIndex - start >= end - signChangeIndex) {\r\n                                        ++start;\r\n                } else {\r\n                                        --end;\r\n                }\r\n                                nextX = Double.NaN;\r\n            }\r\n        } while (Double.isNaN(nextX) && (end - start > 1));\r\n        if (Double.isNaN(nextX)) {\r\n                        nextX = xA + 0.5 * (xB - xA);\r\n            start = signChangeIndex - 1;\r\n            end = signChangeIndex;\r\n        }\r\n                final double nextY = computeObjectiveValue(nextX);\r\n        if (Precision.equals(nextY, 0.0, 1)) {\r\n                        return nextX;\r\n        }\r\n        if ((nbPoints > 2) && (end - start != nbPoints)) {\r\n                                    nbPoints = end - start;\r\n            System.arraycopy(x, start, x, 0, nbPoints);\r\n            System.arraycopy(y, start, y, 0, nbPoints);\r\n            signChangeIndex -= start;\r\n        } else if (nbPoints == x.length) {\r\n                        nbPoints--;\r\n                        if (signChangeIndex >= (x.length + 1) \/ 2) {\r\n                                System.arraycopy(x, 1, x, 0, nbPoints);\r\n                System.arraycopy(y, 1, y, 0, nbPoints);\r\n                --signChangeIndex;\r\n            }\r\n        }\r\n                        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\r\n        x[signChangeIndex] = nextX;\r\n        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\r\n        y[signChangeIndex] = nextY;\r\n        ++nbPoints;\r\n                if (nextY * yA <= 0) {\r\n                        xB = nextX;\r\n            yB = nextY;\r\n            absYB = FastMath.abs(yB);\r\n            ++agingA;\r\n            agingB = 0;\r\n        } else {\r\n                        xA = nextX;\r\n            yA = nextY;\r\n            absYA = FastMath.abs(yA);\r\n            agingA = 0;\r\n            ++agingB;\r\n                        signChangeIndex++;\r\n        }\r\n    }\r\n}","lc":5.0909090909,"pi":0.8468899522,"ma":5.2,"nbd":1.0,"ml":4.0,"d":8.4047619048,"mi":-1.5880197322,"fo":2.25,"r":-0.0263157895,"e":56.573348778}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1269_b8fe2ded","label":1,"code":"@Override\r\npublic Cursor query(Filter filter, NodeState root) {\r\n    NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);\r\n    if (!hasNodeTypeRestriction(filter) || !lookup.isIndexed(filter.getPath())) {\r\n        throw new IllegalStateException(\"NodeType index is used even when no index is available for filter \" + filter);\r\n    }\r\n    return Cursors.newPathCursorDistinct(lookup.query(filter));\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Cursor query(Filter filter, NodeState root) {\r\n    NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);\r\n    if (!hasNodeTypeRestriction(filter) || !lookup.isIndexed(filter.getPath())) {\r\n        throw new IllegalStateException(\"NodeType index is used even when no index is available for filter \" + filter);\r\n    }\r\n    return Cursors.newPathCursorDistinct(lookup.query(filter));\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.2,"nbd":-0.5,"ml":0.0833333333,"d":0.2420634921,"mi":0.2882311487,"fo":-0.0833333333,"r":0.0263157895,"e":0.0292272494}
{"project_name":"Closure","project_version":"89","label":2,"code":"boolean canCollapseUnannotatedChildNames() {\r\n    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\r\n        return false;\r\n    }\r\n    \/\/ Don't try to collapse if the one global set is a twin reference.\r\n    \/\/ We could theoretically handle this case in CollapseProperties, but\r\n    \/\/ it's probably not worth the effort.\r\n    Preconditions.checkNotNull(declaration);\r\n    if (declaration.getTwin() != null) {\r\n        return false;\r\n    }\r\n    if (isClassOrEnum) {\r\n        return true;\r\n    }\r\n    \/\/ later. So we won't be able to collapse its properties.\r\n    if (parent != null && parent.shouldKeepKeys()) {\r\n        return false;\r\n    }\r\n    \/\/ If this is aliased, then its properties can't be collapsed either.\r\n    if (type != Type.FUNCTION && aliasingGets > 0) {\r\n        return false;\r\n    }\r\n    return (parent == null || parent.canCollapseUnannotatedChildNames());\r\n}","code_comment":null,"code_no_comment":"boolean canCollapseUnannotatedChildNames() {\r\n    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\r\n        return false;\r\n    }\r\n                Preconditions.checkNotNull(declaration);\r\n    if (declaration.getTwin() != null) {\r\n        return false;\r\n    }\r\n    if (isClassOrEnum) {\r\n        return true;\r\n    }\r\n        if (parent != null && parent.shouldKeepKeys()) {\r\n        return false;\r\n    }\r\n        if (type != Type.FUNCTION && aliasingGets > 0) {\r\n        return false;\r\n    }\r\n    return (parent == null || parent.canCollapseUnannotatedChildNames());\r\n}","lc":0.2272727273,"pi":-0.3110047847,"ma":0.4,"nbd":-0.5,"ml":1.0,"d":0.2777777778,"mi":-0.1971811135,"fo":-0.1666666667,"r":0.0789473684,"e":0.1670118659}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-880_2a9cbbab","label":1,"code":"\/**\r\n * Check if the instance and another vertex share a node.\r\n * <p>\r\n * When two vertices share a node, this means they are already handled\r\n * by the hyperplane of this node, so there is no need to create a cut\r\n * hyperplane for them.\r\n * <\/p>\r\n * @param vertex other vertex to check instance against\r\n * @return true if the instance and another vertex share a node\r\n *\/\r\npublic boolean shareNodeWith(final Vertex vertex) {\r\n    for (final BSPTree<Euclidean2D> node1 : nodes) {\r\n        for (final BSPTree<Euclidean2D> node2 : vertex.nodes) {\r\n            if (node1 == node2) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":"\/**\r\n * Check if the instance and another vertex share a node.\r\n * <p>\r\n * When two vertices share a node, this means they are already handled\r\n * by the hyperplane of this node, so there is no need to create a cut\r\n * hyperplane for them.\r\n * <\/p>\r\n * @param vertex other vertex to check instance against\r\n * @return true if the instance and another vertex share a node\r\n *\/\r\n","code_no_comment":"public boolean shareNodeWith(final Vertex vertex) {\r\n    for (final BSPTree<Euclidean2D> node1 : nodes) {\r\n        for (final BSPTree<Euclidean2D> node2 : vertex.nodes) {\r\n            if (node1 == node2) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}","lc":-0.1818181818,"pi":1.0,"ma":0.0,"nbd":0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.2893587033,"fo":-0.5,"r":0.3684210526,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-9641_9a6e6d8a","label":1,"code":"private Expression createSimpleFileExpression(String remainder) {\r\n    if (ObjectHelper.equal(remainder, \"name\")) {\r\n        return ExpressionBuilder.fileNameExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"name.noext\")) {\r\n        return ExpressionBuilder.fileNameNoExtensionExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"name.noext.single\")) {\r\n        return ExpressionBuilder.fileNameNoExtensionSingleExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"name.ext\") || ObjectHelper.equal(remainder, \"ext\")) {\r\n        return ExpressionBuilder.fileExtensionExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"name.ext.single\")) {\r\n        return ExpressionBuilder.fileExtensionSingleExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"onlyname\")) {\r\n        return ExpressionBuilder.fileOnlyNameExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"onlyname.noext\")) {\r\n        return ExpressionBuilder.fileOnlyNameNoExtensionExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"onlyname.noext.single\")) {\r\n        return ExpressionBuilder.fileOnlyNameNoExtensionSingleExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"parent\")) {\r\n        return ExpressionBuilder.fileParentExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"path\")) {\r\n        return ExpressionBuilder.filePathExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"absolute\")) {\r\n        return ExpressionBuilder.fileAbsoluteExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"absolute.path\")) {\r\n        return ExpressionBuilder.fileAbsolutePathExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"length\") || ObjectHelper.equal(remainder, \"size\")) {\r\n        return ExpressionBuilder.fileSizeExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"modified\")) {\r\n        return ExpressionBuilder.fileLastModifiedExpression();\r\n    }\r\n    throw new SimpleParserException(\"Unknown file language syntax: \" + remainder, token.getIndex());\r\n}","code_comment":null,"code_no_comment":"private Expression createSimpleFileExpression(String remainder) {\r\n    if (ObjectHelper.equal(remainder, \"name\")) {\r\n        return ExpressionBuilder.fileNameExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"name.noext\")) {\r\n        return ExpressionBuilder.fileNameNoExtensionExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"name.noext.single\")) {\r\n        return ExpressionBuilder.fileNameNoExtensionSingleExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"name.ext\") || ObjectHelper.equal(remainder, \"ext\")) {\r\n        return ExpressionBuilder.fileExtensionExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"name.ext.single\")) {\r\n        return ExpressionBuilder.fileExtensionSingleExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"onlyname\")) {\r\n        return ExpressionBuilder.fileOnlyNameExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"onlyname.noext\")) {\r\n        return ExpressionBuilder.fileOnlyNameNoExtensionExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"onlyname.noext.single\")) {\r\n        return ExpressionBuilder.fileOnlyNameNoExtensionSingleExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"parent\")) {\r\n        return ExpressionBuilder.fileParentExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"path\")) {\r\n        return ExpressionBuilder.filePathExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"absolute\")) {\r\n        return ExpressionBuilder.fileAbsoluteExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"absolute.path\")) {\r\n        return ExpressionBuilder.fileAbsolutePathExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"length\") || ObjectHelper.equal(remainder, \"size\")) {\r\n        return ExpressionBuilder.fileSizeExpression();\r\n    } else if (ObjectHelper.equal(remainder, \"modified\")) {\r\n        return ExpressionBuilder.fileLastModifiedExpression();\r\n    }\r\n    throw new SimpleParserException(\"Unknown file language syntax: \" + remainder, token.getIndex());\r\n}","lc":0.8181818182,"pi":-0.2822966507,"ma":2.4,"nbd":6.0,"ml":2.3333333333,"d":0.1170634921,"mi":-0.6397463002,"fo":2.0833333333,"r":-0.0263157895,"e":0.4790396662}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3789_9319e139","label":1,"code":"public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {\r\n    lockFileName = file.getAbsoluteFilePath() + FileComponent.DEFAULT_LOCK_FILE_POSTFIX;\r\n    LOG.trace(\"Locking the file: {} using the lock file name: {}\", file, lockFileName);\r\n    \/\/ create a plain file as marker filer for locking (do not use FileLock)\r\n    lock = new File(lockFileName);\r\n    boolean acquired = lock.createNewFile();\r\n    if (!acquired) {\r\n        lock = null;\r\n    }\r\n    return acquired;\r\n}","code_comment":null,"code_no_comment":"public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {\r\n    lockFileName = file.getAbsoluteFilePath() + FileComponent.DEFAULT_LOCK_FILE_POSTFIX;\r\n    LOG.trace(\"Locking the file: {} using the lock file name: {}\", file, lockFileName);\r\n        lock = new File(lockFileName);\r\n    boolean acquired = lock.createNewFile();\r\n    if (!acquired) {\r\n        lock = null;\r\n    }\r\n    return acquired;\r\n}","lc":-0.1818181818,"pi":-0.4019138756,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0714285714,"mi":0.1605355884,"fo":-0.25,"r":0.0,"e":-0.0473366643}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2763_af477563","label":1,"code":"\/**\r\n *  Spills this partition to disk and sets it up such that it continues spilling records that are added to\r\n *  it. The spilling process must free at least one buffer, either in the partition's record buffers, or in\r\n *  the memory segments for overflow buckets.\r\n *  The partition immediately takes back one buffer to use it for further spilling.\r\n *\r\n *  @param target The list to which memory segments from overflow buckets are added.\r\n *  @param ioAccess The I\/O manager to be used to create a writer to disk.\r\n *  @param targetChannel The id of the target channel for this partition.\r\n *  @return The number of buffers that were freed by spilling this partition.\r\n *  @throws IOException Thrown, if the writing failed.\r\n *\/\r\npublic int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel, LinkedBlockingQueue<MemorySegment> bufferReturnQueue) throws IOException {\r\n    \/\/ sanity checks\r\n    if (!isInMemory()) {\r\n        throw new RuntimeException(\"Bug in Hybrid Hash Join: \" + \"Request to spill a partition that has already been spilled.\");\r\n    }\r\n    if (getBuildSideBlockCount() + this.numOverflowSegments < 2) {\r\n        throw new RuntimeException(\"Bug in Hybrid Hash Join: \" + \"Request to spill a partition with less than two buffers.\");\r\n    }\r\n    \/\/ return the memory from the overflow segments\r\n    for (int i = 0; i < this.numOverflowSegments; i++) {\r\n        target.add(this.overflowSegments[i]);\r\n    }\r\n    this.overflowSegments = null;\r\n    this.numOverflowSegments = 0;\r\n    this.nextOverflowBucket = 0;\r\n    \/\/ create the channel block writer and spill the current buffers\r\n    \/\/ that keep the build side buffers current block, as it is most likely not full, yet\r\n    \/\/ we return the number of blocks that become available\r\n    this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue);\r\n    return this.buildSideWriteBuffer.spill(this.buildSideChannel);\r\n}","code_comment":"\/**\r\n *  Spills this partition to disk and sets it up such that it continues spilling records that are added to\r\n *  it. The spilling process must free at least one buffer, either in the partition's record buffers, or in\r\n *  the memory segments for overflow buckets.\r\n *  The partition immediately takes back one buffer to use it for further spilling.\r\n *\r\n *  @param target The list to which memory segments from overflow buckets are added.\r\n *  @param ioAccess The I\/O manager to be used to create a writer to disk.\r\n *  @param targetChannel The id of the target channel for this partition.\r\n *  @return The number of buffers that were freed by spilling this partition.\r\n *  @throws IOException Thrown, if the writing failed.\r\n *\/\r\n","code_no_comment":"public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIOChannel.ID targetChannel, LinkedBlockingQueue<MemorySegment> bufferReturnQueue) throws IOException {\r\n        if (!isInMemory()) {\r\n        throw new RuntimeException(\"Bug in Hybrid Hash Join: \" + \"Request to spill a partition that has already been spilled.\");\r\n    }\r\n    if (getBuildSideBlockCount() + this.numOverflowSegments < 2) {\r\n        throw new RuntimeException(\"Bug in Hybrid Hash Join: \" + \"Request to spill a partition with less than two buffers.\");\r\n    }\r\n        for (int i = 0; i < this.numOverflowSegments; i++) {\r\n        target.add(this.overflowSegments[i]);\r\n    }\r\n    this.overflowSegments = null;\r\n    this.numOverflowSegments = 0;\r\n    this.nextOverflowBucket = 0;\r\n                this.buildSideChannel = ioAccess.createBlockChannelWriter(targetChannel, bufferReturnQueue);\r\n    return this.buildSideWriteBuffer.spill(this.buildSideChannel);\r\n}","lc":0.0909090909,"pi":-0.3684210526,"ma":0.4,"nbd":-0.5,"ml":0.1666666667,"d":0.2361111111,"mi":-0.1658914729,"fo":-0.0833333333,"r":-0.0263157895,"e":0.2636261475}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1290_45fb6d82","label":1,"code":"@Override\r\nprotected List<GlobalPropertiesPair> createPossibleGlobalProperties() {\r\n    RequestedGlobalProperties partitioned1 = new RequestedGlobalProperties();\r\n    if (this.customPartitioner == null) {\r\n        partitioned1.setAnyPartitioning(this.keys1);\r\n    } else {\r\n        partitioned1.setCustomPartitioned(this.keys1, this.customPartitioner);\r\n    }\r\n    RequestedGlobalProperties partitioned2 = new RequestedGlobalProperties();\r\n    if (this.customPartitioner == null) {\r\n        partitioned2.setAnyPartitioning(this.keys2);\r\n    } else {\r\n        partitioned2.setCustomPartitioned(this.keys2, this.customPartitioner);\r\n    }\r\n    return Collections.singletonList(new GlobalPropertiesPair(partitioned1, partitioned2));\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected List<GlobalPropertiesPair> createPossibleGlobalProperties() {\r\n    RequestedGlobalProperties partitioned1 = new RequestedGlobalProperties();\r\n    if (this.customPartitioner == null) {\r\n        partitioned1.setAnyPartitioning(this.keys1);\r\n    } else {\r\n        partitioned1.setCustomPartitioned(this.keys1, this.customPartitioner);\r\n    }\r\n    RequestedGlobalProperties partitioned2 = new RequestedGlobalProperties();\r\n    if (this.customPartitioner == null) {\r\n        partitioned2.setAnyPartitioning(this.keys2);\r\n    } else {\r\n        partitioned2.setCustomPartitioned(this.keys2, this.customPartitioner);\r\n    }\r\n    return Collections.singletonList(new GlobalPropertiesPair(partitioned1, partitioned2));\r\n}","lc":0.0909090909,"pi":-0.1722488038,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":0.0555555556,"mi":-0.0505990134,"fo":-0.0833333333,"r":-0.0263157895,"e":-0.0075540418}
{"project_name":"Lang","project_version":"63","label":1,"code":"static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\r\n    end.add(field, -1 * difference);\r\n    int endValue = end.get(field);\r\n    int startValue = start.get(field);\r\n    if (endValue < startValue) {\r\n        int newdiff = startValue - endValue;\r\n        end.add(field, newdiff);\r\n        return newdiff;\r\n    } else {\r\n        return 0;\r\n    }\r\n}","code_comment":null,"code_no_comment":"static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\r\n    end.add(field, -1 * difference);\r\n    int endValue = end.get(field);\r\n    int startValue = start.get(field);\r\n    if (endValue < startValue) {\r\n        int newdiff = startValue - endValue;\r\n        end.add(field, newdiff);\r\n        return newdiff;\r\n    } else {\r\n        return 0;\r\n    }\r\n}","lc":-0.0909090909,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":0.5416666667,"mi":0.0835799859,"fo":-0.1666666667,"r":-0.0263157895,"e":0.1799577001}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5796_de6dd425","label":1,"code":"protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorDefinition<?>> outputs) throws Exception {\r\n    List<Processor> list = new ArrayList<Processor>();\r\n    for (ProcessorDefinition<?> output : outputs) {\r\n        \/\/ resolve properties before we create the processor\r\n        resolvePropertyPlaceholders(routeContext, output);\r\n        Processor processor = null;\r\n        \/\/ at first use custom factory\r\n        if (routeContext.getCamelContext().getProcessorFactory() != null) {\r\n            processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, output);\r\n        }\r\n        \/\/ fallback to default implementation if factory did not create the processor\r\n        if (processor == null) {\r\n            processor = output.createProcessor(routeContext);\r\n        }\r\n        if (output instanceof Channel && processor == null) {\r\n            continue;\r\n        }\r\n        Processor channel = wrapChannel(routeContext, processor, output);\r\n        list.add(channel);\r\n    }\r\n    \/\/ if more than one output wrap than in a composite processor else just keep it as is\r\n    Processor processor = null;\r\n    if (!list.isEmpty()) {\r\n        if (list.size() == 1) {\r\n            processor = list.get(0);\r\n        } else {\r\n            processor = createCompositeProcessor(routeContext, list);\r\n        }\r\n    }\r\n    return processor;\r\n}","code_comment":null,"code_no_comment":"protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorDefinition<?>> outputs) throws Exception {\r\n    List<Processor> list = new ArrayList<Processor>();\r\n    for (ProcessorDefinition<?> output : outputs) {\r\n                resolvePropertyPlaceholders(routeContext, output);\r\n        Processor processor = null;\r\n                if (routeContext.getCamelContext().getProcessorFactory() != null) {\r\n            processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, output);\r\n        }\r\n                if (processor == null) {\r\n            processor = output.createProcessor(routeContext);\r\n        }\r\n        if (output instanceof Channel && processor == null) {\r\n            continue;\r\n        }\r\n        Processor channel = wrapChannel(routeContext, processor, output);\r\n        list.add(channel);\r\n    }\r\n        Processor processor = null;\r\n    if (!list.isEmpty()) {\r\n        if (list.size() == 1) {\r\n            processor = list.get(0);\r\n        } else {\r\n            processor = createCompositeProcessor(routeContext, list);\r\n        }\r\n    }\r\n    return processor;\r\n}","lc":0.5909090909,"pi":0.1626794258,"ma":0.8,"nbd":0.0,"ml":0.5,"d":0.5932539683,"mi":-0.467230444,"fo":0.5833333333,"r":-0.0263157895,"e":0.7883427557}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1096_19c1c3bb","label":0,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic EnclosingBall<Euclidean2D, Vector2D> ballOnSupport(final List<Vector2D> support) {\r\n    if (support.size() < 1) {\r\n        return new EnclosingBall<Euclidean2D, Vector2D>(Vector2D.ZERO, -1.0);\r\n    } else {\r\n        final Vector2D vA = support.get(0);\r\n        if (support.size() < 2) {\r\n            return new EnclosingBall<Euclidean2D, Vector2D>(vA, 0, vA);\r\n        } else {\r\n            final Vector2D vB = support.get(1);\r\n            if (support.size() < 3) {\r\n                return new EnclosingBall<Euclidean2D, Vector2D>(new Vector2D(0.5, vA, 0.5, vB), 0.5 * vA.distance(vB), vA, vB);\r\n            } else {\r\n                final Vector2D vC = support.get(2);\r\n                \/\/ a disk is 2D can be defined as:\r\n                \/\/ (1)   (x - x_0)^2 + (y - y_0)^2 = r^2\r\n                \/\/ which can be written:\r\n                \/\/ (2)   (x^2 + y^2) - 2 x_0 x - 2 y_0 y + (x_0^2 + y_0^2 - r^2) = 0\r\n                \/\/ or simply:\r\n                \/\/ (3)   (x^2 + y^2) + a x + b y + c= 0\r\n                \/\/ with disk center coordinates -a\/2, -b\/2\r\n                \/\/ If the sphere exists, a, b and c are a non zero solution to\r\n                \/\/ [ (x^2  + y^2 )   x    y   1 ]   [ 1 ]   [ 0 ]\r\n                \/\/ [ (xA^2 + yA^2)   xA   yA  1 ]   [ a ]   [ 0 ]\r\n                \/\/ [ (xB^2 + yB^2)   xB   yB  1 ] * [ b ] = [ 0 ]\r\n                \/\/ [ (xC^2 + yC^2)   xC   yC  1 ]   [ c ]   [ 0 ]\r\n                \/\/ So the determinant of the matrix is zero. Computing this determinant\r\n                \/\/ by expanding it using the minors m_ij of first row leads to\r\n                \/\/ (4)   m_11 (x^2 + y^2) - m_12 x + m_13 y - m_14 = 0\r\n                \/\/ So by identifying equations (2) and (4) we get the coordinates\r\n                \/\/ of center as:\r\n                \/\/ x_0 = +m_12 \/ (2 m_11)\r\n                \/\/ y_0 = -m_13 \/ (2 m_11)\r\n                \/\/ Note that the minors m_11, m_12 and m_13 all have the last column\r\n                \/\/ filled with 1.0, hence simplifying the computation\r\n                final double[] c1 = new double[] { vA.getNormSq(), vB.getNormSq(), vC.getNormSq() };\r\n                final double[] c2 = new double[] { vA.getX(), vB.getX(), vC.getX() };\r\n                final double[] c3 = new double[] { vA.getY(), vB.getY(), vC.getY() };\r\n                final double m11 = minor(c2, c3);\r\n                final double m12 = minor(c1, c3);\r\n                final double m13 = minor(c1, c2);\r\n                final Vector2D center = new Vector2D(0.5 * m12 \/ m11, -0.5 * m13 \/ m11);\r\n                return new EnclosingBall<Euclidean2D, Vector2D>(center, center.distance(vA), vA, vB, vC);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public EnclosingBall<Euclidean2D, Vector2D> ballOnSupport(final List<Vector2D> support) {\r\n    if (support.size() < 1) {\r\n        return new EnclosingBall<Euclidean2D, Vector2D>(Vector2D.ZERO, -1.0);\r\n    } else {\r\n        final Vector2D vA = support.get(0);\r\n        if (support.size() < 2) {\r\n            return new EnclosingBall<Euclidean2D, Vector2D>(vA, 0, vA);\r\n        } else {\r\n            final Vector2D vB = support.get(1);\r\n            if (support.size() < 3) {\r\n                return new EnclosingBall<Euclidean2D, Vector2D>(new Vector2D(0.5, vA, 0.5, vB), 0.5 * vA.distance(vB), vA, vB);\r\n            } else {\r\n                final Vector2D vC = support.get(2);\r\n                                                                                                                                                                                                                                                                                                                                                                final double[] c1 = new double[] { vA.getNormSq(), vB.getNormSq(), vC.getNormSq() };\r\n                final double[] c2 = new double[] { vA.getX(), vB.getX(), vC.getX() };\r\n                final double[] c3 = new double[] { vA.getY(), vB.getY(), vC.getY() };\r\n                final double m11 = minor(c2, c3);\r\n                final double m12 = minor(c1, c3);\r\n                final double m13 = minor(c1, c2);\r\n                final Vector2D center = new Vector2D(0.5 * m12 \/ m11, -0.5 * m13 \/ m11);\r\n                return new EnclosingBall<Euclidean2D, Vector2D>(center, center.distance(vA), vA, vB, vC);\r\n            }\r\n        }\r\n    }\r\n}","lc":0.5,"pi":1.0813397129,"ma":0.0,"nbd":0.5,"ml":-0.0833333333,"d":1.0436507937,"mi":-0.4725863284,"fo":1.1666666667,"r":-0.0263157895,"e":2.0361865574}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-370_495f04bc","label":3,"code":"\/**\r\n * Get the next machine representable number after a number, moving\r\n * in the direction of another number.\r\n * <p>\r\n * If <code>direction<\/code> is greater than or equal to<code>d<\/code>,\r\n * the smallest machine representable number strictly greater than\r\n * <code>d<\/code> is returned; otherwise the largest representable number\r\n * strictly less than <code>d<\/code> is returned.<\/p>\r\n * <p>\r\n * If <code>d<\/code> is NaN or Infinite, it is returned unchanged.<\/p>\r\n *\r\n * @param d base number\r\n * @param direction (the only important thing is whether\r\n * direction is greater or smaller than d)\r\n * @return the next machine representable number in the specified direction\r\n * @since 1.2\r\n * @deprecated as of 2.2, replaced by {@link FastMath#nextAfter(double, double)}\r\n *\/\r\n@Deprecated\r\npublic static double nextAfter(double d, double direction) {\r\n    return FastMath.nextAfter(d, direction);\r\n}","code_comment":"\/**\r\n * Get the next machine representable number after a number, moving\r\n * in the direction of another number.\r\n * <p>\r\n * If <code>direction<\/code> is greater than or equal to<code>d<\/code>,\r\n * the smallest machine representable number strictly greater than\r\n * <code>d<\/code> is returned; otherwise the largest representable number\r\n * strictly less than <code>d<\/code> is returned.<\/p>\r\n * <p>\r\n * If <code>d<\/code> is NaN or Infinite, it is returned unchanged.<\/p>\r\n *\r\n * @param d base number\r\n * @param direction (the only important thing is whether\r\n * direction is greater or smaller than d)\r\n * @return the next machine representable number in the specified direction\r\n * @since 1.2\r\n * @deprecated as of 2.2, replaced by {@link FastMath#nextAfter(double, double)}\r\n *\/\r\n","code_no_comment":"@Deprecated\r\npublic static double nextAfter(double d, double direction) {\r\n    return FastMath.nextAfter(d, direction);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8768146582,"fo":-0.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Closure","project_version":"81","label":2,"code":"@Override\r\nNode processFunctionNode(FunctionNode functionNode) {\r\n    Name name = functionNode.getFunctionName();\r\n    Boolean isUnnamedFunction = false;\r\n    if (name == null) {\r\n        name = new Name();\r\n        name.setIdentifier(\"\");\r\n        isUnnamedFunction = true;\r\n    }\r\n    Node node = newNode(Token.FUNCTION);\r\n    Node newName = transform(name);\r\n    if (isUnnamedFunction) {\r\n        \/\/ Old Rhino tagged the empty name node with the line number of the\r\n        \/\/ declaration.\r\n        newName.setLineno(functionNode.getLineno());\r\n        \/\/ TODO(bowdidge) Mark line number of paren correctly.\r\n        \/\/ Same problem as below - the left paren might not be on the\r\n        \/\/ same line as the function keyword.\r\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\r\n        newName.setCharno(position2charno(lpColumn));\r\n    }\r\n    node.addChildToBack(newName);\r\n    Node lp = newNode(Token.LP);\r\n    \/\/ The left paren's complicated because it's not represented by an\r\n    \/\/ AstNode, so there's nothing that has the actual line number that it\r\n    \/\/ appeared on.  We know the paren has to appear on the same line as the\r\n    \/\/ function name (or else a semicolon will be inserted.)  If there's no\r\n    \/\/ function name, assume the paren was on the same line as the function.\r\n    \/\/ TODO(bowdidge): Mark line number of paren correctly.\r\n    Name fnName = functionNode.getFunctionName();\r\n    if (fnName != null) {\r\n        lp.setLineno(fnName.getLineno());\r\n    } else {\r\n        lp.setLineno(functionNode.getLineno());\r\n    }\r\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\r\n    lp.setCharno(position2charno(lparenCharno));\r\n    for (AstNode param : functionNode.getParams()) {\r\n        lp.addChildToBack(transform(param));\r\n    }\r\n    node.addChildToBack(lp);\r\n    Node bodyNode = transform(functionNode.getBody());\r\n    parseDirectives(bodyNode);\r\n    node.addChildToBack(bodyNode);\r\n    return node;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nNode processFunctionNode(FunctionNode functionNode) {\r\n    Name name = functionNode.getFunctionName();\r\n    Boolean isUnnamedFunction = false;\r\n    if (name == null) {\r\n        name = new Name();\r\n        name.setIdentifier(\"\");\r\n        isUnnamedFunction = true;\r\n    }\r\n    Node node = newNode(Token.FUNCTION);\r\n    Node newName = transform(name);\r\n    if (isUnnamedFunction) {\r\n                        newName.setLineno(functionNode.getLineno());\r\n                                int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\r\n        newName.setCharno(position2charno(lpColumn));\r\n    }\r\n    node.addChildToBack(newName);\r\n    Node lp = newNode(Token.LP);\r\n                            Name fnName = functionNode.getFunctionName();\r\n    if (fnName != null) {\r\n        lp.setLineno(fnName.getLineno());\r\n    } else {\r\n        lp.setLineno(functionNode.getLineno());\r\n    }\r\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\r\n    lp.setCharno(position2charno(lparenCharno));\r\n    for (AstNode param : functionNode.getParams()) {\r\n        lp.addChildToBack(transform(param));\r\n    }\r\n    node.addChildToBack(lp);\r\n    Node bodyNode = transform(functionNode.getBody());\r\n    parseDirectives(bodyNode);\r\n    node.addChildToBack(bodyNode);\r\n    return node;\r\n}","lc":0.9545454545,"pi":-0.3588516746,"ma":0.2,"nbd":-0.5,"ml":0.0833333333,"d":0.6071428571,"mi":-0.6202959831,"fo":1.9166666667,"r":-0.0263157895,"e":1.2308616149}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4066_9a109aa3","label":0,"code":"\/**\r\n * close writer if it's not null\r\n *\/\r\nvoid closeWriter() throws IOException {\r\n    \/\/ in directory\r\n    if (reindex && writer == null) {\r\n        getWriter();\r\n    }\r\n    if (writer != null) {\r\n        if (log.isTraceEnabled()) {\r\n            trackIndexSizeInfo(writer, definition, directory);\r\n        }\r\n        final long start = PERF_LOGGER.start();\r\n        updateSuggester(writer.getAnalyzer());\r\n        PERF_LOGGER.end(start, -1, \"Completed suggester for directory {}\", definition);\r\n        writer.close();\r\n        PERF_LOGGER.end(start, -1, \"Closed writer for directory {}\", definition);\r\n        directory.close();\r\n        PERF_LOGGER.end(start, -1, \"Closed directory for directory {}\", definition);\r\n        \/\/ OAK-2029 Record the last updated status so\r\n        \/\/ as to make IndexTracker detect changes when index\r\n        \/\/ is stored in file system\r\n        NodeBuilder status = definitionBuilder.child(\":status\");\r\n        status.setProperty(\"lastUpdated\", ISO8601.format(getCalendar()), Type.DATE);\r\n        status.setProperty(\"indexedNodes\", indexedNodes);\r\n        PERF_LOGGER.end(start, -1, \"Overall Closed IndexWriter for directory {}\", definition);\r\n        textExtractionStats.log(reindex);\r\n        textExtractionStats.collectStats(extractedTextCache);\r\n    }\r\n}","code_comment":"\/**\r\n * close writer if it's not null\r\n *\/\r\n","code_no_comment":"void closeWriter() throws IOException {\r\n        if (reindex && writer == null) {\r\n        getWriter();\r\n    }\r\n    if (writer != null) {\r\n        if (log.isTraceEnabled()) {\r\n            trackIndexSizeInfo(writer, definition, directory);\r\n        }\r\n        final long start = PERF_LOGGER.start();\r\n        updateSuggester(writer.getAnalyzer());\r\n        PERF_LOGGER.end(start, -1, \"Completed suggester for directory {}\", definition);\r\n        writer.close();\r\n        PERF_LOGGER.end(start, -1, \"Closed writer for directory {}\", definition);\r\n        directory.close();\r\n        PERF_LOGGER.end(start, -1, \"Closed directory for directory {}\", definition);\r\n                                NodeBuilder status = definitionBuilder.child(\":status\");\r\n        status.setProperty(\"lastUpdated\", ISO8601.format(getCalendar()), Type.DATE);\r\n        status.setProperty(\"indexedNodes\", indexedNodes);\r\n        PERF_LOGGER.end(start, -1, \"Overall Closed IndexWriter for directory {}\", definition);\r\n        textExtractionStats.log(reindex);\r\n        textExtractionStats.collectStats(extractedTextCache);\r\n    }\r\n}","lc":0.4090909091,"pi":-0.1148325359,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":0.3670634921,"mi":-0.3730796335,"fo":1.0833333333,"r":-0.0263157895,"e":0.5899782738}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-305_ef9b639a","label":1,"code":"\/**\r\n * Calculates the L<sub>2<\/sub> (Euclidean) distance between two points.\r\n *\r\n * @param p1 the first point\r\n * @param p2 the second point\r\n * @return the L<sub>2<\/sub> distance between the two points\r\n *\/\r\npublic static double distance(int[] p1, int[] p2) {\r\n    int sum = 0;\r\n    for (int i = 0; i < p1.length; i++) {\r\n        final int dp = p1[i] - p2[i];\r\n        sum += dp * dp;\r\n    }\r\n    return Math.sqrt(sum);\r\n}","code_comment":"\/**\r\n * Calculates the L<sub>2<\/sub> (Euclidean) distance between two points.\r\n *\r\n * @param p1 the first point\r\n * @param p2 the second point\r\n * @return the L<sub>2<\/sub> distance between the two points\r\n *\/\r\n","code_no_comment":"public static double distance(int[] p1, int[] p2) {\r\n    int sum = 0;\r\n    for (int i = 0; i < p1.length; i++) {\r\n        final int dp = p1[i] - p2[i];\r\n        sum += dp * dp;\r\n    }\r\n    return Math.sqrt(sum);\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":0.878968254,"mi":0.3054263566,"fo":-0.4166666667,"r":1.9736842105,"e":0.2036502366}
{"project_name":"Compress","project_version":"22","label":3,"code":"private int setupNoRandPartA() throws IOException {\r\n    if (this.su_i2 <= this.last) {\r\n        this.su_chPrev = this.su_ch2;\r\n        int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\r\n        this.su_ch2 = su_ch2Shadow;\r\n        this.su_tPos = this.data.tt[this.su_tPos];\r\n        this.su_i2++;\r\n        this.currentChar = su_ch2Shadow;\r\n        this.currentState = NO_RAND_PART_B_STATE;\r\n        this.crc.updateCRC(su_ch2Shadow);\r\n        return su_ch2Shadow;\r\n    } else {\r\n        this.currentState = NO_RAND_PART_A_STATE;\r\n        endBlock();\r\n        initBlock();\r\n        return setupBlock();\r\n    }\r\n}","code_comment":null,"code_no_comment":"private int setupNoRandPartA() throws IOException {\r\n    if (this.su_i2 <= this.last) {\r\n        this.su_chPrev = this.su_ch2;\r\n        int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\r\n        this.su_ch2 = su_ch2Shadow;\r\n        this.su_tPos = this.data.tt[this.su_tPos];\r\n        this.su_i2++;\r\n        this.currentChar = su_ch2Shadow;\r\n        this.currentState = NO_RAND_PART_B_STATE;\r\n        this.crc.updateCRC(su_ch2Shadow);\r\n        return su_ch2Shadow;\r\n    } else {\r\n        this.currentState = NO_RAND_PART_A_STATE;\r\n        endBlock();\r\n        initBlock();\r\n        return setupBlock();\r\n    }\r\n}","lc":0.1818181818,"pi":-0.1339712919,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":0.2123015873,"mi":-0.1300916138,"fo":-0.1666666667,"r":-0.0263157895,"e":0.1019830224}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Returns the element at the specified index\r\n *\r\n * @param index index to fetch a value from\r\n * @return value stored at the specified index\r\n * @throws ArrayIndexOutOfBoundsException if <code>index<\/code> is less than\r\n * zero or is greater than <code>getNumElements() - 1<\/code>.\r\n *\/\r\n@Override\r\npublic synchronized double getElement(int index) {\r\n    if (index >= numElements) {\r\n        throw new ArrayIndexOutOfBoundsException(index);\r\n    } else if (index >= 0) {\r\n        return internalArray[startIndex + index];\r\n    } else {\r\n        throw new ArrayIndexOutOfBoundsException(index);\r\n    }\r\n}","code_comment":"\/**\r\n * Returns the element at the specified index\r\n *\r\n * @param index index to fetch a value from\r\n * @return value stored at the specified index\r\n * @throws ArrayIndexOutOfBoundsException if <code>index<\/code> is less than\r\n * zero or is greater than <code>getNumElements() - 1<\/code>.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic synchronized double getElement(int index) {\r\n    if (index >= numElements) {\r\n        throw new ArrayIndexOutOfBoundsException(index);\r\n    } else if (index >= 0) {\r\n        return internalArray[startIndex + index];\r\n    } else {\r\n        throw new ArrayIndexOutOfBoundsException(index);\r\n    }\r\n}","lc":-0.1818181818,"pi":0.0526315789,"ma":0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0337301587,"mi":0.28794926,"fo":-0.5,"r":0.2105263158,"e":-0.1149472981}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1300_1d635088","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic void nextBytes(byte[] bytes) {\r\n    int i = 0;\r\n    final int iEnd = bytes.length - 3;\r\n    while (i < iEnd) {\r\n        final int random = next(32);\r\n        bytes[i] = (byte) (random & 0xff);\r\n        bytes[i + 1] = (byte) ((random >> 8) & 0xff);\r\n        bytes[i + 2] = (byte) ((random >> 16) & 0xff);\r\n        bytes[i + 3] = (byte) ((random >> 24) & 0xff);\r\n        i += 4;\r\n    }\r\n    int random = next(32);\r\n    while (i < bytes.length) {\r\n        bytes[i++] = (byte) (random & 0xff);\r\n        random >>= 8;\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void nextBytes(byte[] bytes) {\r\n    int i = 0;\r\n    final int iEnd = bytes.length - 3;\r\n    while (i < iEnd) {\r\n        final int random = next(32);\r\n        bytes[i] = (byte) (random & 0xff);\r\n        bytes[i + 1] = (byte) ((random >> 8) & 0xff);\r\n        bytes[i + 2] = (byte) ((random >> 16) & 0xff);\r\n        bytes[i + 3] = (byte) ((random >> 24) & 0xff);\r\n        i += 4;\r\n    }\r\n    int random = next(32);\r\n    while (i < bytes.length) {\r\n        bytes[i++] = (byte) (random & 0xff);\r\n        random >>= 8;\r\n    }\r\n}","lc":0.1818181818,"pi":-0.033492823,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":1.7658730159,"mi":-0.2287526427,"fo":-0.3333333333,"r":0.2894736842,"e":1.6695492817}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-294_5c592d85","label":1,"code":"\/**\r\n *  @see wicket.request.target.coding.IRequestTargetUrlCodingStrategy#decode(wicket.request.RequestParameters)\r\n *\/\r\npublic IRequestTarget decode(RequestParameters requestParameters) {\r\n    String remainder = requestParameters.getPath().substring(getMountPath().length());\r\n    final String parametersFragment;\r\n    int ix = remainder.indexOf('\/', 1);\r\n    if (ix == -1) {\r\n        ix = remainder.length();\r\n        parametersFragment = \"\";\r\n    } else {\r\n        parametersFragment = remainder.substring(ix);\r\n    }\r\n    if (remainder.startsWith(\"\/\")) {\r\n        remainder = remainder.substring(1);\r\n        ix--;\r\n    }\r\n    final String bookmarkablePageClassName = packageName + \".\" + remainder.substring(0, ix);\r\n    Class bookmarkablePageClass = Session.get().getClassResolver().resolveClass(bookmarkablePageClassName);\r\n    PageParameters parameters = new PageParameters(decodeParameters(parametersFragment, requestParameters.getParameters()));\r\n    final String pageMapName = (String) parameters.remove(WebRequestCodingStrategy.PAGEMAP);\r\n    requestParameters.setPageMapName(pageMapName);\r\n    BookmarkablePageRequestTarget target = new BookmarkablePageRequestTarget(pageMapName, bookmarkablePageClass, parameters);\r\n    return target;\r\n}","code_comment":"\/**\r\n *  @see wicket.request.target.coding.IRequestTargetUrlCodingStrategy#decode(wicket.request.RequestParameters)\r\n *\/\r\n","code_no_comment":"public IRequestTarget decode(RequestParameters requestParameters) {\r\n    String remainder = requestParameters.getPath().substring(getMountPath().length());\r\n    final String parametersFragment;\r\n    int ix = remainder.indexOf('\/', 1);\r\n    if (ix == -1) {\r\n        ix = remainder.length();\r\n        parametersFragment = \"\";\r\n    } else {\r\n        parametersFragment = remainder.substring(ix);\r\n    }\r\n    if (remainder.startsWith(\"\/\")) {\r\n        remainder = remainder.substring(1);\r\n        ix--;\r\n    }\r\n    final String bookmarkablePageClassName = packageName + \".\" + remainder.substring(0, ix);\r\n    Class bookmarkablePageClass = Session.get().getClassResolver().resolveClass(bookmarkablePageClassName);\r\n    PageParameters parameters = new PageParameters(decodeParameters(parametersFragment, requestParameters.getParameters()));\r\n    final String pageMapName = (String) parameters.remove(WebRequestCodingStrategy.PAGEMAP);\r\n    requestParameters.setPageMapName(pageMapName);\r\n    BookmarkablePageRequestTarget target = new BookmarkablePageRequestTarget(pageMapName, bookmarkablePageClass, parameters);\r\n    return target;\r\n}","lc":0.3636363636,"pi":-0.3827751196,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":0.4186507937,"mi":-0.3649048626,"fo":0.9166666667,"r":-0.0263157895,"e":0.7515799058}
{"project_name":"Cli","project_version":"31","label":3,"code":"\/**\r\n * Appends the usage clause for an Option to a StringBuffer.\r\n *\r\n * @param buff the StringBuffer to append to\r\n * @param option the Option to append\r\n * @param required whether the Option is required or not\r\n *\/\r\nprivate void appendOption(final StringBuffer buff, final Option option, final boolean required) {\r\n    if (!required) {\r\n        buff.append(\"[\");\r\n    }\r\n    if (option.getOpt() != null) {\r\n        buff.append(\"-\").append(option.getOpt());\r\n    } else {\r\n        buff.append(\"--\").append(option.getLongOpt());\r\n    }\r\n    \/\/ if the Option has a value and a non blank argname\r\n    if (option.hasArg() && option.hasArgName()) {\r\n        buff.append(option.getOpt() == null ? longOptSeparator : \" \");\r\n        buff.append(\"<\").append(option.getArgName()).append(\">\");\r\n    }\r\n    \/\/ if the Option is not a required option\r\n    if (!required) {\r\n        buff.append(\"]\");\r\n    }\r\n}","code_comment":"\/**\r\n * Appends the usage clause for an Option to a StringBuffer.\r\n *\r\n * @param buff the StringBuffer to append to\r\n * @param option the Option to append\r\n * @param required whether the Option is required or not\r\n *\/\r\n","code_no_comment":"private void appendOption(final StringBuffer buff, final Option option, final boolean required) {\r\n    if (!required) {\r\n        buff.append(\"[\");\r\n    }\r\n    if (option.getOpt() != null) {\r\n        buff.append(\"-\").append(option.getOpt());\r\n    } else {\r\n        buff.append(\"--\").append(option.getLongOpt());\r\n    }\r\n        if (option.hasArg() && option.hasArgName()) {\r\n        buff.append(option.getOpt() == null ? longOptSeparator : \" \");\r\n        buff.append(\"<\").append(option.getArgName()).append(\">\");\r\n    }\r\n        if (!required) {\r\n        buff.append(\"]\");\r\n    }\r\n}","lc":0.1363636364,"pi":-0.1961722488,"ma":0.4,"nbd":-0.5,"ml":0.4166666667,"d":0.5178571429,"mi":-0.1667371388,"fo":0.9166666667,"r":-0.0263157895,"e":0.3584838897}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1153_8acedb4e","label":1,"code":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nprivate void processRemainingProperties(ComponentBuilder<?> builder, String name, Properties properties) {\r\n    while (properties.size() > 0) {\r\n        String propertyName = properties.stringPropertyNames().iterator().next();\r\n        int index = propertyName.indexOf('.');\r\n        if (index > 0) {\r\n            String prefix = propertyName.substring(0, index);\r\n            Properties componentProperties = PropertiesUtil.extractSubset(properties, prefix);\r\n            builder.addComponent(createComponent(builder, prefix, componentProperties));\r\n        } else {\r\n            builder.addAttribute(propertyName, properties.getProperty(propertyName));\r\n            properties.remove(propertyName);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nprivate void processRemainingProperties(ComponentBuilder<?> builder, String name, Properties properties) {\r\n    while (properties.size() > 0) {\r\n        String propertyName = properties.stringPropertyNames().iterator().next();\r\n        int index = propertyName.indexOf('.');\r\n        if (index > 0) {\r\n            String prefix = propertyName.substring(0, index);\r\n            Properties componentProperties = PropertiesUtil.extractSubset(properties, prefix);\r\n            builder.addComponent(createComponent(builder, prefix, componentProperties));\r\n        } else {\r\n            builder.addAttribute(propertyName, properties.getProperty(propertyName));\r\n            properties.remove(propertyName);\r\n        }\r\n    }\r\n}","lc":0.0454545455,"pi":0.6889952153,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0138888889,"mi":-0.11205074,"fo":0.5,"r":-0.0263157895,"e":0.0774836765}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2621_c849f986","label":1,"code":"\/**\r\n *  @see org.apache.wicket.Component#onRender()\r\n *\/\r\n@Override\r\nprotected void onRender() {\r\n    \/\/ Force multi-part on if any child form component is multi-part\r\n    visitFormComponents(new FormComponent.AbstractVisitor() {\r\n\r\n        @Override\r\n        public void onFormComponent(FormComponent<?> formComponent) {\r\n            if (formComponent.isVisible() && formComponent.isMultiPart()) {\r\n                setMultiPart(true);\r\n            }\r\n        }\r\n    });\r\n    super.onRender();\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.Component#onRender()\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void onRender() {\r\n        visitFormComponents(new FormComponent.AbstractVisitor() {\r\n\r\n        @Override\r\n        public void onFormComponent(FormComponent<?> formComponent) {\r\n            if (formComponent.isVisible() && formComponent.isMultiPart()) {\r\n                setMultiPart(true);\r\n            }\r\n        }\r\n    });\r\n    super.onRender();\r\n}","lc":-0.0909090909,"pi":0.971291866,"ma":-0.4,"nbd":0.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.2143763214,"fo":-0.0833333333,"r":1.0526315789,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-1205_1bdeeccc","label":1,"code":"public ArtifactResolutionResult collect(Set artifacts, Artifact originatingArtifact, Map managedVersions, ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List listeners) throws ArtifactResolutionException {\r\n    Map resolvedArtifacts = new HashMap();\r\n    ResolutionNode root = new ResolutionNode(originatingArtifact, remoteRepositories);\r\n    root.addDependencies(artifacts, remoteRepositories, filter);\r\n    recurse(root, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter, listeners);\r\n    Set set = new HashSet();\r\n    for (Iterator i = resolvedArtifacts.values().iterator(); i.hasNext(); ) {\r\n        List nodes = (List) i.next();\r\n        for (Iterator j = nodes.iterator(); j.hasNext(); ) {\r\n            ResolutionNode node = (ResolutionNode) j.next();\r\n            if (!node.equals(root) && node.isActive()) {\r\n                Artifact artifact = node.getArtifact();\r\n                if (node.filterTrail(filter)) {\r\n                    \/\/ If it was optional, we don't add it or its children, just allow the update of the version and scope\r\n                    if (!artifact.isOptional()) {\r\n                        artifact.setDependencyTrail(node.getDependencyTrail());\r\n                        set.add(node);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    ArtifactResolutionResult result = new ArtifactResolutionResult();\r\n    result.setArtifactResolutionNodes(set);\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"public ArtifactResolutionResult collect(Set artifacts, Artifact originatingArtifact, Map managedVersions, ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List listeners) throws ArtifactResolutionException {\r\n    Map resolvedArtifacts = new HashMap();\r\n    ResolutionNode root = new ResolutionNode(originatingArtifact, remoteRepositories);\r\n    root.addDependencies(artifacts, remoteRepositories, filter);\r\n    recurse(root, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter, listeners);\r\n    Set set = new HashSet();\r\n    for (Iterator i = resolvedArtifacts.values().iterator(); i.hasNext(); ) {\r\n        List nodes = (List) i.next();\r\n        for (Iterator j = nodes.iterator(); j.hasNext(); ) {\r\n            ResolutionNode node = (ResolutionNode) j.next();\r\n            if (!node.equals(root) && node.isActive()) {\r\n                Artifact artifact = node.getArtifact();\r\n                if (node.filterTrail(filter)) {\r\n                                        if (!artifact.isOptional()) {\r\n                        artifact.setDependencyTrail(node.getDependencyTrail());\r\n                        set.add(node);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    ArtifactResolutionResult result = new ArtifactResolutionResult();\r\n    result.setArtifactResolutionNodes(set);\r\n    return result;\r\n}","lc":0.5,"pi":1.985645933,"ma":0.4,"nbd":1.5,"ml":0.75,"d":0.0396825397,"mi":-0.4711768851,"fo":1.0,"r":-0.0263157895,"e":0.4111985155}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2174_5931a4a7","label":1,"code":"public ContentRepository createContentRepository() {\r\n    final List<Registration> regs = Lists.newArrayList();\r\n    regs.add(whiteboard.register(Executor.class, getExecutor(), Collections.emptyMap()));\r\n    IndexEditorProvider indexEditors = CompositeIndexEditorProvider.compose(indexEditorProviders);\r\n    OakInitializer.initialize(store, new CompositeInitializer(initializers), indexEditors);\r\n    QueryIndexProvider indexProvider = CompositeQueryIndexProvider.compose(queryIndexProviders);\r\n    List<CommitHook> initHooks = new ArrayList<CommitHook>(commitHooks);\r\n    initHooks.add(new EditorHook(CompositeEditorProvider.compose(editorProviders)));\r\n    if (asyncIndexing) {\r\n        String name = \"async\";\r\n        AsyncIndexUpdate task = new AsyncIndexUpdate(name, store, indexEditors);\r\n        regs.add(scheduleWithFixedDelay(whiteboard, task, 5, true));\r\n        regs.add(registerMBean(whiteboard, IndexStatsMBean.class, task.getIndexStats(), IndexStatsMBean.TYPE, name));\r\n        PropertyIndexAsyncReindex asyncPI = new PropertyIndexAsyncReindex(new AsyncIndexUpdate(\"async-reindex\", store, indexEditors, true), getExecutor());\r\n        regs.add(registerMBean(whiteboard, PropertyIndexAsyncReindexMBean.class, asyncPI, PropertyIndexAsyncReindexMBean.TYPE, name));\r\n    }\r\n    regs.add(registerMBean(whiteboard, QueryEngineSettingsMBean.class, queryEngineSettings, QueryEngineSettingsMBean.TYPE, \"settings\"));\r\n    \/\/ FIXME: OAK-810 move to proper workspace initialization\r\n    \/\/ initialize default workspace\r\n    Iterable<WorkspaceInitializer> workspaceInitializers = Iterables.transform(securityProvider.getConfigurations(), new Function<SecurityConfiguration, WorkspaceInitializer>() {\r\n\r\n        @Override\r\n        public WorkspaceInitializer apply(SecurityConfiguration sc) {\r\n            return sc.getWorkspaceInitializer();\r\n        }\r\n    });\r\n    OakInitializer.initialize(workspaceInitializers, store, defaultWorkspaceName, indexEditors);\r\n    \/\/ add index hooks later to prevent the OakInitializer to do excessive indexing\r\n    with(new IndexUpdateProvider(indexEditors));\r\n    withEditorHook();\r\n    \/\/ Register observer last to prevent sending events while initialising\r\n    for (Observer observer : observers) {\r\n        regs.add(registerObserver(whiteboard, observer));\r\n    }\r\n    RepositoryManager repositoryManager = new RepositoryManager(whiteboard);\r\n    regs.add(registerMBean(whiteboard, RepositoryManagementMBean.class, repositoryManager, RepositoryManagementMBean.TYPE, repositoryManager.getName()));\r\n    return new ContentRepositoryImpl(store, CompositeHook.compose(commitHooks), defaultWorkspaceName, queryEngineSettings, indexProvider, securityProvider) {\r\n\r\n        @Override\r\n        public void close() throws IOException {\r\n            super.close();\r\n            new CompositeRegistration(regs).unregister();\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"public ContentRepository createContentRepository() {\r\n    final List<Registration> regs = Lists.newArrayList();\r\n    regs.add(whiteboard.register(Executor.class, getExecutor(), Collections.emptyMap()));\r\n    IndexEditorProvider indexEditors = CompositeIndexEditorProvider.compose(indexEditorProviders);\r\n    OakInitializer.initialize(store, new CompositeInitializer(initializers), indexEditors);\r\n    QueryIndexProvider indexProvider = CompositeQueryIndexProvider.compose(queryIndexProviders);\r\n    List<CommitHook> initHooks = new ArrayList<CommitHook>(commitHooks);\r\n    initHooks.add(new EditorHook(CompositeEditorProvider.compose(editorProviders)));\r\n    if (asyncIndexing) {\r\n        String name = \"async\";\r\n        AsyncIndexUpdate task = new AsyncIndexUpdate(name, store, indexEditors);\r\n        regs.add(scheduleWithFixedDelay(whiteboard, task, 5, true));\r\n        regs.add(registerMBean(whiteboard, IndexStatsMBean.class, task.getIndexStats(), IndexStatsMBean.TYPE, name));\r\n        PropertyIndexAsyncReindex asyncPI = new PropertyIndexAsyncReindex(new AsyncIndexUpdate(\"async-reindex\", store, indexEditors, true), getExecutor());\r\n        regs.add(registerMBean(whiteboard, PropertyIndexAsyncReindexMBean.class, asyncPI, PropertyIndexAsyncReindexMBean.TYPE, name));\r\n    }\r\n    regs.add(registerMBean(whiteboard, QueryEngineSettingsMBean.class, queryEngineSettings, QueryEngineSettingsMBean.TYPE, \"settings\"));\r\n            Iterable<WorkspaceInitializer> workspaceInitializers = Iterables.transform(securityProvider.getConfigurations(), new Function<SecurityConfiguration, WorkspaceInitializer>() {\r\n\r\n        @Override\r\n        public WorkspaceInitializer apply(SecurityConfiguration sc) {\r\n            return sc.getWorkspaceInitializer();\r\n        }\r\n    });\r\n    OakInitializer.initialize(workspaceInitializers, store, defaultWorkspaceName, indexEditors);\r\n        with(new IndexUpdateProvider(indexEditors));\r\n    withEditorHook();\r\n        for (Observer observer : observers) {\r\n        regs.add(registerObserver(whiteboard, observer));\r\n    }\r\n    RepositoryManager repositoryManager = new RepositoryManager(whiteboard);\r\n    regs.add(registerMBean(whiteboard, RepositoryManagementMBean.class, repositoryManager, RepositoryManagementMBean.TYPE, repositoryManager.getName()));\r\n    return new ContentRepositoryImpl(store, CompositeHook.compose(commitHooks), defaultWorkspaceName, queryEngineSettings, indexProvider, securityProvider) {\r\n\r\n        @Override\r\n        public void close() throws IOException {\r\n            super.close();\r\n            new CompositeRegistration(regs).unregister();\r\n        }\r\n    };\r\n}","lc":1.1363636364,"pi":-0.0765550239,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":-0.7429175476,"fo":2.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7146_b6981cfd","label":3,"code":"\/**\r\n * Gets the given exchange with the correlation key\r\n *\r\n * @param camelContext   the current CamelContext\r\n * @param key            the correlation key\r\n * @return the exchange, or <tt>null<\/tt> if no exchange was previously added\r\n *\/\r\nExchange get(CamelContext camelContext, String key);","code_comment":"\/**\r\n * Gets the given exchange with the correlation key\r\n *\r\n * @param camelContext   the current CamelContext\r\n * @param key            the correlation key\r\n * @return the exchange, or <tt>null<\/tt> if no exchange was previously added\r\n *\/\r\n","code_no_comment":"Exchange get(CamelContext camelContext, String key);","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.5344608879,"fo":-0.5,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  @see wicket.model.IModel#getObject()\r\n *\/\r\npublic final Object getObject() {\r\n    if (messages == null) {\r\n        \/\/ Get filtered messages from page where component lives\r\n        List pageMessages = component.getPage().getFeedbackMessages().messages(filter);\r\n        List sessionMessages = component.getSession().getFeedbackMessages().messages(filter);\r\n        messages = new ArrayList(pageMessages.size() + sessionMessages.size());\r\n        messages.addAll(pageMessages);\r\n        messages.addAll(sessionMessages);\r\n        \/\/ Sort the list before returning it\r\n        if (sortingComparator != null) {\r\n            Collections.sort(messages, sortingComparator);\r\n        }\r\n        \/\/ Let subclass do any extra processing it wants to on the messages.\r\n        \/\/ It may want to do something special, such as removing a given\r\n        \/\/ message under some special condition or perhaps eliminate\r\n        \/\/ duplicate messages. It could even add a message under certain\r\n        \/\/ conditions.\r\n        messages = processMessages(messages);\r\n    }\r\n    return messages;\r\n}","code_comment":"\/**\r\n *  @see wicket.model.IModel#getObject()\r\n *\/\r\n","code_no_comment":"public final Object getObject() {\r\n    if (messages == null) {\r\n                List pageMessages = component.getPage().getFeedbackMessages().messages(filter);\r\n        List sessionMessages = component.getSession().getFeedbackMessages().messages(filter);\r\n        messages = new ArrayList(pageMessages.size() + sessionMessages.size());\r\n        messages.addAll(pageMessages);\r\n        messages.addAll(sessionMessages);\r\n                if (sortingComparator != null) {\r\n            Collections.sort(messages, sortingComparator);\r\n        }\r\n                                                messages = processMessages(messages);\r\n    }\r\n    return messages;\r\n}","lc":0.0,"pi":0.1387559809,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":0.4484126984,"mi":-0.0376321353,"fo":0.5,"r":-0.0263157895,"e":0.2532067795}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3013_eabb4066","label":1,"code":"@Override\r\npublic void setOffset(long offset) {\r\n    this.offset = offset;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void setOffset(long offset) {\r\n    this.offset = offset;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9292459479,"fo":-0.5,"r":1.7105263158,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-1703_b68c84b8","label":1,"code":"public static void mergePluginDefinitions(Plugin child, Plugin parent, boolean handleAsInheritance) {\r\n    if (child == null || parent == null) {\r\n        \/\/ nothing to do.\r\n        return;\r\n    }\r\n    if (parent.isExtensions()) {\r\n        child.setExtensions(true);\r\n    }\r\n    if (child.getVersion() == null && parent.getVersion() != null) {\r\n        child.setVersion(parent.getVersion());\r\n    }\r\n    Xpp3Dom childConfiguration = (Xpp3Dom) child.getConfiguration();\r\n    Xpp3Dom parentConfiguration = (Xpp3Dom) parent.getConfiguration();\r\n    childConfiguration = Xpp3Dom.mergeXpp3Dom(childConfiguration, parentConfiguration);\r\n    child.setConfiguration(childConfiguration);\r\n    \/\/ from here to the end of the method is dealing with merging of the <executions\/> section.\r\n    String parentInherited = parent.getInherited();\r\n    boolean parentIsInherited = parentInherited == null || Boolean.valueOf(parentInherited).booleanValue();\r\n    List parentExecutions = parent.getExecutions();\r\n    if (parentExecutions != null && !parentExecutions.isEmpty()) {\r\n        List mergedExecutions = new ArrayList();\r\n        Map assembledExecutions = new TreeMap();\r\n        Map childExecutions = child.getExecutionsAsMap();\r\n        for (Iterator it = parentExecutions.iterator(); it.hasNext(); ) {\r\n            PluginExecution parentExecution = (PluginExecution) it.next();\r\n            if (!handleAsInheritance || parentIsInherited) {\r\n                PluginExecution assembled = parentExecution;\r\n                PluginExecution childExecution = (PluginExecution) childExecutions.get(parentExecution.getId());\r\n                if (childExecution != null) {\r\n                    mergePluginExecutionDefinitions(childExecution, parentExecution);\r\n                    assembled = childExecution;\r\n                } else if (handleAsInheritance && parentInherited == null) {\r\n                    parentExecution.unsetInheritanceApplied();\r\n                }\r\n                assembledExecutions.put(assembled.getId(), assembled);\r\n                mergedExecutions.add(assembled);\r\n            }\r\n        }\r\n        for (Iterator it = child.getExecutions().iterator(); it.hasNext(); ) {\r\n            PluginExecution childExecution = (PluginExecution) it.next();\r\n            if (!assembledExecutions.containsKey(childExecution.getId())) {\r\n                mergedExecutions.add(childExecution);\r\n            }\r\n        }\r\n        child.setExecutions(mergedExecutions);\r\n        child.flushExecutionMap();\r\n    }\r\n}","code_comment":null,"code_no_comment":"public static void mergePluginDefinitions(Plugin child, Plugin parent, boolean handleAsInheritance) {\r\n    if (child == null || parent == null) {\r\n                return;\r\n    }\r\n    if (parent.isExtensions()) {\r\n        child.setExtensions(true);\r\n    }\r\n    if (child.getVersion() == null && parent.getVersion() != null) {\r\n        child.setVersion(parent.getVersion());\r\n    }\r\n    Xpp3Dom childConfiguration = (Xpp3Dom) child.getConfiguration();\r\n    Xpp3Dom parentConfiguration = (Xpp3Dom) parent.getConfiguration();\r\n    childConfiguration = Xpp3Dom.mergeXpp3Dom(childConfiguration, parentConfiguration);\r\n    child.setConfiguration(childConfiguration);\r\n        String parentInherited = parent.getInherited();\r\n    boolean parentIsInherited = parentInherited == null || Boolean.valueOf(parentInherited).booleanValue();\r\n    List parentExecutions = parent.getExecutions();\r\n    if (parentExecutions != null && !parentExecutions.isEmpty()) {\r\n        List mergedExecutions = new ArrayList();\r\n        Map assembledExecutions = new TreeMap();\r\n        Map childExecutions = child.getExecutionsAsMap();\r\n        for (Iterator it = parentExecutions.iterator(); it.hasNext(); ) {\r\n            PluginExecution parentExecution = (PluginExecution) it.next();\r\n            if (!handleAsInheritance || parentIsInherited) {\r\n                PluginExecution assembled = parentExecution;\r\n                PluginExecution childExecution = (PluginExecution) childExecutions.get(parentExecution.getId());\r\n                if (childExecution != null) {\r\n                    mergePluginExecutionDefinitions(childExecution, parentExecution);\r\n                    assembled = childExecution;\r\n                } else if (handleAsInheritance && parentInherited == null) {\r\n                    parentExecution.unsetInheritanceApplied();\r\n                }\r\n                assembledExecutions.put(assembled.getId(), assembled);\r\n                mergedExecutions.add(assembled);\r\n            }\r\n        }\r\n        for (Iterator it = child.getExecutions().iterator(); it.hasNext(); ) {\r\n            PluginExecution childExecution = (PluginExecution) it.next();\r\n            if (!assembledExecutions.containsKey(childExecution.getId())) {\r\n                mergedExecutions.add(childExecution);\r\n            }\r\n        }\r\n        child.setExecutions(mergedExecutions);\r\n        child.flushExecutionMap();\r\n    }\r\n}","lc":1.4545454545,"pi":1.1674641148,"ma":1.4,"nbd":1.5,"ml":2.0,"d":1.1785714286,"mi":-0.8579281184,"fo":2.4166666667,"r":-0.0263157895,"e":3.5015277514}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4383_0f3d4d24","label":1,"code":"public void validateEffectiveModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\r\n    validateStringNotEmpty(\"modelVersion\", problems, false, model.getModelVersion());\r\n    validateId(\"groupId\", problems, model.getGroupId());\r\n    validateId(\"artifactId\", problems, model.getArtifactId());\r\n    validateStringNotEmpty(\"packaging\", problems, false, model.getPackaging());\r\n    if (!model.getModules().isEmpty() && !\"pom\".equals(model.getPackaging())) {\r\n        addViolation(problems, false, \"Packaging '\" + model.getPackaging() + \"' is invalid. Aggregator projects \" + \"require 'pom' as packaging.\");\r\n    }\r\n    Parent parent = model.getParent();\r\n    if (parent != null) {\r\n        if (parent.getGroupId().equals(model.getGroupId()) && parent.getArtifactId().equals(model.getArtifactId())) {\r\n            addViolation(problems, false, \"The parent element cannot have the same ID as the project.\");\r\n        }\r\n    }\r\n    validateStringNotEmpty(\"version\", problems, false, model.getVersion());\r\n    boolean warnOnBadBoolean = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\r\n    boolean warnOnBadDependencyScope = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\r\n    for (Dependency d : model.getDependencies()) {\r\n        validateId(\"dependencies.dependency.artifactId\", problems, d.getArtifactId());\r\n        validateId(\"dependencies.dependency.groupId\", problems, d.getGroupId());\r\n        validateStringNotEmpty(\"dependencies.dependency.type\", problems, false, d.getType(), d.getManagementKey());\r\n        validateStringNotEmpty(\"dependencies.dependency.version\", problems, false, d.getVersion(), d.getManagementKey());\r\n        if (\"system\".equals(d.getScope())) {\r\n            String systemPath = d.getSystemPath();\r\n            if (StringUtils.isEmpty(systemPath)) {\r\n                addViolation(problems, false, \"For dependency \" + d + \": system-scoped dependency must specify systemPath.\");\r\n            } else {\r\n                if (!new File(systemPath).isAbsolute()) {\r\n                    addViolation(problems, false, \"For dependency \" + d + \": system-scoped dependency must \" + \"specify an absolute path systemPath.\");\r\n                }\r\n            }\r\n        } else if (StringUtils.isNotEmpty(d.getSystemPath())) {\r\n            addViolation(problems, false, \"For dependency \" + d + \": only dependency with system scope can specify systemPath.\");\r\n        }\r\n        if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\r\n            validateBoolean(\"dependencies.dependency.optional\", problems, warnOnBadBoolean, d.getOptional(), d.getManagementKey());\r\n            \/*\r\n                 * TODO: Extensions like Flex Mojos use custom scopes like \"merged\", \"internal\", \"external\", etc. In\r\n                 * order to don't break backward-compat with those, only warn but don't error our.\r\n                 *\/\r\n            validateEnum(\"dependencies.dependency.scope\", problems, true, d.getScope(), d.getManagementKey(), \"provided\", \"compile\", \"runtime\", \"test\", \"system\");\r\n        }\r\n    }\r\n    DependencyManagement mgmt = model.getDependencyManagement();\r\n    if (mgmt != null) {\r\n        for (Dependency d : mgmt.getDependencies()) {\r\n            validateSubElementStringNotEmpty(d, \"dependencyManagement.dependencies.dependency.artifactId\", problems, d.getArtifactId());\r\n            validateSubElementStringNotEmpty(d, \"dependencyManagement.dependencies.dependency.groupId\", problems, d.getGroupId());\r\n            if (\"system\".equals(d.getScope())) {\r\n                String systemPath = d.getSystemPath();\r\n                if (StringUtils.isEmpty(systemPath)) {\r\n                    addViolation(problems, false, \"For managed dependency \" + d + \": system-scoped dependency must specify systemPath.\");\r\n                } else {\r\n                    if (!new File(systemPath).isAbsolute()) {\r\n                        addViolation(problems, false, \"For managed dependency \" + d + \": system-scoped dependency must \" + \"specify an absolute path systemPath.\");\r\n                    }\r\n                }\r\n            } else if (StringUtils.isNotEmpty(d.getSystemPath())) {\r\n                addViolation(problems, false, \"For managed dependency \" + d + \": only dependency with system scope can specify systemPath.\");\r\n            }\r\n            if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\r\n                validateBoolean(\"dependencyManagement.dependencies.dependency.optional\", problems, warnOnBadBoolean, d.getOptional(), d.getManagementKey());\r\n            }\r\n        }\r\n    }\r\n    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\r\n        boolean warnOnMissingPluginVersion = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1;\r\n        Build build = model.getBuild();\r\n        if (build != null) {\r\n            for (Plugin p : build.getPlugins()) {\r\n                validateStringNotEmpty(\"build.plugins.plugin.artifactId\", problems, false, p.getArtifactId());\r\n                validateStringNotEmpty(\"build.plugins.plugin.groupId\", problems, false, p.getGroupId());\r\n                validateStringNotEmpty(\"build.plugins.plugin.version\", problems, warnOnMissingPluginVersion, p.getVersion(), p.getKey());\r\n                validateBoolean(\"build.plugins.plugin.inherited\", problems, warnOnBadBoolean, p.getInherited(), p.getKey());\r\n                validateBoolean(\"build.plugins.plugin.extensions\", problems, warnOnBadBoolean, p.getExtensions(), p.getKey());\r\n                for (Dependency d : p.getDependencies()) {\r\n                    validateEnum(\"build.plugins.plugin[\" + p.getKey() + \"].dependencies.dependency.scope\", problems, warnOnBadDependencyScope, d.getScope(), d.getManagementKey(), \"compile\", \"runtime\", \"system\");\r\n                }\r\n            }\r\n            validateResources(problems, build.getResources(), \"build.resources.resource\", request);\r\n            validateResources(problems, build.getTestResources(), \"build.testResources.testResource\", request);\r\n        }\r\n        Reporting reporting = model.getReporting();\r\n        if (reporting != null) {\r\n            for (ReportPlugin p : reporting.getPlugins()) {\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.artifactId\", problems, false, p.getArtifactId());\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.groupId\", problems, false, p.getGroupId());\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.version\", problems, warnOnMissingPluginVersion, p.getVersion(), p.getKey());\r\n            }\r\n        }\r\n        forcePluginExecutionIdCollision(model, problems);\r\n        for (Repository repository : model.getRepositories()) {\r\n            validateRepositoryLayout(problems, repository, \"repositories.repository\", request);\r\n        }\r\n        for (Repository repository : model.getPluginRepositories()) {\r\n            validateRepositoryLayout(problems, repository, \"pluginRepositories.pluginRepository\", request);\r\n        }\r\n        DistributionManagement distMgmt = model.getDistributionManagement();\r\n        if (distMgmt != null) {\r\n            validateRepositoryLayout(problems, distMgmt.getRepository(), \"distributionManagement.repository\", request);\r\n            validateRepositoryLayout(problems, distMgmt.getSnapshotRepository(), \"distributionManagement.snapshotRepository\", request);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void validateEffectiveModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\r\n    validateStringNotEmpty(\"modelVersion\", problems, false, model.getModelVersion());\r\n    validateId(\"groupId\", problems, model.getGroupId());\r\n    validateId(\"artifactId\", problems, model.getArtifactId());\r\n    validateStringNotEmpty(\"packaging\", problems, false, model.getPackaging());\r\n    if (!model.getModules().isEmpty() && !\"pom\".equals(model.getPackaging())) {\r\n        addViolation(problems, false, \"Packaging '\" + model.getPackaging() + \"' is invalid. Aggregator projects \" + \"require 'pom' as packaging.\");\r\n    }\r\n    Parent parent = model.getParent();\r\n    if (parent != null) {\r\n        if (parent.getGroupId().equals(model.getGroupId()) && parent.getArtifactId().equals(model.getArtifactId())) {\r\n            addViolation(problems, false, \"The parent element cannot have the same ID as the project.\");\r\n        }\r\n    }\r\n    validateStringNotEmpty(\"version\", problems, false, model.getVersion());\r\n    boolean warnOnBadBoolean = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\r\n    boolean warnOnBadDependencyScope = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\r\n    for (Dependency d : model.getDependencies()) {\r\n        validateId(\"dependencies.dependency.artifactId\", problems, d.getArtifactId());\r\n        validateId(\"dependencies.dependency.groupId\", problems, d.getGroupId());\r\n        validateStringNotEmpty(\"dependencies.dependency.type\", problems, false, d.getType(), d.getManagementKey());\r\n        validateStringNotEmpty(\"dependencies.dependency.version\", problems, false, d.getVersion(), d.getManagementKey());\r\n        if (\"system\".equals(d.getScope())) {\r\n            String systemPath = d.getSystemPath();\r\n            if (StringUtils.isEmpty(systemPath)) {\r\n                addViolation(problems, false, \"For dependency \" + d + \": system-scoped dependency must specify systemPath.\");\r\n            } else {\r\n                if (!new File(systemPath).isAbsolute()) {\r\n                    addViolation(problems, false, \"For dependency \" + d + \": system-scoped dependency must \" + \"specify an absolute path systemPath.\");\r\n                }\r\n            }\r\n        } else if (StringUtils.isNotEmpty(d.getSystemPath())) {\r\n            addViolation(problems, false, \"For dependency \" + d + \": only dependency with system scope can specify systemPath.\");\r\n        }\r\n        if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\r\n            validateBoolean(\"dependencies.dependency.optional\", problems, warnOnBadBoolean, d.getOptional(), d.getManagementKey());\r\n                        validateEnum(\"dependencies.dependency.scope\", problems, true, d.getScope(), d.getManagementKey(), \"provided\", \"compile\", \"runtime\", \"test\", \"system\");\r\n        }\r\n    }\r\n    DependencyManagement mgmt = model.getDependencyManagement();\r\n    if (mgmt != null) {\r\n        for (Dependency d : mgmt.getDependencies()) {\r\n            validateSubElementStringNotEmpty(d, \"dependencyManagement.dependencies.dependency.artifactId\", problems, d.getArtifactId());\r\n            validateSubElementStringNotEmpty(d, \"dependencyManagement.dependencies.dependency.groupId\", problems, d.getGroupId());\r\n            if (\"system\".equals(d.getScope())) {\r\n                String systemPath = d.getSystemPath();\r\n                if (StringUtils.isEmpty(systemPath)) {\r\n                    addViolation(problems, false, \"For managed dependency \" + d + \": system-scoped dependency must specify systemPath.\");\r\n                } else {\r\n                    if (!new File(systemPath).isAbsolute()) {\r\n                        addViolation(problems, false, \"For managed dependency \" + d + \": system-scoped dependency must \" + \"specify an absolute path systemPath.\");\r\n                    }\r\n                }\r\n            } else if (StringUtils.isNotEmpty(d.getSystemPath())) {\r\n                addViolation(problems, false, \"For managed dependency \" + d + \": only dependency with system scope can specify systemPath.\");\r\n            }\r\n            if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\r\n                validateBoolean(\"dependencyManagement.dependencies.dependency.optional\", problems, warnOnBadBoolean, d.getOptional(), d.getManagementKey());\r\n            }\r\n        }\r\n    }\r\n    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\r\n        boolean warnOnMissingPluginVersion = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1;\r\n        Build build = model.getBuild();\r\n        if (build != null) {\r\n            for (Plugin p : build.getPlugins()) {\r\n                validateStringNotEmpty(\"build.plugins.plugin.artifactId\", problems, false, p.getArtifactId());\r\n                validateStringNotEmpty(\"build.plugins.plugin.groupId\", problems, false, p.getGroupId());\r\n                validateStringNotEmpty(\"build.plugins.plugin.version\", problems, warnOnMissingPluginVersion, p.getVersion(), p.getKey());\r\n                validateBoolean(\"build.plugins.plugin.inherited\", problems, warnOnBadBoolean, p.getInherited(), p.getKey());\r\n                validateBoolean(\"build.plugins.plugin.extensions\", problems, warnOnBadBoolean, p.getExtensions(), p.getKey());\r\n                for (Dependency d : p.getDependencies()) {\r\n                    validateEnum(\"build.plugins.plugin[\" + p.getKey() + \"].dependencies.dependency.scope\", problems, warnOnBadDependencyScope, d.getScope(), d.getManagementKey(), \"compile\", \"runtime\", \"system\");\r\n                }\r\n            }\r\n            validateResources(problems, build.getResources(), \"build.resources.resource\", request);\r\n            validateResources(problems, build.getTestResources(), \"build.testResources.testResource\", request);\r\n        }\r\n        Reporting reporting = model.getReporting();\r\n        if (reporting != null) {\r\n            for (ReportPlugin p : reporting.getPlugins()) {\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.artifactId\", problems, false, p.getArtifactId());\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.groupId\", problems, false, p.getGroupId());\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.version\", problems, warnOnMissingPluginVersion, p.getVersion(), p.getKey());\r\n            }\r\n        }\r\n        forcePluginExecutionIdCollision(model, problems);\r\n        for (Repository repository : model.getRepositories()) {\r\n            validateRepositoryLayout(problems, repository, \"repositories.repository\", request);\r\n        }\r\n        for (Repository repository : model.getPluginRepositories()) {\r\n            validateRepositoryLayout(problems, repository, \"pluginRepositories.pluginRepository\", request);\r\n        }\r\n        DistributionManagement distMgmt = model.getDistributionManagement();\r\n        if (distMgmt != null) {\r\n            validateRepositoryLayout(problems, distMgmt.getRepository(), \"distributionManagement.repository\", request);\r\n            validateRepositoryLayout(problems, distMgmt.getSnapshotRepository(), \"distributionManagement.snapshotRepository\", request);\r\n        }\r\n    }\r\n}","lc":3.9090909091,"pi":0.9473684211,"ma":4.4,"nbd":1.5,"ml":2.9166666667,"d":1.5297619048,"mi":-1.4699083862,"fo":9.4166666667,"r":-0.0263157895,"e":13.2697682728}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1168_c05cec12","label":3,"code":"\/**\r\n * Checks if the given path needs to be fully parsed to apply namespace\r\n * mappings or to validate its syntax. If the given path is \"simple\", i.e.\r\n * it doesn't contain any complex constructs, and there are no local\r\n * namespace remappings, it's possible to skip the full path parsing\r\n * and simply use the JCR path string as-is as an Oak path.\r\n *\r\n * @param path JCR path\r\n * @return {@code true} if the path needs to be fully parsed,\r\n *         {@code false} if not\r\n *\/\r\nprivate boolean needsFullMapping(String path) {\r\n    int length = path.length();\r\n    if (length == 0) {\r\n        return true;\r\n    }\r\n    \/\/ index of the last slash in the path\r\n    int slash = -1;\r\n    \/\/ index of the last colon in the path\r\n    int colon = -1;\r\n    switch(path.charAt(0)) {\r\n        \/\/ possibly an expanded name\r\n        case '{':\r\n        \/\/ starts with an identifier\r\n        case '[':\r\n        \/\/ possibly \".\" or \"..\"\r\n        case '.':\r\n        case \/\/ colon as the first character\r\n        ':':\r\n            return true;\r\n        case '\/':\r\n            if (length == 1) {\r\n                \/\/ the root path\r\n                return false;\r\n            }\r\n            slash = 0;\r\n            break;\r\n    }\r\n    for (int i = 1; i < length; i++) {\r\n        switch(path.charAt(i)) {\r\n            \/\/ possibly an expanded name\r\n            case '{':\r\n            case \/\/ possibly an index\r\n            '[':\r\n                return true;\r\n            case '.':\r\n                if (i == slash + 1) {\r\n                    \/\/ possibly \".\" or \"..\"\r\n                    return true;\r\n                }\r\n                break;\r\n            case ':':\r\n                if (\/\/ \"x\/:y\"\r\n                i == slash + 1 || \/\/ \"x::y\"\r\n                i == colon + i || \/\/ \"x:y:z\"\r\n                colon > slash || i + 1 == length) {\r\n                    \/\/ \"x:\"\r\n                    return true;\r\n                }\r\n                colon = i;\r\n                break;\r\n            case '\/':\r\n                if (\/\/ \"x\/\/y\"\r\n                i == slash + 1 || \/\/ \"x:\/y\"\r\n                i == colon + i || i + 1 == length) {\r\n                    \/\/ \"x\/\"\r\n                    return true;\r\n                }\r\n                slash = i;\r\n                break;\r\n        }\r\n    }\r\n    return colon != -1 && !nameMapper.getSessionLocalMappings().isEmpty();\r\n}","code_comment":"\/**\r\n * Checks if the given path needs to be fully parsed to apply namespace\r\n * mappings or to validate its syntax. If the given path is \"simple\", i.e.\r\n * it doesn't contain any complex constructs, and there are no local\r\n * namespace remappings, it's possible to skip the full path parsing\r\n * and simply use the JCR path string as-is as an Oak path.\r\n *\r\n * @param path JCR path\r\n * @return {@code true} if the path needs to be fully parsed,\r\n *         {@code false} if not\r\n *\/\r\n","code_no_comment":"private boolean needsFullMapping(String path) {\r\n    int length = path.length();\r\n    if (length == 0) {\r\n        return true;\r\n    }\r\n        int slash = -1;\r\n        int colon = -1;\r\n    switch(path.charAt(0)) {\r\n                case '{':\r\n                case '[':\r\n                case '.':\r\n        case         ':':\r\n            return true;\r\n        case '\/':\r\n            if (length == 1) {\r\n                                return false;\r\n            }\r\n            slash = 0;\r\n            break;\r\n    }\r\n    for (int i = 1; i < length; i++) {\r\n        switch(path.charAt(i)) {\r\n                        case '{':\r\n            case             '[':\r\n                return true;\r\n            case '.':\r\n                if (i == slash + 1) {\r\n                                        return true;\r\n                }\r\n                break;\r\n            case ':':\r\n                if (                i == slash + 1 ||                 i == colon + i ||                 colon > slash || i + 1 == length) {\r\n                                        return true;\r\n                }\r\n                colon = i;\r\n                break;\r\n            case '\/':\r\n                if (                i == slash + 1 ||                 i == colon + i || i + 1 == length) {\r\n                                        return true;\r\n                }\r\n                slash = i;\r\n                break;\r\n        }\r\n    }\r\n    return colon != -1 && !nameMapper.getSessionLocalMappings().isEmpty();\r\n}","lc":1.7727272727,"pi":1.1291866029,"ma":3.4,"nbd":1.0,"ml":1.8333333333,"d":3.2718253968,"mi":-0.9019027484,"fo":-0.0833333333,"r":-0.0263157895,"e":4.6550117276}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1203_4aa4c6d3","label":1,"code":"\/**\r\n * The within-bin smoothing kernel. Returns a Gaussian distribution\r\n * parameterized by {@code bStats}, unless the bin contains only one\r\n * observation, in which case a constant distribution is returned.\r\n *\r\n * @param bStats summary statistics for the bin\r\n * @return within-bin kernel parameterized by bStats\r\n *\/\r\nprotected RealDistribution getKernel(SummaryStatistics bStats) {\r\n    if (bStats.getN() == 1) {\r\n        return new ConstantRealDistribution(bStats.getMean());\r\n    } else {\r\n        return new NormalDistribution(randomData.getRandomGenerator(), bStats.getMean(), bStats.getStandardDeviation(), NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\r\n    }\r\n}","code_comment":"\/**\r\n * The within-bin smoothing kernel. Returns a Gaussian distribution\r\n * parameterized by {@code bStats}, unless the bin contains only one\r\n * observation, in which case a constant distribution is returned.\r\n *\r\n * @param bStats summary statistics for the bin\r\n * @return within-bin kernel parameterized by bStats\r\n *\/\r\n","code_no_comment":"protected RealDistribution getKernel(SummaryStatistics bStats) {\r\n    if (bStats.getN() == 1) {\r\n        return new ConstantRealDistribution(bStats.getMean());\r\n    } else {\r\n        return new NormalDistribution(randomData.getRandomGenerator(), bStats.getMean(), bStats.getStandardDeviation(), NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\r\n    }\r\n}","lc":-0.3181818182,"pi":0.014354067,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.4300211416,"fo":-0.0833333333,"r":0.1578947368,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1208_ce2badf0","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\r\n * <p>Algorithm description:<ol>\r\n * <li>Find the bin B that x belongs to.<\/li>\r\n * <li>Compute P(B) = the mass of B and P(B-) = the combined mass of the bins below B.<\/li>\r\n * <li>Compute K(B) = the probability mass of B with respect to the within-bin kernel\r\n * and K(B-) = the kernel distribution evaluated at the lower endpoint of B<\/li>\r\n * <li>Return P(B-) + P(B) * [K(x) - K(B-)] \/ K(B) where\r\n * K(x) is the within-bin kernel distribution function evaluated at x.<\/li><\/ol>\r\n * If K is a constant distribution, we return P(B-) + P(B) (counting the full\r\n * mass of B).<\/p>\r\n *\r\n * @since 3.1\r\n *\/\r\npublic double cumulativeProbability(double x) {\r\n    if (x < min) {\r\n        return 0d;\r\n    } else if (x >= max) {\r\n        return 1d;\r\n    }\r\n    final int binIndex = findBin(x);\r\n    final double pBminus = pBminus(binIndex);\r\n    final double pB = pB(binIndex);\r\n    final RealDistribution kernel = k(x);\r\n    if (kernel instanceof ConstantRealDistribution) {\r\n        return pBminus + pB;\r\n    }\r\n    final double[] binBounds = getUpperBounds();\r\n    final double kB = kB(binIndex);\r\n    final double lower = binIndex == 0 ? min : binBounds[binIndex - 1];\r\n    final double withinBinCum = (kernel.cumulativeProbability(x) - kernel.cumulativeProbability(lower)) \/ kB;\r\n    return pBminus + pB * withinBinCum;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\r\n * <p>Algorithm description:<ol>\r\n * <li>Find the bin B that x belongs to.<\/li>\r\n * <li>Compute P(B) = the mass of B and P(B-) = the combined mass of the bins below B.<\/li>\r\n * <li>Compute K(B) = the probability mass of B with respect to the within-bin kernel\r\n * and K(B-) = the kernel distribution evaluated at the lower endpoint of B<\/li>\r\n * <li>Return P(B-) + P(B) * [K(x) - K(B-)] \/ K(B) where\r\n * K(x) is the within-bin kernel distribution function evaluated at x.<\/li><\/ol>\r\n * If K is a constant distribution, we return P(B-) + P(B) (counting the full\r\n * mass of B).<\/p>\r\n *\r\n * @since 3.1\r\n *\/\r\n","code_no_comment":"public double cumulativeProbability(double x) {\r\n    if (x < min) {\r\n        return 0d;\r\n    } else if (x >= max) {\r\n        return 1d;\r\n    }\r\n    final int binIndex = findBin(x);\r\n    final double pBminus = pBminus(binIndex);\r\n    final double pB = pB(binIndex);\r\n    final RealDistribution kernel = k(x);\r\n    if (kernel instanceof ConstantRealDistribution) {\r\n        return pBminus + pB;\r\n    }\r\n    final double[] binBounds = getUpperBounds();\r\n    final double kB = kB(binIndex);\r\n    final double lower = binIndex == 0 ? min : binBounds[binIndex - 1];\r\n    final double withinBinCum = (kernel.cumulativeProbability(x) - kernel.cumulativeProbability(lower)) \/ kB;\r\n    return pBminus + pB * withinBinCum;\r\n}","lc":0.2272727273,"pi":-0.4545454545,"ma":0.2,"nbd":0.0,"ml":0.3333333333,"d":1.4027777778,"mi":-0.2467935166,"fo":0.1666666667,"r":0.0263157895,"e":1.1674048973}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1153_8acedb4e","label":1,"code":"@Override\r\npublic PropertiesConfiguration getConfiguration(ConfigurationSource source) {\r\n    final InputStream configStream = source.getInputStream();\r\n    Properties properties = new Properties();\r\n    try {\r\n        properties.load(configStream);\r\n    } catch (IOException ioe) {\r\n        throw new ConfigurationException(\"Unable to load \" + source.toString(), ioe);\r\n    }\r\n    ConfigurationBuilder<PropertiesConfiguration> builder = newConfigurationBuilder(PropertiesConfiguration.class);\r\n    String value = properties.getProperty(STATUS_KEY);\r\n    if (value != null) {\r\n        builder.setStatusLevel(Level.toLevel(value, Level.ERROR));\r\n    } else {\r\n        builder.setStatusLevel(Level.ERROR);\r\n    }\r\n    value = properties.getProperty(SHUTDOWN_HOOK);\r\n    if (value != null) {\r\n        builder.setShutdownHook(value);\r\n    }\r\n    value = properties.getProperty(VERBOSE);\r\n    if (value != null) {\r\n        builder.setVerbosity(value);\r\n    }\r\n    value = properties.getProperty(PACKAGES);\r\n    if (value != null) {\r\n        builder.setPackages(value);\r\n    }\r\n    value = properties.getProperty(CONFIG_NAME);\r\n    if (value != null) {\r\n        builder.setConfigurationName(value);\r\n    }\r\n    value = properties.getProperty(MONITOR_INTERVAL);\r\n    if (value != null) {\r\n        builder.setMonitorInterval(value);\r\n    }\r\n    value = properties.getProperty(ADVERTISER_KEY);\r\n    if (value != null) {\r\n        builder.setAdvertiser(value);\r\n    }\r\n    Properties props = PropertiesUtil.extractSubset(properties, \"property\");\r\n    for (String key : props.stringPropertyNames()) {\r\n        builder.addProperty(key, props.getProperty(key));\r\n    }\r\n    String scriptProp = properties.getProperty(\"scripts\");\r\n    if (scriptProp != null) {\r\n        String[] scriptNames = scriptProp.split(\",\");\r\n        for (String scriptName : scriptNames) {\r\n            String name = scriptName.trim();\r\n            Properties scriptProps = PropertiesUtil.extractSubset(properties, \"script.\" + name);\r\n            String type = scriptProps.getProperty(\"type\");\r\n            if (type == null) {\r\n                throw new ConfigurationException(\"No type provided for script - must be Script or ScriptFile\");\r\n            }\r\n            scriptProps.remove(\"type\");\r\n            if (type.equalsIgnoreCase(\"script\")) {\r\n                builder.add(createScript(builder, name, scriptProps));\r\n            } else {\r\n                builder.add(createScriptFile(builder, name, scriptProps));\r\n            }\r\n        }\r\n    }\r\n    Properties levelProps = PropertiesUtil.extractSubset(properties, \"customLevel\");\r\n    if (levelProps.size() > 0) {\r\n        for (String key : levelProps.stringPropertyNames()) {\r\n            builder.add(builder.newCustomLevel(key, Integer.parseInt(props.getProperty(key))));\r\n        }\r\n    }\r\n    String filterProp = properties.getProperty(\"filters\");\r\n    if (filterProp != null) {\r\n        String[] filterNames = filterProp.split(\",\");\r\n        for (String filterName : filterNames) {\r\n            String name = filterName.trim();\r\n            builder.add(createFilter(builder, name, PropertiesUtil.extractSubset(properties, \"filter.\" + name)));\r\n        }\r\n    }\r\n    String appenderProp = properties.getProperty(\"appenders\");\r\n    if (appenderProp != null) {\r\n        String[] appenderNames = appenderProp.split(\",\");\r\n        for (String appenderName : appenderNames) {\r\n            String name = appenderName.trim();\r\n            builder.add(createAppender(builder, name, PropertiesUtil.extractSubset(properties, \"appender.\" + name)));\r\n        }\r\n    }\r\n    String loggerProp = properties.getProperty(\"loggers\");\r\n    if (appenderProp != null) {\r\n        String[] loggerNames = loggerProp.split(\",\");\r\n        for (String loggerName : loggerNames) {\r\n            String name = loggerName.trim();\r\n            if (!name.equals(LoggerConfig.ROOT)) {\r\n                builder.add(createLogger(builder, name, PropertiesUtil.extractSubset(properties, \"logger.\" + name)));\r\n            }\r\n        }\r\n    }\r\n    props = PropertiesUtil.extractSubset(properties, \"rootLogger\");\r\n    if (props.size() > 0) {\r\n        builder.add(createRootLogger(builder, props));\r\n    }\r\n    return builder.build();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic PropertiesConfiguration getConfiguration(ConfigurationSource source) {\r\n    final InputStream configStream = source.getInputStream();\r\n    Properties properties = new Properties();\r\n    try {\r\n        properties.load(configStream);\r\n    } catch (IOException ioe) {\r\n        throw new ConfigurationException(\"Unable to load \" + source.toString(), ioe);\r\n    }\r\n    ConfigurationBuilder<PropertiesConfiguration> builder = newConfigurationBuilder(PropertiesConfiguration.class);\r\n    String value = properties.getProperty(STATUS_KEY);\r\n    if (value != null) {\r\n        builder.setStatusLevel(Level.toLevel(value, Level.ERROR));\r\n    } else {\r\n        builder.setStatusLevel(Level.ERROR);\r\n    }\r\n    value = properties.getProperty(SHUTDOWN_HOOK);\r\n    if (value != null) {\r\n        builder.setShutdownHook(value);\r\n    }\r\n    value = properties.getProperty(VERBOSE);\r\n    if (value != null) {\r\n        builder.setVerbosity(value);\r\n    }\r\n    value = properties.getProperty(PACKAGES);\r\n    if (value != null) {\r\n        builder.setPackages(value);\r\n    }\r\n    value = properties.getProperty(CONFIG_NAME);\r\n    if (value != null) {\r\n        builder.setConfigurationName(value);\r\n    }\r\n    value = properties.getProperty(MONITOR_INTERVAL);\r\n    if (value != null) {\r\n        builder.setMonitorInterval(value);\r\n    }\r\n    value = properties.getProperty(ADVERTISER_KEY);\r\n    if (value != null) {\r\n        builder.setAdvertiser(value);\r\n    }\r\n    Properties props = PropertiesUtil.extractSubset(properties, \"property\");\r\n    for (String key : props.stringPropertyNames()) {\r\n        builder.addProperty(key, props.getProperty(key));\r\n    }\r\n    String scriptProp = properties.getProperty(\"scripts\");\r\n    if (scriptProp != null) {\r\n        String[] scriptNames = scriptProp.split(\",\");\r\n        for (String scriptName : scriptNames) {\r\n            String name = scriptName.trim();\r\n            Properties scriptProps = PropertiesUtil.extractSubset(properties, \"script.\" + name);\r\n            String type = scriptProps.getProperty(\"type\");\r\n            if (type == null) {\r\n                throw new ConfigurationException(\"No type provided for script - must be Script or ScriptFile\");\r\n            }\r\n            scriptProps.remove(\"type\");\r\n            if (type.equalsIgnoreCase(\"script\")) {\r\n                builder.add(createScript(builder, name, scriptProps));\r\n            } else {\r\n                builder.add(createScriptFile(builder, name, scriptProps));\r\n            }\r\n        }\r\n    }\r\n    Properties levelProps = PropertiesUtil.extractSubset(properties, \"customLevel\");\r\n    if (levelProps.size() > 0) {\r\n        for (String key : levelProps.stringPropertyNames()) {\r\n            builder.add(builder.newCustomLevel(key, Integer.parseInt(props.getProperty(key))));\r\n        }\r\n    }\r\n    String filterProp = properties.getProperty(\"filters\");\r\n    if (filterProp != null) {\r\n        String[] filterNames = filterProp.split(\",\");\r\n        for (String filterName : filterNames) {\r\n            String name = filterName.trim();\r\n            builder.add(createFilter(builder, name, PropertiesUtil.extractSubset(properties, \"filter.\" + name)));\r\n        }\r\n    }\r\n    String appenderProp = properties.getProperty(\"appenders\");\r\n    if (appenderProp != null) {\r\n        String[] appenderNames = appenderProp.split(\",\");\r\n        for (String appenderName : appenderNames) {\r\n            String name = appenderName.trim();\r\n            builder.add(createAppender(builder, name, PropertiesUtil.extractSubset(properties, \"appender.\" + name)));\r\n        }\r\n    }\r\n    String loggerProp = properties.getProperty(\"loggers\");\r\n    if (appenderProp != null) {\r\n        String[] loggerNames = loggerProp.split(\",\");\r\n        for (String loggerName : loggerNames) {\r\n            String name = loggerName.trim();\r\n            if (!name.equals(LoggerConfig.ROOT)) {\r\n                builder.add(createLogger(builder, name, PropertiesUtil.extractSubset(properties, \"logger.\" + name)));\r\n            }\r\n        }\r\n    }\r\n    props = PropertiesUtil.extractSubset(properties, \"rootLogger\");\r\n    if (props.size() > 0) {\r\n        builder.add(createRootLogger(builder, props));\r\n    }\r\n    return builder.build();\r\n}","lc":3.9090909091,"pi":0.3397129187,"ma":4.4,"nbd":0.5,"ml":1.6666666667,"d":1.4642857143,"mi":-1.4290345314,"fo":5.0,"r":-0.0263157895,"e":9.6392501282}
{"project_name":"Math","project_version":"14","label":0,"code":"\/**\r\n * Computes the square-root of the weight matrix.\r\n *\r\n * @param m Symmetric, positive-definite (weight) matrix.\r\n * @return the square-root of the weight matrix.\r\n *\/\r\nprivate RealMatrix squareRoot(RealMatrix m) {\r\n    final EigenDecomposition dec = new EigenDecomposition(m);\r\n    return dec.getSquareRoot();\r\n}","code_comment":"\/**\r\n * Computes the square-root of the weight matrix.\r\n *\r\n * @param m Symmetric, positive-definite (weight) matrix.\r\n * @return the square-root of the weight matrix.\r\n *\/\r\n","code_no_comment":"private RealMatrix squareRoot(RealMatrix m) {\r\n    final EigenDecomposition dec = new EigenDecomposition(m);\r\n    return dec.getSquareRoot();\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8128259338,"fo":-0.4166666667,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3847_de9399f3","label":3,"code":"public void addTypeConverter(Class<?> toType, Class<?> fromType, TypeConverter typeConverter) {\r\n    log.trace(\"Adding type converter: {}\", typeConverter);\r\n    TypeMapping key = new TypeMapping(toType, fromType);\r\n    synchronized (typeMappings) {\r\n        TypeConverter converter = typeMappings.get(key);\r\n        \/\/ as race conditions can lead to many threads trying to promote the same fallback converter\r\n        if (typeConverter != converter) {\r\n            if (converter != null) {\r\n                log.warn(\"Overriding type converter from: \" + converter + \" to: \" + typeConverter);\r\n            }\r\n            typeMappings.put(key, typeConverter);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void addTypeConverter(Class<?> toType, Class<?> fromType, TypeConverter typeConverter) {\r\n    log.trace(\"Adding type converter: {}\", typeConverter);\r\n    TypeMapping key = new TypeMapping(toType, fromType);\r\n    synchronized (typeMappings) {\r\n        TypeConverter converter = typeMappings.get(key);\r\n                if (typeConverter != converter) {\r\n            if (converter != null) {\r\n                log.warn(\"Overriding type converter from: \" + converter + \" to: \" + typeConverter);\r\n            }\r\n            typeMappings.put(key, typeConverter);\r\n        }\r\n    }\r\n}","lc":-0.0454545455,"pi":0.8421052632,"ma":-0.2,"nbd":0.5,"ml":-0.0833333333,"d":0.001984127,"mi":0.0176180409,"fo":-0.1666666667,"r":0.0,"e":-0.0007491802}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2109_d594d024","label":1,"code":"\/**\r\n *  The core work method that bootstraps the task and executes it code\r\n *\/\r\n@Override\r\npublic void run() {\r\n    \/\/ ----------------------------\r\n    while (true) {\r\n        ExecutionState current = this.executionState;\r\n        if (current == ExecutionState.CREATED) {\r\n            if (STATE_UPDATER.compareAndSet(this, ExecutionState.CREATED, ExecutionState.DEPLOYING)) {\r\n                \/\/ success, we can start our work\r\n                break;\r\n            }\r\n        } else if (current == ExecutionState.FAILED) {\r\n            \/\/ we were immediately failed. tell the TaskManager that we reached our final state\r\n            notifyFinalState();\r\n            return;\r\n        } else if (current == ExecutionState.CANCELING) {\r\n            if (STATE_UPDATER.compareAndSet(this, ExecutionState.CANCELING, ExecutionState.CANCELED)) {\r\n                \/\/ we were immediately canceled. tell the TaskManager that we reached our final state\r\n                notifyFinalState();\r\n                return;\r\n            }\r\n        } else {\r\n            throw new IllegalStateException(\"Invalid state for beginning of task operation\");\r\n        }\r\n    }\r\n    \/\/ all resource acquisitions and registrations from here on\r\n    \/\/ need to be undone in the end\r\n    Map<String, Future<Path>> distributedCacheEntries = new HashMap<String, Future<Path>>();\r\n    AbstractInvokable invokable = null;\r\n    try {\r\n        \/\/ ----------------------------\r\n        \/\/ Task Bootstrap - We periodically\r\n        \/\/ check for canceling as a shortcut\r\n        \/\/ ----------------------------\r\n        \/\/ first of all, get a user-code classloader\r\n        \/\/ this may involve downloading the job's JAR files and\/or classes\r\n        LOG.info(\"Loading JAR files for task \" + taskNameWithSubtask);\r\n        final ClassLoader userCodeClassLoader = createUserCodeClassloader(libraryCache);\r\n        \/\/ now load the task's invokable code\r\n        invokable = loadAndInstantiateInvokable(userCodeClassLoader, nameOfInvokableClass);\r\n        if (isCanceledOrFailed()) {\r\n            throw new CancelTaskException();\r\n        }\r\n        \/\/ ----------------------------------------------------------------\r\n        \/\/ register the task with the network stack\r\n        \/\/ this operation may fail if the system does not have enough\r\n        \/\/ memory to run the necessary data exchanges\r\n        \/\/ the registration must also strictly be undone\r\n        \/\/ ----------------------------------------------------------------\r\n        LOG.info(\"Registering task at network: \" + this);\r\n        network.registerTask(this);\r\n        \/\/ next, kick off the background copying of files for the distributed cache\r\n        try {\r\n            for (Map.Entry<String, DistributedCache.DistributedCacheEntry> entry : DistributedCache.readFileInfoFromConfig(jobConfiguration)) {\r\n                LOG.info(\"Obtaining local cache file for '\" + entry.getKey() + '\\'');\r\n                Future<Path> cp = fileCache.createTmpFile(entry.getKey(), entry.getValue(), jobId);\r\n                distributedCacheEntries.put(entry.getKey(), cp);\r\n            }\r\n        } catch (Exception e) {\r\n            throw new Exception(\"Exception while adding files to distributed cache.\", e);\r\n        }\r\n        if (isCanceledOrFailed()) {\r\n            throw new CancelTaskException();\r\n        }\r\n        \/\/ ----------------------------------------------------------------\r\n        \/\/ call the user code initialization methods\r\n        \/\/ ----------------------------------------------------------------\r\n        TaskInputSplitProvider splitProvider = new TaskInputSplitProvider(jobManager, jobId, vertexId, executionId, userCodeClassLoader, actorAskTimeout);\r\n        Environment env = new RuntimeEnvironment(jobId, vertexId, executionId, taskName, taskNameWithSubtask, subtaskIndex, parallelism, jobConfiguration, taskConfiguration, userCodeClassLoader, memoryManager, ioManager, broadcastVariableManager, splitProvider, distributedCacheEntries, writers, inputGates, jobManager);\r\n        \/\/ let the task code create its readers and writers\r\n        invokable.setEnvironment(env);\r\n        try {\r\n            invokable.registerInputOutput();\r\n        } catch (Exception e) {\r\n            throw new Exception(\"Call to registerInputOutput() of invokable failed\", e);\r\n        }\r\n        \/\/ the very last thing before the actual execution starts running is to inject\r\n        \/\/ the state into the task. the state is non-empty if this is an execution\r\n        \/\/ of a task that failed but had backuped state from a checkpoint\r\n        \/\/ get our private reference onto the stack (be safe against concurrent changes)\r\n        SerializedValue<StateHandle<?>> operatorState = this.operatorState;\r\n        if (operatorState != null) {\r\n            if (invokable instanceof OperatorStateCarrier) {\r\n                try {\r\n                    StateHandle<?> state = operatorState.deserializeValue(userCodeClassLoader);\r\n                    OperatorStateCarrier<?> op = (OperatorStateCarrier<?>) invokable;\r\n                    StateUtils.setOperatorState(op, state);\r\n                } catch (Exception e) {\r\n                    throw new RuntimeException(\"Failed to deserialize state handle and setup initial operator state.\", e);\r\n                }\r\n            } else {\r\n                throw new IllegalStateException(\"Found operator state for a non-stateful task invokable\");\r\n            }\r\n        }\r\n        \/\/ be memory and GC friendly - since the code stays in invoke() for a potentially long time,\r\n        \/\/ we clear the reference to the state handle\r\n        \/\/ noinspection UnusedAssignment\r\n        operatorState = null;\r\n        this.operatorState = null;\r\n        \/\/ ----------------------------------------------------------------\r\n        \/\/ actual task core work\r\n        \/\/ ----------------------------------------------------------------\r\n        \/\/ we must make strictly sure that the invokable is accessible to teh cancel() call\r\n        \/\/ by the time we switched to running.\r\n        this.invokable = invokable;\r\n        \/\/ switch to the RUNNING state, if that fails, we have been canceled\/failed in the meantime\r\n        if (!STATE_UPDATER.compareAndSet(this, ExecutionState.DEPLOYING, ExecutionState.RUNNING)) {\r\n            throw new CancelTaskException();\r\n        }\r\n        \/\/ notify everyone that we switched to running. especially the TaskManager needs\r\n        \/\/ to know this!\r\n        notifyObservers(ExecutionState.RUNNING, null);\r\n        taskManager.tell(new TaskMessages.UpdateTaskExecutionState(new TaskExecutionState(jobId, executionId, ExecutionState.RUNNING)), ActorRef.noSender());\r\n        \/\/ make sure the user code classloader is accessible thread-locally\r\n        executingThread.setContextClassLoader(userCodeClassLoader);\r\n        \/\/ run the invokable\r\n        invokable.invoke();\r\n        \/\/ to the fact that it has been canceled\r\n        if (isCanceledOrFailed()) {\r\n            throw new CancelTaskException();\r\n        }\r\n        \/\/ finish the produced partitions. if this fails, we consider the execution failed.\r\n        for (ResultPartition partition : producedPartitions) {\r\n            if (partition != null) {\r\n                partition.finish();\r\n            }\r\n        }\r\n        \/\/ if that fails, the task was canceled\/failed in the meantime\r\n        if (STATE_UPDATER.compareAndSet(this, ExecutionState.RUNNING, ExecutionState.FINISHED)) {\r\n            notifyObservers(ExecutionState.FINISHED, null);\r\n        } else {\r\n            throw new CancelTaskException();\r\n        }\r\n    } catch (Throwable t) {\r\n        try {\r\n            \/\/ to failExternally()\r\n            while (true) {\r\n                ExecutionState current = this.executionState;\r\n                if (current == ExecutionState.RUNNING || current == ExecutionState.DEPLOYING) {\r\n                    if (STATE_UPDATER.compareAndSet(this, current, ExecutionState.FAILED)) {\r\n                        \/\/ proper failure of the task. record the exception as the root cause\r\n                        failureCause = t;\r\n                        notifyObservers(ExecutionState.FAILED, t);\r\n                        \/\/ in case of an exception during execution, we still call \"cancel()\" on the task\r\n                        if (invokable != null && this.invokable != null && invokableHasBeenCanceled.compareAndSet(false, true)) {\r\n                            try {\r\n                                invokable.cancel();\r\n                            } catch (Throwable t2) {\r\n                                LOG.error(\"Error while canceling task \" + taskNameWithSubtask, t2);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                } else if (current == ExecutionState.CANCELING) {\r\n                    if (STATE_UPDATER.compareAndSet(this, current, ExecutionState.CANCELED)) {\r\n                        notifyObservers(ExecutionState.CANCELED, null);\r\n                        break;\r\n                    }\r\n                } else if (current == ExecutionState.FAILED) {\r\n                    \/\/ in state failed already, no transition necessary any more\r\n                    break;\r\n                } else \/\/ unexpected state, go to failed\r\n                if (STATE_UPDATER.compareAndSet(this, current, ExecutionState.FAILED)) {\r\n                    LOG.error(\"Unexpected state in Task during an exception: \" + current);\r\n                    break;\r\n                }\r\n            \/\/ else fall through the loop and\r\n            }\r\n        } catch (Throwable tt) {\r\n            String message = \"FATAL - exception in task exception handler\";\r\n            LOG.error(message, tt);\r\n            notifyFatalError(message, tt);\r\n        }\r\n    } finally {\r\n        try {\r\n            LOG.info(\"Freeing task resources for \" + taskNameWithSubtask);\r\n            \/\/ free the network resources\r\n            network.unregisterTask(this);\r\n            if (invokable != null) {\r\n                memoryManager.releaseAll(invokable);\r\n            }\r\n            \/\/ remove all of the tasks library resources\r\n            libraryCache.unregisterTask(jobId, executionId);\r\n            \/\/ remove all files in the distributed cache\r\n            removeCachedFiles(distributedCacheEntries, fileCache);\r\n            notifyFinalState();\r\n        } catch (Throwable t) {\r\n            \/\/ an error in the resource cleanup is fatal\r\n            String message = \"FATAL - exception in task resource cleanup\";\r\n            LOG.error(message, t);\r\n            notifyFatalError(message, t);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  The core work method that bootstraps the task and executes it code\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void run() {\r\n        while (true) {\r\n        ExecutionState current = this.executionState;\r\n        if (current == ExecutionState.CREATED) {\r\n            if (STATE_UPDATER.compareAndSet(this, ExecutionState.CREATED, ExecutionState.DEPLOYING)) {\r\n                                break;\r\n            }\r\n        } else if (current == ExecutionState.FAILED) {\r\n                        notifyFinalState();\r\n            return;\r\n        } else if (current == ExecutionState.CANCELING) {\r\n            if (STATE_UPDATER.compareAndSet(this, ExecutionState.CANCELING, ExecutionState.CANCELED)) {\r\n                                notifyFinalState();\r\n                return;\r\n            }\r\n        } else {\r\n            throw new IllegalStateException(\"Invalid state for beginning of task operation\");\r\n        }\r\n    }\r\n            Map<String, Future<Path>> distributedCacheEntries = new HashMap<String, Future<Path>>();\r\n    AbstractInvokable invokable = null;\r\n    try {\r\n                                                        LOG.info(\"Loading JAR files for task \" + taskNameWithSubtask);\r\n        final ClassLoader userCodeClassLoader = createUserCodeClassloader(libraryCache);\r\n                invokable = loadAndInstantiateInvokable(userCodeClassLoader, nameOfInvokableClass);\r\n        if (isCanceledOrFailed()) {\r\n            throw new CancelTaskException();\r\n        }\r\n                                                        LOG.info(\"Registering task at network: \" + this);\r\n        network.registerTask(this);\r\n                try {\r\n            for (Map.Entry<String, DistributedCache.DistributedCacheEntry> entry : DistributedCache.readFileInfoFromConfig(jobConfiguration)) {\r\n                LOG.info(\"Obtaining local cache file for '\" + entry.getKey() + '\\'');\r\n                Future<Path> cp = fileCache.createTmpFile(entry.getKey(), entry.getValue(), jobId);\r\n                distributedCacheEntries.put(entry.getKey(), cp);\r\n            }\r\n        } catch (Exception e) {\r\n            throw new Exception(\"Exception while adding files to distributed cache.\", e);\r\n        }\r\n        if (isCanceledOrFailed()) {\r\n            throw new CancelTaskException();\r\n        }\r\n                                TaskInputSplitProvider splitProvider = new TaskInputSplitProvider(jobManager, jobId, vertexId, executionId, userCodeClassLoader, actorAskTimeout);\r\n        Environment env = new RuntimeEnvironment(jobId, vertexId, executionId, taskName, taskNameWithSubtask, subtaskIndex, parallelism, jobConfiguration, taskConfiguration, userCodeClassLoader, memoryManager, ioManager, broadcastVariableManager, splitProvider, distributedCacheEntries, writers, inputGates, jobManager);\r\n                invokable.setEnvironment(env);\r\n        try {\r\n            invokable.registerInputOutput();\r\n        } catch (Exception e) {\r\n            throw new Exception(\"Call to registerInputOutput() of invokable failed\", e);\r\n        }\r\n                                        SerializedValue<StateHandle<?>> operatorState = this.operatorState;\r\n        if (operatorState != null) {\r\n            if (invokable instanceof OperatorStateCarrier) {\r\n                try {\r\n                    StateHandle<?> state = operatorState.deserializeValue(userCodeClassLoader);\r\n                    OperatorStateCarrier<?> op = (OperatorStateCarrier<?>) invokable;\r\n                    StateUtils.setOperatorState(op, state);\r\n                } catch (Exception e) {\r\n                    throw new RuntimeException(\"Failed to deserialize state handle and setup initial operator state.\", e);\r\n                }\r\n            } else {\r\n                throw new IllegalStateException(\"Found operator state for a non-stateful task invokable\");\r\n            }\r\n        }\r\n                                operatorState = null;\r\n        this.operatorState = null;\r\n                                                this.invokable = invokable;\r\n                if (!STATE_UPDATER.compareAndSet(this, ExecutionState.DEPLOYING, ExecutionState.RUNNING)) {\r\n            throw new CancelTaskException();\r\n        }\r\n                        notifyObservers(ExecutionState.RUNNING, null);\r\n        taskManager.tell(new TaskMessages.UpdateTaskExecutionState(new TaskExecutionState(jobId, executionId, ExecutionState.RUNNING)), ActorRef.noSender());\r\n                executingThread.setContextClassLoader(userCodeClassLoader);\r\n                invokable.invoke();\r\n                if (isCanceledOrFailed()) {\r\n            throw new CancelTaskException();\r\n        }\r\n                for (ResultPartition partition : producedPartitions) {\r\n            if (partition != null) {\r\n                partition.finish();\r\n            }\r\n        }\r\n                if (STATE_UPDATER.compareAndSet(this, ExecutionState.RUNNING, ExecutionState.FINISHED)) {\r\n            notifyObservers(ExecutionState.FINISHED, null);\r\n        } else {\r\n            throw new CancelTaskException();\r\n        }\r\n    } catch (Throwable t) {\r\n        try {\r\n                        while (true) {\r\n                ExecutionState current = this.executionState;\r\n                if (current == ExecutionState.RUNNING || current == ExecutionState.DEPLOYING) {\r\n                    if (STATE_UPDATER.compareAndSet(this, current, ExecutionState.FAILED)) {\r\n                                                failureCause = t;\r\n                        notifyObservers(ExecutionState.FAILED, t);\r\n                                                if (invokable != null && this.invokable != null && invokableHasBeenCanceled.compareAndSet(false, true)) {\r\n                            try {\r\n                                invokable.cancel();\r\n                            } catch (Throwable t2) {\r\n                                LOG.error(\"Error while canceling task \" + taskNameWithSubtask, t2);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                } else if (current == ExecutionState.CANCELING) {\r\n                    if (STATE_UPDATER.compareAndSet(this, current, ExecutionState.CANCELED)) {\r\n                        notifyObservers(ExecutionState.CANCELED, null);\r\n                        break;\r\n                    }\r\n                } else if (current == ExecutionState.FAILED) {\r\n                                        break;\r\n                } else                 if (STATE_UPDATER.compareAndSet(this, current, ExecutionState.FAILED)) {\r\n                    LOG.error(\"Unexpected state in Task during an exception: \" + current);\r\n                    break;\r\n                }\r\n                        }\r\n        } catch (Throwable tt) {\r\n            String message = \"FATAL - exception in task exception handler\";\r\n            LOG.error(message, tt);\r\n            notifyFatalError(message, tt);\r\n        }\r\n    } finally {\r\n        try {\r\n            LOG.info(\"Freeing task resources for \" + taskNameWithSubtask);\r\n                        network.unregisterTask(this);\r\n            if (invokable != null) {\r\n                memoryManager.releaseAll(invokable);\r\n            }\r\n                        libraryCache.unregisterTask(jobId, executionId);\r\n                        removeCachedFiles(distributedCacheEntries, fileCache);\r\n            notifyFinalState();\r\n        } catch (Throwable t) {\r\n                        String message = \"FATAL - exception in task resource cleanup\";\r\n            LOG.error(message, t);\r\n            notifyFatalError(message, t);\r\n        }\r\n    }\r\n}","lc":5.7272727273,"pi":1.5119617225,"ma":8.8,"nbd":2.5,"ml":2.8333333333,"d":1.1607142857,"mi":-1.7430584919,"fo":3.8333333333,"r":-0.0263157895,"e":9.0672498747}
{"project_name":"Math","project_version":"6","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected PointValuePair doOptimize() {\r\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\r\n    final double[] point = getStartPoint();\r\n    final GoalType goal = getGoalType();\r\n    final int n = point.length;\r\n    double[] r = computeObjectiveGradient(point);\r\n    if (goal == GoalType.MINIMIZE) {\r\n        for (int i = 0; i < n; i++) {\r\n            r[i] = -r[i];\r\n        }\r\n    }\r\n    \/\/ Initial search direction.\r\n    double[] steepestDescent = preconditioner.precondition(point, r);\r\n    double[] searchDirection = steepestDescent.clone();\r\n    double delta = 0;\r\n    for (int i = 0; i < n; ++i) {\r\n        delta += r[i] * searchDirection[i];\r\n    }\r\n    PointValuePair current = null;\r\n    int iter = 0;\r\n    int maxEval = getMaxEvaluations();\r\n    while (true) {\r\n        ++iter;\r\n        final double objective = computeObjectiveValue(point);\r\n        PointValuePair previous = current;\r\n        current = new PointValuePair(point, objective);\r\n        if (previous != null) {\r\n            if (checker.converged(iter, previous, current)) {\r\n                \/\/ We have found an optimum.\r\n                return current;\r\n            }\r\n        }\r\n        \/\/ Find the optimal step in the search direction.\r\n        final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);\r\n        final double uB = findUpperBound(lsf, 0, initialStep);\r\n        \/\/ XXX Last parameters is set to a value close to zero in order to\r\n        \/\/ work around the divergence problem in the \"testCircleFitting\"\r\n        \/\/ unit test (see MATH-439).\r\n        final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\r\n        \/\/ Subtract used up evaluations.\r\n        maxEval -= solver.getEvaluations();\r\n        \/\/ Validate new point.\r\n        for (int i = 0; i < point.length; ++i) {\r\n            point[i] += step * searchDirection[i];\r\n        }\r\n        r = computeObjectiveGradient(point);\r\n        if (goal == GoalType.MINIMIZE) {\r\n            for (int i = 0; i < n; ++i) {\r\n                r[i] = -r[i];\r\n            }\r\n        }\r\n        \/\/ Compute beta.\r\n        final double deltaOld = delta;\r\n        final double[] newSteepestDescent = preconditioner.precondition(point, r);\r\n        delta = 0;\r\n        for (int i = 0; i < n; ++i) {\r\n            delta += r[i] * newSteepestDescent[i];\r\n        }\r\n        final double beta;\r\n        switch(updateFormula) {\r\n            case FLETCHER_REEVES:\r\n                beta = delta \/ deltaOld;\r\n                break;\r\n            case POLAK_RIBIERE:\r\n                double deltaMid = 0;\r\n                for (int i = 0; i < r.length; ++i) {\r\n                    deltaMid += r[i] * steepestDescent[i];\r\n                }\r\n                beta = (delta - deltaMid) \/ deltaOld;\r\n                break;\r\n            default:\r\n                \/\/ Should never happen.\r\n                throw new MathInternalError();\r\n        }\r\n        steepestDescent = newSteepestDescent;\r\n        \/\/ Compute conjugate search direction.\r\n        if (iter % n == 0 || beta < 0) {\r\n            \/\/ Break conjugation: reset search direction.\r\n            searchDirection = steepestDescent.clone();\r\n        } else {\r\n            \/\/ Compute new conjugate search direction.\r\n            for (int i = 0; i < n; ++i) {\r\n                searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected PointValuePair doOptimize() {\r\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\r\n    final double[] point = getStartPoint();\r\n    final GoalType goal = getGoalType();\r\n    final int n = point.length;\r\n    double[] r = computeObjectiveGradient(point);\r\n    if (goal == GoalType.MINIMIZE) {\r\n        for (int i = 0; i < n; i++) {\r\n            r[i] = -r[i];\r\n        }\r\n    }\r\n        double[] steepestDescent = preconditioner.precondition(point, r);\r\n    double[] searchDirection = steepestDescent.clone();\r\n    double delta = 0;\r\n    for (int i = 0; i < n; ++i) {\r\n        delta += r[i] * searchDirection[i];\r\n    }\r\n    PointValuePair current = null;\r\n    int iter = 0;\r\n    int maxEval = getMaxEvaluations();\r\n    while (true) {\r\n        ++iter;\r\n        final double objective = computeObjectiveValue(point);\r\n        PointValuePair previous = current;\r\n        current = new PointValuePair(point, objective);\r\n        if (previous != null) {\r\n            if (checker.converged(iter, previous, current)) {\r\n                                return current;\r\n            }\r\n        }\r\n                final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);\r\n        final double uB = findUpperBound(lsf, 0, initialStep);\r\n                                final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\r\n                maxEval -= solver.getEvaluations();\r\n                for (int i = 0; i < point.length; ++i) {\r\n            point[i] += step * searchDirection[i];\r\n        }\r\n        r = computeObjectiveGradient(point);\r\n        if (goal == GoalType.MINIMIZE) {\r\n            for (int i = 0; i < n; ++i) {\r\n                r[i] = -r[i];\r\n            }\r\n        }\r\n                final double deltaOld = delta;\r\n        final double[] newSteepestDescent = preconditioner.precondition(point, r);\r\n        delta = 0;\r\n        for (int i = 0; i < n; ++i) {\r\n            delta += r[i] * newSteepestDescent[i];\r\n        }\r\n        final double beta;\r\n        switch(updateFormula) {\r\n            case FLETCHER_REEVES:\r\n                beta = delta \/ deltaOld;\r\n                break;\r\n            case POLAK_RIBIERE:\r\n                double deltaMid = 0;\r\n                for (int i = 0; i < r.length; ++i) {\r\n                    deltaMid += r[i] * steepestDescent[i];\r\n                }\r\n                beta = (delta - deltaMid) \/ deltaOld;\r\n                break;\r\n            default:\r\n                                throw new MathInternalError();\r\n        }\r\n        steepestDescent = newSteepestDescent;\r\n                if (iter % n == 0 || beta < 0) {\r\n                        searchDirection = steepestDescent.clone();\r\n        } else {\r\n                        for (int i = 0; i < n; ++i) {\r\n                searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\r\n            }\r\n        }\r\n    }\r\n}","lc":2.7727272727,"pi":0.6889952153,"ma":3.2,"nbd":1.0,"ml":1.8333333333,"d":3.8452380952,"mi":-1.2057787174,"fo":0.75,"r":-0.0263157895,"e":15.5653855685}
{"project_name":"Closure","project_version":"88","label":1,"code":"\/**\r\n * Give an expression and a variable. It returns READ, if the first\r\n * reference of that variable is a read. It returns KILL, if the first\r\n * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\r\n *\/\r\nprivate VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\r\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\r\n        if (NodeUtil.isLhs(n, n.getParent())) {\r\n            \/\/ occurs after the RHS is evaluated.\r\n            return VariableLiveness.KILL;\r\n        } else {\r\n            return VariableLiveness.READ;\r\n        }\r\n    }\r\n    \/\/ Expressions are evaluated left-right, depth first.\r\n    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\r\n        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\r\n            \/\/ Not a FUNCTION\r\n            VariableLiveness state = isVariableReadBeforeKill(child, variable);\r\n            if (state != VariableLiveness.MAYBE_LIVE) {\r\n                return state;\r\n            }\r\n        }\r\n    }\r\n    return VariableLiveness.MAYBE_LIVE;\r\n}","code_comment":"\/**\r\n * Give an expression and a variable. It returns READ, if the first\r\n * reference of that variable is a read. It returns KILL, if the first\r\n * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\r\n *\/\r\n","code_no_comment":"private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\r\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\r\n        if (NodeUtil.isLhs(n, n.getParent())) {\r\n                        return VariableLiveness.KILL;\r\n        } else {\r\n            return VariableLiveness.READ;\r\n        }\r\n    }\r\n        for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\r\n        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\r\n                        VariableLiveness state = isVariableReadBeforeKill(child, variable);\r\n            if (state != VariableLiveness.MAYBE_LIVE) {\r\n                return state;\r\n            }\r\n        }\r\n    }\r\n    return VariableLiveness.MAYBE_LIVE;\r\n}","lc":0.1818181818,"pi":0.6746411483,"ma":0.4,"nbd":0.5,"ml":0.8333333333,"d":0.4285714286,"mi":-0.191825229,"fo":0.25,"r":0.0,"e":0.3019472923}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2494_0dc92ca1","label":1,"code":"public long getMin() {\r\n    return min;\r\n}","code_comment":null,"code_no_comment":"public long getMin() {\r\n    return min;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.2407329105,"fo":-0.5,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1241_471e6b07","label":3,"code":"\/**\r\n * Computes the trigamma function of x.\r\n * This function is derived by taking the derivative of the implementation\r\n * of digamma.\r\n *\r\n * @param x Argument.\r\n * @return trigamma(x) to within 10-8 relative or absolute error whichever is smaller\r\n * @see <a href=\"http:\/\/en.wikipedia.org\/wiki\/Trigamma_function\">Trigamma<\/a>\r\n * @see Gamma#digamma(double)\r\n * @since 2.0\r\n *\/\r\npublic static double trigamma(double x) {\r\n    if (x > 0 && x <= S_LIMIT) {\r\n        return 1 \/ (x * x);\r\n    }\r\n    if (x >= C_LIMIT) {\r\n        double inv = 1 \/ (x * x);\r\n        \/\/ 2 x    6 x    30 x    42 x\r\n        return 1 \/ x + inv \/ 2 + inv \/ x * (1.0 \/ 6 - inv * (1.0 \/ 30 + inv \/ 42));\r\n    }\r\n    return trigamma(x + 1) + 1 \/ (x * x);\r\n}","code_comment":"\/**\r\n * Computes the trigamma function of x.\r\n * This function is derived by taking the derivative of the implementation\r\n * of digamma.\r\n *\r\n * @param x Argument.\r\n * @return trigamma(x) to within 10-8 relative or absolute error whichever is smaller\r\n * @see <a href=\"http:\/\/en.wikipedia.org\/wiki\/Trigamma_function\">Trigamma<\/a>\r\n * @see Gamma#digamma(double)\r\n * @since 2.0\r\n *\/\r\n","code_no_comment":"public static double trigamma(double x) {\r\n    if (x > 0 && x <= S_LIMIT) {\r\n        return 1 \/ (x * x);\r\n    }\r\n    if (x >= C_LIMIT) {\r\n        double inv = 1 \/ (x * x);\r\n                return 1 \/ x + inv \/ 2 + inv \/ x * (1.0 \/ 6 - inv * (1.0 \/ 30 + inv \/ 42));\r\n    }\r\n    return trigamma(x + 1) + 1 \/ (x * x);\r\n}","lc":-0.1818181818,"pi":-0.0909090909,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":1.7718253968,"mi":0.0872445384,"fo":-0.4166666667,"r":1.9473684211,"e":1.1656667992}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5853_b80f6640","label":3,"code":"\/**\r\n *  @see org.apache.wicket.util.convert.converter.AbstractConverter#getTargetType()\r\n *\/\r\n@Override\r\nprotected Class<Integer> getTargetType() {\r\n    return Integer.class;\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.util.convert.converter.AbstractConverter#getTargetType()\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected Class<Integer> getTargetType() {\r\n    return Integer.class;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9517970402,"fo":-0.5,"r":2.0789473684,"e":-0.1627934049}
{"project_name":"Closure","project_version":"22","label":2,"code":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    \/\/ so we'll allow it.\r\n    if (n.isEmpty() || n.isComma()) {\r\n        return;\r\n    }\r\n    if (parent == null) {\r\n        return;\r\n    }\r\n    \/\/ fix up the tree in more clever ways when these are removed.\r\n    if (parent.getType() == Token.COMMA) {\r\n        Node gramps = parent.getParent();\r\n        if (gramps.isCall() && parent == gramps.getFirstChild()) {\r\n            if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\r\n                return;\r\n            }\r\n        }\r\n        \/\/ be attached to the name. This check should not complain about it.\r\n        if (n == parent.getLastChild()) {\r\n            for (Node an : parent.getAncestors()) {\r\n                int ancestorType = an.getType();\r\n                if (ancestorType == Token.COMMA)\r\n                    continue;\r\n                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\r\n                    return;\r\n                else\r\n                    break;\r\n            }\r\n        }\r\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\r\n        if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\r\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\r\n    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\r\n        if (n.isQualifiedName() && n.getJSDocInfo() != null) {\r\n            return;\r\n        } else if (n.isExprResult()) {\r\n            return;\r\n        }\r\n        String msg = \"This code lacks side-effects. Is there a bug?\";\r\n        if (n.isString()) {\r\n            msg = \"Is there a missing '+' on the previous line?\";\r\n        } else if (isSimpleOp) {\r\n            msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";\r\n        }\r\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\r\n        \/\/ try to protect side-effect free statements as well.\r\n        if (!NodeUtil.isStatement(n)) {\r\n            problemNodes.add(n);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n        if (n.isEmpty() || n.isComma()) {\r\n        return;\r\n    }\r\n    if (parent == null) {\r\n        return;\r\n    }\r\n        if (parent.getType() == Token.COMMA) {\r\n        Node gramps = parent.getParent();\r\n        if (gramps.isCall() && parent == gramps.getFirstChild()) {\r\n            if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\r\n                return;\r\n            }\r\n        }\r\n                if (n == parent.getLastChild()) {\r\n            for (Node an : parent.getAncestors()) {\r\n                int ancestorType = an.getType();\r\n                if (ancestorType == Token.COMMA)\r\n                    continue;\r\n                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\r\n                    return;\r\n                else\r\n                    break;\r\n            }\r\n        }\r\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\r\n        if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\r\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\r\n    if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\r\n        if (n.isQualifiedName() && n.getJSDocInfo() != null) {\r\n            return;\r\n        } else if (n.isExprResult()) {\r\n            return;\r\n        }\r\n        String msg = \"This code lacks side-effects. Is there a bug?\";\r\n        if (n.isString()) {\r\n            msg = \"Is there a missing '+' on the previous line?\";\r\n        } else if (isSimpleOp) {\r\n            msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";\r\n        }\r\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\r\n                if (!NodeUtil.isStatement(n)) {\r\n            problemNodes.add(n);\r\n        }\r\n    }\r\n}","lc":1.7272727273,"pi":0.8995215311,"ma":3.2,"nbd":0.5,"ml":4.0,"d":1.0277777778,"mi":-0.9797040169,"fo":2.9166666667,"r":-0.0263157895,"e":3.3178057088}
{"project_name":"Closure","project_version":"100","label":2,"code":"\/**\r\n * Since this pass reports errors only when a global {@code this} keyword\r\n * is encountered, there is no reason to traverse non global contexts.\r\n *\/\r\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\r\n    if (n.getType() == Token.FUNCTION) {\r\n        \/\/ Don't traverse functions that are constructors or have the @this\r\n        \/\/ annotation.\r\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\r\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\r\n            return false;\r\n        }\r\n    \/\/ Don't traverse functions unless they would normally\r\n    \/\/ be able to have a @this annotation associated with them. e.g.,\r\n    \/\/ var a = function() { }; \/\/ or\r\n    \/\/ function a() {} \/\/ or\r\n    \/\/ a.x = function() {};\r\n    }\r\n    if (parent != null && parent.getType() == Token.ASSIGN) {\r\n        Node lhs = parent.getFirstChild();\r\n        Node rhs = lhs.getNext();\r\n        if (n == lhs) {\r\n            \/\/ assignLhsChild should not be overridden.\r\n            if (assignLhsChild == null) {\r\n                assignLhsChild = lhs;\r\n            }\r\n        } else {\r\n            \/\/ property or subproperty.\r\n            if (lhs.getType() == Token.GETPROP) {\r\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\r\n                    return false;\r\n                }\r\n                String leftName = lhs.getQualifiedName();\r\n                if (leftName != null && leftName.contains(\".prototype.\")) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n * Since this pass reports errors only when a global {@code this} keyword\r\n * is encountered, there is no reason to traverse non global contexts.\r\n *\/\r\n","code_no_comment":"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\r\n    if (n.getType() == Token.FUNCTION) {\r\n                        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\r\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\r\n            return false;\r\n        }\r\n                        }\r\n    if (parent != null && parent.getType() == Token.ASSIGN) {\r\n        Node lhs = parent.getFirstChild();\r\n        Node rhs = lhs.getNext();\r\n        if (n == lhs) {\r\n                        if (assignLhsChild == null) {\r\n                assignLhsChild = lhs;\r\n            }\r\n        } else {\r\n                        if (lhs.getType() == Token.GETPROP) {\r\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\r\n                    return false;\r\n                }\r\n                String leftName = lhs.getQualifiedName();\r\n                if (leftName != null && leftName.contains(\".prototype.\")) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}","lc":0.6363636364,"pi":1.2009569378,"ma":1.0,"nbd":1.0,"ml":1.6666666667,"d":0.380952381,"mi":-0.4906272023,"fo":0.5833333333,"r":0.0263157895,"e":0.5802735084}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-640_98556fed","label":1,"code":"\/**\r\n * Returns the next pseudorandom, uniformly distributed {@code int}\r\n * value from this random number generator's sequence.\r\n * All 2<font size=\"-1\"><sup>32<\/sup><\/font> possible {@code int} values\r\n * should be produced with  (approximately) equal probability.\r\n * <p>\r\n * The default implementation provided here returns\r\n * <pre>\r\n * <code>(int) (nextDouble() * Integer.MAX_VALUE)<\/code>\r\n * <\/pre><\/p>\r\n *\r\n * @return the next pseudorandom, uniformly distributed {@code int}\r\n *  value from this random number generator's sequence\r\n *\/\r\npublic int nextInt() {\r\n    return (int) (nextDouble() * Integer.MAX_VALUE);\r\n}","code_comment":"\/**\r\n * Returns the next pseudorandom, uniformly distributed {@code int}\r\n * value from this random number generator's sequence.\r\n * All 2<font size=\"-1\"><sup>32<\/sup><\/font> possible {@code int} values\r\n * should be produced with  (approximately) equal probability.\r\n * <p>\r\n * The default implementation provided here returns\r\n * <pre>\r\n * <code>(int) (nextDouble() * Integer.MAX_VALUE)<\/code>\r\n * <\/pre><\/p>\r\n *\r\n * @return the next pseudorandom, uniformly distributed {@code int}\r\n *  value from this random number generator's sequence\r\n *\/\r\n","code_no_comment":"public int nextInt() {\r\n    return (int) (nextDouble() * Integer.MAX_VALUE);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.067653277,"fo":-0.4166666667,"r":1.8421052632,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2389_0fa892b3","label":1,"code":"\/**\r\n * Convert a string to a quoted Json literal using the correct escape\r\n * sequences. The literal is enclosed in double quotes. Characters outside\r\n * the range 32..127 are encoded (backslash u xxxx). The forward slash\r\n * (solidus) is not escaped. Null is encoded as \"null\" (without quotes).\r\n *\r\n * @param s the text to convert\r\n * @return the Json representation (including double quotes)\r\n *\/\r\npublic static String encode(String s) {\r\n    if (s == null) {\r\n        return \"null\";\r\n    }\r\n    int length = s.length();\r\n    if (length == 0) {\r\n        return \"\\\"\\\"\";\r\n    }\r\n    for (int i = 0; i < length; i++) {\r\n        char c = s.charAt(i);\r\n        if (c == '\\\"' || c == '\\\\' || c < ' ') {\r\n            StringBuilder buff = new StringBuilder(length + 2 + length \/ 8);\r\n            buff.append('\\\"');\r\n            escape(s, length, buff);\r\n            return buff.append('\\\"').toString();\r\n        }\r\n    }\r\n    StringBuilder buff = new StringBuilder(length + 2);\r\n    return buff.append('\\\"').append(s).append('\\\"').toString();\r\n}","code_comment":"\/**\r\n * Convert a string to a quoted Json literal using the correct escape\r\n * sequences. The literal is enclosed in double quotes. Characters outside\r\n * the range 32..127 are encoded (backslash u xxxx). The forward slash\r\n * (solidus) is not escaped. Null is encoded as \"null\" (without quotes).\r\n *\r\n * @param s the text to convert\r\n * @return the Json representation (including double quotes)\r\n *\/\r\n","code_no_comment":"public static String encode(String s) {\r\n    if (s == null) {\r\n        return \"null\";\r\n    }\r\n    int length = s.length();\r\n    if (length == 0) {\r\n        return \"\\\"\\\"\";\r\n    }\r\n    for (int i = 0; i < length; i++) {\r\n        char c = s.charAt(i);\r\n        if (c == '\\\"' || c == '\\\\' || c < ' ') {\r\n            StringBuilder buff = new StringBuilder(length + 2 + length \/ 8);\r\n            buff.append('\\\"');\r\n            escape(s, length, buff);\r\n            return buff.append('\\\"').toString();\r\n        }\r\n    }\r\n    StringBuilder buff = new StringBuilder(length + 2);\r\n    return buff.append('\\\"').append(s).append('\\\"').toString();\r\n}","lc":0.2727272727,"pi":0.3301435407,"ma":0.2,"nbd":0.0,"ml":0.4166666667,"d":1.3353174603,"mi":-0.289640592,"fo":0.3333333333,"r":0.0263157895,"e":1.2999982711}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1075_79467350","label":1,"code":"\/**\r\n * \"operand2 always evaluates to a scalar value\"\r\n *\r\n * for multi-valued properties: if any of the value matches, then return true\r\n *\r\n * @param p1\r\n * @param p2\r\n * @return\r\n *\/\r\nprivate boolean evaluate(PropertyValue p1, PropertyValue p2) {\r\n    switch(operator) {\r\n        case EQUAL:\r\n            return PropertyValues.match(p1, p2);\r\n        case NOT_EQUAL:\r\n            return !PropertyValues.match(p1, p2);\r\n        case GREATER_OR_EQUAL:\r\n            return p1.compareTo(p2) >= 0;\r\n        case GREATER_THAN:\r\n            return p1.compareTo(p2) > 0;\r\n        case LESS_OR_EQUAL:\r\n            return p1.compareTo(p2) <= 0;\r\n        case LESS_THAN:\r\n            return p1.compareTo(p2) < 0;\r\n        case LIKE:\r\n            return evaluateLike(p1, p2);\r\n    }\r\n    throw new IllegalArgumentException(\"Unknown operator: \" + operator);\r\n}","code_comment":"\/**\r\n * \"operand2 always evaluates to a scalar value\"\r\n *\r\n * for multi-valued properties: if any of the value matches, then return true\r\n *\r\n * @param p1\r\n * @param p2\r\n * @return\r\n *\/\r\n","code_no_comment":"private boolean evaluate(PropertyValue p1, PropertyValue p2) {\r\n    switch(operator) {\r\n        case EQUAL:\r\n            return PropertyValues.match(p1, p2);\r\n        case NOT_EQUAL:\r\n            return !PropertyValues.match(p1, p2);\r\n        case GREATER_OR_EQUAL:\r\n            return p1.compareTo(p2) >= 0;\r\n        case GREATER_THAN:\r\n            return p1.compareTo(p2) > 0;\r\n        case LESS_OR_EQUAL:\r\n            return p1.compareTo(p2) <= 0;\r\n        case LESS_THAN:\r\n            return p1.compareTo(p2) < 0;\r\n        case LIKE:\r\n            return evaluateLike(p1, p2);\r\n    }\r\n    throw new IllegalArgumentException(\"Unknown operator: \" + operator);\r\n}","lc":0.2272727273,"pi":0.4306220096,"ma":1.0,"nbd":0.0,"ml":0.25,"d":0.9444444444,"mi":-0.2256518675,"fo":0.0833333333,"r":0.0526315789,"e":0.5523394593}
{"project_name":"Closure","project_version":"6","label":2,"code":"\/**\r\n * Expect that the first type can be assigned to a symbol of the second\r\n * type.\r\n *\r\n * @param t The node traversal.\r\n * @param n The node to issue warnings on.\r\n * @param rightType The type on the RHS of the assign.\r\n * @param leftType The type of the symbol on the LHS of the assign.\r\n * @param owner The owner of the property being assigned to.\r\n * @param propName The name of the property being assigned to.\r\n * @return True if the types matched, false otherwise.\r\n *\/\r\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\r\n    \/\/ The NoType check is a hack to make typedefs work OK.\r\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\r\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\r\n            registerMismatch(rightType, leftType, null);\r\n        } else {\r\n            \/\/ Do not type-check interface methods, because we expect that\r\n            \/\/ they will have dummy implementations that do not match the type\r\n            \/\/ annotations.\r\n            JSType ownerType = getJSType(owner);\r\n            if (ownerType.isFunctionPrototypeType()) {\r\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\r\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\r\n                    return true;\r\n                }\r\n            }\r\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n * Expect that the first type can be assigned to a symbol of the second\r\n * type.\r\n *\r\n * @param t The node traversal.\r\n * @param n The node to issue warnings on.\r\n * @param rightType The type on the RHS of the assign.\r\n * @param leftType The type of the symbol on the LHS of the assign.\r\n * @param owner The owner of the property being assigned to.\r\n * @param propName The name of the property being assigned to.\r\n * @return True if the types matched, false otherwise.\r\n *\/\r\n","code_no_comment":"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\r\n        if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\r\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\r\n            registerMismatch(rightType, leftType, null);\r\n        } else {\r\n                                                JSType ownerType = getJSType(owner);\r\n            if (ownerType.isFunctionPrototypeType()) {\r\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\r\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\r\n                    return true;\r\n                }\r\n            }\r\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}","lc":0.1818181818,"pi":1.2105263158,"ma":0.2,"nbd":1.0,"ml":1.3333333333,"d":0.380952381,"mi":-0.2445384073,"fo":0.8333333333,"r":-0.0263157895,"e":0.4917826455}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-964_16ad8763","label":1,"code":"private void writeObject(final ObjectOutputStream out) throws IOException {\r\n    out.defaultWriteObject();\r\n    getFormattedMessage();\r\n    out.writeUTF(formattedMessage);\r\n    out.writeUTF(messagePattern);\r\n    out.writeInt(argArray.length);\r\n    stringArgs = new String[argArray.length];\r\n    int i = 0;\r\n    for (final Object obj : argArray) {\r\n        stringArgs[i] = obj.toString();\r\n        ++i;\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void writeObject(final ObjectOutputStream out) throws IOException {\r\n    out.defaultWriteObject();\r\n    getFormattedMessage();\r\n    out.writeUTF(formattedMessage);\r\n    out.writeUTF(messagePattern);\r\n    out.writeInt(argArray.length);\r\n    stringArgs = new String[argArray.length];\r\n    int i = 0;\r\n    for (final Object obj : argArray) {\r\n        stringArgs[i] = obj.toString();\r\n        ++i;\r\n    }\r\n}","lc":-0.0454545455,"pi":-0.3684210526,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.0476190476,"mi":0.0489076815,"fo":0.0,"r":0.0526315789,"e":-0.0443722158}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-278_db19e70f","label":1,"code":"private boolean isRemoved() {\r\n    return parent == this;\r\n}","code_comment":null,"code_no_comment":"private boolean isRemoved() {\r\n    return parent == this;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1646229739,"fo":-0.5,"r":2.5,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1241_471e6b07","label":3,"code":"\/**\r\n * <p>Computes the digamma function of x.<\/p>\r\n *\r\n * <p>This is an independently written implementation of the algorithm described in\r\n * Jose Bernardo, Algorithm AS 103: Psi (Digamma) Function, Applied Statistics, 1976.<\/p>\r\n *\r\n * <p>Some of the constants have been changed to increase accuracy at the moderate expense\r\n * of run-time.  The result should be accurate to within 10^-8 absolute tolerance for\r\n * x >= 10^-5 and within 10^-8 relative tolerance for x > 0.<\/p>\r\n *\r\n * <p>Performance for large negative values of x will be quite expensive (proportional to\r\n * |x|).  Accuracy for negative values of x should be about 10^-8 absolute for results\r\n * less than 10^5 and 10^-8 relative for results larger than that.<\/p>\r\n *\r\n * @param x Argument.\r\n * @return digamma(x) to within 10-8 relative or absolute error whichever is smaller.\r\n * @see <a href=\"http:\/\/en.wikipedia.org\/wiki\/Digamma_function\">Digamma<\/a>\r\n * @see <a href=\"http:\/\/www.uv.es\/~bernardo\/1976AppStatist.pdf\">Bernardo&apos;s original article <\/a>\r\n * @since 2.0\r\n *\/\r\npublic static double digamma(double x) {\r\n    if (x > 0 && x <= S_LIMIT) {\r\n        \/\/ accurate to O(x)\r\n        return -GAMMA - 1 \/ x;\r\n    }\r\n    if (x >= C_LIMIT) {\r\n        \/\/ use method 4 (accurate to O(1\/x^8)\r\n        double inv = 1 \/ (x * x);\r\n        \/\/ 2 x   12 x^2   120 x^4   252 x^6\r\n        return FastMath.log(x) - 0.5 \/ x - inv * ((1.0 \/ 12) + inv * (1.0 \/ 120 - inv \/ 252));\r\n    }\r\n    return digamma(x + 1) - 1 \/ x;\r\n}","code_comment":"\/**\r\n * <p>Computes the digamma function of x.<\/p>\r\n *\r\n * <p>This is an independently written implementation of the algorithm described in\r\n * Jose Bernardo, Algorithm AS 103: Psi (Digamma) Function, Applied Statistics, 1976.<\/p>\r\n *\r\n * <p>Some of the constants have been changed to increase accuracy at the moderate expense\r\n * of run-time.  The result should be accurate to within 10^-8 absolute tolerance for\r\n * x >= 10^-5 and within 10^-8 relative tolerance for x > 0.<\/p>\r\n *\r\n * <p>Performance for large negative values of x will be quite expensive (proportional to\r\n * |x|).  Accuracy for negative values of x should be about 10^-8 absolute for results\r\n * less than 10^5 and 10^-8 relative for results larger than that.<\/p>\r\n *\r\n * @param x Argument.\r\n * @return digamma(x) to within 10-8 relative or absolute error whichever is smaller.\r\n * @see <a href=\"http:\/\/en.wikipedia.org\/wiki\/Digamma_function\">Digamma<\/a>\r\n * @see <a href=\"http:\/\/www.uv.es\/~bernardo\/1976AppStatist.pdf\">Bernardo&apos;s original article <\/a>\r\n * @since 2.0\r\n *\/\r\n","code_no_comment":"public static double digamma(double x) {\r\n    if (x > 0 && x <= S_LIMIT) {\r\n                return -GAMMA - 1 \/ x;\r\n    }\r\n    if (x >= C_LIMIT) {\r\n                double inv = 1 \/ (x * x);\r\n                return FastMath.log(x) - 0.5 \/ x - inv * ((1.0 \/ 12) + inv * (1.0 \/ 120 - inv \/ 252));\r\n    }\r\n    return digamma(x + 1) - 1 \/ x;\r\n}","lc":-0.1818181818,"pi":-0.0909090909,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":1.3214285714,"mi":0.0889358703,"fo":-0.3333333333,"r":-0.0263157895,"e":0.8745100073}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4927_8c827e33","label":1,"code":"@Override\r\npublic void setStatus(int sc) {\r\n    bufferedResponse.setStatus(sc);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void setStatus(int sc) {\r\n    bufferedResponse.setStatus(sc);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9292459479,"fo":-0.4166666667,"r":1.7368421053,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-766_6fc5ea9d","label":1,"code":"private TreeImpl internalGetChild(String childName) {\r\n    return nodeBuilder.hasChildNode(childName) ? new TreeImpl(root, this, childName, pendingMoves) : null;\r\n}","code_comment":null,"code_no_comment":"private TreeImpl internalGetChild(String childName) {\r\n    return nodeBuilder.hasChildNode(childName) ? new TreeImpl(root, this, childName, pendingMoves) : null;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.9109231853,"fo":-0.4166666667,"r":0.0,"e":-0.1627934049}
{"project_name":"Chart","project_version":"11","label":2,"code":"\/**\r\n * Tests two polygons for equality.  If both are <code>null<\/code> this\r\n * method returns <code>true<\/code>.\r\n *\r\n * @param p1  path 1 (<code>null<\/code> permitted).\r\n * @param p2  path 2 (<code>null<\/code> permitted).\r\n *\r\n * @return A boolean.\r\n *\/\r\npublic static boolean equal(GeneralPath p1, GeneralPath p2) {\r\n    if (p1 == null) {\r\n        return (p2 == null);\r\n    }\r\n    if (p2 == null) {\r\n        return false;\r\n    }\r\n    if (p1.getWindingRule() != p2.getWindingRule()) {\r\n        return false;\r\n    }\r\n    PathIterator iterator1 = p1.getPathIterator(null);\r\n    PathIterator iterator2 = p1.getPathIterator(null);\r\n    double[] d1 = new double[6];\r\n    double[] d2 = new double[6];\r\n    boolean done = iterator1.isDone() && iterator2.isDone();\r\n    while (!done) {\r\n        if (iterator1.isDone() != iterator2.isDone()) {\r\n            return false;\r\n        }\r\n        int seg1 = iterator1.currentSegment(d1);\r\n        int seg2 = iterator2.currentSegment(d2);\r\n        if (seg1 != seg2) {\r\n            return false;\r\n        }\r\n        if (!Arrays.equals(d1, d2)) {\r\n            return false;\r\n        }\r\n        iterator1.next();\r\n        iterator2.next();\r\n        done = iterator1.isDone() && iterator2.isDone();\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n * Tests two polygons for equality.  If both are <code>null<\/code> this\r\n * method returns <code>true<\/code>.\r\n *\r\n * @param p1  path 1 (<code>null<\/code> permitted).\r\n * @param p2  path 2 (<code>null<\/code> permitted).\r\n *\r\n * @return A boolean.\r\n *\/\r\n","code_no_comment":"public static boolean equal(GeneralPath p1, GeneralPath p2) {\r\n    if (p1 == null) {\r\n        return (p2 == null);\r\n    }\r\n    if (p2 == null) {\r\n        return false;\r\n    }\r\n    if (p1.getWindingRule() != p2.getWindingRule()) {\r\n        return false;\r\n    }\r\n    PathIterator iterator1 = p1.getPathIterator(null);\r\n    PathIterator iterator2 = p1.getPathIterator(null);\r\n    double[] d1 = new double[6];\r\n    double[] d2 = new double[6];\r\n    boolean done = iterator1.isDone() && iterator2.isDone();\r\n    while (!done) {\r\n        if (iterator1.isDone() != iterator2.isDone()) {\r\n            return false;\r\n        }\r\n        int seg1 = iterator1.currentSegment(d1);\r\n        int seg2 = iterator2.currentSegment(d2);\r\n        if (seg1 != seg2) {\r\n            return false;\r\n        }\r\n        if (!Arrays.equals(d1, d2)) {\r\n            return false;\r\n        }\r\n        iterator1.next();\r\n        iterator2.next();\r\n        done = iterator1.isDone() && iterator2.isDone();\r\n    }\r\n    return true;\r\n}","lc":0.8636363636,"pi":-0.009569378,"ma":0.8,"nbd":0.0,"ml":1.1666666667,"d":0.7757936508,"mi":-0.5574348132,"fo":0.75,"r":-0.0263157895,"e":0.9576113829}
{"project_name":"Cli","project_version":"3","label":1,"code":"\/**\r\n * <p>Create a number from a String. If a . is present, it creates a\r\n *    Double, otherwise a Long. <\/p>\r\n *\r\n * @param str the value\r\n * @return the number represented by <code>str<\/code>, if <code>str<\/code>\r\n * is not a number, null is returned.\r\n *\/\r\npublic static Number createNumber(String str) {\r\n    try {\r\n        return NumberUtils.createNumber(str);\r\n    } catch (NumberFormatException nfe) {\r\n        System.err.println(nfe.getMessage());\r\n    }\r\n    return null;\r\n}","code_comment":"\/**\r\n * <p>Create a number from a String. If a . is present, it creates a\r\n *    Double, otherwise a Long. <\/p>\r\n *\r\n * @param str the value\r\n * @return the number represented by <code>str<\/code>, if <code>str<\/code>\r\n * is not a number, null is returned.\r\n *\/\r\n","code_no_comment":"public static Number createNumber(String str) {\r\n    try {\r\n        return NumberUtils.createNumber(str);\r\n    } catch (NumberFormatException nfe) {\r\n        System.err.println(nfe.getMessage());\r\n    }\r\n    return null;\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4167723749,"fo":-0.25,"r":0.6052631579,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5418_e350f19e","label":1,"code":"\/**\r\n *  Marks the form component required if necessary\r\n *\/\r\nprivate void setComponentRequiredFlag() {\r\n    BeanValidationContext config = BeanValidationConfiguration.get();\r\n    Validator validator = config.getValidator();\r\n    Property property = getProperty();\r\n    \/\/ if the property has a NotNull constraint mark the form component required\r\n    Iterator<ConstraintDescriptor<?>> it = new ConstraintIterator(validator, property);\r\n    while (it.hasNext()) {\r\n        ConstraintDescriptor<?> desc = it.next();\r\n        if (desc.getAnnotation().annotationType().equals(NotNull.class)) {\r\n            component.setRequired(true);\r\n            break;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  Marks the form component required if necessary\r\n *\/\r\n","code_no_comment":"private void setComponentRequiredFlag() {\r\n    BeanValidationContext config = BeanValidationConfiguration.get();\r\n    Validator validator = config.getValidator();\r\n    Property property = getProperty();\r\n        Iterator<ConstraintDescriptor<?>> it = new ConstraintIterator(validator, property);\r\n    while (it.hasNext()) {\r\n        ConstraintDescriptor<?> desc = it.next();\r\n        if (desc.getAnnotation().annotationType().equals(NotNull.class)) {\r\n            component.setRequired(true);\r\n            break;\r\n        }\r\n    }\r\n}","lc":-0.0454545455,"pi":0.3349282297,"ma":0.0,"nbd":0.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.0184637068,"fo":0.25,"r":0.4210526316,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5359_61122bab","label":3,"code":"\/**\r\n *  Convert this text to an enum.\r\n *\r\n *  @param eClass\r\n *             enum type\r\n *  @return The value as an enum\r\n *  @throws StringValueConversionException\r\n *\/\r\npublic final <T extends Enum<T>> T toEnum(Class<T> eClass) throws StringValueConversionException {\r\n    return Strings.toEnum(text, eClass);\r\n}","code_comment":"\/**\r\n *  Convert this text to an enum.\r\n *\r\n *  @param eClass\r\n *             enum type\r\n *  @return The value as an enum\r\n *  @throws StringValueConversionException\r\n *\/\r\n","code_no_comment":"public final <T extends Enum<T>> T toEnum(Class<T> eClass) throws StringValueConversionException {\r\n    return Strings.toEnum(text, eClass);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9134601832,"fo":-0.4166666667,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4927_8c827e33","label":1,"code":"@Override\r\npublic void addHeader(String name, String value) {\r\n    checkHeader();\r\n    bufferedResponse.addHeader(name, value);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void addHeader(String name, String value) {\r\n    checkHeader();\r\n    bufferedResponse.addHeader(name, value);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.710782241,"fo":-0.3333333333,"r":0.4473684211,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7100_00a9b02b","label":1,"code":"@Override\r\npublic void close() throws IOException {\r\n    if (it instanceof Closeable) {\r\n        IOHelper.close((Closeable) it);\r\n    } else if (it instanceof Scanner) {\r\n        \/\/ special for Scanner as it does not implement Closeable\r\n        ((Scanner) it).close();\r\n    }\r\n    \/\/ close the buffer as well\r\n    bos.close();\r\n    \/\/ we are now closed\r\n    closed = true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void close() throws IOException {\r\n    if (it instanceof Closeable) {\r\n        IOHelper.close((Closeable) it);\r\n    } else if (it instanceof Scanner) {\r\n                ((Scanner) it).close();\r\n    }\r\n        bos.close();\r\n        closed = true;\r\n}","lc":-0.1818181818,"pi":-0.0909090909,"ma":-0.2,"nbd":0.0,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.2803382664,"fo":-0.25,"r":1.3157894737,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4184_a0150366","label":1,"code":"\/**\r\n *  Inserts the string into this string buffer.\r\n *  <p>\r\n *  The characters of the <code>String<\/code> argument are inserted, in order, into this string\r\n *  buffer at the indicated offset, moving up any characters originally above that position and\r\n *  increasing the length of this string buffer by the length of the argument. If\r\n *  <code>str<\/code> is <code>null<\/code>, then the four characters <code>\"null\"<\/code> are\r\n *  inserted into this string buffer.\r\n *  <p>\r\n *  The character at index <i>k<\/i> in the new character sequence is equal to:\r\n *  <ul>\r\n *  <li>the character at index <i>k<\/i> in the old character sequence, if <i>k<\/i> is less than\r\n *  <code>offset<\/code>\r\n *  <li>the character at index <i>k<\/i><code>-offset<\/code> in the argument <code>str<\/code>, if\r\n *  <i>k<\/i> is not less than <code>offset<\/code> but is less than\r\n *  <code>offset+str.length()<\/code>\r\n *  <li>the character at index <i>k<\/i><code>-str.length()<\/code> in the old character sequence,\r\n *  if <i>k<\/i> is not less than <code>offset+str.length()<\/code>\r\n *  <\/ul>\r\n *  <p>\r\n *  The offset argument must be greater than or equal to <code>0<\/code>, and less than or equal\r\n *  to the length of this string buffer.\r\n *\r\n *  @param offset\r\n *             the offset.\r\n *  @param str\r\n *             a string.\r\n *  @return a reference to this <code>AppendingStringBuffer<\/code> object.\r\n *  @exception StringIndexOutOfBoundsException\r\n *                 if the offset is invalid.\r\n *  @see java.lang.StringBuffer#length()\r\n *\/\r\npublic AppendingStringBuffer insert(final int offset, StringBuilder str) {\r\n    if ((offset < 0) || (offset > count)) {\r\n        throw new StringIndexOutOfBoundsException();\r\n    }\r\n    if (str == null) {\r\n        str = SB_NULL;\r\n    }\r\n    int len = str.length();\r\n    int newcount = count + len;\r\n    if (newcount > value.length) {\r\n        expandCapacity(newcount);\r\n    }\r\n    System.arraycopy(value, offset, value, offset + len, count - offset);\r\n    str.getChars(0, len, value, offset);\r\n    count = newcount;\r\n    return this;\r\n}","code_comment":"\/**\r\n *  Inserts the string into this string buffer.\r\n *  <p>\r\n *  The characters of the <code>String<\/code> argument are inserted, in order, into this string\r\n *  buffer at the indicated offset, moving up any characters originally above that position and\r\n *  increasing the length of this string buffer by the length of the argument. If\r\n *  <code>str<\/code> is <code>null<\/code>, then the four characters <code>\"null\"<\/code> are\r\n *  inserted into this string buffer.\r\n *  <p>\r\n *  The character at index <i>k<\/i> in the new character sequence is equal to:\r\n *  <ul>\r\n *  <li>the character at index <i>k<\/i> in the old character sequence, if <i>k<\/i> is less than\r\n *  <code>offset<\/code>\r\n *  <li>the character at index <i>k<\/i><code>-offset<\/code> in the argument <code>str<\/code>, if\r\n *  <i>k<\/i> is not less than <code>offset<\/code> but is less than\r\n *  <code>offset+str.length()<\/code>\r\n *  <li>the character at index <i>k<\/i><code>-str.length()<\/code> in the old character sequence,\r\n *  if <i>k<\/i> is not less than <code>offset+str.length()<\/code>\r\n *  <\/ul>\r\n *  <p>\r\n *  The offset argument must be greater than or equal to <code>0<\/code>, and less than or equal\r\n *  to the length of this string buffer.\r\n *\r\n *  @param offset\r\n *             the offset.\r\n *  @param str\r\n *             a string.\r\n *  @return a reference to this <code>AppendingStringBuffer<\/code> object.\r\n *  @exception StringIndexOutOfBoundsException\r\n *                 if the offset is invalid.\r\n *  @see java.lang.StringBuffer#length()\r\n *\/\r\n","code_no_comment":"public AppendingStringBuffer insert(final int offset, StringBuilder str) {\r\n    if ((offset < 0) || (offset > count)) {\r\n        throw new StringIndexOutOfBoundsException();\r\n    }\r\n    if (str == null) {\r\n        str = SB_NULL;\r\n    }\r\n    int len = str.length();\r\n    int newcount = count + len;\r\n    if (newcount > value.length) {\r\n        expandCapacity(newcount);\r\n    }\r\n    System.arraycopy(value, offset, value, offset + len, count - offset);\r\n    str.getChars(0, len, value, offset);\r\n    count = newcount;\r\n    return this;\r\n}","lc":0.1363636364,"pi":-0.3971291866,"ma":0.2,"nbd":-0.5,"ml":0.3333333333,"d":0.9821428571,"mi":-0.1627906977,"fo":-0.1666666667,"r":-0.0263157895,"e":0.6464318851}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-208_b224bad8","label":3,"code":"\/**\r\n *  @see wicket.ajax.AbstractDefaultAjaxBehavior#respond(wicket.ajax.AjaxRequestTarget)\r\n *\/\r\nprotected final void respond(final AjaxRequestTarget target) {\r\n    onTimer(target);\r\n    if (!stopped) {\r\n        \/\/ this might look strange, but it is necessary for IE not to leak\r\n        String js = \"setTimeout(\\\"\" + getCallbackScript(false, true) + \"\\\", \" + updateInterval.getMilliseconds() + \");\";\r\n        target.appendJavascript(js);\r\n    }\r\n}","code_comment":"\/**\r\n *  @see wicket.ajax.AbstractDefaultAjaxBehavior#respond(wicket.ajax.AjaxRequestTarget)\r\n *\/\r\n","code_no_comment":"protected final void respond(final AjaxRequestTarget target) {\r\n    onTimer(target);\r\n    if (!stopped) {\r\n                String js = \"setTimeout(\\\"\" + getCallbackScript(false, true) + \"\\\", \" + updateInterval.getMilliseconds() + \");\";\r\n        target.appendJavascript(js);\r\n    }\r\n}","lc":-0.3181818182,"pi":0.014354067,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.130952381,"mi":0.4018322763,"fo":-0.1666666667,"r":1.7894736842,"e":-0.1088754805}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4659_ccd74641","label":1,"code":"@Override\r\npublic IRequestHandler map(Exception e) {\r\n    try {\r\n        return internalMap(e);\r\n    } catch (RuntimeException e2) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.error(\"An error occurred while handling a previous error: \" + e2.getMessage(), e2);\r\n        }\r\n        \/\/ hmmm, we were already handling an exception! give up\r\n        logger.error(\"unexpected exception when handling another exception: \" + e.getMessage(), e);\r\n        return new ErrorCodeRequestHandler(500);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic IRequestHandler map(Exception e) {\r\n    try {\r\n        return internalMap(e);\r\n    } catch (RuntimeException e2) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.error(\"An error occurred while handling a previous error: \" + e2.getMessage(), e2);\r\n        }\r\n                logger.error(\"unexpected exception when handling another exception: \" + e.getMessage(), e);\r\n        return new ErrorCodeRequestHandler(500);\r\n    }\r\n}","lc":-0.0909090909,"pi":0.3732057416,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.3650793651,"mi":0.1255813953,"fo":0.0,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2412_a56aad74","label":0,"code":"@Override\r\npublic Buffer getNextBuffer() throws IOException, InterruptedException {\r\n    if (isReleased.get()) {\r\n        return null;\r\n    }\r\n    \/\/ 1) In-memory\r\n    synchronized (parent.buffers) {\r\n        if (parent.spillWriter == null) {\r\n            if (currentQueuePosition < numberOfBuffers) {\r\n                Buffer buffer = parent.buffers.get(currentQueuePosition);\r\n                buffer.retain();\r\n                \/\/ TODO Fix hard coding of 8 bytes for the header\r\n                currentBytesRead += buffer.getSize() + 8;\r\n                currentQueuePosition++;\r\n                return buffer;\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n    \/\/ 2) Spilled\r\n    if (spilledView != null) {\r\n        return spilledView.getNextBuffer();\r\n    }\r\n    \/\/ because this might be called from an network I\/O thread.\r\n    if (parent.spillWriter.getNumberOfOutstandingRequests() > 0) {\r\n        return null;\r\n    }\r\n    if (ioMode.isSynchronous()) {\r\n        spilledView = new SpilledSubpartitionViewSyncIO(parent, bufferProvider.getMemorySegmentSize(), parent.spillWriter.getChannelID(), currentBytesRead);\r\n    } else {\r\n        spilledView = new SpilledSubpartitionViewAsyncIO(parent, bufferProvider, parent.ioManager, parent.spillWriter.getChannelID(), currentBytesRead);\r\n    }\r\n    return spilledView.getNextBuffer();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Buffer getNextBuffer() throws IOException, InterruptedException {\r\n    if (isReleased.get()) {\r\n        return null;\r\n    }\r\n        synchronized (parent.buffers) {\r\n        if (parent.spillWriter == null) {\r\n            if (currentQueuePosition < numberOfBuffers) {\r\n                Buffer buffer = parent.buffers.get(currentQueuePosition);\r\n                buffer.retain();\r\n                                currentBytesRead += buffer.getSize() + 8;\r\n                currentQueuePosition++;\r\n                return buffer;\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n        if (spilledView != null) {\r\n        return spilledView.getNextBuffer();\r\n    }\r\n        if (parent.spillWriter.getNumberOfOutstandingRequests() > 0) {\r\n        return null;\r\n    }\r\n    if (ioMode.isSynchronous()) {\r\n        spilledView = new SpilledSubpartitionViewSyncIO(parent, bufferProvider.getMemorySegmentSize(), parent.spillWriter.getChannelID(), currentBytesRead);\r\n    } else {\r\n        spilledView = new SpilledSubpartitionViewAsyncIO(parent, bufferProvider, parent.ioManager, parent.spillWriter.getChannelID(), currentBytesRead);\r\n    }\r\n    return spilledView.getNextBuffer();\r\n}","lc":0.7272727273,"pi":0.9425837321,"ma":0.6,"nbd":0.5,"ml":0.6666666667,"d":1.3015873016,"mi":-0.4928823115,"fo":0.4166666667,"r":-0.0263157895,"e":1.3208277865}
{"project_name":"Lang","project_version":"7","label":1,"code":"\/\/ -----------------------------------------------------------------------\r\n\/\/ must handle Long, Float, Integer, Float, Short,\r\n\/\/ BigDecimal, BigInteger and Byte\r\n\/\/ useful methods:\r\n\/\/ Byte.decode(String)\r\n\/\/ Byte.valueOf(String,int radix)\r\n\/\/ Byte.valueOf(String)\r\n\/\/ Double.valueOf(String)\r\n\/\/ Float.valueOf(String)\r\n\/\/ Float.valueOf(String)\r\n\/\/ Integer.valueOf(String,int radix)\r\n\/\/ Integer.valueOf(String)\r\n\/\/ Integer.decode(String)\r\n\/\/ Integer.getInteger(String)\r\n\/\/ Integer.getInteger(String,int val)\r\n\/\/ Integer.getInteger(String,Integer val)\r\n\/\/ Integer.valueOf(String)\r\n\/\/ Double.valueOf(String)\r\n\/\/ new Byte(String)\r\n\/\/ Long.valueOf(String)\r\n\/\/ Long.getLong(String)\r\n\/\/ Long.getLong(String,int)\r\n\/\/ Long.getLong(String,Integer)\r\n\/\/ Long.valueOf(String,int)\r\n\/\/ Long.valueOf(String)\r\n\/\/ Short.valueOf(String)\r\n\/\/ Short.decode(String)\r\n\/\/ Short.valueOf(String,int)\r\n\/\/ Short.valueOf(String)\r\n\/\/ new BigDecimal(String)\r\n\/\/ new BigInteger(String)\r\n\/\/ new BigInteger(String,int radix)\r\n\/\/ Possible inputs:\r\n\/\/ 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\r\n\/\/ plus minus everything. Prolly more. A lot are not separable.\r\n\/**\r\n * <p>Turns a string value into a java.lang.Number.<\/p>\r\n *\r\n * <p>If the string starts with <code>0x<\/code> or <code>-0x<\/code> (lower or upper case), it\r\n * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\r\n * prefix is more than 8.\r\n * Values with leading <code>0<\/code>'s will not be interpreted as octal.<\/p>\r\n *\r\n * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\r\n * <code>'f','F','d','D','l','L'<\/code>.  If it is found, it starts\r\n * trying to create successively larger types from the type specified\r\n * until one is found that can represent the value.<\/p>\r\n *\r\n * <p>If a type specifier is not found, it will check for a decimal point\r\n * and then try successively larger types from <code>Integer<\/code> to\r\n * <code>BigInteger<\/code> and from <code>Float<\/code> to\r\n * <code>BigDecimal<\/code>.<\/p>\r\n *\r\n * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\r\n *\r\n * <p>This method does not trim the input string, i.e., strings with leading\r\n * or trailing spaces will generate NumberFormatExceptions.<\/p>\r\n *\r\n * @param str  String containing a number, may be null\r\n * @return Number created from the string (or null if the input is null)\r\n * @throws NumberFormatException if the value cannot be converted\r\n *\/\r\npublic static Number createNumber(String str) throws NumberFormatException {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    if (StringUtils.isBlank(str)) {\r\n        throw new NumberFormatException(\"A blank string is not a valid number\");\r\n    }\r\n    if (str.startsWith(\"--\")) {\r\n        return null;\r\n    }\r\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\r\n        \/\/ drop 0x\r\n        int hexDigits = str.length() - 2;\r\n        if (str.startsWith(\"-\")) {\r\n            \/\/ drop -\r\n            hexDigits--;\r\n        }\r\n        if (hexDigits > 8) {\r\n            \/\/ too many for an int\r\n            return createLong(str);\r\n        }\r\n        return createInteger(str);\r\n    }\r\n    char lastChar = str.charAt(str.length() - 1);\r\n    String mant;\r\n    String dec;\r\n    String exp;\r\n    int decPos = str.indexOf('.');\r\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\r\n    if (decPos > -1) {\r\n        if (expPos > -1) {\r\n            if (expPos < decPos || expPos > str.length()) {\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            }\r\n            dec = str.substring(decPos + 1, expPos);\r\n        } else {\r\n            dec = str.substring(decPos + 1);\r\n        }\r\n        mant = str.substring(0, decPos);\r\n    } else {\r\n        if (expPos > -1) {\r\n            if (expPos > str.length()) {\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            }\r\n            mant = str.substring(0, expPos);\r\n        } else {\r\n            mant = str;\r\n        }\r\n        dec = null;\r\n    }\r\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\r\n        if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length() - 1);\r\n        } else {\r\n            exp = null;\r\n        }\r\n        \/\/ Requesting a specific type..\r\n        String numeric = str.substring(0, str.length() - 1);\r\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n        switch(lastChar) {\r\n            case 'l':\r\n            case 'L':\r\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\r\n                    try {\r\n                        return createLong(numeric);\r\n                    } catch (NumberFormatException nfe) {\r\n                    \/\/ NOPMD\r\n                    \/\/ Too big for a long\r\n                    }\r\n                    return createBigInteger(numeric);\r\n                }\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            case 'f':\r\n            case 'F':\r\n                try {\r\n                    Float f = NumberUtils.createFloat(numeric);\r\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                        \/\/ has non-zeros in it, then float does not have the precision we want\r\n                        return f;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                \/\/ NOPMD\r\n                \/\/ ignore the bad number\r\n                }\r\n            \/\/ $FALL-THROUGH$\r\n            case 'd':\r\n            case 'D':\r\n                try {\r\n                    Double d = NumberUtils.createDouble(numeric);\r\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\r\n                        return d;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                \/\/ NOPMD\r\n                \/\/ ignore the bad number\r\n                }\r\n                try {\r\n                    return createBigDecimal(numeric);\r\n                } catch (NumberFormatException e) {\r\n                \/\/ NOPMD\r\n                \/\/ ignore the bad number\r\n                }\r\n            \/\/ $FALL-THROUGH$\r\n            default:\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n        }\r\n    } else {\r\n        \/\/ small and go from there...\r\n        if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length());\r\n        } else {\r\n            exp = null;\r\n        }\r\n        if (dec == null && exp == null) {\r\n            \/\/ Must be an int,long,bigint\r\n            try {\r\n                return createInteger(str);\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ NOPMD\r\n            \/\/ ignore the bad number\r\n            }\r\n            try {\r\n                return createLong(str);\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ NOPMD\r\n            \/\/ ignore the bad number\r\n            }\r\n            return createBigInteger(str);\r\n        } else {\r\n            \/\/ Must be a float,double,BigDec\r\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n            try {\r\n                Float f = createFloat(str);\r\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                    return f;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ NOPMD\r\n            \/\/ ignore the bad number\r\n            }\r\n            try {\r\n                Double d = createDouble(str);\r\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\r\n                    return d;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ NOPMD\r\n            \/\/ ignore the bad number\r\n            }\r\n            return createBigDecimal(str);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * <p>Turns a string value into a java.lang.Number.<\/p>\r\n *\r\n * <p>If the string starts with <code>0x<\/code> or <code>-0x<\/code> (lower or upper case), it\r\n * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\r\n * prefix is more than 8.\r\n * Values with leading <code>0<\/code>'s will not be interpreted as octal.<\/p>\r\n *\r\n * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\r\n * <code>'f','F','d','D','l','L'<\/code>.  If it is found, it starts\r\n * trying to create successively larger types from the type specified\r\n * until one is found that can represent the value.<\/p>\r\n *\r\n * <p>If a type specifier is not found, it will check for a decimal point\r\n * and then try successively larger types from <code>Integer<\/code> to\r\n * <code>BigInteger<\/code> and from <code>Float<\/code> to\r\n * <code>BigDecimal<\/code>.<\/p>\r\n *\r\n * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\r\n *\r\n * <p>This method does not trim the input string, i.e., strings with leading\r\n * or trailing spaces will generate NumberFormatExceptions.<\/p>\r\n *\r\n * @param str  String containing a number, may be null\r\n * @return Number created from the string (or null if the input is null)\r\n * @throws NumberFormatException if the value cannot be converted\r\n *\/\r\n","code_no_comment":"public static Number createNumber(String str) throws NumberFormatException {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    if (StringUtils.isBlank(str)) {\r\n        throw new NumberFormatException(\"A blank string is not a valid number\");\r\n    }\r\n    if (str.startsWith(\"--\")) {\r\n        return null;\r\n    }\r\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\r\n                int hexDigits = str.length() - 2;\r\n        if (str.startsWith(\"-\")) {\r\n                        hexDigits--;\r\n        }\r\n        if (hexDigits > 8) {\r\n                        return createLong(str);\r\n        }\r\n        return createInteger(str);\r\n    }\r\n    char lastChar = str.charAt(str.length() - 1);\r\n    String mant;\r\n    String dec;\r\n    String exp;\r\n    int decPos = str.indexOf('.');\r\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\r\n    if (decPos > -1) {\r\n        if (expPos > -1) {\r\n            if (expPos < decPos || expPos > str.length()) {\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            }\r\n            dec = str.substring(decPos + 1, expPos);\r\n        } else {\r\n            dec = str.substring(decPos + 1);\r\n        }\r\n        mant = str.substring(0, decPos);\r\n    } else {\r\n        if (expPos > -1) {\r\n            if (expPos > str.length()) {\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            }\r\n            mant = str.substring(0, expPos);\r\n        } else {\r\n            mant = str;\r\n        }\r\n        dec = null;\r\n    }\r\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\r\n        if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length() - 1);\r\n        } else {\r\n            exp = null;\r\n        }\r\n                String numeric = str.substring(0, str.length() - 1);\r\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n        switch(lastChar) {\r\n            case 'l':\r\n            case 'L':\r\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\r\n                    try {\r\n                        return createLong(numeric);\r\n                    } catch (NumberFormatException nfe) {\r\n                                                            }\r\n                    return createBigInteger(numeric);\r\n                }\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            case 'f':\r\n            case 'F':\r\n                try {\r\n                    Float f = NumberUtils.createFloat(numeric);\r\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                                                return f;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                                                }\r\n                        case 'd':\r\n            case 'D':\r\n                try {\r\n                    Double d = NumberUtils.createDouble(numeric);\r\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\r\n                        return d;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                                                }\r\n                try {\r\n                    return createBigDecimal(numeric);\r\n                } catch (NumberFormatException e) {\r\n                                                }\r\n                        default:\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n        }\r\n    } else {\r\n                if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length());\r\n        } else {\r\n            exp = null;\r\n        }\r\n        if (dec == null && exp == null) {\r\n                        try {\r\n                return createInteger(str);\r\n            } catch (NumberFormatException nfe) {\r\n                                    }\r\n            try {\r\n                return createLong(str);\r\n            } catch (NumberFormatException nfe) {\r\n                                    }\r\n            return createBigInteger(str);\r\n        } else {\r\n                        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n            try {\r\n                Float f = createFloat(str);\r\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                    return f;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n                                    }\r\n            try {\r\n                Double d = createDouble(str);\r\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\r\n                    return d;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n                                    }\r\n            return createBigDecimal(str);\r\n        }\r\n    }\r\n}","lc":5.1363636364,"pi":1.1291866029,"ma":7.4,"nbd":1.5,"ml":5.6666666667,"d":3.9503968254,"mi":-1.6336856942,"fo":4.25,"r":-0.0263157895,"e":22.6843772872}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-988_d270055e","label":1,"code":"\/**\r\n * Get the intersection of the instance and another sub-line.\r\n * <p>\r\n * This method is related to the {@link Line#intersection(Line)\r\n * intersection} method in the {@link Line Line} class, but in addition\r\n * to compute the point along infinite lines, it also checks the point\r\n * lies on both sub-line ranges.\r\n * <\/p>\r\n * @param subLine other sub-line which may intersect instance\r\n * @param includeEndPoints if true, endpoints are considered to belong to\r\n * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\r\n * are considered to not belong to instance (i.e. they are open sets) and intersection\r\n * occurring on endpoints lead to null being returned\r\n * @return the intersection point if there is one, null if the sub-lines don't intersect\r\n *\/\r\npublic Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\r\n    \/\/ compute the intersection on infinite line\r\n    Vector3D v1D = line.intersection(subLine.line);\r\n    \/\/ check location of point with respect to first sub-line\r\n    Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\r\n    \/\/ check location of point with respect to second sub-line\r\n    Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\r\n    if (includeEndPoints) {\r\n        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\r\n    } else {\r\n        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\r\n    }\r\n}","code_comment":"\/**\r\n * Get the intersection of the instance and another sub-line.\r\n * <p>\r\n * This method is related to the {@link Line#intersection(Line)\r\n * intersection} method in the {@link Line Line} class, but in addition\r\n * to compute the point along infinite lines, it also checks the point\r\n * lies on both sub-line ranges.\r\n * <\/p>\r\n * @param subLine other sub-line which may intersect instance\r\n * @param includeEndPoints if true, endpoints are considered to belong to\r\n * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\r\n * are considered to not belong to instance (i.e. they are open sets) and intersection\r\n * occurring on endpoints lead to null being returned\r\n * @return the intersection point if there is one, null if the sub-lines don't intersect\r\n *\/\r\n","code_no_comment":"public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\r\n        Vector3D v1D = line.intersection(subLine.line);\r\n        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\r\n        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\r\n    if (includeEndPoints) {\r\n        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\r\n    } else {\r\n        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\r\n    }\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":0.0,"nbd":-0.5,"ml":0.25,"d":0.6845238095,"mi":0.0985200846,"fo":-0.0833333333,"r":-0.0263157895,"e":0.4161223584}
{"project_name":"Math","project_version":"102","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n * <p><strong>Note: <\/strong>This implementation rescales the\r\n * <code>expected<\/code> array if necessary to ensure that the sum of the\r\n * expected and observed counts are equal.<\/p>\r\n *\r\n * @param observed array of observed frequency counts\r\n * @param expected array of expected frequency counts\r\n * @return chi-square test statistic\r\n * @throws IllegalArgumentException if preconditions are not met\r\n * or length is less than 2\r\n *\/\r\npublic double chiSquare(double[] expected, long[] observed) throws IllegalArgumentException {\r\n    if ((expected.length < 2) || (expected.length != observed.length)) {\r\n        throw new IllegalArgumentException(\"observed, expected array lengths incorrect\");\r\n    }\r\n    if (!isPositive(expected) || !isNonNegative(observed)) {\r\n        throw new IllegalArgumentException(\"observed counts must be non-negative and expected counts must be postive\");\r\n    }\r\n    double sumSq = 0.0d;\r\n    double dev = 0.0d;\r\n    for (int i = 0; i < observed.length; i++) {\r\n        dev = ((double) observed[i] - expected[i]);\r\n        sumSq += dev * dev \/ expected[i];\r\n    }\r\n    return sumSq;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n * <p><strong>Note: <\/strong>This implementation rescales the\r\n * <code>expected<\/code> array if necessary to ensure that the sum of the\r\n * expected and observed counts are equal.<\/p>\r\n *\r\n * @param observed array of observed frequency counts\r\n * @param expected array of expected frequency counts\r\n * @return chi-square test statistic\r\n * @throws IllegalArgumentException if preconditions are not met\r\n * or length is less than 2\r\n *\/\r\n","code_no_comment":"public double chiSquare(double[] expected, long[] observed) throws IllegalArgumentException {\r\n    if ((expected.length < 2) || (expected.length != observed.length)) {\r\n        throw new IllegalArgumentException(\"observed, expected array lengths incorrect\");\r\n    }\r\n    if (!isPositive(expected) || !isNonNegative(observed)) {\r\n        throw new IllegalArgumentException(\"observed counts must be non-negative and expected counts must be postive\");\r\n    }\r\n    double sumSq = 0.0d;\r\n    double dev = 0.0d;\r\n    for (int i = 0; i < observed.length; i++) {\r\n        dev = ((double) observed[i] - expected[i]);\r\n        sumSq += dev * dev \/ expected[i];\r\n    }\r\n    return sumSq;\r\n}","lc":0.0454545455,"pi":-0.2488038278,"ma":0.4,"nbd":-0.5,"ml":0.5833333333,"d":2.1765873016,"mi":-0.1174066244,"fo":-0.3333333333,"r":-0.0263157895,"e":1.4198394449}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-414_ebf22df0","label":1,"code":"\/**\r\n * Iterates over the source until an acceptable key\/value pair is found.\r\n *\/\r\nprotected void findTop() {\r\n    while (getSource().hasTop() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {\r\n        try {\r\n            getSource().next();\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Iterates over the source until an acceptable key\/value pair is found.\r\n *\/\r\n","code_no_comment":"protected void findTop() {\r\n    while (getSource().hasTop() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {\r\n        try {\r\n            getSource().next();\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n}","lc":-0.2272727273,"pi":0.6076555024,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":-0.1011904762,"mi":0.3285412262,"fo":0.25,"r":1.3157894737,"e":-0.1206641195}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1372_ffedf33f","label":3,"code":"@Override\r\nprotected PrettyPrinter newPrettyPrinter() {\r\n    return new DefaultXmlPrettyPrinter();\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected PrettyPrinter newPrettyPrinter() {\r\n    return new DefaultXmlPrettyPrinter();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9785764623,"fo":-0.5,"r":1.4473684211,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2219_f2740ce1","label":1,"code":"@Override\r\npublic Cursor query(IndexPlan plan, NodeState root) {\r\n    LOG.debug(\"query(IndexPlan, NodeState)\");\r\n    LOG.debug(\"query() - plan: {}\", plan);\r\n    LOG.debug(\"query() - rootState: {}\", root);\r\n    Filter filter = plan.getFilter();\r\n    List<OrderEntry> sortOrder = plan.getSortOrder();\r\n    String pathPrefix = plan.getPathPrefix();\r\n    Iterable<String> paths = null;\r\n    OrderedContentMirrorStoreStrategy strategy = OrderedPropertyIndexLookup.getStrategy(plan.getDefinition());\r\n    int depth = 1;\r\n    PropertyRestriction pr = plan.getPropertyRestriction();\r\n    if (pr != null) {\r\n        String propertyName = PathUtils.getName(pr.propertyName);\r\n        depth = PathUtils.getDepth(propertyName);\r\n        paths = strategy.query(plan.getFilter(), propertyName, plan.getDefinition(), pr, pathPrefix);\r\n    }\r\n    if (paths == null && sortOrder != null && !sortOrder.isEmpty()) {\r\n        \/\/ we could be here if we have a query where the ORDER BY makes us play it.\r\n        for (OrderEntry oe : sortOrder) {\r\n            String propertyName = PathUtils.getName(oe.getPropertyName());\r\n            depth = PathUtils.getDepth(oe.getPropertyName());\r\n            paths = strategy.query(plan.getFilter(), propertyName, plan.getDefinition(), new PropertyRestriction(), pathPrefix);\r\n        }\r\n    }\r\n    if (paths == null) {\r\n        \/\/ if still here then something went wrong.\r\n        throw new IllegalStateException(\"OrderedPropertyIndex index is used even when no index is available for filter \" + filter);\r\n    }\r\n    Cursor cursor = Cursors.newPathCursor(paths, filter.getQueryEngineSettings());\r\n    if (depth > 1) {\r\n        cursor = Cursors.newAncestorCursor(cursor, depth - 1, filter.getQueryEngineSettings());\r\n    }\r\n    return cursor;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Cursor query(IndexPlan plan, NodeState root) {\r\n    LOG.debug(\"query(IndexPlan, NodeState)\");\r\n    LOG.debug(\"query() - plan: {}\", plan);\r\n    LOG.debug(\"query() - rootState: {}\", root);\r\n    Filter filter = plan.getFilter();\r\n    List<OrderEntry> sortOrder = plan.getSortOrder();\r\n    String pathPrefix = plan.getPathPrefix();\r\n    Iterable<String> paths = null;\r\n    OrderedContentMirrorStoreStrategy strategy = OrderedPropertyIndexLookup.getStrategy(plan.getDefinition());\r\n    int depth = 1;\r\n    PropertyRestriction pr = plan.getPropertyRestriction();\r\n    if (pr != null) {\r\n        String propertyName = PathUtils.getName(pr.propertyName);\r\n        depth = PathUtils.getDepth(propertyName);\r\n        paths = strategy.query(plan.getFilter(), propertyName, plan.getDefinition(), pr, pathPrefix);\r\n    }\r\n    if (paths == null && sortOrder != null && !sortOrder.isEmpty()) {\r\n                for (OrderEntry oe : sortOrder) {\r\n            String propertyName = PathUtils.getName(oe.getPropertyName());\r\n            depth = PathUtils.getDepth(oe.getPropertyName());\r\n            paths = strategy.query(plan.getFilter(), propertyName, plan.getDefinition(), new PropertyRestriction(), pathPrefix);\r\n        }\r\n    }\r\n    if (paths == null) {\r\n                throw new IllegalStateException(\"OrderedPropertyIndex index is used even when no index is available for filter \" + filter);\r\n    }\r\n    Cursor cursor = Cursors.newPathCursor(paths, filter.getQueryEngineSettings());\r\n    if (depth > 1) {\r\n        cursor = Cursors.newAncestorCursor(cursor, depth - 1, filter.getQueryEngineSettings());\r\n    }\r\n    return cursor;\r\n}","lc":0.8636363636,"pi":0.019138756,"ma":0.6,"nbd":0.0,"ml":0.5,"d":1.5873015873,"mi":-0.6560958421,"fo":1.6666666667,"r":-0.0263157895,"e":3.7703290054}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-642_7a84b3a8","label":3,"code":"@Override\r\npublic Node perform() throws RepositoryException {\r\n    String oakPath = sessionDelegate.getOakPathKeepIndexOrThrowNotFound(relPath);\r\n    String oakName = PathUtils.getName(oakPath);\r\n    String parentPath = sessionDelegate.getOakPath(PathUtils.getParentPath(oakPath));\r\n    \/\/ handle index\r\n    if (oakName.contains(\"[\")) {\r\n        throw new RepositoryException(\"Cannot create a new node using a name including an index\");\r\n    }\r\n    NodeDelegate parent = dlg.getChild(parentPath);\r\n    if (parent == null) {\r\n        \/\/ is it a property?\r\n        String grandParentPath = PathUtils.getParentPath(parentPath);\r\n        NodeDelegate grandParent = dlg.getChild(grandParentPath);\r\n        if (grandParent != null) {\r\n            String propName = PathUtils.getName(parentPath);\r\n            if (grandParent.getProperty(propName) != null) {\r\n                throw new ConstraintViolationException(\"Can't add new node to property.\");\r\n            }\r\n        }\r\n        throw new PathNotFoundException(relPath);\r\n    }\r\n    if (parent.getChild(oakName) != null) {\r\n        throw new ItemExistsException(relPath);\r\n    }\r\n    String ntName = primaryNodeTypeName;\r\n    if (ntName == null) {\r\n        DefinitionProvider dp = sessionDelegate.getDefinitionProvider();\r\n        try {\r\n            String childName = sessionDelegate.getOakName(PathUtils.getName(relPath));\r\n            NodeDefinition def = dp.getDefinition(new NodeImpl<NodeDelegate>(parent), childName);\r\n            ntName = def.getDefaultPrimaryTypeName();\r\n        } catch (RepositoryException e) {\r\n            throw new ConstraintViolationException(\"no matching child node definition found for \" + relPath);\r\n        }\r\n    }\r\n    \/\/ TODO: figure out the right place for this check\r\n    NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();\r\n    \/\/ throws on not found\r\n    NodeType nt = ntm.getNodeType(ntName);\r\n    if (nt.isAbstract() || nt.isMixin()) {\r\n        throw new ConstraintViolationException();\r\n    }\r\n    \/\/ TODO: END\r\n    NodeDelegate added = parent.addChild(oakName);\r\n    if (added == null) {\r\n        throw new ItemExistsException();\r\n    }\r\n    if (getPrimaryNodeType().hasOrderableChildNodes()) {\r\n        dlg.setOrderableChildren(true);\r\n    }\r\n    NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added);\r\n    childNode.internalSetPrimaryType(ntName);\r\n    childNode.autoCreateItems();\r\n    return childNode;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Node perform() throws RepositoryException {\r\n    String oakPath = sessionDelegate.getOakPathKeepIndexOrThrowNotFound(relPath);\r\n    String oakName = PathUtils.getName(oakPath);\r\n    String parentPath = sessionDelegate.getOakPath(PathUtils.getParentPath(oakPath));\r\n        if (oakName.contains(\"[\")) {\r\n        throw new RepositoryException(\"Cannot create a new node using a name including an index\");\r\n    }\r\n    NodeDelegate parent = dlg.getChild(parentPath);\r\n    if (parent == null) {\r\n                String grandParentPath = PathUtils.getParentPath(parentPath);\r\n        NodeDelegate grandParent = dlg.getChild(grandParentPath);\r\n        if (grandParent != null) {\r\n            String propName = PathUtils.getName(parentPath);\r\n            if (grandParent.getProperty(propName) != null) {\r\n                throw new ConstraintViolationException(\"Can't add new node to property.\");\r\n            }\r\n        }\r\n        throw new PathNotFoundException(relPath);\r\n    }\r\n    if (parent.getChild(oakName) != null) {\r\n        throw new ItemExistsException(relPath);\r\n    }\r\n    String ntName = primaryNodeTypeName;\r\n    if (ntName == null) {\r\n        DefinitionProvider dp = sessionDelegate.getDefinitionProvider();\r\n        try {\r\n            String childName = sessionDelegate.getOakName(PathUtils.getName(relPath));\r\n            NodeDefinition def = dp.getDefinition(new NodeImpl<NodeDelegate>(parent), childName);\r\n            ntName = def.getDefaultPrimaryTypeName();\r\n        } catch (RepositoryException e) {\r\n            throw new ConstraintViolationException(\"no matching child node definition found for \" + relPath);\r\n        }\r\n    }\r\n        NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();\r\n        NodeType nt = ntm.getNodeType(ntName);\r\n    if (nt.isAbstract() || nt.isMixin()) {\r\n        throw new ConstraintViolationException();\r\n    }\r\n        NodeDelegate added = parent.addChild(oakName);\r\n    if (added == null) {\r\n        throw new ItemExistsException();\r\n    }\r\n    if (getPrimaryNodeType().hasOrderableChildNodes()) {\r\n        dlg.setOrderableChildren(true);\r\n    }\r\n    NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added);\r\n    childNode.internalSetPrimaryType(ntName);\r\n    childNode.autoCreateItems();\r\n    return childNode;\r\n}","lc":1.6818181818,"pi":0.2344497608,"ma":2.8,"nbd":0.5,"ml":1.4166666667,"d":0.4861111111,"mi":-0.9424947146,"fo":1.6666666667,"r":-0.0263157895,"e":1.7496539364}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8964_ea8ee025","label":1,"code":"\/**\r\n * Suspends each element of the given {@code services} if {@code services} itself is\r\n * not {@code null}, otherwise this method would return immediately.\r\n * <p\/>\r\n * If there's any exception being thrown while suspending the elements one after the\r\n * other this method would rethrow the <b>first<\/b> such exception being thrown.\r\n *\r\n * @see #suspendService(Service)\r\n *\/\r\npublic static void suspendServices(Collection<?> services) throws Exception {\r\n    if (services == null) {\r\n        return;\r\n    }\r\n    Exception firstException = null;\r\n    for (Object value : services) {\r\n        if (value instanceof Service) {\r\n            Service service = (Service) value;\r\n            try {\r\n                suspendService(service);\r\n            } catch (Exception e) {\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Caught exception suspending service: \" + service, e);\r\n                }\r\n                if (firstException == null) {\r\n                    firstException = e;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (firstException != null) {\r\n        throw firstException;\r\n    }\r\n}","code_comment":"\/**\r\n * Suspends each element of the given {@code services} if {@code services} itself is\r\n * not {@code null}, otherwise this method would return immediately.\r\n * <p\/>\r\n * If there's any exception being thrown while suspending the elements one after the\r\n * other this method would rethrow the <b>first<\/b> such exception being thrown.\r\n *\r\n * @see #suspendService(Service)\r\n *\/\r\n","code_no_comment":"public static void suspendServices(Collection<?> services) throws Exception {\r\n    if (services == null) {\r\n        return;\r\n    }\r\n    Exception firstException = null;\r\n    for (Object value : services) {\r\n        if (value instanceof Service) {\r\n            Service service = (Service) value;\r\n            try {\r\n                suspendService(service);\r\n            } catch (Exception e) {\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Caught exception suspending service: \" + service, e);\r\n                }\r\n                if (firstException == null) {\r\n                    firstException = e;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (firstException != null) {\r\n        throw firstException;\r\n    }\r\n}","lc":0.4545454545,"pi":1.4306220096,"ma":1.0,"nbd":1.0,"ml":0.3333333333,"d":0.498015873,"mi":-0.3037350247,"fo":-0.25,"r":0.0263157895,"e":0.2250560444}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2047_a0a495f0","label":0,"code":"\/**\r\n * Copies the full content from the source to the target repository.\r\n * <p>\r\n * The source repository <strong>must not be modified<\/strong> while\r\n * the copy operation is running to avoid an inconsistent copy.\r\n * <p>\r\n * Note that both the source and the target repository must be closed\r\n * during the copy operation as this method requires exclusive access\r\n * to the repositories.\r\n *\r\n * @param initializer optional extra repository initializer to use\r\n * @throws RepositoryException if the copy operation fails\r\n *\/\r\npublic void copy(RepositoryInitializer initializer) throws RepositoryException {\r\n    RepositoryConfig config = source.getRepositoryConfig();\r\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\r\n    try {\r\n        NodeState base = target.getRoot();\r\n        NodeBuilder builder = base.builder();\r\n        String workspaceName = source.getRepositoryConfig().getDefaultWorkspaceName();\r\n        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\r\n        \/\/ init target repository first\r\n        new InitialContent().initialize(builder);\r\n        if (initializer != null) {\r\n            initializer.initialize(builder);\r\n        }\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            sc.getRepositoryInitializer().initialize(builder);\r\n        }\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            sc.getWorkspaceInitializer().initialize(builder, workspaceName);\r\n        }\r\n        HashBiMap<String, String> uriToPrefix = HashBiMap.create();\r\n        Map<Integer, String> idxToPrefix = newHashMap();\r\n        copyNamespaces(builder, uriToPrefix, idxToPrefix);\r\n        copyNodeTypes(builder, uriToPrefix.inverse());\r\n        copyPrivileges(builder);\r\n        \/\/ Triggers compilation of type information, which we need for\r\n        \/\/ the type predicates used by the bulk  copy operations below.\r\n        new TypeEditorProvider(false).getRootEditor(base, builder.getNodeState(), builder, null);\r\n        Map<String, String> versionablePaths = newHashMap();\r\n        NodeState root = builder.getNodeState();\r\n        copyWorkspace(builder, root, workspaceName, uriToPrefix, idxToPrefix, versionablePaths);\r\n        copyVersionStore(builder, root, workspaceName, uriToPrefix, idxToPrefix, versionablePaths);\r\n        logger.info(\"Applying default commit hooks\");\r\n        \/\/ TODO: default hooks?\r\n        List<CommitHook> hooks = newArrayList();\r\n        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);\r\n        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\r\n        \/\/ hooks specific to the upgrade, need to run first\r\n        hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath))));\r\n        \/\/ security-related hooks\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            hooks.addAll(sc.getCommitHooks(workspaceName));\r\n        }\r\n        \/\/ type validation, reference and indexing hooks\r\n        hooks.add(new EditorHook(new CompositeEditorProvider(createTypeEditorProvider(), createIndexEditorProvider())));\r\n        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);\r\n    } catch (Exception e) {\r\n        throw new RepositoryException(\"Failed to copy content\", e);\r\n    }\r\n}","code_comment":"\/**\r\n * Copies the full content from the source to the target repository.\r\n * <p>\r\n * The source repository <strong>must not be modified<\/strong> while\r\n * the copy operation is running to avoid an inconsistent copy.\r\n * <p>\r\n * Note that both the source and the target repository must be closed\r\n * during the copy operation as this method requires exclusive access\r\n * to the repositories.\r\n *\r\n * @param initializer optional extra repository initializer to use\r\n * @throws RepositoryException if the copy operation fails\r\n *\/\r\n","code_no_comment":"public void copy(RepositoryInitializer initializer) throws RepositoryException {\r\n    RepositoryConfig config = source.getRepositoryConfig();\r\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\r\n    try {\r\n        NodeState base = target.getRoot();\r\n        NodeBuilder builder = base.builder();\r\n        String workspaceName = source.getRepositoryConfig().getDefaultWorkspaceName();\r\n        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\r\n                new InitialContent().initialize(builder);\r\n        if (initializer != null) {\r\n            initializer.initialize(builder);\r\n        }\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            sc.getRepositoryInitializer().initialize(builder);\r\n        }\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            sc.getWorkspaceInitializer().initialize(builder, workspaceName);\r\n        }\r\n        HashBiMap<String, String> uriToPrefix = HashBiMap.create();\r\n        Map<Integer, String> idxToPrefix = newHashMap();\r\n        copyNamespaces(builder, uriToPrefix, idxToPrefix);\r\n        copyNodeTypes(builder, uriToPrefix.inverse());\r\n        copyPrivileges(builder);\r\n                        new TypeEditorProvider(false).getRootEditor(base, builder.getNodeState(), builder, null);\r\n        Map<String, String> versionablePaths = newHashMap();\r\n        NodeState root = builder.getNodeState();\r\n        copyWorkspace(builder, root, workspaceName, uriToPrefix, idxToPrefix, versionablePaths);\r\n        copyVersionStore(builder, root, workspaceName, uriToPrefix, idxToPrefix, versionablePaths);\r\n        logger.info(\"Applying default commit hooks\");\r\n                List<CommitHook> hooks = newArrayList();\r\n        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);\r\n        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\r\n                hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath))));\r\n                for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            hooks.addAll(sc.getCommitHooks(workspaceName));\r\n        }\r\n                hooks.add(new EditorHook(new CompositeEditorProvider(createTypeEditorProvider(), createIndexEditorProvider())));\r\n        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);\r\n    } catch (Exception e) {\r\n        throw new RepositoryException(\"Failed to copy content\", e);\r\n    }\r\n}","lc":1.2727272727,"pi":-0.2344497608,"ma":0.6,"nbd":0.0,"ml":-0.25,"d":0.0277777778,"mi":-0.807751938,"fo":3.0833333333,"r":-0.0263157895,"e":0.8852336578}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8137_53b4e90c","label":3,"code":"\/**\r\n * Introspects the given class\r\n *\r\n * @param clazz the class\r\n *\/\r\nprivate void introspect(Class<?> clazz) {\r\n    \/\/ get the target clazz as it could potentially have been enhanced by CGLIB etc.\r\n    clazz = getTargetClass(clazz);\r\n    ObjectHelper.notNull(clazz, \"clazz\", this);\r\n    LOG.trace(\"Introspecting class: {}\", clazz);\r\n    \/\/ favor declared methods, and then filter out duplicate interface methods\r\n    List<Method> methods;\r\n    if (Modifier.isPublic(clazz.getModifiers())) {\r\n        LOG.trace(\"Preferring class methods as class: {} is public accessible\", clazz);\r\n        methods = new ArrayList<Method>(Arrays.asList(clazz.getDeclaredMethods()));\r\n    } else {\r\n        LOG.trace(\"Preferring interface methods as class: {} is not public accessible\", clazz);\r\n        methods = getInterfaceMethods(clazz);\r\n        \/\/ and then we must add its declared methods as well\r\n        List<Method> extraMethods = Arrays.asList(clazz.getDeclaredMethods());\r\n        methods.addAll(extraMethods);\r\n    }\r\n    \/\/ it may have duplicate methods already, even from declared or from interfaces + declared\r\n    Set<Method> overrides = new HashSet<Method>();\r\n    for (Method source : methods) {\r\n        for (Method target : methods) {\r\n            \/\/ skip ourselves\r\n            if (ObjectHelper.isOverridingMethod(source, target, true)) {\r\n                continue;\r\n            }\r\n            \/\/ skip duplicates which may be assign compatible (favor keep first added method when duplicate)\r\n            if (ObjectHelper.isOverridingMethod(source, target, false)) {\r\n                overrides.add(target);\r\n            }\r\n        }\r\n    }\r\n    methods.removeAll(overrides);\r\n    overrides.clear();\r\n    \/\/ if we are a public class, then add non duplicate interface classes also\r\n    if (Modifier.isPublic(clazz.getModifiers())) {\r\n        \/\/ add additional interface methods\r\n        List<Method> extraMethods = getInterfaceMethods(clazz);\r\n        for (Method target : extraMethods) {\r\n            for (Method source : methods) {\r\n                if (ObjectHelper.isOverridingMethod(source, target, false)) {\r\n                    overrides.add(target);\r\n                }\r\n            }\r\n        }\r\n        \/\/ remove all the overrides methods\r\n        extraMethods.removeAll(overrides);\r\n        methods.addAll(extraMethods);\r\n    }\r\n    \/\/ now introspect the methods and filter non valid methods\r\n    for (Method method : methods) {\r\n        boolean valid = isValidMethod(clazz, method);\r\n        LOG.trace(\"Method: {} is valid: {}\", method, valid);\r\n        if (valid) {\r\n            introspect(clazz, method);\r\n        }\r\n    }\r\n    Class<?> superclass = clazz.getSuperclass();\r\n    if (superclass != null && !superclass.equals(Object.class)) {\r\n        introspect(superclass);\r\n    }\r\n}","code_comment":"\/**\r\n * Introspects the given class\r\n *\r\n * @param clazz the class\r\n *\/\r\n","code_no_comment":"private void introspect(Class<?> clazz) {\r\n        clazz = getTargetClass(clazz);\r\n    ObjectHelper.notNull(clazz, \"clazz\", this);\r\n    LOG.trace(\"Introspecting class: {}\", clazz);\r\n        List<Method> methods;\r\n    if (Modifier.isPublic(clazz.getModifiers())) {\r\n        LOG.trace(\"Preferring class methods as class: {} is public accessible\", clazz);\r\n        methods = new ArrayList<Method>(Arrays.asList(clazz.getDeclaredMethods()));\r\n    } else {\r\n        LOG.trace(\"Preferring interface methods as class: {} is not public accessible\", clazz);\r\n        methods = getInterfaceMethods(clazz);\r\n                List<Method> extraMethods = Arrays.asList(clazz.getDeclaredMethods());\r\n        methods.addAll(extraMethods);\r\n    }\r\n        Set<Method> overrides = new HashSet<Method>();\r\n    for (Method source : methods) {\r\n        for (Method target : methods) {\r\n                        if (ObjectHelper.isOverridingMethod(source, target, true)) {\r\n                continue;\r\n            }\r\n                        if (ObjectHelper.isOverridingMethod(source, target, false)) {\r\n                overrides.add(target);\r\n            }\r\n        }\r\n    }\r\n    methods.removeAll(overrides);\r\n    overrides.clear();\r\n        if (Modifier.isPublic(clazz.getModifiers())) {\r\n                List<Method> extraMethods = getInterfaceMethods(clazz);\r\n        for (Method target : extraMethods) {\r\n            for (Method source : methods) {\r\n                if (ObjectHelper.isOverridingMethod(source, target, false)) {\r\n                    overrides.add(target);\r\n                }\r\n            }\r\n        }\r\n                extraMethods.removeAll(overrides);\r\n        methods.addAll(extraMethods);\r\n    }\r\n        for (Method method : methods) {\r\n        boolean valid = isValidMethod(clazz, method);\r\n        LOG.trace(\"Method: {} is valid: {}\", method, valid);\r\n        if (valid) {\r\n            introspect(clazz, method);\r\n        }\r\n    }\r\n    Class<?> superclass = clazz.getSuperclass();\r\n    if (superclass != null && !superclass.equals(Object.class)) {\r\n        introspect(superclass);\r\n    }\r\n}","lc":1.6818181818,"pi":0.6172248804,"ma":2.0,"nbd":1.0,"ml":1.0,"d":0.8253968254,"mi":-0.8920366455,"fo":2.0833333333,"r":-0.0263157895,"e":2.1047976349}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Adds an element to the end of this expandable array.\r\n *\r\n * @param value Value to be added to end of array.\r\n *\/\r\n@Override\r\npublic synchronized void addElement(double value) {\r\n    if (internalArray.length <= startIndex + numElements) {\r\n        expand();\r\n    }\r\n    internalArray[startIndex + numElements++] = value;\r\n}","code_comment":"\/**\r\n * Adds an element to the end of this expandable array.\r\n *\r\n * @param value Value to be added to end of array.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic synchronized void addElement(double value) {\r\n    if (internalArray.length <= startIndex + numElements) {\r\n        expand();\r\n    }\r\n    internalArray[startIndex + numElements++] = value;\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":0.2083333333,"mi":0.4604651163,"fo":-0.4166666667,"r":2.5526315789,"e":-0.0740812457}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5724_b92591f6","label":1,"code":"@Override\r\nprotected MarkupElement onComponentTag(final ComponentTag tag) throws ParseException {\r\n    \/\/ We only need ComponentTags\r\n    if (tag instanceof WicketTag) {\r\n        return tag;\r\n    }\r\n    \/\/ Has wicket:enclosure attribute?\r\n    String enclosureAttr = getAttribute(tag, null);\r\n    if (enclosureAttr != null) {\r\n        if (tag.isOpen()) {\r\n            \/\/ Make sure 'wicket:id' and 'id' are consistent\r\n            String htmlId = tag.getAttribute(\"id\");\r\n            if ((tag.getId() != null) && !Strings.isEmpty(htmlId) && !htmlId.equals(tag.getId())) {\r\n                throw new ParseException(\"Make sure that 'id' and 'wicket:id' are the same if both are provided. Tag:\" + tag.toString(), tag.getPos());\r\n            }\r\n            \/\/ if it doesn't have a wicket-id already, then assign one now.\r\n            if (Strings.isEmpty(tag.getId())) {\r\n                if (Strings.isEmpty(htmlId)) {\r\n                    String id = getWicketNamespace() + \"_\" + INLINE_ENCLOSURE_ID_PREFIX + (counter++);\r\n                    tag.setId(id);\r\n                } else {\r\n                    tag.setId(htmlId);\r\n                }\r\n                tag.setAutoComponentTag(true);\r\n                tag.setAutoComponentFactory(new ComponentTag.IAutoComponentFactory() {\r\n\r\n                    @Override\r\n                    public Component newComponent(ComponentTag tag) {\r\n                        String attributeName = getInlineEnclosureAttributeName(null);\r\n                        String childId = tag.getAttribute(attributeName);\r\n                        return new InlineEnclosure(tag.getId(), childId);\r\n                    }\r\n                });\r\n                tag.setModified(true);\r\n            }\r\n            \/\/ Put the enclosure on the stack. The most current one will be on top\r\n            if (enclosures == null) {\r\n                enclosures = new ArrayDeque<>();\r\n            }\r\n            enclosures.push(tag);\r\n        } else {\r\n            throw new ParseException(\"Open-close tags don't make sense for InlineEnclosure. Tag:\" + tag.toString(), tag.getPos());\r\n        }\r\n    } else \/\/ Are we within an enclosure?\r\n    if ((enclosures != null) && (enclosures.size() > 0)) {\r\n        \/\/ first ComponentTag's id found as the controlling child to the enclosure.\r\n        if (tag.isOpen() && (tag.getId() != null) && !(tag instanceof WicketTag) && !tag.isAutoComponentTag()) {\r\n            Iterator<ComponentTag> componentTagIterator = enclosures.descendingIterator();\r\n            while (componentTagIterator.hasNext()) {\r\n                ComponentTag lastEnclosure = componentTagIterator.next();\r\n                String attr = getAttribute(lastEnclosure, null);\r\n                if (Strings.isEmpty(attr) == true) {\r\n                    lastEnclosure.getAttributes().put(getInlineEnclosureAttributeName(null), tag.getId());\r\n                    lastEnclosure.setModified(true);\r\n                }\r\n            }\r\n        } else if (tag.isClose() && tag.closes(enclosures.peek())) {\r\n            ComponentTag lastEnclosure = enclosures.pop();\r\n            String attr = getAttribute(lastEnclosure, null);\r\n            if (Strings.isEmpty(attr) == true) {\r\n                throw new ParseException(\"Did not find any child for InlineEnclosure. Tag:\" + lastEnclosure.toString(), tag.getPos());\r\n            }\r\n        }\r\n    }\r\n    return tag;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected MarkupElement onComponentTag(final ComponentTag tag) throws ParseException {\r\n        if (tag instanceof WicketTag) {\r\n        return tag;\r\n    }\r\n        String enclosureAttr = getAttribute(tag, null);\r\n    if (enclosureAttr != null) {\r\n        if (tag.isOpen()) {\r\n                        String htmlId = tag.getAttribute(\"id\");\r\n            if ((tag.getId() != null) && !Strings.isEmpty(htmlId) && !htmlId.equals(tag.getId())) {\r\n                throw new ParseException(\"Make sure that 'id' and 'wicket:id' are the same if both are provided. Tag:\" + tag.toString(), tag.getPos());\r\n            }\r\n                        if (Strings.isEmpty(tag.getId())) {\r\n                if (Strings.isEmpty(htmlId)) {\r\n                    String id = getWicketNamespace() + \"_\" + INLINE_ENCLOSURE_ID_PREFIX + (counter++);\r\n                    tag.setId(id);\r\n                } else {\r\n                    tag.setId(htmlId);\r\n                }\r\n                tag.setAutoComponentTag(true);\r\n                tag.setAutoComponentFactory(new ComponentTag.IAutoComponentFactory() {\r\n\r\n                    @Override\r\n                    public Component newComponent(ComponentTag tag) {\r\n                        String attributeName = getInlineEnclosureAttributeName(null);\r\n                        String childId = tag.getAttribute(attributeName);\r\n                        return new InlineEnclosure(tag.getId(), childId);\r\n                    }\r\n                });\r\n                tag.setModified(true);\r\n            }\r\n                        if (enclosures == null) {\r\n                enclosures = new ArrayDeque<>();\r\n            }\r\n            enclosures.push(tag);\r\n        } else {\r\n            throw new ParseException(\"Open-close tags don't make sense for InlineEnclosure. Tag:\" + tag.toString(), tag.getPos());\r\n        }\r\n    } else     if ((enclosures != null) && (enclosures.size() > 0)) {\r\n                if (tag.isOpen() && (tag.getId() != null) && !(tag instanceof WicketTag) && !tag.isAutoComponentTag()) {\r\n            Iterator<ComponentTag> componentTagIterator = enclosures.descendingIterator();\r\n            while (componentTagIterator.hasNext()) {\r\n                ComponentTag lastEnclosure = componentTagIterator.next();\r\n                String attr = getAttribute(lastEnclosure, null);\r\n                if (Strings.isEmpty(attr) == true) {\r\n                    lastEnclosure.getAttributes().put(getInlineEnclosureAttributeName(null), tag.getId());\r\n                    lastEnclosure.setModified(true);\r\n                }\r\n            }\r\n        } else if (tag.isClose() && tag.closes(enclosures.peek())) {\r\n            ComponentTag lastEnclosure = enclosures.pop();\r\n            String attr = getAttribute(lastEnclosure, null);\r\n            if (Strings.isEmpty(attr) == true) {\r\n                throw new ParseException(\"Did not find any child for InlineEnclosure. Tag:\" + lastEnclosure.toString(), tag.getPos());\r\n            }\r\n        }\r\n    }\r\n    return tag;\r\n}","lc":2.0454545455,"pi":1.4976076555,"ma":2.6,"nbd":1.5,"ml":2.6666666667,"d":1.9226190476,"mi":-1.0369274137,"fo":3.3333333333,"r":-0.0263157895,"e":6.3482420198}
{"project_name":"Compress","project_version":"43","label":3,"code":"private boolean usesDataDescriptor(final int zipMethod) {\r\n    return zipMethod == DEFLATED && channel == null;\r\n}","code_comment":null,"code_no_comment":"private boolean usesDataDescriptor(final int zipMethod) {\r\n    return zipMethod == DEFLATED && channel == null;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.1329365079,"mi":0.9709654686,"fo":-0.5,"r":2.5526315789,"e":-0.1466572155}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7130_cc192f87","label":1,"code":"\/**\r\n * Converts the inbound body to a {@link Source}, if the body is <b>not<\/b> already a {@link Source}.\r\n * <p\/>\r\n * This implementation will prefer to source in the following order:\r\n * <ul>\r\n *   <li>StAX - Is StAX is allowed<\/li>\r\n *   <li>SAX - SAX as 2nd choice<\/li>\r\n *   <li>Stream - Stream as 3rd choice<\/li>\r\n *   <li>DOM - DOM as 4th choice<\/li>\r\n * <\/ul>\r\n *\/\r\nprotected Source getSource(Exchange exchange, Object body) {\r\n    \/\/ body may already be a source\r\n    if (body instanceof Source) {\r\n        return (Source) body;\r\n    }\r\n    Source source = null;\r\n    if (body instanceof InputStream) {\r\n        return new StreamSource((InputStream) body);\r\n    }\r\n    if (body != null) {\r\n        if (isAllowStAX()) {\r\n            source = exchange.getContext().getTypeConverter().tryConvertTo(StAXSource.class, exchange, body);\r\n        }\r\n        if (source == null) {\r\n            \/\/ then try SAX\r\n            source = exchange.getContext().getTypeConverter().tryConvertTo(SAXSource.class, exchange, body);\r\n        }\r\n        if (source == null) {\r\n            \/\/ then try stream\r\n            source = exchange.getContext().getTypeConverter().tryConvertTo(StreamSource.class, exchange, body);\r\n        }\r\n        if (source == null) {\r\n            \/\/ and fallback to DOM\r\n            source = exchange.getContext().getTypeConverter().tryConvertTo(DOMSource.class, exchange, body);\r\n        }\r\n        \/\/ now we just put the call of source converter at last\r\n        if (source == null) {\r\n            TypeConverter tc = exchange.getContext().getTypeConverterRegistry().lookup(Source.class, body.getClass());\r\n            if (tc != null) {\r\n                source = tc.convertTo(Source.class, exchange, body);\r\n            }\r\n        }\r\n    }\r\n    if (source == null) {\r\n        if (isFailOnNullBody()) {\r\n            throw new ExpectedBodyTypeException(exchange, Source.class);\r\n        } else {\r\n            try {\r\n                source = converter.toDOMSource(converter.createDocument());\r\n            } catch (ParserConfigurationException e) {\r\n                throw new RuntimeTransformException(e);\r\n            }\r\n        }\r\n    }\r\n    return source;\r\n}","code_comment":"\/**\r\n * Converts the inbound body to a {@link Source}, if the body is <b>not<\/b> already a {@link Source}.\r\n * <p\/>\r\n * This implementation will prefer to source in the following order:\r\n * <ul>\r\n *   <li>StAX - Is StAX is allowed<\/li>\r\n *   <li>SAX - SAX as 2nd choice<\/li>\r\n *   <li>Stream - Stream as 3rd choice<\/li>\r\n *   <li>DOM - DOM as 4th choice<\/li>\r\n * <\/ul>\r\n *\/\r\n","code_no_comment":"protected Source getSource(Exchange exchange, Object body) {\r\n        if (body instanceof Source) {\r\n        return (Source) body;\r\n    }\r\n    Source source = null;\r\n    if (body instanceof InputStream) {\r\n        return new StreamSource((InputStream) body);\r\n    }\r\n    if (body != null) {\r\n        if (isAllowStAX()) {\r\n            source = exchange.getContext().getTypeConverter().tryConvertTo(StAXSource.class, exchange, body);\r\n        }\r\n        if (source == null) {\r\n                        source = exchange.getContext().getTypeConverter().tryConvertTo(SAXSource.class, exchange, body);\r\n        }\r\n        if (source == null) {\r\n                        source = exchange.getContext().getTypeConverter().tryConvertTo(StreamSource.class, exchange, body);\r\n        }\r\n        if (source == null) {\r\n                        source = exchange.getContext().getTypeConverter().tryConvertTo(DOMSource.class, exchange, body);\r\n        }\r\n                if (source == null) {\r\n            TypeConverter tc = exchange.getContext().getTypeConverterRegistry().lookup(Source.class, body.getClass());\r\n            if (tc != null) {\r\n                source = tc.convertTo(Source.class, exchange, body);\r\n            }\r\n        }\r\n    }\r\n    if (source == null) {\r\n        if (isFailOnNullBody()) {\r\n            throw new ExpectedBodyTypeException(exchange, Source.class);\r\n        } else {\r\n            try {\r\n                source = converter.toDOMSource(converter.createDocument());\r\n            } catch (ParserConfigurationException e) {\r\n                throw new RuntimeTransformException(e);\r\n            }\r\n        }\r\n    }\r\n    return source;\r\n}","lc":1.2272727273,"pi":0.4784688995,"ma":2.2,"nbd":0.5,"ml":0.9166666667,"d":0.2242063492,"mi":-0.7440451022,"fo":1.25,"r":-0.0263157895,"e":0.6094523493}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4138_eb0f9b41","label":1,"code":"\/**\r\n * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.\r\n *\r\n * @param tableName\r\n *          the table to compact\r\n * @param start\r\n *          first tablet to be compacted contains the row after this row, null means the first tablet in table\r\n * @param end\r\n *          last tablet to be merged contains this row, null means the last tablet in table\r\n * @param iterators\r\n *          A set of iterators that will be applied to each tablet compacted\r\n * @param flush\r\n *          when true, table memory is flushed before compaction starts\r\n * @param wait\r\n *          when true, the call will not return until compactions are finished\r\n * @since 1.5.0\r\n *\/\r\nvoid compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;","code_comment":"\/**\r\n * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.\r\n *\r\n * @param tableName\r\n *          the table to compact\r\n * @param start\r\n *          first tablet to be compacted contains the row after this row, null means the first tablet in table\r\n * @param end\r\n *          last tablet to be merged contains this row, null means the last tablet in table\r\n * @param iterators\r\n *          A set of iterators that will be applied to each tablet compacted\r\n * @param flush\r\n *          when true, table memory is flushed before compaction starts\r\n * @param wait\r\n *          when true, the call will not return until compactions are finished\r\n * @since 1.5.0\r\n *\/\r\n","code_no_comment":"void compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.3650458069,"fo":-0.5,"r":0.3157894737,"e":-0.1627934049}
{"project_name":"JxPath","project_version":"17","label":1,"code":"private boolean testAttr(Attr attr) {\r\n    String nodePrefix = DOMNodePointer.getPrefix(attr);\r\n    String nodeLocalName = DOMNodePointer.getLocalName(attr);\r\n    if (nodePrefix != null && nodePrefix.equals(\"xmlns\")) {\r\n        return false;\r\n    }\r\n    if (nodePrefix == null && nodeLocalName.equals(\"xmlns\")) {\r\n        return false;\r\n    }\r\n    String testLocalName = name.getName();\r\n    if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)) {\r\n        String testPrefix = name.getPrefix();\r\n        if (equalStrings(testPrefix, nodePrefix)) {\r\n            return true;\r\n        }\r\n        String testNS = null;\r\n        if (testPrefix != null) {\r\n            testNS = parent.getNamespaceURI(testPrefix);\r\n        }\r\n        String nodeNS = null;\r\n        if (nodePrefix != null) {\r\n            nodeNS = parent.getNamespaceURI(nodePrefix);\r\n        }\r\n        return equalStrings(testNS, nodeNS);\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"private boolean testAttr(Attr attr) {\r\n    String nodePrefix = DOMNodePointer.getPrefix(attr);\r\n    String nodeLocalName = DOMNodePointer.getLocalName(attr);\r\n    if (nodePrefix != null && nodePrefix.equals(\"xmlns\")) {\r\n        return false;\r\n    }\r\n    if (nodePrefix == null && nodeLocalName.equals(\"xmlns\")) {\r\n        return false;\r\n    }\r\n    String testLocalName = name.getName();\r\n    if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)) {\r\n        String testPrefix = name.getPrefix();\r\n        if (equalStrings(testPrefix, nodePrefix)) {\r\n            return true;\r\n        }\r\n        String testNS = null;\r\n        if (testPrefix != null) {\r\n            testNS = parent.getNamespaceURI(testPrefix);\r\n        }\r\n        String nodeNS = null;\r\n        if (nodePrefix != null) {\r\n            nodeNS = parent.getNamespaceURI(nodePrefix);\r\n        }\r\n        return equalStrings(testNS, nodeNS);\r\n    }\r\n    return false;\r\n}","lc":0.5909090909,"pi":0.0669856459,"ma":0.6,"nbd":0.0,"ml":1.0,"d":0.6825396825,"mi":-0.4503171247,"fo":0.5,"r":-0.0263157895,"e":0.8047232932}
{"project_name":"Cli","project_version":"1","label":1,"code":"\/**\r\n * Returns an iterator over the Option members of CommandLine.\r\n *\r\n * @return an <code>Iterator<\/code> over the processed {@link Option}\r\n * members of this {@link CommandLine}\r\n *\/\r\npublic Iterator iterator() {\r\n    return hashcodeMap.values().iterator();\r\n}","code_comment":"\/**\r\n * Returns an iterator over the Option members of CommandLine.\r\n *\r\n * @return an <code>Iterator<\/code> over the processed {@link Option}\r\n * members of this {@link CommandLine}\r\n *\/\r\n","code_no_comment":"public Iterator iterator() {\r\n    return hashcodeMap.values().iterator();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0831571529,"fo":-0.3333333333,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1333_63ef8e86","label":1,"code":"\/**\r\n *  Checks if the given field is a valid pojo field:\r\n *  - it is public\r\n *  OR\r\n *   - there are getter and setter methods for the field.\r\n *\r\n *  @param f field to check\r\n *  @param clazz class of field\r\n *  @param typeHierarchy type hierarchy for materializing generic types\r\n *  @return\r\n *\/\r\nprivate boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {\r\n    if (Modifier.isPublic(f.getModifiers())) {\r\n        return true;\r\n    } else {\r\n        boolean hasGetter = false, hasSetter = false;\r\n        final String fieldNameLow = f.getName().toLowerCase();\r\n        Type fieldType = f.getGenericType();\r\n        TypeVariable<?> fieldTypeGeneric = null;\r\n        if (fieldType instanceof TypeVariable) {\r\n            fieldTypeGeneric = (TypeVariable<?>) fieldType;\r\n            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);\r\n        }\r\n        for (Method m : clazz.getMethods()) {\r\n            \/\/ check for getter\r\n            if (\/\/ The name should be \"get<FieldName>\" or \"<fieldName>\" (for scala).\r\n            (m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) && \/\/ no arguments for the getter\r\n            m.getParameterTypes().length == 0 && \/\/ return type is same as field type (or the generic variant of it)\r\n            (m.getReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {\r\n                if (hasGetter) {\r\n                    throw new IllegalStateException(\"Detected more than one getter\");\r\n                }\r\n                hasGetter = true;\r\n            }\r\n            \/\/ check for setters (<FieldName>_$eq for scala)\r\n            if ((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) && \/\/ one parameter of the field's type\r\n            m.getParameterTypes().length == 1 && (m.getParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) && \/\/ return type is void.\r\n            m.getReturnType().equals(Void.TYPE)) {\r\n                if (hasSetter) {\r\n                    throw new IllegalStateException(\"Detected more than one setter\");\r\n                }\r\n                hasSetter = true;\r\n            }\r\n        }\r\n        if (hasGetter && hasSetter) {\r\n            return true;\r\n        } else {\r\n            if (!hasGetter) {\r\n                LOG.warn(\"Class \" + clazz + \" does not contain a getter for field \" + f.getName());\r\n            }\r\n            if (!hasSetter) {\r\n                LOG.warn(\"Class \" + clazz + \" does not contain a setter for field \" + f.getName());\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  Checks if the given field is a valid pojo field:\r\n *  - it is public\r\n *  OR\r\n *   - there are getter and setter methods for the field.\r\n *\r\n *  @param f field to check\r\n *  @param clazz class of field\r\n *  @param typeHierarchy type hierarchy for materializing generic types\r\n *  @return\r\n *\/\r\n","code_no_comment":"private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHierarchy) {\r\n    if (Modifier.isPublic(f.getModifiers())) {\r\n        return true;\r\n    } else {\r\n        boolean hasGetter = false, hasSetter = false;\r\n        final String fieldNameLow = f.getName().toLowerCase();\r\n        Type fieldType = f.getGenericType();\r\n        TypeVariable<?> fieldTypeGeneric = null;\r\n        if (fieldType instanceof TypeVariable) {\r\n            fieldTypeGeneric = (TypeVariable<?>) fieldType;\r\n            fieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) fieldType);\r\n        }\r\n        for (Method m : clazz.getMethods()) {\r\n                        if (            (m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&             m.getParameterTypes().length == 0 &&             (m.getReturnType().equals(fieldType) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)))) {\r\n                if (hasGetter) {\r\n                    throw new IllegalStateException(\"Detected more than one getter\");\r\n                }\r\n                hasGetter = true;\r\n            }\r\n                        if ((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) &&             m.getParameterTypes().length == 1 && (m.getParameterTypes()[0].equals(fieldType) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric))) &&             m.getReturnType().equals(Void.TYPE)) {\r\n                if (hasSetter) {\r\n                    throw new IllegalStateException(\"Detected more than one setter\");\r\n                }\r\n                hasSetter = true;\r\n            }\r\n        }\r\n        if (hasGetter && hasSetter) {\r\n            return true;\r\n        } else {\r\n            if (!hasGetter) {\r\n                LOG.warn(\"Class \" + clazz + \" does not contain a getter for field \" + f.getName());\r\n            }\r\n            if (!hasSetter) {\r\n                LOG.warn(\"Class \" + clazz + \" does not contain a setter for field \" + f.getName());\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n}","lc":1.3636363636,"pi":0.7033492823,"ma":1.8,"nbd":1.0,"ml":2.75,"d":1.2063492063,"mi":-0.8407329105,"fo":2.4166666667,"r":-0.0263157895,"e":3.3301014851}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public setTableProperty_result getResult(I iface, setTableProperty_args args) throws org.apache.thrift.TException {\r\n    setTableProperty_result result = new setTableProperty_result();\r\n    try {\r\n        iface.setTableProperty(args.login, args.tableName, args.property, args.value);\r\n    } catch (AccumuloException ouch1) {\r\n        result.ouch1 = ouch1;\r\n    } catch (AccumuloSecurityException ouch2) {\r\n        result.ouch2 = ouch2;\r\n    }\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"public setTableProperty_result getResult(I iface, setTableProperty_args args) throws org.apache.thrift.TException {\r\n    setTableProperty_result result = new setTableProperty_result();\r\n    try {\r\n        iface.setTableProperty(args.login, args.tableName, args.property, args.value);\r\n    } catch (AccumuloException ouch1) {\r\n        result.ouch1 = ouch1;\r\n    } catch (AccumuloSecurityException ouch2) {\r\n        result.ouch2 = ouch2;\r\n    }\r\n    return result;\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.1106412967,"fo":-0.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Math","project_version":"28","label":1,"code":"\/**\r\n * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\r\n * @param tableau simple tableau for the problem\r\n * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\r\n * @return row with the minimum ratio\r\n *\/\r\nprivate Integer getPivotRow(SimplexTableau tableau, final int col) {\r\n    \/\/ create a list of all the rows that tie for the lowest score in the minimum ratio test\r\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\r\n    double minRatio = Double.MAX_VALUE;\r\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\r\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\r\n        final double entry = tableau.getEntry(i, col);\r\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\r\n            final double ratio = rhs \/ entry;\r\n            \/\/ check if the entry is strictly equal to the current min ratio\r\n            \/\/ do not use a ulp\/epsilon check\r\n            final int cmp = Double.compare(ratio, minRatio);\r\n            if (cmp == 0) {\r\n                minRatioPositions.add(i);\r\n            } else if (cmp < 0) {\r\n                minRatio = ratio;\r\n                minRatioPositions = new ArrayList<Integer>();\r\n                minRatioPositions.add(i);\r\n            }\r\n        }\r\n    }\r\n    if (minRatioPositions.size() == 0) {\r\n        return null;\r\n    } else if (minRatioPositions.size() > 1) {\r\n        \/\/ 1. check if there's an artificial variable that can be forced out of the basis\r\n        for (Integer row : minRatioPositions) {\r\n            for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\r\n                int column = i + tableau.getArtificialVariableOffset();\r\n                final double entry = tableau.getEntry(row, column);\r\n                if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\r\n                    return row;\r\n                }\r\n            }\r\n        }\r\n        \/\/ 2. apply Bland's rule to prevent cycling:\r\n        \/\/ take the row for which the corresponding basic variable has the smallest index\r\n        \/\/ \r\n        \/\/ see http:\/\/www.stanford.edu\/class\/msande310\/blandrule.pdf\r\n        \/\/ see http:\/\/en.wikipedia.org\/wiki\/Bland%27s_rule (not equivalent to the above paper)\r\n        \/\/ \r\n        \/\/ Additional heuristic: if we did not get a solution after half of maxIterations\r\n        \/\/ revert to the simple case of just returning the top-most row\r\n        \/\/ This heuristic is based on empirical data gathered while investigating MATH-828.\r\n        Integer minRow = null;\r\n        int minIndex = tableau.getWidth();\r\n        for (Integer row : minRatioPositions) {\r\n            int i = tableau.getNumObjectiveFunctions();\r\n            for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\r\n                if (row == tableau.getBasicRow(i)) {\r\n                    if (i < minIndex) {\r\n                        minIndex = i;\r\n                        minRow = row;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return minRow;\r\n    }\r\n    return minRatioPositions.get(0);\r\n}","code_comment":"\/**\r\n * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\r\n * @param tableau simple tableau for the problem\r\n * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\r\n * @return row with the minimum ratio\r\n *\/\r\n","code_no_comment":"private Integer getPivotRow(SimplexTableau tableau, final int col) {\r\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\r\n    double minRatio = Double.MAX_VALUE;\r\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\r\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\r\n        final double entry = tableau.getEntry(i, col);\r\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\r\n            final double ratio = rhs \/ entry;\r\n                                    final int cmp = Double.compare(ratio, minRatio);\r\n            if (cmp == 0) {\r\n                minRatioPositions.add(i);\r\n            } else if (cmp < 0) {\r\n                minRatio = ratio;\r\n                minRatioPositions = new ArrayList<Integer>();\r\n                minRatioPositions.add(i);\r\n            }\r\n        }\r\n    }\r\n    if (minRatioPositions.size() == 0) {\r\n        return null;\r\n    } else if (minRatioPositions.size() > 1) {\r\n                for (Integer row : minRatioPositions) {\r\n            for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\r\n                int column = i + tableau.getArtificialVariableOffset();\r\n                final double entry = tableau.getEntry(row, column);\r\n                if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\r\n                    return row;\r\n                }\r\n            }\r\n        }\r\n                                                                                Integer minRow = null;\r\n        int minIndex = tableau.getWidth();\r\n        for (Integer row : minRatioPositions) {\r\n            int i = tableau.getNumObjectiveFunctions();\r\n            for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\r\n                if (row == tableau.getBasicRow(i)) {\r\n                    if (i < minIndex) {\r\n                        minIndex = i;\r\n                        minRow = row;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return minRow;\r\n    }\r\n    return minRatioPositions.get(0);\r\n}","lc":1.5,"pi":1.3444976077,"ma":2.0,"nbd":2.0,"ml":2.0833333333,"d":2.8055555556,"mi":-0.8768146582,"fo":1.3333333333,"r":-0.0263157895,"e":6.8560986152}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3395_8433e6db","label":3,"code":"\/**\r\n * Creates a new instance and copies from the current message exchange so that it can be\r\n * forwarded to another destination as a new instance. Unlike regular copy this operation\r\n * will not share the same {@link org.apache.camel.spi.UnitOfWork} so its should be used\r\n * for async messaging, where the original and copied exchange are independent.\r\n *\r\n * @param exchange original copy of the exchange\r\n * @param handover whether the on completion callbacks should be handed over to the new copy.\r\n *\/\r\npublic static Exchange createCorrelatedCopy(Exchange exchange, boolean handover) {\r\n    Exchange copy = exchange.copy();\r\n    \/\/ do not share the unit of work\r\n    copy.setUnitOfWork(null);\r\n    \/\/ hand over on completion to the copy if we got any\r\n    UnitOfWork uow = exchange.getUnitOfWork();\r\n    if (handover && uow != null) {\r\n        uow.handoverSynchronization(copy);\r\n    }\r\n    \/\/ set a correlation id so we can track back the original exchange\r\n    copy.setProperty(Exchange.CORRELATION_ID, exchange.getExchangeId());\r\n    return copy;\r\n}","code_comment":"\/**\r\n * Creates a new instance and copies from the current message exchange so that it can be\r\n * forwarded to another destination as a new instance. Unlike regular copy this operation\r\n * will not share the same {@link org.apache.camel.spi.UnitOfWork} so its should be used\r\n * for async messaging, where the original and copied exchange are independent.\r\n *\r\n * @param exchange original copy of the exchange\r\n * @param handover whether the on completion callbacks should be handed over to the new copy.\r\n *\/\r\n","code_no_comment":"public static Exchange createCorrelatedCopy(Exchange exchange, boolean handover) {\r\n    Exchange copy = exchange.copy();\r\n        copy.setUnitOfWork(null);\r\n        UnitOfWork uow = exchange.getUnitOfWork();\r\n    if (handover && uow != null) {\r\n        uow.handoverSynchronization(copy);\r\n    }\r\n        copy.setProperty(Exchange.CORRELATION_ID, exchange.getExchangeId());\r\n    return copy;\r\n}","lc":-0.1818181818,"pi":-0.4019138756,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":0.0317460317,"mi":0.1870331219,"fo":0.0,"r":0.0,"e":-0.0320672188}
{"project_name":"Lang","project_version":"64","label":1,"code":"\/**\r\n * <p>Tests for order.<\/p>\r\n *\r\n * <p>The default ordering is numeric by value, but this\r\n * can be overridden by subclasses.<\/p>\r\n *\r\n * <p>NOTE: From v2.2 the enums must be of the same type.\r\n * If the parameter is in a different class loader than this instance,\r\n * reflection is used to compare the values.<\/p>\r\n *\r\n * @see java.lang.Comparable#compareTo(Object)\r\n * @param other  the other object to compare to\r\n * @return -ve if this is less than the other object, +ve if greater than,\r\n *  <code>0<\/code> of equal\r\n * @throws ClassCastException if other is not an <code>Enum<\/code>\r\n * @throws NullPointerException if other is <code>null<\/code>\r\n *\/\r\npublic int compareTo(Object other) {\r\n    return iValue - ((ValuedEnum) other).iValue;\r\n}","code_comment":"\/**\r\n * <p>Tests for order.<\/p>\r\n *\r\n * <p>The default ordering is numeric by value, but this\r\n * can be overridden by subclasses.<\/p>\r\n *\r\n * <p>NOTE: From v2.2 the enums must be of the same type.\r\n * If the parameter is in a different class loader than this instance,\r\n * reflection is used to compare the values.<\/p>\r\n *\r\n * @see java.lang.Comparable#compareTo(Object)\r\n * @param other  the other object to compare to\r\n * @return -ve if this is less than the other object, +ve if greater than,\r\n *  <code>0<\/code> of equal\r\n * @throws ClassCastException if other is not an <code>Enum<\/code>\r\n * @throws NullPointerException if other is <code>null<\/code>\r\n *\/\r\n","code_no_comment":"public int compareTo(Object other) {\r\n    return iValue - ((ValuedEnum) other).iValue;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9960535588,"fo":-0.5,"r":0.5263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6810_6b210169","label":3,"code":"\/**\r\n * Returns true if this method is covariant with the specified method\r\n * (this method may above or below the specified method in the class hierarchy)\r\n * @param method\r\n * @return\r\n *\/\r\npublic boolean isCovariantWith(MethodInfo method) {\r\n    return method.getMethod().getName().equals(this.getMethod().getName()) && (method.getMethod().getReturnType().isAssignableFrom(this.getMethod().getReturnType()) || this.getMethod().getReturnType().isAssignableFrom(method.getMethod().getReturnType())) && Arrays.deepEquals(method.getMethod().getParameterTypes(), this.getMethod().getParameterTypes());\r\n}","code_comment":"\/**\r\n * Returns true if this method is covariant with the specified method\r\n * (this method may above or below the specified method in the class hierarchy)\r\n * @param method\r\n * @return\r\n *\/\r\n","code_no_comment":"public boolean isCovariantWith(MethodInfo method) {\r\n    return method.getMethod().getName().equals(this.getMethod().getName()) && (method.getMethod().getReturnType().isAssignableFrom(this.getMethod().getReturnType()) || this.getMethod().getReturnType().isAssignableFrom(method.getMethod().getReturnType())) && Arrays.deepEquals(method.getMethod().getParameterTypes(), this.getMethod().getParameterTypes());\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":0.1150793651,"mi":0.7699788584,"fo":1.1666666667,"r":-0.0263157895,"e":-0.0312926817}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2147_a1556c30","label":1,"code":"\/**\r\n * short-cut for using NodeBuilder. See {@code getNext(NodeState)}\r\n *\/\r\nstatic String getPropertyNext(@Nonnull final NodeBuilder node, final int lane) {\r\n    checkNotNull(node);\r\n    String next = \"\";\r\n    PropertyState ps = node.getProperty(NEXT);\r\n    if (ps != null) {\r\n        if (ps.isArray()) {\r\n            next = ps.getValue(Type.STRING, Math.min(ps.count() - 1, lane));\r\n        } else {\r\n            next = ps.getValue(Type.STRING);\r\n        }\r\n    }\r\n    return next;\r\n}","code_comment":"\/**\r\n * short-cut for using NodeBuilder. See {@code getNext(NodeState)}\r\n *\/\r\n","code_no_comment":"static String getPropertyNext(@Nonnull final NodeBuilder node, final int lane) {\r\n    checkNotNull(node);\r\n    String next = \"\";\r\n    PropertyState ps = node.getProperty(NEXT);\r\n    if (ps != null) {\r\n        if (ps.isArray()) {\r\n            next = ps.getValue(Type.STRING, Math.min(ps.count() - 1, lane));\r\n        } else {\r\n            next = ps.getValue(Type.STRING);\r\n        }\r\n    }\r\n    return next;\r\n}","lc":-0.0454545455,"pi":0.3349282297,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0376984127,"mi":0.0052149401,"fo":0.0833333333,"r":0.1578947368,"e":-0.0052580926}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-370_495f04bc","label":3,"code":"\/**\r\n * Returns true iff they are equal as defined by\r\n * {@link #equals(double,double,int) this method}.\r\n *\r\n * @param x first value\r\n * @param y second value\r\n * @return {@code true} if the values are equal.\r\n * @deprecated This method considers that {@code NaN == NaN}. In release\r\n * 3.0, the semantics will change in order to comply with IEEE754 where it\r\n * is specified that {@code NaN != NaN}.\r\n * New methods have been added for those cases wher the old semantics is\r\n * useful (see e.g. {@link #equalsIncludingNaN(double,double)\r\n * equalsIncludingNaN}.\r\n *\/\r\npublic static boolean equals(double x, double y) {\r\n    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\r\n}","code_comment":"\/**\r\n * Returns true iff they are equal as defined by\r\n * {@link #equals(double,double,int) this method}.\r\n *\r\n * @param x first value\r\n * @param y second value\r\n * @return {@code true} if the values are equal.\r\n * @deprecated This method considers that {@code NaN == NaN}. In release\r\n * 3.0, the semantics will change in order to comply with IEEE754 where it\r\n * is specified that {@code NaN != NaN}.\r\n * New methods have been added for those cases wher the old semantics is\r\n * useful (see e.g. {@link #equalsIncludingNaN(double,double)\r\n * equalsIncludingNaN}.\r\n *\/\r\n","code_no_comment":"public static boolean equals(double x, double y) {\r\n    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":0.0317460317,"mi":0.9033121917,"fo":-0.3333333333,"r":1.5789473684,"e":-0.118949073}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3324_5f863af6","label":1,"code":"@Override\r\npublic boolean apply(@Nullable PermissionEntry entry) {\r\n    if (entry == null) {\r\n        return false;\r\n    }\r\n    if (tree != null) {\r\n        return entry.matches(tree, property) || applyToParent(entry);\r\n    } else if (path != null) {\r\n        return entry.matches(path) || applyToParent(entry);\r\n    } else {\r\n        return entry.matches();\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean apply(@Nullable PermissionEntry entry) {\r\n    if (entry == null) {\r\n        return false;\r\n    }\r\n    if (tree != null) {\r\n        return entry.matches(tree, property) || applyToParent(entry);\r\n    } else if (path != null) {\r\n        return entry.matches(path) || applyToParent(entry);\r\n    } else {\r\n        return entry.matches();\r\n    }\r\n}","lc":-0.0454545455,"pi":-0.033492823,"ma":0.0,"nbd":0.0,"ml":0.0833333333,"d":0.0317460317,"mi":0.073713883,"fo":-0.0833333333,"r":0.1315789474,"e":-0.0484569769}
{"project_name":"Closure","project_version":"41","label":2,"code":"\/**\r\n * Infer the parameter and return types of a function from\r\n * the parameter and return types of the function it is overriding.\r\n *\r\n * @param oldType The function being overridden. Does nothing if this is null.\r\n * @param paramsParent The LP node of the function that we're assigning to.\r\n *     If null, that just means we're not initializing this to a function\r\n *     literal.\r\n *\/\r\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\r\n    if (oldType == null) {\r\n        return this;\r\n    }\r\n    returnType = oldType.getReturnType();\r\n    returnTypeInferred = oldType.isReturnTypeInferred();\r\n    if (paramsParent == null) {\r\n        \/\/ Not a function literal.\r\n        parametersNode = oldType.getParametersNode();\r\n        if (parametersNode == null) {\r\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\r\n        }\r\n    } else {\r\n        \/\/ We're overriding with a function literal. Apply type information\r\n        \/\/ to each parameter of the literal.\r\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\r\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\r\n        boolean warnedAboutArgList = false;\r\n        boolean oldParamsListHitOptArgs = false;\r\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\r\n            if (oldParams.hasNext()) {\r\n                Node oldParam = oldParams.next();\r\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\r\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\r\n                \/\/ arguments.\r\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\r\n                    newParam.setVarArgs(false);\r\n                    newParam.setOptionalArg(true);\r\n                }\r\n            } else {\r\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\r\n            }\r\n        }\r\n        \/\/ Clone any remaining params that aren't in the function literal.\r\n        parametersNode = paramBuilder.build();\r\n    }\r\n    return this;\r\n}","code_comment":"\/**\r\n * Infer the parameter and return types of a function from\r\n * the parameter and return types of the function it is overriding.\r\n *\r\n * @param oldType The function being overridden. Does nothing if this is null.\r\n * @param paramsParent The LP node of the function that we're assigning to.\r\n *     If null, that just means we're not initializing this to a function\r\n *     literal.\r\n *\/\r\n","code_no_comment":"FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\r\n    if (oldType == null) {\r\n        return this;\r\n    }\r\n    returnType = oldType.getReturnType();\r\n    returnTypeInferred = oldType.isReturnTypeInferred();\r\n    if (paramsParent == null) {\r\n                parametersNode = oldType.getParametersNode();\r\n        if (parametersNode == null) {\r\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\r\n        }\r\n    } else {\r\n                        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\r\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\r\n        boolean warnedAboutArgList = false;\r\n        boolean oldParamsListHitOptArgs = false;\r\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\r\n            if (oldParams.hasNext()) {\r\n                Node oldParam = oldParams.next();\r\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\r\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\r\n                                if (currentParam.getNext() != null && newParam.isVarArgs()) {\r\n                    newParam.setVarArgs(false);\r\n                    newParam.setOptionalArg(true);\r\n                }\r\n            } else {\r\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\r\n            }\r\n        }\r\n                parametersNode = paramBuilder.build();\r\n    }\r\n    return this;\r\n}","lc":0.8636363636,"pi":1.1291866029,"ma":0.6,"nbd":1.0,"ml":0.75,"d":0.9047619048,"mi":-0.6194503171,"fo":1.3333333333,"r":-0.0263157895,"e":1.8289287299}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-290_b01fcc31","label":1,"code":"\/**\r\n * Get new versions of the constraints which have positive right hand sides.\r\n * @return new versions of the constraints\r\n *\/\r\npublic List<LinearConstraint> getNormalizedConstraints() {\r\n    List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();\r\n    for (LinearConstraint constraint : constraints) {\r\n        normalized.add(normalize(constraint));\r\n    }\r\n    return normalized;\r\n}","code_comment":"\/**\r\n * Get new versions of the constraints which have positive right hand sides.\r\n * @return new versions of the constraints\r\n *\/\r\n","code_no_comment":"public List<LinearConstraint> getNormalizedConstraints() {\r\n    List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();\r\n    for (LinearConstraint constraint : constraints) {\r\n        normalized.add(normalize(constraint));\r\n    }\r\n    return normalized;\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4703312192,"fo":-0.3333333333,"r":2.0789473684,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-4011_cbffff59","label":3,"code":"\/**\r\n * Returns the converted value, or null if the value is null\r\n *\/\r\n@Converter\r\npublic static Float toFloat(Object value) {\r\n    if (value instanceof Float) {\r\n        return (Float) value;\r\n    } else if (value instanceof Number) {\r\n        Number number = (Number) value;\r\n        return number.floatValue();\r\n    } else if (value instanceof String) {\r\n        return Float.valueOf((String) value);\r\n    } else {\r\n        return null;\r\n    }\r\n}","code_comment":"\/**\r\n * Returns the converted value, or null if the value is null\r\n *\/\r\n","code_no_comment":"@Converter\r\npublic static Float toFloat(Object value) {\r\n    if (value instanceof Float) {\r\n        return (Float) value;\r\n    } else if (value instanceof Number) {\r\n        Number number = (Number) value;\r\n        return number.floatValue();\r\n    } else if (value instanceof String) {\r\n        return Float.valueOf((String) value);\r\n    } else {\r\n        return null;\r\n    }\r\n}","lc":-0.0454545455,"pi":0.043062201,"ma":0.0,"nbd":0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.1109231853,"fo":-0.3333333333,"r":0.2368421053,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1287_14849e22","label":1,"code":"\/**\r\n * Writes a list record containing the given list of record identifiers.\r\n *\r\n * @param list list of record identifiers\r\n * @return list record identifier\r\n *\/\r\npublic RecordId writeList(List<RecordId> list) {\r\n    checkNotNull(list);\r\n    checkArgument(list.size() > 0);\r\n    List<RecordId> thisLevel = list;\r\n    while (thisLevel.size() > 1) {\r\n        List<RecordId> nextLevel = Lists.newArrayList();\r\n        for (List<RecordId> bucket : Lists.partition(thisLevel, ListRecord.LEVEL_SIZE)) {\r\n            nextLevel.add(writeListBucket(bucket));\r\n        }\r\n        thisLevel = nextLevel;\r\n    }\r\n    return thisLevel.iterator().next();\r\n}","code_comment":"\/**\r\n * Writes a list record containing the given list of record identifiers.\r\n *\r\n * @param list list of record identifiers\r\n * @return list record identifier\r\n *\/\r\n","code_no_comment":"public RecordId writeList(List<RecordId> list) {\r\n    checkNotNull(list);\r\n    checkArgument(list.size() > 0);\r\n    List<RecordId> thisLevel = list;\r\n    while (thisLevel.size() > 1) {\r\n        List<RecordId> nextLevel = Lists.newArrayList();\r\n        for (List<RecordId> bucket : Lists.partition(thisLevel, ListRecord.LEVEL_SIZE)) {\r\n            nextLevel.add(writeListBucket(bucket));\r\n        }\r\n        thisLevel = nextLevel;\r\n    }\r\n    return thisLevel.iterator().next();\r\n}","lc":-0.0454545455,"pi":0.1435406699,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":0.003968254,"mi":0.0023960536,"fo":0.3333333333,"r":0.0,"e":0.0184206128}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3013_eabb4066","label":1,"code":"@Override\r\npublic void setLimit(long limit) {\r\n    this.limit = limit;\r\n    left.setLimit(limit);\r\n    right.setLimit(limit);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void setLimit(long limit) {\r\n    this.limit = limit;\r\n    left.setLimit(limit);\r\n    right.setLimit(limit);\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6256518675,"fo":-0.3333333333,"r":0.2894736842,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1363_69b68890","label":0,"code":"private void updateSubject(@Nonnull TokenCredentials tc, @Nonnull AuthInfo authInfo, @Nullable Set<? extends Principal> principals) {\r\n    if (!subject.isReadOnly()) {\r\n        subject.getPublicCredentials().add(tc);\r\n        if (principals != null) {\r\n            subject.getPrincipals().addAll(principals);\r\n        }\r\n        \/\/ replace all existing auth-info\r\n        Set<AuthInfo> ais = subject.getPublicCredentials(AuthInfo.class);\r\n        if (!ais.isEmpty()) {\r\n            subject.getPublicCredentials().removeAll(ais);\r\n        }\r\n        subject.getPublicCredentials().add(authInfo);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void updateSubject(@Nonnull TokenCredentials tc, @Nonnull AuthInfo authInfo, @Nullable Set<? extends Principal> principals) {\r\n    if (!subject.isReadOnly()) {\r\n        subject.getPublicCredentials().add(tc);\r\n        if (principals != null) {\r\n            subject.getPrincipals().addAll(principals);\r\n        }\r\n                Set<AuthInfo> ais = subject.getPublicCredentials(AuthInfo.class);\r\n        if (!ais.isEmpty()) {\r\n            subject.getPublicCredentials().removeAll(ais);\r\n        }\r\n        subject.getPublicCredentials().add(authInfo);\r\n    }\r\n}","lc":-0.0454545455,"pi":0.3110047847,"ma":0.0,"nbd":0.0,"ml":0.0833333333,"d":0.0119047619,"mi":0.0023960536,"fo":0.4166666667,"r":0.0,"e":0.0143635138}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2734_8b40bb7a","label":0,"code":"\/\/ TODO:fix cluster default parallelism\r\n\/**\r\n *  Creates a {@link RemoteStreamEnvironment}. The remote environment sends\r\n *  (parts of) the program to a cluster for execution. Note that all file\r\n *  paths used in the program must be accessible from the cluster. The\r\n *  execution will use no parallelism, unless the parallelism is set\r\n *  explicitly via {@link #setParallelism}.\r\n *\r\n *  @param host\r\n *  \t\tThe host name or address of the master (JobManager), where the\r\n *  \t\tprogram should be executed.\r\n *  @param port\r\n *  \t\tThe port of the master (JobManager), where the program should\r\n *  \t\tbe executed.\r\n *  @param jarFiles\r\n *  \t\tThe JAR files with code that needs to be shipped to the\r\n *  \t\tcluster. If the program uses user-defined functions,\r\n *  \t\tuser-defined input formats, or any libraries, those must be\r\n *  \t\tprovided in the JAR files.\r\n *  @return A remote environment that executes the program on a cluster.\r\n *\/\r\npublic static StreamExecutionEnvironment createRemoteEnvironment(String host, int port, String... jarFiles) {\r\n    RemoteStreamEnvironment env = new RemoteStreamEnvironment(host, port, jarFiles);\r\n    return env;\r\n}","code_comment":"\/**\r\n *  Creates a {@link RemoteStreamEnvironment}. The remote environment sends\r\n *  (parts of) the program to a cluster for execution. Note that all file\r\n *  paths used in the program must be accessible from the cluster. The\r\n *  execution will use no parallelism, unless the parallelism is set\r\n *  explicitly via {@link #setParallelism}.\r\n *\r\n *  @param host\r\n *  \t\tThe host name or address of the master (JobManager), where the\r\n *  \t\tprogram should be executed.\r\n *  @param port\r\n *  \t\tThe port of the master (JobManager), where the program should\r\n *  \t\tbe executed.\r\n *  @param jarFiles\r\n *  \t\tThe JAR files with code that needs to be shipped to the\r\n *  \t\tcluster. If the program uses user-defined functions,\r\n *  \t\tuser-defined input formats, or any libraries, those must be\r\n *  \t\tprovided in the JAR files.\r\n *  @return A remote environment that executes the program on a cluster.\r\n *\/\r\n","code_no_comment":"public static StreamExecutionEnvironment createRemoteEnvironment(String host, int port, String... jarFiles) {\r\n    RemoteStreamEnvironment env = new RemoteStreamEnvironment(host, port, jarFiles);\r\n    return env;\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.755602537,"fo":-0.5,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Cli","project_version":"18","label":1,"code":"\/**\r\n * <p>If an {@link Option} exists for <code>token<\/code> then\r\n * set the current option and add the token to the processed\r\n * list.<\/p>\r\n *\r\n * <p>If an {@link Option} does not exist and <code>stopAtNonOption<\/code>\r\n * is set then ignore the current token and add the remaining tokens\r\n * to the processed tokens list directly.<\/p>\r\n *\r\n * @param token The current option token\r\n * @param stopAtNonOption Specifies whether flattening should halt\r\n * at the first non option.\r\n *\/\r\nprivate void processOptionToken(String token, boolean stopAtNonOption) {\r\n    if (options.hasOption(token)) {\r\n        currentOption = options.getOption(token);\r\n        tokens.add(token);\r\n    } else if (stopAtNonOption) {\r\n        eatTheRest = true;\r\n    }\r\n}","code_comment":"\/**\r\n * <p>If an {@link Option} exists for <code>token<\/code> then\r\n * set the current option and add the token to the processed\r\n * list.<\/p>\r\n *\r\n * <p>If an {@link Option} does not exist and <code>stopAtNonOption<\/code>\r\n * is set then ignore the current token and add the remaining tokens\r\n * to the processed tokens list directly.<\/p>\r\n *\r\n * @param token The current option token\r\n * @param stopAtNonOption Specifies whether flattening should halt\r\n * at the first non option.\r\n *\/\r\n","code_no_comment":"private void processOptionToken(String token, boolean stopAtNonOption) {\r\n    if (options.hasOption(token)) {\r\n        currentOption = options.getOption(token);\r\n        tokens.add(token);\r\n    } else if (stopAtNonOption) {\r\n        eatTheRest = true;\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":-0.3650793651,"mi":0.3733615222,"fo":-0.25,"r":0.2631578947,"e":-0.1627934049}
{"project_name":"Math","project_version":"99","label":3,"code":"\/**\r\n * <p>\r\n * Returns the least common multiple of the absolute value of two numbers,\r\n * using the formula <code>lcm(a,b) = (a \/ gcd(a,b)) * b<\/code>.\r\n * <\/p>\r\n * Special cases:\r\n * <ul>\r\n * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)<\/code> and\r\n * <code>lcm(n, Integer.MIN_VALUE)<\/code>, where <code>abs(n)<\/code> is a\r\n * power of 2, throw an <code>ArithmeticException<\/code>, because the result\r\n * would be 2^31, which is too large for an int value.<\/li>\r\n * <li>The result of <code>lcm(0, x)<\/code> and <code>lcm(x, 0)<\/code> is\r\n * <code>0<\/code> for any <code>x<\/code>.\r\n * <\/ul>\r\n *\r\n * @param a any number\r\n * @param b any number\r\n * @return the least common multiple, never negative\r\n * @throws ArithmeticException\r\n *             if the result cannot be represented as a nonnegative int\r\n *             value\r\n * @since 1.1\r\n *\/\r\npublic static int lcm(int a, int b) {\r\n    if (a == 0 || b == 0) {\r\n        return 0;\r\n    }\r\n    int lcm = Math.abs(mulAndCheck(a \/ gcd(a, b), b));\r\n    return lcm;\r\n}","code_comment":"\/**\r\n * <p>\r\n * Returns the least common multiple of the absolute value of two numbers,\r\n * using the formula <code>lcm(a,b) = (a \/ gcd(a,b)) * b<\/code>.\r\n * <\/p>\r\n * Special cases:\r\n * <ul>\r\n * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)<\/code> and\r\n * <code>lcm(n, Integer.MIN_VALUE)<\/code>, where <code>abs(n)<\/code> is a\r\n * power of 2, throw an <code>ArithmeticException<\/code>, because the result\r\n * would be 2^31, which is too large for an int value.<\/li>\r\n * <li>The result of <code>lcm(0, x)<\/code> and <code>lcm(x, 0)<\/code> is\r\n * <code>0<\/code> for any <code>x<\/code>.\r\n * <\/ul>\r\n *\r\n * @param a any number\r\n * @param b any number\r\n * @return the least common multiple, never negative\r\n * @throws ArithmeticException\r\n *             if the result cannot be represented as a nonnegative int\r\n *             value\r\n * @since 1.1\r\n *\/\r\n","code_no_comment":"public static int lcm(int a, int b) {\r\n    if (a == 0 || b == 0) {\r\n        return 0;\r\n    }\r\n    int lcm = Math.abs(mulAndCheck(a \/ gcd(a, b), b));\r\n    return lcm;\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":0.4722222222,"mi":0.4184637068,"fo":-0.25,"r":-0.0263157895,"e":0.0100851184}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2426_920f32d0","label":1,"code":"@Override\r\npublic void collectResults(NodeInclude rootInclude, String rootIncludePath, String nodePath, NodeState nodeState, ResultCollector results) throws CommitFailedException {\r\n    \/\/ For supporting jcr:contains(jcr:content, 'foo')\r\n    if (rootInclude != this && rootInclude.relativeNode) {\r\n        results.onResult(new NodeIncludeResult(nodePath, rootIncludePath, nodeState));\r\n    }\r\n    \/\/ For supporting jcr:contains(., 'foo')\r\n    results.onResult(new NodeIncludeResult(nodePath, nodeState));\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void collectResults(NodeInclude rootInclude, String rootIncludePath, String nodePath, NodeState nodeState, ResultCollector results) throws CommitFailedException {\r\n        if (rootInclude != this && rootInclude.relativeNode) {\r\n        results.onResult(new NodeIncludeResult(nodePath, rootIncludePath, nodeState));\r\n    }\r\n        results.onResult(new NodeIncludeResult(nodePath, nodeState));\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0178571429,"mi":0.3680056378,"fo":-0.3333333333,"r":0.0263157895,"e":-0.0618638451}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7163_5f726d0b","label":1,"code":"public void setMessageBodyOnBreakpoint(String nodeId, String body) {\r\n    backlogDebugger.setMessageBodyOnBreakpoint(nodeId, body);\r\n}","code_comment":null,"code_no_comment":"public void setMessageBodyOnBreakpoint(String nodeId, String body) {\r\n    backlogDebugger.setMessageBodyOnBreakpoint(nodeId, body);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.992670895,"fo":-0.4166666667,"r":0.2368421053,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2359_b3071839","label":0,"code":"@Override\r\npublic boolean containsKey(Object key) {\r\n    \/\/ the values map does not have null values\r\n    return get(key) != null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean containsKey(Object key) {\r\n        return get(key) != null;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8548273432,"fo":-0.4166666667,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-71_2afe3dff","label":1,"code":"\/**\r\n * Rename file.\r\n *\r\n * @param source           current file name.\r\n * @param destination      new file name.\r\n * @param renameEmptyFiles if true, rename file even if empty, otherwise delete empty files.\r\n * @return true if successfully renamed.\r\n *\/\r\npublic static boolean execute(final File source, final File destination, boolean renameEmptyFiles) {\r\n    if (renameEmptyFiles || (source.length() > 0)) {\r\n        try {\r\n            boolean result = source.renameTo(destination);\r\n            \/\/ System.out.println(\"Rename of \" + source.getName() + \" to \" + destination.getName() + \": \" + result);\r\n            return result;\r\n        } catch (Exception ex) {\r\n            try {\r\n                copyFile(source, destination);\r\n                return source.delete();\r\n            } catch (IOException iex) {\r\n                iex.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":"\/**\r\n * Rename file.\r\n *\r\n * @param source           current file name.\r\n * @param destination      new file name.\r\n * @param renameEmptyFiles if true, rename file even if empty, otherwise delete empty files.\r\n * @return true if successfully renamed.\r\n *\/\r\n","code_no_comment":"public static boolean execute(final File source, final File destination, boolean renameEmptyFiles) {\r\n    if (renameEmptyFiles || (source.length() > 0)) {\r\n        try {\r\n            boolean result = source.renameTo(destination);\r\n                        return result;\r\n        } catch (Exception ex) {\r\n            try {\r\n                copyFile(source, destination);\r\n                return source.delete();\r\n            } catch (IOException iex) {\r\n                iex.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}","lc":0.0909090909,"pi":1.0574162679,"ma":0.0,"nbd":0.5,"ml":-0.0833333333,"d":-0.0555555556,"mi":-0.0348132488,"fo":-0.0833333333,"r":0.0263157895,"e":-0.0651417968}
{"project_name":"JxPath","project_version":"22","label":1,"code":"\/**\r\n * Get the ns uri of the specified node.\r\n * @param node Node to check\r\n * @return String ns uri\r\n *\/\r\npublic static String getNamespaceURI(Node node) {\r\n    if (node instanceof Document) {\r\n        node = ((Document) node).getDocumentElement();\r\n    }\r\n    Element element = (Element) node;\r\n    String uri = element.getNamespaceURI();\r\n    if (uri == null) {\r\n        String prefix = getPrefix(node);\r\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\r\n        Node aNode = node;\r\n        while (aNode != null) {\r\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\r\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\r\n                if (attr != null) {\r\n                    return attr.getValue();\r\n                }\r\n            }\r\n            aNode = aNode.getParentNode();\r\n        }\r\n        return null;\r\n    }\r\n    return uri;\r\n}","code_comment":"\/**\r\n * Get the ns uri of the specified node.\r\n * @param node Node to check\r\n * @return String ns uri\r\n *\/\r\n","code_no_comment":"public static String getNamespaceURI(Node node) {\r\n    if (node instanceof Document) {\r\n        node = ((Document) node).getDocumentElement();\r\n    }\r\n    Element element = (Element) node;\r\n    String uri = element.getNamespaceURI();\r\n    if (uri == null) {\r\n        String prefix = getPrefix(node);\r\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\r\n        Node aNode = node;\r\n        while (aNode != null) {\r\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\r\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\r\n                if (attr != null) {\r\n                    return attr.getValue();\r\n                }\r\n            }\r\n            aNode = aNode.getParentNode();\r\n        }\r\n        return null;\r\n    }\r\n    return uri;\r\n}","lc":0.4090909091,"pi":1.0622009569,"ma":0.6,"nbd":1.0,"ml":0.5833333333,"d":0.5615079365,"mi":-0.3525017618,"fo":0.0833333333,"r":0.0263157895,"e":0.5612143635}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"@Override\r\npublic void updateAndFlush(ByteBuffer login, String tableName, Map<ByteBuffer, List<ColumnUpdate>> cells) throws TException {\r\n    try {\r\n        BatchWriter writer = getWriter(login, tableName, null);\r\n        addCellsToWriter(cells, writer);\r\n        writer.flush();\r\n        writer.close();\r\n    } catch (Exception e) {\r\n        throw translateException(e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void updateAndFlush(ByteBuffer login, String tableName, Map<ByteBuffer, List<ColumnUpdate>> cells) throws TException {\r\n    try {\r\n        BatchWriter writer = getWriter(login, tableName, null);\r\n        addCellsToWriter(cells, writer);\r\n        writer.flush();\r\n        writer.close();\r\n    } catch (Exception e) {\r\n        throw translateException(e);\r\n    }\r\n}","lc":-0.1363636364,"pi":0.1626794258,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.1385482734,"fo":-0.0833333333,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4431_7441a3d5","label":1,"code":"public Directory wrapForRead(String indexPath, IndexDefinition definition, Directory remote) throws IOException {\r\n    Directory local = createLocalDirForIndexReader(indexPath, definition);\r\n    return new CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath, getSharedWorkingSet(definition));\r\n}","code_comment":null,"code_no_comment":"public Directory wrapForRead(String indexPath, IndexDefinition definition, Directory remote) throws IOException {\r\n    Directory local = createLocalDirForIndexReader(indexPath, definition);\r\n    return new CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath, getSharedWorkingSet(definition));\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6786469345,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5138_e8dab4a0","label":1,"code":"\/**\r\n *  This is Wicket's main method to execute a request\r\n *\r\n *  @param request\r\n *  @param response\r\n *  @param chain\r\n *  @return false, if the request could not be processed\r\n *  @throws IOException\r\n *  @throws ServletException\r\n *\/\r\nboolean processRequest(ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException {\r\n    final ThreadContext previousThreadContext = ThreadContext.detach();\r\n    \/\/ Assume we are able to handle the request\r\n    boolean res = true;\r\n    final ClassLoader previousClassLoader = Thread.currentThread().getContextClassLoader();\r\n    final ClassLoader newClassLoader = getClassLoader();\r\n    try {\r\n        if (previousClassLoader != newClassLoader) {\r\n            Thread.currentThread().setContextClassLoader(newClassLoader);\r\n        }\r\n        HttpServletRequest httpServletRequest = (HttpServletRequest) request;\r\n        HttpServletResponse httpServletResponse = (HttpServletResponse) response;\r\n        \/\/ Make sure getFilterPath() gets called before checkIfRedirectRequired()\r\n        String filterPath = getFilterPath(httpServletRequest);\r\n        if (filterPath == null) {\r\n            throw new IllegalStateException(\"filter path was not configured\");\r\n        }\r\n        if (shouldIgnorePath(httpServletRequest)) {\r\n            log.debug(\"Ignoring request {}\", httpServletRequest.getRequestURL());\r\n            if (chain != null) {\r\n                chain.doFilter(request, response);\r\n            }\r\n            return false;\r\n        }\r\n        if (\"OPTIONS\".equals(httpServletRequest.getMethod())) {\r\n            \/\/ handle the OPTIONS request outside of normal request processing.\r\n            \/\/ wicket pages normally only support GET and POST methods, but resources and\r\n            \/\/ special pages acting like REST clients can also support other methods, so\r\n            \/\/ we include them all.\r\n            httpServletResponse.setStatus(HttpServletResponse.SC_OK);\r\n            httpServletResponse.setHeader(\"Allow\", \"GET,POST,OPTIONS,PUT,HEAD,PATCH,DELETE,TRACE\");\r\n            httpServletResponse.setHeader(\"Content-Length\", \"0\");\r\n            return true;\r\n        }\r\n        String redirectURL = checkIfRedirectRequired(httpServletRequest);\r\n        if (redirectURL == null) {\r\n            \/\/ No redirect; process the request\r\n            ThreadContext.setApplication(application);\r\n            WebRequest webRequest = application.createWebRequest(httpServletRequest, filterPath);\r\n            WebResponse webResponse = application.createWebResponse(webRequest, httpServletResponse);\r\n            RequestCycle requestCycle = application.createRequestCycle(webRequest, webResponse);\r\n            res = processRequestCycle(requestCycle, webResponse, httpServletRequest, httpServletResponse, chain);\r\n        } else {\r\n            if (Strings.isEmpty(httpServletRequest.getQueryString()) == false) {\r\n                redirectURL += \"?\" + httpServletRequest.getQueryString();\r\n            }\r\n            try {\r\n                \/\/ send redirect - this will discard POST parameters if the request is POST\r\n                \/\/ - still better than getting an error because of lacking trailing slash\r\n                httpServletResponse.sendRedirect(httpServletResponse.encodeRedirectURL(redirectURL));\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    } finally {\r\n        ThreadContext.restore(previousThreadContext);\r\n        if (newClassLoader != previousClassLoader) {\r\n            Thread.currentThread().setContextClassLoader(previousClassLoader);\r\n        }\r\n        if (response.isCommitted()) {\r\n            response.flushBuffer();\r\n        }\r\n    }\r\n    return res;\r\n}","code_comment":"\/**\r\n *  This is Wicket's main method to execute a request\r\n *\r\n *  @param request\r\n *  @param response\r\n *  @param chain\r\n *  @return false, if the request could not be processed\r\n *  @throws IOException\r\n *  @throws ServletException\r\n *\/\r\n","code_no_comment":"boolean processRequest(ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException {\r\n    final ThreadContext previousThreadContext = ThreadContext.detach();\r\n        boolean res = true;\r\n    final ClassLoader previousClassLoader = Thread.currentThread().getContextClassLoader();\r\n    final ClassLoader newClassLoader = getClassLoader();\r\n    try {\r\n        if (previousClassLoader != newClassLoader) {\r\n            Thread.currentThread().setContextClassLoader(newClassLoader);\r\n        }\r\n        HttpServletRequest httpServletRequest = (HttpServletRequest) request;\r\n        HttpServletResponse httpServletResponse = (HttpServletResponse) response;\r\n                String filterPath = getFilterPath(httpServletRequest);\r\n        if (filterPath == null) {\r\n            throw new IllegalStateException(\"filter path was not configured\");\r\n        }\r\n        if (shouldIgnorePath(httpServletRequest)) {\r\n            log.debug(\"Ignoring request {}\", httpServletRequest.getRequestURL());\r\n            if (chain != null) {\r\n                chain.doFilter(request, response);\r\n            }\r\n            return false;\r\n        }\r\n        if (\"OPTIONS\".equals(httpServletRequest.getMethod())) {\r\n                                                            httpServletResponse.setStatus(HttpServletResponse.SC_OK);\r\n            httpServletResponse.setHeader(\"Allow\", \"GET,POST,OPTIONS,PUT,HEAD,PATCH,DELETE,TRACE\");\r\n            httpServletResponse.setHeader(\"Content-Length\", \"0\");\r\n            return true;\r\n        }\r\n        String redirectURL = checkIfRedirectRequired(httpServletRequest);\r\n        if (redirectURL == null) {\r\n                        ThreadContext.setApplication(application);\r\n            WebRequest webRequest = application.createWebRequest(httpServletRequest, filterPath);\r\n            WebResponse webResponse = application.createWebResponse(webRequest, httpServletResponse);\r\n            RequestCycle requestCycle = application.createRequestCycle(webRequest, webResponse);\r\n            res = processRequestCycle(requestCycle, webResponse, httpServletRequest, httpServletResponse, chain);\r\n        } else {\r\n            if (Strings.isEmpty(httpServletRequest.getQueryString()) == false) {\r\n                redirectURL += \"?\" + httpServletRequest.getQueryString();\r\n            }\r\n            try {\r\n                                                httpServletResponse.sendRedirect(httpServletResponse.encodeRedirectURL(redirectURL));\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    } finally {\r\n        ThreadContext.restore(previousThreadContext);\r\n        if (newClassLoader != previousClassLoader) {\r\n            Thread.currentThread().setContextClassLoader(previousClassLoader);\r\n        }\r\n        if (response.isCommitted()) {\r\n            response.flushBuffer();\r\n        }\r\n    }\r\n    return res;\r\n}","lc":1.9090909091,"pi":0.3444976077,"ma":1.8,"nbd":0.5,"ml":1.3333333333,"d":0.3908730159,"mi":-0.9619450317,"fo":2.1666666667,"r":-0.0263157895,"e":1.6488580765}
{"project_name":"Math","project_version":"18","label":1,"code":"\/**\r\n * @param x Original objective variables.\r\n * @return the normalized objective variables.\r\n *\/\r\npublic double[] encode(final double[] x) {\r\n    if (boundaries == null) {\r\n        return x;\r\n    }\r\n    double[] res = new double[x.length];\r\n    for (int i = 0; i < x.length; i++) {\r\n        double diff = boundaries[1][i] - boundaries[0][i];\r\n        res[i] = (x[i] - boundaries[0][i]) \/ diff;\r\n    }\r\n    return res;\r\n}","code_comment":"\/**\r\n * @param x Original objective variables.\r\n * @return the normalized objective variables.\r\n *\/\r\n","code_no_comment":"public double[] encode(final double[] x) {\r\n    if (boundaries == null) {\r\n        return x;\r\n    }\r\n    double[] res = new double[x.length];\r\n    for (int i = 0; i < x.length; i++) {\r\n        double diff = boundaries[1][i] - boundaries[0][i];\r\n        res[i] = (x[i] - boundaries[0][i]) \/ diff;\r\n    }\r\n    return res;\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":1.3115079365,"mi":0.1123326286,"fo":-0.5,"r":1.8947368421,"e":0.4904272056}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Returns the number of elements currently in the array.  Please note\r\n * that this is different from the length of the internal storage array.\r\n *\r\n * @return the number of elements.\r\n *\/\r\n@Override\r\npublic synchronized int getNumElements() {\r\n    return numElements;\r\n}","code_comment":"\/**\r\n * Returns the number of elements currently in the array.  Please note\r\n * that this is different from the length of the internal storage array.\r\n *\r\n * @return the number of elements.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic synchronized int getNumElements() {\r\n    return numElements;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0332628612,"fo":-0.5,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1127_ba62c59d","label":1,"code":"\/**\r\n * Compares two numbers given some amount of allowed error.\r\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\r\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\r\n * point numbers are considered equal.\r\n * Adapted from <a\r\n * href=\"http:\/\/www.cygnus-software.com\/papers\/comparingfloats\/comparingfloats.htm\">\r\n * Bruce Dawson<\/a>\r\n *\r\n * @param x first value\r\n * @param y second value\r\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\r\n * values between {@code x} and {@code y}.\r\n * @return <ul><li>0 if  {@link #equals(double, double, int) equals(x, y, maxUlps)}<\/li>\r\n *       <li>&lt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x &lt; y<\/li>\r\n *       <li>> 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x > y<\/li><\/ul>\r\n *\/\r\npublic static int compareTo(final double x, final double y, final int maxUlps) {\r\n    if (equals(x, y, maxUlps)) {\r\n        return 0;\r\n    } else if (x < y) {\r\n        return -1;\r\n    }\r\n    return 1;\r\n}","code_comment":"\/**\r\n * Compares two numbers given some amount of allowed error.\r\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\r\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\r\n * point numbers are considered equal.\r\n * Adapted from <a\r\n * href=\"http:\/\/www.cygnus-software.com\/papers\/comparingfloats\/comparingfloats.htm\">\r\n * Bruce Dawson<\/a>\r\n *\r\n * @param x first value\r\n * @param y second value\r\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\r\n * values between {@code x} and {@code y}.\r\n * @return <ul><li>0 if  {@link #equals(double, double, int) equals(x, y, maxUlps)}<\/li>\r\n *       <li>&lt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x &lt; y<\/li>\r\n *       <li>> 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x > y<\/li><\/ul>\r\n *\/\r\n","code_no_comment":"public static int compareTo(final double x, final double y, final int maxUlps) {\r\n    if (equals(x, y, maxUlps)) {\r\n        return 0;\r\n    } else if (x < y) {\r\n        return -1;\r\n    }\r\n    return 1;\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.2,"nbd":0.0,"ml":0.0833333333,"d":-0.0178571429,"mi":0.4260747005,"fo":-0.4166666667,"r":0.0,"e":-0.1199126341}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-395_4ed7bc8e","label":1,"code":"@Override\r\npublic PropertyImpl perform() throws RepositoryException {\r\n    String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\r\n    if (value == null) {\r\n        dlg.removeProperty(oakName);\r\n        return null;\r\n    } else {\r\n        int targetType = getTargetType(value, type);\r\n        Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\r\n        return new PropertyImpl(dlg.setProperty(oakName, targetValue));\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic PropertyImpl perform() throws RepositoryException {\r\n    String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\r\n    if (value == null) {\r\n        dlg.removeProperty(oakName);\r\n        return null;\r\n    } else {\r\n        int targetType = getTargetType(value, type);\r\n        Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\r\n        return new PropertyImpl(dlg.setProperty(oakName, targetValue));\r\n    }\r\n}","lc":-0.0909090909,"pi":0.1004784689,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0892857143,"mi":0.0796335447,"fo":0.0,"r":0.0526315789,"e":-0.0555569002}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1123_a197ba85","label":1,"code":"\/**\r\n * Fit a sub-hyperplane inside the cell defined by the instance.\r\n * <p>Fitting is done by chopping off the parts of the\r\n * sub-hyperplane that lie outside of the cell using the\r\n * cut-hyperplanes of the parent nodes of the instance.<\/p>\r\n * @param sub sub-hyperplane to fit\r\n * @return a new sub-hyperplane, guaranteed to have no part outside\r\n * of the instance cell\r\n *\/\r\nprivate SubHyperplane<S> fitToCell(final SubHyperplane<S> sub) {\r\n    SubHyperplane<S> s = sub;\r\n    for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {\r\n        if (tree == tree.parent.plus) {\r\n            s = s.split(tree.parent.cut.getHyperplane()).getPlus();\r\n        } else {\r\n            s = s.split(tree.parent.cut.getHyperplane()).getMinus();\r\n        }\r\n    }\r\n    return s;\r\n}","code_comment":"\/**\r\n * Fit a sub-hyperplane inside the cell defined by the instance.\r\n * <p>Fitting is done by chopping off the parts of the\r\n * sub-hyperplane that lie outside of the cell using the\r\n * cut-hyperplanes of the parent nodes of the instance.<\/p>\r\n * @param sub sub-hyperplane to fit\r\n * @return a new sub-hyperplane, guaranteed to have no part outside\r\n * of the instance cell\r\n *\/\r\n","code_no_comment":"private SubHyperplane<S> fitToCell(final SubHyperplane<S> sub) {\r\n    SubHyperplane<S> s = sub;\r\n    for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {\r\n        if (tree == tree.parent.plus) {\r\n            s = s.split(tree.parent.cut.getHyperplane()).getPlus();\r\n        } else {\r\n            s = s.split(tree.parent.cut.getHyperplane()).getMinus();\r\n        }\r\n    }\r\n    return s;\r\n}","lc":-0.1363636364,"pi":0.4593301435,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":0.1428571429,"mi":0.0835799859,"fo":0.0,"r":-0.0263157895,"e":0.0780968517}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-428_d906576c","label":3,"code":"public Object next() {\r\n    index++;\r\n    return new Map.Entry() {\r\n\r\n        public Object getKey() {\r\n            return key;\r\n        }\r\n\r\n        public Object getValue() {\r\n            return value;\r\n        }\r\n\r\n        public Object setValue(final Object value) {\r\n            final Object oldValue = MicroMap.this.value;\r\n            MicroMap.this.value = value;\r\n            return oldValue;\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"public Object next() {\r\n    index++;\r\n    return new Map.Entry() {\r\n\r\n        public Object getKey() {\r\n            return key;\r\n        }\r\n\r\n        public Object getValue() {\r\n            return value;\r\n        }\r\n\r\n        public Object setValue(final Object value) {\r\n            final Object oldValue = MicroMap.this.value;\r\n            MicroMap.this.value = value;\r\n            return oldValue;\r\n        }\r\n    };\r\n}","lc":0.0909090909,"pi":0.4688995215,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":0.001984127,"mi":0.0221282593,"fo":-0.5,"r":1.0789473684,"e":-0.0730116469}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"@Override\r\npublic void read(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {\r\n    TTupleProtocol iprot = (TTupleProtocol) prot;\r\n    BitSet incoming = iprot.readBitSet(2);\r\n    if (incoming.get(0)) {\r\n        struct.ouch1 = new UnknownWriter();\r\n        struct.ouch1.read(iprot);\r\n        struct.setOuch1IsSet(true);\r\n    }\r\n    if (incoming.get(1)) {\r\n        struct.ouch2 = new MutationsRejectedException();\r\n        struct.ouch2.read(iprot);\r\n        struct.setOuch2IsSet(true);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void read(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {\r\n    TTupleProtocol iprot = (TTupleProtocol) prot;\r\n    BitSet incoming = iprot.readBitSet(2);\r\n    if (incoming.get(0)) {\r\n        struct.ouch1 = new UnknownWriter();\r\n        struct.ouch1.read(iprot);\r\n        struct.setOuch1IsSet(true);\r\n    }\r\n    if (incoming.get(1)) {\r\n        struct.ouch2 = new MutationsRejectedException();\r\n        struct.ouch2.read(iprot);\r\n        struct.setOuch2IsSet(true);\r\n    }\r\n}","lc":0.0454545455,"pi":0.0,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":-0.0948555321,"fo":0.0833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Cli","project_version":"1","label":1,"code":"\/**\r\n * Return the <code>Object<\/code> type of this <code>Option<\/code>.\r\n *\r\n * @param opt the name of the option\r\n * @return the type of this <code>Option<\/code>\r\n *\/\r\npublic Object getOptionObject(String opt) {\r\n    String res = getOptionValue(opt);\r\n    if (!options.containsKey(opt)) {\r\n        return null;\r\n    }\r\n    Object type = ((Option) options.get(opt)).getType();\r\n    return (res == null) ? null : TypeHandler.createValue(res, type);\r\n}","code_comment":"\/**\r\n * Return the <code>Object<\/code> type of this <code>Option<\/code>.\r\n *\r\n * @param opt the name of the option\r\n * @return the type of this <code>Option<\/code>\r\n *\/\r\n","code_no_comment":"public Object getOptionObject(String opt) {\r\n    String res = getOptionValue(opt);\r\n    if (!options.containsKey(opt)) {\r\n        return null;\r\n    }\r\n    Object type = ((Option) options.get(opt)).getType();\r\n    return (res == null) ? null : TypeHandler.createValue(res, type);\r\n}","lc":-0.2727272727,"pi":-0.2822966507,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":-0.0297619048,"mi":0.2930232558,"fo":-0.0833333333,"r":1.1315789474,"e":-0.060342433}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-395_962315ba","label":1,"code":"\/**\r\n * Method for implementing actual optimization algorithms in derived\r\n * classes.\r\n *\r\n * @return the optimum.\r\n *\/\r\nprotected abstract double doOptimize();","code_comment":"\/**\r\n * Method for implementing actual optimization algorithms in derived\r\n * classes.\r\n *\r\n * @return the optimum.\r\n *\/\r\n","code_no_comment":"protected abstract double doOptimize();","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.8696264975,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-926_e1ae968c","label":1,"code":"\/**\r\n * Returns update operations to split this document. The implementation may\r\n * decide to not return any operations if no splitting is required.\r\n *\r\n * @param context the revision context.\r\n * @return the split operations.\r\n *\/\r\n@Nonnull\r\npublic Iterable<UpdateOp> split(@Nonnull RevisionContext context) {\r\n    \/\/ only consider if there are enough commits\r\n    if (getLocalRevisions().size() + getLocalCommitRoot().size() <= REVISIONS_SPLIT_OFF_SIZE) {\r\n        return Collections.emptyList();\r\n    }\r\n    String id = getId();\r\n    SortedMap<Revision, Range> previous = getPreviousRanges();\r\n    \/\/ what's the most recent previous revision?\r\n    Revision recentPrevious = null;\r\n    for (Revision rev : previous.keySet()) {\r\n        if (rev.getClusterId() != context.getClusterId()) {\r\n            continue;\r\n        }\r\n        if (recentPrevious == null || isRevisionNewer(context, rev, recentPrevious)) {\r\n            recentPrevious = rev;\r\n        }\r\n    }\r\n    Map<String, NavigableMap<Revision, String>> splitValues = new HashMap<String, NavigableMap<Revision, String>>();\r\n    for (String property : new String[] { REVISIONS, COMMIT_ROOT, DELETED }) {\r\n        NavigableMap<Revision, String> splitMap = new TreeMap<Revision, String>(context.getRevisionComparator());\r\n        splitValues.put(property, splitMap);\r\n        Map<String, String> valueMap = getLocalMap(property);\r\n        \/\/ most recent previous split revision\r\n        for (Map.Entry<String, String> entry : valueMap.entrySet()) {\r\n            Revision rev = Revision.fromString(entry.getKey());\r\n            if (rev.getClusterId() != context.getClusterId()) {\r\n                continue;\r\n            }\r\n            if (recentPrevious == null || isRevisionNewer(context, rev, recentPrevious)) {\r\n                if (isCommitted(rev)) {\r\n                    splitMap.put(rev, entry.getValue());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    List<UpdateOp> splitOps = Collections.emptyList();\r\n    int numValues = 0;\r\n    Revision high = null;\r\n    Revision low = null;\r\n    for (NavigableMap<Revision, String> splitMap : splitValues.values()) {\r\n        \/\/ keep the most recent in the main document\r\n        if (!splitMap.isEmpty()) {\r\n            splitMap.remove(splitMap.lastKey());\r\n        }\r\n        if (splitMap.isEmpty()) {\r\n            continue;\r\n        }\r\n        \/\/ remember highest \/ lowest revision\r\n        if (high == null || isRevisionNewer(context, splitMap.lastKey(), high)) {\r\n            high = splitMap.lastKey();\r\n        }\r\n        if (low == null || isRevisionNewer(context, low, splitMap.firstKey())) {\r\n            low = splitMap.firstKey();\r\n        }\r\n        numValues += splitMap.size();\r\n    }\r\n    if (high != null && low != null && numValues >= REVISIONS_SPLIT_OFF_SIZE) {\r\n        \/\/ enough revisions to split off\r\n        splitOps = new ArrayList<UpdateOp>(2);\r\n        \/\/ move to another document\r\n        UpdateOp main = new UpdateOp(id, false);\r\n        main.setMapEntry(PREVIOUS, high.toString(), low.toString());\r\n        UpdateOp old = new UpdateOp(Utils.getPreviousIdFor(id, high), true);\r\n        old.set(ID, old.getKey());\r\n        for (String property : splitValues.keySet()) {\r\n            NavigableMap<Revision, String> splitMap = splitValues.get(property);\r\n            for (Map.Entry<Revision, String> entry : splitMap.entrySet()) {\r\n                String r = entry.getKey().toString();\r\n                main.removeMapEntry(property, r);\r\n                old.setMapEntry(property, r, entry.getValue());\r\n            }\r\n            splitOps.add(old);\r\n            splitOps.add(main);\r\n        }\r\n    }\r\n    return splitOps;\r\n}","code_comment":"\/**\r\n * Returns update operations to split this document. The implementation may\r\n * decide to not return any operations if no splitting is required.\r\n *\r\n * @param context the revision context.\r\n * @return the split operations.\r\n *\/\r\n","code_no_comment":"@Nonnull\r\npublic Iterable<UpdateOp> split(@Nonnull RevisionContext context) {\r\n        if (getLocalRevisions().size() + getLocalCommitRoot().size() <= REVISIONS_SPLIT_OFF_SIZE) {\r\n        return Collections.emptyList();\r\n    }\r\n    String id = getId();\r\n    SortedMap<Revision, Range> previous = getPreviousRanges();\r\n        Revision recentPrevious = null;\r\n    for (Revision rev : previous.keySet()) {\r\n        if (rev.getClusterId() != context.getClusterId()) {\r\n            continue;\r\n        }\r\n        if (recentPrevious == null || isRevisionNewer(context, rev, recentPrevious)) {\r\n            recentPrevious = rev;\r\n        }\r\n    }\r\n    Map<String, NavigableMap<Revision, String>> splitValues = new HashMap<String, NavigableMap<Revision, String>>();\r\n    for (String property : new String[] { REVISIONS, COMMIT_ROOT, DELETED }) {\r\n        NavigableMap<Revision, String> splitMap = new TreeMap<Revision, String>(context.getRevisionComparator());\r\n        splitValues.put(property, splitMap);\r\n        Map<String, String> valueMap = getLocalMap(property);\r\n                for (Map.Entry<String, String> entry : valueMap.entrySet()) {\r\n            Revision rev = Revision.fromString(entry.getKey());\r\n            if (rev.getClusterId() != context.getClusterId()) {\r\n                continue;\r\n            }\r\n            if (recentPrevious == null || isRevisionNewer(context, rev, recentPrevious)) {\r\n                if (isCommitted(rev)) {\r\n                    splitMap.put(rev, entry.getValue());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    List<UpdateOp> splitOps = Collections.emptyList();\r\n    int numValues = 0;\r\n    Revision high = null;\r\n    Revision low = null;\r\n    for (NavigableMap<Revision, String> splitMap : splitValues.values()) {\r\n                if (!splitMap.isEmpty()) {\r\n            splitMap.remove(splitMap.lastKey());\r\n        }\r\n        if (splitMap.isEmpty()) {\r\n            continue;\r\n        }\r\n                if (high == null || isRevisionNewer(context, splitMap.lastKey(), high)) {\r\n            high = splitMap.lastKey();\r\n        }\r\n        if (low == null || isRevisionNewer(context, low, splitMap.firstKey())) {\r\n            low = splitMap.firstKey();\r\n        }\r\n        numValues += splitMap.size();\r\n    }\r\n    if (high != null && low != null && numValues >= REVISIONS_SPLIT_OFF_SIZE) {\r\n                splitOps = new ArrayList<UpdateOp>(2);\r\n                UpdateOp main = new UpdateOp(id, false);\r\n        main.setMapEntry(PREVIOUS, high.toString(), low.toString());\r\n        UpdateOp old = new UpdateOp(Utils.getPreviousIdFor(id, high), true);\r\n        old.set(ID, old.getKey());\r\n        for (String property : splitValues.keySet()) {\r\n            NavigableMap<Revision, String> splitMap = splitValues.get(property);\r\n            for (Map.Entry<Revision, String> entry : splitMap.entrySet()) {\r\n                String r = entry.getKey().toString();\r\n                main.removeMapEntry(property, r);\r\n                old.setMapEntry(property, r, entry.getValue());\r\n            }\r\n            splitOps.add(old);\r\n            splitOps.add(main);\r\n        }\r\n    }\r\n    return splitOps;\r\n}","lc":2.5909090909,"pi":0.5933014354,"ma":3.4,"nbd":1.0,"ml":2.4166666667,"d":2.6765873016,"mi":-1.1990133897,"fo":3.8333333333,"r":-0.0263157895,"e":12.1447992485}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2974_5eceb10e","label":0,"code":"@Override\r\npublic Path getFullPath(FileType fileType, String path) {\r\n    int colon = path.indexOf(':');\r\n    if (colon > -1) {\r\n        \/\/ Check if this is really an absolute path or if this is a 1.4 style relative path for a WAL\r\n        if (fileType == FileType.WAL && path.charAt(colon + 1) != '\/') {\r\n            path = path.substring(path.indexOf('\/'));\r\n        } else {\r\n            return new Path(path);\r\n        }\r\n    }\r\n    \/\/ normalize the path\r\n    Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());\r\n    if (path.startsWith(\"\/\"))\r\n        path = path.substring(1);\r\n    fullPath = new Path(fullPath, path);\r\n    FileSystem fs = getVolumeByPath(fullPath).getFileSystem();\r\n    return fs.makeQualified(fullPath);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Path getFullPath(FileType fileType, String path) {\r\n    int colon = path.indexOf(':');\r\n    if (colon > -1) {\r\n                if (fileType == FileType.WAL && path.charAt(colon + 1) != '\/') {\r\n            path = path.substring(path.indexOf('\/'));\r\n        } else {\r\n            return new Path(path);\r\n        }\r\n    }\r\n        Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());\r\n    if (path.startsWith(\"\/\"))\r\n        path = path.substring(1);\r\n    fullPath = new Path(fullPath, path);\r\n    FileSystem fs = getVolumeByPath(fullPath).getFileSystem();\r\n    return fs.makeQualified(fullPath);\r\n}","lc":0.1363636364,"pi":0.2775119617,"ma":0.0,"nbd":0.0,"ml":0.25,"d":0.9166666667,"mi":-0.1977448908,"fo":0.4166666667,"r":-0.0263157895,"e":0.8590561482}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4616_dd1df04b","label":1,"code":"\/**\r\n *  Called (by the default implementation of 'process') when all fields validated, the form was\r\n *  updated and it's data was allowed to be persisted. It is meant for delegating further\r\n *  processing to clients.\r\n *  <p>\r\n *  This implementation first finds out whether the form processing was triggered by a nested\r\n *  IFormSubmittingComponent of this form. If that is the case, that component's onSubmit is\r\n *  called first.\r\n *  <\/p>\r\n *  <p>\r\n *  Regardless of whether a submitting component was found, the form's onSubmit method is called\r\n *  next.\r\n *  <\/p>\r\n *\r\n *  @param submittingComponent\r\n *             the component that triggered this form processing, or null if the processing was\r\n *             triggered by something else (like a non-Wicket submit button or a javascript\r\n *             execution)\r\n *\/\r\nprotected void delegateSubmit(IFormSubmitter submittingComponent) {\r\n    final Form<?> processingForm = findFormToProcess(submittingComponent);\r\n    \/\/ process submitting component (if specified)\r\n    if (submittingComponent != null) {\r\n        \/\/ invoke submit on component\r\n        submittingComponent.onSubmitBeforeForm();\r\n    }\r\n    \/\/ invoke Form#onSubmit(..) going from innermost to outermost\r\n    Visits.visitPostOrder(processingForm, new IVisitor<Form<?>, Void>() {\r\n\r\n        @Override\r\n        public void component(Form<?> form, IVisit<Void> visit) {\r\n            if (form.isEnabledInHierarchy() && form.isVisibleInHierarchy()) {\r\n                form.onSubmit();\r\n            }\r\n        }\r\n    }, new ClassVisitFilter(Form.class));\r\n    if (submittingComponent != null) {\r\n        submittingComponent.onSubmitAfterForm();\r\n    }\r\n}","code_comment":"\/**\r\n *  Called (by the default implementation of 'process') when all fields validated, the form was\r\n *  updated and it's data was allowed to be persisted. It is meant for delegating further\r\n *  processing to clients.\r\n *  <p>\r\n *  This implementation first finds out whether the form processing was triggered by a nested\r\n *  IFormSubmittingComponent of this form. If that is the case, that component's onSubmit is\r\n *  called first.\r\n *  <\/p>\r\n *  <p>\r\n *  Regardless of whether a submitting component was found, the form's onSubmit method is called\r\n *  next.\r\n *  <\/p>\r\n *\r\n *  @param submittingComponent\r\n *             the component that triggered this form processing, or null if the processing was\r\n *             triggered by something else (like a non-Wicket submit button or a javascript\r\n *             execution)\r\n *\/\r\n","code_no_comment":"protected void delegateSubmit(IFormSubmitter submittingComponent) {\r\n    final Form<?> processingForm = findFormToProcess(submittingComponent);\r\n        if (submittingComponent != null) {\r\n                submittingComponent.onSubmitBeforeForm();\r\n    }\r\n        Visits.visitPostOrder(processingForm, new IVisitor<Form<?>, Void>() {\r\n\r\n        @Override\r\n        public void component(Form<?> form, IVisit<Void> visit) {\r\n            if (form.isEnabledInHierarchy() && form.isVisibleInHierarchy()) {\r\n                form.onSubmit();\r\n            }\r\n        }\r\n    }, new ClassVisitFilter(Form.class));\r\n    if (submittingComponent != null) {\r\n        submittingComponent.onSubmitAfterForm();\r\n    }\r\n}","lc":0.1363636364,"pi":0.5454545455,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":-0.0456349206,"mi":-0.1134601832,"fo":0.0833333333,"r":-0.0263157895,"e":-0.0198636492}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1008_0c20bfd8","label":1,"code":"\/**\r\n * Attempts to discover classes that pass the test. Accumulated\r\n * classes can be accessed by calling {@link #getClasses()}.\r\n *\r\n * @param test the test to determine matching classes\r\n * @param packageNames one or more package names to scan (including subpackages) for classes\r\n *\/\r\npublic void find(final Test test, final String... packageNames) {\r\n    if (packageNames == null) {\r\n        return;\r\n    }\r\n    for (final String pkg : packageNames) {\r\n        findInPackage(test, pkg);\r\n    }\r\n}","code_comment":"\/**\r\n * Attempts to discover classes that pass the test. Accumulated\r\n * classes can be accessed by calling {@link #getClasses()}.\r\n *\r\n * @param test the test to determine matching classes\r\n * @param packageNames one or more package names to scan (including subpackages) for classes\r\n *\/\r\n","code_no_comment":"public void find(final Test test, final String... packageNames) {\r\n    if (packageNames == null) {\r\n        return;\r\n    }\r\n    for (final String pkg : packageNames) {\r\n        findInPackage(test, pkg);\r\n    }\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.4356589147,"fo":-0.4166666667,"r":1.7105263158,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4927_8c827e33","label":1,"code":"private void writeBuffered() {\r\n    if (!bufferedWritten) {\r\n        bufferedResponse.writeTo(originalResponse);\r\n        bufferedWritten = true;\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void writeBuffered() {\r\n    if (!bufferedWritten) {\r\n        bufferedResponse.writeTo(originalResponse);\r\n        bufferedWritten = true;\r\n    }\r\n}","lc":-0.3636363636,"pi":0.1339712919,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1388888889,"mi":0.6397463002,"fo":-0.4166666667,"r":0.7894736842,"e":-0.1460901437}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-276_1bf5c550","label":1,"code":"public void readNode(StoredNode node) throws NotFoundException, Exception {\r\n    Id id = node.getId();\r\n    Connection con = cp.getConnection();\r\n    try {\r\n        PreparedStatement stmt = con.prepareStatement(\"select DATA from REVS where ID = ?\");\r\n        try {\r\n            stmt.setBytes(1, id.getBytes());\r\n            ResultSet rs = stmt.executeQuery();\r\n            if (rs.next()) {\r\n                ByteArrayInputStream in = new ByteArrayInputStream(rs.getBytes(1));\r\n                node.deserialize(new BinaryBinding(in));\r\n            } else {\r\n                throw new NotFoundException(id.toString());\r\n            }\r\n        } finally {\r\n            stmt.close();\r\n        }\r\n    } finally {\r\n        con.close();\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void readNode(StoredNode node) throws NotFoundException, Exception {\r\n    Id id = node.getId();\r\n    Connection con = cp.getConnection();\r\n    try {\r\n        PreparedStatement stmt = con.prepareStatement(\"select DATA from REVS where ID = ?\");\r\n        try {\r\n            stmt.setBytes(1, id.getBytes());\r\n            ResultSet rs = stmt.executeQuery();\r\n            if (rs.next()) {\r\n                ByteArrayInputStream in = new ByteArrayInputStream(rs.getBytes(1));\r\n                node.deserialize(new BinaryBinding(in));\r\n            } else {\r\n                throw new NotFoundException(id.toString());\r\n            }\r\n        } finally {\r\n            stmt.close();\r\n        }\r\n    } finally {\r\n        con.close();\r\n    }\r\n}","lc":0.3181818182,"pi":0.8803827751,"ma":-0.2,"nbd":0.5,"ml":-0.25,"d":-0.3650793651,"mi":-0.2459478506,"fo":0.5,"r":0.0526315789,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2961_3d8c9d75","label":1,"code":"\/**\r\n *  Used to call {@link #onInitialize()}\r\n *\/\r\nvoid initialize() {\r\n    if (!getFlag(FLAG_INITIALIZED)) {\r\n        onInitialize();\r\n        setFlag(FLAG_INITIALIZED, true);\r\n    }\r\n}","code_comment":"\/**\r\n *  Used to call {@link #onInitialize()}\r\n *\/\r\n","code_no_comment":"void initialize() {\r\n    if (!getFlag(FLAG_INITIALIZED)) {\r\n        onInitialize();\r\n        setFlag(FLAG_INITIALIZED, true);\r\n    }\r\n}","lc":-0.3636363636,"pi":0.1339712919,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.6634249471,"fo":-0.25,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"Compress","project_version":"8","label":1,"code":"\/**\r\n * Parse an octal string from a buffer.\r\n * Leading spaces are ignored.\r\n * The buffer must contain a trailing space or NUL,\r\n * and may contain an additional trailing space or NUL.\r\n *\r\n * The input buffer is allowed to contain all NULs,\r\n * in which case the method returns 0L\r\n * (this allows for missing fields).\r\n *\r\n * @param buffer The buffer from which to parse.\r\n * @param offset The offset into the buffer from which to parse.\r\n * @param length The maximum number of bytes to parse - must be at least 2 bytes.\r\n * @return The long value of the octal string.\r\n * @throws IllegalArgumentException if the trailing space\/NUL is missing or if a invalid byte is detected.\r\n *\/\r\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\r\n    long result = 0;\r\n    boolean stillPadding = true;\r\n    int end = offset + length;\r\n    int start = offset;\r\n    for (int i = start; i < end; i++) {\r\n        final byte currentByte = buffer[i];\r\n        if (currentByte == 0) {\r\n            break;\r\n        }\r\n        \/\/ Skip leading spaces\r\n        if (currentByte == (byte) ' ' || currentByte == '0') {\r\n            if (stillPadding) {\r\n                continue;\r\n            }\r\n            if (currentByte == (byte) ' ') {\r\n                break;\r\n            }\r\n        }\r\n        \/\/ Must have trailing NUL or space\r\n        \/\/ May have additional NUL or space\r\n        stillPadding = false;\r\n        \/\/ CheckStyle:MagicNumber OFF\r\n        if (currentByte < '0' || currentByte > '7') {\r\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\r\n        }\r\n        \/\/ convert from ASCII\r\n        result = (result << 3) + (currentByte - '0');\r\n    \/\/ CheckStyle:MagicNumber ON\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n * Parse an octal string from a buffer.\r\n * Leading spaces are ignored.\r\n * The buffer must contain a trailing space or NUL,\r\n * and may contain an additional trailing space or NUL.\r\n *\r\n * The input buffer is allowed to contain all NULs,\r\n * in which case the method returns 0L\r\n * (this allows for missing fields).\r\n *\r\n * @param buffer The buffer from which to parse.\r\n * @param offset The offset into the buffer from which to parse.\r\n * @param length The maximum number of bytes to parse - must be at least 2 bytes.\r\n * @return The long value of the octal string.\r\n * @throws IllegalArgumentException if the trailing space\/NUL is missing or if a invalid byte is detected.\r\n *\/\r\n","code_no_comment":"public static long parseOctal(final byte[] buffer, final int offset, final int length) {\r\n    long result = 0;\r\n    boolean stillPadding = true;\r\n    int end = offset + length;\r\n    int start = offset;\r\n    for (int i = start; i < end; i++) {\r\n        final byte currentByte = buffer[i];\r\n        if (currentByte == 0) {\r\n            break;\r\n        }\r\n                if (currentByte == (byte) ' ' || currentByte == '0') {\r\n            if (stillPadding) {\r\n                continue;\r\n            }\r\n            if (currentByte == (byte) ' ') {\r\n                break;\r\n            }\r\n        }\r\n                        stillPadding = false;\r\n                if (currentByte < '0' || currentByte > '7') {\r\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\r\n        }\r\n                result = (result << 3) + (currentByte - '0');\r\n        }\r\n    return result;\r\n}","lc":0.5454545455,"pi":0.5885167464,"ma":1.4,"nbd":0.5,"ml":0.5833333333,"d":1.7242063492,"mi":-0.4384778013,"fo":-0.4166666667,"r":0.0,"e":1.5169700847}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5441_8ccb1f6d","label":1,"code":"\/**\r\n *  set resource caching to maximum and set cache-visibility to 'public'\r\n *\r\n *  @param response\r\n *\/\r\n@Override\r\npublic void decorateResponse(AbstractResource.ResourceResponse response, IStaticCacheableResource resource) {\r\n    response.setCacheDurationToMaximum();\r\n    response.setCacheScope(WebResponse.CacheScope.PUBLIC);\r\n}","code_comment":"\/**\r\n *  set resource caching to maximum and set cache-visibility to 'public'\r\n *\r\n *  @param response\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void decorateResponse(AbstractResource.ResourceResponse response, IStaticCacheableResource resource) {\r\n    response.setCacheDurationToMaximum();\r\n    response.setCacheScope(WebResponse.CacheScope.PUBLIC);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6473572939,"fo":-0.3333333333,"r":2.2631578947,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1822_016df669","label":1,"code":"\/**\r\n * Apply the changes to the in-memory document.\r\n *\r\n * @param doc\r\n *            the target document.\r\n * @param update\r\n *            the changes to apply.\r\n * @param comparator\r\n *            the revision comparator.\r\n *\/\r\npublic static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {\r\n    for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {\r\n        Key k = e.getKey();\r\n        Operation op = e.getValue();\r\n        switch(op.type) {\r\n            case SET:\r\n                {\r\n                    doc.put(k.toString(), op.value);\r\n                    break;\r\n                }\r\n            case INCREMENT:\r\n                {\r\n                    Object old = doc.get(k.toString());\r\n                    Long x = (Long) op.value;\r\n                    if (old == null) {\r\n                        old = 0L;\r\n                    }\r\n                    doc.put(k.toString(), ((Long) old) + x);\r\n                    break;\r\n                }\r\n            case SET_MAP_ENTRY:\r\n                {\r\n                    Object old = doc.get(k.getName());\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    Map<Revision, Object> m = (Map<Revision, Object>) old;\r\n                    if (m == null) {\r\n                        m = new TreeMap<Revision, Object>(comparator);\r\n                        doc.put(k.getName(), m);\r\n                    }\r\n                    if (k.getRevision() == null) {\r\n                        throw new IllegalArgumentException(\"Cannot set map entry \" + k.getName() + \" with null revision\");\r\n                    }\r\n                    m.put(k.getRevision(), op.value);\r\n                    break;\r\n                }\r\n            case REMOVE_MAP_ENTRY:\r\n                {\r\n                    Object old = doc.get(k.getName());\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    Map<Revision, Object> m = (Map<Revision, Object>) old;\r\n                    if (m != null) {\r\n                        m.remove(k.getRevision());\r\n                    }\r\n                    break;\r\n                }\r\n            case CONTAINS_MAP_ENTRY:\r\n                \/\/ no effect\r\n                break;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Apply the changes to the in-memory document.\r\n *\r\n * @param doc\r\n *            the target document.\r\n * @param update\r\n *            the changes to apply.\r\n * @param comparator\r\n *            the revision comparator.\r\n *\/\r\n","code_no_comment":"public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {\r\n    for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {\r\n        Key k = e.getKey();\r\n        Operation op = e.getValue();\r\n        switch(op.type) {\r\n            case SET:\r\n                {\r\n                    doc.put(k.toString(), op.value);\r\n                    break;\r\n                }\r\n            case INCREMENT:\r\n                {\r\n                    Object old = doc.get(k.toString());\r\n                    Long x = (Long) op.value;\r\n                    if (old == null) {\r\n                        old = 0L;\r\n                    }\r\n                    doc.put(k.toString(), ((Long) old) + x);\r\n                    break;\r\n                }\r\n            case SET_MAP_ENTRY:\r\n                {\r\n                    Object old = doc.get(k.getName());\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    Map<Revision, Object> m = (Map<Revision, Object>) old;\r\n                    if (m == null) {\r\n                        m = new TreeMap<Revision, Object>(comparator);\r\n                        doc.put(k.getName(), m);\r\n                    }\r\n                    if (k.getRevision() == null) {\r\n                        throw new IllegalArgumentException(\"Cannot set map entry \" + k.getName() + \" with null revision\");\r\n                    }\r\n                    m.put(k.getRevision(), op.value);\r\n                    break;\r\n                }\r\n            case REMOVE_MAP_ENTRY:\r\n                {\r\n                    Object old = doc.get(k.getName());\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    Map<Revision, Object> m = (Map<Revision, Object>) old;\r\n                    if (m != null) {\r\n                        m.remove(k.getRevision());\r\n                    }\r\n                    break;\r\n                }\r\n            case CONTAINS_MAP_ENTRY:\r\n                                break;\r\n        }\r\n    }\r\n}","lc":1.6363636364,"pi":1.4497607656,"ma":2.6,"nbd":1.0,"ml":0.6666666667,"d":0.6845238095,"mi":-0.9016208598,"fo":1.4166666667,"r":-0.0263157895,"e":1.8259089573}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5960_03663750","label":1,"code":"@Override\r\nprotected void onDetach() {\r\n    super.onDetach();\r\n    renderedComponentsPerScope = null;\r\n    headerResponse = null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void onDetach() {\r\n    super.onDetach();\r\n    renderedComponentsPerScope = null;\r\n    headerResponse = null;\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6639887245,"fo":-0.4166666667,"r":1.2631578947,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1922_ccd574a4","label":1,"code":"@Override\r\npublic void onComplete(Throwable failure, Object success) throws Throwable {\r\n    if (failure != null) {\r\n        if (failure instanceof TimeoutException) {\r\n            markFailed(new Exception(\"Cannot deploy task - TaskManager not responding.\", failure));\r\n        } else {\r\n            markFailed(failure);\r\n        }\r\n    } else {\r\n        if (success == null) {\r\n            markFailed(new Exception(\"Failed to deploy the task to slot \" + slot + \": TaskOperationResult was null\"));\r\n        }\r\n        if (success instanceof TaskOperationResult) {\r\n            TaskOperationResult result = (TaskOperationResult) success;\r\n            if (!result.executionID().equals(attemptId)) {\r\n                markFailed(new Exception(\"Answer execution id does not match the request execution id.\"));\r\n            } else if (result.success()) {\r\n                switchToRunning();\r\n            } else {\r\n                \/\/ deployment failed :(\r\n                markFailed(new Exception(\"Failed to deploy the task \" + getVertexWithAttempt() + \" to slot \" + slot + \": \" + result.description()));\r\n            }\r\n        } else {\r\n            markFailed(new Exception(\"Failed to deploy the task to slot \" + slot + \": Response was not of type TaskOperationResult\"));\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void onComplete(Throwable failure, Object success) throws Throwable {\r\n    if (failure != null) {\r\n        if (failure instanceof TimeoutException) {\r\n            markFailed(new Exception(\"Cannot deploy task - TaskManager not responding.\", failure));\r\n        } else {\r\n            markFailed(failure);\r\n        }\r\n    } else {\r\n        if (success == null) {\r\n            markFailed(new Exception(\"Failed to deploy the task to slot \" + slot + \": TaskOperationResult was null\"));\r\n        }\r\n        if (success instanceof TaskOperationResult) {\r\n            TaskOperationResult result = (TaskOperationResult) success;\r\n            if (!result.executionID().equals(attemptId)) {\r\n                markFailed(new Exception(\"Answer execution id does not match the request execution id.\"));\r\n            } else if (result.success()) {\r\n                switchToRunning();\r\n            } else {\r\n                                markFailed(new Exception(\"Failed to deploy the task \" + getVertexWithAttempt() + \" to slot \" + slot + \": \" + result.description()));\r\n            }\r\n        } else {\r\n            markFailed(new Exception(\"Failed to deploy the task to slot \" + slot + \": Response was not of type TaskOperationResult\"));\r\n        }\r\n    }\r\n}","lc":0.5454545455,"pi":0.7799043062,"ma":0.6,"nbd":1.0,"ml":0.5,"d":0.4146825397,"mi":-0.3978858351,"fo":0.5,"r":0.0,"e":0.4036652202}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3281_f7dd2fff","label":1,"code":"\/**\r\n * Adds a route for an interceptor that intercepts incoming messages on any inputs in this route\r\n *\r\n * @return the builder\r\n *\/\r\npublic InterceptFromDefinition interceptFrom() {\r\n    routeCollection.setCamelContext(getContext());\r\n    return routeCollection.interceptFrom();\r\n}","code_comment":"\/**\r\n * Adds a route for an interceptor that intercepts incoming messages on any inputs in this route\r\n *\r\n * @return the builder\r\n *\/\r\n","code_no_comment":"public InterceptFromDefinition interceptFrom() {\r\n    routeCollection.setCamelContext(getContext());\r\n    return routeCollection.interceptFrom();\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8940098661,"fo":-0.25,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-548_717186d6","label":1,"code":"public String build() throws Exception {\r\n    final JsopBuilder buff = new JsopBuilder();\r\n    \/\/ maps (key: id of target node, value: path\/to\/target)\r\n    \/\/ for tracking added\/removed nodes; this allows us\r\n    \/\/ to detect 'move' operations\r\n    final HashMap<NodeState, String> addedNodes = new HashMap<NodeState, String>();\r\n    final HashMap<NodeState, String> removedNodes = new HashMap<NodeState, String>();\r\n    if (!PathUtils.isAncestor(path, pathFilter) && !path.startsWith(pathFilter)) {\r\n        return \"\";\r\n    }\r\n    if (before == null) {\r\n        if (after != null) {\r\n            buff.tag('+').key(path).object();\r\n            toJson(buff, after);\r\n            return buff.endObject().newline().toString();\r\n        } else {\r\n            \/\/ path doesn't exist in the specified revisions\r\n            return \"\";\r\n        }\r\n    } else if (after == null) {\r\n        buff.tag('-');\r\n        buff.value(path);\r\n        return buff.newline().toString();\r\n    }\r\n    TraversingNodeDiffHandler diffHandler = new TraversingNodeDiffHandler(store) {\r\n\r\n        int levels = depth < 0 ? Integer.MAX_VALUE : depth;\r\n\r\n        @Override\r\n        public void propertyAdded(PropertyState after) {\r\n            String p = PathUtils.concat(getCurrentPath(), after.getName());\r\n            if (p.startsWith(pathFilter)) {\r\n                buff.tag('^').key(p).encodedValue(after.getEncodedValue()).newline();\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void propertyChanged(PropertyState before, PropertyState after) {\r\n            String p = PathUtils.concat(getCurrentPath(), after.getName());\r\n            if (p.startsWith(pathFilter)) {\r\n                buff.tag('^').key(p).encodedValue(after.getEncodedValue()).newline();\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void propertyDeleted(PropertyState before) {\r\n            String p = PathUtils.concat(getCurrentPath(), before.getName());\r\n            if (p.startsWith(pathFilter)) {\r\n                \/\/ since property and node deletions can't be distinguished\r\n                \/\/ using the \"- <path>\" notation we're representing\r\n                \/\/ property deletions as \"^ <path>:null\"\r\n                buff.tag('^').key(p).value(null).newline();\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void childNodeAdded(String name, NodeState after) {\r\n            String p = PathUtils.concat(getCurrentPath(), name);\r\n            if (p.startsWith(pathFilter)) {\r\n                addedNodes.put(after, p);\r\n                buff.tag('+').key(p).object();\r\n                toJson(buff, after);\r\n                buff.endObject().newline();\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void childNodeDeleted(String name, NodeState before) {\r\n            String p = PathUtils.concat(getCurrentPath(), name);\r\n            if (p.startsWith(pathFilter)) {\r\n                removedNodes.put(before, p);\r\n                buff.tag('-');\r\n                buff.value(p);\r\n                buff.newline();\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void childNodeChanged(String name, NodeState before, NodeState after) {\r\n            String p = PathUtils.concat(getCurrentPath(), name);\r\n            if (PathUtils.isAncestor(p, pathFilter) || p.startsWith(pathFilter)) {\r\n                --levels;\r\n                if (levels >= 0) {\r\n                    \/\/ recurse\r\n                    super.childNodeChanged(name, before, after);\r\n                } else {\r\n                    buff.tag('^');\r\n                    buff.key(p);\r\n                    buff.object().endObject();\r\n                    buff.newline();\r\n                }\r\n                ++levels;\r\n            }\r\n        }\r\n    };\r\n    diffHandler.start(before, after, path);\r\n    \/\/ check if this commit includes 'move' operations\r\n    \/\/ by building intersection of added and removed nodes\r\n    addedNodes.keySet().retainAll(removedNodes.keySet());\r\n    if (!addedNodes.isEmpty()) {\r\n        \/\/ this commit includes 'move' operations\r\n        removedNodes.keySet().retainAll(addedNodes.keySet());\r\n        \/\/ addedNodes & removedNodes now only contain information about moved nodes\r\n        \/\/ re-build the diff in a 2nd pass, this time representing moves correctly\r\n        buff.resetWriter();\r\n        \/\/ TODO refactor code, avoid duplication\r\n        diffHandler = new TraversingNodeDiffHandler(store) {\r\n\r\n            int levels = depth < 0 ? Integer.MAX_VALUE : depth;\r\n\r\n            @Override\r\n            public void propertyAdded(PropertyState after) {\r\n                String p = PathUtils.concat(getCurrentPath(), after.getName());\r\n                if (p.startsWith(pathFilter)) {\r\n                    buff.tag('^').key(p).encodedValue(after.getEncodedValue()).newline();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void propertyChanged(PropertyState before, PropertyState after) {\r\n                String p = PathUtils.concat(getCurrentPath(), after.getName());\r\n                if (p.startsWith(pathFilter)) {\r\n                    buff.tag('^').key(p).encodedValue(after.getEncodedValue()).newline();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void propertyDeleted(PropertyState before) {\r\n                String p = PathUtils.concat(getCurrentPath(), before.getName());\r\n                if (p.startsWith(pathFilter)) {\r\n                    \/\/ since property and node deletions can't be distinguished\r\n                    \/\/ using the \"- <path>\" notation we're representing\r\n                    \/\/ property deletions as \"^ <path>:null\"\r\n                    buff.tag('^').key(p).value(null).newline();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void childNodeAdded(String name, NodeState after) {\r\n                if (addedNodes.containsKey(after)) {\r\n                    \/\/ moved node, will be processed separately\r\n                    return;\r\n                }\r\n                String p = PathUtils.concat(getCurrentPath(), name);\r\n                if (p.startsWith(pathFilter)) {\r\n                    buff.tag('+').key(p).object();\r\n                    toJson(buff, after);\r\n                    buff.endObject().newline();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void childNodeDeleted(String name, NodeState before) {\r\n                if (addedNodes.containsKey(before)) {\r\n                    \/\/ moved node, will be processed separately\r\n                    return;\r\n                }\r\n                String p = PathUtils.concat(getCurrentPath(), name);\r\n                if (p.startsWith(pathFilter)) {\r\n                    buff.tag('-');\r\n                    buff.value(p);\r\n                    buff.newline();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void childNodeChanged(String name, NodeState before, NodeState after) {\r\n                String p = PathUtils.concat(getCurrentPath(), name);\r\n                if (PathUtils.isAncestor(p, pathFilter) || p.startsWith(pathFilter)) {\r\n                    --levels;\r\n                    if (levels >= 0) {\r\n                        \/\/ recurse\r\n                        super.childNodeChanged(name, before, after);\r\n                    } else {\r\n                        buff.tag('^');\r\n                        buff.value(p);\r\n                        buff.newline();\r\n                    }\r\n                    ++levels;\r\n                }\r\n            }\r\n        };\r\n        diffHandler.start(before, after, path);\r\n        \/\/ finally process moved nodes\r\n        for (Map.Entry<NodeState, String> entry : addedNodes.entrySet()) {\r\n            buff.tag('>').key(removedNodes.get(entry.getKey())).value(entry.getValue()).newline();\r\n        }\r\n    }\r\n    return buff.toString();\r\n}","code_comment":null,"code_no_comment":"public String build() throws Exception {\r\n    final JsopBuilder buff = new JsopBuilder();\r\n                final HashMap<NodeState, String> addedNodes = new HashMap<NodeState, String>();\r\n    final HashMap<NodeState, String> removedNodes = new HashMap<NodeState, String>();\r\n    if (!PathUtils.isAncestor(path, pathFilter) && !path.startsWith(pathFilter)) {\r\n        return \"\";\r\n    }\r\n    if (before == null) {\r\n        if (after != null) {\r\n            buff.tag('+').key(path).object();\r\n            toJson(buff, after);\r\n            return buff.endObject().newline().toString();\r\n        } else {\r\n                        return \"\";\r\n        }\r\n    } else if (after == null) {\r\n        buff.tag('-');\r\n        buff.value(path);\r\n        return buff.newline().toString();\r\n    }\r\n    TraversingNodeDiffHandler diffHandler = new TraversingNodeDiffHandler(store) {\r\n\r\n        int levels = depth < 0 ? Integer.MAX_VALUE : depth;\r\n\r\n        @Override\r\n        public void propertyAdded(PropertyState after) {\r\n            String p = PathUtils.concat(getCurrentPath(), after.getName());\r\n            if (p.startsWith(pathFilter)) {\r\n                buff.tag('^').key(p).encodedValue(after.getEncodedValue()).newline();\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void propertyChanged(PropertyState before, PropertyState after) {\r\n            String p = PathUtils.concat(getCurrentPath(), after.getName());\r\n            if (p.startsWith(pathFilter)) {\r\n                buff.tag('^').key(p).encodedValue(after.getEncodedValue()).newline();\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void propertyDeleted(PropertyState before) {\r\n            String p = PathUtils.concat(getCurrentPath(), before.getName());\r\n            if (p.startsWith(pathFilter)) {\r\n                                                                buff.tag('^').key(p).value(null).newline();\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void childNodeAdded(String name, NodeState after) {\r\n            String p = PathUtils.concat(getCurrentPath(), name);\r\n            if (p.startsWith(pathFilter)) {\r\n                addedNodes.put(after, p);\r\n                buff.tag('+').key(p).object();\r\n                toJson(buff, after);\r\n                buff.endObject().newline();\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void childNodeDeleted(String name, NodeState before) {\r\n            String p = PathUtils.concat(getCurrentPath(), name);\r\n            if (p.startsWith(pathFilter)) {\r\n                removedNodes.put(before, p);\r\n                buff.tag('-');\r\n                buff.value(p);\r\n                buff.newline();\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void childNodeChanged(String name, NodeState before, NodeState after) {\r\n            String p = PathUtils.concat(getCurrentPath(), name);\r\n            if (PathUtils.isAncestor(p, pathFilter) || p.startsWith(pathFilter)) {\r\n                --levels;\r\n                if (levels >= 0) {\r\n                                        super.childNodeChanged(name, before, after);\r\n                } else {\r\n                    buff.tag('^');\r\n                    buff.key(p);\r\n                    buff.object().endObject();\r\n                    buff.newline();\r\n                }\r\n                ++levels;\r\n            }\r\n        }\r\n    };\r\n    diffHandler.start(before, after, path);\r\n            addedNodes.keySet().retainAll(removedNodes.keySet());\r\n    if (!addedNodes.isEmpty()) {\r\n                removedNodes.keySet().retainAll(addedNodes.keySet());\r\n                        buff.resetWriter();\r\n                diffHandler = new TraversingNodeDiffHandler(store) {\r\n\r\n            int levels = depth < 0 ? Integer.MAX_VALUE : depth;\r\n\r\n            @Override\r\n            public void propertyAdded(PropertyState after) {\r\n                String p = PathUtils.concat(getCurrentPath(), after.getName());\r\n                if (p.startsWith(pathFilter)) {\r\n                    buff.tag('^').key(p).encodedValue(after.getEncodedValue()).newline();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void propertyChanged(PropertyState before, PropertyState after) {\r\n                String p = PathUtils.concat(getCurrentPath(), after.getName());\r\n                if (p.startsWith(pathFilter)) {\r\n                    buff.tag('^').key(p).encodedValue(after.getEncodedValue()).newline();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void propertyDeleted(PropertyState before) {\r\n                String p = PathUtils.concat(getCurrentPath(), before.getName());\r\n                if (p.startsWith(pathFilter)) {\r\n                                                                                buff.tag('^').key(p).value(null).newline();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void childNodeAdded(String name, NodeState after) {\r\n                if (addedNodes.containsKey(after)) {\r\n                                        return;\r\n                }\r\n                String p = PathUtils.concat(getCurrentPath(), name);\r\n                if (p.startsWith(pathFilter)) {\r\n                    buff.tag('+').key(p).object();\r\n                    toJson(buff, after);\r\n                    buff.endObject().newline();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void childNodeDeleted(String name, NodeState before) {\r\n                if (addedNodes.containsKey(before)) {\r\n                                        return;\r\n                }\r\n                String p = PathUtils.concat(getCurrentPath(), name);\r\n                if (p.startsWith(pathFilter)) {\r\n                    buff.tag('-');\r\n                    buff.value(p);\r\n                    buff.newline();\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void childNodeChanged(String name, NodeState before, NodeState after) {\r\n                String p = PathUtils.concat(getCurrentPath(), name);\r\n                if (PathUtils.isAncestor(p, pathFilter) || p.startsWith(pathFilter)) {\r\n                    --levels;\r\n                    if (levels >= 0) {\r\n                                                super.childNodeChanged(name, before, after);\r\n                    } else {\r\n                        buff.tag('^');\r\n                        buff.value(p);\r\n                        buff.newline();\r\n                    }\r\n                    ++levels;\r\n                }\r\n            }\r\n        };\r\n        diffHandler.start(before, after, path);\r\n                for (Map.Entry<NodeState, String> entry : addedNodes.entrySet()) {\r\n            buff.tag('>').key(removedNodes.get(entry.getKey())).value(entry.getValue()).newline();\r\n        }\r\n    }\r\n    return buff.toString();\r\n}","lc":6.4090909091,"pi":1.0765550239,"ma":4.2,"nbd":1.0,"ml":2.9166666667,"d":6.244047619,"mi":-1.6646934461,"fo":10.8333333333,"r":-0.0263157895,"e":47.0363536822}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2812_e494c279","label":3,"code":"public static <X, K> KeySelector<X, K> getSelectorForOneKey(Keys<X> keys, Partitioner<K> partitioner, TypeInformation<X> typeInfo, ExecutionConfig executionConfig) {\r\n    if (partitioner != null) {\r\n        keys.validateCustomPartitioner(partitioner, null);\r\n    }\r\n    int[] logicalKeyPositions = keys.computeLogicalKeyPositions();\r\n    if (logicalKeyPositions.length != 1) {\r\n        throw new IllegalArgumentException(\"There must be exactly 1 key specified\");\r\n    }\r\n    TypeComparator<X> comparator = ((CompositeType<X>) typeInfo).createComparator(logicalKeyPositions, new boolean[1], 0, executionConfig);\r\n    return new OneKeySelector<X, K>(comparator);\r\n}","code_comment":null,"code_no_comment":"public static <X, K> KeySelector<X, K> getSelectorForOneKey(Keys<X> keys, Partitioner<K> partitioner, TypeInformation<X> typeInfo, ExecutionConfig executionConfig) {\r\n    if (partitioner != null) {\r\n        keys.validateCustomPartitioner(partitioner, null);\r\n    }\r\n    int[] logicalKeyPositions = keys.computeLogicalKeyPositions();\r\n    if (logicalKeyPositions.length != 1) {\r\n        throw new IllegalArgumentException(\"There must be exactly 1 key specified\");\r\n    }\r\n    TypeComparator<X> comparator = ((CompositeType<X>) typeInfo).createComparator(logicalKeyPositions, new boolean[1], 0, executionConfig);\r\n    return new OneKeySelector<X, K>(comparator);\r\n}","lc":-0.1363636364,"pi":-0.2775119617,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0198412698,"mi":0.0486257928,"fo":-0.25,"r":-0.0263157895,"e":0.0360413317}
{"project_name":"Closure","project_version":"153","label":2,"code":"\/**\r\n * Scans and gather variables declarations under a Node\r\n *\/\r\nprivate void scanVars(Node n, Node parent) {\r\n    switch(n.getType()) {\r\n        case Token.VAR:\r\n            \/\/ Declare all variables. e.g. var x = 1, y, z;\r\n            for (Node child = n.getFirstChild(); child != null; ) {\r\n                Node next = child.getNext();\r\n                Preconditions.checkState(child.getType() == Token.NAME);\r\n                String name = child.getString();\r\n                declareVar(name, child, n, parent, null, n);\r\n                child = next;\r\n            }\r\n            return;\r\n        case Token.FUNCTION:\r\n            if (NodeUtil.isFunctionExpression(n)) {\r\n                return;\r\n            }\r\n            String fnName = n.getFirstChild().getString();\r\n            if (fnName.isEmpty()) {\r\n                \/\/ This is invalid, but allow it so the checks can catch it.\r\n                return;\r\n            }\r\n            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\r\n            \/\/ should not examine function's children\r\n            return;\r\n        case Token.CATCH:\r\n            Preconditions.checkState(n.getChildCount() == 2);\r\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\r\n            \/\/ the first child is the catch var and the third child\r\n            \/\/ is the code block\r\n            final Node var = n.getFirstChild();\r\n            final Node block = var.getNext();\r\n            declareVar(var.getString(), var, n, parent, null, n);\r\n            scanVars(block, n);\r\n            \/\/ only one child to scan\r\n            return;\r\n        case Token.SCRIPT:\r\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\r\n            break;\r\n    }\r\n    \/\/ we only need to traverse children in a couple special cases.\r\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\r\n        for (Node child = n.getFirstChild(); child != null; ) {\r\n            Node next = child.getNext();\r\n            scanVars(child, n);\r\n            child = next;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Scans and gather variables declarations under a Node\r\n *\/\r\n","code_no_comment":"private void scanVars(Node n, Node parent) {\r\n    switch(n.getType()) {\r\n        case Token.VAR:\r\n                        for (Node child = n.getFirstChild(); child != null; ) {\r\n                Node next = child.getNext();\r\n                Preconditions.checkState(child.getType() == Token.NAME);\r\n                String name = child.getString();\r\n                declareVar(name, child, n, parent, null, n);\r\n                child = next;\r\n            }\r\n            return;\r\n        case Token.FUNCTION:\r\n            if (NodeUtil.isFunctionExpression(n)) {\r\n                return;\r\n            }\r\n            String fnName = n.getFirstChild().getString();\r\n            if (fnName.isEmpty()) {\r\n                                return;\r\n            }\r\n            declareVar(fnName, n.getFirstChild(), n, parent, null, n);\r\n                        return;\r\n        case Token.CATCH:\r\n            Preconditions.checkState(n.getChildCount() == 2);\r\n            Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\r\n                                    final Node var = n.getFirstChild();\r\n            final Node block = var.getNext();\r\n            declareVar(var.getString(), var, n, parent, null, n);\r\n            scanVars(block, n);\r\n                        return;\r\n        case Token.SCRIPT:\r\n            sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\r\n            break;\r\n    }\r\n        if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\r\n        for (Node child = n.getFirstChild(); child != null; ) {\r\n            Node next = child.getNext();\r\n            scanVars(child, n);\r\n            child = next;\r\n        }\r\n    }\r\n}","lc":1.2272727273,"pi":0.5263157895,"ma":1.4,"nbd":0.5,"ml":1.0,"d":0.9682539683,"mi":-0.7570119803,"fo":1.9166666667,"r":-0.0263157895,"e":2.1133221533}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1044_ea2f9856","label":0,"code":"public List<Short> check(Environment env, Mutation mutation) {\r\n    ArrayList<Short> violations = null;\r\n    Collection<ColumnUpdate> colUpdates = mutation.getUpdates();\r\n    \/\/ check the row, it should contains at least one ; or end with <\r\n    boolean containsSemiC = false;\r\n    byte[] row = mutation.getRow();\r\n    \/\/ always allow rows that fall within reserved area\r\n    if (row.length > 0 && row[0] == '~')\r\n        return null;\r\n    for (byte b : row) {\r\n        if (b == ';') {\r\n            containsSemiC = true;\r\n        }\r\n        if (b == ';' || b == '<')\r\n            break;\r\n        if (!validTableNameChars[0xff & b]) {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            if (!violations.contains((short) 4))\r\n                violations.add((short) 4);\r\n        }\r\n    }\r\n    if (!containsSemiC) {\r\n        \/\/ see if last row char is <\r\n        if (row.length == 0 || row[row.length - 1] != '<') {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            if (!violations.contains((short) 4))\r\n                violations.add((short) 4);\r\n        }\r\n    } else {\r\n        if (row.length == 0) {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            if (!violations.contains((short) 4))\r\n                violations.add((short) 4);\r\n        }\r\n    }\r\n    if (row.length > 0 && row[0] == '!') {\r\n        if (row.length < 3 || row[1] != '0' || (row[2] != '<' && row[2] != ';')) {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            if (!violations.contains((short) 4))\r\n                violations.add((short) 4);\r\n        }\r\n    }\r\n    \/\/ ensure row is not less than Constants.METADATA_TABLE_ID\r\n    if (new Text(row).compareTo(new Text(Constants.METADATA_TABLE_ID)) < 0) {\r\n        if (violations == null)\r\n            violations = new ArrayList<Short>();\r\n        violations.add((short) 5);\r\n    }\r\n    for (ColumnUpdate columnUpdate : colUpdates) {\r\n        Text columnFamily = new Text(columnUpdate.getColumnFamily());\r\n        if (columnUpdate.isDeleted()) {\r\n            if (!isValidColumn(columnUpdate)) {\r\n                if (violations == null)\r\n                    violations = new ArrayList<Short>();\r\n                violations.add((short) 2);\r\n            }\r\n            continue;\r\n        }\r\n        if (columnUpdate.getValue().length == 0 && !columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            violations.add((short) 6);\r\n        }\r\n        if (columnFamily.equals(Constants.METADATA_DATAFILE_COLUMN_FAMILY)) {\r\n            try {\r\n                DataFileValue dfv = new DataFileValue(columnUpdate.getValue());\r\n                if (dfv.getSize() < 0 || dfv.getNumEntries() < 0) {\r\n                    if (violations == null)\r\n                        violations = new ArrayList<Short>();\r\n                    violations.add((short) 1);\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n                if (violations == null)\r\n                    violations = new ArrayList<Short>();\r\n                violations.add((short) 1);\r\n            } catch (ArrayIndexOutOfBoundsException aiooe) {\r\n                if (violations == null)\r\n                    violations = new ArrayList<Short>();\r\n                violations.add((short) 1);\r\n            }\r\n        } else if (columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\r\n        } else {\r\n            if (!isValidColumn(columnUpdate)) {\r\n                if (violations == null)\r\n                    violations = new ArrayList<Short>();\r\n                violations.add((short) 2);\r\n            } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_PREV_ROW_COLUMN) && columnUpdate.getValue().length > 0 && (violations == null || !violations.contains((short) 4))) {\r\n                KeyExtent ke = new KeyExtent(new Text(mutation.getRow()), (Text) null);\r\n                Text per = KeyExtent.decodePrevEndRow(new Value(columnUpdate.getValue()));\r\n                boolean prevEndRowLessThanEndRow = per == null || ke.getEndRow() == null || per.compareTo(ke.getEndRow()) < 0;\r\n                if (!prevEndRowLessThanEndRow) {\r\n                    if (violations == null)\r\n                        violations = new ArrayList<Short>();\r\n                    violations.add((short) 3);\r\n                }\r\n            } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_LOCK_COLUMN)) {\r\n                if (zooCache == null) {\r\n                    zooCache = new ZooCache();\r\n                }\r\n                if (zooRoot == null) {\r\n                    zooRoot = ZooUtil.getRoot(HdfsZooInstance.getInstance());\r\n                }\r\n                boolean lockHeld = false;\r\n                String lockId = new String(columnUpdate.getValue());\r\n                try {\r\n                    lockHeld = ZooLock.isLockHeld(zooCache, new ZooUtil.LockID(zooRoot, lockId));\r\n                } catch (Exception e) {\r\n                    log.debug(\"Failed to verify lock was held \" + lockId + \" \" + e.getMessage());\r\n                }\r\n                if (!lockHeld) {\r\n                    if (violations == null)\r\n                        violations = new ArrayList<Short>();\r\n                    violations.add((short) 7);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (violations != null) {\r\n        log.debug(\" violating metadata mutation : \" + mutation);\r\n    }\r\n    return violations;\r\n}","code_comment":null,"code_no_comment":"public List<Short> check(Environment env, Mutation mutation) {\r\n    ArrayList<Short> violations = null;\r\n    Collection<ColumnUpdate> colUpdates = mutation.getUpdates();\r\n        boolean containsSemiC = false;\r\n    byte[] row = mutation.getRow();\r\n        if (row.length > 0 && row[0] == '~')\r\n        return null;\r\n    for (byte b : row) {\r\n        if (b == ';') {\r\n            containsSemiC = true;\r\n        }\r\n        if (b == ';' || b == '<')\r\n            break;\r\n        if (!validTableNameChars[0xff & b]) {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            if (!violations.contains((short) 4))\r\n                violations.add((short) 4);\r\n        }\r\n    }\r\n    if (!containsSemiC) {\r\n                if (row.length == 0 || row[row.length - 1] != '<') {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            if (!violations.contains((short) 4))\r\n                violations.add((short) 4);\r\n        }\r\n    } else {\r\n        if (row.length == 0) {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            if (!violations.contains((short) 4))\r\n                violations.add((short) 4);\r\n        }\r\n    }\r\n    if (row.length > 0 && row[0] == '!') {\r\n        if (row.length < 3 || row[1] != '0' || (row[2] != '<' && row[2] != ';')) {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            if (!violations.contains((short) 4))\r\n                violations.add((short) 4);\r\n        }\r\n    }\r\n        if (new Text(row).compareTo(new Text(Constants.METADATA_TABLE_ID)) < 0) {\r\n        if (violations == null)\r\n            violations = new ArrayList<Short>();\r\n        violations.add((short) 5);\r\n    }\r\n    for (ColumnUpdate columnUpdate : colUpdates) {\r\n        Text columnFamily = new Text(columnUpdate.getColumnFamily());\r\n        if (columnUpdate.isDeleted()) {\r\n            if (!isValidColumn(columnUpdate)) {\r\n                if (violations == null)\r\n                    violations = new ArrayList<Short>();\r\n                violations.add((short) 2);\r\n            }\r\n            continue;\r\n        }\r\n        if (columnUpdate.getValue().length == 0 && !columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            violations.add((short) 6);\r\n        }\r\n        if (columnFamily.equals(Constants.METADATA_DATAFILE_COLUMN_FAMILY)) {\r\n            try {\r\n                DataFileValue dfv = new DataFileValue(columnUpdate.getValue());\r\n                if (dfv.getSize() < 0 || dfv.getNumEntries() < 0) {\r\n                    if (violations == null)\r\n                        violations = new ArrayList<Short>();\r\n                    violations.add((short) 1);\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n                if (violations == null)\r\n                    violations = new ArrayList<Short>();\r\n                violations.add((short) 1);\r\n            } catch (ArrayIndexOutOfBoundsException aiooe) {\r\n                if (violations == null)\r\n                    violations = new ArrayList<Short>();\r\n                violations.add((short) 1);\r\n            }\r\n        } else if (columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\r\n        } else {\r\n            if (!isValidColumn(columnUpdate)) {\r\n                if (violations == null)\r\n                    violations = new ArrayList<Short>();\r\n                violations.add((short) 2);\r\n            } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_PREV_ROW_COLUMN) && columnUpdate.getValue().length > 0 && (violations == null || !violations.contains((short) 4))) {\r\n                KeyExtent ke = new KeyExtent(new Text(mutation.getRow()), (Text) null);\r\n                Text per = KeyExtent.decodePrevEndRow(new Value(columnUpdate.getValue()));\r\n                boolean prevEndRowLessThanEndRow = per == null || ke.getEndRow() == null || per.compareTo(ke.getEndRow()) < 0;\r\n                if (!prevEndRowLessThanEndRow) {\r\n                    if (violations == null)\r\n                        violations = new ArrayList<Short>();\r\n                    violations.add((short) 3);\r\n                }\r\n            } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_LOCK_COLUMN)) {\r\n                if (zooCache == null) {\r\n                    zooCache = new ZooCache();\r\n                }\r\n                if (zooRoot == null) {\r\n                    zooRoot = ZooUtil.getRoot(HdfsZooInstance.getInstance());\r\n                }\r\n                boolean lockHeld = false;\r\n                String lockId = new String(columnUpdate.getValue());\r\n                try {\r\n                    lockHeld = ZooLock.isLockHeld(zooCache, new ZooUtil.LockID(zooRoot, lockId));\r\n                } catch (Exception e) {\r\n                    log.debug(\"Failed to verify lock was held \" + lockId + \" \" + e.getMessage());\r\n                }\r\n                if (!lockHeld) {\r\n                    if (violations == null)\r\n                        violations = new ArrayList<Short>();\r\n                    violations.add((short) 7);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (violations != null) {\r\n        log.debug(\" violating metadata mutation : \" + mutation);\r\n    }\r\n    return violations;\r\n}","lc":4.9090909091,"pi":1.2344497608,"ma":9.0,"nbd":2.5,"ml":5.6666666667,"d":3.2619047619,"mi":-1.6993657505,"fo":3.5,"r":-0.0263157895,"e":23.7386144776}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4138_50db442b","label":1,"code":"public static Option startRowOpt() {\r\n    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (inclusive)\");\r\n    o.setArgName(\"begin-row\");\r\n    return o;\r\n}","code_comment":null,"code_no_comment":"public static Option startRowOpt() {\r\n    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (inclusive)\");\r\n    o.setArgName(\"begin-row\");\r\n    return o;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6631430585,"fo":-0.4166666667,"r":0.3157894737,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-276_1bf5c550","label":1,"code":"public void initialize() throws Exception {\r\n    if (initialized) {\r\n        throw new IllegalStateException(\"already initialized\");\r\n    }\r\n    initialCacheSize = determineInitialCacheSize();\r\n    cache = Collections.synchronizedMap(SimpleLRUCache.<Id, Object>newInstance(initialCacheSize));\r\n    \/\/ make sure we've got a HEAD commit\r\n    head = pm.readHead();\r\n    if (head == null || head.getBytes().length == 0) {\r\n        \/\/ assume virgin repository\r\n        byte[] rawHead = Id.fromLong(commitCounter.incrementAndGet()).getBytes();\r\n        head = new Id(rawHead);\r\n        Id rootNodeId = pm.writeNode(new MutableNode(this));\r\n        MutableCommit initialCommit = new MutableCommit();\r\n        initialCommit.setCommitTS(System.currentTimeMillis());\r\n        initialCommit.setRootNodeId(rootNodeId);\r\n        pm.writeCommit(head, initialCommit);\r\n        pm.writeHead(head);\r\n    } else {\r\n        commitCounter.set(Long.parseLong(head.toString(), 16));\r\n    }\r\n    if (gcpm != null) {\r\n        gcExecutor = Executors.newScheduledThreadPool(1, new ThreadFactory() {\r\n\r\n            @Override\r\n            public Thread newThread(Runnable r) {\r\n                return new Thread(r, \"RevisionStore-GC\");\r\n            }\r\n        });\r\n        gcExecutor.scheduleWithFixedDelay(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                if (cache.size() >= initialCacheSize) {\r\n                    gc();\r\n                }\r\n            }\r\n        }, 10, 1, TimeUnit.MINUTES);\r\n    }\r\n    initialized = true;\r\n}","code_comment":null,"code_no_comment":"public void initialize() throws Exception {\r\n    if (initialized) {\r\n        throw new IllegalStateException(\"already initialized\");\r\n    }\r\n    initialCacheSize = determineInitialCacheSize();\r\n    cache = Collections.synchronizedMap(SimpleLRUCache.<Id, Object>newInstance(initialCacheSize));\r\n        head = pm.readHead();\r\n    if (head == null || head.getBytes().length == 0) {\r\n                byte[] rawHead = Id.fromLong(commitCounter.incrementAndGet()).getBytes();\r\n        head = new Id(rawHead);\r\n        Id rootNodeId = pm.writeNode(new MutableNode(this));\r\n        MutableCommit initialCommit = new MutableCommit();\r\n        initialCommit.setCommitTS(System.currentTimeMillis());\r\n        initialCommit.setRootNodeId(rootNodeId);\r\n        pm.writeCommit(head, initialCommit);\r\n        pm.writeHead(head);\r\n    } else {\r\n        commitCounter.set(Long.parseLong(head.toString(), 16));\r\n    }\r\n    if (gcpm != null) {\r\n        gcExecutor = Executors.newScheduledThreadPool(1, new ThreadFactory() {\r\n\r\n            @Override\r\n            public Thread newThread(Runnable r) {\r\n                return new Thread(r, \"RevisionStore-GC\");\r\n            }\r\n        });\r\n        gcExecutor.scheduleWithFixedDelay(new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                if (cache.size() >= initialCacheSize) {\r\n                    gc();\r\n                }\r\n            }\r\n        }, 10, 1, TimeUnit.MINUTES);\r\n    }\r\n    initialized = true;\r\n}","lc":1.0454545455,"pi":0.7033492823,"ma":0.4,"nbd":0.5,"ml":0.5,"d":0.2301587302,"mi":-0.659478506,"fo":1.25,"r":-0.0263157895,"e":0.734936579}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3715_557de7bc","label":3,"code":"\/**\r\n *  Convenience method that copies the input stream returned by {@link #getInputStream()} into a\r\n *  temporary file.\r\n *  <p>\r\n *  Only use this if you actually need a {@link File} to work with, in all other cases use\r\n *  {@link #getInputStream()} or {@link #getBytes()}\r\n *\r\n *  @since 1.2\r\n *\r\n *  @return temporary file containing the contents of the uploaded file\r\n *  @throws IOException\r\n *\/\r\npublic final File writeToTempFile() throws IOException {\r\n    File temp = File.createTempFile(Session.get().getId(), Files.cleanupFilename(item.getFieldName()));\r\n    writeTo(temp);\r\n    return temp;\r\n}","code_comment":"\/**\r\n *  Convenience method that copies the input stream returned by {@link #getInputStream()} into a\r\n *  temporary file.\r\n *  <p>\r\n *  Only use this if you actually need a {@link File} to work with, in all other cases use\r\n *  {@link #getInputStream()} or {@link #getBytes()}\r\n *\r\n *  @since 1.2\r\n *\r\n *  @return temporary file containing the contents of the uploaded file\r\n *  @throws IOException\r\n *\/\r\n","code_no_comment":"public final File writeToTempFile() throws IOException {\r\n    File temp = File.createTempFile(Session.get().getId(), Files.cleanupFilename(item.getFieldName()));\r\n    writeTo(temp);\r\n    return temp;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6047921071,"fo":0.0,"r":2.3947368421,"e":-0.1627934049}
{"project_name":"Math","project_version":"39","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\r\n    sanityChecks(equations, t);\r\n    setEquations(equations);\r\n    final boolean forward = t > equations.getTime();\r\n    \/\/ create some internal working arrays\r\n    final double[] y0 = equations.getCompleteState();\r\n    final double[] y = y0.clone();\r\n    final int stages = c.length + 1;\r\n    final double[][] yDotK = new double[stages][y.length];\r\n    final double[] yTmp = y0.clone();\r\n    final double[] yDotTmp = new double[y.length];\r\n    \/\/ set up an interpolator sharing the integrator arrays\r\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\r\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\r\n    interpolator.storeTime(equations.getTime());\r\n    \/\/ set up integration control objects\r\n    stepStart = equations.getTime();\r\n    double hNew = 0;\r\n    boolean firstTime = true;\r\n    initIntegration(equations.getTime(), y0, t);\r\n    \/\/ main integration loop\r\n    isLastStep = false;\r\n    do {\r\n        interpolator.shift();\r\n        \/\/ iterate over step size, ensuring local normalized error is smaller than 1\r\n        double error = 10;\r\n        while (error >= 1.0) {\r\n            if (firstTime || !fsal) {\r\n                \/\/ first stage\r\n                computeDerivatives(stepStart, y, yDotK[0]);\r\n            }\r\n            if (firstTime) {\r\n                final double[] scale = new double[mainSetDimension];\r\n                if (vecAbsoluteTolerance == null) {\r\n                    for (int i = 0; i < scale.length; ++i) {\r\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\r\n                    }\r\n                } else {\r\n                    for (int i = 0; i < scale.length; ++i) {\r\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\r\n                    }\r\n                }\r\n                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\r\n                firstTime = false;\r\n            }\r\n            stepSize = hNew;\r\n            \/\/ next stages\r\n            for (int k = 1; k < stages; ++k) {\r\n                for (int j = 0; j < y0.length; ++j) {\r\n                    double sum = a[k - 1][0] * yDotK[0][j];\r\n                    for (int l = 1; l < k; ++l) {\r\n                        sum += a[k - 1][l] * yDotK[l][j];\r\n                    }\r\n                    yTmp[j] = y[j] + stepSize * sum;\r\n                }\r\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\r\n            }\r\n            \/\/ estimate the state at the end of the step\r\n            for (int j = 0; j < y0.length; ++j) {\r\n                double sum = b[0] * yDotK[0][j];\r\n                for (int l = 1; l < stages; ++l) {\r\n                    sum += b[l] * yDotK[l][j];\r\n                }\r\n                yTmp[j] = y[j] + stepSize * sum;\r\n            }\r\n            \/\/ estimate the error at the end of the step\r\n            error = estimateError(yDotK, y, yTmp, stepSize);\r\n            if (error >= 1.0) {\r\n                \/\/ reject the step and attempt to reduce error by stepsize control\r\n                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\r\n                hNew = filterStep(stepSize * factor, forward, false);\r\n            }\r\n        }\r\n        \/\/ local error is small enough: accept the step, trigger events and step handlers\r\n        interpolator.storeTime(stepStart + stepSize);\r\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\r\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\r\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\r\n        System.arraycopy(y, 0, yTmp, 0, y.length);\r\n        if (!isLastStep) {\r\n            \/\/ prepare next step\r\n            interpolator.storeTime(stepStart);\r\n            if (fsal) {\r\n                \/\/ save the last evaluation for the next step\r\n                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\r\n            }\r\n            \/\/ stepsize control for next step\r\n            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\r\n            final double scaledH = stepSize * factor;\r\n            final double nextT = stepStart + scaledH;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            hNew = filterStep(scaledH, forward, nextIsLast);\r\n            final double filteredNextT = stepStart + hNew;\r\n            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\r\n            if (filteredNextIsLast) {\r\n                hNew = t - stepStart;\r\n            }\r\n        }\r\n    } while (!isLastStep);\r\n    \/\/ dispatch results\r\n    equations.setTime(stepStart);\r\n    equations.setCompleteState(y);\r\n    resetInternalState();\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\r\n    sanityChecks(equations, t);\r\n    setEquations(equations);\r\n    final boolean forward = t > equations.getTime();\r\n        final double[] y0 = equations.getCompleteState();\r\n    final double[] y = y0.clone();\r\n    final int stages = c.length + 1;\r\n    final double[][] yDotK = new double[stages][y.length];\r\n    final double[] yTmp = y0.clone();\r\n    final double[] yDotTmp = new double[y.length];\r\n        final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\r\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\r\n    interpolator.storeTime(equations.getTime());\r\n        stepStart = equations.getTime();\r\n    double hNew = 0;\r\n    boolean firstTime = true;\r\n    initIntegration(equations.getTime(), y0, t);\r\n        isLastStep = false;\r\n    do {\r\n        interpolator.shift();\r\n                double error = 10;\r\n        while (error >= 1.0) {\r\n            if (firstTime || !fsal) {\r\n                                computeDerivatives(stepStart, y, yDotK[0]);\r\n            }\r\n            if (firstTime) {\r\n                final double[] scale = new double[mainSetDimension];\r\n                if (vecAbsoluteTolerance == null) {\r\n                    for (int i = 0; i < scale.length; ++i) {\r\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\r\n                    }\r\n                } else {\r\n                    for (int i = 0; i < scale.length; ++i) {\r\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\r\n                    }\r\n                }\r\n                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\r\n                firstTime = false;\r\n            }\r\n            stepSize = hNew;\r\n                        for (int k = 1; k < stages; ++k) {\r\n                for (int j = 0; j < y0.length; ++j) {\r\n                    double sum = a[k - 1][0] * yDotK[0][j];\r\n                    for (int l = 1; l < k; ++l) {\r\n                        sum += a[k - 1][l] * yDotK[l][j];\r\n                    }\r\n                    yTmp[j] = y[j] + stepSize * sum;\r\n                }\r\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\r\n            }\r\n                        for (int j = 0; j < y0.length; ++j) {\r\n                double sum = b[0] * yDotK[0][j];\r\n                for (int l = 1; l < stages; ++l) {\r\n                    sum += b[l] * yDotK[l][j];\r\n                }\r\n                yTmp[j] = y[j] + stepSize * sum;\r\n            }\r\n                        error = estimateError(yDotK, y, yTmp, stepSize);\r\n            if (error >= 1.0) {\r\n                                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\r\n                hNew = filterStep(stepSize * factor, forward, false);\r\n            }\r\n        }\r\n                interpolator.storeTime(stepStart + stepSize);\r\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\r\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\r\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\r\n        System.arraycopy(y, 0, yTmp, 0, y.length);\r\n        if (!isLastStep) {\r\n                        interpolator.storeTime(stepStart);\r\n            if (fsal) {\r\n                                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\r\n            }\r\n                        final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\r\n            final double scaledH = stepSize * factor;\r\n            final double nextT = stepStart + scaledH;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            hNew = filterStep(scaledH, forward, nextIsLast);\r\n            final double filteredNextT = stepStart + hNew;\r\n            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\r\n            if (filteredNextIsLast) {\r\n                hNew = t - stepStart;\r\n            }\r\n        }\r\n    } while (!isLastStep);\r\n        equations.setTime(stepStart);\r\n    equations.setCompleteState(y);\r\n    resetInternalState();\r\n}","lc":3.4545454545,"pi":1.4449760766,"ma":3.0,"nbd":1.5,"ml":2.3333333333,"d":4.3273809524,"mi":-1.3670190275,"fo":2.9166666667,"r":-0.0263157895,"e":30.9905453456}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7163_5f726d0b","label":1,"code":"public void setMessageBodyOnBreakpoint(String nodeId, String body) {\r\n    SuspendedExchange se = suspendedBreakpoints.get(nodeId);\r\n    if (se != null) {\r\n        logger.log(\"Breakpoint at node \" + nodeId + \" is updating message body on exchangeId: \" + se.getExchange().getExchangeId() + \" with new body: \" + body);\r\n        if (se.getExchange().hasOut()) {\r\n            se.getExchange().getOut().setBody(body);\r\n        } else {\r\n            se.getExchange().getIn().setBody(body);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void setMessageBodyOnBreakpoint(String nodeId, String body) {\r\n    SuspendedExchange se = suspendedBreakpoints.get(nodeId);\r\n    if (se != null) {\r\n        logger.log(\"Breakpoint at node \" + nodeId + \" is updating message body on exchangeId: \" + se.getExchange().getExchangeId() + \" with new body: \" + body);\r\n        if (se.getExchange().hasOut()) {\r\n            se.getExchange().getOut().setBody(body);\r\n        } else {\r\n            se.getExchange().getIn().setBody(body);\r\n        }\r\n    }\r\n}","lc":-0.1363636364,"pi":0.4593301435,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0257936508,"mi":0.103030303,"fo":0.5,"r":0.0,"e":-0.0214680475}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-320_c06cc933","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic RealMatrix getV() throws InvalidMatrixException {\r\n    if (cachedV == null) {\r\n        if (m >= n) {\r\n            \/\/ the tridiagonal matrix is Bt.B, where B is upper bidiagonal\r\n            cachedV = transformer.getV().multiply(eigenDecomposition.getV());\r\n        } else {\r\n            \/\/ the tridiagonal matrix is B.Bt, where B is lower bidiagonal\r\n            final double[][] eData = eigenDecomposition.getV().getData();\r\n            final double[][] iData = new double[n][];\r\n            double[] ei1 = eData[0];\r\n            iData[0] = ei1;\r\n            for (int i = 0; i < m - 1; ++i) {\r\n                \/\/ compute Bt.E.S^(-1) where E is the eigenvectors matrix\r\n                \/\/ we reuse the array from matrix E to store the result\r\n                final double mi = mainBidiagonal[i];\r\n                final double si = secondaryBidiagonal[i];\r\n                final double[] ei0 = ei1;\r\n                ei1 = eData[i + 1];\r\n                iData[i + 1] = ei1;\r\n                for (int j = 0; j < m; ++j) {\r\n                    ei0[j] = (mi * ei0[j] + si * ei1[j]) \/ singularValues[j];\r\n                }\r\n            }\r\n            \/\/ last row\r\n            final double lastMain = mainBidiagonal[m - 1];\r\n            for (int j = 0; j < m; ++j) {\r\n                ei1[j] *= lastMain \/ singularValues[j];\r\n            }\r\n            for (int i = m; i < n; ++i) {\r\n                iData[i] = new double[m];\r\n            }\r\n            cachedV = transformer.getV().multiply(MatrixUtils.createRealMatrix(iData));\r\n        }\r\n    }\r\n    \/\/ return the cached matrix\r\n    return cachedV;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public RealMatrix getV() throws InvalidMatrixException {\r\n    if (cachedV == null) {\r\n        if (m >= n) {\r\n                        cachedV = transformer.getV().multiply(eigenDecomposition.getV());\r\n        } else {\r\n                        final double[][] eData = eigenDecomposition.getV().getData();\r\n            final double[][] iData = new double[n][];\r\n            double[] ei1 = eData[0];\r\n            iData[0] = ei1;\r\n            for (int i = 0; i < m - 1; ++i) {\r\n                                                final double mi = mainBidiagonal[i];\r\n                final double si = secondaryBidiagonal[i];\r\n                final double[] ei0 = ei1;\r\n                ei1 = eData[i + 1];\r\n                iData[i + 1] = ei1;\r\n                for (int j = 0; j < m; ++j) {\r\n                    ei0[j] = (mi * ei0[j] + si * ei1[j]) \/ singularValues[j];\r\n                }\r\n            }\r\n                        final double lastMain = mainBidiagonal[m - 1];\r\n            for (int j = 0; j < m; ++j) {\r\n                ei1[j] *= lastMain \/ singularValues[j];\r\n            }\r\n            for (int i = m; i < n; ++i) {\r\n                iData[i] = new double[m];\r\n            }\r\n            cachedV = transformer.getV().multiply(MatrixUtils.createRealMatrix(iData));\r\n        }\r\n    }\r\n        return cachedV;\r\n}","lc":0.7727272727,"pi":0.8899521531,"ma":0.6,"nbd":1.0,"ml":0.5,"d":2.9305555556,"mi":-0.593516561,"fo":0.1666666667,"r":-0.0263157895,"e":5.1008546417}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-1895_806eaeb0","label":0,"code":"public ArtifactResolutionResult collect(Set artifacts, Artifact originatingArtifact, Map managedVersions, ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List listeners) throws ArtifactResolutionException {\r\n    Map resolvedArtifacts = new HashMap();\r\n    ResolutionNode root = new ResolutionNode(originatingArtifact, remoteRepositories);\r\n    root.addDependencies(artifacts, remoteRepositories, filter);\r\n    recurse(root, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter, listeners);\r\n    Set set = new HashSet();\r\n    for (Iterator i = resolvedArtifacts.values().iterator(); i.hasNext(); ) {\r\n        List nodes = (List) i.next();\r\n        for (Iterator j = nodes.iterator(); j.hasNext(); ) {\r\n            ResolutionNode node = (ResolutionNode) j.next();\r\n            if (!node.equals(root) && node.isActive()) {\r\n                Artifact artifact = node.getArtifact();\r\n                if (node.filterTrail(filter)) {\r\n                    \/\/ we don't add it or its children, just allow the update of the version and scope\r\n                    if (node.isChildOfRootNode() || !artifact.isOptional()) {\r\n                        artifact.setDependencyTrail(node.getDependencyTrail());\r\n                        set.add(node);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    ArtifactResolutionResult result = new ArtifactResolutionResult();\r\n    result.setArtifactResolutionNodes(set);\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"public ArtifactResolutionResult collect(Set artifacts, Artifact originatingArtifact, Map managedVersions, ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List listeners) throws ArtifactResolutionException {\r\n    Map resolvedArtifacts = new HashMap();\r\n    ResolutionNode root = new ResolutionNode(originatingArtifact, remoteRepositories);\r\n    root.addDependencies(artifacts, remoteRepositories, filter);\r\n    recurse(root, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter, listeners);\r\n    Set set = new HashSet();\r\n    for (Iterator i = resolvedArtifacts.values().iterator(); i.hasNext(); ) {\r\n        List nodes = (List) i.next();\r\n        for (Iterator j = nodes.iterator(); j.hasNext(); ) {\r\n            ResolutionNode node = (ResolutionNode) j.next();\r\n            if (!node.equals(root) && node.isActive()) {\r\n                Artifact artifact = node.getArtifact();\r\n                if (node.filterTrail(filter)) {\r\n                                        if (node.isChildOfRootNode() || !artifact.isOptional()) {\r\n                        artifact.setDependencyTrail(node.getDependencyTrail());\r\n                        set.add(node);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    ArtifactResolutionResult result = new ArtifactResolutionResult();\r\n    result.setArtifactResolutionNodes(set);\r\n    return result;\r\n}","lc":0.5,"pi":1.985645933,"ma":0.4,"nbd":1.5,"ml":0.9166666667,"d":0.4444444444,"mi":-0.4768146582,"fo":1.0833333333,"r":-0.0263157895,"e":1.0283893201}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3769_306a9e00","label":1,"code":"\/**\r\n * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)\r\n *\/\r\nprivate static String rewriteQueryText(String textsearch) {\r\n    \/\/ replace escaped ' with just '\r\n    StringBuilder rewritten = new StringBuilder();\r\n    \/\/ the default lucene query parser recognizes 'AND' and 'NOT' as\r\n    \/\/ keywords.\r\n    textsearch = textsearch.replaceAll(\"AND\", \"and\");\r\n    textsearch = textsearch.replaceAll(\"NOT\", \"not\");\r\n    boolean escaped = false;\r\n    for (int i = 0; i < textsearch.length(); i++) {\r\n        if (textsearch.charAt(i) == '\\\\') {\r\n            if (escaped) {\r\n                rewritten.append(\"\\\\\\\\\");\r\n                escaped = false;\r\n            } else {\r\n                escaped = true;\r\n            }\r\n        } else if (textsearch.charAt(i) == '\\'') {\r\n            if (escaped) {\r\n                escaped = false;\r\n            }\r\n            rewritten.append(textsearch.charAt(i));\r\n        } else if (textsearch.charAt(i) == ':') {\r\n            \/\/ fields as known in lucene are not supported\r\n            rewritten.append(\"\\\\:\");\r\n        } else {\r\n            if (escaped) {\r\n                rewritten.append('\\\\');\r\n                escaped = false;\r\n            }\r\n            rewritten.append(textsearch.charAt(i));\r\n        }\r\n    }\r\n    return rewritten.toString();\r\n}","code_comment":"\/**\r\n * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)\r\n *\/\r\n","code_no_comment":"private static String rewriteQueryText(String textsearch) {\r\n        StringBuilder rewritten = new StringBuilder();\r\n            textsearch = textsearch.replaceAll(\"AND\", \"and\");\r\n    textsearch = textsearch.replaceAll(\"NOT\", \"not\");\r\n    boolean escaped = false;\r\n    for (int i = 0; i < textsearch.length(); i++) {\r\n        if (textsearch.charAt(i) == '\\\\') {\r\n            if (escaped) {\r\n                rewritten.append(\"\\\\\\\\\");\r\n                escaped = false;\r\n            } else {\r\n                escaped = true;\r\n            }\r\n        } else if (textsearch.charAt(i) == '\\'') {\r\n            if (escaped) {\r\n                escaped = false;\r\n            }\r\n            rewritten.append(textsearch.charAt(i));\r\n        } else if (textsearch.charAt(i) == ':') {\r\n                        rewritten.append(\"\\\\:\");\r\n        } else {\r\n            if (escaped) {\r\n                rewritten.append('\\\\');\r\n                escaped = false;\r\n            }\r\n            rewritten.append(textsearch.charAt(i));\r\n        }\r\n    }\r\n    return rewritten.toString();\r\n}","lc":0.7272727273,"pi":0.9138755981,"ma":0.8,"nbd":1.5,"ml":0.5,"d":0.746031746,"mi":-0.5086680761,"fo":0.6666666667,"r":-0.0263157895,"e":0.8907568449}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5724_b92591f6","label":1,"code":"private void dequeueAutoComponents() {\r\n    \/\/ dequeue auto components\r\n    DequeueContext context = newDequeueContext();\r\n    if (context != null && context.peekTag() != null) {\r\n        for (ComponentTag tag = context.takeTag(); tag != null; tag = context.takeTag()) {\r\n            ComponentTag.IAutoComponentFactory autoComponentFactory = tag.getAutoComponentFactory();\r\n            if (autoComponentFactory != null) {\r\n                queue(autoComponentFactory.newComponent(tag));\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void dequeueAutoComponents() {\r\n        DequeueContext context = newDequeueContext();\r\n    if (context != null && context.peekTag() != null) {\r\n        for (ComponentTag tag = context.takeTag(); tag != null; tag = context.takeTag()) {\r\n            ComponentTag.IAutoComponentFactory autoComponentFactory = tag.getAutoComponentFactory();\r\n            if (autoComponentFactory != null) {\r\n                queue(autoComponentFactory.newComponent(tag));\r\n            }\r\n        }\r\n    }\r\n}","lc":-0.1363636364,"pi":0.990430622,"ma":0.0,"nbd":0.5,"ml":0.25,"d":0.0317460317,"mi":0.110359408,"fo":0.0833333333,"r":0.5,"e":-0.0128421016}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-926_e1ae968c","label":1,"code":"\/**\r\n * Returns <code>true<\/code> if the given <code>revision<\/code> is marked\r\n * committed in <strong>this<\/strong> document including previous documents.\r\n *\r\n * @param revision the revision.\r\n * @return <code>true<\/code> if committed; <code>false<\/code> otherwise.\r\n *\/\r\npublic boolean isCommitted(@Nonnull Revision revision) {\r\n    String rev = checkNotNull(revision).toString();\r\n    String value = getLocalRevisions().get(rev);\r\n    if (value != null) {\r\n        return Utils.isCommitted(value);\r\n    }\r\n    \/\/ check previous docs\r\n    for (NodeDocument prev : getPreviousDocs(revision, REVISIONS)) {\r\n        if (prev.containsRevision(revision)) {\r\n            return prev.isCommitted(revision);\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":"\/**\r\n * Returns <code>true<\/code> if the given <code>revision<\/code> is marked\r\n * committed in <strong>this<\/strong> document including previous documents.\r\n *\r\n * @param revision the revision.\r\n * @return <code>true<\/code> if committed; <code>false<\/code> otherwise.\r\n *\/\r\n","code_no_comment":"public boolean isCommitted(@Nonnull Revision revision) {\r\n    String rev = checkNotNull(revision).toString();\r\n    String value = getLocalRevisions().get(rev);\r\n    if (value != null) {\r\n        return Utils.isCommitted(value);\r\n    }\r\n        for (NodeDocument prev : getPreviousDocs(revision, REVISIONS)) {\r\n        if (prev.containsRevision(revision)) {\r\n            return prev.isCommitted(revision);\r\n        }\r\n    }\r\n    return false;\r\n}","lc":-0.0454545455,"pi":0.1004784689,"ma":0.0,"nbd":0.0,"ml":0.0,"d":-0.0476190476,"mi":0.0401691332,"fo":0.1666666667,"r":0.0526315789,"e":-0.0476593881}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1822_016df669","label":1,"code":"public Operation getReverse() {\r\n    Operation reverse = null;\r\n    switch(type) {\r\n        case INCREMENT:\r\n            reverse = new Operation();\r\n            reverse.type = Type.INCREMENT;\r\n            reverse.value = -(Long) value;\r\n            break;\r\n        case SET:\r\n        case REMOVE_MAP_ENTRY:\r\n        case CONTAINS_MAP_ENTRY:\r\n            \/\/ nothing to do\r\n            break;\r\n        case SET_MAP_ENTRY:\r\n            reverse = new Operation();\r\n            reverse.type = Type.REMOVE_MAP_ENTRY;\r\n            break;\r\n    }\r\n    return reverse;\r\n}","code_comment":null,"code_no_comment":"public Operation getReverse() {\r\n    Operation reverse = null;\r\n    switch(type) {\r\n        case INCREMENT:\r\n            reverse = new Operation();\r\n            reverse.type = Type.INCREMENT;\r\n            reverse.value = -(Long) value;\r\n            break;\r\n        case SET:\r\n        case REMOVE_MAP_ENTRY:\r\n        case CONTAINS_MAP_ENTRY:\r\n                        break;\r\n        case SET_MAP_ENTRY:\r\n            reverse = new Operation();\r\n            reverse.type = Type.REMOVE_MAP_ENTRY;\r\n            break;\r\n    }\r\n    return reverse;\r\n}","lc":0.2272727273,"pi":0.5311004785,"ma":1.0,"nbd":0.0,"ml":0.0833333333,"d":0.0456349206,"mi":-0.1537702607,"fo":-0.5,"r":0.1315789474,"e":-0.0252715778}
{"project_name":"Compress","project_version":"2","label":1,"code":"public int read(byte[] b, final int off, final int len) throws IOException {\r\n    int toRead = len;\r\n    final int ret = this.input.read(b, off, toRead);\r\n    offset += (ret > 0 ? ret : 0);\r\n    return ret;\r\n}","code_comment":null,"code_no_comment":"public int read(byte[] b, final int off, final int len) throws IOException {\r\n    int toRead = len;\r\n    final int ret = this.input.read(b, off, toRead);\r\n    offset += (ret > 0 ? ret : 0);\r\n    return ret;\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.003968254,"mi":0.4847075405,"fo":-0.4166666667,"r":0.0,"e":-0.0861972188}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-939_49444ee6","label":1,"code":"\/**\r\n * Create a covariance matrix from a rectangular array whose columns represent\r\n * covariates. Covariances are computed using the bias-corrected formula.\r\n * @param data input array (must have at least two columns and two rows)\r\n * @return covariance matrix\r\n * @throws MathIllegalArgumentException if the data array does not contain sufficient data\r\n * @see #Covariance\r\n *\/\r\nprotected RealMatrix computeCovarianceMatrix(double[][] data) throws MathIllegalArgumentException {\r\n    return computeCovarianceMatrix(data, true);\r\n}","code_comment":"\/**\r\n * Create a covariance matrix from a rectangular array whose columns represent\r\n * covariates. Covariances are computed using the bias-corrected formula.\r\n * @param data input array (must have at least two columns and two rows)\r\n * @return covariance matrix\r\n * @throws MathIllegalArgumentException if the data array does not contain sufficient data\r\n * @see #Covariance\r\n *\/\r\n","code_no_comment":"protected RealMatrix computeCovarianceMatrix(double[][] data) throws MathIllegalArgumentException {\r\n    return computeCovarianceMatrix(data, true);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0253699789,"fo":-0.4166666667,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7239_ae419224","label":1,"code":"public SchemaFactory getSchemaFactory() {\r\n    if (schemaFactory == null) {\r\n        schemaFactory = createSchemaFactory();\r\n    }\r\n    return schemaFactory;\r\n}","code_comment":null,"code_no_comment":"public SchemaFactory getSchemaFactory() {\r\n    if (schemaFactory == null) {\r\n        schemaFactory = createSchemaFactory();\r\n    }\r\n    return schemaFactory;\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1011904762,"mi":0.6479210712,"fo":-0.4166666667,"r":1.1315789474,"e":-0.1443520456}
{"project_name":"Lang","project_version":"41","label":3,"code":"\/**\r\n * <p>Gets the class name minus the package name from a String.<\/p>\r\n *\r\n * <p>The string passed in is assumed to be a class name - it is not checked.<\/p>\r\n *\r\n * @param className  the className to get the short name for\r\n * @return the class name of the class without the package name or an empty string\r\n *\/\r\npublic static String getShortClassName(String className) {\r\n    if (className == null) {\r\n        return StringUtils.EMPTY;\r\n    }\r\n    if (className.length() == 0) {\r\n        return StringUtils.EMPTY;\r\n    }\r\n    \/\/ Handle array encoding\r\n    \/\/ Strip Object type encoding\r\n    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\r\n    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\r\n    String out = className.substring(lastDotIdx + 1);\r\n    if (innerIdx != -1) {\r\n        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\r\n    }\r\n    return out;\r\n}","code_comment":"\/**\r\n * <p>Gets the class name minus the package name from a String.<\/p>\r\n *\r\n * <p>The string passed in is assumed to be a class name - it is not checked.<\/p>\r\n *\r\n * @param className  the className to get the short name for\r\n * @return the class name of the class without the package name or an empty string\r\n *\/\r\n","code_no_comment":"public static String getShortClassName(String className) {\r\n    if (className == null) {\r\n        return StringUtils.EMPTY;\r\n    }\r\n    if (className.length() == 0) {\r\n        return StringUtils.EMPTY;\r\n    }\r\n            int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\r\n    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\r\n    String out = className.substring(lastDotIdx + 1);\r\n    if (innerIdx != -1) {\r\n        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\r\n    }\r\n    return out;\r\n}","lc":0.0454545455,"pi":-0.3349282297,"ma":0.2,"nbd":-0.5,"ml":0.25,"d":0.4920634921,"mi":-0.096546864,"fo":-0.0833333333,"r":0.2631578947,"e":0.3207159858}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7055_15e1077d","label":1,"code":"@Override\r\npublic void onDone(Exchange exchange) {\r\n    try {\r\n        if (fileInputStreamCache != null) {\r\n            fileInputStreamCache.close();\r\n        }\r\n        close();\r\n    } catch (Exception e) {\r\n        LOG.warn(\"Error deleting temporary cache file: \" + tempFile, e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void onDone(Exchange exchange) {\r\n    try {\r\n        if (fileInputStreamCache != null) {\r\n            fileInputStreamCache.close();\r\n        }\r\n        close();\r\n    } catch (Exception e) {\r\n        LOG.warn(\"Error deleting temporary cache file: \" + tempFile, e);\r\n    }\r\n}","lc":-0.1363636364,"pi":0.4114832536,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.125,"mi":0.2281888654,"fo":-0.25,"r":1.3947368421,"e":-0.1202445785}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-4682_1e54865c","label":3,"code":"protected synchronized void doStop() throws Exception {\r\n    stopWatch.restart();\r\n    log.info(\"Apache Camel \" + getVersion() + \" (CamelContext:\" + getName() + \") is shutting down\");\r\n    EventHelper.notifyCamelContextStopping(this);\r\n    \/\/ stop route inputs in the same order as they was started so we stop the very first inputs first\r\n    try {\r\n        shutdownStrategy.shutdown(this, getRouteStartupOrder());\r\n    } catch (Throwable e) {\r\n        log.warn(\"Error occurred while shutting down routes. This exception will be ignored.\", e);\r\n    }\r\n    getRouteStartupOrder().clear();\r\n    shutdownServices(routeServices.values());\r\n    \/\/ do not clear route services or startup listeners as we can start Camel again and get the route back as before\r\n    \/\/ but clear any suspend routes\r\n    suspendedRouteServices.clear();\r\n    \/\/ the stop order is important\r\n    \/\/ shutdown debugger\r\n    ServiceHelper.stopAndShutdownService(getDebugger());\r\n    shutdownServices(endpoints.values());\r\n    endpoints.clear();\r\n    shutdownServices(components.values());\r\n    components.clear();\r\n    try {\r\n        for (LifecycleStrategy strategy : lifecycleStrategies) {\r\n            strategy.onContextStop(this);\r\n        }\r\n    } catch (Throwable e) {\r\n        log.warn(\"Error occurred while stopping lifecycle strategies. This exception will be ignored.\", e);\r\n    }\r\n    \/\/ shutdown services as late as possible\r\n    shutdownServices(servicesToClose);\r\n    servicesToClose.clear();\r\n    \/\/ must notify that we are stopped before stopping the management strategy\r\n    EventHelper.notifyCamelContextStopped(this);\r\n    \/\/ stop the notifier service\r\n    for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {\r\n        shutdownServices(notifier);\r\n    }\r\n    \/\/ shutdown management as the last one\r\n    shutdownServices(managementStrategy);\r\n    shutdownServices(lifecycleStrategies);\r\n    lifecycleStrategies.clear();\r\n    \/\/ stop the lazy created so they can be re-created on restart\r\n    forceStopLazyInitialization();\r\n    stopWatch.stop();\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"Uptime: \" + getUptime());\r\n        log.info(\"Apache Camel \" + getVersion() + \" (CamelContext: \" + getName() + \") is shutdown in \" + TimeUtils.printDuration(stopWatch.taken()));\r\n    }\r\n    \/\/ and clear start date\r\n    startDate = null;\r\n}","code_comment":null,"code_no_comment":"protected synchronized void doStop() throws Exception {\r\n    stopWatch.restart();\r\n    log.info(\"Apache Camel \" + getVersion() + \" (CamelContext:\" + getName() + \") is shutting down\");\r\n    EventHelper.notifyCamelContextStopping(this);\r\n        try {\r\n        shutdownStrategy.shutdown(this, getRouteStartupOrder());\r\n    } catch (Throwable e) {\r\n        log.warn(\"Error occurred while shutting down routes. This exception will be ignored.\", e);\r\n    }\r\n    getRouteStartupOrder().clear();\r\n    shutdownServices(routeServices.values());\r\n            suspendedRouteServices.clear();\r\n            ServiceHelper.stopAndShutdownService(getDebugger());\r\n    shutdownServices(endpoints.values());\r\n    endpoints.clear();\r\n    shutdownServices(components.values());\r\n    components.clear();\r\n    try {\r\n        for (LifecycleStrategy strategy : lifecycleStrategies) {\r\n            strategy.onContextStop(this);\r\n        }\r\n    } catch (Throwable e) {\r\n        log.warn(\"Error occurred while stopping lifecycle strategies. This exception will be ignored.\", e);\r\n    }\r\n        shutdownServices(servicesToClose);\r\n    servicesToClose.clear();\r\n        EventHelper.notifyCamelContextStopped(this);\r\n        for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {\r\n        shutdownServices(notifier);\r\n    }\r\n        shutdownServices(managementStrategy);\r\n    shutdownServices(lifecycleStrategies);\r\n    lifecycleStrategies.clear();\r\n        forceStopLazyInitialization();\r\n    stopWatch.stop();\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"Uptime: \" + getUptime());\r\n        log.info(\"Apache Camel \" + getVersion() + \" (CamelContext: \" + getName() + \") is shutdown in \" + TimeUtils.printDuration(stopWatch.taken()));\r\n    }\r\n        startDate = null;\r\n}","lc":1.2272727273,"pi":-0.3779904306,"ma":0.4,"nbd":0.0,"ml":-0.25,"d":-0.0257936508,"mi":-0.6876673714,"fo":3.0,"r":-0.0263157895,"e":0.2876183561}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-369_4e245a76","label":3,"code":"\/**\r\n * Get child node\r\n * @param relPath  oak path\r\n * @return  node at the path given by {@code relPath} or {@code null} if\r\n * no such node exists\r\n *\/\r\n@CheckForNull\r\npublic NodeDelegate getChild(String relPath) throws InvalidItemStateException {\r\n    return create(sessionDelegate, getChildLocation(relPath));\r\n}","code_comment":"\/**\r\n * Get child node\r\n * @param relPath  oak path\r\n * @return  node at the path given by {@code relPath} or {@code null} if\r\n * no such node exists\r\n *\/\r\n","code_no_comment":"@CheckForNull\r\npublic NodeDelegate getChild(String relPath) throws InvalidItemStateException {\r\n    return create(sessionDelegate, getChildLocation(relPath));\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8105708245,"fo":-0.3333333333,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3989_6a8fc1cc","label":1,"code":"\/**\r\n *  Invoke the component's onComponentTagBody().\r\n *\/\r\npublic void onComponentTagBody(final Component component, final MarkupStream markupStream, final ComponentTag openTag) {\r\n    component.onComponentTagBody(markupStream, openTag);\r\n}","code_comment":"\/**\r\n *  Invoke the component's onComponentTagBody().\r\n *\/\r\n","code_no_comment":"public void onComponentTagBody(final Component component, final MarkupStream markupStream, final ComponentTag openTag) {\r\n    component.onComponentTagBody(markupStream, openTag);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9441860465,"fo":-0.4166666667,"r":2.2368421053,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_add180fb","label":1,"code":"@Override\r\npublic void create(String tableName, boolean versioningIter, TimeType timeType) throws AccumuloException, AccumuloSecurityException, TableExistsException {\r\n    if (!tableName.matches(Constants.VALID_TABLE_NAME_REGEX)) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    acu.createTable(username, tableName, versioningIter, timeType);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void create(String tableName, boolean versioningIter, TimeType timeType) throws AccumuloException, AccumuloSecurityException, TableExistsException {\r\n    if (!tableName.matches(Constants.VALID_TABLE_NAME_REGEX)) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    acu.createTable(username, tableName, versioningIter, timeType);\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.3978858351,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"JxPath","project_version":"4","label":1,"code":"public Object getValue() {\r\n    if (node instanceof Element) {\r\n        return ((Element) node).getTextTrim();\r\n    }\r\n    if (node instanceof Comment) {\r\n        String text = ((Comment) node).getText();\r\n        if (text != null) {\r\n            text = text.trim();\r\n        }\r\n        return text;\r\n    }\r\n    if (node instanceof Text) {\r\n        return ((Text) node).getTextTrim();\r\n    }\r\n    if (node instanceof CDATA) {\r\n        return ((CDATA) node).getTextTrim();\r\n    }\r\n    if (node instanceof ProcessingInstruction) {\r\n        String text = ((ProcessingInstruction) node).getData();\r\n        if (text != null) {\r\n            text = text.trim();\r\n        }\r\n        return text;\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"public Object getValue() {\r\n    if (node instanceof Element) {\r\n        return ((Element) node).getTextTrim();\r\n    }\r\n    if (node instanceof Comment) {\r\n        String text = ((Comment) node).getText();\r\n        if (text != null) {\r\n            text = text.trim();\r\n        }\r\n        return text;\r\n    }\r\n    if (node instanceof Text) {\r\n        return ((Text) node).getTextTrim();\r\n    }\r\n    if (node instanceof CDATA) {\r\n        return ((CDATA) node).getTextTrim();\r\n    }\r\n    if (node instanceof ProcessingInstruction) {\r\n        String text = ((ProcessingInstruction) node).getData();\r\n        if (text != null) {\r\n            text = text.trim();\r\n        }\r\n        return text;\r\n    }\r\n    return null;\r\n}","lc":0.5454545455,"pi":0.0,"ma":0.8,"nbd":0.0,"ml":0.3333333333,"d":0.1924603175,"mi":-0.3477096547,"fo":0.0833333333,"r":0.0,"e":0.1129602416}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3433_e76d23b0","label":3,"code":"\/**\r\n * Returns an expression which converts the given expression to the given type the type\r\n * expression is evaluated to\r\n *\/\r\npublic static Expression convertToExpression(final Expression expression, final Expression type) {\r\n    return new ExpressionAdapter() {\r\n\r\n        public Object evaluate(Exchange exchange) {\r\n            return expression.evaluate(exchange, type.evaluate(exchange, Object.class).getClass());\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"\" + expression + \".convertToEvaluatedType(\" + type + \")\";\r\n        }\r\n    };\r\n}","code_comment":"\/**\r\n * Returns an expression which converts the given expression to the given type the type\r\n * expression is evaluated to\r\n *\/\r\n","code_no_comment":"public static Expression convertToExpression(final Expression expression, final Expression type) {\r\n    return new ExpressionAdapter() {\r\n\r\n        public Object evaluate(Exchange exchange) {\r\n            return expression.evaluate(exchange, type.evaluate(exchange, Object.class).getClass());\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"\" + expression + \".convertToEvaluatedType(\" + type + \")\";\r\n        }\r\n    };\r\n}","lc":-0.1363636364,"pi":0.4449760766,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.1732205779,"fo":-0.25,"r":0.7368421053,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1874_3ae276c1","label":1,"code":"@Override\r\npublic void enter(NodeState before, NodeState after) throws CommitFailedException {\r\n    collectIndexEditors(builder.getChildNode(INDEX_DEFINITIONS_NAME));\r\n    \/\/ no-op when reindex is empty\r\n    CommitFailedException exception = EditorDiff.process(CompositeEditor.compose(reindex.values()), MISSING_NODE, after);\r\n    if (exception != null) {\r\n        throw exception;\r\n    }\r\n    for (Editor editor : editors) {\r\n        editor.enter(before, after);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void enter(NodeState before, NodeState after) throws CommitFailedException {\r\n    collectIndexEditors(builder.getChildNode(INDEX_DEFINITIONS_NAME));\r\n        CommitFailedException exception = EditorDiff.process(CompositeEditor.compose(reindex.values()), MISSING_NODE, after);\r\n    if (exception != null) {\r\n        throw exception;\r\n    }\r\n    for (Editor editor : editors) {\r\n        editor.enter(before, after);\r\n    }\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":0.0,"nbd":-0.5,"ml":-0.25,"d":-0.0892857143,"mi":0.1145877378,"fo":0.0,"r":0.0263157895,"e":-0.0615180697}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-705_645d642b","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\r\n    sanityChecks(equations, t);\r\n    setEquations(equations);\r\n    resetEvaluations();\r\n    final boolean forward = t > equations.getTime();\r\n    \/\/ create some internal working arrays\r\n    final double[] y0 = equations.getCompleteState();\r\n    final double[] y = y0.clone();\r\n    final int stages = c.length + 1;\r\n    final double[][] yDotK = new double[stages][];\r\n    for (int i = 0; i < stages; ++i) {\r\n        yDotK[i] = new double[y0.length];\r\n    }\r\n    final double[] yTmp = new double[y0.length];\r\n    final double[] yDotTmp = new double[y0.length];\r\n    \/\/ set up an interpolator sharing the integrator arrays\r\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\r\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\r\n    interpolator.storeTime(equations.getTime());\r\n    \/\/ set up integration control objects\r\n    stepStart = equations.getTime();\r\n    stepSize = forward ? step : -step;\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.reset();\r\n    }\r\n    setStateInitialized(false);\r\n    \/\/ main integration loop\r\n    isLastStep = false;\r\n    do {\r\n        interpolator.shift();\r\n        \/\/ first stage\r\n        computeDerivatives(stepStart, y, yDotK[0]);\r\n        \/\/ next stages\r\n        for (int k = 1; k < stages; ++k) {\r\n            for (int j = 0; j < y0.length; ++j) {\r\n                double sum = a[k - 1][0] * yDotK[0][j];\r\n                for (int l = 1; l < k; ++l) {\r\n                    sum += a[k - 1][l] * yDotK[l][j];\r\n                }\r\n                yTmp[j] = y[j] + stepSize * sum;\r\n            }\r\n            computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\r\n        }\r\n        \/\/ estimate the state at the end of the step\r\n        for (int j = 0; j < y0.length; ++j) {\r\n            double sum = b[0] * yDotK[0][j];\r\n            for (int l = 1; l < stages; ++l) {\r\n                sum += b[l] * yDotK[l][j];\r\n            }\r\n            yTmp[j] = y[j] + stepSize * sum;\r\n        }\r\n        \/\/ discrete events handling\r\n        interpolator.storeTime(stepStart + stepSize);\r\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\r\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\r\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\r\n        if (!isLastStep) {\r\n            \/\/ prepare next step\r\n            interpolator.storeTime(stepStart);\r\n            \/\/ stepsize control for next step\r\n            final double nextT = stepStart + stepSize;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            if (nextIsLast) {\r\n                stepSize = t - stepStart;\r\n            }\r\n        }\r\n    } while (!isLastStep);\r\n    \/\/ dispatch results\r\n    equations.setTime(stepStart);\r\n    equations.setCompleteState(y);\r\n    stepStart = Double.NaN;\r\n    stepSize = Double.NaN;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\r\n    sanityChecks(equations, t);\r\n    setEquations(equations);\r\n    resetEvaluations();\r\n    final boolean forward = t > equations.getTime();\r\n        final double[] y0 = equations.getCompleteState();\r\n    final double[] y = y0.clone();\r\n    final int stages = c.length + 1;\r\n    final double[][] yDotK = new double[stages][];\r\n    for (int i = 0; i < stages; ++i) {\r\n        yDotK[i] = new double[y0.length];\r\n    }\r\n    final double[] yTmp = new double[y0.length];\r\n    final double[] yDotTmp = new double[y0.length];\r\n        final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\r\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\r\n    interpolator.storeTime(equations.getTime());\r\n        stepStart = equations.getTime();\r\n    stepSize = forward ? step : -step;\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.reset();\r\n    }\r\n    setStateInitialized(false);\r\n        isLastStep = false;\r\n    do {\r\n        interpolator.shift();\r\n                computeDerivatives(stepStart, y, yDotK[0]);\r\n                for (int k = 1; k < stages; ++k) {\r\n            for (int j = 0; j < y0.length; ++j) {\r\n                double sum = a[k - 1][0] * yDotK[0][j];\r\n                for (int l = 1; l < k; ++l) {\r\n                    sum += a[k - 1][l] * yDotK[l][j];\r\n                }\r\n                yTmp[j] = y[j] + stepSize * sum;\r\n            }\r\n            computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\r\n        }\r\n                for (int j = 0; j < y0.length; ++j) {\r\n            double sum = b[0] * yDotK[0][j];\r\n            for (int l = 1; l < stages; ++l) {\r\n                sum += b[l] * yDotK[l][j];\r\n            }\r\n            yTmp[j] = y[j] + stepSize * sum;\r\n        }\r\n                interpolator.storeTime(stepStart + stepSize);\r\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\r\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\r\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\r\n        if (!isLastStep) {\r\n                        interpolator.storeTime(stepStart);\r\n                        final double nextT = stepStart + stepSize;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            if (nextIsLast) {\r\n                stepSize = t - stepStart;\r\n            }\r\n        }\r\n    } while (!isLastStep);\r\n        equations.setTime(stepStart);\r\n    equations.setCompleteState(y);\r\n    stepStart = Double.NaN;\r\n    stepSize = Double.NaN;\r\n}","lc":2.2272727273,"pi":0.7703349282,"ma":1.8,"nbd":1.0,"ml":1.25,"d":3.2123015873,"mi":-1.0944326991,"fo":1.5833333333,"r":-0.0263157895,"e":14.5075984163}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-4211_4efddb3f","label":1,"code":"public static String createQueryString(Map<Object, Object> options) throws URISyntaxException {\r\n    try {\r\n        if (options.size() > 0) {\r\n            StringBuilder rc = new StringBuilder();\r\n            boolean first = true;\r\n            for (Object o : options.keySet()) {\r\n                if (first) {\r\n                    first = false;\r\n                } else {\r\n                    rc.append(\"&\");\r\n                }\r\n                String key = (String) o;\r\n                String value = (String) options.get(key);\r\n                rc.append(URLEncoder.encode(key, CHARSET));\r\n                \/\/ only append if value is not null\r\n                if (value != null) {\r\n                    rc.append(\"=\");\r\n                    rc.append(URLEncoder.encode(value, CHARSET));\r\n                }\r\n            }\r\n            return rc.toString();\r\n        } else {\r\n            return \"\";\r\n        }\r\n    } catch (UnsupportedEncodingException e) {\r\n        URISyntaxException se = new URISyntaxException(e.toString(), \"Invalid encoding\");\r\n        se.initCause(e);\r\n        throw se;\r\n    }\r\n}","code_comment":null,"code_no_comment":"public static String createQueryString(Map<Object, Object> options) throws URISyntaxException {\r\n    try {\r\n        if (options.size() > 0) {\r\n            StringBuilder rc = new StringBuilder();\r\n            boolean first = true;\r\n            for (Object o : options.keySet()) {\r\n                if (first) {\r\n                    first = false;\r\n                } else {\r\n                    rc.append(\"&\");\r\n                }\r\n                String key = (String) o;\r\n                String value = (String) options.get(key);\r\n                rc.append(URLEncoder.encode(key, CHARSET));\r\n                                if (value != null) {\r\n                    rc.append(\"=\");\r\n                    rc.append(URLEncoder.encode(value, CHARSET));\r\n                }\r\n            }\r\n            return rc.toString();\r\n        } else {\r\n            return \"\";\r\n        }\r\n    } catch (UnsupportedEncodingException e) {\r\n        URISyntaxException se = new URISyntaxException(e.toString(), \"Invalid encoding\");\r\n        se.initCause(e);\r\n        throw se;\r\n    }\r\n}","lc":0.6818181818,"pi":1.3205741627,"ma":0.6,"nbd":1.0,"ml":0.0833333333,"d":0.0436507937,"mi":-0.481042988,"fo":0.5,"r":0.0263157895,"e":0.2104781499}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-412_be2fdba7","label":1,"code":"@Override\r\npublic void run() {\r\n    ClientService.Iface client = null;\r\n    try {\r\n        client = ServerClient.getConnection(HdfsZooInstance.getInstance());\r\n        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\r\n        attempt.removeAll(fail);\r\n        filesToLoad.removeAll(attempt);\r\n    } catch (Exception ex) {\r\n        log.error(ex, ex);\r\n    } finally {\r\n        ServerClient.close(client);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void run() {\r\n    ClientService.Iface client = null;\r\n    try {\r\n        client = ServerClient.getConnection(HdfsZooInstance.getInstance());\r\n        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\r\n        attempt.removeAll(fail);\r\n        filesToLoad.removeAll(attempt);\r\n    } catch (Exception ex) {\r\n        log.error(ex, ex);\r\n    } finally {\r\n        ServerClient.close(client);\r\n    }\r\n}","lc":0.0,"pi":0.04784689,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.0249471459,"fo":0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Closure","project_version":"138","label":2,"code":"@Override\r\npublic FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {\r\n    if (condition.getType() == CALL && condition.getChildCount() == 2) {\r\n        Node callee = condition.getFirstChild();\r\n        Node param = condition.getLastChild();\r\n        if (callee.getType() == GETPROP && param.isQualifiedName()) {\r\n            JSType paramType = getTypeIfRefinable(param, blindScope);\r\n            if (paramType != null) {\r\n                Node left = callee.getFirstChild();\r\n                Node right = callee.getLastChild();\r\n                if (left.getType() == NAME && \"goog\".equals(left.getString()) && right.getType() == STRING) {\r\n                    Function<TypeRestriction, JSType> restricter = restricters.get(right.getString());\r\n                    if (restricter != null) {\r\n                        return restrictParameter(param, paramType, blindScope, restricter, outcome);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {\r\n    if (condition.getType() == CALL && condition.getChildCount() == 2) {\r\n        Node callee = condition.getFirstChild();\r\n        Node param = condition.getLastChild();\r\n        if (callee.getType() == GETPROP && param.isQualifiedName()) {\r\n            JSType paramType = getTypeIfRefinable(param, blindScope);\r\n            if (paramType != null) {\r\n                Node left = callee.getFirstChild();\r\n                Node right = callee.getLastChild();\r\n                if (left.getType() == NAME && \"goog\".equals(left.getString()) && right.getType() == STRING) {\r\n                    Function<TypeRestriction, JSType> restricter = restricters.get(right.getString());\r\n                    if (restricter != null) {\r\n                        return restrictParameter(param, paramType, blindScope, restricter, outcome);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);\r\n}","lc":0.3181818182,"pi":1.971291866,"ma":0.4,"nbd":1.5,"ml":1.1666666667,"d":0.4404761905,"mi":-0.3561663143,"fo":0.9166666667,"r":-0.0263157895,"e":0.7327651089}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5250_6122df49","label":1,"code":"@Override\r\npublic JavaScriptPackageResource getResource() {\r\n    return new JavaScriptPackageResource(getScope(), getName(), getLocale(), getStyle(), getVariation());\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic JavaScriptPackageResource getResource() {\r\n    return new JavaScriptPackageResource(getScope(), getName(), getLocale(), getStyle(), getVariation());\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8314305849,"fo":-0.0833333333,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4353_b0014b7d","label":1,"code":"public static int getGcGen(ByteBuffer data) {\r\n    return data.getInt(GC_GEN_OFFSET);\r\n}","code_comment":null,"code_no_comment":"public static int getGcGen(ByteBuffer data) {\r\n    return data.getInt(GC_GEN_OFFSET);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0451021846,"fo":-0.4166666667,"r":1.8157894737,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-846_7acb091a","label":3,"code":"private static boolean markCommitRoot(@Nonnull Map<String, Object> document, @Nonnull String revision, @Nonnull DocumentStore store) {\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<String, Integer> commitRoots = (Map<String, Integer>) document.get(UpdateOp.COMMIT_ROOT);\r\n    if (commitRoots != null) {\r\n        Integer depth = commitRoots.get(revision);\r\n        if (depth != null) {\r\n            String p = Utils.getPathFromId((String) document.get(UpdateOp.ID));\r\n            String commitRootPath = PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - depth);\r\n            UpdateOp op = new UpdateOp(commitRootPath, Utils.getIdFromPath(commitRootPath), false);\r\n            op.setMapEntry(UpdateOp.COLLISIONS, revision, true);\r\n            \/\/ TODO: detect concurrent commit of previously un-merged changes\r\n            \/\/ TODO: check _commitRoot for revision is not 'true'\r\n            store.createOrUpdate(DocumentStore.Collection.NODES, op);\r\n            LOG.debug(\"Marked collision on: {} for {} ({})\", new Object[] { commitRootPath, p, revision });\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"private static boolean markCommitRoot(@Nonnull Map<String, Object> document, @Nonnull String revision, @Nonnull DocumentStore store) {\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<String, Integer> commitRoots = (Map<String, Integer>) document.get(UpdateOp.COMMIT_ROOT);\r\n    if (commitRoots != null) {\r\n        Integer depth = commitRoots.get(revision);\r\n        if (depth != null) {\r\n            String p = Utils.getPathFromId((String) document.get(UpdateOp.ID));\r\n            String commitRootPath = PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - depth);\r\n            UpdateOp op = new UpdateOp(commitRootPath, Utils.getIdFromPath(commitRootPath), false);\r\n            op.setMapEntry(UpdateOp.COLLISIONS, revision, true);\r\n                                    store.createOrUpdate(DocumentStore.Collection.NODES, op);\r\n            LOG.debug(\"Marked collision on: {} for {} ({})\", new Object[] { commitRootPath, p, revision });\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","lc":0.1363636364,"pi":0.6315789474,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":0.0515873016,"mi":-0.2422832981,"fo":0.3333333333,"r":-0.0263157895,"e":0.307641062}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4391_5d64196a","label":3,"code":"@Override\r\npublic MarkupType getMarkupType() {\r\n    return new MarkupType(\"xsl\", null);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic MarkupType getMarkupType() {\r\n    return new MarkupType(\"xsl\", null);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9134601832,"fo":-0.5,"r":1.3157894737,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3278_60d07288","label":1,"code":"\/**\r\n *  @see FormComponent#getModelValue()\r\n *\/\r\n@Override\r\npublic String getModelValue() {\r\n    final T object = getModelObject();\r\n    if (object != null) {\r\n        int index = getChoices().indexOf(object);\r\n        return getChoiceRenderer().getIdValue(object, index);\r\n    }\r\n    return getNoSelectionValue().toString();\r\n}","code_comment":"\/**\r\n *  @see FormComponent#getModelValue()\r\n *\/\r\n","code_no_comment":"@Override\r\npublic String getModelValue() {\r\n    final T object = getModelObject();\r\n    if (object != null) {\r\n        int index = getChoices().indexOf(object);\r\n        return getChoiceRenderer().getIdValue(object, index);\r\n    }\r\n    return getNoSelectionValue().toString();\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1130952381,"mi":0.3017618041,"fo":0.0833333333,"r":1.7631578947,"e":-0.1102816341}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2999_3bf07779","label":1,"code":"private Document makeDocument(String path, NodeState state, boolean isUpdate) {\r\n    if (!isIndexable()) {\r\n        return null;\r\n    }\r\n    List<Field> fields = new ArrayList<Field>();\r\n    boolean dirty = false;\r\n    for (PropertyState property : state.getProperties()) {\r\n        String pname = property.getName();\r\n        if (!isVisible(pname)) {\r\n            continue;\r\n        }\r\n        PropertyDefinition pd = indexingRule.getConfig(pname);\r\n        if (pd == null || !pd.index) {\r\n            continue;\r\n        }\r\n        if (pd.ordered) {\r\n            dirty |= addTypedOrderedFields(fields, property, pname, pd);\r\n        }\r\n        dirty |= indexProperty(path, fields, state, property, pname, pd);\r\n    }\r\n    dirty |= indexAggregates(path, fields, state);\r\n    dirty |= indexNullCheckEnabledProps(path, fields, state);\r\n    dirty |= indexNotNullCheckEnabledProps(path, fields, state);\r\n    if (isUpdate && !dirty) {\r\n        \/\/ updated the state but had no relevant changes\r\n        return null;\r\n    }\r\n    \/\/ none of the properties are indexed\r\n    if (!indexingRule.isFulltextEnabled() && !dirty) {\r\n        return null;\r\n    }\r\n    Document document = new Document();\r\n    document.add(newPathField(path));\r\n    String name = getName(path);\r\n    \/\/ TODO Possibly index nodeName without tokenization for node name based queries\r\n    if (indexingRule.isFulltextEnabled()) {\r\n        document.add(newFulltextField(name));\r\n    }\r\n    if (getDefinition().evaluatePathRestrictions()) {\r\n        document.add(newAncestorsField(PathUtils.getParentPath(path)));\r\n        document.add(newDepthField(path));\r\n    }\r\n    \/\/ because of LUCENE-5833 we have to merge the suggest fields into a single one\r\n    Field suggestField = null;\r\n    for (Field f : fields) {\r\n        if (FieldNames.SUGGEST.endsWith(f.name())) {\r\n            if (suggestField == null) {\r\n                suggestField = FieldFactory.newSuggestField(f.stringValue());\r\n            } else {\r\n                suggestField = FieldFactory.newSuggestField(suggestField.stringValue(), f.stringValue());\r\n            }\r\n        } else {\r\n            document.add(f);\r\n        }\r\n    }\r\n    if (suggestField != null) {\r\n        document.add(suggestField);\r\n    }\r\n    return document;\r\n}","code_comment":null,"code_no_comment":"private Document makeDocument(String path, NodeState state, boolean isUpdate) {\r\n    if (!isIndexable()) {\r\n        return null;\r\n    }\r\n    List<Field> fields = new ArrayList<Field>();\r\n    boolean dirty = false;\r\n    for (PropertyState property : state.getProperties()) {\r\n        String pname = property.getName();\r\n        if (!isVisible(pname)) {\r\n            continue;\r\n        }\r\n        PropertyDefinition pd = indexingRule.getConfig(pname);\r\n        if (pd == null || !pd.index) {\r\n            continue;\r\n        }\r\n        if (pd.ordered) {\r\n            dirty |= addTypedOrderedFields(fields, property, pname, pd);\r\n        }\r\n        dirty |= indexProperty(path, fields, state, property, pname, pd);\r\n    }\r\n    dirty |= indexAggregates(path, fields, state);\r\n    dirty |= indexNullCheckEnabledProps(path, fields, state);\r\n    dirty |= indexNotNullCheckEnabledProps(path, fields, state);\r\n    if (isUpdate && !dirty) {\r\n                return null;\r\n    }\r\n        if (!indexingRule.isFulltextEnabled() && !dirty) {\r\n        return null;\r\n    }\r\n    Document document = new Document();\r\n    document.add(newPathField(path));\r\n    String name = getName(path);\r\n        if (indexingRule.isFulltextEnabled()) {\r\n        document.add(newFulltextField(name));\r\n    }\r\n    if (getDefinition().evaluatePathRestrictions()) {\r\n        document.add(newAncestorsField(PathUtils.getParentPath(path)));\r\n        document.add(newDepthField(path));\r\n    }\r\n        Field suggestField = null;\r\n    for (Field f : fields) {\r\n        if (FieldNames.SUGGEST.endsWith(f.name())) {\r\n            if (suggestField == null) {\r\n                suggestField = FieldFactory.newSuggestField(f.stringValue());\r\n            } else {\r\n                suggestField = FieldFactory.newSuggestField(suggestField.stringValue(), f.stringValue());\r\n            }\r\n        } else {\r\n            document.add(f);\r\n        }\r\n    }\r\n    if (suggestField != null) {\r\n        document.add(suggestField);\r\n    }\r\n    return document;\r\n}","lc":1.9090909091,"pi":0.2392344498,"ma":2.4,"nbd":0.5,"ml":1.8333333333,"d":1.1726190476,"mi":-0.9712473573,"fo":2.25,"r":-0.0263157895,"e":3.2794799537}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-373_bfe4623c","label":1,"code":"\/**\r\n * <p>Returns the weighted product of the entries in the specified portion of\r\n * the input array, or <code>Double.NaN<\/code> if the designated subarray\r\n * is empty.<\/p>\r\n *\r\n * <p>Throws <code>IllegalArgumentException<\/code> if any of the following are true:\r\n * <ul><li>the values array is null<\/li>\r\n *     <li>the weights array is null<\/li>\r\n *     <li>the weights array does not have the same length as the values array<\/li>\r\n *     <li>the weights array contains one or more infinite values<\/li>\r\n *     <li>the weights array contains one or more NaN values<\/li>\r\n *     <li>the weights array contains negative values<\/li>\r\n *     <li>the start and length arguments do not determine a valid array<\/li>\r\n * <\/ul><\/p>\r\n *\r\n * <p>Uses the formula, <pre>\r\n *    weighted product = &prod;values[i]<sup>weights[i]<\/sup>\r\n * <\/pre>\r\n * that is, the weights are applied as exponents when computing the weighted product.<\/p>\r\n *\r\n * @param values the input array\r\n * @param weights the weights array\r\n * @param begin index of the first array element to include\r\n * @param length the number of elements to include\r\n * @return the product of the values or Double.NaN if length = 0\r\n * @throws IllegalArgumentException if the parameters are not valid\r\n * @since 2.1\r\n *\/\r\npublic double evaluate(final double[] values, final double[] weights, final int begin, final int length) {\r\n    double product = Double.NaN;\r\n    if (test(values, weights, begin, length)) {\r\n        product = 1.0;\r\n        for (int i = begin; i < begin + length; i++) {\r\n            product *= FastMath.pow(values[i], weights[i]);\r\n        }\r\n    }\r\n    return product;\r\n}","code_comment":"\/**\r\n * <p>Returns the weighted product of the entries in the specified portion of\r\n * the input array, or <code>Double.NaN<\/code> if the designated subarray\r\n * is empty.<\/p>\r\n *\r\n * <p>Throws <code>IllegalArgumentException<\/code> if any of the following are true:\r\n * <ul><li>the values array is null<\/li>\r\n *     <li>the weights array is null<\/li>\r\n *     <li>the weights array does not have the same length as the values array<\/li>\r\n *     <li>the weights array contains one or more infinite values<\/li>\r\n *     <li>the weights array contains one or more NaN values<\/li>\r\n *     <li>the weights array contains negative values<\/li>\r\n *     <li>the start and length arguments do not determine a valid array<\/li>\r\n * <\/ul><\/p>\r\n *\r\n * <p>Uses the formula, <pre>\r\n *    weighted product = &prod;values[i]<sup>weights[i]<\/sup>\r\n * <\/pre>\r\n * that is, the weights are applied as exponents when computing the weighted product.<\/p>\r\n *\r\n * @param values the input array\r\n * @param weights the weights array\r\n * @param begin index of the first array element to include\r\n * @param length the number of elements to include\r\n * @return the product of the values or Double.NaN if length = 0\r\n * @throws IllegalArgumentException if the parameters are not valid\r\n * @since 2.1\r\n *\/\r\n","code_no_comment":"public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {\r\n    double product = Double.NaN;\r\n    if (test(values, weights, begin, length)) {\r\n        product = 1.0;\r\n        for (int i = begin; i < begin + length; i++) {\r\n            product *= FastMath.pow(values[i], weights[i]);\r\n        }\r\n    }\r\n    return product;\r\n}","lc":-0.1818181818,"pi":0.2918660287,"ma":-0.2,"nbd":0.0,"ml":0.25,"d":0.4861111111,"mi":0.1653276956,"fo":-0.3333333333,"r":-0.0263157895,"e":0.1477590867}
{"project_name":"Compress","project_version":"5","label":1,"code":"public int read(byte[] buffer, int start, int length) throws IOException {\r\n    if (closed) {\r\n        throw new IOException(\"The stream is closed\");\r\n    }\r\n    if (inf.finished() || current == null) {\r\n        return -1;\r\n    }\r\n    \/\/ avoid int overflow, check null buffer\r\n    if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) {\r\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\r\n            int csize = (int) current.getSize();\r\n            if (readBytesOfEntry >= csize) {\r\n                return -1;\r\n            }\r\n            if (offsetInBuffer >= lengthOfLastRead) {\r\n                offsetInBuffer = 0;\r\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\r\n                    return -1;\r\n                }\r\n                count(lengthOfLastRead);\r\n                bytesReadFromStream += lengthOfLastRead;\r\n            }\r\n            int toRead = length > lengthOfLastRead ? lengthOfLastRead - offsetInBuffer : length;\r\n            if ((csize - readBytesOfEntry) < toRead) {\r\n                toRead = csize - readBytesOfEntry;\r\n            }\r\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\r\n            offsetInBuffer += toRead;\r\n            readBytesOfEntry += toRead;\r\n            crc.update(buffer, start, toRead);\r\n            return toRead;\r\n        }\r\n        if (inf.needsInput()) {\r\n            fill();\r\n            if (lengthOfLastRead > 0) {\r\n                bytesReadFromStream += lengthOfLastRead;\r\n            }\r\n        }\r\n        int read = 0;\r\n        try {\r\n            read = inf.inflate(buffer, start, length);\r\n        } catch (DataFormatException e) {\r\n            throw new ZipException(e.getMessage());\r\n        }\r\n        if (read == 0 && inf.finished()) {\r\n            return -1;\r\n        }\r\n        crc.update(buffer, start, read);\r\n        return read;\r\n    }\r\n    throw new ArrayIndexOutOfBoundsException();\r\n}","code_comment":null,"code_no_comment":"public int read(byte[] buffer, int start, int length) throws IOException {\r\n    if (closed) {\r\n        throw new IOException(\"The stream is closed\");\r\n    }\r\n    if (inf.finished() || current == null) {\r\n        return -1;\r\n    }\r\n        if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) {\r\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\r\n            int csize = (int) current.getSize();\r\n            if (readBytesOfEntry >= csize) {\r\n                return -1;\r\n            }\r\n            if (offsetInBuffer >= lengthOfLastRead) {\r\n                offsetInBuffer = 0;\r\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\r\n                    return -1;\r\n                }\r\n                count(lengthOfLastRead);\r\n                bytesReadFromStream += lengthOfLastRead;\r\n            }\r\n            int toRead = length > lengthOfLastRead ? lengthOfLastRead - offsetInBuffer : length;\r\n            if ((csize - readBytesOfEntry) < toRead) {\r\n                toRead = csize - readBytesOfEntry;\r\n            }\r\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\r\n            offsetInBuffer += toRead;\r\n            readBytesOfEntry += toRead;\r\n            crc.update(buffer, start, toRead);\r\n            return toRead;\r\n        }\r\n        if (inf.needsInput()) {\r\n            fill();\r\n            if (lengthOfLastRead > 0) {\r\n                bytesReadFromStream += lengthOfLastRead;\r\n            }\r\n        }\r\n        int read = 0;\r\n        try {\r\n            read = inf.inflate(buffer, start, length);\r\n        } catch (DataFormatException e) {\r\n            throw new ZipException(e.getMessage());\r\n        }\r\n        if (read == 0 && inf.finished()) {\r\n            return -1;\r\n        }\r\n        crc.update(buffer, start, read);\r\n        return read;\r\n    }\r\n    throw new ArrayIndexOutOfBoundsException();\r\n}","lc":1.6818181818,"pi":0.6555023923,"ma":2.6,"nbd":1.0,"ml":2.1666666667,"d":2.4325396825,"mi":-0.9134601832,"fo":0.5833333333,"r":-0.0263157895,"e":5.2400223601}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1192_9476b877","label":3,"code":"public static void printDiskUsage(AccumuloConfiguration acuConf, Collection<String> tables, FileSystem fs, Connector conn, Printer printer) throws TableNotFoundException, IOException {\r\n    TableDiskUsage tdu = new TableDiskUsage();\r\n    HashSet<String> tableIds = new HashSet<String>();\r\n    for (String tableName : tables) {\r\n        String tableId = conn.tableOperations().tableIdMap().get(tableName);\r\n        if (tableId == null)\r\n            throw new TableNotFoundException(null, tableName, \"Table \" + tableName + \" not found\");\r\n        tableIds.add(tableId);\r\n    }\r\n    for (String tableId : tableIds) tdu.addTable(tableId);\r\n    HashSet<String> tablesReferenced = new HashSet<String>(tableIds);\r\n    for (String tableId : tableIds) {\r\n        Scanner mdScanner = conn.createScanner(Constants.METADATA_TABLE_NAME, Constants.NO_AUTHS);\r\n        mdScanner.fetchColumnFamily(Constants.METADATA_DATAFILE_COLUMN_FAMILY);\r\n        mdScanner.setRange(new KeyExtent(new Text(tableId), null, null).toMetadataRange());\r\n        for (Entry<Key, Value> entry : mdScanner) {\r\n            String file = entry.getKey().getColumnQualifier().toString();\r\n            if (file.startsWith(\"..\/\")) {\r\n                file = file.substring(2);\r\n                tablesReferenced.add(file.split(\"\\\\\/\")[1]);\r\n            } else\r\n                file = \"\/\" + tableId + file;\r\n            tdu.linkFileAndTable(tableId, file);\r\n        }\r\n    }\r\n    for (String tableId : tablesReferenced) {\r\n        FileStatus[] files = fs.globStatus(new Path(Constants.getTablesDir(acuConf) + \"\/\" + tableId + \"\/*\/*\"));\r\n        for (FileStatus fileStatus : files) {\r\n            String dir = fileStatus.getPath().getParent().getName();\r\n            String name = fileStatus.getPath().getName();\r\n            tdu.addFileSize(\"\/\" + tableId + \"\/\" + dir + \"\/\" + name, fileStatus.getLen());\r\n        }\r\n    }\r\n    HashMap<String, String> reverseTableIdMap = new HashMap<String, String>();\r\n    for (Entry<String, String> entry : conn.tableOperations().tableIdMap().entrySet()) reverseTableIdMap.put(entry.getValue(), entry.getKey());\r\n    TreeMap<TreeSet<String>, Long> usage = new TreeMap<TreeSet<String>, Long>(new Comparator<TreeSet<String>>() {\r\n\r\n        @Override\r\n        public int compare(TreeSet<String> o1, TreeSet<String> o2) {\r\n            int len1 = o1.size();\r\n            int len2 = o2.size();\r\n            int min = Math.min(len1, len2);\r\n            Iterator<String> iter1 = o1.iterator();\r\n            Iterator<String> iter2 = o2.iterator();\r\n            int count = 0;\r\n            while (count < min) {\r\n                String s1 = iter1.next();\r\n                String s2 = iter2.next();\r\n                int cmp = s1.compareTo(s2);\r\n                if (cmp != 0)\r\n                    return cmp;\r\n                count++;\r\n            }\r\n            return len1 - len2;\r\n        }\r\n    });\r\n    for (Entry<List<String>, Long> entry : tdu.calculateUsage().entrySet()) {\r\n        TreeSet<String> tableNames = new TreeSet<String>();\r\n        for (String tableId : entry.getKey()) tableNames.add(reverseTableIdMap.get(tableId));\r\n        usage.put(tableNames, entry.getValue());\r\n    }\r\n    for (Entry<TreeSet<String>, Long> entry : usage.entrySet()) printer.print(String.format(\"%,24d %s\", entry.getValue(), entry.getKey()));\r\n}","code_comment":null,"code_no_comment":"public static void printDiskUsage(AccumuloConfiguration acuConf, Collection<String> tables, FileSystem fs, Connector conn, Printer printer) throws TableNotFoundException, IOException {\r\n    TableDiskUsage tdu = new TableDiskUsage();\r\n    HashSet<String> tableIds = new HashSet<String>();\r\n    for (String tableName : tables) {\r\n        String tableId = conn.tableOperations().tableIdMap().get(tableName);\r\n        if (tableId == null)\r\n            throw new TableNotFoundException(null, tableName, \"Table \" + tableName + \" not found\");\r\n        tableIds.add(tableId);\r\n    }\r\n    for (String tableId : tableIds) tdu.addTable(tableId);\r\n    HashSet<String> tablesReferenced = new HashSet<String>(tableIds);\r\n    for (String tableId : tableIds) {\r\n        Scanner mdScanner = conn.createScanner(Constants.METADATA_TABLE_NAME, Constants.NO_AUTHS);\r\n        mdScanner.fetchColumnFamily(Constants.METADATA_DATAFILE_COLUMN_FAMILY);\r\n        mdScanner.setRange(new KeyExtent(new Text(tableId), null, null).toMetadataRange());\r\n        for (Entry<Key, Value> entry : mdScanner) {\r\n            String file = entry.getKey().getColumnQualifier().toString();\r\n            if (file.startsWith(\"..\/\")) {\r\n                file = file.substring(2);\r\n                tablesReferenced.add(file.split(\"\\\\\/\")[1]);\r\n            } else\r\n                file = \"\/\" + tableId + file;\r\n            tdu.linkFileAndTable(tableId, file);\r\n        }\r\n    }\r\n    for (String tableId : tablesReferenced) {\r\n        FileStatus[] files = fs.globStatus(new Path(Constants.getTablesDir(acuConf) + \"\/\" + tableId + \"\/*\/*\"));\r\n        for (FileStatus fileStatus : files) {\r\n            String dir = fileStatus.getPath().getParent().getName();\r\n            String name = fileStatus.getPath().getName();\r\n            tdu.addFileSize(\"\/\" + tableId + \"\/\" + dir + \"\/\" + name, fileStatus.getLen());\r\n        }\r\n    }\r\n    HashMap<String, String> reverseTableIdMap = new HashMap<String, String>();\r\n    for (Entry<String, String> entry : conn.tableOperations().tableIdMap().entrySet()) reverseTableIdMap.put(entry.getValue(), entry.getKey());\r\n    TreeMap<TreeSet<String>, Long> usage = new TreeMap<TreeSet<String>, Long>(new Comparator<TreeSet<String>>() {\r\n\r\n        @Override\r\n        public int compare(TreeSet<String> o1, TreeSet<String> o2) {\r\n            int len1 = o1.size();\r\n            int len2 = o2.size();\r\n            int min = Math.min(len1, len2);\r\n            Iterator<String> iter1 = o1.iterator();\r\n            Iterator<String> iter2 = o2.iterator();\r\n            int count = 0;\r\n            while (count < min) {\r\n                String s1 = iter1.next();\r\n                String s2 = iter2.next();\r\n                int cmp = s1.compareTo(s2);\r\n                if (cmp != 0)\r\n                    return cmp;\r\n                count++;\r\n            }\r\n            return len1 - len2;\r\n        }\r\n    });\r\n    for (Entry<List<String>, Long> entry : tdu.calculateUsage().entrySet()) {\r\n        TreeSet<String> tableNames = new TreeSet<String>();\r\n        for (String tableId : entry.getKey()) tableNames.add(reverseTableIdMap.get(tableId));\r\n        usage.put(tableNames, entry.getValue());\r\n    }\r\n    for (Entry<TreeSet<String>, Long> entry : usage.entrySet()) printer.print(String.format(\"%,24d %s\", entry.getValue(), entry.getKey()));\r\n}","lc":2.1818181818,"pi":0.7368421053,"ma":2.4,"nbd":0.5,"ml":0.3333333333,"d":1.1428571429,"mi":-1.1330514447,"fo":3.8333333333,"r":-0.0263157895,"e":7.2346858918}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"private TException translateException(Exception ex) {\r\n    try {\r\n        throw ex;\r\n    } catch (MutationsRejectedException e) {\r\n        logger.debug(e, e);\r\n        return new org.apache.accumulo.proxy.thrift.MutationsRejectedException(e.toString());\r\n    } catch (AccumuloException e) {\r\n        logger.debug(e, e);\r\n        return new org.apache.accumulo.proxy.thrift.AccumuloException(e.toString());\r\n    } catch (AccumuloSecurityException e) {\r\n        logger.debug(e, e);\r\n        if (e.getSecurityErrorCode().equals(SecurityErrorCode.TABLE_DOESNT_EXIST))\r\n            return new org.apache.accumulo.proxy.thrift.TableNotFoundException(e.toString());\r\n        return new org.apache.accumulo.proxy.thrift.AccumuloSecurityException(e.toString());\r\n    } catch (TableNotFoundException e) {\r\n        logger.debug(e, e);\r\n        return new org.apache.accumulo.proxy.thrift.TableNotFoundException(e.toString());\r\n    } catch (TableExistsException e) {\r\n        logger.debug(e, e);\r\n        return new org.apache.accumulo.proxy.thrift.TableExistsException(e.toString());\r\n    } catch (RuntimeException e) {\r\n        if (e.getCause() != null) {\r\n            if (e.getCause() instanceof Exception)\r\n                return translateException((Exception) e.getCause());\r\n        }\r\n        return new TException(e);\r\n    } catch (Exception e) {\r\n        return new TException(ex);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private TException translateException(Exception ex) {\r\n    try {\r\n        throw ex;\r\n    } catch (MutationsRejectedException e) {\r\n        logger.debug(e, e);\r\n        return new org.apache.accumulo.proxy.thrift.MutationsRejectedException(e.toString());\r\n    } catch (AccumuloException e) {\r\n        logger.debug(e, e);\r\n        return new org.apache.accumulo.proxy.thrift.AccumuloException(e.toString());\r\n    } catch (AccumuloSecurityException e) {\r\n        logger.debug(e, e);\r\n        if (e.getSecurityErrorCode().equals(SecurityErrorCode.TABLE_DOESNT_EXIST))\r\n            return new org.apache.accumulo.proxy.thrift.TableNotFoundException(e.toString());\r\n        return new org.apache.accumulo.proxy.thrift.AccumuloSecurityException(e.toString());\r\n    } catch (TableNotFoundException e) {\r\n        logger.debug(e, e);\r\n        return new org.apache.accumulo.proxy.thrift.TableNotFoundException(e.toString());\r\n    } catch (TableExistsException e) {\r\n        logger.debug(e, e);\r\n        return new org.apache.accumulo.proxy.thrift.TableExistsException(e.toString());\r\n    } catch (RuntimeException e) {\r\n        if (e.getCause() != null) {\r\n            if (e.getCause() instanceof Exception)\r\n                return translateException((Exception) e.getCause());\r\n        }\r\n        return new TException(e);\r\n    } catch (Exception e) {\r\n        return new TException(ex);\r\n    }\r\n}","lc":0.7272727273,"pi":0.1435406699,"ma":1.6,"nbd":0.0,"ml":0.0,"d":-0.3650793651,"mi":-0.5681465821,"fo":0.9166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-209_76d727f0","label":1,"code":"@Override\r\npublic IteratorOptions describeOptions() {\r\n    IteratorOptions io = super.describeOptions();\r\n    io.setName(\"regex\");\r\n    io.setDescription(\"The RegExFilter\/Iterator allows you to filter for key\/value pairs based on regular expressions\");\r\n    io.addNamedOption(RegExFilter.ROW_REGEX, \"regular expression on row\");\r\n    io.addNamedOption(RegExFilter.COLF_REGEX, \"regular expression on column family\");\r\n    io.addNamedOption(RegExFilter.COLQ_REGEX, \"regular expression on column qualifier\");\r\n    io.addNamedOption(RegExFilter.VALUE_REGEX, \"regular expression on value\");\r\n    io.addNamedOption(RegExFilter.OR_FIELDS, \"use OR instread of AND when multiple regexes given\");\r\n    return io;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic IteratorOptions describeOptions() {\r\n    IteratorOptions io = super.describeOptions();\r\n    io.setName(\"regex\");\r\n    io.setDescription(\"The RegExFilter\/Iterator allows you to filter for key\/value pairs based on regular expressions\");\r\n    io.addNamedOption(RegExFilter.ROW_REGEX, \"regular expression on row\");\r\n    io.addNamedOption(RegExFilter.COLF_REGEX, \"regular expression on column family\");\r\n    io.addNamedOption(RegExFilter.COLQ_REGEX, \"regular expression on column qualifier\");\r\n    io.addNamedOption(RegExFilter.VALUE_REGEX, \"regular expression on value\");\r\n    io.addNamedOption(RegExFilter.OR_FIELDS, \"use OR instread of AND when multiple regexes given\");\r\n    return io;\r\n}","lc":-0.0909090909,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.0765327696,"fo":0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Compress","project_version":"39","label":1,"code":"\/**\r\n * Returns a \"sanitized\" version of the string given as arguments,\r\n * where sanitized means non-printable characters have been\r\n * replaced with a question mark and the outcome is not longer\r\n * than 255 chars.\r\n *\r\n * <p>This method is used to clean up file names when they are\r\n * used in exception messages as they may end up in log files or\r\n * as console output and may have been read from a corrupted\r\n * input.<\/p>\r\n *\r\n * @param s the string to sanitize\r\n * @return a sanitized version of the argument\r\n * @since Compress 1.12\r\n *\/\r\npublic static String sanitize(String s) {\r\n    final char[] chars = s.toCharArray();\r\n    final int len = chars.length;\r\n    final StringBuilder sb = new StringBuilder();\r\n    for (int i = 0; i < len; i++) {\r\n        final char c = chars[i];\r\n        if (!Character.isISOControl(c)) {\r\n            Character.UnicodeBlock block = Character.UnicodeBlock.of(c);\r\n            if (block != null && block != Character.UnicodeBlock.SPECIALS) {\r\n                sb.append(c);\r\n                continue;\r\n            }\r\n        }\r\n        sb.append('?');\r\n    }\r\n    return sb.toString();\r\n}","code_comment":"\/**\r\n * Returns a \"sanitized\" version of the string given as arguments,\r\n * where sanitized means non-printable characters have been\r\n * replaced with a question mark and the outcome is not longer\r\n * than 255 chars.\r\n *\r\n * <p>This method is used to clean up file names when they are\r\n * used in exception messages as they may end up in log files or\r\n * as console output and may have been read from a corrupted\r\n * input.<\/p>\r\n *\r\n * @param s the string to sanitize\r\n * @return a sanitized version of the argument\r\n * @since Compress 1.12\r\n *\/\r\n","code_no_comment":"public static String sanitize(String s) {\r\n    final char[] chars = s.toCharArray();\r\n    final int len = chars.length;\r\n    final StringBuilder sb = new StringBuilder();\r\n    for (int i = 0; i < len; i++) {\r\n        final char c = chars[i];\r\n        if (!Character.isISOControl(c)) {\r\n            Character.UnicodeBlock block = Character.UnicodeBlock.of(c);\r\n            if (block != null && block != Character.UnicodeBlock.SPECIALS) {\r\n                sb.append(c);\r\n                continue;\r\n            }\r\n        }\r\n        sb.append('?');\r\n    }\r\n    return sb.toString();\r\n}","lc":0.1363636364,"pi":0.8660287081,"ma":0.2,"nbd":0.5,"ml":0.3333333333,"d":0.8253968254,"mi":-0.1754756871,"fo":0.0,"r":1.1842105263,"e":0.6166214277}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-334_9d8cc45d","label":1,"code":"@Override\r\npublic VersioningIterator deepCopy(IteratorEnvironment env) {\r\n    return new VersioningIterator(this, env);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic VersioningIterator deepCopy(IteratorEnvironment env) {\r\n    return new VersioningIterator(this, env);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8940098661,"fo":-0.5,"r":1.1315789474,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-949_f83bbc1d","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected PointValuePair doOptimize() {\r\n    \/\/ -------------------- Initialization --------------------------------\r\n    isMinimize = getGoalType().equals(GoalType.MINIMIZE);\r\n    final FitnessFunction fitfun = new FitnessFunction();\r\n    final double[] guess = getStartPoint();\r\n    \/\/ number of objective variables\/problem dimension\r\n    dimension = guess.length;\r\n    initializeCMA(guess);\r\n    iterations = 0;\r\n    double bestValue = fitfun.value(guess);\r\n    push(fitnessHistory, bestValue);\r\n    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);\r\n    PointValuePair lastResult = null;\r\n    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {\r\n        \/\/ Generate and evaluate lambda offspring\r\n        final RealMatrix arz = randn1(dimension, lambda);\r\n        final RealMatrix arx = zeros(dimension, lambda);\r\n        final double[] fitness = new double[lambda];\r\n        \/\/ generate random offspring\r\n        for (int k = 0; k < lambda; k++) {\r\n            RealMatrix arxk = null;\r\n            for (int i = 0; i < checkFeasableCount + 1; i++) {\r\n                if (diagonalOnly <= 0) {\r\n                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(\/\/ m + sig * Normal(0,C)\r\n                    sigma));\r\n                } else {\r\n                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));\r\n                }\r\n                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\r\n                    break;\r\n                }\r\n                \/\/ regenerate random arguments for row\r\n                arz.setColumn(k, randn(dimension));\r\n            }\r\n            copyColumn(arxk, 0, arx, k);\r\n            try {\r\n                \/\/ compute fitness\r\n                fitness[k] = fitfun.value(arx.getColumn(k));\r\n            } catch (TooManyEvaluationsException e) {\r\n                break generationLoop;\r\n            }\r\n        }\r\n        \/\/ Sort by fitness and compute weighted mean into xmean\r\n        final int[] arindex = sortedIndices(fitness);\r\n        \/\/ Calculate new xmean, this is selection and recombination\r\n        \/\/ for speed up of Eq. (2) and (3)\r\n        final RealMatrix xold = xmean;\r\n        final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\r\n        xmean = bestArx.multiply(weights);\r\n        final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\r\n        final RealMatrix zmean = bestArz.multiply(weights);\r\n        final boolean hsig = updateEvolutionPaths(zmean, xold);\r\n        if (diagonalOnly <= 0) {\r\n            updateCovariance(hsig, bestArx, arz, arindex, xold);\r\n        } else {\r\n            updateCovarianceDiagonalOnly(hsig, bestArz);\r\n        }\r\n        \/\/ Adapt step size sigma - Eq. (5)\r\n        sigma *= Math.exp(Math.min(1, (normps \/ chiN - 1) * cs \/ damps));\r\n        final double bestFitness = fitness[arindex[0]];\r\n        final double worstFitness = fitness[arindex[arindex.length - 1]];\r\n        if (bestValue > bestFitness) {\r\n            bestValue = bestFitness;\r\n            lastResult = optimum;\r\n            optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);\r\n            if (getConvergenceChecker() != null && lastResult != null) {\r\n                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\r\n                    break generationLoop;\r\n                }\r\n            }\r\n        }\r\n        \/\/ Break, if fitness is good enough\r\n        if (stopFitness != 0) {\r\n            \/\/ only if stopFitness is defined\r\n            if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\r\n                break generationLoop;\r\n            }\r\n        }\r\n        final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\r\n        final double[] pcCol = pc.getColumn(0);\r\n        for (int i = 0; i < dimension; i++) {\r\n            if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {\r\n                break;\r\n            }\r\n            if (i >= dimension - 1) {\r\n                break generationLoop;\r\n            }\r\n        }\r\n        for (int i = 0; i < dimension; i++) {\r\n            if (sigma * sqrtDiagC[i] > stopTolUpX) {\r\n                break generationLoop;\r\n            }\r\n        }\r\n        final double historyBest = min(fitnessHistory);\r\n        final double historyWorst = max(fitnessHistory);\r\n        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {\r\n            break generationLoop;\r\n        }\r\n        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {\r\n            break generationLoop;\r\n        }\r\n        \/\/ condition number of the covariance matrix exceeds 1e14\r\n        if (max(diagD) \/ min(diagD) > 1e7) {\r\n            break generationLoop;\r\n        }\r\n        \/\/ user defined termination\r\n        if (getConvergenceChecker() != null) {\r\n            final PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);\r\n            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {\r\n                break generationLoop;\r\n            }\r\n            lastResult = current;\r\n        }\r\n        \/\/ Adjust step size in case of equal function values (flat fitness)\r\n        if (bestValue == fitness[arindex[(int) (0.1 + lambda \/ 4.)]]) {\r\n            sigma = sigma * Math.exp(0.2 + cs \/ damps);\r\n        }\r\n        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {\r\n            sigma = sigma * Math.exp(0.2 + cs \/ damps);\r\n        }\r\n        \/\/ store best in history\r\n        push(fitnessHistory, bestFitness);\r\n        fitfun.setValueRange(worstFitness - bestFitness);\r\n        if (generateStatistics) {\r\n            statisticsSigmaHistory.add(sigma);\r\n            statisticsFitnessHistory.add(bestFitness);\r\n            statisticsMeanHistory.add(xmean.transpose());\r\n            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\r\n        }\r\n    }\r\n    return optimum;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected PointValuePair doOptimize() {\r\n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\r\n    final FitnessFunction fitfun = new FitnessFunction();\r\n    final double[] guess = getStartPoint();\r\n        dimension = guess.length;\r\n    initializeCMA(guess);\r\n    iterations = 0;\r\n    double bestValue = fitfun.value(guess);\r\n    push(fitnessHistory, bestValue);\r\n    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);\r\n    PointValuePair lastResult = null;\r\n    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {\r\n                final RealMatrix arz = randn1(dimension, lambda);\r\n        final RealMatrix arx = zeros(dimension, lambda);\r\n        final double[] fitness = new double[lambda];\r\n                for (int k = 0; k < lambda; k++) {\r\n            RealMatrix arxk = null;\r\n            for (int i = 0; i < checkFeasableCount + 1; i++) {\r\n                if (diagonalOnly <= 0) {\r\n                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(                    sigma));\r\n                } else {\r\n                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));\r\n                }\r\n                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\r\n                    break;\r\n                }\r\n                                arz.setColumn(k, randn(dimension));\r\n            }\r\n            copyColumn(arxk, 0, arx, k);\r\n            try {\r\n                                fitness[k] = fitfun.value(arx.getColumn(k));\r\n            } catch (TooManyEvaluationsException e) {\r\n                break generationLoop;\r\n            }\r\n        }\r\n                final int[] arindex = sortedIndices(fitness);\r\n                        final RealMatrix xold = xmean;\r\n        final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\r\n        xmean = bestArx.multiply(weights);\r\n        final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\r\n        final RealMatrix zmean = bestArz.multiply(weights);\r\n        final boolean hsig = updateEvolutionPaths(zmean, xold);\r\n        if (diagonalOnly <= 0) {\r\n            updateCovariance(hsig, bestArx, arz, arindex, xold);\r\n        } else {\r\n            updateCovarianceDiagonalOnly(hsig, bestArz);\r\n        }\r\n                sigma *= Math.exp(Math.min(1, (normps \/ chiN - 1) * cs \/ damps));\r\n        final double bestFitness = fitness[arindex[0]];\r\n        final double worstFitness = fitness[arindex[arindex.length - 1]];\r\n        if (bestValue > bestFitness) {\r\n            bestValue = bestFitness;\r\n            lastResult = optimum;\r\n            optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);\r\n            if (getConvergenceChecker() != null && lastResult != null) {\r\n                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\r\n                    break generationLoop;\r\n                }\r\n            }\r\n        }\r\n                if (stopFitness != 0) {\r\n                        if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\r\n                break generationLoop;\r\n            }\r\n        }\r\n        final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\r\n        final double[] pcCol = pc.getColumn(0);\r\n        for (int i = 0; i < dimension; i++) {\r\n            if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {\r\n                break;\r\n            }\r\n            if (i >= dimension - 1) {\r\n                break generationLoop;\r\n            }\r\n        }\r\n        for (int i = 0; i < dimension; i++) {\r\n            if (sigma * sqrtDiagC[i] > stopTolUpX) {\r\n                break generationLoop;\r\n            }\r\n        }\r\n        final double historyBest = min(fitnessHistory);\r\n        final double historyWorst = max(fitnessHistory);\r\n        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {\r\n            break generationLoop;\r\n        }\r\n        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {\r\n            break generationLoop;\r\n        }\r\n                if (max(diagD) \/ min(diagD) > 1e7) {\r\n            break generationLoop;\r\n        }\r\n                if (getConvergenceChecker() != null) {\r\n            final PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);\r\n            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {\r\n                break generationLoop;\r\n            }\r\n            lastResult = current;\r\n        }\r\n                if (bestValue == fitness[arindex[(int) (0.1 + lambda \/ 4.)]]) {\r\n            sigma = sigma * Math.exp(0.2 + cs \/ damps);\r\n        }\r\n        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {\r\n            sigma = sigma * Math.exp(0.2 + cs \/ damps);\r\n        }\r\n                push(fitnessHistory, bestFitness);\r\n        fitfun.setValueRange(worstFitness - bestFitness);\r\n        if (generateStatistics) {\r\n            statisticsSigmaHistory.add(sigma);\r\n            statisticsFitnessHistory.add(bestFitness);\r\n            statisticsMeanHistory.add(xmean.transpose());\r\n            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\r\n        }\r\n    }\r\n    return optimum;\r\n}","lc":4.6818181818,"pi":0.6124401914,"ma":7.4,"nbd":1.0,"ml":5.5833333333,"d":4.2023809524,"mi":-1.6491895701,"fo":5.25,"r":-0.0263157895,"e":34.5636140454}
{"project_name":"Cli","project_version":"10","label":3,"code":"protected void setOptions(final Options options) {\r\n    this.options = options;\r\n    this.requiredOptions = options.getRequiredOptions();\r\n}","code_comment":null,"code_no_comment":"protected void setOptions(final Options options) {\r\n    this.options = options;\r\n    this.requiredOptions = options.getRequiredOptions();\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8353770261,"fo":-0.4166666667,"r":0.7105263158,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"private final Component children_set(int index, Component child) {\r\n    final Component replaced;\r\n    if (index < children_size()) {\r\n        if (children == null || children instanceof Component) {\r\n            replaced = (Component) children;\r\n            children = child;\r\n        } else {\r\n            final Component[] children = (Component[]) this.children;\r\n            replaced = children[index];\r\n            children[index] = child;\r\n        }\r\n    } else {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    return replaced != child ? replaced : null;\r\n}","code_comment":null,"code_no_comment":"private final Component children_set(int index, Component child) {\r\n    final Component replaced;\r\n    if (index < children_size()) {\r\n        if (children == null || children instanceof Component) {\r\n            replaced = (Component) children;\r\n            children = child;\r\n        } else {\r\n            final Component[] children = (Component[]) this.children;\r\n            replaced = children[index];\r\n            children[index] = child;\r\n        }\r\n    } else {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    return replaced != child ? replaced : null;\r\n}","lc":0.0909090909,"pi":0.5406698565,"ma":0.2,"nbd":0.0,"ml":0.3333333333,"d":0.9841269841,"mi":-0.0720225511,"fo":-0.4166666667,"r":0.0263157895,"e":0.3638779874}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1155_f64e8adc","label":1,"code":"@Override\r\npublic void visit(NodeState state) {\r\n    if (state.hasProperty(\"match\")) {\r\n        count++;\r\n        depthTotal += depth;\r\n    }\r\n    if (count < maxCount) {\r\n        depth++;\r\n        int width = 0;\r\n        boolean finished = true;\r\n        for (ChildNodeEntry entry : state.getChildNodeEntries()) {\r\n            if (count >= maxCount) {\r\n                finished = false;\r\n                break;\r\n            }\r\n            width++;\r\n            visit(entry.getNodeState());\r\n        }\r\n        if (finished && width > 0) {\r\n            widthTotal += width;\r\n            widthCount++;\r\n        }\r\n        depth--;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void visit(NodeState state) {\r\n    if (state.hasProperty(\"match\")) {\r\n        count++;\r\n        depthTotal += depth;\r\n    }\r\n    if (count < maxCount) {\r\n        depth++;\r\n        int width = 0;\r\n        boolean finished = true;\r\n        for (ChildNodeEntry entry : state.getChildNodeEntries()) {\r\n            if (count >= maxCount) {\r\n                finished = false;\r\n                break;\r\n            }\r\n            width++;\r\n            visit(entry.getNodeState());\r\n        }\r\n        if (finished && width > 0) {\r\n            widthTotal += width;\r\n            widthCount++;\r\n        }\r\n        depth--;\r\n    }\r\n}","lc":0.5,"pi":0.6650717703,"ma":0.6,"nbd":0.5,"ml":0.4166666667,"d":0.9702380952,"mi":-0.3471458774,"fo":-0.1666666667,"r":0.4736842105,"e":0.6133619174}
{"project_name":"JxPath","project_version":"6","label":1,"code":"\/**\r\n * Compares two values\r\n *\/\r\nprotected boolean equal(EvalContext context, Expression left, Expression right) {\r\n    Object l = left.compute(context);\r\n    Object r = right.compute(context);\r\n    if (l instanceof InitialContext || l instanceof SelfContext) {\r\n        l = ((EvalContext) l).getSingleNodePointer();\r\n    }\r\n    if (r instanceof InitialContext || r instanceof SelfContext) {\r\n        r = ((EvalContext) r).getSingleNodePointer();\r\n    }\r\n    if (l instanceof Collection) {\r\n        l = ((Collection) l).iterator();\r\n    }\r\n    if (r instanceof Collection) {\r\n        r = ((Collection) r).iterator();\r\n    }\r\n    if ((l instanceof Iterator) && !(r instanceof Iterator)) {\r\n        return contains((Iterator) l, r);\r\n    }\r\n    if (!(l instanceof Iterator) && (r instanceof Iterator)) {\r\n        return contains((Iterator) r, l);\r\n    }\r\n    if (l instanceof Iterator && r instanceof Iterator) {\r\n        return findMatch((Iterator) l, (Iterator) r);\r\n    }\r\n    return equal(l, r);\r\n}","code_comment":"\/**\r\n * Compares two values\r\n *\/\r\n","code_no_comment":"protected boolean equal(EvalContext context, Expression left, Expression right) {\r\n    Object l = left.compute(context);\r\n    Object r = right.compute(context);\r\n    if (l instanceof InitialContext || l instanceof SelfContext) {\r\n        l = ((EvalContext) l).getSingleNodePointer();\r\n    }\r\n    if (r instanceof InitialContext || r instanceof SelfContext) {\r\n        r = ((EvalContext) r).getSingleNodePointer();\r\n    }\r\n    if (l instanceof Collection) {\r\n        l = ((Collection) l).iterator();\r\n    }\r\n    if (r instanceof Collection) {\r\n        r = ((Collection) r).iterator();\r\n    }\r\n    if ((l instanceof Iterator) && !(r instanceof Iterator)) {\r\n        return contains((Iterator) l, r);\r\n    }\r\n    if (!(l instanceof Iterator) && (r instanceof Iterator)) {\r\n        return contains((Iterator) r, l);\r\n    }\r\n    if (l instanceof Iterator && r instanceof Iterator) {\r\n        return findMatch((Iterator) l, (Iterator) r);\r\n    }\r\n    return equal(l, r);\r\n}","lc":0.5454545455,"pi":-0.3684210526,"ma":0.8,"nbd":-0.5,"ml":0.75,"d":1.1805555556,"mi":-0.437914024,"fo":0.3333333333,"r":-0.0263157895,"e":1.2505293246}
{"project_name":"Math","project_version":"57","label":3,"code":"\/**\r\n * Use K-means++ to choose the initial centers.\r\n *\r\n * @param <T> type of the points to cluster\r\n * @param points the points to choose the initial centers from\r\n * @param k the number of centers to choose\r\n * @param random random generator to use\r\n * @return the initial centers\r\n *\/\r\nprivate static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\r\n    final List<T> pointSet = new ArrayList<T>(points);\r\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\r\n    \/\/ Choose one center uniformly at random from among the data points.\r\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\r\n    resultSet.add(new Cluster<T>(firstPoint));\r\n    final double[] dx2 = new double[pointSet.size()];\r\n    while (resultSet.size() < k) {\r\n        \/\/ For each data point x, compute D(x), the distance between x and\r\n        \/\/ the nearest center that has already been chosen.\r\n        int sum = 0;\r\n        for (int i = 0; i < pointSet.size(); i++) {\r\n            final T p = pointSet.get(i);\r\n            final Cluster<T> nearest = getNearestCluster(resultSet, p);\r\n            final double d = p.distanceFrom(nearest.getCenter());\r\n            sum += d * d;\r\n            dx2[i] = sum;\r\n        }\r\n        \/\/ Add one new data point as a center. Each point x is chosen with\r\n        \/\/ probability proportional to D(x)2\r\n        final double r = random.nextDouble() * sum;\r\n        for (int i = 0; i < dx2.length; i++) {\r\n            if (dx2[i] >= r) {\r\n                final T p = pointSet.remove(i);\r\n                resultSet.add(new Cluster<T>(p));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return resultSet;\r\n}","code_comment":"\/**\r\n * Use K-means++ to choose the initial centers.\r\n *\r\n * @param <T> type of the points to cluster\r\n * @param points the points to choose the initial centers from\r\n * @param k the number of centers to choose\r\n * @param random random generator to use\r\n * @return the initial centers\r\n *\/\r\n","code_no_comment":"private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\r\n    final List<T> pointSet = new ArrayList<T>(points);\r\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\r\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\r\n    resultSet.add(new Cluster<T>(firstPoint));\r\n    final double[] dx2 = new double[pointSet.size()];\r\n    while (resultSet.size() < k) {\r\n                        int sum = 0;\r\n        for (int i = 0; i < pointSet.size(); i++) {\r\n            final T p = pointSet.get(i);\r\n            final Cluster<T> nearest = getNearestCluster(resultSet, p);\r\n            final double d = p.distanceFrom(nearest.getCenter());\r\n            sum += d * d;\r\n            dx2[i] = sum;\r\n        }\r\n                        final double r = random.nextDouble() * sum;\r\n        for (int i = 0; i < dx2.length; i++) {\r\n            if (dx2[i] >= r) {\r\n                final T p = pointSet.remove(i);\r\n                resultSet.add(new Cluster<T>(p));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return resultSet;\r\n}","lc":0.5454545455,"pi":0.7894736842,"ma":0.4,"nbd":0.5,"ml":0.4166666667,"d":1.4384920635,"mi":-0.49739253,"fo":0.6666666667,"r":-0.0263157895,"e":2.5397831988}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1096_be44b816","label":1,"code":"@Override\r\npublic QueryResult execute() throws RepositoryException {\r\n    return manager.executeQuery(statement, language, limit, offset, bindVariableMap);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic QueryResult execute() throws RepositoryException {\r\n    return manager.executeQuery(statement, language, limit, offset, bindVariableMap);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7866102889,"fo":-0.4166666667,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5432_93935780","label":1,"code":"\/**\r\n * Strategy method for adding the exchange to the queue.\r\n * <p>\r\n * Will perform a blocking \"put\" if blockWhenFull is true, otherwise it will\r\n * simply add which will throw exception if the queue is full\r\n *\r\n * @param exchange the exchange to add to the queue\r\n *\/\r\nprotected void addToQueue(Exchange exchange) {\r\n    if (blockWhenFull) {\r\n        try {\r\n            queue.put(exchange);\r\n        } catch (InterruptedException e) {\r\n            \/\/ ignore\r\n            log.debug(\"Put interrupted, are we stopping? {}\", isStopping() || isStopped());\r\n        }\r\n    } else {\r\n        queue.add(exchange);\r\n    }\r\n}","code_comment":"\/**\r\n * Strategy method for adding the exchange to the queue.\r\n * <p>\r\n * Will perform a blocking \"put\" if blockWhenFull is true, otherwise it will\r\n * simply add which will throw exception if the queue is full\r\n *\r\n * @param exchange the exchange to add to the queue\r\n *\/\r\n","code_no_comment":"protected void addToQueue(Exchange exchange) {\r\n    if (blockWhenFull) {\r\n        try {\r\n            queue.put(exchange);\r\n        } catch (InterruptedException e) {\r\n                        log.debug(\"Put interrupted, are we stopping? {}\", isStopping() || isStopped());\r\n        }\r\n    } else {\r\n        queue.add(exchange);\r\n    }\r\n}","lc":-0.1363636364,"pi":0.4593301435,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.3650793651,"mi":0.2281888654,"fo":-0.0833333333,"r":0.8157894737,"e":-0.1627934049}
{"project_name":"JxPath","project_version":"13","label":1,"code":"\/**\r\n * Get the prefix associated with the specifed namespace URI.\r\n * @param namespaceURI the ns URI to check.\r\n * @return String prefix\r\n *\/\r\npublic synchronized String getPrefix(String namespaceURI) {\r\n    \/**\r\n     * Get the nearest prefix found that matches an externally-registered namespace.\r\n     * @param namespaceURI\r\n     * @return String prefix if found.\r\n     * @since JXPath 1.3\r\n     *\/\r\n    if (reverseMap == null) {\r\n        reverseMap = new HashMap();\r\n        NodeIterator ni = pointer.namespaceIterator();\r\n        if (ni != null) {\r\n            for (int position = 1; ni.setPosition(position); position++) {\r\n                NodePointer nsPointer = ni.getNodePointer();\r\n                String uri = nsPointer.getNamespaceURI();\r\n                String prefix = nsPointer.getName().getName();\r\n                if (!\"\".equals(prefix)) {\r\n                    reverseMap.put(uri, prefix);\r\n                }\r\n            }\r\n        }\r\n        Iterator it = namespaceMap.entrySet().iterator();\r\n        while (it.hasNext()) {\r\n            Map.Entry entry = (Map.Entry) it.next();\r\n            reverseMap.put(entry.getValue(), entry.getKey());\r\n        }\r\n    }\r\n    String prefix = (String) reverseMap.get(namespaceURI);\r\n    if (prefix == null && parent != null) {\r\n        return parent.getPrefix(namespaceURI);\r\n    }\r\n    return prefix;\r\n}","code_comment":"\/**\r\n * Get the prefix associated with the specifed namespace URI.\r\n * @param namespaceURI the ns URI to check.\r\n * @return String prefix\r\n *\/\r\n\/**\r\n * Get the nearest prefix found that matches an externally-registered namespace.\r\n * @param namespaceURI\r\n * @return String prefix if found.\r\n * @since JXPath 1.3\r\n *\/\r\n","code_no_comment":"public synchronized String getPrefix(String namespaceURI) {\r\n    \/**\r\n     * Get the nearest prefix found that matches an externally-registered namespace.\r\n     * @param namespaceURI\r\n     * @return String prefix if found.\r\n     * @since JXPath 1.3\r\n     *\/\r\n    if (reverseMap == null) {\r\n        reverseMap = new HashMap();\r\n        NodeIterator ni = pointer.namespaceIterator();\r\n        if (ni != null) {\r\n            for (int position = 1; ni.setPosition(position); position++) {\r\n                NodePointer nsPointer = ni.getNodePointer();\r\n                String uri = nsPointer.getNamespaceURI();\r\n                String prefix = nsPointer.getName().getName();\r\n                if (!\"\".equals(prefix)) {\r\n                    reverseMap.put(uri, prefix);\r\n                }\r\n            }\r\n        }\r\n        Iterator it = namespaceMap.entrySet().iterator();\r\n        while (it.hasNext()) {\r\n            Map.Entry entry = (Map.Entry) it.next();\r\n            reverseMap.put(entry.getValue(), entry.getKey());\r\n        }\r\n    }\r\n    String prefix = (String) reverseMap.get(namespaceURI);\r\n    if (prefix == null && parent != null) {\r\n        return parent.getPrefix(namespaceURI);\r\n    }\r\n    return prefix;\r\n}","lc":0.8181818182,"pi":0.976076555,"ma":0.6,"nbd":1.0,"ml":0.8333333333,"d":0.8095238095,"mi":-0.5605355884,"fo":0.9166666667,"r":-0.0263157895,"e":1.1933979933}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4072_7d5b8645","label":1,"code":"\/**\r\n *  return path for current url in given encoding\r\n *\r\n *  @param charset\r\n *            character set for encoding\r\n *\r\n *  @return path string\r\n *\/\r\npublic String getPath(Charset charset) {\r\n    Args.notNull(charset, \"charset\");\r\n    StringBuilder path = new StringBuilder();\r\n    boolean slash = false;\r\n    for (String segment : getSegments()) {\r\n        if (slash) {\r\n            path.append('\/');\r\n        }\r\n        path.append(encodeSegment(segment, charset));\r\n        slash = true;\r\n    }\r\n    return path.toString();\r\n}","code_comment":"\/**\r\n *  return path for current url in given encoding\r\n *\r\n *  @param charset\r\n *            character set for encoding\r\n *\r\n *  @return path string\r\n *\/\r\n","code_no_comment":"public String getPath(Charset charset) {\r\n    Args.notNull(charset, \"charset\");\r\n    StringBuilder path = new StringBuilder();\r\n    boolean slash = false;\r\n    for (String segment : getSegments()) {\r\n        if (slash) {\r\n            path.append('\/');\r\n        }\r\n        path.append(encodeSegment(segment, charset));\r\n        slash = true;\r\n    }\r\n    return path.toString();\r\n}","lc":-0.0454545455,"pi":0.1435406699,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.3650793651,"mi":0.0621564482,"fo":0.0,"r":1.4210526316,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4153_9120fd1b","label":0,"code":"@Override\r\npublic boolean compareAgainstBaseState(NodeState base, NodeStateDiff diff) {\r\n    if (this == base || fastEquals(this, base)) {\r\n        \/\/ no changes\r\n        return true;\r\n    } else if (base == EMPTY_NODE || !base.exists()) {\r\n        \/\/ special case\r\n        return EmptyNodeState.compareAgainstEmptyState(this, diff);\r\n    } else if (!(base instanceof SegmentNodeState)) {\r\n        \/\/ fallback\r\n        return AbstractNodeState.compareAgainstBaseState(this, base, diff);\r\n    }\r\n    SegmentNodeState that = (SegmentNodeState) base;\r\n    if (that.wasCompactedTo(this)) {\r\n        \/\/ no changes during compaction\r\n        return true;\r\n    }\r\n    Template beforeTemplate = that.getTemplate();\r\n    RecordId beforeId = that.getRecordId();\r\n    Template afterTemplate = getTemplate();\r\n    RecordId afterId = getRecordId();\r\n    \/\/ Compare type properties\r\n    if (!compareProperties(beforeTemplate.getPrimaryType(), afterTemplate.getPrimaryType(), diff)) {\r\n        return false;\r\n    }\r\n    if (!compareProperties(beforeTemplate.getMixinTypes(), afterTemplate.getMixinTypes(), diff)) {\r\n        return false;\r\n    }\r\n    \/\/ Compare other properties, leveraging the ordering\r\n    int beforeIndex = 0;\r\n    int afterIndex = 0;\r\n    PropertyTemplate[] beforeProperties = beforeTemplate.getPropertyTemplates();\r\n    PropertyTemplate[] afterProperties = afterTemplate.getPropertyTemplates();\r\n    while (beforeIndex < beforeProperties.length && afterIndex < afterProperties.length) {\r\n        int d = Integer.valueOf(afterProperties[afterIndex].hashCode()).compareTo(Integer.valueOf(beforeProperties[beforeIndex].hashCode()));\r\n        if (d == 0) {\r\n            d = afterProperties[afterIndex].getName().compareTo(beforeProperties[beforeIndex].getName());\r\n        }\r\n        PropertyState beforeProperty = null;\r\n        PropertyState afterProperty = null;\r\n        if (d < 0) {\r\n            afterProperty = afterTemplate.getProperty(afterId, afterIndex++);\r\n        } else if (d > 0) {\r\n            beforeProperty = beforeTemplate.getProperty(beforeId, beforeIndex++);\r\n        } else {\r\n            afterProperty = afterTemplate.getProperty(afterId, afterIndex++);\r\n            beforeProperty = beforeTemplate.getProperty(beforeId, beforeIndex++);\r\n        }\r\n        if (!compareProperties(beforeProperty, afterProperty, diff)) {\r\n            return false;\r\n        }\r\n    }\r\n    while (afterIndex < afterProperties.length) {\r\n        if (!diff.propertyAdded(afterTemplate.getProperty(afterId, afterIndex++))) {\r\n            return false;\r\n        }\r\n    }\r\n    while (beforeIndex < beforeProperties.length) {\r\n        PropertyState beforeProperty = beforeTemplate.getProperty(beforeId, beforeIndex++);\r\n        if (!diff.propertyDeleted(beforeProperty)) {\r\n            return false;\r\n        }\r\n    }\r\n    String beforeChildName = beforeTemplate.getChildName();\r\n    String afterChildName = afterTemplate.getChildName();\r\n    if (afterChildName == Template.ZERO_CHILD_NODES) {\r\n        if (beforeChildName != Template.ZERO_CHILD_NODES) {\r\n            for (ChildNodeEntry entry : beforeTemplate.getChildNodeEntries(beforeId)) {\r\n                if (!diff.childNodeDeleted(entry.getName(), entry.getNodeState())) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    } else if (afterChildName != Template.MANY_CHILD_NODES) {\r\n        NodeState afterNode = afterTemplate.getChildNode(afterChildName, afterId);\r\n        NodeState beforeNode = beforeTemplate.getChildNode(afterChildName, beforeId);\r\n        if (!beforeNode.exists()) {\r\n            if (!diff.childNodeAdded(afterChildName, afterNode)) {\r\n                return false;\r\n            }\r\n        } else if (!fastEquals(afterNode, beforeNode)) {\r\n            if (!diff.childNodeChanged(afterChildName, beforeNode, afterNode)) {\r\n                return false;\r\n            }\r\n        }\r\n        if (beforeChildName == Template.MANY_CHILD_NODES || (beforeChildName != Template.ZERO_CHILD_NODES && !beforeNode.exists())) {\r\n            for (ChildNodeEntry entry : beforeTemplate.getChildNodeEntries(beforeId)) {\r\n                if (!afterChildName.equals(entry.getName())) {\r\n                    if (!diff.childNodeDeleted(entry.getName(), entry.getNodeState())) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else if (beforeChildName == Template.ZERO_CHILD_NODES) {\r\n        for (ChildNodeEntry entry : afterTemplate.getChildNodeEntries(afterId)) {\r\n            if (!diff.childNodeAdded(entry.getName(), entry.getNodeState())) {\r\n                return false;\r\n            }\r\n        }\r\n    } else if (beforeChildName != Template.MANY_CHILD_NODES) {\r\n        for (ChildNodeEntry entry : afterTemplate.getChildNodeEntries(afterId)) {\r\n            String childName = entry.getName();\r\n            NodeState afterChild = entry.getNodeState();\r\n            if (beforeChildName.equals(childName)) {\r\n                NodeState beforeChild = beforeTemplate.getChildNode(beforeChildName, beforeId);\r\n                if (beforeChild.exists()) {\r\n                    if (!fastEquals(afterChild, beforeChild) && !diff.childNodeChanged(childName, beforeChild, afterChild)) {\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    if (!diff.childNodeAdded(childName, afterChild)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else if (!diff.childNodeAdded(childName, afterChild)) {\r\n                return false;\r\n            }\r\n        }\r\n    } else {\r\n        MapRecord afterMap = afterTemplate.getChildNodeMap(afterId);\r\n        MapRecord beforeMap = beforeTemplate.getChildNodeMap(beforeId);\r\n        return afterMap.compare(beforeMap, diff);\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean compareAgainstBaseState(NodeState base, NodeStateDiff diff) {\r\n    if (this == base || fastEquals(this, base)) {\r\n                return true;\r\n    } else if (base == EMPTY_NODE || !base.exists()) {\r\n                return EmptyNodeState.compareAgainstEmptyState(this, diff);\r\n    } else if (!(base instanceof SegmentNodeState)) {\r\n                return AbstractNodeState.compareAgainstBaseState(this, base, diff);\r\n    }\r\n    SegmentNodeState that = (SegmentNodeState) base;\r\n    if (that.wasCompactedTo(this)) {\r\n                return true;\r\n    }\r\n    Template beforeTemplate = that.getTemplate();\r\n    RecordId beforeId = that.getRecordId();\r\n    Template afterTemplate = getTemplate();\r\n    RecordId afterId = getRecordId();\r\n        if (!compareProperties(beforeTemplate.getPrimaryType(), afterTemplate.getPrimaryType(), diff)) {\r\n        return false;\r\n    }\r\n    if (!compareProperties(beforeTemplate.getMixinTypes(), afterTemplate.getMixinTypes(), diff)) {\r\n        return false;\r\n    }\r\n        int beforeIndex = 0;\r\n    int afterIndex = 0;\r\n    PropertyTemplate[] beforeProperties = beforeTemplate.getPropertyTemplates();\r\n    PropertyTemplate[] afterProperties = afterTemplate.getPropertyTemplates();\r\n    while (beforeIndex < beforeProperties.length && afterIndex < afterProperties.length) {\r\n        int d = Integer.valueOf(afterProperties[afterIndex].hashCode()).compareTo(Integer.valueOf(beforeProperties[beforeIndex].hashCode()));\r\n        if (d == 0) {\r\n            d = afterProperties[afterIndex].getName().compareTo(beforeProperties[beforeIndex].getName());\r\n        }\r\n        PropertyState beforeProperty = null;\r\n        PropertyState afterProperty = null;\r\n        if (d < 0) {\r\n            afterProperty = afterTemplate.getProperty(afterId, afterIndex++);\r\n        } else if (d > 0) {\r\n            beforeProperty = beforeTemplate.getProperty(beforeId, beforeIndex++);\r\n        } else {\r\n            afterProperty = afterTemplate.getProperty(afterId, afterIndex++);\r\n            beforeProperty = beforeTemplate.getProperty(beforeId, beforeIndex++);\r\n        }\r\n        if (!compareProperties(beforeProperty, afterProperty, diff)) {\r\n            return false;\r\n        }\r\n    }\r\n    while (afterIndex < afterProperties.length) {\r\n        if (!diff.propertyAdded(afterTemplate.getProperty(afterId, afterIndex++))) {\r\n            return false;\r\n        }\r\n    }\r\n    while (beforeIndex < beforeProperties.length) {\r\n        PropertyState beforeProperty = beforeTemplate.getProperty(beforeId, beforeIndex++);\r\n        if (!diff.propertyDeleted(beforeProperty)) {\r\n            return false;\r\n        }\r\n    }\r\n    String beforeChildName = beforeTemplate.getChildName();\r\n    String afterChildName = afterTemplate.getChildName();\r\n    if (afterChildName == Template.ZERO_CHILD_NODES) {\r\n        if (beforeChildName != Template.ZERO_CHILD_NODES) {\r\n            for (ChildNodeEntry entry : beforeTemplate.getChildNodeEntries(beforeId)) {\r\n                if (!diff.childNodeDeleted(entry.getName(), entry.getNodeState())) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    } else if (afterChildName != Template.MANY_CHILD_NODES) {\r\n        NodeState afterNode = afterTemplate.getChildNode(afterChildName, afterId);\r\n        NodeState beforeNode = beforeTemplate.getChildNode(afterChildName, beforeId);\r\n        if (!beforeNode.exists()) {\r\n            if (!diff.childNodeAdded(afterChildName, afterNode)) {\r\n                return false;\r\n            }\r\n        } else if (!fastEquals(afterNode, beforeNode)) {\r\n            if (!diff.childNodeChanged(afterChildName, beforeNode, afterNode)) {\r\n                return false;\r\n            }\r\n        }\r\n        if (beforeChildName == Template.MANY_CHILD_NODES || (beforeChildName != Template.ZERO_CHILD_NODES && !beforeNode.exists())) {\r\n            for (ChildNodeEntry entry : beforeTemplate.getChildNodeEntries(beforeId)) {\r\n                if (!afterChildName.equals(entry.getName())) {\r\n                    if (!diff.childNodeDeleted(entry.getName(), entry.getNodeState())) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else if (beforeChildName == Template.ZERO_CHILD_NODES) {\r\n        for (ChildNodeEntry entry : afterTemplate.getChildNodeEntries(afterId)) {\r\n            if (!diff.childNodeAdded(entry.getName(), entry.getNodeState())) {\r\n                return false;\r\n            }\r\n        }\r\n    } else if (beforeChildName != Template.MANY_CHILD_NODES) {\r\n        for (ChildNodeEntry entry : afterTemplate.getChildNodeEntries(afterId)) {\r\n            String childName = entry.getName();\r\n            NodeState afterChild = entry.getNodeState();\r\n            if (beforeChildName.equals(childName)) {\r\n                NodeState beforeChild = beforeTemplate.getChildNode(beforeChildName, beforeId);\r\n                if (beforeChild.exists()) {\r\n                    if (!fastEquals(afterChild, beforeChild) && !diff.childNodeChanged(childName, beforeChild, afterChild)) {\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    if (!diff.childNodeAdded(childName, afterChild)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else if (!diff.childNodeAdded(childName, afterChild)) {\r\n                return false;\r\n            }\r\n        }\r\n    } else {\r\n        MapRecord afterMap = afterTemplate.getChildNodeMap(afterId);\r\n        MapRecord beforeMap = beforeTemplate.getChildNodeMap(beforeId);\r\n        return afterMap.compare(beforeMap, diff);\r\n    }\r\n    return true;\r\n}","lc":4.8181818182,"pi":1.1291866029,"ma":7.0,"nbd":3.0,"ml":6.5833333333,"d":2.9583333333,"mi":-1.6074700493,"fo":5.3333333333,"r":-0.0263157895,"e":19.0357912208}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3428_320545cd","label":3,"code":"public <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType) {\r\n    Endpoint endpoint = getEndpoint(name);\r\n    if (endpoint instanceof InterceptSendToEndpoint) {\r\n        endpoint = ((InterceptSendToEndpoint) endpoint).getDelegate();\r\n    }\r\n    if (endpointType.isInstance(endpoint)) {\r\n        return endpointType.cast(endpoint);\r\n    } else {\r\n        throw new IllegalArgumentException(\"The endpoint is not of type: \" + endpointType + \" but is: \" + endpoint.getClass().getCanonicalName());\r\n    }\r\n}","code_comment":null,"code_no_comment":"public <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType) {\r\n    Endpoint endpoint = getEndpoint(name);\r\n    if (endpoint instanceof InterceptSendToEndpoint) {\r\n        endpoint = ((InterceptSendToEndpoint) endpoint).getDelegate();\r\n    }\r\n    if (endpointType.isInstance(endpoint)) {\r\n        return endpointType.cast(endpoint);\r\n    } else {\r\n        throw new IllegalArgumentException(\"The endpoint is not of type: \" + endpointType + \" but is: \" + endpoint.getClass().getCanonicalName());\r\n    }\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":-0.001984127,"mi":0.1168428471,"fo":0.0,"r":0.0,"e":-0.031283461}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2713_63d9800e","label":1,"code":"@Override\r\npublic S value() throws IOException {\r\n    return state;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic S value() throws IOException {\r\n    return state;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9362931642,"fo":-0.5,"r":2.4210526316,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Discards the <code>i<\/code> initial elements of the array.  For example,\r\n * if the array contains the elements 1,2,3,4, invoking\r\n * <code>discardFrontElements(2)<\/code> will cause the first two elements\r\n * to be discarded, leaving 3,4 in the array.  Throws illegalArgumentException\r\n * if i exceeds numElements.\r\n *\r\n * @param i  the number of elements to discard from the front of the array\r\n * @throws MathIllegalArgumentException if i is greater than numElements.\r\n * @since 2.0\r\n *\/\r\npublic synchronized void discardFrontElements(int i) throws MathIllegalArgumentException {\r\n    discardExtremeElements(i, true);\r\n}","code_comment":"\/**\r\n * Discards the <code>i<\/code> initial elements of the array.  For example,\r\n * if the array contains the elements 1,2,3,4, invoking\r\n * <code>discardFrontElements(2)<\/code> will cause the first two elements\r\n * to be discarded, leaving 3,4 in the array.  Throws illegalArgumentException\r\n * if i exceeds numElements.\r\n *\r\n * @param i  the number of elements to discard from the front of the array\r\n * @throws MathIllegalArgumentException if i is greater than numElements.\r\n * @since 2.0\r\n *\/\r\n","code_no_comment":"public synchronized void discardFrontElements(int i) throws MathIllegalArgumentException {\r\n    discardExtremeElements(i, true);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0451021846,"fo":-0.4166666667,"r":0.0526315789,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3028_89317b28","label":0,"code":"\/**\r\n * Updates a commit root document.\r\n *\r\n * @param commit the updates to apply on the commit root document.\r\n * @return the document before the update was applied or <code>null<\/code>\r\n *          if the update failed because of a collision.\r\n * @throws DocumentStoreException if the update fails with an error.\r\n *\/\r\n@CheckForNull\r\nNodeDocument updateCommitRoot(UpdateOp commit) throws DocumentStoreException {\r\n    \/\/ use batch commit when there are only revision and modified updates\r\n    \/\/ and collision checks\r\n    boolean batch = true;\r\n    for (Map.Entry<Key, Operation> op : commit.getChanges().entrySet()) {\r\n        String name = op.getKey().getName();\r\n        if (NodeDocument.isRevisionsEntry(name) || NodeDocument.MODIFIED_IN_SECS.equals(name) || NodeDocument.COLLISIONS.equals(name)) {\r\n            continue;\r\n        }\r\n        batch = false;\r\n        break;\r\n    }\r\n    if (batch) {\r\n        return batchUpdateCommitRoot(commit);\r\n    } else {\r\n        return store.findAndUpdate(NODES, commit);\r\n    }\r\n}","code_comment":"\/**\r\n * Updates a commit root document.\r\n *\r\n * @param commit the updates to apply on the commit root document.\r\n * @return the document before the update was applied or <code>null<\/code>\r\n *          if the update failed because of a collision.\r\n * @throws DocumentStoreException if the update fails with an error.\r\n *\/\r\n","code_no_comment":"@CheckForNull\r\nNodeDocument updateCommitRoot(UpdateOp commit) throws DocumentStoreException {\r\n            boolean batch = true;\r\n    for (Map.Entry<Key, Operation> op : commit.getChanges().entrySet()) {\r\n        String name = op.getKey().getName();\r\n        if (NodeDocument.isRevisionsEntry(name) || NodeDocument.MODIFIED_IN_SECS.equals(name) || NodeDocument.COLLISIONS.equals(name)) {\r\n            continue;\r\n        }\r\n        batch = false;\r\n        break;\r\n    }\r\n    if (batch) {\r\n        return batchUpdateCommitRoot(commit);\r\n    } else {\r\n        return store.findAndUpdate(NODES, commit);\r\n    }\r\n}","lc":0.1363636364,"pi":0.1674641148,"ma":0.4,"nbd":0.0,"ml":0.3333333333,"d":-0.0773809524,"mi":-0.1509513742,"fo":0.25,"r":0.0,"e":-0.0106291385}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1020_83427028","label":3,"code":"private Tree findMatchingPropertyDefinition(List<Tree> types, String propertyName, Type<?> propertyType, boolean exactTypeMatch) {\r\n    \/\/ Escape the property name for looking up a matching definition\r\n    String escapedName;\r\n    if (JCR_PRIMARYTYPE.equals(propertyName)) {\r\n        escapedName = \"oak:primaryType\";\r\n    } else if (JCR_MIXINTYPES.equals(propertyName)) {\r\n        escapedName = \"oak:mixinTypes\";\r\n    } else if (JCR_UUID.equals(propertyName)) {\r\n        escapedName = \"oak:uuid\";\r\n    } else {\r\n        escapedName = propertyName;\r\n    }\r\n    String definedType = propertyType.toString();\r\n    String undefinedType = UNDEFINED.toString();\r\n    if (propertyType.isArray()) {\r\n        undefinedType = UNDEFINEDS.toString();\r\n    }\r\n    \/\/ First look for a matching named property definition\r\n    for (Tree type : types) {\r\n        Tree definitions = type.getChild(OAK_NAMED_PROPERTY_DEFINITIONS).getChild(escapedName);\r\n        Tree definition = definitions.getChild(definedType);\r\n        if (definition.exists()) {\r\n            return definition;\r\n        }\r\n        definition = definitions.getChild(undefinedType);\r\n        if (definition.exists()) {\r\n            return definition;\r\n        }\r\n        if (!exactTypeMatch) {\r\n            for (Tree def : definitions.getChildren()) {\r\n                if (propertyType.isArray() == TreeUtil.getBoolean(def, JCR_MULTIPLE)) {\r\n                    return def;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \/\/ Then look through any residual property definitions\r\n    for (Tree type : types) {\r\n        Tree definitions = type.getChild(OAK_RESIDUAL_PROPERTY_DEFINITIONS);\r\n        Tree definition = definitions.getChild(definedType);\r\n        if (definition.exists()) {\r\n            return definition;\r\n        }\r\n        definition = definitions.getChild(undefinedType);\r\n        if (definition.exists()) {\r\n            return definition;\r\n        }\r\n        if (!exactTypeMatch) {\r\n            for (Tree def : definitions.getChildren()) {\r\n                if (propertyType.isArray() == TreeUtil.getBoolean(def, JCR_MULTIPLE)) {\r\n                    return def;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"private Tree findMatchingPropertyDefinition(List<Tree> types, String propertyName, Type<?> propertyType, boolean exactTypeMatch) {\r\n        String escapedName;\r\n    if (JCR_PRIMARYTYPE.equals(propertyName)) {\r\n        escapedName = \"oak:primaryType\";\r\n    } else if (JCR_MIXINTYPES.equals(propertyName)) {\r\n        escapedName = \"oak:mixinTypes\";\r\n    } else if (JCR_UUID.equals(propertyName)) {\r\n        escapedName = \"oak:uuid\";\r\n    } else {\r\n        escapedName = propertyName;\r\n    }\r\n    String definedType = propertyType.toString();\r\n    String undefinedType = UNDEFINED.toString();\r\n    if (propertyType.isArray()) {\r\n        undefinedType = UNDEFINEDS.toString();\r\n    }\r\n        for (Tree type : types) {\r\n        Tree definitions = type.getChild(OAK_NAMED_PROPERTY_DEFINITIONS).getChild(escapedName);\r\n        Tree definition = definitions.getChild(definedType);\r\n        if (definition.exists()) {\r\n            return definition;\r\n        }\r\n        definition = definitions.getChild(undefinedType);\r\n        if (definition.exists()) {\r\n            return definition;\r\n        }\r\n        if (!exactTypeMatch) {\r\n            for (Tree def : definitions.getChildren()) {\r\n                if (propertyType.isArray() == TreeUtil.getBoolean(def, JCR_MULTIPLE)) {\r\n                    return def;\r\n                }\r\n            }\r\n        }\r\n    }\r\n        for (Tree type : types) {\r\n        Tree definitions = type.getChild(OAK_RESIDUAL_PROPERTY_DEFINITIONS);\r\n        Tree definition = definitions.getChild(definedType);\r\n        if (definition.exists()) {\r\n            return definition;\r\n        }\r\n        definition = definitions.getChild(undefinedType);\r\n        if (definition.exists()) {\r\n            return definition;\r\n        }\r\n        if (!exactTypeMatch) {\r\n            for (Tree def : definitions.getChildren()) {\r\n                if (propertyType.isArray() == TreeUtil.getBoolean(def, JCR_MULTIPLE)) {\r\n                    return def;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}","lc":1.8181818182,"pi":0.6650717703,"ma":2.6,"nbd":1.0,"ml":1.3333333333,"d":0.2579365079,"mi":-0.9159971811,"fo":1.5,"r":-0.0263157895,"e":0.8602871089}
{"project_name":"Math","project_version":"13","label":0,"code":"\/**\r\n * Computes the square-root of the weight matrix.\r\n *\r\n * @param m Symmetric, positive-definite (weight) matrix.\r\n * @return the square-root of the weight matrix.\r\n *\/\r\nprivate RealMatrix squareRoot(RealMatrix m) {\r\n    final EigenDecomposition dec = new EigenDecomposition(m);\r\n    return dec.getSquareRoot();\r\n}","code_comment":"\/**\r\n * Computes the square-root of the weight matrix.\r\n *\r\n * @param m Symmetric, positive-definite (weight) matrix.\r\n * @return the square-root of the weight matrix.\r\n *\/\r\n","code_no_comment":"private RealMatrix squareRoot(RealMatrix m) {\r\n    final EigenDecomposition dec = new EigenDecomposition(m);\r\n    return dec.getSquareRoot();\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8128259338,"fo":-0.4166666667,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6810_6b210169","label":3,"code":"\/**\r\n * Evaluate using parameter values where the values can be provided in the method name syntax.\r\n * <p\/>\r\n * This methods returns accordingly:\r\n * <ul>\r\n *     <li><tt>null<\/tt> - if not a parameter value<\/li>\r\n *     <li><tt>Void.TYPE<\/tt> - if an explicit null, forcing Camel to pass in <tt>null<\/tt> for that given parameter<\/li>\r\n *     <li>a non <tt>null<\/tt> value - if the parameter was a parameter value, and to be used<\/li>\r\n * <\/ul>\r\n *\r\n * @since 2.9\r\n *\/\r\nprivate Object evaluateParameterValue(Exchange exchange, int index, Object parameterValue, Class<?> parameterType) {\r\n    Object answer = null;\r\n    \/\/ convert the parameter value to a String\r\n    String exp = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, parameterValue);\r\n    if (exp != null) {\r\n        \/\/ check if its a valid parameter value\r\n        boolean valid = BeanHelper.isValidParameterValue(exp);\r\n        if (!valid) {\r\n            \/\/ it may be a parameter type instead, and if so, then we should return null,\r\n            \/\/ as this method is only for evaluating parameter values\r\n            Boolean isClass = BeanHelper.isAssignableToExpectedType(exchange.getContext().getClassResolver(), exp, parameterType);\r\n            \/\/ the method will return a non null value if exp is a class\r\n            if (isClass != null) {\r\n                return null;\r\n            }\r\n        }\r\n        \/\/ use simple language to evaluate the expression, as it may use the simple language to refer to message body, headers etc.\r\n        Expression expression = null;\r\n        try {\r\n            expression = exchange.getContext().resolveLanguage(\"simple\").createExpression(exp);\r\n            parameterValue = expression.evaluate(exchange, Object.class);\r\n            \/\/ use \"null\" to indicate the expression returned a null value which is a valid response we need to honor\r\n            if (parameterValue == null) {\r\n                parameterValue = \"null\";\r\n            }\r\n        } catch (Exception e) {\r\n            throw new ExpressionEvaluationException(expression, \"Cannot create\/evaluate simple expression: \" + exp + \" to be bound to parameter at index: \" + index + \" on method: \" + getMethod(), exchange, e);\r\n        }\r\n        \/\/ see method javadoc for details\r\n        if (\"null\".equals(parameterValue)) {\r\n            return Void.TYPE;\r\n        }\r\n        \/\/ the parameter value was not already valid, but since the simple language have evaluated the expression\r\n        \/\/ which may change the parameterValue, so we have to check it again to see if its now valid\r\n        exp = exchange.getContext().getTypeConverter().convertTo(String.class, parameterValue);\r\n        \/\/ String values from the simple language is always valid\r\n        if (!valid) {\r\n            \/\/ re validate if the parameter was not valid the first time (String values should be accepted)\r\n            valid = parameterValue instanceof String || BeanHelper.isValidParameterValue(exp);\r\n        }\r\n        if (valid) {\r\n            \/\/ we need to unquote String parameters, as the enclosing quotes is there to denote a parameter value\r\n            if (parameterValue instanceof String) {\r\n                parameterValue = StringHelper.removeLeadingAndEndingQuotes((String) parameterValue);\r\n            }\r\n            if (parameterValue != null) {\r\n                try {\r\n                    \/\/ its a valid parameter value, so convert it to the expected type of the parameter\r\n                    answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, exchange, parameterValue);\r\n                    if (LOG.isTraceEnabled()) {\r\n                        LOG.trace(\"Parameter #{} evaluated as: {} type: \", new Object[] { index, answer, ObjectHelper.type(answer) });\r\n                    }\r\n                } catch (Exception e) {\r\n                    if (LOG.isDebugEnabled()) {\r\n                        LOG.debug(\"Cannot convert from type: {} to type: {} for parameter #{}\", new Object[] { ObjectHelper.type(parameterValue), parameterType, index });\r\n                    }\r\n                    throw new ParameterBindingException(e, method, index, parameterType, parameterValue);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return answer;\r\n}","code_comment":"\/**\r\n * Evaluate using parameter values where the values can be provided in the method name syntax.\r\n * <p\/>\r\n * This methods returns accordingly:\r\n * <ul>\r\n *     <li><tt>null<\/tt> - if not a parameter value<\/li>\r\n *     <li><tt>Void.TYPE<\/tt> - if an explicit null, forcing Camel to pass in <tt>null<\/tt> for that given parameter<\/li>\r\n *     <li>a non <tt>null<\/tt> value - if the parameter was a parameter value, and to be used<\/li>\r\n * <\/ul>\r\n *\r\n * @since 2.9\r\n *\/\r\n","code_no_comment":"private Object evaluateParameterValue(Exchange exchange, int index, Object parameterValue, Class<?> parameterType) {\r\n    Object answer = null;\r\n        String exp = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, parameterValue);\r\n    if (exp != null) {\r\n                boolean valid = BeanHelper.isValidParameterValue(exp);\r\n        if (!valid) {\r\n                                    Boolean isClass = BeanHelper.isAssignableToExpectedType(exchange.getContext().getClassResolver(), exp, parameterType);\r\n                        if (isClass != null) {\r\n                return null;\r\n            }\r\n        }\r\n                Expression expression = null;\r\n        try {\r\n            expression = exchange.getContext().resolveLanguage(\"simple\").createExpression(exp);\r\n            parameterValue = expression.evaluate(exchange, Object.class);\r\n                        if (parameterValue == null) {\r\n                parameterValue = \"null\";\r\n            }\r\n        } catch (Exception e) {\r\n            throw new ExpressionEvaluationException(expression, \"Cannot create\/evaluate simple expression: \" + exp + \" to be bound to parameter at index: \" + index + \" on method: \" + getMethod(), exchange, e);\r\n        }\r\n                if (\"null\".equals(parameterValue)) {\r\n            return Void.TYPE;\r\n        }\r\n                        exp = exchange.getContext().getTypeConverter().convertTo(String.class, parameterValue);\r\n                if (!valid) {\r\n                        valid = parameterValue instanceof String || BeanHelper.isValidParameterValue(exp);\r\n        }\r\n        if (valid) {\r\n                        if (parameterValue instanceof String) {\r\n                parameterValue = StringHelper.removeLeadingAndEndingQuotes((String) parameterValue);\r\n            }\r\n            if (parameterValue != null) {\r\n                try {\r\n                                        answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, exchange, parameterValue);\r\n                    if (LOG.isTraceEnabled()) {\r\n                        LOG.trace(\"Parameter #{} evaluated as: {} type: \", new Object[] { index, answer, ObjectHelper.type(answer) });\r\n                    }\r\n                } catch (Exception e) {\r\n                    if (LOG.isDebugEnabled()) {\r\n                        LOG.debug(\"Cannot convert from type: {} to type: {} for parameter #{}\", new Object[] { ObjectHelper.type(parameterValue), parameterType, index });\r\n                    }\r\n                    throw new ParameterBindingException(e, method, index, parameterType, parameterValue);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return answer;\r\n}","lc":1.5909090909,"pi":1.2918660287,"ma":2.4,"nbd":1.5,"ml":1.0833333333,"d":1.2063492063,"mi":-0.9069767442,"fo":1.75,"r":-0.0263157895,"e":3.275943823}
{"project_name":"Compress","project_version":"12","label":1,"code":"\/**\r\n * Get the next entry in this tar archive. This will skip\r\n * over any remaining data in the current entry, if there\r\n * is one, and place the input stream at the header of the\r\n * next entry, and read the header and instantiate a new\r\n * TarEntry from the header bytes and return that entry.\r\n * If there are no more entries in the archive, null will\r\n * be returned to indicate that the end of the archive has\r\n * been reached.\r\n *\r\n * @return The next TarEntry in the archive, or null.\r\n * @throws IOException on error\r\n *\/\r\npublic TarArchiveEntry getNextTarEntry() throws IOException {\r\n    if (hasHitEOF) {\r\n        return null;\r\n    }\r\n    if (currEntry != null) {\r\n        long numToSkip = entrySize - entryOffset;\r\n        while (numToSkip > 0) {\r\n            long skipped = skip(numToSkip);\r\n            if (skipped <= 0) {\r\n                throw new RuntimeException(\"failed to skip current tar entry\");\r\n            }\r\n            numToSkip -= skipped;\r\n        }\r\n        readBuf = null;\r\n    }\r\n    byte[] headerBuf = getRecord();\r\n    if (hasHitEOF) {\r\n        currEntry = null;\r\n        return null;\r\n    }\r\n    currEntry = new TarArchiveEntry(headerBuf);\r\n    entryOffset = 0;\r\n    entrySize = currEntry.getSize();\r\n    if (currEntry.isGNULongNameEntry()) {\r\n        \/\/ read in the name\r\n        StringBuffer longName = new StringBuffer();\r\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\r\n        int length = 0;\r\n        while ((length = read(buf)) >= 0) {\r\n            longName.append(new String(buf, 0, length));\r\n        }\r\n        getNextEntry();\r\n        if (currEntry == null) {\r\n            \/\/ Malformed tar file - long entry name not followed by entry\r\n            return null;\r\n        }\r\n        \/\/ remove trailing null terminator\r\n        if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {\r\n            longName.deleteCharAt(longName.length() - 1);\r\n        }\r\n        currEntry.setName(longName.toString());\r\n    }\r\n    if (currEntry.isPaxHeader()) {\r\n        \/\/ Process Pax headers\r\n        paxHeaders();\r\n    }\r\n    if (currEntry.isGNUSparse()) {\r\n        \/\/ Process sparse files\r\n        readGNUSparse();\r\n    }\r\n    \/\/ If the size of the next element in the archive has changed\r\n    \/\/ due to a new size being reported in the posix header\r\n    \/\/ information, we update entrySize here so that it contains\r\n    \/\/ the correct value.\r\n    entrySize = currEntry.getSize();\r\n    return currEntry;\r\n}","code_comment":"\/**\r\n * Get the next entry in this tar archive. This will skip\r\n * over any remaining data in the current entry, if there\r\n * is one, and place the input stream at the header of the\r\n * next entry, and read the header and instantiate a new\r\n * TarEntry from the header bytes and return that entry.\r\n * If there are no more entries in the archive, null will\r\n * be returned to indicate that the end of the archive has\r\n * been reached.\r\n *\r\n * @return The next TarEntry in the archive, or null.\r\n * @throws IOException on error\r\n *\/\r\n","code_no_comment":"public TarArchiveEntry getNextTarEntry() throws IOException {\r\n    if (hasHitEOF) {\r\n        return null;\r\n    }\r\n    if (currEntry != null) {\r\n        long numToSkip = entrySize - entryOffset;\r\n        while (numToSkip > 0) {\r\n            long skipped = skip(numToSkip);\r\n            if (skipped <= 0) {\r\n                throw new RuntimeException(\"failed to skip current tar entry\");\r\n            }\r\n            numToSkip -= skipped;\r\n        }\r\n        readBuf = null;\r\n    }\r\n    byte[] headerBuf = getRecord();\r\n    if (hasHitEOF) {\r\n        currEntry = null;\r\n        return null;\r\n    }\r\n    currEntry = new TarArchiveEntry(headerBuf);\r\n    entryOffset = 0;\r\n    entrySize = currEntry.getSize();\r\n    if (currEntry.isGNULongNameEntry()) {\r\n                StringBuffer longName = new StringBuffer();\r\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\r\n        int length = 0;\r\n        while ((length = read(buf)) >= 0) {\r\n            longName.append(new String(buf, 0, length));\r\n        }\r\n        getNextEntry();\r\n        if (currEntry == null) {\r\n                        return null;\r\n        }\r\n                if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {\r\n            longName.deleteCharAt(longName.length() - 1);\r\n        }\r\n        currEntry.setName(longName.toString());\r\n    }\r\n    if (currEntry.isPaxHeader()) {\r\n                paxHeaders();\r\n    }\r\n    if (currEntry.isGNUSparse()) {\r\n                readGNUSparse();\r\n    }\r\n                    entrySize = currEntry.getSize();\r\n    return currEntry;\r\n}","lc":1.5454545455,"pi":0.1674641148,"ma":1.8,"nbd":0.5,"ml":1.3333333333,"d":1.494047619,"mi":-0.8201550388,"fo":1.0833333333,"r":-0.0263157895,"e":2.5721984982}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5570_57d8f051","label":1,"code":"\/**\r\n *  @param updateInterval\r\n *             Duration between AJAX callbacks\r\n *  @return JS script\r\n *\/\r\nprotected final String getJsTimeoutCall(final Duration updateInterval) {\r\n    CharSequence js = getCallbackScript();\r\n    js = JavaScriptUtils.escapeQuotes(js);\r\n    String timeoutHandle = getTimeoutHandle();\r\n    \/\/ this might look strange, but it is necessary for IE not to leak :(\r\n    return timeoutHandle + \" = setTimeout('\" + js + \"', \" + updateInterval.getMilliseconds() + ')';\r\n}","code_comment":"\/**\r\n *  @param updateInterval\r\n *             Duration between AJAX callbacks\r\n *  @return JS script\r\n *\/\r\n","code_no_comment":"protected final String getJsTimeoutCall(final Duration updateInterval) {\r\n    CharSequence js = getCallbackScript();\r\n    js = JavaScriptUtils.escapeQuotes(js);\r\n    String timeoutHandle = getTimeoutHandle();\r\n        return timeoutHandle + \" = setTimeout('\" + js + \"', \" + updateInterval.getMilliseconds() + ')';\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.0912698413,"mi":0.4661028894,"fo":-0.1666666667,"r":2.5526315789,"e":-0.0940670689}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3719_5ad32df9","label":1,"code":"\/**\r\n *  {@inheritDoc}\r\n *\/\r\npublic IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {\r\n    \/\/ If the sourcing strategy did not provide one, than ask the component.\r\n    \/\/ Get the markup for the container\r\n    IMarkupFragment markup = container.getMarkup();\r\n    if (markup == null) {\r\n        return null;\r\n    }\r\n    if (child == null) {\r\n        return markup;\r\n    }\r\n    \/\/ Find the child's markup\r\n    markup = markup.find(child.getId());\r\n    if (markup != null) {\r\n        return markup;\r\n    }\r\n    \/\/ This is to make migration for Items from 1.4 to 1.5 more easy\r\n    if (Character.isDigit(child.getId().charAt(0))) {\r\n        String id = child.getId();\r\n        boolean miss = false;\r\n        for (int i = 1; i < id.length(); i++) {\r\n            if (Character.isDigit(id.charAt(i)) == false) {\r\n                miss = true;\r\n                break;\r\n            }\r\n        }\r\n        if (miss == false) {\r\n            \/\/ The LoopItems markup is equal to the Loops markup\r\n            markup = container.getMarkup();\r\n            if (!(child instanceof AbstractItem) && log.isWarnEnabled()) {\r\n                log.warn(\"1.4 to 1.5 migration issue: the childs wicket-id contains decimals only. \" + \"By convention that +\" + \"is only the case for children (Items) of Loop, ListView, \" + \"Tree etc.. To avoid the warning, the childs container should implement:\\n\" + \"@Override public IMarkupFragment getMarkup(Component child) {\\n\" + \"\/\/ The childs markup is always equal to the parents markup.\\n\" + \"return getMarkup(); }\\n\" + \"Child: \" + child.toString() + \"\\nContainer: \" + container.toString());\r\n            }\r\n        }\r\n    }\r\n    return markup;\r\n}","code_comment":"\/**\r\n *  {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {\r\n            IMarkupFragment markup = container.getMarkup();\r\n    if (markup == null) {\r\n        return null;\r\n    }\r\n    if (child == null) {\r\n        return markup;\r\n    }\r\n        markup = markup.find(child.getId());\r\n    if (markup != null) {\r\n        return markup;\r\n    }\r\n        if (Character.isDigit(child.getId().charAt(0))) {\r\n        String id = child.getId();\r\n        boolean miss = false;\r\n        for (int i = 1; i < id.length(); i++) {\r\n            if (Character.isDigit(id.charAt(i)) == false) {\r\n                miss = true;\r\n                break;\r\n            }\r\n        }\r\n        if (miss == false) {\r\n                        markup = container.getMarkup();\r\n            if (!(child instanceof AbstractItem) && log.isWarnEnabled()) {\r\n                log.warn(\"1.4 to 1.5 migration issue: the childs wicket-id contains decimals only. \" + \"By convention that +\" + \"is only the case for children (Items) of Loop, ListView, \" + \"Tree etc.. To avoid the warning, the childs container should implement:\\n\" + \"@Override public IMarkupFragment getMarkup(Component child) {\\n\" + \"\/\/ The childs markup is always equal to the parents markup.\\n\" + \"return getMarkup(); }\\n\" + \"Child: \" + child.toString() + \"\\nContainer: \" + container.toString());\r\n            }\r\n        }\r\n    }\r\n    return markup;\r\n}","lc":0.7272727273,"pi":0.6507177033,"ma":1.2,"nbd":0.5,"ml":1.1666666667,"d":1.2658730159,"mi":-0.55602537,"fo":0.75,"r":-0.0263157895,"e":1.7926776277}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1926_9225a3e2","label":1,"code":"\/**\r\n * Gets a sorted map of uncommitted revisions of this document with the\r\n * local cluster node id as returned by the {@link RevisionContext}. These\r\n * are the {@link #REVISIONS} entries where {@link Utils#isCommitted(String)}\r\n * returns false.\r\n *\r\n * @param context the revision context.\r\n * @return the uncommitted revisions of this document.\r\n *\/\r\npublic SortedMap<Revision, Revision> getUncommittedRevisions(RevisionContext context) {\r\n    \/\/ only look at revisions in this document.\r\n    \/\/ uncommitted revisions are not split off\r\n    Map<Revision, String> valueMap = getLocalRevisions();\r\n    SortedMap<Revision, Revision> revisions = new TreeMap<Revision, Revision>(context.getRevisionComparator());\r\n    for (Map.Entry<Revision, String> commit : valueMap.entrySet()) {\r\n        if (!Utils.isCommitted(commit.getValue())) {\r\n            Revision r = commit.getKey();\r\n            if (r.getClusterId() == context.getClusterId()) {\r\n                Revision b = Revision.fromString(commit.getValue());\r\n                revisions.put(r, b);\r\n            }\r\n        }\r\n    }\r\n    return revisions;\r\n}","code_comment":"\/**\r\n * Gets a sorted map of uncommitted revisions of this document with the\r\n * local cluster node id as returned by the {@link RevisionContext}. These\r\n * are the {@link #REVISIONS} entries where {@link Utils#isCommitted(String)}\r\n * returns false.\r\n *\r\n * @param context the revision context.\r\n * @return the uncommitted revisions of this document.\r\n *\/\r\n","code_no_comment":"public SortedMap<Revision, Revision> getUncommittedRevisions(RevisionContext context) {\r\n            Map<Revision, String> valueMap = getLocalRevisions();\r\n    SortedMap<Revision, Revision> revisions = new TreeMap<Revision, Revision>(context.getRevisionComparator());\r\n    for (Map.Entry<Revision, String> commit : valueMap.entrySet()) {\r\n        if (!Utils.isCommitted(commit.getValue())) {\r\n            Revision r = commit.getKey();\r\n            if (r.getClusterId() == context.getClusterId()) {\r\n                Revision b = Revision.fromString(commit.getValue());\r\n                revisions.put(r, b);\r\n            }\r\n        }\r\n    }\r\n    return revisions;\r\n}","lc":0.0,"pi":1.0622009569,"ma":0.0,"nbd":0.5,"ml":0.0833333333,"d":0.0396825397,"mi":-0.0762508809,"fo":0.4166666667,"r":-0.0263157895,"e":0.0949245921}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5853_b80f6640","label":3,"code":"\/**\r\n *  @param locale\r\n *  @return Returns the numberFormat.\r\n *\/\r\npublic abstract NumberFormat getNumberFormat(Locale locale);","code_comment":"\/**\r\n *  @param locale\r\n *  @return Returns the numberFormat.\r\n *\/\r\n","code_no_comment":"public abstract NumberFormat getNumberFormat(Locale locale);","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.6116983791,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"Closure","project_version":"169","label":2,"code":"\/**\r\n * @return True if our parameter spec is equal to {@code that}'s parameter\r\n *     spec.\r\n *\/\r\nboolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {\r\n    Node thisParam = parameters.getFirstChild();\r\n    Node otherParam = that.parameters.getFirstChild();\r\n    while (thisParam != null && otherParam != null) {\r\n        JSType thisParamType = thisParam.getJSType();\r\n        JSType otherParamType = otherParam.getJSType();\r\n        if (thisParamType != null) {\r\n            \/\/ Both parameter lists give a type for this param, it should be equal\r\n            if (otherParamType != null && !thisParamType.checkEquivalenceHelper(otherParamType, tolerateUnknowns)) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (otherParamType != null) {\r\n                return false;\r\n            }\r\n        }\r\n        thisParam = thisParam.getNext();\r\n        otherParam = otherParam.getNext();\r\n    }\r\n    \/\/ parameter lists are null (they are equal).\r\n    return thisParam == otherParam;\r\n}","code_comment":"\/**\r\n * @return True if our parameter spec is equal to {@code that}'s parameter\r\n *     spec.\r\n *\/\r\n","code_no_comment":"boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {\r\n    Node thisParam = parameters.getFirstChild();\r\n    Node otherParam = that.parameters.getFirstChild();\r\n    while (thisParam != null && otherParam != null) {\r\n        JSType thisParamType = thisParam.getJSType();\r\n        JSType otherParamType = otherParam.getJSType();\r\n        if (thisParamType != null) {\r\n                        if (otherParamType != null && !thisParamType.checkEquivalenceHelper(otherParamType, tolerateUnknowns)) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (otherParamType != null) {\r\n                return false;\r\n            }\r\n        }\r\n        thisParam = thisParam.getNext();\r\n        otherParam = otherParam.getNext();\r\n    }\r\n        return thisParam == otherParam;\r\n}","lc":0.2727272727,"pi":0.7081339713,"ma":0.2,"nbd":0.5,"ml":0.5833333333,"d":0.6488095238,"mi":-0.2467935166,"fo":0.0833333333,"r":0.1052631579,"e":0.4874258744}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1437_fb7ce0e3","label":1,"code":"@Override\r\npublic T copy(T from) {\r\n    T target;\r\n    try {\r\n        target = clazz.newInstance();\r\n    } catch (Throwable t) {\r\n        throw new RuntimeException(\"Cannot instantiate class.\", t);\r\n    }\r\n    try {\r\n        for (int i = 0; i < numFields; i++) {\r\n            Object copy = fieldSerializers[i].copy(fields[i].get(from));\r\n            fields[i].set(target, copy);\r\n        }\r\n    } catch (IllegalAccessException e) {\r\n        throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields before.\");\r\n    }\r\n    return target;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic T copy(T from) {\r\n    T target;\r\n    try {\r\n        target = clazz.newInstance();\r\n    } catch (Throwable t) {\r\n        throw new RuntimeException(\"Cannot instantiate class.\", t);\r\n    }\r\n    try {\r\n        for (int i = 0; i < numFields; i++) {\r\n            Object copy = fieldSerializers[i].copy(fields[i].get(from));\r\n            fields[i].set(target, copy);\r\n        }\r\n    } catch (IllegalAccessException e) {\r\n        throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields before.\");\r\n    }\r\n    return target;\r\n}","lc":0.1818181818,"pi":0.2583732057,"ma":0.4,"nbd":0.0,"ml":-0.1666666667,"d":-0.0198412698,"mi":-0.1661733615,"fo":-0.1666666667,"r":0.0526315789,"e":0.0068025564}
{"project_name":"Compress","project_version":"13","label":1,"code":"\/**\r\n * Set the name of the entry.\r\n * @param name the name to use\r\n *\/\r\nprotected void setName(String name) {\r\n    this.name = name;\r\n}","code_comment":"\/**\r\n * Set the name of the entry.\r\n * @param name the name to use\r\n *\/\r\n","code_no_comment":"protected void setName(String name) {\r\n    this.name = name;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0606060606,"fo":-0.5,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"Closure","project_version":"148","label":2,"code":"private void openLine() throws IOException {\r\n    out.append(\"[\");\r\n    this.firstChar = true;\r\n}","code_comment":null,"code_no_comment":"private void openLine() throws IOException {\r\n    out.append(\"[\");\r\n    this.firstChar = true;\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8469344609,"fo":-0.4166666667,"r":2.0526315789,"e":-0.1627934049}
{"project_name":"Cli","project_version":"13","label":1,"code":"public void processValues(final WriteableCommandLine commandLine, final ListIterator arguments, final Option option) throws OptionException {\r\n    \/\/ count of arguments processed for this option.\r\n    int argumentCount = 0;\r\n    while (arguments.hasNext() && (argumentCount < maximum)) {\r\n        final String allValuesQuoted = (String) arguments.next();\r\n        final String allValues = stripBoundaryQuotes(allValuesQuoted);\r\n        \/\/ should we ignore things that look like options?\r\n        if (allValuesQuoted.equals(consumeRemaining)) {\r\n            while (arguments.hasNext() && (argumentCount < maximum)) {\r\n                ++argumentCount;\r\n                commandLine.addValue(option, arguments.next());\r\n            }\r\n        } else \/\/ does it look like an option?\r\n        if (commandLine.looksLikeOption(allValuesQuoted)) {\r\n            arguments.previous();\r\n            break;\r\n        } else \/\/ should we split the string up?\r\n        if (subsequentSplit) {\r\n            final StringTokenizer values = new StringTokenizer(allValues, String.valueOf(subsequentSeparator));\r\n            arguments.remove();\r\n            while (values.hasMoreTokens() && (argumentCount < maximum)) {\r\n                ++argumentCount;\r\n                final String token = values.nextToken();\r\n                commandLine.addValue(option, token);\r\n                arguments.add(token);\r\n            }\r\n            if (values.hasMoreTokens()) {\r\n                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE, values.nextToken());\r\n            }\r\n        } else \/\/ it must be a value as it is\r\n        {\r\n            ++argumentCount;\r\n            commandLine.addValue(option, allValues);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void processValues(final WriteableCommandLine commandLine, final ListIterator arguments, final Option option) throws OptionException {\r\n        int argumentCount = 0;\r\n    while (arguments.hasNext() && (argumentCount < maximum)) {\r\n        final String allValuesQuoted = (String) arguments.next();\r\n        final String allValues = stripBoundaryQuotes(allValuesQuoted);\r\n                if (allValuesQuoted.equals(consumeRemaining)) {\r\n            while (arguments.hasNext() && (argumentCount < maximum)) {\r\n                ++argumentCount;\r\n                commandLine.addValue(option, arguments.next());\r\n            }\r\n        } else         if (commandLine.looksLikeOption(allValuesQuoted)) {\r\n            arguments.previous();\r\n            break;\r\n        } else         if (subsequentSplit) {\r\n            final StringTokenizer values = new StringTokenizer(allValues, String.valueOf(subsequentSeparator));\r\n            arguments.remove();\r\n            while (values.hasMoreTokens() && (argumentCount < maximum)) {\r\n                ++argumentCount;\r\n                final String token = values.nextToken();\r\n                commandLine.addValue(option, token);\r\n                arguments.add(token);\r\n            }\r\n            if (values.hasMoreTokens()) {\r\n                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE, values.nextToken());\r\n            }\r\n        } else         {\r\n            ++argumentCount;\r\n            commandLine.addValue(option, allValues);\r\n        }\r\n    }\r\n}","lc":0.9090909091,"pi":0.6555023923,"ma":1.2,"nbd":1.5,"ml":1.1666666667,"d":0.5535714286,"mi":-0.6090204369,"fo":1.0,"r":-0.0263157895,"e":0.9086818462}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3197_be70e608","label":1,"code":"\/**\r\n *  Replaces a child component of this container with another\r\n *\r\n *  @param child\r\n *             The child\r\n *  @throws IllegalArgumentException\r\n *              Thrown if there was no child with the same id.\r\n *  @return This\r\n *\/\r\npublic final MarkupContainer replace(final Component child) {\r\n    checkHierarchyChange(child);\r\n    if (child == null) {\r\n        throw new IllegalArgumentException(\"argument child must be not null\");\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Replacing \" + child.getId() + \" in \" + this);\r\n    }\r\n    if (child.getParent() != this) {\r\n        \/\/ Add to map\r\n        final Component replaced = put(child);\r\n        \/\/ Look up to make sure it was already in the map\r\n        if (replaced == null) {\r\n            throw new WicketRuntimeException(exceptionMessage(\"Cannot replace a component which has not been added: id='\" + child.getId() + \"', component=\" + child));\r\n        }\r\n        \/\/ first remove the component.\r\n        removedComponent(replaced);\r\n        \/\/ then add the other one.\r\n        addedComponent(child);\r\n        \/\/ The generated markup id remains the same\r\n        child.setMarkupIdImpl(replaced.getMarkupIdImpl());\r\n    }\r\n    return this;\r\n}","code_comment":"\/**\r\n *  Replaces a child component of this container with another\r\n *\r\n *  @param child\r\n *             The child\r\n *  @throws IllegalArgumentException\r\n *              Thrown if there was no child with the same id.\r\n *  @return This\r\n *\/\r\n","code_no_comment":"public final MarkupContainer replace(final Component child) {\r\n    checkHierarchyChange(child);\r\n    if (child == null) {\r\n        throw new IllegalArgumentException(\"argument child must be not null\");\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Replacing \" + child.getId() + \" in \" + this);\r\n    }\r\n    if (child.getParent() != this) {\r\n                final Component replaced = put(child);\r\n                if (replaced == null) {\r\n            throw new WicketRuntimeException(exceptionMessage(\"Cannot replace a component which has not been added: id='\" + child.getId() + \"', component=\" + child));\r\n        }\r\n                removedComponent(replaced);\r\n                addedComponent(child);\r\n                child.setMarkupIdImpl(replaced.getMarkupIdImpl());\r\n    }\r\n    return this;\r\n}","lc":0.2272727273,"pi":0.0,"ma":0.6,"nbd":0.0,"ml":0.25,"d":0.2757936508,"mi":-0.2129668781,"fo":0.5,"r":-0.0263157895,"e":0.1880304052}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5226_8e518d88","label":1,"code":"@Override\r\npublic void onInstantiation(Component component) {\r\n    Class<? extends Component> componentClass = component.getClass();\r\n    if (componentClass.isMemberClass() && Modifier.isStatic(componentClass.getModifiers()) == false) {\r\n        LOG.debug(\"Skipping non-static inner class '{}' \", componentClass);\r\n    } else {\r\n        inject(component);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void onInstantiation(Component component) {\r\n    Class<? extends Component> componentClass = component.getClass();\r\n    if (componentClass.isMemberClass() && Modifier.isStatic(componentClass.getModifiers()) == false) {\r\n        LOG.debug(\"Skipping non-static inner class '{}' \", componentClass);\r\n    } else {\r\n        inject(component);\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.4,"nbd":-0.5,"ml":0.0,"d":-0.0972222222,"mi":0.2690627202,"fo":0.0,"r":0.2368421053,"e":-0.0927024083}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4941_c4002945","label":1,"code":"public MojoDescriptor buildComponentDescriptor(PlexusConfiguration c, PluginDescriptor pluginDescriptor) throws PlexusConfigurationException {\r\n    MojoDescriptor mojo = new MojoDescriptor();\r\n    mojo.setPluginDescriptor(pluginDescriptor);\r\n    mojo.setGoal(c.getChild(\"goal\").getValue());\r\n    mojo.setImplementation(c.getChild(\"implementation\").getValue());\r\n    PlexusConfiguration langConfig = c.getChild(\"language\");\r\n    if (langConfig != null) {\r\n        mojo.setLanguage(langConfig.getValue());\r\n    }\r\n    PlexusConfiguration configuratorConfig = c.getChild(\"configurator\");\r\n    if (configuratorConfig != null) {\r\n        mojo.setComponentConfigurator(configuratorConfig.getValue());\r\n    }\r\n    PlexusConfiguration composerConfig = c.getChild(\"composer\");\r\n    if (composerConfig != null) {\r\n        mojo.setComponentComposer(composerConfig.getValue());\r\n    }\r\n    String since = c.getChild(\"since\").getValue();\r\n    if (since != null) {\r\n        mojo.setSince(since);\r\n    }\r\n    PlexusConfiguration deprecated = c.getChild(\"deprecated\", false);\r\n    if (deprecated != null) {\r\n        mojo.setDeprecated(deprecated.getValue());\r\n    }\r\n    String phase = c.getChild(\"phase\").getValue();\r\n    if (phase != null) {\r\n        mojo.setPhase(phase);\r\n    }\r\n    String executePhase = c.getChild(\"executePhase\").getValue();\r\n    if (executePhase != null) {\r\n        mojo.setExecutePhase(executePhase);\r\n    }\r\n    String executeMojo = c.getChild(\"executeGoal\").getValue();\r\n    if (executeMojo != null) {\r\n        mojo.setExecuteGoal(executeMojo);\r\n    }\r\n    String executeLifecycle = c.getChild(\"executeLifecycle\").getValue();\r\n    if (executeLifecycle != null) {\r\n        mojo.setExecuteLifecycle(executeLifecycle);\r\n    }\r\n    mojo.setInstantiationStrategy(c.getChild(\"instantiationStrategy\").getValue());\r\n    mojo.setDescription(c.getChild(\"description\").getValue());\r\n    PlexusConfiguration dependencyResolution = c.getChild(\"requiresDependencyResolution\", false);\r\n    if (dependencyResolution != null) {\r\n        mojo.setDependencyResolutionRequired(dependencyResolution.getValue());\r\n    }\r\n    PlexusConfiguration dependencyCollection = c.getChild(\"requiresDependencyCollection\", false);\r\n    if (dependencyCollection != null) {\r\n        mojo.setDependencyCollectionRequired(dependencyCollection.getValue());\r\n    }\r\n    String directInvocationOnly = c.getChild(\"requiresDirectInvocation\").getValue();\r\n    if (directInvocationOnly != null) {\r\n        mojo.setDirectInvocationOnly(Boolean.parseBoolean(directInvocationOnly));\r\n    }\r\n    String requiresProject = c.getChild(\"requiresProject\").getValue();\r\n    if (requiresProject != null) {\r\n        mojo.setProjectRequired(Boolean.parseBoolean(requiresProject));\r\n    }\r\n    String requiresReports = c.getChild(\"requiresReports\").getValue();\r\n    if (requiresReports != null) {\r\n        mojo.setRequiresReports(Boolean.parseBoolean(requiresReports));\r\n    }\r\n    String aggregator = c.getChild(\"aggregator\").getValue();\r\n    if (aggregator != null) {\r\n        mojo.setAggregator(Boolean.parseBoolean(aggregator));\r\n    }\r\n    String requiresOnline = c.getChild(\"requiresOnline\").getValue();\r\n    if (requiresOnline != null) {\r\n        mojo.setOnlineRequired(Boolean.parseBoolean(requiresOnline));\r\n    }\r\n    String inheritedByDefault = c.getChild(\"inheritedByDefault\").getValue();\r\n    if (inheritedByDefault != null) {\r\n        mojo.setInheritedByDefault(Boolean.parseBoolean(inheritedByDefault));\r\n    }\r\n    String threadSafe = c.getChild(\"threadSafe\").getValue();\r\n    if (threadSafe != null) {\r\n        mojo.setThreadSafe(Boolean.parseBoolean(threadSafe));\r\n    }\r\n    \/\/ ----------------------------------------------------------------------\r\n    \/\/ Parameters\r\n    \/\/ ----------------------------------------------------------------------\r\n    PlexusConfiguration[] parameterConfigurations = c.getChild(\"parameters\").getChildren(\"parameter\");\r\n    List<Parameter> parameters = new ArrayList<Parameter>();\r\n    for (PlexusConfiguration d : parameterConfigurations) {\r\n        Parameter parameter = new Parameter();\r\n        parameter.setName(d.getChild(\"name\").getValue());\r\n        parameter.setAlias(d.getChild(\"alias\").getValue());\r\n        parameter.setType(d.getChild(\"type\").getValue());\r\n        String required = d.getChild(\"required\").getValue();\r\n        parameter.setRequired(Boolean.parseBoolean(required));\r\n        PlexusConfiguration editableConfig = d.getChild(\"editable\");\r\n        \/\/ we need the null check for pre-build legacy plugins...\r\n        if (editableConfig != null) {\r\n            String editable = d.getChild(\"editable\").getValue();\r\n            parameter.setEditable(editable == null || Boolean.parseBoolean(editable));\r\n        }\r\n        parameter.setDescription(d.getChild(\"description\").getValue());\r\n        parameter.setDeprecated(d.getChild(\"deprecated\").getValue());\r\n        parameter.setImplementation(d.getChild(\"implementation\").getValue());\r\n        parameters.add(parameter);\r\n    }\r\n    mojo.setParameters(parameters);\r\n    \/\/ TODO: this should not need to be handed off...\r\n    \/\/ ----------------------------------------------------------------------\r\n    \/\/ Configuration\r\n    \/\/ ----------------------------------------------------------------------\r\n    mojo.setMojoConfiguration(c.getChild(\"configuration\"));\r\n    \/\/ TODO: Go back to this when we get the container ready to configure mojos...\r\n    \/\/ mojo.setConfiguration( c.getChild( \"configuration\" ) );\r\n    \/\/ ----------------------------------------------------------------------\r\n    \/\/ Requirements\r\n    \/\/ ----------------------------------------------------------------------\r\n    PlexusConfiguration[] requirements = c.getChild(\"requirements\").getChildren(\"requirement\");\r\n    for (PlexusConfiguration requirement : requirements) {\r\n        ComponentRequirement cr = new ComponentRequirement();\r\n        cr.setRole(requirement.getChild(\"role\").getValue());\r\n        cr.setRoleHint(requirement.getChild(\"role-hint\").getValue());\r\n        cr.setFieldName(requirement.getChild(\"field-name\").getValue());\r\n        mojo.addRequirement(cr);\r\n    }\r\n    return mojo;\r\n}","code_comment":null,"code_no_comment":"public MojoDescriptor buildComponentDescriptor(PlexusConfiguration c, PluginDescriptor pluginDescriptor) throws PlexusConfigurationException {\r\n    MojoDescriptor mojo = new MojoDescriptor();\r\n    mojo.setPluginDescriptor(pluginDescriptor);\r\n    mojo.setGoal(c.getChild(\"goal\").getValue());\r\n    mojo.setImplementation(c.getChild(\"implementation\").getValue());\r\n    PlexusConfiguration langConfig = c.getChild(\"language\");\r\n    if (langConfig != null) {\r\n        mojo.setLanguage(langConfig.getValue());\r\n    }\r\n    PlexusConfiguration configuratorConfig = c.getChild(\"configurator\");\r\n    if (configuratorConfig != null) {\r\n        mojo.setComponentConfigurator(configuratorConfig.getValue());\r\n    }\r\n    PlexusConfiguration composerConfig = c.getChild(\"composer\");\r\n    if (composerConfig != null) {\r\n        mojo.setComponentComposer(composerConfig.getValue());\r\n    }\r\n    String since = c.getChild(\"since\").getValue();\r\n    if (since != null) {\r\n        mojo.setSince(since);\r\n    }\r\n    PlexusConfiguration deprecated = c.getChild(\"deprecated\", false);\r\n    if (deprecated != null) {\r\n        mojo.setDeprecated(deprecated.getValue());\r\n    }\r\n    String phase = c.getChild(\"phase\").getValue();\r\n    if (phase != null) {\r\n        mojo.setPhase(phase);\r\n    }\r\n    String executePhase = c.getChild(\"executePhase\").getValue();\r\n    if (executePhase != null) {\r\n        mojo.setExecutePhase(executePhase);\r\n    }\r\n    String executeMojo = c.getChild(\"executeGoal\").getValue();\r\n    if (executeMojo != null) {\r\n        mojo.setExecuteGoal(executeMojo);\r\n    }\r\n    String executeLifecycle = c.getChild(\"executeLifecycle\").getValue();\r\n    if (executeLifecycle != null) {\r\n        mojo.setExecuteLifecycle(executeLifecycle);\r\n    }\r\n    mojo.setInstantiationStrategy(c.getChild(\"instantiationStrategy\").getValue());\r\n    mojo.setDescription(c.getChild(\"description\").getValue());\r\n    PlexusConfiguration dependencyResolution = c.getChild(\"requiresDependencyResolution\", false);\r\n    if (dependencyResolution != null) {\r\n        mojo.setDependencyResolutionRequired(dependencyResolution.getValue());\r\n    }\r\n    PlexusConfiguration dependencyCollection = c.getChild(\"requiresDependencyCollection\", false);\r\n    if (dependencyCollection != null) {\r\n        mojo.setDependencyCollectionRequired(dependencyCollection.getValue());\r\n    }\r\n    String directInvocationOnly = c.getChild(\"requiresDirectInvocation\").getValue();\r\n    if (directInvocationOnly != null) {\r\n        mojo.setDirectInvocationOnly(Boolean.parseBoolean(directInvocationOnly));\r\n    }\r\n    String requiresProject = c.getChild(\"requiresProject\").getValue();\r\n    if (requiresProject != null) {\r\n        mojo.setProjectRequired(Boolean.parseBoolean(requiresProject));\r\n    }\r\n    String requiresReports = c.getChild(\"requiresReports\").getValue();\r\n    if (requiresReports != null) {\r\n        mojo.setRequiresReports(Boolean.parseBoolean(requiresReports));\r\n    }\r\n    String aggregator = c.getChild(\"aggregator\").getValue();\r\n    if (aggregator != null) {\r\n        mojo.setAggregator(Boolean.parseBoolean(aggregator));\r\n    }\r\n    String requiresOnline = c.getChild(\"requiresOnline\").getValue();\r\n    if (requiresOnline != null) {\r\n        mojo.setOnlineRequired(Boolean.parseBoolean(requiresOnline));\r\n    }\r\n    String inheritedByDefault = c.getChild(\"inheritedByDefault\").getValue();\r\n    if (inheritedByDefault != null) {\r\n        mojo.setInheritedByDefault(Boolean.parseBoolean(inheritedByDefault));\r\n    }\r\n    String threadSafe = c.getChild(\"threadSafe\").getValue();\r\n    if (threadSafe != null) {\r\n        mojo.setThreadSafe(Boolean.parseBoolean(threadSafe));\r\n    }\r\n                PlexusConfiguration[] parameterConfigurations = c.getChild(\"parameters\").getChildren(\"parameter\");\r\n    List<Parameter> parameters = new ArrayList<Parameter>();\r\n    for (PlexusConfiguration d : parameterConfigurations) {\r\n        Parameter parameter = new Parameter();\r\n        parameter.setName(d.getChild(\"name\").getValue());\r\n        parameter.setAlias(d.getChild(\"alias\").getValue());\r\n        parameter.setType(d.getChild(\"type\").getValue());\r\n        String required = d.getChild(\"required\").getValue();\r\n        parameter.setRequired(Boolean.parseBoolean(required));\r\n        PlexusConfiguration editableConfig = d.getChild(\"editable\");\r\n                if (editableConfig != null) {\r\n            String editable = d.getChild(\"editable\").getValue();\r\n            parameter.setEditable(editable == null || Boolean.parseBoolean(editable));\r\n        }\r\n        parameter.setDescription(d.getChild(\"description\").getValue());\r\n        parameter.setDeprecated(d.getChild(\"deprecated\").getValue());\r\n        parameter.setImplementation(d.getChild(\"implementation\").getValue());\r\n        parameters.add(parameter);\r\n    }\r\n    mojo.setParameters(parameters);\r\n                    mojo.setMojoConfiguration(c.getChild(\"configuration\"));\r\n                        PlexusConfiguration[] requirements = c.getChild(\"requirements\").getChildren(\"requirement\");\r\n    for (PlexusConfiguration requirement : requirements) {\r\n        ComponentRequirement cr = new ComponentRequirement();\r\n        cr.setRole(requirement.getChild(\"role\").getValue());\r\n        cr.setRoleHint(requirement.getChild(\"role-hint\").getValue());\r\n        cr.setFieldName(requirement.getChild(\"field-name\").getValue());\r\n        mojo.addRequirement(cr);\r\n    }\r\n    return mojo;\r\n}","lc":4.3636363636,"pi":-0.3827751196,"ma":3.6,"nbd":0.0,"ml":2.75,"d":1.128968254,"mi":-1.480620155,"fo":9.4166666667,"r":-0.0263157895,"e":9.9264512485}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-412_be2fdba7","label":1,"code":"private List<List<String>> groupFiles(List<String> files, int groups) {\r\n    List<List<String>> result = new ArrayList<List<String>>();\r\n    Iterator<String> iter = files.iterator();\r\n    for (int i = 0; i < groups && iter.hasNext(); i++) {\r\n        List<String> group = new ArrayList<String>();\r\n        for (int j = 0; j < Math.ceil(files.size() \/ (double) groups) && iter.hasNext(); j++) {\r\n            group.add(iter.next());\r\n        }\r\n        result.add(group);\r\n    }\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"private List<List<String>> groupFiles(List<String> files, int groups) {\r\n    List<List<String>> result = new ArrayList<List<String>>();\r\n    Iterator<String> iter = files.iterator();\r\n    for (int i = 0; i < groups && iter.hasNext(); i++) {\r\n        List<String> group = new ArrayList<String>();\r\n        for (int j = 0; j < Math.ceil(files.size() \/ (double) groups) && iter.hasNext(); j++) {\r\n            group.add(iter.next());\r\n        }\r\n        result.add(group);\r\n    }\r\n    return result;\r\n}","lc":-0.0909090909,"pi":0.1961722488,"ma":-0.2,"nbd":0.0,"ml":0.4166666667,"d":0.6170634921,"mi":-0.0131078224,"fo":0.1666666667,"r":-0.0263157895,"e":0.5240642451}
{"project_name":"Closure","project_version":"139","label":2,"code":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    switch(n.getType()) {\r\n        case Token.WHILE:\r\n            if (CONVERT_WHILE_TO_FOR) {\r\n                Node expr = n.getFirstChild();\r\n                n.setType(Token.FOR);\r\n                n.addChildBefore(new Node(Token.EMPTY), expr);\r\n                n.addChildAfter(new Node(Token.EMPTY), expr);\r\n                reportCodeChange(\"WHILE node\");\r\n            }\r\n            break;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    switch(n.getType()) {\r\n        case Token.WHILE:\r\n            if (CONVERT_WHILE_TO_FOR) {\r\n                Node expr = n.getFirstChild();\r\n                n.setType(Token.FOR);\r\n                n.addChildBefore(new Node(Token.EMPTY), expr);\r\n                n.addChildAfter(new Node(Token.EMPTY), expr);\r\n                reportCodeChange(\"WHILE node\");\r\n            }\r\n            break;\r\n    }\r\n}","lc":0.0,"pi":1.6028708134,"ma":0.0,"nbd":0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":-0.0018322763,"fo":0.0,"r":0.0,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5701_087c0a26","label":1,"code":"\/**\r\n *  Exports the Wicket thread locals and broadcasts the received message from the client to all\r\n *  interested components and behaviors in the page with id {@code #pageId}\r\n *  <p>\r\n *      Note: ConnectedMessage and ClosedMessage messages are notification-only. I.e. whatever the\r\n *      components\/behaviors write in the WebSocketRequestHandler will be ignored because the protocol\r\n *      doesn't expect response from the user.\r\n *  <\/p>\r\n *\r\n *  @param message\r\n *       the message to broadcast\r\n *\/\r\npublic final void broadcastMessage(final IWebSocketMessage message) {\r\n    IKey key = getRegistryKey();\r\n    IWebSocketConnection connection = connectionRegistry.getConnection(application, sessionId, key);\r\n    if (connection != null && connection.isOpen()) {\r\n        Application oldApplication = ThreadContext.getApplication();\r\n        Session oldSession = ThreadContext.getSession();\r\n        RequestCycle oldRequestCycle = ThreadContext.getRequestCycle();\r\n        WebSocketResponse webResponse = new WebSocketResponse(connection);\r\n        try {\r\n            RequestCycle requestCycle;\r\n            if (oldRequestCycle == null || message instanceof IWebSocketPushMessage) {\r\n                RequestCycleContext context = new RequestCycleContext(webRequest, webResponse, application.getRootRequestMapper(), application.getExceptionMapperProvider().get());\r\n                requestCycle = application.getRequestCycleProvider().get(context);\r\n                requestCycle.getUrlRenderer().setBaseUrl(baseUrl);\r\n                ThreadContext.setRequestCycle(requestCycle);\r\n            } else {\r\n                requestCycle = oldRequestCycle;\r\n            }\r\n            ThreadContext.setApplication(application);\r\n            Session session;\r\n            if (oldSession == null || message instanceof IWebSocketPushMessage) {\r\n                ISessionStore sessionStore = application.getSessionStore();\r\n                session = sessionStore.lookup(webRequest);\r\n                ThreadContext.setSession(session);\r\n            } else {\r\n                session = oldSession;\r\n            }\r\n            IPageManager pageManager = session.getPageManager();\r\n            try {\r\n                Page page = getPage(pageManager);\r\n                WebSocketRequestHandler requestHandler = new WebSocketRequestHandler(page, connection);\r\n                WebSocketPayload payload = createEventPayload(message, requestHandler);\r\n                sendPayload(payload, page);\r\n                if (!(message instanceof ConnectedMessage || message instanceof ClosedMessage)) {\r\n                    requestHandler.respond(requestCycle);\r\n                }\r\n            } finally {\r\n                pageManager.commitRequest();\r\n            }\r\n        } catch (Exception x) {\r\n            LOG.error(\"An error occurred during processing of a WebSocket message\", x);\r\n        } finally {\r\n            try {\r\n                webResponse.close();\r\n            } finally {\r\n                ThreadContext.setApplication(oldApplication);\r\n                ThreadContext.setRequestCycle(oldRequestCycle);\r\n                ThreadContext.setSession(oldSession);\r\n            }\r\n        }\r\n    } else {\r\n        LOG.debug(\"Either there is no connection({}) or it is closed.\", connection);\r\n    }\r\n}","code_comment":"\/**\r\n *  Exports the Wicket thread locals and broadcasts the received message from the client to all\r\n *  interested components and behaviors in the page with id {@code #pageId}\r\n *  <p>\r\n *      Note: ConnectedMessage and ClosedMessage messages are notification-only. I.e. whatever the\r\n *      components\/behaviors write in the WebSocketRequestHandler will be ignored because the protocol\r\n *      doesn't expect response from the user.\r\n *  <\/p>\r\n *\r\n *  @param message\r\n *       the message to broadcast\r\n *\/\r\n","code_no_comment":"public final void broadcastMessage(final IWebSocketMessage message) {\r\n    IKey key = getRegistryKey();\r\n    IWebSocketConnection connection = connectionRegistry.getConnection(application, sessionId, key);\r\n    if (connection != null && connection.isOpen()) {\r\n        Application oldApplication = ThreadContext.getApplication();\r\n        Session oldSession = ThreadContext.getSession();\r\n        RequestCycle oldRequestCycle = ThreadContext.getRequestCycle();\r\n        WebSocketResponse webResponse = new WebSocketResponse(connection);\r\n        try {\r\n            RequestCycle requestCycle;\r\n            if (oldRequestCycle == null || message instanceof IWebSocketPushMessage) {\r\n                RequestCycleContext context = new RequestCycleContext(webRequest, webResponse, application.getRootRequestMapper(), application.getExceptionMapperProvider().get());\r\n                requestCycle = application.getRequestCycleProvider().get(context);\r\n                requestCycle.getUrlRenderer().setBaseUrl(baseUrl);\r\n                ThreadContext.setRequestCycle(requestCycle);\r\n            } else {\r\n                requestCycle = oldRequestCycle;\r\n            }\r\n            ThreadContext.setApplication(application);\r\n            Session session;\r\n            if (oldSession == null || message instanceof IWebSocketPushMessage) {\r\n                ISessionStore sessionStore = application.getSessionStore();\r\n                session = sessionStore.lookup(webRequest);\r\n                ThreadContext.setSession(session);\r\n            } else {\r\n                session = oldSession;\r\n            }\r\n            IPageManager pageManager = session.getPageManager();\r\n            try {\r\n                Page page = getPage(pageManager);\r\n                WebSocketRequestHandler requestHandler = new WebSocketRequestHandler(page, connection);\r\n                WebSocketPayload payload = createEventPayload(message, requestHandler);\r\n                sendPayload(payload, page);\r\n                if (!(message instanceof ConnectedMessage || message instanceof ClosedMessage)) {\r\n                    requestHandler.respond(requestCycle);\r\n                }\r\n            } finally {\r\n                pageManager.commitRequest();\r\n            }\r\n        } catch (Exception x) {\r\n            LOG.error(\"An error occurred during processing of a WebSocket message\", x);\r\n        } finally {\r\n            try {\r\n                webResponse.close();\r\n            } finally {\r\n                ThreadContext.setApplication(oldApplication);\r\n                ThreadContext.setRequestCycle(oldRequestCycle);\r\n                ThreadContext.setSession(oldSession);\r\n            }\r\n        }\r\n    } else {\r\n        LOG.debug(\"Either there is no connection({}) or it is closed.\", connection);\r\n    }\r\n}","lc":1.8181818182,"pi":0.7607655502,"ma":0.4,"nbd":1.0,"ml":0.6666666667,"d":0.7837301587,"mi":-0.8968287526,"fo":2.0,"r":-0.0263157895,"e":2.5299032405}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-723_1352a70f","label":1,"code":"\/**\r\n * Initialize, or reinitialize, this instance of rand.\r\n *\/\r\nprivate void initState() {\r\n    a = b = c = 0;\r\n    for (i = 0; i < arr.length; i++) {\r\n        arr[i] = GLD_RATIO;\r\n    }\r\n    for (i = 0; i < 4; i++) {\r\n        shuffle();\r\n    }\r\n    \/\/ fill in mem[] with messy stuff\r\n    for (i = 0; i < SIZE; i += 8) {\r\n        arr[0] += rsl[i];\r\n        arr[1] += rsl[i + 1];\r\n        arr[2] += rsl[i + 2];\r\n        arr[3] += rsl[i + 3];\r\n        arr[4] += rsl[i + 4];\r\n        arr[5] += rsl[i + 5];\r\n        arr[6] += rsl[i + 6];\r\n        arr[7] += rsl[i + 7];\r\n        shuffle();\r\n        setState();\r\n    }\r\n    \/\/ second pass makes all of seed affect all of mem\r\n    for (i = 0; i < SIZE; i += 8) {\r\n        arr[0] += mem[i];\r\n        arr[1] += mem[i + 1];\r\n        arr[2] += mem[i + 2];\r\n        arr[3] += mem[i + 3];\r\n        arr[4] += mem[i + 4];\r\n        arr[5] += mem[i + 5];\r\n        arr[6] += mem[i + 6];\r\n        arr[7] += mem[i + 7];\r\n        shuffle();\r\n        setState();\r\n    }\r\n    isaac();\r\n    count = SIZE - 1;\r\n}","code_comment":"\/**\r\n * Initialize, or reinitialize, this instance of rand.\r\n *\/\r\n","code_no_comment":"private void initState() {\r\n    a = b = c = 0;\r\n    for (i = 0; i < arr.length; i++) {\r\n        arr[i] = GLD_RATIO;\r\n    }\r\n    for (i = 0; i < 4; i++) {\r\n        shuffle();\r\n    }\r\n        for (i = 0; i < SIZE; i += 8) {\r\n        arr[0] += rsl[i];\r\n        arr[1] += rsl[i + 1];\r\n        arr[2] += rsl[i + 2];\r\n        arr[3] += rsl[i + 3];\r\n        arr[4] += rsl[i + 4];\r\n        arr[5] += rsl[i + 5];\r\n        arr[6] += rsl[i + 6];\r\n        arr[7] += rsl[i + 7];\r\n        shuffle();\r\n        setState();\r\n    }\r\n        for (i = 0; i < SIZE; i += 8) {\r\n        arr[0] += mem[i];\r\n        arr[1] += mem[i + 1];\r\n        arr[2] += mem[i + 2];\r\n        arr[3] += mem[i + 3];\r\n        arr[4] += mem[i + 4];\r\n        arr[5] += mem[i + 5];\r\n        arr[6] += mem[i + 6];\r\n        arr[7] += mem[i + 7];\r\n        shuffle();\r\n        setState();\r\n    }\r\n    isaac();\r\n    count = SIZE - 1;\r\n}","lc":0.9545454545,"pi":-0.2822966507,"ma":0.2,"nbd":-0.5,"ml":0.0833333333,"d":2.4682539683,"mi":-0.6631430585,"fo":0.0,"r":-0.0263157895,"e":5.2841248711}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1025_a96b455c","label":1,"code":"\/*\r\n     * TODO consider making public.\r\n     *\/\r\nprivate void mapJulToLog4j(java.util.logging.Level julLevel, Level level) {\r\n    julToLog4j.put(julLevel, level);\r\n}","code_comment":null,"code_no_comment":"private void mapJulToLog4j(java.util.logging.Level julLevel, Level level) {\r\n    julToLog4j.put(julLevel, level);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9174066244,"fo":-0.4166666667,"r":2.2105263158,"e":-0.1627934049}
{"project_name":"Math","project_version":"27","label":3,"code":"\/**\r\n * <p>\r\n * Gets the fraction percentage as a <tt>double<\/tt>. This calculates the\r\n * fraction as the numerator divided by denominator multiplied by 100.\r\n * <\/p>\r\n *\r\n * @return the fraction percentage as a <tt>double<\/tt>.\r\n *\/\r\npublic double percentageValue() {\r\n    return multiply(100).doubleValue();\r\n}","code_comment":"\/**\r\n * <p>\r\n * Gets the fraction percentage as a <tt>double<\/tt>. This calculates the\r\n * fraction as the numerator divided by denominator multiplied by 100.\r\n * <\/p>\r\n *\r\n * @return the fraction percentage as a <tt>double<\/tt>.\r\n *\/\r\n","code_no_comment":"public double percentageValue() {\r\n    return multiply(100).doubleValue();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.3333333333,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4658_ef3adb12","label":3,"code":"\/**\r\n *  @param tabIndex\r\n *  @return visible\r\n *\/\r\nprivate boolean isTabVisible(final int tabIndex) {\r\n    if (tabsVisibilityCache == null) {\r\n        tabsVisibilityCache = new Boolean[tabs.size()];\r\n    }\r\n    if (tabsVisibilityCache.length < tabIndex + 1) {\r\n        Boolean[] resized = new Boolean[tabIndex + 1];\r\n        System.arraycopy(tabsVisibilityCache, 0, resized, 0, tabsVisibilityCache.length);\r\n        tabsVisibilityCache = resized;\r\n    }\r\n    if (tabsVisibilityCache.length > 0) {\r\n        Boolean visible = tabsVisibilityCache[tabIndex];\r\n        if (visible == null) {\r\n            visible = tabs.get(tabIndex).isVisible();\r\n            tabsVisibilityCache[tabIndex] = visible;\r\n        }\r\n        return visible;\r\n    } else {\r\n        return false;\r\n    }\r\n}","code_comment":"\/**\r\n *  @param tabIndex\r\n *  @return visible\r\n *\/\r\n","code_no_comment":"private boolean isTabVisible(final int tabIndex) {\r\n    if (tabsVisibilityCache == null) {\r\n        tabsVisibilityCache = new Boolean[tabs.size()];\r\n    }\r\n    if (tabsVisibilityCache.length < tabIndex + 1) {\r\n        Boolean[] resized = new Boolean[tabIndex + 1];\r\n        System.arraycopy(tabsVisibilityCache, 0, resized, 0, tabsVisibilityCache.length);\r\n        tabsVisibilityCache = resized;\r\n    }\r\n    if (tabsVisibilityCache.length > 0) {\r\n        Boolean visible = tabsVisibilityCache[tabIndex];\r\n        if (visible == null) {\r\n            visible = tabs.get(tabIndex).isVisible();\r\n            tabsVisibilityCache[tabIndex] = visible;\r\n        }\r\n        return visible;\r\n    } else {\r\n        return false;\r\n    }\r\n}","lc":0.2727272727,"pi":0.1100478469,"ma":0.2,"nbd":0.0,"ml":0.25,"d":0.6706349206,"mi":-0.2417195208,"fo":-0.1666666667,"r":-0.0263157895,"e":0.4797773206}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4474_269c956e","label":1,"code":"@Deprecated\r\npublic Wagon getWagon(String protocol) throws UnsupportedProtocolException {\r\n    if (protocol == null) {\r\n        throw new UnsupportedProtocolException(\"Unspecified protocol\");\r\n    }\r\n    String hint = protocol.toLowerCase(java.util.Locale.ENGLISH);\r\n    Wagon wagon = (Wagon) wagons.get(hint);\r\n    if (wagon == null) {\r\n        throw new UnsupportedProtocolException(\"Cannot find wagon which supports the requested protocol: \" + protocol);\r\n    }\r\n    return wagon;\r\n}","code_comment":null,"code_no_comment":"@Deprecated\r\npublic Wagon getWagon(String protocol) throws UnsupportedProtocolException {\r\n    if (protocol == null) {\r\n        throw new UnsupportedProtocolException(\"Unspecified protocol\");\r\n    }\r\n    String hint = protocol.toLowerCase(java.util.Locale.ENGLISH);\r\n    Wagon wagon = (Wagon) wagons.get(hint);\r\n    if (wagon == null) {\r\n        throw new UnsupportedProtocolException(\"Cannot find wagon which supports the requested protocol: \" + protocol);\r\n    }\r\n    return wagon;\r\n}","lc":-0.0909090909,"pi":-0.2057416268,"ma":0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0416666667,"mi":0.0661028894,"fo":-0.3333333333,"r":0.1578947368,"e":-0.0420347735}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-1895_806eaeb0","label":0,"code":"private void recurse(ResolutionNode node, Map resolvedArtifacts, Map managedVersions, ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List listeners) throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException {\r\n    fireEvent(ResolutionListener.TEST_ARTIFACT, listeners, node);\r\n    \/\/ TODO: use as a conflict resolver\r\n    Object key = node.getKey();\r\n    if (managedVersions.containsKey(key)) {\r\n        Artifact artifact = (Artifact) managedVersions.get(key);\r\n        fireEvent(ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact);\r\n        if (artifact.getVersion() != null) {\r\n            node.getArtifact().setVersion(artifact.getVersion());\r\n        }\r\n        if (artifact.getScope() != null) {\r\n            node.getArtifact().setScope(artifact.getScope());\r\n        }\r\n    }\r\n    List previousNodes = (List) resolvedArtifacts.get(key);\r\n    if (previousNodes != null) {\r\n        for (Iterator i = previousNodes.iterator(); i.hasNext(); ) {\r\n            ResolutionNode previous = (ResolutionNode) i.next();\r\n            if (previous.isActive()) {\r\n                \/\/ Version mediation\r\n                VersionRange previousRange = previous.getArtifact().getVersionRange();\r\n                VersionRange currentRange = node.getArtifact().getVersionRange();\r\n                \/\/ TODO: why do we force the version on it? what if they don't match?\r\n                if (previousRange == null) {\r\n                    \/\/ version was already resolved\r\n                    node.getArtifact().setVersion(previous.getArtifact().getVersion());\r\n                } else if (currentRange == null) {\r\n                    \/\/ version was already resolved\r\n                    previous.getArtifact().setVersion(node.getArtifact().getVersion());\r\n                } else {\r\n                    \/\/ TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended\r\n                    \/\/ version but the restriction is identical\r\n                    VersionRange newRange = previousRange.restrict(currentRange);\r\n                    \/\/ TODO: ick. this forces the OCE that should have come from the previous call. It is still correct\r\n                    if (newRange.isSelectedVersionKnown(previous.getArtifact())) {\r\n                        fireEvent(ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(), newRange);\r\n                    }\r\n                    previous.getArtifact().setVersionRange(newRange);\r\n                    node.getArtifact().setVersionRange(currentRange.restrict(previousRange));\r\n                    \/\/ Select an appropriate available version from the (now restricted) range\r\n                    \/\/ Note this version was selected before to get the appropriate POM\r\n                    \/\/ But it was reset by the call to setVersionRange on restricting the version\r\n                    ResolutionNode[] resetNodes = { previous, node };\r\n                    for (int j = 0; j < 2; j++) {\r\n                        Artifact resetArtifact = resetNodes[j].getArtifact();\r\n                        if (resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null && resetArtifact.getAvailableVersions() != null) {\r\n                            resetArtifact.selectVersion(resetArtifact.getVersionRange().matchVersion(resetArtifact.getAvailableVersions()).toString());\r\n                            fireEvent(ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j]);\r\n                        }\r\n                    }\r\n                }\r\n                \/\/ Conflict Resolution\r\n                \/\/ TODO: use as conflict resolver(s), chain\r\n                \/\/ TODO: should this be part of mediation?\r\n                \/\/ previous one is more dominant\r\n                ResolutionNode nearest, farthest;\r\n                if (previous.getDepth() <= node.getDepth()) {\r\n                    nearest = previous;\r\n                    farthest = node;\r\n                } else {\r\n                    nearest = node;\r\n                    farthest = previous;\r\n                }\r\n                \/* if we need to update scope of nearest to use farthest scope *\/\r\n                if (checkScopeUpdate(farthest, nearest, listeners)) {\r\n                    fireEvent(ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthest.getArtifact());\r\n                    \/* we need nearest version but farthest scope *\/\r\n                    nearest.disable();\r\n                    farthest.getArtifact().setVersion(nearest.getArtifact().getVersion());\r\n                } else {\r\n                    farthest.disable();\r\n                }\r\n                fireEvent(ResolutionListener.OMIT_FOR_NEARER, listeners, farthest, nearest.getArtifact());\r\n            }\r\n        }\r\n    } else {\r\n        previousNodes = new ArrayList();\r\n        resolvedArtifacts.put(key, previousNodes);\r\n    }\r\n    previousNodes.add(node);\r\n    if (node.isActive()) {\r\n        fireEvent(ResolutionListener.INCLUDE_ARTIFACT, listeners, node);\r\n    }\r\n    \/\/ don't pull in the transitive deps of a system-scoped dependency.\r\n    if (node.isActive() && !Artifact.SCOPE_SYSTEM.equals(node.getArtifact().getScope())) {\r\n        fireEvent(ResolutionListener.PROCESS_CHILDREN, listeners, node);\r\n        for (Iterator i = node.getChildrenIterator(); i.hasNext(); ) {\r\n            ResolutionNode child = (ResolutionNode) i.next();\r\n            \/\/ We leave in optional ones, but don't pick up its dependencies\r\n            if (!child.isResolved() && (!child.getArtifact().isOptional() || child.isChildOfRootNode())) {\r\n                Artifact artifact = child.getArtifact();\r\n                try {\r\n                    if (artifact.getVersion() == null) {\r\n                        \/\/ set the recommended version\r\n                        \/\/ TODO: maybe its better to just pass the range through to retrieval and use a transformation?\r\n                        ArtifactVersion version;\r\n                        if (!artifact.isSelectedVersionKnown()) {\r\n                            List versions = artifact.getAvailableVersions();\r\n                            if (versions == null) {\r\n                                versions = source.retrieveAvailableVersions(artifact, localRepository, remoteRepositories);\r\n                                artifact.setAvailableVersions(versions);\r\n                            }\r\n                            VersionRange versionRange = artifact.getVersionRange();\r\n                            version = versionRange.matchVersion(versions);\r\n                            if (version == null) {\r\n                                if (versions.isEmpty()) {\r\n                                    throw new OverConstrainedVersionException(\"No versions are present in the repository for the artifact with a range \" + versionRange, artifact, remoteRepositories);\r\n                                } else {\r\n                                    throw new OverConstrainedVersionException(\"Couldn't find a version in \" + versions + \" to match range \" + versionRange, artifact, remoteRepositories);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            version = artifact.getSelectedVersion();\r\n                        }\r\n                        artifact.selectVersion(version.toString());\r\n                        fireEvent(ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child);\r\n                    }\r\n                    artifact.setDependencyTrail(node.getDependencyTrail());\r\n                    ResolutionGroup rGroup = source.retrieve(artifact, localRepository, remoteRepositories);\r\n                    \/\/ and catch here rather than have it return null\r\n                    if (rGroup == null) {\r\n                        \/\/ relocated dependency artifact is declared excluded, no need to add and recurse further\r\n                        continue;\r\n                    }\r\n                    child.addDependencies(rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter);\r\n                } catch (CyclicDependencyException e) {\r\n                    \/\/ would like to throw this, but we have crappy stuff in the repo\r\n                    fireEvent(ResolutionListener.OMIT_FOR_CYCLE, listeners, new ResolutionNode(e.getArtifact(), remoteRepositories, child));\r\n                } catch (ArtifactMetadataRetrievalException e) {\r\n                    artifact.setDependencyTrail(node.getDependencyTrail());\r\n                    throw new ArtifactResolutionException(\"Unable to get dependency information: \" + e.getMessage(), artifact, remoteRepositories, e);\r\n                }\r\n                recurse(child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter, listeners);\r\n            }\r\n        }\r\n        fireEvent(ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void recurse(ResolutionNode node, Map resolvedArtifacts, Map managedVersions, ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List listeners) throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException {\r\n    fireEvent(ResolutionListener.TEST_ARTIFACT, listeners, node);\r\n        Object key = node.getKey();\r\n    if (managedVersions.containsKey(key)) {\r\n        Artifact artifact = (Artifact) managedVersions.get(key);\r\n        fireEvent(ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact);\r\n        if (artifact.getVersion() != null) {\r\n            node.getArtifact().setVersion(artifact.getVersion());\r\n        }\r\n        if (artifact.getScope() != null) {\r\n            node.getArtifact().setScope(artifact.getScope());\r\n        }\r\n    }\r\n    List previousNodes = (List) resolvedArtifacts.get(key);\r\n    if (previousNodes != null) {\r\n        for (Iterator i = previousNodes.iterator(); i.hasNext(); ) {\r\n            ResolutionNode previous = (ResolutionNode) i.next();\r\n            if (previous.isActive()) {\r\n                                VersionRange previousRange = previous.getArtifact().getVersionRange();\r\n                VersionRange currentRange = node.getArtifact().getVersionRange();\r\n                                if (previousRange == null) {\r\n                                        node.getArtifact().setVersion(previous.getArtifact().getVersion());\r\n                } else if (currentRange == null) {\r\n                                        previous.getArtifact().setVersion(node.getArtifact().getVersion());\r\n                } else {\r\n                                                            VersionRange newRange = previousRange.restrict(currentRange);\r\n                                        if (newRange.isSelectedVersionKnown(previous.getArtifact())) {\r\n                        fireEvent(ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(), newRange);\r\n                    }\r\n                    previous.getArtifact().setVersionRange(newRange);\r\n                    node.getArtifact().setVersionRange(currentRange.restrict(previousRange));\r\n                                                                                ResolutionNode[] resetNodes = { previous, node };\r\n                    for (int j = 0; j < 2; j++) {\r\n                        Artifact resetArtifact = resetNodes[j].getArtifact();\r\n                        if (resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null && resetArtifact.getAvailableVersions() != null) {\r\n                            resetArtifact.selectVersion(resetArtifact.getVersionRange().matchVersion(resetArtifact.getAvailableVersions()).toString());\r\n                            fireEvent(ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j]);\r\n                        }\r\n                    }\r\n                }\r\n                                                                                ResolutionNode nearest, farthest;\r\n                if (previous.getDepth() <= node.getDepth()) {\r\n                    nearest = previous;\r\n                    farthest = node;\r\n                } else {\r\n                    nearest = node;\r\n                    farthest = previous;\r\n                }\r\n                                if (checkScopeUpdate(farthest, nearest, listeners)) {\r\n                    fireEvent(ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthest.getArtifact());\r\n                                        nearest.disable();\r\n                    farthest.getArtifact().setVersion(nearest.getArtifact().getVersion());\r\n                } else {\r\n                    farthest.disable();\r\n                }\r\n                fireEvent(ResolutionListener.OMIT_FOR_NEARER, listeners, farthest, nearest.getArtifact());\r\n            }\r\n        }\r\n    } else {\r\n        previousNodes = new ArrayList();\r\n        resolvedArtifacts.put(key, previousNodes);\r\n    }\r\n    previousNodes.add(node);\r\n    if (node.isActive()) {\r\n        fireEvent(ResolutionListener.INCLUDE_ARTIFACT, listeners, node);\r\n    }\r\n        if (node.isActive() && !Artifact.SCOPE_SYSTEM.equals(node.getArtifact().getScope())) {\r\n        fireEvent(ResolutionListener.PROCESS_CHILDREN, listeners, node);\r\n        for (Iterator i = node.getChildrenIterator(); i.hasNext(); ) {\r\n            ResolutionNode child = (ResolutionNode) i.next();\r\n                        if (!child.isResolved() && (!child.getArtifact().isOptional() || child.isChildOfRootNode())) {\r\n                Artifact artifact = child.getArtifact();\r\n                try {\r\n                    if (artifact.getVersion() == null) {\r\n                                                                        ArtifactVersion version;\r\n                        if (!artifact.isSelectedVersionKnown()) {\r\n                            List versions = artifact.getAvailableVersions();\r\n                            if (versions == null) {\r\n                                versions = source.retrieveAvailableVersions(artifact, localRepository, remoteRepositories);\r\n                                artifact.setAvailableVersions(versions);\r\n                            }\r\n                            VersionRange versionRange = artifact.getVersionRange();\r\n                            version = versionRange.matchVersion(versions);\r\n                            if (version == null) {\r\n                                if (versions.isEmpty()) {\r\n                                    throw new OverConstrainedVersionException(\"No versions are present in the repository for the artifact with a range \" + versionRange, artifact, remoteRepositories);\r\n                                } else {\r\n                                    throw new OverConstrainedVersionException(\"Couldn't find a version in \" + versions + \" to match range \" + versionRange, artifact, remoteRepositories);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            version = artifact.getSelectedVersion();\r\n                        }\r\n                        artifact.selectVersion(version.toString());\r\n                        fireEvent(ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child);\r\n                    }\r\n                    artifact.setDependencyTrail(node.getDependencyTrail());\r\n                    ResolutionGroup rGroup = source.retrieve(artifact, localRepository, remoteRepositories);\r\n                                        if (rGroup == null) {\r\n                                                continue;\r\n                    }\r\n                    child.addDependencies(rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter);\r\n                } catch (CyclicDependencyException e) {\r\n                                        fireEvent(ResolutionListener.OMIT_FOR_CYCLE, listeners, new ResolutionNode(e.getArtifact(), remoteRepositories, child));\r\n                } catch (ArtifactMetadataRetrievalException e) {\r\n                    artifact.setDependencyTrail(node.getDependencyTrail());\r\n                    throw new ArtifactResolutionException(\"Unable to get dependency information: \" + e.getMessage(), artifact, remoteRepositories, e);\r\n                }\r\n                recurse(child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter, listeners);\r\n            }\r\n        }\r\n        fireEvent(ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node);\r\n    }\r\n}","lc":4.5454545455,"pi":2.5933014354,"ma":5.2,"nbd":3.0,"ml":4.5833333333,"d":3.1765873016,"mi":-1.5525017618,"fo":8.25,"r":-0.0263157895,"e":24.375934026}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-828_a49e443c","label":1,"code":"\/**\r\n * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\r\n * @param tableau simple tableau for the problem\r\n * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\r\n * @return row with the minimum ratio\r\n *\/\r\nprivate Integer getPivotRow(SimplexTableau tableau, final int col) {\r\n    \/\/ create a list of all the rows that tie for the lowest score in the minimum ratio test\r\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\r\n    double minRatio = Double.MAX_VALUE;\r\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\r\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\r\n        final double entry = tableau.getEntry(i, col);\r\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\r\n            final double ratio = rhs \/ entry;\r\n            \/\/ check if the entry is strictly equal to the current min ratio\r\n            \/\/ do not use a ulp\/epsilon check\r\n            final int cmp = Double.compare(ratio, minRatio);\r\n            if (cmp == 0) {\r\n                minRatioPositions.add(i);\r\n            } else if (cmp < 0) {\r\n                minRatio = ratio;\r\n                minRatioPositions = new ArrayList<Integer>();\r\n                minRatioPositions.add(i);\r\n            }\r\n        }\r\n    }\r\n    if (minRatioPositions.size() == 0) {\r\n        return null;\r\n    } else if (minRatioPositions.size() > 1) {\r\n        \/\/ 1. check if there's an artificial variable that can be forced out of the basis\r\n        for (Integer row : minRatioPositions) {\r\n            for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\r\n                int column = i + tableau.getArtificialVariableOffset();\r\n                final double entry = tableau.getEntry(row, column);\r\n                if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\r\n                    return row;\r\n                }\r\n            }\r\n        }\r\n        \/\/ 2. apply Bland's rule to prevent cycling:\r\n        \/\/ take the row for which the corresponding basic variable has the smallest index\r\n        \/\/ \r\n        \/\/ see http:\/\/www.stanford.edu\/class\/msande310\/blandrule.pdf\r\n        \/\/ see http:\/\/en.wikipedia.org\/wiki\/Bland%27s_rule (not equivalent to the above paper)\r\n        Integer minRow = null;\r\n        int minIndex = tableau.getWidth();\r\n        for (Integer row : minRatioPositions) {\r\n            for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1 && minRow != row; i++) {\r\n                if (row == tableau.getBasicRow(i)) {\r\n                    if (i < minIndex) {\r\n                        minIndex = i;\r\n                        minRow = row;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return minRow;\r\n    }\r\n    return minRatioPositions.get(0);\r\n}","code_comment":"\/**\r\n * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\r\n * @param tableau simple tableau for the problem\r\n * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\r\n * @return row with the minimum ratio\r\n *\/\r\n","code_no_comment":"private Integer getPivotRow(SimplexTableau tableau, final int col) {\r\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\r\n    double minRatio = Double.MAX_VALUE;\r\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\r\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\r\n        final double entry = tableau.getEntry(i, col);\r\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\r\n            final double ratio = rhs \/ entry;\r\n                                    final int cmp = Double.compare(ratio, minRatio);\r\n            if (cmp == 0) {\r\n                minRatioPositions.add(i);\r\n            } else if (cmp < 0) {\r\n                minRatio = ratio;\r\n                minRatioPositions = new ArrayList<Integer>();\r\n                minRatioPositions.add(i);\r\n            }\r\n        }\r\n    }\r\n    if (minRatioPositions.size() == 0) {\r\n        return null;\r\n    } else if (minRatioPositions.size() > 1) {\r\n                for (Integer row : minRatioPositions) {\r\n            for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\r\n                int column = i + tableau.getArtificialVariableOffset();\r\n                final double entry = tableau.getEntry(row, column);\r\n                if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\r\n                    return row;\r\n                }\r\n            }\r\n        }\r\n                                                Integer minRow = null;\r\n        int minIndex = tableau.getWidth();\r\n        for (Integer row : minRatioPositions) {\r\n            for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1 && minRow != row; i++) {\r\n                if (row == tableau.getBasicRow(i)) {\r\n                    if (i < minIndex) {\r\n                        minIndex = i;\r\n                        minRow = row;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return minRow;\r\n    }\r\n    return minRatioPositions.get(0);\r\n}","lc":1.4545454545,"pi":1.3732057416,"ma":2.0,"nbd":2.0,"ml":2.0833333333,"d":2.8055555556,"mi":-0.8669485553,"fo":1.3333333333,"r":-0.0263157895,"e":6.8560986152}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2899_31aea2ad","label":0,"code":"private Set<String> beginClearingUnusedLogs() {\r\n    Set<String> doomed = new HashSet<String>();\r\n    ArrayList<String> otherLogsCopy = new ArrayList<String>();\r\n    ArrayList<String> currentLogsCopy = new ArrayList<String>();\r\n    \/\/ do not hold tablet lock while acquiring the log lock\r\n    logLock.lock();\r\n    synchronized (this) {\r\n        if (removingLogs)\r\n            throw new IllegalStateException(\"Attempted to clear logs when removal of logs in progress\");\r\n        for (DfsLogger logger : otherLogs) {\r\n            otherLogsCopy.add(logger.toString());\r\n            doomed.add(logger.toString());\r\n        }\r\n        for (DfsLogger logger : currentLogs) {\r\n            currentLogsCopy.add(logger.toString());\r\n            doomed.remove(logger.toString());\r\n        }\r\n        otherLogs = Collections.emptySet();\r\n        if (doomed.size() > 0)\r\n            removingLogs = true;\r\n    }\r\n    \/\/ do debug logging outside tablet lock\r\n    for (String logger : otherLogsCopy) {\r\n        log.debug(\"Logs for memory compacted: \" + getExtent() + \" \" + logger.toString());\r\n    }\r\n    for (String logger : currentLogsCopy) {\r\n        log.debug(\"Logs for current memory: \" + getExtent() + \" \" + logger);\r\n    }\r\n    return doomed;\r\n}","code_comment":null,"code_no_comment":"private Set<String> beginClearingUnusedLogs() {\r\n    Set<String> doomed = new HashSet<String>();\r\n    ArrayList<String> otherLogsCopy = new ArrayList<String>();\r\n    ArrayList<String> currentLogsCopy = new ArrayList<String>();\r\n        logLock.lock();\r\n    synchronized (this) {\r\n        if (removingLogs)\r\n            throw new IllegalStateException(\"Attempted to clear logs when removal of logs in progress\");\r\n        for (DfsLogger logger : otherLogs) {\r\n            otherLogsCopy.add(logger.toString());\r\n            doomed.add(logger.toString());\r\n        }\r\n        for (DfsLogger logger : currentLogs) {\r\n            currentLogsCopy.add(logger.toString());\r\n            doomed.remove(logger.toString());\r\n        }\r\n        otherLogs = Collections.emptySet();\r\n        if (doomed.size() > 0)\r\n            removingLogs = true;\r\n    }\r\n        for (String logger : otherLogsCopy) {\r\n        log.debug(\"Logs for memory compacted: \" + getExtent() + \" \" + logger.toString());\r\n    }\r\n    for (String logger : currentLogsCopy) {\r\n        log.debug(\"Logs for current memory: \" + getExtent() + \" \" + logger);\r\n    }\r\n    return doomed;\r\n}","lc":0.6363636364,"pi":0.2679425837,"ma":0.8,"nbd":0.0,"ml":-0.0833333333,"d":0.0932539683,"mi":-0.4816067653,"fo":0.8333333333,"r":-0.0263157895,"e":0.2856266893}
{"project_name":"Compress","project_version":"15","label":1,"code":"\/* (non-Javadoc)\r\n     * @see java.lang.Object#equals(java.lang.Object)\r\n     *\/\r\n@Override\r\npublic boolean equals(Object obj) {\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj == null || getClass() != obj.getClass()) {\r\n        return false;\r\n    }\r\n    ZipArchiveEntry other = (ZipArchiveEntry) obj;\r\n    String myName = getName();\r\n    String otherName = other.getName();\r\n    if (myName == null) {\r\n        if (otherName != null) {\r\n            return false;\r\n        }\r\n    } else if (!myName.equals(otherName)) {\r\n        return false;\r\n    }\r\n    String myComment = getComment();\r\n    String otherComment = other.getComment();\r\n    if (myComment == null) {\r\n        if (otherComment != null) {\r\n            return false;\r\n        }\r\n    } else if (!myComment.equals(otherComment)) {\r\n        return false;\r\n    }\r\n    return getTime() == other.getTime() && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform() && getExternalAttributes() == other.getExternalAttributes() && getMethod() == other.getMethod() && getSize() == other.getSize() && getCrc() == other.getCrc() && getCompressedSize() == other.getCompressedSize() && Arrays.equals(getCentralDirectoryExtra(), other.getCentralDirectoryExtra()) && Arrays.equals(getLocalFileDataExtra(), other.getLocalFileDataExtra()) && gpb.equals(other.gpb);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean equals(Object obj) {\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj == null || getClass() != obj.getClass()) {\r\n        return false;\r\n    }\r\n    ZipArchiveEntry other = (ZipArchiveEntry) obj;\r\n    String myName = getName();\r\n    String otherName = other.getName();\r\n    if (myName == null) {\r\n        if (otherName != null) {\r\n            return false;\r\n        }\r\n    } else if (!myName.equals(otherName)) {\r\n        return false;\r\n    }\r\n    String myComment = getComment();\r\n    String otherComment = other.getComment();\r\n    if (myComment == null) {\r\n        if (otherComment != null) {\r\n            return false;\r\n        }\r\n    } else if (!myComment.equals(otherComment)) {\r\n        return false;\r\n    }\r\n    return getTime() == other.getTime() && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform() && getExternalAttributes() == other.getExternalAttributes() && getMethod() == other.getMethod() && getSize() == other.getSize() && getCrc() == other.getCrc() && getCompressedSize() == other.getCompressedSize() && Arrays.equals(getCentralDirectoryExtra(), other.getCentralDirectoryExtra()) && Arrays.equals(getLocalFileDataExtra(), other.getLocalFileDataExtra()) && gpb.equals(other.gpb);\r\n}","lc":0.6818181818,"pi":0.0,"ma":1.0,"nbd":0.0,"ml":1.0833333333,"d":1.3611111111,"mi":-0.5610993658,"fo":2.0833333333,"r":-0.0263157895,"e":2.3255914202}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-428_4a6a573b","label":3,"code":"public Object get(final int index) {\r\n    int keyIndex = nextKey(0);\r\n    for (int i = 0; i < index; i++) {\r\n        keyIndex = nextKey(keyIndex + 1);\r\n    }\r\n    return values[keyIndex];\r\n}","code_comment":null,"code_no_comment":"public Object get(final int index) {\r\n    int keyIndex = nextKey(0);\r\n    for (int i = 0; i < index; i++) {\r\n        keyIndex = nextKey(keyIndex + 1);\r\n    }\r\n    return values[keyIndex];\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":0.3492063492,"mi":0.414235377,"fo":-0.3333333333,"r":0.9736842105,"e":-0.0111316655}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4927_8c827e33","label":1,"code":"@Override\r\npublic void write(byte[] array, int offset, int length) {\r\n    writeBuffered();\r\n    originalResponse.write(array, offset, length);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void write(byte[] array, int offset, int length) {\r\n    writeBuffered();\r\n    originalResponse.write(array, offset, length);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.710782241,"fo":-0.3333333333,"r":0.0526315789,"e":-0.1627934049}
{"project_name":"Math","project_version":"15","label":1,"code":"\/**\r\n * Power function.  Compute x^y.\r\n *\r\n * @param x   a double\r\n * @param y   a double\r\n * @return double\r\n *\/\r\npublic static double pow(double x, double y) {\r\n    final double[] lns = new double[2];\r\n    if (y == 0.0) {\r\n        return 1.0;\r\n    }\r\n    if (x != x) {\r\n        \/\/ X is NaN\r\n        return x;\r\n    }\r\n    if (x == 0) {\r\n        long bits = Double.doubleToLongBits(x);\r\n        if ((bits & 0x8000000000000000L) != 0) {\r\n            \/\/ -zero\r\n            long yi = (long) y;\r\n            if (y < 0 && y == yi && (yi & 1) == 1) {\r\n                return Double.NEGATIVE_INFINITY;\r\n            }\r\n            if (y > 0 && y == yi && (yi & 1) == 1) {\r\n                return -0.0;\r\n            }\r\n        }\r\n        if (y < 0) {\r\n            return Double.POSITIVE_INFINITY;\r\n        }\r\n        if (y > 0) {\r\n            return 0.0;\r\n        }\r\n        return Double.NaN;\r\n    }\r\n    if (x == Double.POSITIVE_INFINITY) {\r\n        if (y != y) {\r\n            \/\/ y is NaN\r\n            return y;\r\n        }\r\n        if (y < 0.0) {\r\n            return 0.0;\r\n        } else {\r\n            return Double.POSITIVE_INFINITY;\r\n        }\r\n    }\r\n    if (y == Double.POSITIVE_INFINITY) {\r\n        if (x * x == 1.0) {\r\n            return Double.NaN;\r\n        }\r\n        if (x * x > 1.0) {\r\n            return Double.POSITIVE_INFINITY;\r\n        } else {\r\n            return 0.0;\r\n        }\r\n    }\r\n    if (x == Double.NEGATIVE_INFINITY) {\r\n        if (y != y) {\r\n            \/\/ y is NaN\r\n            return y;\r\n        }\r\n        if (y < 0) {\r\n            long yi = (long) y;\r\n            if (y == yi && (yi & 1) == 1) {\r\n                return -0.0;\r\n            }\r\n            return 0.0;\r\n        }\r\n        if (y > 0) {\r\n            long yi = (long) y;\r\n            if (y == yi && (yi & 1) == 1) {\r\n                return Double.NEGATIVE_INFINITY;\r\n            }\r\n            return Double.POSITIVE_INFINITY;\r\n        }\r\n    }\r\n    if (y == Double.NEGATIVE_INFINITY) {\r\n        if (x * x == 1.0) {\r\n            return Double.NaN;\r\n        }\r\n        if (x * x < 1.0) {\r\n            return Double.POSITIVE_INFINITY;\r\n        } else {\r\n            return 0.0;\r\n        }\r\n    }\r\n    \/* Handle special case x<0 *\/\r\n    if (x < 0) {\r\n        \/\/ y is an even integer in this case\r\n        if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\r\n            return pow(-x, y);\r\n        }\r\n        if (y == (long) y) {\r\n            \/\/ If y is an integer\r\n            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\r\n        } else {\r\n            return Double.NaN;\r\n        }\r\n    }\r\n    \/* Split y into ya and yb such that y = ya+yb *\/\r\n    double ya;\r\n    double yb;\r\n    if (y < 8e298 && y > -8e298) {\r\n        double tmp1 = y * HEX_40000000;\r\n        ya = y + tmp1 - tmp1;\r\n        yb = y - ya;\r\n    } else {\r\n        double tmp1 = y * 9.31322574615478515625E-10;\r\n        double tmp2 = tmp1 * 9.31322574615478515625E-10;\r\n        ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\r\n        yb = y - ya;\r\n    }\r\n    \/* Compute ln(x) *\/\r\n    final double lores = log(x, lns);\r\n    if (Double.isInfinite(lores)) {\r\n        \/\/ don't allow this to be converted to NaN\r\n        return lores;\r\n    }\r\n    double lna = lns[0];\r\n    double lnb = lns[1];\r\n    \/* resplit lns *\/\r\n    double tmp1 = lna * HEX_40000000;\r\n    double tmp2 = lna + tmp1 - tmp1;\r\n    lnb += lna - tmp2;\r\n    lna = tmp2;\r\n    \/\/ y*ln(x) = (aa+ab)\r\n    final double aa = lna * ya;\r\n    final double ab = lna * yb + lnb * ya + lnb * yb;\r\n    lna = aa + ab;\r\n    lnb = -(lna - aa - ab);\r\n    double z = 1.0 \/ 120.0;\r\n    z = z * lnb + (1.0 \/ 24.0);\r\n    z = z * lnb + (1.0 \/ 6.0);\r\n    z = z * lnb + 0.5;\r\n    z = z * lnb + 1.0;\r\n    z = z * lnb;\r\n    final double result = exp(lna, z, null);\r\n    \/\/ result = result + result * z;\r\n    return result;\r\n}","code_comment":"\/**\r\n * Power function.  Compute x^y.\r\n *\r\n * @param x   a double\r\n * @param y   a double\r\n * @return double\r\n *\/\r\n","code_no_comment":"public static double pow(double x, double y) {\r\n    final double[] lns = new double[2];\r\n    if (y == 0.0) {\r\n        return 1.0;\r\n    }\r\n    if (x != x) {\r\n                return x;\r\n    }\r\n    if (x == 0) {\r\n        long bits = Double.doubleToLongBits(x);\r\n        if ((bits & 0x8000000000000000L) != 0) {\r\n                        long yi = (long) y;\r\n            if (y < 0 && y == yi && (yi & 1) == 1) {\r\n                return Double.NEGATIVE_INFINITY;\r\n            }\r\n            if (y > 0 && y == yi && (yi & 1) == 1) {\r\n                return -0.0;\r\n            }\r\n        }\r\n        if (y < 0) {\r\n            return Double.POSITIVE_INFINITY;\r\n        }\r\n        if (y > 0) {\r\n            return 0.0;\r\n        }\r\n        return Double.NaN;\r\n    }\r\n    if (x == Double.POSITIVE_INFINITY) {\r\n        if (y != y) {\r\n                        return y;\r\n        }\r\n        if (y < 0.0) {\r\n            return 0.0;\r\n        } else {\r\n            return Double.POSITIVE_INFINITY;\r\n        }\r\n    }\r\n    if (y == Double.POSITIVE_INFINITY) {\r\n        if (x * x == 1.0) {\r\n            return Double.NaN;\r\n        }\r\n        if (x * x > 1.0) {\r\n            return Double.POSITIVE_INFINITY;\r\n        } else {\r\n            return 0.0;\r\n        }\r\n    }\r\n    if (x == Double.NEGATIVE_INFINITY) {\r\n        if (y != y) {\r\n                        return y;\r\n        }\r\n        if (y < 0) {\r\n            long yi = (long) y;\r\n            if (y == yi && (yi & 1) == 1) {\r\n                return -0.0;\r\n            }\r\n            return 0.0;\r\n        }\r\n        if (y > 0) {\r\n            long yi = (long) y;\r\n            if (y == yi && (yi & 1) == 1) {\r\n                return Double.NEGATIVE_INFINITY;\r\n            }\r\n            return Double.POSITIVE_INFINITY;\r\n        }\r\n    }\r\n    if (y == Double.NEGATIVE_INFINITY) {\r\n        if (x * x == 1.0) {\r\n            return Double.NaN;\r\n        }\r\n        if (x * x < 1.0) {\r\n            return Double.POSITIVE_INFINITY;\r\n        } else {\r\n            return 0.0;\r\n        }\r\n    }\r\n        if (x < 0) {\r\n                if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\r\n            return pow(-x, y);\r\n        }\r\n        if (y == (long) y) {\r\n                        return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\r\n        } else {\r\n            return Double.NaN;\r\n        }\r\n    }\r\n        double ya;\r\n    double yb;\r\n    if (y < 8e298 && y > -8e298) {\r\n        double tmp1 = y * HEX_40000000;\r\n        ya = y + tmp1 - tmp1;\r\n        yb = y - ya;\r\n    } else {\r\n        double tmp1 = y * 9.31322574615478515625E-10;\r\n        double tmp2 = tmp1 * 9.31322574615478515625E-10;\r\n        ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\r\n        yb = y - ya;\r\n    }\r\n        final double lores = log(x, lns);\r\n    if (Double.isInfinite(lores)) {\r\n                return lores;\r\n    }\r\n    double lna = lns[0];\r\n    double lnb = lns[1];\r\n        double tmp1 = lna * HEX_40000000;\r\n    double tmp2 = lna + tmp1 - tmp1;\r\n    lnb += lna - tmp2;\r\n    lna = tmp2;\r\n        final double aa = lna * ya;\r\n    final double ab = lna * yb + lnb * ya + lnb * yb;\r\n    lna = aa + ab;\r\n    lnb = -(lna - aa - ab);\r\n    double z = 1.0 \/ 120.0;\r\n    z = z * lnb + (1.0 \/ 24.0);\r\n    z = z * lnb + (1.0 \/ 6.0);\r\n    z = z * lnb + 0.5;\r\n    z = z * lnb + 1.0;\r\n    z = z * lnb;\r\n    final double result = exp(lna, z, null);\r\n        return result;\r\n}","lc":4.8636363636,"pi":0.2583732057,"ma":5.2,"nbd":0.5,"ml":3.1666666667,"d":7.9007936508,"mi":-1.5319238901,"fo":0.0833333333,"r":-0.0263157895,"e":41.2170859194}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4358_74cbba24","label":1,"code":"\/**\r\n * Returns an {@link Iterable} of {@link Revision} of all changes performed\r\n * on this document. This covers all entries for {@link #REVISIONS} and\r\n * {@link #COMMIT_ROOT} including previous documents. The revisions are\r\n * returned in descending stable revision order using\r\n * {@link StableRevisionComparator#REVERSE}.\r\n *\r\n * @return revisions of all changes performed on this document.\r\n *\/\r\nIterable<Revision> getAllChanges() {\r\n    final SortedSet<Revision> stack = Sets.newTreeSet(REVERSE);\r\n    \/\/ initialize with local revisions and commitRoot entries\r\n    stack.addAll(getLocalCommitRoot().keySet());\r\n    stack.addAll(getLocalRevisions().keySet());\r\n    if (getPreviousRanges().isEmpty()) {\r\n        return stack;\r\n    }\r\n    return new Iterable<Revision>() {\r\n\r\n        @Override\r\n        public Iterator<Revision> iterator() {\r\n            final Iterator<NodeDocument> previousDocs = getPreviousDocLeaves();\r\n            return new AbstractIterator<Revision>() {\r\n\r\n                private NodeDocument nextDoc;\r\n\r\n                private Revision nextRevision;\r\n\r\n                @Override\r\n                protected Revision computeNext() {\r\n                    if (stack.isEmpty()) {\r\n                        return endOfData();\r\n                    }\r\n                    Revision next = stack.first();\r\n                    stack.remove(next);\r\n                    fillStackIfNeeded();\r\n                    return next;\r\n                }\r\n\r\n                private void fillStackIfNeeded() {\r\n                    for (; ; ) {\r\n                        fetchNextDoc();\r\n                        \/\/ no more changes to compare with\r\n                        if (nextDoc == null) {\r\n                            return;\r\n                        }\r\n                        \/\/ most recent revision of next document\r\n                        if (!stack.isEmpty()) {\r\n                            Revision top = stack.first();\r\n                            if (top.compareRevisionTimeThenClusterId(nextRevision) > 0) {\r\n                                return;\r\n                            }\r\n                        }\r\n                        \/\/ if we get here, we need to pull in changes\r\n                        \/\/ from nextDoc\r\n                        Iterables.addAll(stack, nextDoc.getAllChanges());\r\n                        nextDoc = null;\r\n                        nextRevision = null;\r\n                    }\r\n                }\r\n\r\n                \/**\r\n                 * Fetch the next document if {@code nextDoc} is\r\n                 * {@code null} and there are more documents.\r\n                 *\/\r\n                private void fetchNextDoc() {\r\n                    for (; ; ) {\r\n                        if (nextDoc != null) {\r\n                            break;\r\n                        }\r\n                        if (!previousDocs.hasNext()) {\r\n                            \/\/ no more previous docs\r\n                            break;\r\n                        }\r\n                        nextDoc = previousDocs.next();\r\n                        Iterator<Revision> changes = nextDoc.getAllChanges().iterator();\r\n                        if (changes.hasNext()) {\r\n                            nextRevision = changes.next();\r\n                            break;\r\n                        } else {\r\n                            \/\/ empty document, try next\r\n                            nextDoc = null;\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    };\r\n}","code_comment":"\/**\r\n * Returns an {@link Iterable} of {@link Revision} of all changes performed\r\n * on this document. This covers all entries for {@link #REVISIONS} and\r\n * {@link #COMMIT_ROOT} including previous documents. The revisions are\r\n * returned in descending stable revision order using\r\n * {@link StableRevisionComparator#REVERSE}.\r\n *\r\n * @return revisions of all changes performed on this document.\r\n *\/\r\n\/**\r\n * Fetch the next document if {@code nextDoc} is\r\n * {@code null} and there are more documents.\r\n *\/\r\n","code_no_comment":"Iterable<Revision> getAllChanges() {\r\n    final SortedSet<Revision> stack = Sets.newTreeSet(REVERSE);\r\n        stack.addAll(getLocalCommitRoot().keySet());\r\n    stack.addAll(getLocalRevisions().keySet());\r\n    if (getPreviousRanges().isEmpty()) {\r\n        return stack;\r\n    }\r\n    return new Iterable<Revision>() {\r\n\r\n        @Override\r\n        public Iterator<Revision> iterator() {\r\n            final Iterator<NodeDocument> previousDocs = getPreviousDocLeaves();\r\n            return new AbstractIterator<Revision>() {\r\n\r\n                private NodeDocument nextDoc;\r\n\r\n                private Revision nextRevision;\r\n\r\n                @Override\r\n                protected Revision computeNext() {\r\n                    if (stack.isEmpty()) {\r\n                        return endOfData();\r\n                    }\r\n                    Revision next = stack.first();\r\n                    stack.remove(next);\r\n                    fillStackIfNeeded();\r\n                    return next;\r\n                }\r\n\r\n                private void fillStackIfNeeded() {\r\n                    for (; ; ) {\r\n                        fetchNextDoc();\r\n                                                if (nextDoc == null) {\r\n                            return;\r\n                        }\r\n                                                if (!stack.isEmpty()) {\r\n                            Revision top = stack.first();\r\n                            if (top.compareRevisionTimeThenClusterId(nextRevision) > 0) {\r\n                                return;\r\n                            }\r\n                        }\r\n                                                                        Iterables.addAll(stack, nextDoc.getAllChanges());\r\n                        nextDoc = null;\r\n                        nextRevision = null;\r\n                    }\r\n                }\r\n\r\n                \/**\r\n                 * Fetch the next document if {@code nextDoc} is\r\n                 * {@code null} and there are more documents.\r\n                 *\/\r\n                private void fetchNextDoc() {\r\n                    for (; ; ) {\r\n                        if (nextDoc != null) {\r\n                            break;\r\n                        }\r\n                        if (!previousDocs.hasNext()) {\r\n                                                        break;\r\n                        }\r\n                        nextDoc = previousDocs.next();\r\n                        Iterator<Revision> changes = nextDoc.getAllChanges().iterator();\r\n                        if (changes.hasNext()) {\r\n                            nextRevision = changes.next();\r\n                            break;\r\n                        } else {\r\n                                                        nextDoc = null;\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    };\r\n}","lc":2.4090909091,"pi":2.4258373206,"ma":2.0,"nbd":1.5,"ml":0.8333333333,"d":0.6369047619,"mi":-0.9715292459,"fo":1.75,"r":-0.0263157895,"e":1.2402620978}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7271_a5a2f750","label":1,"code":"@Override\r\npublic Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\r\n    Exchange answer = super.aggregate(oldExchange, newExchange);\r\n    if (oldExchange == null) {\r\n        \/\/ for the first time we must do a copy as the answer, so the outgoing\r\n        \/\/ exchange is not one of the grouped exchanges, as that causes a endless circular reference\r\n        answer = answer.copy();\r\n    }\r\n    return answer;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\r\n    Exchange answer = super.aggregate(oldExchange, newExchange);\r\n    if (oldExchange == null) {\r\n                        answer = answer.copy();\r\n    }\r\n    return answer;\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.0535714286,"mi":0.3801268499,"fo":-0.3333333333,"r":0.1578947368,"e":-0.0887190747}
{"project_name":"Math","project_version":"65","label":1,"code":"\/**\r\n * Get the Root Mean Square value.\r\n * Get the Root Mean Square value, i.e. the root of the arithmetic\r\n * mean of the square of all weighted residuals. This is related to the\r\n * criterion that is minimized by the optimizer as follows: if\r\n * <em>c<\/em> if the criterion, and <em>n<\/em> is the number of\r\n * measurements, then the RMS is <em>sqrt (c\/n)<\/em>.\r\n *\r\n * @return RMS value\r\n *\/\r\npublic double getRMS() {\r\n    double criterion = 0;\r\n    for (int i = 0; i < rows; ++i) {\r\n        final double residual = residuals[i];\r\n        criterion += residual * residual * residualsWeights[i];\r\n    }\r\n    return Math.sqrt(criterion \/ rows);\r\n}","code_comment":"\/**\r\n * Get the Root Mean Square value.\r\n * Get the Root Mean Square value, i.e. the root of the arithmetic\r\n * mean of the square of all weighted residuals. This is related to the\r\n * criterion that is minimized by the optimizer as follows: if\r\n * <em>c<\/em> if the criterion, and <em>n<\/em> is the number of\r\n * measurements, then the RMS is <em>sqrt (c\/n)<\/em>.\r\n *\r\n * @return RMS value\r\n *\/\r\n","code_no_comment":"public double getRMS() {\r\n    double criterion = 0;\r\n    for (int i = 0; i < rows; ++i) {\r\n        final double residual = residuals[i];\r\n        criterion += residual * residual * residualsWeights[i];\r\n    }\r\n    return Math.sqrt(criterion \/ rows);\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":0.7718253968,"mi":0.3150105708,"fo":-0.4166666667,"r":0.0526315789,"e":0.1501979565}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5687_3d2d8619","label":1,"code":"private void getDownstreamProjects(String projectId, Collection<String> projectIds, boolean transitive) {\r\n    for (String id : sorter.getDependents(projectId)) {\r\n        if (projectIds.add(id) && transitive) {\r\n            getDownstreamProjects(id, projectIds, transitive);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void getDownstreamProjects(String projectId, Collection<String> projectIds, boolean transitive) {\r\n    for (String id : sorter.getDependents(projectId)) {\r\n        if (projectIds.add(id) && transitive) {\r\n            getDownstreamProjects(id, projectIds, transitive);\r\n        }\r\n    }\r\n}","lc":-0.3181818182,"pi":0.5406698565,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":-0.3650793651,"mi":0.4291754757,"fo":-0.25,"r":0.0,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"public update_result deepCopy() {\r\n    return new update_result(this);\r\n}","code_comment":null,"code_no_comment":"public update_result deepCopy() {\r\n    return new update_result(this);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1987315011,"fo":-0.5,"r":2.2631578947,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3549_9772f5b2","label":1,"code":"\/**\r\n * OAK-2624 : background read operations are split from background update ops\r\n *\/\r\nprivate void internalRunBackgroundReadOperations() {\r\n    synchronized (backgroundReadMonitor) {\r\n        long start = clock.getTime();\r\n        \/\/ pull in changes from other cluster nodes\r\n        BackgroundReadStats readStats = backgroundRead(true);\r\n        long readTime = clock.getTime() - start;\r\n        String msg = \"Background read operations stats (read:{} {})\";\r\n        if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {\r\n            \/\/ log as info if it took more than 10 seconds\r\n            LOG.info(msg, readTime, readStats);\r\n        } else {\r\n            LOG.debug(msg, readTime, readStats);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * OAK-2624 : background read operations are split from background update ops\r\n *\/\r\n","code_no_comment":"private void internalRunBackgroundReadOperations() {\r\n    synchronized (backgroundReadMonitor) {\r\n        long start = clock.getTime();\r\n                BackgroundReadStats readStats = backgroundRead(true);\r\n        long readTime = clock.getTime() - start;\r\n        String msg = \"Background read operations stats (read:{} {})\";\r\n        if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {\r\n                        LOG.info(msg, readTime, readStats);\r\n        } else {\r\n            LOG.debug(msg, readTime, readStats);\r\n        }\r\n    }\r\n}","lc":-0.0454545455,"pi":0.3110047847,"ma":-0.4,"nbd":0.0,"ml":-0.0833333333,"d":-0.0436507937,"mi":0.0257928118,"fo":0.0833333333,"r":1.7368421053,"e":-0.0224777119}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4309_b4274415","label":1,"code":"\/**\r\n *  Convert to object types, returning null if text is null.\r\n *\r\n *  @return converted\r\n *  @throws StringValueConversionException\r\n *\/\r\npublic final Integer toOptionalInteger() throws StringValueConversionException {\r\n    return (text == null) ? null : toInteger();\r\n}","code_comment":"\/**\r\n *  Convert to object types, returning null if text is null.\r\n *\r\n *  @return converted\r\n *  @throws StringValueConversionException\r\n *\/\r\n","code_no_comment":"public final Integer toOptionalInteger() throws StringValueConversionException {\r\n    return (text == null) ? null : toInteger();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.3650793651,"mi":0.9797040169,"fo":-0.4166666667,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"Codec","project_version":"10","label":1,"code":"\/**\r\n * Encodes the given String into a Caverphone value.\r\n *\r\n * @param txt String the source string\r\n * @return A caverphone code for the given String\r\n *\/\r\npublic String caverphone(String txt) {\r\n    if (txt == null || txt.length() == 0) {\r\n        return \"1111111111\";\r\n    }\r\n    \/\/ 1. Convert to lowercase\r\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\r\n    \/\/ 2. Remove anything not A-Z\r\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\r\n    \/\/ 2.5. Remove final e\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"e$\", \"\");\r\n    \/\/ 3. Handle various start options\r\n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\r\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\r\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\r\n    \/\/ 2.0 only - note the spec says ^enough here again, c+p error I assume\r\n    txt = txt.replaceAll(\"^trough\", \"trou2f\");\r\n    txt = txt.replaceAll(\"^gn\", \"2n\");\r\n    \/\/ End\r\n    txt = txt.replaceAll(\"^mb\", \"m2\");\r\n    \/\/ 4. Handle replacements\r\n    txt = txt.replaceAll(\"cq\", \"2q\");\r\n    txt = txt.replaceAll(\"ci\", \"si\");\r\n    txt = txt.replaceAll(\"ce\", \"se\");\r\n    txt = txt.replaceAll(\"cy\", \"sy\");\r\n    txt = txt.replaceAll(\"tch\", \"2ch\");\r\n    txt = txt.replaceAll(\"c\", \"k\");\r\n    txt = txt.replaceAll(\"q\", \"k\");\r\n    txt = txt.replaceAll(\"x\", \"k\");\r\n    txt = txt.replaceAll(\"v\", \"f\");\r\n    txt = txt.replaceAll(\"dg\", \"2g\");\r\n    txt = txt.replaceAll(\"tio\", \"sio\");\r\n    txt = txt.replaceAll(\"tia\", \"sia\");\r\n    txt = txt.replaceAll(\"d\", \"t\");\r\n    txt = txt.replaceAll(\"ph\", \"fh\");\r\n    txt = txt.replaceAll(\"b\", \"p\");\r\n    txt = txt.replaceAll(\"sh\", \"s2\");\r\n    txt = txt.replaceAll(\"z\", \"s\");\r\n    txt = txt.replaceAll(\"^[aeiou]\", \"A\");\r\n    txt = txt.replaceAll(\"[aeiou]\", \"3\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"j\", \"y\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"^y3\", \"Y3\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"^y\", \"A\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"y\", \"3\");\r\n    txt = txt.replaceAll(\"3gh3\", \"3kh3\");\r\n    txt = txt.replaceAll(\"gh\", \"22\");\r\n    txt = txt.replaceAll(\"g\", \"k\");\r\n    txt = txt.replaceAll(\"s+\", \"S\");\r\n    txt = txt.replaceAll(\"t+\", \"T\");\r\n    txt = txt.replaceAll(\"p+\", \"P\");\r\n    txt = txt.replaceAll(\"k+\", \"K\");\r\n    txt = txt.replaceAll(\"f+\", \"F\");\r\n    txt = txt.replaceAll(\"m+\", \"M\");\r\n    txt = txt.replaceAll(\"n+\", \"N\");\r\n    txt = txt.replaceAll(\"w3\", \"W3\");\r\n    \/\/ txt = txt.replaceAll(\"wy\", \"Wy\");    \/\/ 1.0 only\r\n    txt = txt.replaceAll(\"wh3\", \"Wh3\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"w$\", \"3\");\r\n    \/\/ txt = txt.replaceAll(\"why\", \"Why\");  \/\/ 1.0 only\r\n    txt = txt.replaceAll(\"w\", \"2\");\r\n    txt = txt.replaceAll(\"^h\", \"A\");\r\n    txt = txt.replaceAll(\"h\", \"2\");\r\n    txt = txt.replaceAll(\"r3\", \"R3\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"r$\", \"3\");\r\n    \/\/ txt = txt.replaceAll(\"ry\", \"Ry\");    \/\/ 1.0 only\r\n    txt = txt.replaceAll(\"r\", \"2\");\r\n    txt = txt.replaceAll(\"l3\", \"L3\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"l$\", \"3\");\r\n    \/\/ txt = txt.replaceAll(\"ly\", \"Ly\");    \/\/ 1.0 only\r\n    txt = txt.replaceAll(\"l\", \"2\");\r\n    \/\/ txt = txt.replaceAll(\"j\", \"y\");      \/\/ 1.0 only\r\n    \/\/ txt = txt.replaceAll(\"y3\", \"Y3\");    \/\/ 1.0 only\r\n    \/\/ txt = txt.replaceAll(\"y\", \"2\");      \/\/ 1.0 only\r\n    \/\/ 5. Handle removals\r\n    txt = txt.replaceAll(\"2\", \"\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"3$\", \"A\");\r\n    txt = txt.replaceAll(\"3\", \"\");\r\n    \/\/ 6. put ten 1s on the end\r\n    \/\/ 1.0 only has 6 1s\r\n    txt = txt + \"111111\" + \"1111\";\r\n    \/\/ 1.0 truncates to 6\r\n    return txt.substring(0, 10);\r\n}","code_comment":"\/**\r\n * Encodes the given String into a Caverphone value.\r\n *\r\n * @param txt String the source string\r\n * @return A caverphone code for the given String\r\n *\/\r\n","code_no_comment":"public String caverphone(String txt) {\r\n    if (txt == null || txt.length() == 0) {\r\n        return \"1111111111\";\r\n    }\r\n        txt = txt.toLowerCase(java.util.Locale.ENGLISH);\r\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\r\n            txt = txt.replaceAll(\"e$\", \"\");\r\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\r\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\r\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\r\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");\r\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");\r\n    txt = txt.replaceAll(\"^gn\", \"2n\");\r\n        txt = txt.replaceAll(\"^mb\", \"m2\");\r\n        txt = txt.replaceAll(\"cq\", \"2q\");\r\n    txt = txt.replaceAll(\"ci\", \"si\");\r\n    txt = txt.replaceAll(\"ce\", \"se\");\r\n    txt = txt.replaceAll(\"cy\", \"sy\");\r\n    txt = txt.replaceAll(\"tch\", \"2ch\");\r\n    txt = txt.replaceAll(\"c\", \"k\");\r\n    txt = txt.replaceAll(\"q\", \"k\");\r\n    txt = txt.replaceAll(\"x\", \"k\");\r\n    txt = txt.replaceAll(\"v\", \"f\");\r\n    txt = txt.replaceAll(\"dg\", \"2g\");\r\n    txt = txt.replaceAll(\"tio\", \"sio\");\r\n    txt = txt.replaceAll(\"tia\", \"sia\");\r\n    txt = txt.replaceAll(\"d\", \"t\");\r\n    txt = txt.replaceAll(\"ph\", \"fh\");\r\n    txt = txt.replaceAll(\"b\", \"p\");\r\n    txt = txt.replaceAll(\"sh\", \"s2\");\r\n    txt = txt.replaceAll(\"z\", \"s\");\r\n    txt = txt.replaceAll(\"^[aeiou]\", \"A\");\r\n    txt = txt.replaceAll(\"[aeiou]\", \"3\");\r\n        txt = txt.replaceAll(\"j\", \"y\");\r\n        txt = txt.replaceAll(\"^y3\", \"Y3\");\r\n        txt = txt.replaceAll(\"^y\", \"A\");\r\n        txt = txt.replaceAll(\"y\", \"3\");\r\n    txt = txt.replaceAll(\"3gh3\", \"3kh3\");\r\n    txt = txt.replaceAll(\"gh\", \"22\");\r\n    txt = txt.replaceAll(\"g\", \"k\");\r\n    txt = txt.replaceAll(\"s+\", \"S\");\r\n    txt = txt.replaceAll(\"t+\", \"T\");\r\n    txt = txt.replaceAll(\"p+\", \"P\");\r\n    txt = txt.replaceAll(\"k+\", \"K\");\r\n    txt = txt.replaceAll(\"f+\", \"F\");\r\n    txt = txt.replaceAll(\"m+\", \"M\");\r\n    txt = txt.replaceAll(\"n+\", \"N\");\r\n    txt = txt.replaceAll(\"w3\", \"W3\");\r\n        txt = txt.replaceAll(\"wh3\", \"Wh3\");\r\n        txt = txt.replaceAll(\"w$\", \"3\");\r\n        txt = txt.replaceAll(\"w\", \"2\");\r\n    txt = txt.replaceAll(\"^h\", \"A\");\r\n    txt = txt.replaceAll(\"h\", \"2\");\r\n    txt = txt.replaceAll(\"r3\", \"R3\");\r\n        txt = txt.replaceAll(\"r$\", \"3\");\r\n        txt = txt.replaceAll(\"r\", \"2\");\r\n    txt = txt.replaceAll(\"l3\", \"L3\");\r\n        txt = txt.replaceAll(\"l$\", \"3\");\r\n        txt = txt.replaceAll(\"l\", \"2\");\r\n                    txt = txt.replaceAll(\"2\", \"\");\r\n        txt = txt.replaceAll(\"3$\", \"A\");\r\n    txt = txt.replaceAll(\"3\", \"\");\r\n            txt = txt + \"111111\" + \"1111\";\r\n        return txt.substring(0, 10);\r\n}","lc":2.3181818182,"pi":-1.019138756,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":0.7261904762,"mi":-1.0924594785,"fo":4.5,"r":-0.0263157895,"e":6.3579375645}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4932_f20b2d70","label":1,"code":"\/**\r\n *  Indicates whether hybrid {@link RenderPageRequestHandler} URL for page will be generated only\r\n *  if page has been created with bookmarkable URL.\r\n *  <p>\r\n *  For generic bookmarkable encoders this method should return <code>true<\/code>. For explicit\r\n *  (mounted) encoders this method should return <code>false<\/code>\r\n *\r\n *  @return <code>true<\/code> if hybrid URL requires page created bookmarkable,\r\n *          <code>false<\/code> otherwise.\r\n *\/\r\nprotected abstract boolean pageMustHaveBeenCreatedBookmarkable();","code_comment":"\/**\r\n *  Indicates whether hybrid {@link RenderPageRequestHandler} URL for page will be generated only\r\n *  if page has been created with bookmarkable URL.\r\n *  <p>\r\n *  For generic bookmarkable encoders this method should return <code>true<\/code>. For explicit\r\n *  (mounted) encoders this method should return <code>false<\/code>\r\n *\r\n *  @return <code>true<\/code> if hybrid URL requires page created bookmarkable,\r\n *          <code>false<\/code> otherwise.\r\n *\/\r\n","code_no_comment":"protected abstract boolean pageMustHaveBeenCreatedBookmarkable();","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.8696264975,"fo":-0.5,"r":1.7894736842,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3531_41e4b5b9","label":1,"code":"\/**\r\n * Evaluate the value as a predicate which attempts to convert the value to\r\n * a boolean otherwise true is returned if the value is not null\r\n *\/\r\npublic static boolean evaluateValuePredicate(Object value) {\r\n    if (value instanceof Boolean) {\r\n        return (Boolean) value;\r\n    } else if (value instanceof String) {\r\n        if (\"true\".equalsIgnoreCase((String) value)) {\r\n            return true;\r\n        } else if (\"false\".equalsIgnoreCase((String) value)) {\r\n            return false;\r\n        }\r\n    }\r\n    return value != null;\r\n}","code_comment":"\/**\r\n * Evaluate the value as a predicate which attempts to convert the value to\r\n * a boolean otherwise true is returned if the value is not null\r\n *\/\r\n","code_no_comment":"public static boolean evaluateValuePredicate(Object value) {\r\n    if (value instanceof Boolean) {\r\n        return (Boolean) value;\r\n    } else if (value instanceof String) {\r\n        if (\"true\".equalsIgnoreCase((String) value)) {\r\n            return true;\r\n        } else if (\"false\".equalsIgnoreCase((String) value)) {\r\n            return false;\r\n        }\r\n    }\r\n    return value != null;\r\n}","lc":-0.0909090909,"pi":0.4019138756,"ma":0.2,"nbd":1.0,"ml":0.1666666667,"d":-0.3650793651,"mi":0.1689922481,"fo":-0.3333333333,"r":0.1842105263,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-718_3a08bfa6","label":1,"code":"\/**\r\n * <p>\r\n * Evaluates the continued fraction at the value x.\r\n * <\/p>\r\n *\r\n * <p>\r\n * The implementation of this method is based on equations 14-17 of:\r\n * <ul>\r\n * <li>\r\n *   Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\r\n *   Resource. <a target=\"_blank\"\r\n *   href=\"http:\/\/mathworld.wolfram.com\/ContinuedFraction.html\">\r\n *   http:\/\/mathworld.wolfram.com\/ContinuedFraction.html<\/a>\r\n * <\/li>\r\n * <\/ul>\r\n * The recurrence relationship defined in those equations can result in\r\n * very large intermediate results which can result in numerical overflow.\r\n * As a means to combat these overflow conditions, the intermediate results\r\n * are scaled whenever they threaten to become numerically unstable.<\/p>\r\n *\r\n * @param x the evaluation point.\r\n * @param epsilon maximum error allowed.\r\n * @param maxIterations maximum number of convergents\r\n * @return the value of the continued fraction evaluated at x.\r\n * @throws ConvergenceException if the algorithm fails to converge.\r\n *\/\r\npublic double evaluate(double x, double epsilon, int maxIterations) {\r\n    double p0 = 1.0;\r\n    double p1 = getA(0, x);\r\n    double q0 = 0.0;\r\n    double q1 = 1.0;\r\n    double c = p1 \/ q1;\r\n    int n = 0;\r\n    double relativeError = Double.MAX_VALUE;\r\n    while (n < maxIterations && relativeError > epsilon) {\r\n        ++n;\r\n        double a = getA(n, x);\r\n        double b = getB(n, x);\r\n        double p2 = a * p1 + b * p0;\r\n        double q2 = a * q1 + b * q0;\r\n        boolean infinite = false;\r\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\r\n            \/*\r\n                 * Need to scale. Try successive powers of the larger of a or b\r\n                 * up to 5th power. Throw ConvergenceException if one or both\r\n                 * of p2, q2 still overflow.\r\n                 *\/\r\n            double scaleFactor = 1d;\r\n            double lastScaleFactor = 1d;\r\n            final int maxPower = 5;\r\n            final double scale = FastMath.max(a, b);\r\n            if (scale <= 0) {\r\n                \/\/ Can't scale\r\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\r\n            }\r\n            infinite = true;\r\n            for (int i = 0; i < maxPower; i++) {\r\n                lastScaleFactor = scaleFactor;\r\n                scaleFactor *= scale;\r\n                if (a != 0.0 && a > b) {\r\n                    p2 = p1 \/ lastScaleFactor + (b \/ scaleFactor * p0);\r\n                    q2 = q1 \/ lastScaleFactor + (b \/ scaleFactor * q0);\r\n                } else if (b != 0) {\r\n                    p2 = (a \/ scaleFactor * p1) + p0 \/ lastScaleFactor;\r\n                    q2 = (a \/ scaleFactor * q1) + q0 \/ lastScaleFactor;\r\n                }\r\n                infinite = Double.isInfinite(p2) || Double.isInfinite(q2);\r\n                if (!infinite) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (infinite) {\r\n            \/\/ Scaling failed\r\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\r\n        }\r\n        double r = p2 \/ q2;\r\n        if (Double.isNaN(r)) {\r\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\r\n        }\r\n        relativeError = FastMath.abs(r \/ c - 1.0);\r\n        \/\/ prepare for next iteration\r\n        c = p2 \/ q2;\r\n        p0 = p1;\r\n        p1 = p2;\r\n        q0 = q1;\r\n        q1 = q2;\r\n    }\r\n    if (n >= maxIterations) {\r\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\r\n    }\r\n    return c;\r\n}","code_comment":"\/**\r\n * <p>\r\n * Evaluates the continued fraction at the value x.\r\n * <\/p>\r\n *\r\n * <p>\r\n * The implementation of this method is based on equations 14-17 of:\r\n * <ul>\r\n * <li>\r\n *   Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\r\n *   Resource. <a target=\"_blank\"\r\n *   href=\"http:\/\/mathworld.wolfram.com\/ContinuedFraction.html\">\r\n *   http:\/\/mathworld.wolfram.com\/ContinuedFraction.html<\/a>\r\n * <\/li>\r\n * <\/ul>\r\n * The recurrence relationship defined in those equations can result in\r\n * very large intermediate results which can result in numerical overflow.\r\n * As a means to combat these overflow conditions, the intermediate results\r\n * are scaled whenever they threaten to become numerically unstable.<\/p>\r\n *\r\n * @param x the evaluation point.\r\n * @param epsilon maximum error allowed.\r\n * @param maxIterations maximum number of convergents\r\n * @return the value of the continued fraction evaluated at x.\r\n * @throws ConvergenceException if the algorithm fails to converge.\r\n *\/\r\n","code_no_comment":"public double evaluate(double x, double epsilon, int maxIterations) {\r\n    double p0 = 1.0;\r\n    double p1 = getA(0, x);\r\n    double q0 = 0.0;\r\n    double q1 = 1.0;\r\n    double c = p1 \/ q1;\r\n    int n = 0;\r\n    double relativeError = Double.MAX_VALUE;\r\n    while (n < maxIterations && relativeError > epsilon) {\r\n        ++n;\r\n        double a = getA(n, x);\r\n        double b = getB(n, x);\r\n        double p2 = a * p1 + b * p0;\r\n        double q2 = a * q1 + b * q0;\r\n        boolean infinite = false;\r\n        if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\r\n                        double scaleFactor = 1d;\r\n            double lastScaleFactor = 1d;\r\n            final int maxPower = 5;\r\n            final double scale = FastMath.max(a, b);\r\n            if (scale <= 0) {\r\n                                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\r\n            }\r\n            infinite = true;\r\n            for (int i = 0; i < maxPower; i++) {\r\n                lastScaleFactor = scaleFactor;\r\n                scaleFactor *= scale;\r\n                if (a != 0.0 && a > b) {\r\n                    p2 = p1 \/ lastScaleFactor + (b \/ scaleFactor * p0);\r\n                    q2 = q1 \/ lastScaleFactor + (b \/ scaleFactor * q0);\r\n                } else if (b != 0) {\r\n                    p2 = (a \/ scaleFactor * p1) + p0 \/ lastScaleFactor;\r\n                    q2 = (a \/ scaleFactor * q1) + q0 \/ lastScaleFactor;\r\n                }\r\n                infinite = Double.isInfinite(p2) || Double.isInfinite(q2);\r\n                if (!infinite) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (infinite) {\r\n                        throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\r\n        }\r\n        double r = p2 \/ q2;\r\n        if (Double.isNaN(r)) {\r\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\r\n        }\r\n        relativeError = FastMath.abs(r \/ c - 1.0);\r\n                c = p2 \/ q2;\r\n        p0 = p1;\r\n        p1 = p2;\r\n        q0 = q1;\r\n        q1 = q2;\r\n    }\r\n    if (n >= maxIterations) {\r\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\r\n    }\r\n    return c;\r\n}","lc":2.0454545455,"pi":1.043062201,"ma":2.4,"nbd":1.5,"ml":2.0,"d":4.5734126984,"mi":-1.0482029598,"fo":0.3333333333,"r":-0.0263157895,"e":15.6975732324}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"\/**\r\n *  Adds a child component to this container.\r\n *  <p>\r\n *  Be careful when overriding this method, if not implemented properly it\r\n *  may lead to a java component hierarchy which no longer matches the\r\n *  template hierarchy, which in turn will lead to an error.\r\n *\r\n *  @param child\r\n *             The child\r\n *\r\n *  @throws IllegalArgumentException\r\n *              Thrown if a child with the same id is replaced by the add\r\n *              operation.\r\n *  @return This\r\n *\/\r\nfinal MarkupContainer add(final Component<?> child) {\r\n    if (child == null) {\r\n        throw new IllegalArgumentException(\"argument child may not be null\");\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Add \" + child.getId() + \" to component \" + this.getClass().getName() + \" with path \" + getPath());\r\n    }\r\n    \/\/ Add to map\r\n    addedComponent(child);\r\n    Component replaced = put(child);\r\n    child.setFlag(FLAG_REMOVED_FROM_PARENT, false);\r\n    if (replaced != null) {\r\n        replaced.setFlag(FLAG_REMOVED_FROM_PARENT, true);\r\n        removedComponent(replaced);\r\n        \/\/ The position of the associated markup remains the same\r\n        child.markupIndex = replaced.markupIndex;\r\n        \/\/ The generated markup id remains the same\r\n        String replacedId = (replaced.hasMarkupIdMetaData()) ? replaced.getMarkupId() : null;\r\n        child.setMarkupIdMetaData(replacedId);\r\n    }\r\n    return this;\r\n}","code_comment":"\/**\r\n *  Adds a child component to this container.\r\n *  <p>\r\n *  Be careful when overriding this method, if not implemented properly it\r\n *  may lead to a java component hierarchy which no longer matches the\r\n *  template hierarchy, which in turn will lead to an error.\r\n *\r\n *  @param child\r\n *             The child\r\n *\r\n *  @throws IllegalArgumentException\r\n *              Thrown if a child with the same id is replaced by the add\r\n *              operation.\r\n *  @return This\r\n *\/\r\n","code_no_comment":"final MarkupContainer add(final Component<?> child) {\r\n    if (child == null) {\r\n        throw new IllegalArgumentException(\"argument child may not be null\");\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Add \" + child.getId() + \" to component \" + this.getClass().getName() + \" with path \" + getPath());\r\n    }\r\n        addedComponent(child);\r\n    Component replaced = put(child);\r\n    child.setFlag(FLAG_REMOVED_FROM_PARENT, false);\r\n    if (replaced != null) {\r\n        replaced.setFlag(FLAG_REMOVED_FROM_PARENT, true);\r\n        removedComponent(replaced);\r\n                child.markupIndex = replaced.markupIndex;\r\n                String replacedId = (replaced.hasMarkupIdMetaData()) ? replaced.getMarkupId() : null;\r\n        child.setMarkupIdMetaData(replacedId);\r\n    }\r\n    return this;\r\n}","lc":0.2272727273,"pi":-0.2153110048,"ma":0.4,"nbd":-0.5,"ml":0.25,"d":0.2916666667,"mi":-0.2445384073,"fo":0.6666666667,"r":-0.0263157895,"e":0.3030353325}
{"project_name":"Compress","project_version":"33","label":1,"code":"\/**\r\n * Create an compressor input stream from an input stream, autodetecting\r\n * the compressor type from the first few bytes of the stream. The InputStream\r\n * must support marks, like BufferedInputStream.\r\n *\r\n * @param in the input stream\r\n * @return the compressor input stream\r\n * @throws CompressorException if the compressor name is not known\r\n * @throws IllegalArgumentException if the stream is null or does not support mark\r\n * @since 1.1\r\n *\/\r\npublic CompressorInputStream createCompressorInputStream(final InputStream in) throws CompressorException {\r\n    if (in == null) {\r\n        throw new IllegalArgumentException(\"Stream must not be null.\");\r\n    }\r\n    if (!in.markSupported()) {\r\n        throw new IllegalArgumentException(\"Mark is not supported.\");\r\n    }\r\n    final byte[] signature = new byte[12];\r\n    in.mark(signature.length);\r\n    try {\r\n        int signatureLength = IOUtils.readFully(in, signature);\r\n        in.reset();\r\n        if (BZip2CompressorInputStream.matches(signature, signatureLength)) {\r\n            return new BZip2CompressorInputStream(in, decompressConcatenated);\r\n        }\r\n        if (GzipCompressorInputStream.matches(signature, signatureLength)) {\r\n            return new GzipCompressorInputStream(in, decompressConcatenated);\r\n        }\r\n        if (Pack200CompressorInputStream.matches(signature, signatureLength)) {\r\n            return new Pack200CompressorInputStream(in);\r\n        }\r\n        if (FramedSnappyCompressorInputStream.matches(signature, signatureLength)) {\r\n            return new FramedSnappyCompressorInputStream(in);\r\n        }\r\n        if (ZCompressorInputStream.matches(signature, signatureLength)) {\r\n            return new ZCompressorInputStream(in);\r\n        }\r\n        if (XZUtils.matches(signature, signatureLength) && XZUtils.isXZCompressionAvailable()) {\r\n            return new XZCompressorInputStream(in, decompressConcatenated);\r\n        }\r\n        if (LZMAUtils.matches(signature, signatureLength) && LZMAUtils.isLZMACompressionAvailable()) {\r\n            return new LZMACompressorInputStream(in);\r\n        }\r\n    } catch (IOException e) {\r\n        throw new CompressorException(\"Failed to detect Compressor from InputStream.\", e);\r\n    }\r\n    throw new CompressorException(\"No Compressor found for the stream signature.\");\r\n}","code_comment":"\/**\r\n * Create an compressor input stream from an input stream, autodetecting\r\n * the compressor type from the first few bytes of the stream. The InputStream\r\n * must support marks, like BufferedInputStream.\r\n *\r\n * @param in the input stream\r\n * @return the compressor input stream\r\n * @throws CompressorException if the compressor name is not known\r\n * @throws IllegalArgumentException if the stream is null or does not support mark\r\n * @since 1.1\r\n *\/\r\n","code_no_comment":"public CompressorInputStream createCompressorInputStream(final InputStream in) throws CompressorException {\r\n    if (in == null) {\r\n        throw new IllegalArgumentException(\"Stream must not be null.\");\r\n    }\r\n    if (!in.markSupported()) {\r\n        throw new IllegalArgumentException(\"Mark is not supported.\");\r\n    }\r\n    final byte[] signature = new byte[12];\r\n    in.mark(signature.length);\r\n    try {\r\n        int signatureLength = IOUtils.readFully(in, signature);\r\n        in.reset();\r\n        if (BZip2CompressorInputStream.matches(signature, signatureLength)) {\r\n            return new BZip2CompressorInputStream(in, decompressConcatenated);\r\n        }\r\n        if (GzipCompressorInputStream.matches(signature, signatureLength)) {\r\n            return new GzipCompressorInputStream(in, decompressConcatenated);\r\n        }\r\n        if (Pack200CompressorInputStream.matches(signature, signatureLength)) {\r\n            return new Pack200CompressorInputStream(in);\r\n        }\r\n        if (FramedSnappyCompressorInputStream.matches(signature, signatureLength)) {\r\n            return new FramedSnappyCompressorInputStream(in);\r\n        }\r\n        if (ZCompressorInputStream.matches(signature, signatureLength)) {\r\n            return new ZCompressorInputStream(in);\r\n        }\r\n        if (XZUtils.matches(signature, signatureLength) && XZUtils.isXZCompressionAvailable()) {\r\n            return new XZCompressorInputStream(in, decompressConcatenated);\r\n        }\r\n        if (LZMAUtils.matches(signature, signatureLength) && LZMAUtils.isLZMACompressionAvailable()) {\r\n            return new LZMACompressorInputStream(in);\r\n        }\r\n    } catch (IOException e) {\r\n        throw new CompressorException(\"Failed to detect Compressor from InputStream.\", e);\r\n    }\r\n    throw new CompressorException(\"No Compressor found for the stream signature.\");\r\n}","lc":1.0909090909,"pi":0.0813397129,"ma":2.2,"nbd":0.0,"ml":1.5833333333,"d":0.5496031746,"mi":-0.6837209302,"fo":0.5833333333,"r":-0.0263157895,"e":0.8441324781}
{"project_name":"Time","project_version":"24","label":2,"code":"\/**\r\n * Computes the parsed datetime by setting the saved fields.\r\n * This method is idempotent, but it is not thread-safe.\r\n *\r\n * @param resetFields false by default, but when true, unsaved field values are cleared\r\n * @param text optional text being parsed, to be included in any error message\r\n * @return milliseconds since 1970-01-01T00:00:00Z\r\n * @throws IllegalArgumentException if any field is out of range\r\n * @since 1.3\r\n *\/\r\npublic long computeMillis(boolean resetFields, String text) {\r\n    SavedField[] savedFields = iSavedFields;\r\n    int count = iSavedFieldsCount;\r\n    if (iSavedFieldsShared) {\r\n        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();\r\n        iSavedFieldsShared = false;\r\n    }\r\n    sort(savedFields, count);\r\n    if (count > 0) {\r\n        \/\/ alter base year for parsing if first field is month or day\r\n        DurationField months = DurationFieldType.months().getField(iChrono);\r\n        DurationField days = DurationFieldType.days().getField(iChrono);\r\n        DurationField first = savedFields[0].iField.getDurationField();\r\n        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\r\n            saveField(DateTimeFieldType.year(), iDefaultYear);\r\n            return computeMillis(resetFields, text);\r\n        }\r\n    }\r\n    long millis = iMillis;\r\n    try {\r\n        for (int i = 0; i < count; i++) {\r\n            millis = savedFields[i].set(millis, resetFields);\r\n        }\r\n    } catch (IllegalFieldValueException e) {\r\n        if (text != null) {\r\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\r\n        }\r\n        throw e;\r\n    }\r\n    if (iZone == null) {\r\n        millis -= iOffset;\r\n    } else {\r\n        int offset = iZone.getOffsetFromLocal(millis);\r\n        millis -= offset;\r\n        if (offset != iZone.getOffset(millis)) {\r\n            String message = \"Illegal instant due to time zone offset transition (\" + iZone + ')';\r\n            if (text != null) {\r\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\r\n            }\r\n            throw new IllegalArgumentException(message);\r\n        }\r\n    }\r\n    return millis;\r\n}","code_comment":"\/**\r\n * Computes the parsed datetime by setting the saved fields.\r\n * This method is idempotent, but it is not thread-safe.\r\n *\r\n * @param resetFields false by default, but when true, unsaved field values are cleared\r\n * @param text optional text being parsed, to be included in any error message\r\n * @return milliseconds since 1970-01-01T00:00:00Z\r\n * @throws IllegalArgumentException if any field is out of range\r\n * @since 1.3\r\n *\/\r\n","code_no_comment":"public long computeMillis(boolean resetFields, String text) {\r\n    SavedField[] savedFields = iSavedFields;\r\n    int count = iSavedFieldsCount;\r\n    if (iSavedFieldsShared) {\r\n        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();\r\n        iSavedFieldsShared = false;\r\n    }\r\n    sort(savedFields, count);\r\n    if (count > 0) {\r\n                DurationField months = DurationFieldType.months().getField(iChrono);\r\n        DurationField days = DurationFieldType.days().getField(iChrono);\r\n        DurationField first = savedFields[0].iField.getDurationField();\r\n        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\r\n            saveField(DateTimeFieldType.year(), iDefaultYear);\r\n            return computeMillis(resetFields, text);\r\n        }\r\n    }\r\n    long millis = iMillis;\r\n    try {\r\n        for (int i = 0; i < count; i++) {\r\n            millis = savedFields[i].set(millis, resetFields);\r\n        }\r\n    } catch (IllegalFieldValueException e) {\r\n        if (text != null) {\r\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\r\n        }\r\n        throw e;\r\n    }\r\n    if (iZone == null) {\r\n        millis -= iOffset;\r\n    } else {\r\n        int offset = iZone.getOffsetFromLocal(millis);\r\n        millis -= offset;\r\n        if (offset != iZone.getOffset(millis)) {\r\n            String message = \"Illegal instant due to time zone offset transition (\" + iZone + ')';\r\n            if (text != null) {\r\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\r\n            }\r\n            throw new IllegalArgumentException(message);\r\n        }\r\n    }\r\n    return millis;\r\n}","lc":1.3181818182,"pi":0.2488038278,"ma":1.6,"nbd":0.5,"ml":1.4166666667,"d":1.8214285714,"mi":-0.7992952784,"fo":0.8333333333,"r":-0.0263157895,"e":3.9487998709}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2515_06e2da35","label":0,"code":"\/**\r\n *  Triggers a new checkpoint and uses the given timestamp as the checkpoint\r\n *  timestamp.\r\n *\r\n *  @param timestamp The timestamp for the checkpoint.\r\n *\/\r\npublic boolean triggerCheckpoint(final long timestamp) {\r\n    if (shutdown) {\r\n        LOG.error(\"Cannot trigger checkpoint, checkpoint coordinator has been shutdown.\");\r\n        return false;\r\n    }\r\n    final long checkpointID = checkpointIdCounter.getAndIncrement();\r\n    LOG.info(\"Triggering checkpoint \" + checkpointID + \" @ \" + timestamp);\r\n    try {\r\n        \/\/ first check if all tasks that we need to trigger are running.\r\n        \/\/ if not, abort the checkpoint\r\n        ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length];\r\n        for (int i = 0; i < tasksToTrigger.length; i++) {\r\n            Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt();\r\n            if (ee != null) {\r\n                triggerIDs[i] = ee.getAttemptId();\r\n            } else {\r\n                LOG.info(\"Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.\", tasksToTrigger[i].getSimpleName());\r\n                return false;\r\n            }\r\n        }\r\n        \/\/ next, check if all tasks that need to acknowledge the checkpoint are running.\r\n        \/\/ if not, abort the checkpoint\r\n        Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length);\r\n        for (ExecutionVertex ev : tasksToWaitFor) {\r\n            Execution ee = ev.getCurrentExecutionAttempt();\r\n            if (ee != null) {\r\n                ackTasks.put(ee.getAttemptId(), ev);\r\n            } else {\r\n                LOG.info(\"Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.\", ev.getSimpleName());\r\n                return false;\r\n            }\r\n        }\r\n        \/\/ register a new pending checkpoint. this makes sure we can properly receive acknowledgements\r\n        final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks);\r\n        \/\/ schedule the timer that will clean up the expired checkpoints\r\n        TimerTask canceller = new TimerTask() {\r\n\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    synchronized (lock) {\r\n                        \/\/ note that checkpoint completion discards the pending checkpoint object\r\n                        if (!checkpoint.isDiscarded()) {\r\n                            LOG.info(\"Checkpoint \" + checkpointID + \" expired before completing.\");\r\n                            checkpoint.discard(userClassLoader, true);\r\n                            pendingCheckpoints.remove(checkpointID);\r\n                            rememberRecentCheckpointId(checkpointID);\r\n                        }\r\n                    }\r\n                } catch (Throwable t) {\r\n                    LOG.error(\"Exception while handling checkpoint timeout\", t);\r\n                }\r\n            }\r\n        };\r\n        synchronized (lock) {\r\n            if (shutdown) {\r\n                throw new IllegalStateException(\"Checkpoint coordinator has been shutdown.\");\r\n            }\r\n            pendingCheckpoints.put(checkpointID, checkpoint);\r\n            timer.schedule(canceller, checkpointTimeout);\r\n        }\r\n        \/\/ send the messages to the tasks that trigger their checkpoint\r\n        for (int i = 0; i < tasksToTrigger.length; i++) {\r\n            ExecutionAttemptID id = triggerIDs[i];\r\n            TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp);\r\n            tasksToTrigger[i].sendMessageToCurrentExecution(message, id);\r\n        }\r\n        numUnsuccessfulCheckpointsTriggers.set(0);\r\n        return true;\r\n    } catch (Throwable t) {\r\n        int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet();\r\n        LOG.warn(\"Failed to trigger checkpoint (\" + numUnsuccessful + \" consecutive failed attempts so far)\", t);\r\n        synchronized (lock) {\r\n            PendingCheckpoint checkpoint = pendingCheckpoints.remove(checkpointID);\r\n            if (checkpoint != null && !checkpoint.isDiscarded()) {\r\n                checkpoint.discard(userClassLoader, true);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}","code_comment":"\/**\r\n *  Triggers a new checkpoint and uses the given timestamp as the checkpoint\r\n *  timestamp.\r\n *\r\n *  @param timestamp The timestamp for the checkpoint.\r\n *\/\r\n","code_no_comment":"public boolean triggerCheckpoint(final long timestamp) {\r\n    if (shutdown) {\r\n        LOG.error(\"Cannot trigger checkpoint, checkpoint coordinator has been shutdown.\");\r\n        return false;\r\n    }\r\n    final long checkpointID = checkpointIdCounter.getAndIncrement();\r\n    LOG.info(\"Triggering checkpoint \" + checkpointID + \" @ \" + timestamp);\r\n    try {\r\n                        ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length];\r\n        for (int i = 0; i < tasksToTrigger.length; i++) {\r\n            Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt();\r\n            if (ee != null) {\r\n                triggerIDs[i] = ee.getAttemptId();\r\n            } else {\r\n                LOG.info(\"Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.\", tasksToTrigger[i].getSimpleName());\r\n                return false;\r\n            }\r\n        }\r\n                        Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length);\r\n        for (ExecutionVertex ev : tasksToWaitFor) {\r\n            Execution ee = ev.getCurrentExecutionAttempt();\r\n            if (ee != null) {\r\n                ackTasks.put(ee.getAttemptId(), ev);\r\n            } else {\r\n                LOG.info(\"Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.\", ev.getSimpleName());\r\n                return false;\r\n            }\r\n        }\r\n                final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks);\r\n                TimerTask canceller = new TimerTask() {\r\n\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    synchronized (lock) {\r\n                                                if (!checkpoint.isDiscarded()) {\r\n                            LOG.info(\"Checkpoint \" + checkpointID + \" expired before completing.\");\r\n                            checkpoint.discard(userClassLoader, true);\r\n                            pendingCheckpoints.remove(checkpointID);\r\n                            rememberRecentCheckpointId(checkpointID);\r\n                        }\r\n                    }\r\n                } catch (Throwable t) {\r\n                    LOG.error(\"Exception while handling checkpoint timeout\", t);\r\n                }\r\n            }\r\n        };\r\n        synchronized (lock) {\r\n            if (shutdown) {\r\n                throw new IllegalStateException(\"Checkpoint coordinator has been shutdown.\");\r\n            }\r\n            pendingCheckpoints.put(checkpointID, checkpoint);\r\n            timer.schedule(canceller, checkpointTimeout);\r\n        }\r\n                for (int i = 0; i < tasksToTrigger.length; i++) {\r\n            ExecutionAttemptID id = triggerIDs[i];\r\n            TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp);\r\n            tasksToTrigger[i].sendMessageToCurrentExecution(message, id);\r\n        }\r\n        numUnsuccessfulCheckpointsTriggers.set(0);\r\n        return true;\r\n    } catch (Throwable t) {\r\n        int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet();\r\n        LOG.warn(\"Failed to trigger checkpoint (\" + numUnsuccessful + \" consecutive failed attempts so far)\", t);\r\n        synchronized (lock) {\r\n            PendingCheckpoint checkpoint = pendingCheckpoints.remove(checkpointID);\r\n            if (checkpoint != null && !checkpoint.isDiscarded()) {\r\n                checkpoint.discard(userClassLoader, true);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}","lc":2.6363636364,"pi":1.5358851675,"ma":1.8,"nbd":1.5,"ml":0.8333333333,"d":1.0932539683,"mi":-1.1065539112,"fo":1.75,"r":-0.0263157895,"e":4.1194792621}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3539_a4459ef4","label":1,"code":"\/**\r\n *  Depth broadcast\r\n *\r\n *  @param event\r\n *             event\r\n *\/\r\nprivate void depth(final ComponentEvent<?> event) {\r\n    IEventSink sink = event.getSink();\r\n    boolean targetsApplication = sink instanceof Application;\r\n    boolean targetsSession = targetsApplication || sink instanceof Session;\r\n    boolean targetsCycle = targetsSession || sink instanceof RequestCycle;\r\n    boolean targetsComponnet = sink instanceof Component;\r\n    if (!targetsComponnet && !targetsCycle) {\r\n        dispatcher.dispatchEvent(sink, event);\r\n        return;\r\n    }\r\n    Component cursor = (targetsCycle) ? source.getPage() : (Component) sink;\r\n    if (cursor instanceof MarkupContainer) {\r\n        Visits.visitPostOrder(cursor, new ComponentEventVisitor(event, dispatcher));\r\n    }\r\n    if (event.isStop()) {\r\n        return;\r\n    }\r\n    if (targetsCycle) {\r\n        dispatcher.dispatchEvent(source.getRequestCycle(), event);\r\n    }\r\n    if (event.isStop()) {\r\n        return;\r\n    }\r\n    if (targetsSession) {\r\n        dispatcher.dispatchEvent(source.getSession(), event);\r\n    }\r\n    if (event.isStop()) {\r\n        return;\r\n    }\r\n    if (targetsApplication) {\r\n        dispatcher.dispatchEvent(source.getApplication(), event);\r\n    }\r\n}","code_comment":"\/**\r\n *  Depth broadcast\r\n *\r\n *  @param event\r\n *             event\r\n *\/\r\n","code_no_comment":"private void depth(final ComponentEvent<?> event) {\r\n    IEventSink sink = event.getSink();\r\n    boolean targetsApplication = sink instanceof Application;\r\n    boolean targetsSession = targetsApplication || sink instanceof Session;\r\n    boolean targetsCycle = targetsSession || sink instanceof RequestCycle;\r\n    boolean targetsComponnet = sink instanceof Component;\r\n    if (!targetsComponnet && !targetsCycle) {\r\n        dispatcher.dispatchEvent(sink, event);\r\n        return;\r\n    }\r\n    Component cursor = (targetsCycle) ? source.getPage() : (Component) sink;\r\n    if (cursor instanceof MarkupContainer) {\r\n        Visits.visitPostOrder(cursor, new ComponentEventVisitor(event, dispatcher));\r\n    }\r\n    if (event.isStop()) {\r\n        return;\r\n    }\r\n    if (targetsCycle) {\r\n        dispatcher.dispatchEvent(source.getRequestCycle(), event);\r\n    }\r\n    if (event.isStop()) {\r\n        return;\r\n    }\r\n    if (targetsSession) {\r\n        dispatcher.dispatchEvent(source.getSession(), event);\r\n    }\r\n    if (event.isStop()) {\r\n        return;\r\n    }\r\n    if (targetsApplication) {\r\n        dispatcher.dispatchEvent(source.getApplication(), event);\r\n    }\r\n}","lc":0.8636363636,"pi":-0.4019138756,"ma":1.2,"nbd":-0.5,"ml":0.9166666667,"d":0.5853174603,"mi":-0.5585623679,"fo":0.5833333333,"r":-0.0263157895,"e":0.6976942538}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1731_024e5d37","label":1,"code":"\/**\r\n * Copies the full content from the source to the target repository.\r\n * <p>\r\n * The source repository <strong>must not be modified<\/strong> while\r\n * the copy operation is running to avoid an inconsistent copy.\r\n * <p>\r\n * Note that both the source and the target repository must be closed\r\n * during the copy operation as this method requires exclusive access\r\n * to the repositories.\r\n *\r\n * @param initializer optional extra repository initializer to use\r\n * @throws RepositoryException if the copy operation fails\r\n *\/\r\npublic void copy(RepositoryInitializer initializer) throws RepositoryException {\r\n    RepositoryConfig config = source.getRepositoryConfig();\r\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\r\n    try {\r\n        NodeBuilder builder = target.getRoot().builder();\r\n        String workspace = source.getRepositoryConfig().getDefaultWorkspaceName();\r\n        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\r\n        \/\/ init target repository first\r\n        new InitialContent().initialize(builder);\r\n        if (initializer != null) {\r\n            initializer.initialize(builder);\r\n        }\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            sc.getWorkspaceInitializer().initialize(builder, workspace);\r\n        }\r\n        Map<String, String> uriToPrefix = newHashMap();\r\n        Map<Integer, String> idxToPrefix = newHashMap();\r\n        copyNamespaces(builder, uriToPrefix, idxToPrefix);\r\n        copyNodeTypes(builder);\r\n        copyPrivileges(builder);\r\n        NodeState root = builder.getNodeState();\r\n        copyVersionStore(builder, root, uriToPrefix, idxToPrefix);\r\n        copyWorkspace(builder, root, workspace, uriToPrefix, idxToPrefix);\r\n        logger.info(\"Applying default commit hooks\");\r\n        \/\/ TODO: default hooks?\r\n        List<CommitHook> hooks = newArrayList();\r\n        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);\r\n        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\r\n        \/\/ hooks specific to the upgrade, need to run first\r\n        hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath))));\r\n        \/\/ security-related hooks\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            hooks.addAll(sc.getCommitHooks(workspace));\r\n        }\r\n        \/\/ type validation, reference and indexing hooks\r\n        hooks.add(new EditorHook(new CompositeEditorProvider(new TypeEditorProvider(false), new IndexUpdateProvider(new CompositeIndexEditorProvider(new ReferenceEditorProvider(), new PropertyIndexEditorProvider())))));\r\n        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);\r\n    } catch (Exception e) {\r\n        throw new RepositoryException(\"Failed to copy content\", e);\r\n    }\r\n}","code_comment":"\/**\r\n * Copies the full content from the source to the target repository.\r\n * <p>\r\n * The source repository <strong>must not be modified<\/strong> while\r\n * the copy operation is running to avoid an inconsistent copy.\r\n * <p>\r\n * Note that both the source and the target repository must be closed\r\n * during the copy operation as this method requires exclusive access\r\n * to the repositories.\r\n *\r\n * @param initializer optional extra repository initializer to use\r\n * @throws RepositoryException if the copy operation fails\r\n *\/\r\n","code_no_comment":"public void copy(RepositoryInitializer initializer) throws RepositoryException {\r\n    RepositoryConfig config = source.getRepositoryConfig();\r\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\r\n    try {\r\n        NodeBuilder builder = target.getRoot().builder();\r\n        String workspace = source.getRepositoryConfig().getDefaultWorkspaceName();\r\n        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\r\n                new InitialContent().initialize(builder);\r\n        if (initializer != null) {\r\n            initializer.initialize(builder);\r\n        }\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            sc.getWorkspaceInitializer().initialize(builder, workspace);\r\n        }\r\n        Map<String, String> uriToPrefix = newHashMap();\r\n        Map<Integer, String> idxToPrefix = newHashMap();\r\n        copyNamespaces(builder, uriToPrefix, idxToPrefix);\r\n        copyNodeTypes(builder);\r\n        copyPrivileges(builder);\r\n        NodeState root = builder.getNodeState();\r\n        copyVersionStore(builder, root, uriToPrefix, idxToPrefix);\r\n        copyWorkspace(builder, root, workspace, uriToPrefix, idxToPrefix);\r\n        logger.info(\"Applying default commit hooks\");\r\n                List<CommitHook> hooks = newArrayList();\r\n        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);\r\n        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\r\n                hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath))));\r\n                for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            hooks.addAll(sc.getCommitHooks(workspace));\r\n        }\r\n                hooks.add(new EditorHook(new CompositeEditorProvider(new TypeEditorProvider(false), new IndexUpdateProvider(new CompositeIndexEditorProvider(new ReferenceEditorProvider(), new PropertyIndexEditorProvider())))));\r\n        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);\r\n    } catch (Exception e) {\r\n        throw new RepositoryException(\"Failed to copy content\", e);\r\n    }\r\n}","lc":1.0,"pi":-0.1961722488,"ma":0.4,"nbd":0.0,"ml":-0.25,"d":-0.0138888889,"mi":-0.7040169133,"fo":2.3333333333,"r":-0.0263157895,"e":0.6193553592}
{"project_name":"Closure","project_version":"58","label":2,"code":"\/**\r\n * Computes the GEN and KILL set.\r\n *\r\n * @param n Root node.\r\n * @param gen Local variables that are live because of the instruction at\r\n *        {@code n} will be added to this set.\r\n * @param kill Local variables that are killed because of the instruction at\r\n *        {@code n} will be added to this set.\r\n * @param conditional {@code true} if any assignments encountered are\r\n *        conditionally executed. These assignments might not kill a variable.\r\n *\/\r\nprivate void computeGenKill(Node n, BitSet gen, BitSet kill, boolean conditional) {\r\n    switch(n.getType()) {\r\n        case Token.SCRIPT:\r\n        case Token.BLOCK:\r\n        case Token.FUNCTION:\r\n            return;\r\n        case Token.WHILE:\r\n        case Token.DO:\r\n        case Token.IF:\r\n            computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional);\r\n            return;\r\n        case Token.FOR:\r\n            if (!NodeUtil.isForIn(n)) {\r\n                computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional);\r\n            } else {\r\n                \/\/ for(x in y) {...}\r\n                Node lhs = n.getFirstChild();\r\n                Node rhs = lhs.getNext();\r\n                if (NodeUtil.isVar(lhs)) {\r\n                    \/\/ for(var x in y) {...}\r\n                    lhs = lhs.getLastChild();\r\n                }\r\n                addToSetIfLocal(lhs, kill);\r\n                addToSetIfLocal(lhs, gen);\r\n                computeGenKill(rhs, gen, kill, conditional);\r\n            }\r\n            return;\r\n        case Token.VAR:\r\n            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\r\n                if (c.hasChildren()) {\r\n                    computeGenKill(c.getFirstChild(), gen, kill, conditional);\r\n                    if (!conditional) {\r\n                        addToSetIfLocal(c, kill);\r\n                    }\r\n                }\r\n            }\r\n            return;\r\n        case Token.AND:\r\n        case Token.OR:\r\n            computeGenKill(n.getFirstChild(), gen, kill, conditional);\r\n            \/\/ May short circuit.\r\n            computeGenKill(n.getLastChild(), gen, kill, true);\r\n            return;\r\n        case Token.HOOK:\r\n            computeGenKill(n.getFirstChild(), gen, kill, conditional);\r\n            \/\/ Assume both sides are conditional.\r\n            computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\r\n            computeGenKill(n.getLastChild(), gen, kill, true);\r\n            return;\r\n        case Token.NAME:\r\n            if (isArgumentsName(n)) {\r\n                markAllParametersEscaped();\r\n            } else {\r\n                addToSetIfLocal(n, gen);\r\n            }\r\n            return;\r\n        default:\r\n            if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\r\n                Node lhs = n.getFirstChild();\r\n                if (!conditional) {\r\n                    addToSetIfLocal(lhs, kill);\r\n                }\r\n                if (!NodeUtil.isAssign(n)) {\r\n                    \/\/ assignments such as a += 1 reads a.\r\n                    addToSetIfLocal(lhs, gen);\r\n                }\r\n                computeGenKill(lhs.getNext(), gen, kill, conditional);\r\n            } else {\r\n                for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\r\n                    computeGenKill(c, gen, kill, conditional);\r\n                }\r\n            }\r\n            return;\r\n    }\r\n}","code_comment":"\/**\r\n * Computes the GEN and KILL set.\r\n *\r\n * @param n Root node.\r\n * @param gen Local variables that are live because of the instruction at\r\n *        {@code n} will be added to this set.\r\n * @param kill Local variables that are killed because of the instruction at\r\n *        {@code n} will be added to this set.\r\n * @param conditional {@code true} if any assignments encountered are\r\n *        conditionally executed. These assignments might not kill a variable.\r\n *\/\r\n","code_no_comment":"private void computeGenKill(Node n, BitSet gen, BitSet kill, boolean conditional) {\r\n    switch(n.getType()) {\r\n        case Token.SCRIPT:\r\n        case Token.BLOCK:\r\n        case Token.FUNCTION:\r\n            return;\r\n        case Token.WHILE:\r\n        case Token.DO:\r\n        case Token.IF:\r\n            computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional);\r\n            return;\r\n        case Token.FOR:\r\n            if (!NodeUtil.isForIn(n)) {\r\n                computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional);\r\n            } else {\r\n                                Node lhs = n.getFirstChild();\r\n                Node rhs = lhs.getNext();\r\n                if (NodeUtil.isVar(lhs)) {\r\n                                        lhs = lhs.getLastChild();\r\n                }\r\n                addToSetIfLocal(lhs, kill);\r\n                addToSetIfLocal(lhs, gen);\r\n                computeGenKill(rhs, gen, kill, conditional);\r\n            }\r\n            return;\r\n        case Token.VAR:\r\n            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\r\n                if (c.hasChildren()) {\r\n                    computeGenKill(c.getFirstChild(), gen, kill, conditional);\r\n                    if (!conditional) {\r\n                        addToSetIfLocal(c, kill);\r\n                    }\r\n                }\r\n            }\r\n            return;\r\n        case Token.AND:\r\n        case Token.OR:\r\n            computeGenKill(n.getFirstChild(), gen, kill, conditional);\r\n                        computeGenKill(n.getLastChild(), gen, kill, true);\r\n            return;\r\n        case Token.HOOK:\r\n            computeGenKill(n.getFirstChild(), gen, kill, conditional);\r\n                        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\r\n            computeGenKill(n.getLastChild(), gen, kill, true);\r\n            return;\r\n        case Token.NAME:\r\n            if (isArgumentsName(n)) {\r\n                markAllParametersEscaped();\r\n            } else {\r\n                addToSetIfLocal(n, gen);\r\n            }\r\n            return;\r\n        default:\r\n            if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\r\n                Node lhs = n.getFirstChild();\r\n                if (!conditional) {\r\n                    addToSetIfLocal(lhs, kill);\r\n                }\r\n                if (!NodeUtil.isAssign(n)) {\r\n                                        addToSetIfLocal(lhs, gen);\r\n                }\r\n                computeGenKill(lhs.getNext(), gen, kill, conditional);\r\n            } else {\r\n                for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\r\n                    computeGenKill(c, gen, kill, conditional);\r\n                }\r\n            }\r\n            return;\r\n    }\r\n}","lc":2.5454545455,"pi":0.7799043062,"ma":4.0,"nbd":1.5,"ml":2.5833333333,"d":1.3392857143,"mi":-1.1375616631,"fo":3.25,"r":-0.0263157895,"e":3.9890804101}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4927_8c827e33","label":1,"code":"@Override\r\npublic void reset() {\r\n    if (flushed) {\r\n        throw new IllegalStateException(\"Response has already been flushed!\");\r\n    }\r\n    bufferedResponse.reset();\r\n    bufferedWritten = false;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void reset() {\r\n    if (flushed) {\r\n        throw new IllegalStateException(\"Response has already been flushed!\");\r\n    }\r\n    bufferedResponse.reset();\r\n    bufferedWritten = false;\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.481042988,"fo":-0.4166666667,"r":1.5789473684,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-434_133cbc2d","label":1,"code":"\/**\r\n * Get the current solution.\r\n *\r\n * @return current solution\r\n *\/\r\nprotected RealPointValuePair getSolution() {\r\n    int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\r\n    Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\r\n    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\r\n    Set<Integer> basicRows = new HashSet<Integer>();\r\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\r\n    for (int i = 0; i < coefficients.length; i++) {\r\n        int colIndex = columnLabels.indexOf(\"x\" + i);\r\n        if (colIndex < 0) {\r\n            coefficients[i] = 0;\r\n            continue;\r\n        }\r\n        Integer basicRow = getBasicRow(colIndex);\r\n        if (basicRows.contains(basicRow)) {\r\n            \/\/ if multiple variables can take a given value\r\n            \/\/ then we choose the first and set the rest equal to 0\r\n            coefficients[i] = 0;\r\n        } else {\r\n            basicRows.add(basicRow);\r\n            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\r\n        }\r\n    }\r\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\r\n}","code_comment":"\/**\r\n * Get the current solution.\r\n *\r\n * @return current solution\r\n *\/\r\n","code_no_comment":"protected RealPointValuePair getSolution() {\r\n    int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\r\n    Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\r\n    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\r\n    Set<Integer> basicRows = new HashSet<Integer>();\r\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\r\n    for (int i = 0; i < coefficients.length; i++) {\r\n        int colIndex = columnLabels.indexOf(\"x\" + i);\r\n        if (colIndex < 0) {\r\n            coefficients[i] = 0;\r\n            continue;\r\n        }\r\n        Integer basicRow = getBasicRow(colIndex);\r\n        if (basicRows.contains(basicRow)) {\r\n                                    coefficients[i] = 0;\r\n        } else {\r\n            basicRows.add(basicRow);\r\n            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\r\n        }\r\n    }\r\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\r\n}","lc":0.3636363636,"pi":0.3349282297,"ma":1.0,"nbd":0.0,"ml":0.8333333333,"d":1.0833333333,"mi":-0.3970401691,"fo":0.5,"r":0.0,"e":1.4502123638}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1054_0adf3a6e","label":1,"code":"@Override\r\npublic Validator childNodeDeleted(String name, NodeState before) throws CommitFailedException {\r\n    Tree node = parentBefore.getChild(name);\r\n    if (isAdminUser(node)) {\r\n        String msg = \"The admin user cannot be removed.\";\r\n        throw constraintViolation(27, msg);\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Validator childNodeDeleted(String name, NodeState before) throws CommitFailedException {\r\n    Tree node = parentBefore.getChild(name);\r\n    if (isAdminUser(node)) {\r\n        String msg = \"The admin user cannot be removed.\";\r\n        throw constraintViolation(27, msg);\r\n    }\r\n    return null;\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.2684989429,"fo":-0.25,"r":0.2894736842,"e":-0.1627934049}
{"project_name":"Closure","project_version":"33","label":2,"code":"@Override\r\npublic void matchConstraint(ObjectType constraintObj) {\r\n    \/\/ properties on this object.\r\n    if (constraintObj.isRecordType()) {\r\n        for (String prop : constraintObj.getOwnPropertyNames()) {\r\n            JSType propType = constraintObj.getPropertyType(prop);\r\n            if (!isPropertyTypeDeclared(prop)) {\r\n                JSType typeToInfer = propType;\r\n                if (!hasProperty(prop)) {\r\n                    typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType);\r\n                }\r\n                defineInferredProperty(prop, typeToInfer, null);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void matchConstraint(ObjectType constraintObj) {\r\n        if (constraintObj.isRecordType()) {\r\n        for (String prop : constraintObj.getOwnPropertyNames()) {\r\n            JSType propType = constraintObj.getPropertyType(prop);\r\n            if (!isPropertyTypeDeclared(prop)) {\r\n                JSType typeToInfer = propType;\r\n                if (!hasProperty(prop)) {\r\n                    typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType);\r\n                }\r\n                defineInferredProperty(prop, typeToInfer, null);\r\n            }\r\n        }\r\n    }\r\n}","lc":0.0454545455,"pi":1.6794258373,"ma":0.2,"nbd":1.0,"ml":0.1666666667,"d":-0.0535714286,"mi":-0.0458069063,"fo":0.1666666667,"r":0.0789473684,"e":-0.0382589052}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-705_645d642b","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\r\n    sanityChecks(equations, t);\r\n    setEquations(equations);\r\n    resetEvaluations();\r\n    final boolean forward = t > equations.getTime();\r\n    \/\/ create some internal working arrays\r\n    final double[] y0 = equations.getCompleteState();\r\n    final double[] y = y0.clone();\r\n    final int stages = c.length + 1;\r\n    final double[][] yDotK = new double[stages][y.length];\r\n    final double[] yTmp = new double[y.length];\r\n    final double[] yDotTmp = new double[y.length];\r\n    \/\/ set up an interpolator sharing the integrator arrays\r\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\r\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\r\n    interpolator.storeTime(equations.getTime());\r\n    \/\/ set up integration control objects\r\n    stepStart = equations.getTime();\r\n    double hNew = 0;\r\n    boolean firstTime = true;\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.reset();\r\n    }\r\n    setStateInitialized(false);\r\n    \/\/ main integration loop\r\n    isLastStep = false;\r\n    do {\r\n        interpolator.shift();\r\n        \/\/ iterate over step size, ensuring local normalized error is smaller than 1\r\n        double error = 10;\r\n        while (error >= 1.0) {\r\n            if (firstTime || !fsal) {\r\n                \/\/ first stage\r\n                computeDerivatives(stepStart, y, yDotK[0]);\r\n            }\r\n            if (firstTime) {\r\n                final double[] scale = new double[mainSetDimension];\r\n                if (vecAbsoluteTolerance == null) {\r\n                    for (int i = 0; i < scale.length; ++i) {\r\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\r\n                    }\r\n                } else {\r\n                    for (int i = 0; i < scale.length; ++i) {\r\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\r\n                    }\r\n                }\r\n                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\r\n                firstTime = false;\r\n            }\r\n            stepSize = hNew;\r\n            \/\/ next stages\r\n            for (int k = 1; k < stages; ++k) {\r\n                for (int j = 0; j < y0.length; ++j) {\r\n                    double sum = a[k - 1][0] * yDotK[0][j];\r\n                    for (int l = 1; l < k; ++l) {\r\n                        sum += a[k - 1][l] * yDotK[l][j];\r\n                    }\r\n                    yTmp[j] = y[j] + stepSize * sum;\r\n                }\r\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\r\n            }\r\n            \/\/ estimate the state at the end of the step\r\n            for (int j = 0; j < y0.length; ++j) {\r\n                double sum = b[0] * yDotK[0][j];\r\n                for (int l = 1; l < stages; ++l) {\r\n                    sum += b[l] * yDotK[l][j];\r\n                }\r\n                yTmp[j] = y[j] + stepSize * sum;\r\n            }\r\n            \/\/ estimate the error at the end of the step\r\n            error = estimateError(yDotK, y, yTmp, stepSize);\r\n            if (error >= 1.0) {\r\n                \/\/ reject the step and attempt to reduce error by stepsize control\r\n                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\r\n                hNew = filterStep(stepSize * factor, forward, false);\r\n            }\r\n        }\r\n        \/\/ local error is small enough: accept the step, trigger events and step handlers\r\n        interpolator.storeTime(stepStart + stepSize);\r\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\r\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\r\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\r\n        if (!isLastStep) {\r\n            \/\/ prepare next step\r\n            interpolator.storeTime(stepStart);\r\n            if (fsal) {\r\n                \/\/ save the last evaluation for the next step\r\n                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\r\n            }\r\n            \/\/ stepsize control for next step\r\n            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\r\n            final double scaledH = stepSize * factor;\r\n            final double nextT = stepStart + scaledH;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            hNew = filterStep(scaledH, forward, nextIsLast);\r\n            final double filteredNextT = stepStart + hNew;\r\n            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\r\n            if (filteredNextIsLast) {\r\n                hNew = t - stepStart;\r\n            }\r\n        }\r\n    } while (!isLastStep);\r\n    \/\/ dispatch results\r\n    equations.setTime(stepStart);\r\n    equations.setCompleteState(y);\r\n    resetInternalState();\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws MathIllegalStateException, MathIllegalArgumentException {\r\n    sanityChecks(equations, t);\r\n    setEquations(equations);\r\n    resetEvaluations();\r\n    final boolean forward = t > equations.getTime();\r\n        final double[] y0 = equations.getCompleteState();\r\n    final double[] y = y0.clone();\r\n    final int stages = c.length + 1;\r\n    final double[][] yDotK = new double[stages][y.length];\r\n    final double[] yTmp = new double[y.length];\r\n    final double[] yDotTmp = new double[y.length];\r\n        final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\r\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\r\n    interpolator.storeTime(equations.getTime());\r\n        stepStart = equations.getTime();\r\n    double hNew = 0;\r\n    boolean firstTime = true;\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.reset();\r\n    }\r\n    setStateInitialized(false);\r\n        isLastStep = false;\r\n    do {\r\n        interpolator.shift();\r\n                double error = 10;\r\n        while (error >= 1.0) {\r\n            if (firstTime || !fsal) {\r\n                                computeDerivatives(stepStart, y, yDotK[0]);\r\n            }\r\n            if (firstTime) {\r\n                final double[] scale = new double[mainSetDimension];\r\n                if (vecAbsoluteTolerance == null) {\r\n                    for (int i = 0; i < scale.length; ++i) {\r\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\r\n                    }\r\n                } else {\r\n                    for (int i = 0; i < scale.length; ++i) {\r\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\r\n                    }\r\n                }\r\n                hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\r\n                firstTime = false;\r\n            }\r\n            stepSize = hNew;\r\n                        for (int k = 1; k < stages; ++k) {\r\n                for (int j = 0; j < y0.length; ++j) {\r\n                    double sum = a[k - 1][0] * yDotK[0][j];\r\n                    for (int l = 1; l < k; ++l) {\r\n                        sum += a[k - 1][l] * yDotK[l][j];\r\n                    }\r\n                    yTmp[j] = y[j] + stepSize * sum;\r\n                }\r\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\r\n            }\r\n                        for (int j = 0; j < y0.length; ++j) {\r\n                double sum = b[0] * yDotK[0][j];\r\n                for (int l = 1; l < stages; ++l) {\r\n                    sum += b[l] * yDotK[l][j];\r\n                }\r\n                yTmp[j] = y[j] + stepSize * sum;\r\n            }\r\n                        error = estimateError(yDotK, y, yTmp, stepSize);\r\n            if (error >= 1.0) {\r\n                                final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\r\n                hNew = filterStep(stepSize * factor, forward, false);\r\n            }\r\n        }\r\n                interpolator.storeTime(stepStart + stepSize);\r\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\r\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\r\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\r\n        if (!isLastStep) {\r\n                        interpolator.storeTime(stepStart);\r\n            if (fsal) {\r\n                                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\r\n            }\r\n                        final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\r\n            final double scaledH = stepSize * factor;\r\n            final double nextT = stepStart + scaledH;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            hNew = filterStep(scaledH, forward, nextIsLast);\r\n            final double filteredNextT = stepStart + hNew;\r\n            final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\r\n            if (filteredNextIsLast) {\r\n                hNew = t - stepStart;\r\n            }\r\n        }\r\n    } while (!isLastStep);\r\n        equations.setTime(stepStart);\r\n    equations.setCompleteState(y);\r\n    resetInternalState();\r\n}","lc":3.5909090909,"pi":1.4593301435,"ma":3.2,"nbd":1.5,"ml":2.3333333333,"d":4.0,"mi":-1.3881606765,"fo":2.8333333333,"r":-0.0263157895,"e":28.7961296197}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"@Override\r\npublic String getPath() {\r\n    if (parent == null) {\r\n        return name;\r\n    } else {\r\n        String path = parent.getPath();\r\n        return path.isEmpty() ? name : path + '\/' + name;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String getPath() {\r\n    if (parent == null) {\r\n        return name;\r\n    } else {\r\n        String path = parent.getPath();\r\n        return path.isEmpty() ? name : path + '\/' + name;\r\n    }\r\n}","lc":-0.2272727273,"pi":0.1339712919,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0277777778,"mi":0.3237491191,"fo":-0.3333333333,"r":1.9473684211,"e":-0.1047907194}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5209_ed651a4d","label":3,"code":"public List<String> getSystemClasspathElements() throws DependencyResolutionRequiredException {\r\n    List<String> list = new ArrayList<String>(getArtifacts().size());\r\n    list.add(getBuild().getOutputDirectory());\r\n    for (Artifact a : getArtifacts()) {\r\n        if (a.getArtifactHandler().isAddedToClasspath()) {\r\n            \/\/ TODO: let the scope handler deal with this\r\n            if (Artifact.SCOPE_SYSTEM.equals(a.getScope())) {\r\n                addArtifactPath(a, list);\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}","code_comment":null,"code_no_comment":"public List<String> getSystemClasspathElements() throws DependencyResolutionRequiredException {\r\n    List<String> list = new ArrayList<String>(getArtifacts().size());\r\n    list.add(getBuild().getOutputDirectory());\r\n    for (Artifact a : getArtifacts()) {\r\n        if (a.getArtifactHandler().isAddedToClasspath()) {\r\n                        if (Artifact.SCOPE_SYSTEM.equals(a.getScope())) {\r\n                addArtifactPath(a, list);\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}","lc":-0.0909090909,"pi":0.8421052632,"ma":0.0,"nbd":0.5,"ml":0.0,"d":-0.3650793651,"mi":0.0920366455,"fo":0.4166666667,"r":0.0526315789,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1899_df59fb45","label":1,"code":"\/**\r\n * set the value of the :next at the given position. If the property :next won't be there by the\r\n * time this method is invoked it won't perform any action\r\n *\r\n * @param node\r\n * @param value\r\n * @param lane\r\n *\/\r\nstatic void setPropertyNext(@Nonnull final NodeBuilder node, final String value, final int lane) {\r\n    if (node != null && value != null && lane >= 0 && lane < OrderedIndex.LANES) {\r\n        PropertyState next = node.getProperty(NEXT);\r\n        if (next != null) {\r\n            String[] values = Iterables.toArray(next.getValue(Type.STRINGS), String.class);\r\n            values[lane] = value;\r\n            setPropertyNext(node, values);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * set the value of the :next at the given position. If the property :next won't be there by the\r\n * time this method is invoked it won't perform any action\r\n *\r\n * @param node\r\n * @param value\r\n * @param lane\r\n *\/\r\n","code_no_comment":"static void setPropertyNext(@Nonnull final NodeBuilder node, final String value, final int lane) {\r\n    if (node != null && value != null && lane >= 0 && lane < OrderedIndex.LANES) {\r\n        PropertyState next = node.getProperty(NEXT);\r\n        if (next != null) {\r\n            String[] values = Iterables.toArray(next.getValue(Type.STRINGS), String.class);\r\n            values[lane] = value;\r\n            setPropertyNext(node, values);\r\n        }\r\n    }\r\n}","lc":-0.1818181818,"pi":0.6746411483,"ma":-0.2,"nbd":0.0,"ml":0.3333333333,"d":0.3392857143,"mi":0.104721635,"fo":-0.1666666667,"r":0.9210526316,"e":0.2258167505}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-880_2a9cbbab","label":1,"code":"\/**\r\n * Check incoming edge processed indicator.\r\n * @return true if incoming edge needs processing\r\n *\/\r\npublic boolean incomingNeedsProcessing() {\r\n    return incomingNeedsProcessing;\r\n}","code_comment":"\/**\r\n * Check incoming edge processed indicator.\r\n * @return true if incoming edge needs processing\r\n *\/\r\n","code_no_comment":"public boolean incomingNeedsProcessing() {\r\n    return incomingNeedsProcessing;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.3083861875,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public void write(org.apache.thrift.protocol.TProtocol oprot, removeConstraint_result struct) throws org.apache.thrift.TException {\r\n    struct.validate();\r\n    oprot.writeStructBegin(STRUCT_DESC);\r\n    if (struct.ouch1 != null) {\r\n        oprot.writeFieldBegin(OUCH1_FIELD_DESC);\r\n        struct.ouch1.write(oprot);\r\n        oprot.writeFieldEnd();\r\n    }\r\n    if (struct.ouch2 != null) {\r\n        oprot.writeFieldBegin(OUCH2_FIELD_DESC);\r\n        struct.ouch2.write(oprot);\r\n        oprot.writeFieldEnd();\r\n    }\r\n    oprot.writeFieldStop();\r\n    oprot.writeStructEnd();\r\n}","code_comment":null,"code_no_comment":"public void write(org.apache.thrift.protocol.TProtocol oprot, removeConstraint_result struct) throws org.apache.thrift.TException {\r\n    struct.validate();\r\n    oprot.writeStructBegin(STRUCT_DESC);\r\n    if (struct.ouch1 != null) {\r\n        oprot.writeFieldBegin(OUCH1_FIELD_DESC);\r\n        struct.ouch1.write(oprot);\r\n        oprot.writeFieldEnd();\r\n    }\r\n    if (struct.ouch2 != null) {\r\n        oprot.writeFieldBegin(OUCH2_FIELD_DESC);\r\n        struct.ouch2.write(oprot);\r\n        oprot.writeFieldEnd();\r\n    }\r\n    oprot.writeFieldStop();\r\n    oprot.writeStructEnd();\r\n}","lc":0.0909090909,"pi":-0.1626794258,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":-0.1016208598,"fo":0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-276_1bf5c550","label":1,"code":"public Id writeCNEMap(ChildNodeEntries map) throws Exception {\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    map.serialize(new BinaryBinding(out));\r\n    byte[] bytes = out.toByteArray();\r\n    byte[] rawId = idFactory.createContentId(bytes);\r\n    Timestamp ts = new Timestamp(System.currentTimeMillis());\r\n    Connection con = cp.getConnection();\r\n    try {\r\n        PreparedStatement stmt = con.prepareStatement(\"insert into REVS (ID, DATA, TIME) select ?, ?, ? where not exists (select 1 from REVS where ID = ?)\");\r\n        try {\r\n            stmt.setBytes(1, rawId);\r\n            stmt.setBytes(2, bytes);\r\n            stmt.setTimestamp(3, ts);\r\n            stmt.setBytes(4, rawId);\r\n            stmt.executeUpdate();\r\n        } finally {\r\n            stmt.close();\r\n        }\r\n    } finally {\r\n        con.close();\r\n    }\r\n    return new Id(rawId);\r\n}","code_comment":null,"code_no_comment":"public Id writeCNEMap(ChildNodeEntries map) throws Exception {\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    map.serialize(new BinaryBinding(out));\r\n    byte[] bytes = out.toByteArray();\r\n    byte[] rawId = idFactory.createContentId(bytes);\r\n    Timestamp ts = new Timestamp(System.currentTimeMillis());\r\n    Connection con = cp.getConnection();\r\n    try {\r\n        PreparedStatement stmt = con.prepareStatement(\"insert into REVS (ID, DATA, TIME) select ?, ?, ? where not exists (select 1 from REVS where ID = ?)\");\r\n        try {\r\n            stmt.setBytes(1, rawId);\r\n            stmt.setBytes(2, bytes);\r\n            stmt.setTimestamp(3, ts);\r\n            stmt.setBytes(4, rawId);\r\n            stmt.executeUpdate();\r\n        } finally {\r\n            stmt.close();\r\n        }\r\n    } finally {\r\n        con.close();\r\n    }\r\n    return new Id(rawId);\r\n}","lc":0.4090909091,"pi":0.4066985646,"ma":-0.6,"nbd":0.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.3110641297,"fo":0.5833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-855_350f726c","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected UnivariatePointValuePair doOptimize() {\r\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\r\n    final double lo = getMin();\r\n    final double mid = getStartValue();\r\n    final double hi = getMax();\r\n    \/\/ Optional additional convergence criteria.\r\n    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\r\n    double a;\r\n    double b;\r\n    if (lo < hi) {\r\n        a = lo;\r\n        b = hi;\r\n    } else {\r\n        a = hi;\r\n        b = lo;\r\n    }\r\n    double x = mid;\r\n    double v = x;\r\n    double w = x;\r\n    double d = 0;\r\n    double e = 0;\r\n    double fx = computeObjectiveValue(x);\r\n    if (!isMinim) {\r\n        fx = -fx;\r\n    }\r\n    double fv = fx;\r\n    double fw = fx;\r\n    UnivariatePointValuePair previous = null;\r\n    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\r\n    int iter = 0;\r\n    while (true) {\r\n        final double m = 0.5 * (a + b);\r\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\r\n        final double tol2 = 2 * tol1;\r\n        \/\/ Default stopping criterion.\r\n        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\r\n        if (!stop) {\r\n            double p = 0;\r\n            double q = 0;\r\n            double r = 0;\r\n            double u = 0;\r\n            if (FastMath.abs(e) > tol1) {\r\n                \/\/ Fit parabola.\r\n                r = (x - w) * (fx - fv);\r\n                q = (x - v) * (fx - fw);\r\n                p = (x - v) * q - (x - w) * r;\r\n                q = 2 * (q - r);\r\n                if (q > 0) {\r\n                    p = -p;\r\n                } else {\r\n                    q = -q;\r\n                }\r\n                r = e;\r\n                e = d;\r\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\r\n                    \/\/ Parabolic interpolation step.\r\n                    d = p \/ q;\r\n                    u = x + d;\r\n                    \/\/ f must not be evaluated too close to a or b.\r\n                    if (u - a < tol2 || b - u < tol2) {\r\n                        if (x <= m) {\r\n                            d = tol1;\r\n                        } else {\r\n                            d = -tol1;\r\n                        }\r\n                    }\r\n                } else {\r\n                    \/\/ Golden section step.\r\n                    if (x < m) {\r\n                        e = b - x;\r\n                    } else {\r\n                        e = a - x;\r\n                    }\r\n                    d = GOLDEN_SECTION * e;\r\n                }\r\n            } else {\r\n                \/\/ Golden section step.\r\n                if (x < m) {\r\n                    e = b - x;\r\n                } else {\r\n                    e = a - x;\r\n                }\r\n                d = GOLDEN_SECTION * e;\r\n            }\r\n            \/\/ Update by at least \"tol1\".\r\n            if (FastMath.abs(d) < tol1) {\r\n                if (d >= 0) {\r\n                    u = x + tol1;\r\n                } else {\r\n                    u = x - tol1;\r\n                }\r\n            } else {\r\n                u = x + d;\r\n            }\r\n            double fu = computeObjectiveValue(u);\r\n            if (!isMinim) {\r\n                fu = -fu;\r\n            }\r\n            \/\/ User-defined convergence checker.\r\n            previous = current;\r\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\r\n            if (checker != null) {\r\n                if (checker.converged(iter, previous, current)) {\r\n                    return current;\r\n                }\r\n            }\r\n            \/\/ Update a, b, v, w and x.\r\n            if (fu <= fx) {\r\n                if (u < x) {\r\n                    b = x;\r\n                } else {\r\n                    a = x;\r\n                }\r\n                v = w;\r\n                fv = fw;\r\n                w = x;\r\n                fw = fx;\r\n                x = u;\r\n                fx = fu;\r\n            } else {\r\n                if (u < x) {\r\n                    a = u;\r\n                } else {\r\n                    b = u;\r\n                }\r\n                if (fu <= fw || Precision.equals(w, x)) {\r\n                    v = w;\r\n                    fv = fw;\r\n                    w = u;\r\n                    fw = fu;\r\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\r\n                    v = u;\r\n                    fv = fu;\r\n                }\r\n            }\r\n        } else {\r\n            \/\/ Default termination (Brent's criterion).\r\n            return current;\r\n        }\r\n        ++iter;\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected UnivariatePointValuePair doOptimize() {\r\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\r\n    final double lo = getMin();\r\n    final double mid = getStartValue();\r\n    final double hi = getMax();\r\n        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\r\n    double a;\r\n    double b;\r\n    if (lo < hi) {\r\n        a = lo;\r\n        b = hi;\r\n    } else {\r\n        a = hi;\r\n        b = lo;\r\n    }\r\n    double x = mid;\r\n    double v = x;\r\n    double w = x;\r\n    double d = 0;\r\n    double e = 0;\r\n    double fx = computeObjectiveValue(x);\r\n    if (!isMinim) {\r\n        fx = -fx;\r\n    }\r\n    double fv = fx;\r\n    double fw = fx;\r\n    UnivariatePointValuePair previous = null;\r\n    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\r\n    int iter = 0;\r\n    while (true) {\r\n        final double m = 0.5 * (a + b);\r\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\r\n        final double tol2 = 2 * tol1;\r\n                final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\r\n        if (!stop) {\r\n            double p = 0;\r\n            double q = 0;\r\n            double r = 0;\r\n            double u = 0;\r\n            if (FastMath.abs(e) > tol1) {\r\n                                r = (x - w) * (fx - fv);\r\n                q = (x - v) * (fx - fw);\r\n                p = (x - v) * q - (x - w) * r;\r\n                q = 2 * (q - r);\r\n                if (q > 0) {\r\n                    p = -p;\r\n                } else {\r\n                    q = -q;\r\n                }\r\n                r = e;\r\n                e = d;\r\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\r\n                                        d = p \/ q;\r\n                    u = x + d;\r\n                                        if (u - a < tol2 || b - u < tol2) {\r\n                        if (x <= m) {\r\n                            d = tol1;\r\n                        } else {\r\n                            d = -tol1;\r\n                        }\r\n                    }\r\n                } else {\r\n                                        if (x < m) {\r\n                        e = b - x;\r\n                    } else {\r\n                        e = a - x;\r\n                    }\r\n                    d = GOLDEN_SECTION * e;\r\n                }\r\n            } else {\r\n                                if (x < m) {\r\n                    e = b - x;\r\n                } else {\r\n                    e = a - x;\r\n                }\r\n                d = GOLDEN_SECTION * e;\r\n            }\r\n                        if (FastMath.abs(d) < tol1) {\r\n                if (d >= 0) {\r\n                    u = x + tol1;\r\n                } else {\r\n                    u = x - tol1;\r\n                }\r\n            } else {\r\n                u = x + d;\r\n            }\r\n            double fu = computeObjectiveValue(u);\r\n            if (!isMinim) {\r\n                fu = -fu;\r\n            }\r\n                        previous = current;\r\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\r\n            if (checker != null) {\r\n                if (checker.converged(iter, previous, current)) {\r\n                    return current;\r\n                }\r\n            }\r\n                        if (fu <= fx) {\r\n                if (u < x) {\r\n                    b = x;\r\n                } else {\r\n                    a = x;\r\n                }\r\n                v = w;\r\n                fv = fw;\r\n                w = x;\r\n                fw = fx;\r\n                x = u;\r\n                fx = fu;\r\n            } else {\r\n                if (u < x) {\r\n                    a = u;\r\n                } else {\r\n                    b = u;\r\n                }\r\n                if (fu <= fw || Precision.equals(w, x)) {\r\n                    v = w;\r\n                    fv = fw;\r\n                    w = u;\r\n                    fw = fu;\r\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\r\n                    v = u;\r\n                    fv = fu;\r\n                }\r\n            }\r\n        } else {\r\n                        return current;\r\n        }\r\n        ++iter;\r\n    }\r\n}","lc":5.3636363636,"pi":1.6555023923,"ma":4.0,"nbd":2.0,"ml":4.8333333333,"d":6.9206349206,"mi":-1.5601127555,"fo":0.9166666667,"r":-0.0263157895,"e":43.7353180846}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-934_724795b5","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic Complex reciprocal() {\r\n    if (isNaN) {\r\n        return NaN;\r\n    }\r\n    if (real == 0.0 && imaginary == 0.0) {\r\n        return NaN;\r\n    }\r\n    if (isInfinite) {\r\n        return ZERO;\r\n    }\r\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\r\n        double q = real \/ imaginary;\r\n        double scale = 1. \/ (real * q + imaginary);\r\n        return createComplex(scale * q, -scale);\r\n    } else {\r\n        double q = imaginary \/ real;\r\n        double scale = 1. \/ (imaginary * q + real);\r\n        return createComplex(scale, -scale * q);\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public Complex reciprocal() {\r\n    if (isNaN) {\r\n        return NaN;\r\n    }\r\n    if (real == 0.0 && imaginary == 0.0) {\r\n        return NaN;\r\n    }\r\n    if (isInfinite) {\r\n        return ZERO;\r\n    }\r\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\r\n        double q = real \/ imaginary;\r\n        double scale = 1. \/ (real * q + imaginary);\r\n        return createComplex(scale * q, -scale);\r\n    } else {\r\n        double q = imaginary \/ real;\r\n        double scale = 1. \/ (imaginary * q + real);\r\n        return createComplex(scale, -scale * q);\r\n    }\r\n}","lc":0.2727272727,"pi":-0.1770334928,"ma":0.2,"nbd":-0.5,"ml":0.5,"d":1.7182539683,"mi":-0.2510218464,"fo":-0.1666666667,"r":0.4473684211,"e":1.2133054408}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2437_a41bc8cc","label":3,"code":"@SuppressWarnings(\"unchecked\")\r\nprotected <OUT, IN1, IN2> TypeInformation<OUT> analyzePojo(Class<OUT> clazz, ArrayList<Type> typeHierarchy, ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\r\n    \/\/ add the hierarchy of the POJO itself if it is generic\r\n    if (parameterizedType != null) {\r\n        getTypeHierarchy(typeHierarchy, parameterizedType, Object.class);\r\n    } else \/\/ create a type hierarchy, if the incoming only contains the most bottom one or none.\r\n    if (typeHierarchy.size() <= 1) {\r\n        getTypeHierarchy(typeHierarchy, clazz, Object.class);\r\n    }\r\n    List<Field> fields = getAllDeclaredFields(clazz);\r\n    if (fields.size() == 0) {\r\n        LOG.info(\"No fields detected for class \" + clazz + \". Cannot be used as a PojoType. Will be handled as GenericType\");\r\n        return new GenericTypeInfo<OUT>(clazz);\r\n    }\r\n    List<PojoField> pojoFields = new ArrayList<PojoField>();\r\n    for (Field field : fields) {\r\n        Type fieldType = field.getGenericType();\r\n        if (!isValidPojoField(field, clazz, typeHierarchy)) {\r\n            LOG.info(\"Class \" + clazz + \" is not a valid POJO type\");\r\n            return null;\r\n        }\r\n        try {\r\n            ArrayList<Type> fieldTypeHierarchy = new ArrayList<Type>(typeHierarchy);\r\n            fieldTypeHierarchy.add(fieldType);\r\n            TypeInformation<?> ti = createTypeInfoWithTypeHierarchy(fieldTypeHierarchy, fieldType, in1Type, in2Type);\r\n            pojoFields.add(new PojoField(field, ti));\r\n        } catch (InvalidTypesException e) {\r\n            Class<?> genericClass = Object.class;\r\n            if (isClassType(fieldType)) {\r\n                genericClass = typeToClass(fieldType);\r\n            }\r\n            pojoFields.add(new PojoField(field, new GenericTypeInfo<OUT>((Class<OUT>) genericClass)));\r\n        }\r\n    }\r\n    CompositeType<OUT> pojoType = new PojoTypeInfo<OUT>(clazz, pojoFields);\r\n    \/\/ \r\n    \/\/ Validate the correctness of the pojo.\r\n    \/\/ returning \"null\" will result create a generic type information.\r\n    \/\/ \r\n    List<Method> methods = getAllDeclaredMethods(clazz);\r\n    for (Method method : methods) {\r\n        if (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\r\n            LOG.info(\"Class \" + clazz + \" contains custom serialization methods we do not call.\");\r\n            return null;\r\n        }\r\n    }\r\n    \/\/ we cannot use this because the serializer uses it.\r\n    try {\r\n        clazz.getDeclaredConstructor();\r\n    } catch (NoSuchMethodException e) {\r\n        if (clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers())) {\r\n            LOG.info(\"Class \" + clazz + \" is abstract or an interface, having a concrete \" + \"type can increase performance.\");\r\n        } else {\r\n            LOG.info(\"Class \" + clazz + \" must have a default constructor to be used as a POJO.\");\r\n            return null;\r\n        }\r\n    }\r\n    \/\/ everything is checked, we return the pojo\r\n    return pojoType;\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings(\"unchecked\")\r\nprotected <OUT, IN1, IN2> TypeInformation<OUT> analyzePojo(Class<OUT> clazz, ArrayList<Type> typeHierarchy, ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\r\n        if (parameterizedType != null) {\r\n        getTypeHierarchy(typeHierarchy, parameterizedType, Object.class);\r\n    } else     if (typeHierarchy.size() <= 1) {\r\n        getTypeHierarchy(typeHierarchy, clazz, Object.class);\r\n    }\r\n    List<Field> fields = getAllDeclaredFields(clazz);\r\n    if (fields.size() == 0) {\r\n        LOG.info(\"No fields detected for class \" + clazz + \". Cannot be used as a PojoType. Will be handled as GenericType\");\r\n        return new GenericTypeInfo<OUT>(clazz);\r\n    }\r\n    List<PojoField> pojoFields = new ArrayList<PojoField>();\r\n    for (Field field : fields) {\r\n        Type fieldType = field.getGenericType();\r\n        if (!isValidPojoField(field, clazz, typeHierarchy)) {\r\n            LOG.info(\"Class \" + clazz + \" is not a valid POJO type\");\r\n            return null;\r\n        }\r\n        try {\r\n            ArrayList<Type> fieldTypeHierarchy = new ArrayList<Type>(typeHierarchy);\r\n            fieldTypeHierarchy.add(fieldType);\r\n            TypeInformation<?> ti = createTypeInfoWithTypeHierarchy(fieldTypeHierarchy, fieldType, in1Type, in2Type);\r\n            pojoFields.add(new PojoField(field, ti));\r\n        } catch (InvalidTypesException e) {\r\n            Class<?> genericClass = Object.class;\r\n            if (isClassType(fieldType)) {\r\n                genericClass = typeToClass(fieldType);\r\n            }\r\n            pojoFields.add(new PojoField(field, new GenericTypeInfo<OUT>((Class<OUT>) genericClass)));\r\n        }\r\n    }\r\n    CompositeType<OUT> pojoType = new PojoTypeInfo<OUT>(clazz, pojoFields);\r\n                    List<Method> methods = getAllDeclaredMethods(clazz);\r\n    for (Method method : methods) {\r\n        if (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\r\n            LOG.info(\"Class \" + clazz + \" contains custom serialization methods we do not call.\");\r\n            return null;\r\n        }\r\n    }\r\n        try {\r\n        clazz.getDeclaredConstructor();\r\n    } catch (NoSuchMethodException e) {\r\n        if (clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers())) {\r\n            LOG.info(\"Class \" + clazz + \" is abstract or an interface, having a concrete \" + \"type can increase performance.\");\r\n        } else {\r\n            LOG.info(\"Class \" + clazz + \" must have a default constructor to be used as a POJO.\");\r\n            return null;\r\n        }\r\n    }\r\n        return pojoType;\r\n}","lc":1.7727272727,"pi":0.3923444976,"ma":1.6,"nbd":0.5,"ml":1.5,"d":1.0456349206,"mi":-0.9484143763,"fo":1.75,"r":-0.0263157895,"e":3.6603631795}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3123_f3c9c818","label":1,"code":"\/**\r\n * Retrieve the value at a given index. Keys are ordered according\r\n * the natural ordering of shorts.\r\n * @param index\r\n * @return the value at {@code index}\r\n *\/\r\n@Nonnull\r\npublic RecordId getRecordId(int index) {\r\n    return values[index];\r\n}","code_comment":"\/**\r\n * Retrieve the value at a given index. Keys are ordered according\r\n * the natural ordering of shorts.\r\n * @param index\r\n * @return the value at {@code index}\r\n *\/\r\n","code_no_comment":"@Nonnull\r\npublic RecordId getRecordId(int index) {\r\n    return values[index];\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9134601832,"fo":-0.5,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1230_96eb80ef","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\r\n * @param optData Optimization data. In addition to those documented in\r\n * {@link LinearOptimizer#optimize(OptimizationData...)\r\n * LinearOptimizer}, this method will register the following data:\r\n * <ul>\r\n *  <li>{@link SolutionCallback}<\/li>\r\n *  <li>{@link PivotSelectionRule}<\/li>\r\n * <\/ul>\r\n *\r\n * @return {@inheritDoc}\r\n * @throws TooManyIterationsException if the maximal number of iterations is exceeded.\r\n *\/\r\n@Override\r\npublic PointValuePair optimize(OptimizationData... optData) throws TooManyIterationsException {\r\n    \/\/ Set up base class and perform computation.\r\n    return super.optimize(optData);\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\r\n * @param optData Optimization data. In addition to those documented in\r\n * {@link LinearOptimizer#optimize(OptimizationData...)\r\n * LinearOptimizer}, this method will register the following data:\r\n * <ul>\r\n *  <li>{@link SolutionCallback}<\/li>\r\n *  <li>{@link PivotSelectionRule}<\/li>\r\n * <\/ul>\r\n *\r\n * @return {@inheritDoc}\r\n * @throws TooManyIterationsException if the maximal number of iterations is exceeded.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic PointValuePair optimize(OptimizationData... optData) throws TooManyIterationsException {\r\n        return super.optimize(optData);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8646934461,"fo":-0.4166666667,"r":2.4473684211,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5187_8cadc344","label":3,"code":"public void unregister(ObjectName name) throws JMException {\r\n    if (server.isRegistered(name)) {\r\n        server.unregisterMBean(name);\r\n        LOG.debug(\"Unregistered MBean with ObjectName: {}\", name);\r\n    }\r\n    mbeansRegistered.remove(name);\r\n}","code_comment":null,"code_no_comment":"public void unregister(ObjectName name) throws JMException {\r\n    if (server.isRegistered(name)) {\r\n        server.unregisterMBean(name);\r\n        LOG.debug(\"Unregistered MBean with ObjectName: {}\", name);\r\n    }\r\n    mbeansRegistered.remove(name);\r\n}","lc":-0.3181818182,"pi":0.014354067,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.4604651163,"fo":-0.1666666667,"r":0.0526315789,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2864_f51ea2a2","label":1,"code":"private Expression parseExpression() throws ParseException {\r\n    if (readIf(\"@\")) {\r\n        return readProperty();\r\n    } else if (readIf(\"true\")) {\r\n        return Expression.Literal.newBoolean(true);\r\n    } else if (readIf(\"false\")) {\r\n        return Expression.Literal.newBoolean(false);\r\n    } else if (currentTokenType == VALUE_NUMBER) {\r\n        Expression.Literal l = Expression.Literal.newNumber(currentToken);\r\n        read();\r\n        return l;\r\n    } else if (currentTokenType == VALUE_STRING) {\r\n        Expression.Literal l = Expression.Literal.newString(currentToken);\r\n        read();\r\n        return l;\r\n    } else if (readIf(\"-\")) {\r\n        if (currentTokenType != VALUE_NUMBER) {\r\n            throw getSyntaxError();\r\n        }\r\n        Expression.Literal l = Expression.Literal.newNumber('-' + currentToken);\r\n        read();\r\n        return l;\r\n    } else if (readIf(\"+\")) {\r\n        if (currentTokenType != VALUE_NUMBER) {\r\n            throw getSyntaxError();\r\n        }\r\n        return parseExpression();\r\n    } else {\r\n        return parsePropertyOrFunction();\r\n    }\r\n}","code_comment":null,"code_no_comment":"private Expression parseExpression() throws ParseException {\r\n    if (readIf(\"@\")) {\r\n        return readProperty();\r\n    } else if (readIf(\"true\")) {\r\n        return Expression.Literal.newBoolean(true);\r\n    } else if (readIf(\"false\")) {\r\n        return Expression.Literal.newBoolean(false);\r\n    } else if (currentTokenType == VALUE_NUMBER) {\r\n        Expression.Literal l = Expression.Literal.newNumber(currentToken);\r\n        read();\r\n        return l;\r\n    } else if (currentTokenType == VALUE_STRING) {\r\n        Expression.Literal l = Expression.Literal.newString(currentToken);\r\n        read();\r\n        return l;\r\n    } else if (readIf(\"-\")) {\r\n        if (currentTokenType != VALUE_NUMBER) {\r\n            throw getSyntaxError();\r\n        }\r\n        Expression.Literal l = Expression.Literal.newNumber('-' + currentToken);\r\n        read();\r\n        return l;\r\n    } else if (readIf(\"+\")) {\r\n        if (currentTokenType != VALUE_NUMBER) {\r\n            throw getSyntaxError();\r\n        }\r\n        return parseExpression();\r\n    } else {\r\n        return parsePropertyOrFunction();\r\n    }\r\n}","lc":0.7727272727,"pi":-0.0956937799,"ma":1.6,"nbd":3.0,"ml":0.8333333333,"d":0.7222222222,"mi":-0.5216349542,"fo":1.0,"r":-0.0263157895,"e":0.6898612864}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4038_557eec4f","label":1,"code":"\/**\r\n * Get the selector associated with this filter.\r\n *\r\n * @return selector\r\n *\/\r\nSelectorImpl getSelector();","code_comment":"\/**\r\n * Get the selector associated with this filter.\r\n *\r\n * @return selector\r\n *\/\r\n","code_no_comment":"SelectorImpl getSelector();","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.7424947146,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-498_f2a2edec","label":1,"code":"@Override\r\npublic boolean parent() {\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean parent() {\r\n    return true;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0332628612,"fo":-0.5,"r":2.3421052632,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-428_d906576c","label":3,"code":"public Object next() {\r\n    index++;\r\n    return key;\r\n}","code_comment":null,"code_no_comment":"public Object next() {\r\n    index++;\r\n    return key;\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9362931642,"fo":-0.5,"r":2.5,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1531_21f47d9c","label":3,"code":"\/**\r\n *  Require makes sure that at least required number of bytes are kept in the buffer. If not, then\r\n *  it will load exactly the difference between required and currently available number of bytes.\r\n *  Thus, it will only load the data which is required and never prefetch data.\r\n *\r\n *  @param required the number of bytes being available in the buffer\r\n *  @return the number of bytes remaining, which is equal to required\r\n *  @throws KryoException\r\n *\/\r\n@Override\r\nprotected int require(int required) throws KryoException {\r\n    if (required > capacity) {\r\n        throw new KryoException(\"Buffer too small: capacity: \" + capacity + \", \" + \"required: \" + required);\r\n    }\r\n    position = 0;\r\n    int bytesRead = 0;\r\n    int count;\r\n    while (true) {\r\n        count = fill(buffer, bytesRead, required - bytesRead);\r\n        if (count == -1) {\r\n            throw new KryoException(\"Buffer underflow\");\r\n        }\r\n        bytesRead += count;\r\n        if (bytesRead == required) {\r\n            break;\r\n        }\r\n    }\r\n    limit = required;\r\n    return required;\r\n}","code_comment":"\/**\r\n *  Require makes sure that at least required number of bytes are kept in the buffer. If not, then\r\n *  it will load exactly the difference between required and currently available number of bytes.\r\n *  Thus, it will only load the data which is required and never prefetch data.\r\n *\r\n *  @param required the number of bytes being available in the buffer\r\n *  @return the number of bytes remaining, which is equal to required\r\n *  @throws KryoException\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected int require(int required) throws KryoException {\r\n    if (required > capacity) {\r\n        throw new KryoException(\"Buffer too small: capacity: \" + capacity + \", \" + \"required: \" + required);\r\n    }\r\n    position = 0;\r\n    int bytesRead = 0;\r\n    int count;\r\n    while (true) {\r\n        count = fill(buffer, bytesRead, required - bytesRead);\r\n        if (count == -1) {\r\n            throw new KryoException(\"Buffer underflow\");\r\n        }\r\n        bytesRead += count;\r\n        if (bytesRead == required) {\r\n            break;\r\n        }\r\n    }\r\n    limit = required;\r\n    return required;\r\n}","lc":0.3181818182,"pi":0.1866028708,"ma":0.8,"nbd":0.0,"ml":0.25,"d":0.7619047619,"mi":-0.2541226216,"fo":-0.4166666667,"r":-0.0263157895,"e":0.409183797}
{"project_name":"Math","project_version":"49","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic OpenMapRealVector ebeDivide(double[] v) {\r\n    checkVectorDimensions(v.length);\r\n    OpenMapRealVector res = new OpenMapRealVector(this);\r\n    Iterator iter = res.entries.iterator();\r\n    while (iter.hasNext()) {\r\n        iter.advance();\r\n        res.setEntry(iter.key(), iter.value() \/ v[iter.key()]);\r\n    }\r\n    return res;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic OpenMapRealVector ebeDivide(double[] v) {\r\n    checkVectorDimensions(v.length);\r\n    OpenMapRealVector res = new OpenMapRealVector(this);\r\n    Iterator iter = res.entries.iterator();\r\n    while (iter.hasNext()) {\r\n        iter.advance();\r\n        res.setEntry(iter.key(), iter.value() \/ v[iter.key()]);\r\n    }\r\n    return res;\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0158730159,"mi":0.1450317125,"fo":0.1666666667,"r":0.1578947368,"e":-0.048742818}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1178_f2bb1a17","label":1,"code":"@Override\r\npublic boolean isNew() {\r\n    return exists() && !base.exists();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean isNew() {\r\n    return exists() && !base.exists();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.126984127,"mi":0.881888654,"fo":-0.3333333333,"r":2.0789473684,"e":-0.150368539}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-612_df9e6913","label":1,"code":"@Override\r\npublic Node perform() throws RepositoryException {\r\n    String oakPath = sessionDelegate.getOakPathKeepIndexOrThrowNotFound(relPath);\r\n    String oakName = PathUtils.getName(oakPath);\r\n    String parentPath = sessionDelegate.getOakPath(PathUtils.getParentPath(oakPath));\r\n    \/\/ handle index\r\n    if (oakName.contains(\"[\")) {\r\n        throw new RepositoryException(\"Cannot create a new node using a name including an index\");\r\n    }\r\n    NodeDelegate parent = dlg.getChild(parentPath);\r\n    if (parent == null) {\r\n        \/\/ is it a property?\r\n        String grandParentPath = PathUtils.getParentPath(parentPath);\r\n        NodeDelegate grandParent = dlg.getChild(grandParentPath);\r\n        if (grandParent != null) {\r\n            String propName = PathUtils.getName(parentPath);\r\n            if (grandParent.getProperty(propName) != null) {\r\n                throw new ConstraintViolationException(\"Can't add new node to property.\");\r\n            }\r\n        }\r\n        throw new PathNotFoundException(relPath);\r\n    }\r\n    if (parent.getChild(oakName) != null) {\r\n        throw new ItemExistsException(relPath);\r\n    }\r\n    String ntName = primaryNodeTypeName;\r\n    if (ntName == null) {\r\n        DefinitionProvider dp = sessionDelegate.getDefinitionProvider();\r\n        try {\r\n            String childName = sessionDelegate.getOakName(PathUtils.getName(relPath));\r\n            NodeDefinition def = dp.getDefinition(new NodeImpl<NodeDelegate>(parent), childName);\r\n            ntName = def.getDefaultPrimaryTypeName();\r\n        } catch (RepositoryException e) {\r\n            throw new ConstraintViolationException(\"no matching child node definition found for \" + relPath);\r\n        }\r\n    }\r\n    \/\/ TODO: figure out the right place for this check\r\n    NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();\r\n    \/\/ throws on not found\r\n    NodeType nt = ntm.getNodeType(ntName);\r\n    if (nt.isAbstract() || nt.isMixin()) {\r\n        throw new ConstraintViolationException();\r\n    }\r\n    \/\/ TODO: END\r\n    NodeDelegate added = parent.addChild(oakName);\r\n    if (added == null) {\r\n        throw new ItemExistsException();\r\n    }\r\n    NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added);\r\n    childNode.internalSetPrimaryType(ntName);\r\n    childNode.autoCreateItems();\r\n    return childNode;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Node perform() throws RepositoryException {\r\n    String oakPath = sessionDelegate.getOakPathKeepIndexOrThrowNotFound(relPath);\r\n    String oakName = PathUtils.getName(oakPath);\r\n    String parentPath = sessionDelegate.getOakPath(PathUtils.getParentPath(oakPath));\r\n        if (oakName.contains(\"[\")) {\r\n        throw new RepositoryException(\"Cannot create a new node using a name including an index\");\r\n    }\r\n    NodeDelegate parent = dlg.getChild(parentPath);\r\n    if (parent == null) {\r\n                String grandParentPath = PathUtils.getParentPath(parentPath);\r\n        NodeDelegate grandParent = dlg.getChild(grandParentPath);\r\n        if (grandParent != null) {\r\n            String propName = PathUtils.getName(parentPath);\r\n            if (grandParent.getProperty(propName) != null) {\r\n                throw new ConstraintViolationException(\"Can't add new node to property.\");\r\n            }\r\n        }\r\n        throw new PathNotFoundException(relPath);\r\n    }\r\n    if (parent.getChild(oakName) != null) {\r\n        throw new ItemExistsException(relPath);\r\n    }\r\n    String ntName = primaryNodeTypeName;\r\n    if (ntName == null) {\r\n        DefinitionProvider dp = sessionDelegate.getDefinitionProvider();\r\n        try {\r\n            String childName = sessionDelegate.getOakName(PathUtils.getName(relPath));\r\n            NodeDefinition def = dp.getDefinition(new NodeImpl<NodeDelegate>(parent), childName);\r\n            ntName = def.getDefaultPrimaryTypeName();\r\n        } catch (RepositoryException e) {\r\n            throw new ConstraintViolationException(\"no matching child node definition found for \" + relPath);\r\n        }\r\n    }\r\n        NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();\r\n        NodeType nt = ntm.getNodeType(ntName);\r\n    if (nt.isAbstract() || nt.isMixin()) {\r\n        throw new ConstraintViolationException();\r\n    }\r\n        NodeDelegate added = parent.addChild(oakName);\r\n    if (added == null) {\r\n        throw new ItemExistsException();\r\n    }\r\n    NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added);\r\n    childNode.internalSetPrimaryType(ntName);\r\n    childNode.autoCreateItems();\r\n    return childNode;\r\n}","lc":1.5454545455,"pi":0.2679425837,"ma":2.6,"nbd":0.5,"ml":1.25,"d":0.5099206349,"mi":-0.9013389711,"fo":1.4166666667,"r":-0.0263157895,"e":1.714472433}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-259_09175c8b","label":1,"code":"@Override\r\npublic \/**\r\n * @return The content type.\r\n *\/\r\nString getContentType() {\r\n    return \"text\/html\";\r\n}","code_comment":"\/**\r\n * @return The content type.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic String getContentType() {\r\n    return \"text\/html\";\r\n}","lc":-0.4090909091,"pi":-0.6650717703,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8768146582,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"Closure","project_version":"156","label":2,"code":"\/**\r\n * Collapses definitions of the collapsible properties of a global name.\r\n * Recurses on subnames that also represent JavaScript objects with\r\n * collapsible properties.\r\n *\r\n * @param n A node representing a global name\r\n * @param alias The flattened name for {@code n}\r\n *\/\r\nprivate void collapseDeclarationOfNameAndDescendants(Name n, String alias) {\r\n    boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames();\r\n    \/\/ Handle this name first so that nested object literals get unrolled.\r\n    if (n.canCollapse() && canCollapseChildNames) {\r\n        updateObjLitOrFunctionDeclaration(n, alias);\r\n    }\r\n    if (n.props != null) {\r\n        for (Name p : n.props) {\r\n            \/\/ Recurse first so that saved node ancestries are intact when needed.\r\n            collapseDeclarationOfNameAndDescendants(p, appendPropForAlias(alias, p.name));\r\n            if (!p.inExterns && canCollapseChildNames && p.declaration != null && p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) {\r\n                updateSimpleDeclaration(appendPropForAlias(alias, p.name), p, p.declaration);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Collapses definitions of the collapsible properties of a global name.\r\n * Recurses on subnames that also represent JavaScript objects with\r\n * collapsible properties.\r\n *\r\n * @param n A node representing a global name\r\n * @param alias The flattened name for {@code n}\r\n *\/\r\n","code_no_comment":"private void collapseDeclarationOfNameAndDescendants(Name n, String alias) {\r\n    boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames();\r\n        if (n.canCollapse() && canCollapseChildNames) {\r\n        updateObjLitOrFunctionDeclaration(n, alias);\r\n    }\r\n    if (n.props != null) {\r\n        for (Name p : n.props) {\r\n                        collapseDeclarationOfNameAndDescendants(p, appendPropForAlias(alias, p.name));\r\n            if (!p.inExterns && canCollapseChildNames && p.declaration != null && p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) {\r\n                updateSimpleDeclaration(appendPropForAlias(alias, p.name), p, p.declaration);\r\n            }\r\n        }\r\n    }\r\n}","lc":0.0,"pi":0.7894736842,"ma":0.2,"nbd":0.5,"ml":1.0,"d":0.6349206349,"mi":-0.1128964059,"fo":0.3333333333,"r":0.0,"e":0.619678083}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5689_2ac29d30","label":3,"code":"\/*\r\n\t * TODO: simplify the code below. See WICKET-3347\r\n\t *\/\r\n@Override\r\npublic void respond(RequestCycle requestCycle) {\r\n    Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();\r\n    Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());\r\n    \/\/ \r\n    \/\/ the code below is little hairy but we have to handle 3 redirect policies,\r\n    \/\/ 3 rendering strategies and two kind of requests (ajax and normal)\r\n    \/\/ \r\n    \/\/ try to get an already rendered buffered response for current URL\r\n    BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);\r\n    if (bufferedResponse != null) {\r\n        logger.warn(\"The Buffered response should be handled by BufferedResponseRequestHandler\");\r\n        \/\/ if there is saved response for this URL render it\r\n        bufferedResponse.writeTo((WebResponse) requestCycle.getResponse());\r\n    } else if (shouldRenderPageAndWriteResponse(requestCycle, currentUrl, targetUrl)) {\r\n        BufferedWebResponse response = renderPage(currentUrl, requestCycle);\r\n        if (response != null) {\r\n            response.writeTo((WebResponse) requestCycle.getResponse());\r\n        }\r\n    } else if (shouldRedirectToTargetUrl(requestCycle, currentUrl, targetUrl)) {\r\n        redirectTo(targetUrl, requestCycle);\r\n    \/\/ note: if we had session here we would render the page to buffer and then\r\n    \/\/ redirect to URL generated *after* page has been rendered (the statelessness\r\n    \/\/ may change during render). this would save one redirect because now we have\r\n    \/\/ to render to URL generated *before* page is rendered, render the page, get\r\n    \/\/ URL after render and if the URL is different (meaning page is not stateless),\r\n    \/\/ save the buffer and redirect again (which is pretty much what the next step\r\n    \/\/ does)\r\n    } else {\r\n        if (isRedirectToBuffer() == false && logger.isDebugEnabled()) {\r\n            String details = String.format(\"redirect strategy: '%s', isAjax: '%s', redirect policy: '%s', \" + \"current url: '%s', target url: '%s', is new: '%s', is stateless: '%s', is temporary: '%s'\", Application.get().getRequestCycleSettings().getRenderStrategy(), isAjax(requestCycle), getRedirectPolicy(), currentUrl, targetUrl, isNewPageInstance(), isPageStateless(), isSessionTemporary());\r\n            logger.debug(\"Falling back to Redirect_To_Buffer render strategy because none of the conditions \" + \"matched. Details: \" + details);\r\n        }\r\n        \/\/ force creation of possible stateful page to get the final target url\r\n        getPage();\r\n        Url beforeRenderUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());\r\n        \/\/ redirect to buffer\r\n        BufferedWebResponse response = renderPage(beforeRenderUrl, requestCycle);\r\n        if (response == null) {\r\n            return;\r\n        }\r\n        \/\/ the url might have changed after page has been rendered (e.g. the\r\n        \/\/ stateless flag might have changed because stateful components\r\n        \/\/ were added)\r\n        final Url afterRenderUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());\r\n        if (beforeRenderUrl.getSegments().equals(afterRenderUrl.getSegments()) == false) {\r\n            \/\/ the amount of segments is different - generated relative URLs\r\n            \/\/ will not work, we need to rerender the page. This can happen\r\n            \/\/ with IRequestHandlers that produce different URLs with\r\n            \/\/ different amount of segments for stateless and stateful pages\r\n            response = renderPage(afterRenderUrl, requestCycle);\r\n        }\r\n        if (currentUrl.equals(afterRenderUrl)) {\r\n            \/\/ no need to redirect when both urls are exactly the same\r\n            response.writeTo((WebResponse) requestCycle.getResponse());\r\n        } else \/\/ if page is still stateless after render\r\n        if (isPageStateless() && !enableRedirectForStatelessPage()) {\r\n            \/\/ we don't want the redirect to happen for stateless page\r\n            \/\/ example:\r\n            \/\/ when a normal mounted stateful page is hit at \/mount\/point\r\n            \/\/ wicket renders the page to buffer and redirects to \/mount\/point?12\r\n            \/\/ but for stateless page the redirect is not necessary\r\n            \/\/ also for listener interface on stateful page we want to redirect\r\n            \/\/ after the listener is invoked, but on stateless page the user\r\n            \/\/ must ask for redirect explicitly\r\n            response.writeTo((WebResponse) requestCycle.getResponse());\r\n        } else {\r\n            storeBufferedResponse(afterRenderUrl, response);\r\n            redirectTo(afterRenderUrl, requestCycle);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void respond(RequestCycle requestCycle) {\r\n    Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();\r\n    Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());\r\n                        BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);\r\n    if (bufferedResponse != null) {\r\n        logger.warn(\"The Buffered response should be handled by BufferedResponseRequestHandler\");\r\n                bufferedResponse.writeTo((WebResponse) requestCycle.getResponse());\r\n    } else if (shouldRenderPageAndWriteResponse(requestCycle, currentUrl, targetUrl)) {\r\n        BufferedWebResponse response = renderPage(currentUrl, requestCycle);\r\n        if (response != null) {\r\n            response.writeTo((WebResponse) requestCycle.getResponse());\r\n        }\r\n    } else if (shouldRedirectToTargetUrl(requestCycle, currentUrl, targetUrl)) {\r\n        redirectTo(targetUrl, requestCycle);\r\n                                } else {\r\n        if (isRedirectToBuffer() == false && logger.isDebugEnabled()) {\r\n            String details = String.format(\"redirect strategy: '%s', isAjax: '%s', redirect policy: '%s', \" + \"current url: '%s', target url: '%s', is new: '%s', is stateless: '%s', is temporary: '%s'\", Application.get().getRequestCycleSettings().getRenderStrategy(), isAjax(requestCycle), getRedirectPolicy(), currentUrl, targetUrl, isNewPageInstance(), isPageStateless(), isSessionTemporary());\r\n            logger.debug(\"Falling back to Redirect_To_Buffer render strategy because none of the conditions \" + \"matched. Details: \" + details);\r\n        }\r\n                getPage();\r\n        Url beforeRenderUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());\r\n                BufferedWebResponse response = renderPage(beforeRenderUrl, requestCycle);\r\n        if (response == null) {\r\n            return;\r\n        }\r\n                                final Url afterRenderUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());\r\n        if (beforeRenderUrl.getSegments().equals(afterRenderUrl.getSegments()) == false) {\r\n                                                            response = renderPage(afterRenderUrl, requestCycle);\r\n        }\r\n        if (currentUrl.equals(afterRenderUrl)) {\r\n                        response.writeTo((WebResponse) requestCycle.getResponse());\r\n        } else         if (isPageStateless() && !enableRedirectForStatelessPage()) {\r\n                                                                                                            response.writeTo((WebResponse) requestCycle.getResponse());\r\n        } else {\r\n            storeBufferedResponse(afterRenderUrl, response);\r\n            redirectTo(afterRenderUrl, requestCycle);\r\n        }\r\n    }\r\n}","lc":1.2272727273,"pi":0.1626794258,"ma":1.2,"nbd":1.5,"ml":1.75,"d":1.0456349206,"mi":-0.7750528541,"fo":3.25,"r":-0.0263157895,"e":2.6839393049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-579_7d72e6ed","label":3,"code":"@Override\r\npublic void execute(NodeState rootState) {\r\n    cursor = index.query(createFilter(), rootState);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void execute(NodeState rootState) {\r\n    cursor = index.query(createFilter(), rootState);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8105708245,"fo":-0.3333333333,"r":1.1842105263,"e":-0.1627934049}
{"project_name":"JxPath","project_version":"10","label":1,"code":"public final Object computeValue(EvalContext context) {\r\n    return compute(args[0].computeValue(context), args[1].computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;\r\n}","code_comment":null,"code_no_comment":"public final Object computeValue(EvalContext context) {\r\n    return compute(args[0].computeValue(context), args[1].computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":0.0,"d":-0.3650793651,"mi":0.8520084567,"fo":-0.25,"r":0.0,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5071_a2f848f2","label":1,"code":"\/**\r\n *  @see org.apache.wicket.request.IRequestMapper#mapRequest(org.apache.wicket.request.Request)\r\n *\/\r\n@Override\r\npublic IRequestHandler mapRequest(Request request) {\r\n    Url url = request.getUrl();\r\n    if (matches(url)) {\r\n        PageComponentInfo info = getPageComponentInfo(url);\r\n        if (info != null && info.getPageInfo().getPageId() != null) {\r\n            Integer renderCount = info.getComponentInfo() != null ? info.getComponentInfo().getRenderCount() : null;\r\n            if (info.getComponentInfo() == null) {\r\n                PageProvider provider = new PageProvider(info.getPageInfo().getPageId(), renderCount);\r\n                provider.setPageSource(getContext());\r\n                \/\/ render page\r\n                return new RenderPageRequestHandler(provider);\r\n            } else {\r\n                ComponentInfo componentInfo = info.getComponentInfo();\r\n                PageAndComponentProvider provider = new PageAndComponentProvider(info.getPageInfo().getPageId(), renderCount, componentInfo.getComponentPath());\r\n                provider.setPageSource(getContext());\r\n                \/\/ listener interface\r\n                RequestListenerInterface listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());\r\n                return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.request.IRequestMapper#mapRequest(org.apache.wicket.request.Request)\r\n *\/\r\n","code_no_comment":"@Override\r\npublic IRequestHandler mapRequest(Request request) {\r\n    Url url = request.getUrl();\r\n    if (matches(url)) {\r\n        PageComponentInfo info = getPageComponentInfo(url);\r\n        if (info != null && info.getPageInfo().getPageId() != null) {\r\n            Integer renderCount = info.getComponentInfo() != null ? info.getComponentInfo().getRenderCount() : null;\r\n            if (info.getComponentInfo() == null) {\r\n                PageProvider provider = new PageProvider(info.getPageInfo().getPageId(), renderCount);\r\n                provider.setPageSource(getContext());\r\n                                return new RenderPageRequestHandler(provider);\r\n            } else {\r\n                ComponentInfo componentInfo = info.getComponentInfo();\r\n                PageAndComponentProvider provider = new PageAndComponentProvider(info.getPageInfo().getPageId(), renderCount, componentInfo.getComponentPath());\r\n                provider.setPageSource(getContext());\r\n                                RequestListenerInterface listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());\r\n                return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}","lc":0.3636363636,"pi":1.3779904306,"ma":0.2,"nbd":0.5,"ml":0.4166666667,"d":0.4623015873,"mi":-0.3615221987,"fo":1.3333333333,"r":-0.0263157895,"e":0.7012073327}
{"project_name":"Closure","project_version":"134","label":2,"code":"private void addNonUnionType(JSType newType) {\r\n    if (skipAmbiguating || isInvalidatingType(newType)) {\r\n        skipAmbiguating = true;\r\n        return;\r\n    }\r\n    if (type == null) {\r\n        type = newType;\r\n    } else {\r\n        type = type.getLeastSupertype(newType);\r\n    }\r\n    typesSet.set(getIntForType(newType));\r\n}","code_comment":null,"code_no_comment":"private void addNonUnionType(JSType newType) {\r\n    if (skipAmbiguating || isInvalidatingType(newType)) {\r\n        skipAmbiguating = true;\r\n        return;\r\n    }\r\n    if (type == null) {\r\n        type = newType;\r\n    } else {\r\n        type = type.getLeastSupertype(newType);\r\n    }\r\n    typesSet.set(getIntForType(newType));\r\n}","lc":-0.0909090909,"pi":-0.1148325359,"ma":-0.2,"nbd":-0.5,"ml":0.1666666667,"d":-0.0436507937,"mi":0.1424947146,"fo":-0.1666666667,"r":0.5526315789,"e":-0.0853396956}
{"project_name":"Closure","project_version":"171","label":2,"code":"private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\r\n    JSType type = n.getJSType();\r\n    Preconditions.checkNotNull(type);\r\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\r\n        scope = traverse(name.getFirstChild(), scope);\r\n    }\r\n    \/\/ Object literals can be reflected on other types.\r\n    \/\/ See CodingConvention#getObjectLiteralCase and goog.object.reflect.\r\n    \/\/ Ignore these types of literals.\r\n    ObjectType objectType = ObjectType.cast(type);\r\n    if (objectType == null) {\r\n        return scope;\r\n    }\r\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\r\n    if (objectType.hasReferenceName() && !hasLendsName) {\r\n        return scope;\r\n    }\r\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\r\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\r\n        String memberName = NodeUtil.getObjectLitKeyName(name);\r\n        if (memberName != null) {\r\n            JSType rawValueType = name.getFirstChild().getJSType();\r\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\r\n            if (valueType == null) {\r\n                valueType = unknownType;\r\n            }\r\n            objectType.defineInferredProperty(memberName, valueType, name);\r\n            \/\/ Do normal flow inference if this is a direct property assignment.\r\n            if (qObjName != null && name.isStringKey()) {\r\n                String qKeyName = qObjName + \".\" + memberName;\r\n                Var var = syntacticScope.getVar(qKeyName);\r\n                JSType oldType = var == null ? null : var.getType();\r\n                if (var != null && var.isTypeInferred()) {\r\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\r\n                }\r\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\r\n            }\r\n        } else {\r\n            n.setJSType(unknownType);\r\n        }\r\n    }\r\n    return scope;\r\n}","code_comment":null,"code_no_comment":"private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\r\n    JSType type = n.getJSType();\r\n    Preconditions.checkNotNull(type);\r\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\r\n        scope = traverse(name.getFirstChild(), scope);\r\n    }\r\n                ObjectType objectType = ObjectType.cast(type);\r\n    if (objectType == null) {\r\n        return scope;\r\n    }\r\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\r\n    if (objectType.hasReferenceName() && !hasLendsName) {\r\n        return scope;\r\n    }\r\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\r\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\r\n        String memberName = NodeUtil.getObjectLitKeyName(name);\r\n        if (memberName != null) {\r\n            JSType rawValueType = name.getFirstChild().getJSType();\r\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\r\n            if (valueType == null) {\r\n                valueType = unknownType;\r\n            }\r\n            objectType.defineInferredProperty(memberName, valueType, name);\r\n                        if (qObjName != null && name.isStringKey()) {\r\n                String qKeyName = qObjName + \".\" + memberName;\r\n                Var var = syntacticScope.getVar(qKeyName);\r\n                JSType oldType = var == null ? null : var.getType();\r\n                if (var != null && var.isTypeInferred()) {\r\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\r\n                }\r\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\r\n            }\r\n        } else {\r\n            n.setJSType(unknownType);\r\n        }\r\n    }\r\n    return scope;\r\n}","lc":1.1363636364,"pi":1.0526315789,"ma":1.6,"nbd":1.0,"ml":1.6666666667,"d":1.2996031746,"mi":-0.7840732911,"fo":1.8333333333,"r":-0.0263157895,"e":3.6602110383}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_46f62443","label":1,"code":"@Override\r\npublic void create(String tableName, boolean versioningIter, TimeType timeType) throws AccumuloException, AccumuloSecurityException, TableExistsException {\r\n    if (!tableName.matches(Constants.VALID_TABLE_NAME_REGEX)) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    acu.createTable(username, tableName, versioningIter, timeType);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void create(String tableName, boolean versioningIter, TimeType timeType) throws AccumuloException, AccumuloSecurityException, TableExistsException {\r\n    if (!tableName.matches(Constants.VALID_TABLE_NAME_REGEX)) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    acu.createTable(username, tableName, versioningIter, timeType);\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.3978858351,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2609_7da4ad17","label":1,"code":"\/**\r\n *  Translates the {@code object} into resource key that will be used to lookup the value shown\r\n *  to the user\r\n *\r\n *  @param object\r\n *  @return resource key\r\n *\/\r\nprotected String resourceKey(T object) {\r\n    return object.getClass().getSimpleName() + \".\" + object.name();\r\n}","code_comment":"\/**\r\n *  Translates the {@code object} into resource key that will be used to lookup the value shown\r\n *  to the user\r\n *\r\n *  @param object\r\n *  @return resource key\r\n *\/\r\n","code_no_comment":"protected String resourceKey(T object) {\r\n    return object.getClass().getSimpleName() + \".\" + object.name();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9292459479,"fo":-0.25,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-848_ad252a8c","label":1,"code":"\/**\r\n * Compute the shift for the current iteration.\r\n *\r\n * @param l the index of the small sub-diagonal element\r\n * @param idx the current eigenvalue index\r\n * @param iteration the current iteration\r\n * @param shift holder for shift information\r\n *\/\r\nprivate void computeShift(final int l, final int idx, final int iteration, final ShiftInfo shift) {\r\n    \/\/ Form shift\r\n    shift.x = matrixT[idx][idx];\r\n    shift.y = shift.w = 0.0;\r\n    if (l < idx) {\r\n        shift.y = matrixT[idx - 1][idx - 1];\r\n        shift.w = matrixT[idx][idx - 1] * matrixT[idx - 1][idx];\r\n    }\r\n    \/\/ Wilkinson's original ad hoc shift\r\n    if (iteration == 10) {\r\n        shift.exShift += shift.x;\r\n        for (int i = 0; i <= idx; i++) {\r\n            matrixT[i][i] -= shift.x;\r\n        }\r\n        double s = FastMath.abs(matrixT[idx][idx - 1]) + FastMath.abs(matrixT[idx - 1][idx - 2]);\r\n        shift.x = shift.y = 0.75 * s;\r\n        shift.w = -0.4375 * s * s;\r\n    }\r\n    \/\/ MATLAB's new ad hoc shift\r\n    if (iteration == 30) {\r\n        double s = (shift.y - shift.x) \/ 2.0;\r\n        s = s * s + shift.w;\r\n        if (Precision.compareTo(s, 0.0d, epsilon) > 0) {\r\n            s = FastMath.sqrt(s);\r\n            if (shift.y < shift.x) {\r\n                s = -s;\r\n            }\r\n            s = shift.x - shift.w \/ ((shift.y - shift.x) \/ 2.0 + s);\r\n            for (int i = 0; i <= idx; i++) {\r\n                matrixT[i][i] -= s;\r\n            }\r\n            shift.exShift += s;\r\n            shift.x = shift.y = shift.w = 0.964;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Compute the shift for the current iteration.\r\n *\r\n * @param l the index of the small sub-diagonal element\r\n * @param idx the current eigenvalue index\r\n * @param iteration the current iteration\r\n * @param shift holder for shift information\r\n *\/\r\n","code_no_comment":"private void computeShift(final int l, final int idx, final int iteration, final ShiftInfo shift) {\r\n        shift.x = matrixT[idx][idx];\r\n    shift.y = shift.w = 0.0;\r\n    if (l < idx) {\r\n        shift.y = matrixT[idx - 1][idx - 1];\r\n        shift.w = matrixT[idx][idx - 1] * matrixT[idx - 1][idx];\r\n    }\r\n        if (iteration == 10) {\r\n        shift.exShift += shift.x;\r\n        for (int i = 0; i <= idx; i++) {\r\n            matrixT[i][i] -= shift.x;\r\n        }\r\n        double s = FastMath.abs(matrixT[idx][idx - 1]) + FastMath.abs(matrixT[idx - 1][idx - 2]);\r\n        shift.x = shift.y = 0.75 * s;\r\n        shift.w = -0.4375 * s * s;\r\n    }\r\n        if (iteration == 30) {\r\n        double s = (shift.y - shift.x) \/ 2.0;\r\n        s = s * s + shift.w;\r\n        if (Precision.compareTo(s, 0.0d, epsilon) > 0) {\r\n            s = FastMath.sqrt(s);\r\n            if (shift.y < shift.x) {\r\n                s = -s;\r\n            }\r\n            s = shift.x - shift.w \/ ((shift.y - shift.x) \/ 2.0 + s);\r\n            for (int i = 0; i <= idx; i++) {\r\n                matrixT[i][i] -= s;\r\n            }\r\n            shift.exShift += s;\r\n            shift.x = shift.y = shift.w = 0.964;\r\n        }\r\n    }\r\n}","lc":0.8636363636,"pi":0.4832535885,"ma":0.8,"nbd":0.5,"ml":0.9166666667,"d":4.8571428571,"mi":-0.68794926,"fo":-0.1666666667,"r":-0.0263157895,"e":12.3488989932}
{"project_name":"Closure","project_version":"20","label":2,"code":"private Node tryFoldSimpleFunctionCall(Node n) {\r\n    Preconditions.checkState(n.isCall());\r\n    Node callTarget = n.getFirstChild();\r\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\r\n        \/\/ Fold String(a) to '' + (a) on immutable literals,\r\n        \/\/ which allows further optimizations\r\n        \/\/ \r\n        \/\/ We can't do this in the general case, because String(a) has\r\n        \/\/ slightly different semantics than '' + (a). See\r\n        \/\/ http:\/\/code.google.com\/p\/closure-compiler\/issues\/detail?id=759\r\n        Node value = callTarget.getNext();\r\n        if (value != null) {\r\n            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\r\n            n.getParent().replaceChild(n, addition);\r\n            reportCodeChange();\r\n            return addition;\r\n        }\r\n    }\r\n    return n;\r\n}","code_comment":null,"code_no_comment":"private Node tryFoldSimpleFunctionCall(Node n) {\r\n    Preconditions.checkState(n.isCall());\r\n    Node callTarget = n.getFirstChild();\r\n    if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) {\r\n                                                        Node value = callTarget.getNext();\r\n        if (value != null) {\r\n            Node addition = IR.add(IR.string(\"\").srcref(callTarget), value.detachFromParent());\r\n            n.getParent().replaceChild(n, addition);\r\n            reportCodeChange();\r\n            return addition;\r\n        }\r\n    }\r\n    return n;\r\n}","lc":0.0,"pi":0.5645933014,"ma":-0.2,"nbd":0.0,"ml":0.25,"d":-0.0138888889,"mi":-0.0607470049,"fo":0.6666666667,"r":0.1578947368,"e":0.0472214058}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Double reusable) {\r\n    int i = startPos;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    while (i < limit) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            break;\r\n        }\r\n        i++;\r\n    }\r\n    String str = new String(bytes, startPos, i - startPos);\r\n    try {\r\n        this.result = Double.parseDouble(str);\r\n        return (i == limit) ? limit : i + delimiter.length;\r\n    } catch (NumberFormatException e) {\r\n        setErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);\r\n        return -1;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Double reusable) {\r\n    int i = startPos;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    while (i < limit) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            break;\r\n        }\r\n        i++;\r\n    }\r\n    String str = new String(bytes, startPos, i - startPos);\r\n    try {\r\n        this.result = Double.parseDouble(str);\r\n        return (i == limit) ? limit : i + delimiter.length;\r\n    } catch (NumberFormatException e) {\r\n        setErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);\r\n        return -1;\r\n    }\r\n}","lc":0.2272727273,"pi":0.0956937799,"ma":0.4,"nbd":0.0,"ml":0.4166666667,"d":0.876984127,"mi":-0.24397463,"fo":-0.25,"r":0.0,"e":0.7153518554}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2074_6bc6dbec","label":0,"code":"@Override\r\nprotected void resetCurrent() {\r\n    currentReducedMap = null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void resetCurrent() {\r\n    currentReducedMap = null;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9362931642,"fo":-0.5,"r":1.9736842105,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1432_808ac9c0","label":1,"code":"public Statement optimize() {\r\n    if (explain || measure || orderList.size() > 0) {\r\n        return this;\r\n    }\r\n    if (where == null) {\r\n        return this;\r\n    }\r\n    if (where instanceof OrCondition) {\r\n        OrCondition or = (OrCondition) where;\r\n        if (or.getCommonLeftPart() != null) {\r\n        \/\/ @x = 1 or @x = 2\r\n        \/\/ is automatically converted to\r\n        \/\/ @x in (1, 2)\r\n        \/\/ within the query engine\r\n        } else if (or.left instanceof Contains && or.right instanceof Contains) {\r\n        \/\/ do not optimize \"contains\"\r\n        } else {\r\n            \/\/ conditions of type\r\n            \/\/ @x = 1 or @y = 2\r\n            \/\/ or similar are converted to\r\n            \/\/ (@x = 1) union (@y = 2)\r\n            Statement s1 = new Statement();\r\n            s1.columnSelector = columnSelector;\r\n            s1.selectors = selectors;\r\n            s1.columnList = columnList;\r\n            s1.where = or.left;\r\n            Statement s2 = new Statement();\r\n            s2.columnSelector = columnSelector;\r\n            s2.selectors = selectors;\r\n            s2.columnList = columnList;\r\n            s2.where = or.right;\r\n            s2.xpathQuery = xpathQuery;\r\n            return new UnionStatement(s1.optimize(), s2.optimize());\r\n        }\r\n    } else if (where instanceof AndCondition) {\r\n        \/\/ conditions of type\r\n        \/\/ @a = 1 and (@x = 1 or @y = 2)\r\n        \/\/ are automatically converted to\r\n        \/\/ (@a = 1 and @x = 1) union (@a = 1 and @y = 2)\r\n        AndCondition and = (AndCondition) where;\r\n        if (and.left instanceof OrCondition && !(and.right instanceof OrCondition)) {\r\n            \/\/ swap left and right\r\n            and = new AndCondition(and.right, and.left);\r\n        }\r\n        if (and.right instanceof OrCondition) {\r\n            OrCondition or = (OrCondition) and.right;\r\n            if (or.getCommonLeftPart() != null) {\r\n            \/\/ @x = 1 or @x = 2\r\n            \/\/ is automatically converted to\r\n            \/\/ @x in (1, 2)\r\n            \/\/ within the query engine\r\n            } else if (or.left instanceof Contains && or.right instanceof Contains) {\r\n            \/\/ do not optimize \"contains\"\r\n            } else {\r\n                \/\/ same as above, but with the added \"and\"\r\n                \/\/ TODO avoid code duplication if possible\r\n                Statement s1 = new Statement();\r\n                s1.columnSelector = columnSelector;\r\n                s1.selectors = selectors;\r\n                s1.columnList = columnList;\r\n                s1.where = new AndCondition(and.left, or.left);\r\n                Statement s2 = new Statement();\r\n                s2.columnSelector = columnSelector;\r\n                s2.selectors = selectors;\r\n                s2.columnList = columnList;\r\n                s2.where = new AndCondition(and.left, or.right);\r\n                s2.xpathQuery = xpathQuery;\r\n                return new UnionStatement(s1.optimize(), s2.optimize());\r\n            }\r\n        }\r\n    }\r\n    return this;\r\n}","code_comment":null,"code_no_comment":"public Statement optimize() {\r\n    if (explain || measure || orderList.size() > 0) {\r\n        return this;\r\n    }\r\n    if (where == null) {\r\n        return this;\r\n    }\r\n    if (where instanceof OrCondition) {\r\n        OrCondition or = (OrCondition) where;\r\n        if (or.getCommonLeftPart() != null) {\r\n                                        } else if (or.left instanceof Contains && or.right instanceof Contains) {\r\n                } else {\r\n                                                            Statement s1 = new Statement();\r\n            s1.columnSelector = columnSelector;\r\n            s1.selectors = selectors;\r\n            s1.columnList = columnList;\r\n            s1.where = or.left;\r\n            Statement s2 = new Statement();\r\n            s2.columnSelector = columnSelector;\r\n            s2.selectors = selectors;\r\n            s2.columnList = columnList;\r\n            s2.where = or.right;\r\n            s2.xpathQuery = xpathQuery;\r\n            return new UnionStatement(s1.optimize(), s2.optimize());\r\n        }\r\n    } else if (where instanceof AndCondition) {\r\n                                        AndCondition and = (AndCondition) where;\r\n        if (and.left instanceof OrCondition && !(and.right instanceof OrCondition)) {\r\n                        and = new AndCondition(and.right, and.left);\r\n        }\r\n        if (and.right instanceof OrCondition) {\r\n            OrCondition or = (OrCondition) and.right;\r\n            if (or.getCommonLeftPart() != null) {\r\n                                                            } else if (or.left instanceof Contains && or.right instanceof Contains) {\r\n                        } else {\r\n                                                Statement s1 = new Statement();\r\n                s1.columnSelector = columnSelector;\r\n                s1.selectors = selectors;\r\n                s1.columnList = columnList;\r\n                s1.where = new AndCondition(and.left, or.left);\r\n                Statement s2 = new Statement();\r\n                s2.columnSelector = columnSelector;\r\n                s2.selectors = selectors;\r\n                s2.columnList = columnList;\r\n                s2.where = new AndCondition(and.left, or.right);\r\n                s2.xpathQuery = xpathQuery;\r\n                return new UnionStatement(s1.optimize(), s2.optimize());\r\n            }\r\n        }\r\n    }\r\n    return this;\r\n}","lc":1.7272727273,"pi":0.7033492823,"ma":1.4,"nbd":1.5,"ml":1.5833333333,"d":3.1111111111,"mi":-0.8959830867,"fo":0.0833333333,"r":-0.0263157895,"e":7.1471770313}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"public int compareTo(update_result other) {\r\n    if (!getClass().equals(other.getClass())) {\r\n        return getClass().getName().compareTo(other.getClass().getName());\r\n    }\r\n    int lastComparison = 0;\r\n    update_result typedOther = (update_result) other;\r\n    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());\r\n    if (lastComparison != 0) {\r\n        return lastComparison;\r\n    }\r\n    if (isSetOuch1()) {\r\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);\r\n        if (lastComparison != 0) {\r\n            return lastComparison;\r\n        }\r\n    }\r\n    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());\r\n    if (lastComparison != 0) {\r\n        return lastComparison;\r\n    }\r\n    if (isSetOuch2()) {\r\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);\r\n        if (lastComparison != 0) {\r\n            return lastComparison;\r\n        }\r\n    }\r\n    return 0;\r\n}","code_comment":null,"code_no_comment":"public int compareTo(update_result other) {\r\n    if (!getClass().equals(other.getClass())) {\r\n        return getClass().getName().compareTo(other.getClass().getName());\r\n    }\r\n    int lastComparison = 0;\r\n    update_result typedOther = (update_result) other;\r\n    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());\r\n    if (lastComparison != 0) {\r\n        return lastComparison;\r\n    }\r\n    if (isSetOuch1()) {\r\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);\r\n        if (lastComparison != 0) {\r\n            return lastComparison;\r\n        }\r\n    }\r\n    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());\r\n    if (lastComparison != 0) {\r\n        return lastComparison;\r\n    }\r\n    if (isSetOuch2()) {\r\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);\r\n        if (lastComparison != 0) {\r\n            return lastComparison;\r\n        }\r\n    }\r\n    return 0;\r\n}","lc":0.6363636364,"pi":-0.043062201,"ma":0.8,"nbd":0.0,"ml":0.5833333333,"d":0.2996031746,"mi":-0.4556730092,"fo":1.1666666667,"r":-0.0263157895,"e":0.3821533745}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3324_5f863af6","label":1,"code":"private boolean applyToParent(@Nonnull PermissionEntry entry) {\r\n    if (parent != null) {\r\n        return entry.matches(parent, null);\r\n    } else if (parentPath != null) {\r\n        return entry.matches(parentPath);\r\n    } else {\r\n        return false;\r\n    }\r\n}","code_comment":null,"code_no_comment":"private boolean applyToParent(@Nonnull PermissionEntry entry) {\r\n    if (parent != null) {\r\n        return entry.matches(parent, null);\r\n    } else if (parentPath != null) {\r\n        return entry.matches(parentPath);\r\n    } else {\r\n        return false;\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.3412262156,"fo":-0.3333333333,"r":1.0263157895,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5742_6ab41ee8","label":1,"code":"private void createPluginRealm(PluginDescriptor pluginDescriptor, MavenSession session, ClassLoader parent, Map<String, ClassLoader> foreignImports, DependencyFilter filter) throws PluginResolutionException, PluginContainerException {\r\n    Plugin plugin = pluginDescriptor.getPlugin();\r\n    if (plugin == null) {\r\n        throw new IllegalArgumentException(\"incomplete plugin descriptor, plugin missing\");\r\n    }\r\n    Artifact pluginArtifact = pluginDescriptor.getPluginArtifact();\r\n    if (pluginArtifact == null) {\r\n        throw new IllegalArgumentException(\"incomplete plugin descriptor, plugin artifact missing\");\r\n    }\r\n    MavenProject project = session.getCurrentProject();\r\n    final ClassRealm pluginRealm;\r\n    final List<Artifact> pluginArtifacts;\r\n    RepositorySystemSession repositorySession = session.getRepositorySession();\r\n    if (plugin.isExtensions()) {\r\n        \/\/ TODO discover components in #setupExtensionsRealm\r\n        ExtensionRealmCache.CacheRecord extensionRecord;\r\n        try {\r\n            extensionRecord = setupExtensionsRealm(project, plugin, repositorySession);\r\n        } catch (PluginManagerException e) {\r\n            \/\/ any exception means a problem in maven code, not a user error\r\n            throw new IllegalStateException(e);\r\n        }\r\n        pluginRealm = extensionRecord.realm;\r\n        pluginArtifacts = extensionRecord.artifacts;\r\n    } else {\r\n        DependencyFilter dependencyFilter = project.getExtensionDependencyFilter();\r\n        dependencyFilter = AndDependencyFilter.newInstance(dependencyFilter, filter);\r\n        DependencyNode root = pluginDependenciesResolver.resolve(plugin, RepositoryUtils.toArtifact(pluginArtifact), dependencyFilter, project.getRemotePluginRepositories(), repositorySession);\r\n        PreorderNodeListGenerator nlg = new PreorderNodeListGenerator();\r\n        root.accept(nlg);\r\n        pluginArtifacts = toMavenArtifacts(root, nlg);\r\n        pluginRealm = classRealmManager.createPluginRealm(plugin, parent, null, foreignImports, toAetherArtifacts(pluginArtifacts));\r\n        discoverPluginComponents(pluginRealm, plugin, pluginDescriptor);\r\n    }\r\n    pluginDescriptor.setClassRealm(pluginRealm);\r\n    pluginDescriptor.setArtifacts(pluginArtifacts);\r\n}","code_comment":null,"code_no_comment":"private void createPluginRealm(PluginDescriptor pluginDescriptor, MavenSession session, ClassLoader parent, Map<String, ClassLoader> foreignImports, DependencyFilter filter) throws PluginResolutionException, PluginContainerException {\r\n    Plugin plugin = pluginDescriptor.getPlugin();\r\n    if (plugin == null) {\r\n        throw new IllegalArgumentException(\"incomplete plugin descriptor, plugin missing\");\r\n    }\r\n    Artifact pluginArtifact = pluginDescriptor.getPluginArtifact();\r\n    if (pluginArtifact == null) {\r\n        throw new IllegalArgumentException(\"incomplete plugin descriptor, plugin artifact missing\");\r\n    }\r\n    MavenProject project = session.getCurrentProject();\r\n    final ClassRealm pluginRealm;\r\n    final List<Artifact> pluginArtifacts;\r\n    RepositorySystemSession repositorySession = session.getRepositorySession();\r\n    if (plugin.isExtensions()) {\r\n                ExtensionRealmCache.CacheRecord extensionRecord;\r\n        try {\r\n            extensionRecord = setupExtensionsRealm(project, plugin, repositorySession);\r\n        } catch (PluginManagerException e) {\r\n                        throw new IllegalStateException(e);\r\n        }\r\n        pluginRealm = extensionRecord.realm;\r\n        pluginArtifacts = extensionRecord.artifacts;\r\n    } else {\r\n        DependencyFilter dependencyFilter = project.getExtensionDependencyFilter();\r\n        dependencyFilter = AndDependencyFilter.newInstance(dependencyFilter, filter);\r\n        DependencyNode root = pluginDependenciesResolver.resolve(plugin, RepositoryUtils.toArtifact(pluginArtifact), dependencyFilter, project.getRemotePluginRepositories(), repositorySession);\r\n        PreorderNodeListGenerator nlg = new PreorderNodeListGenerator();\r\n        root.accept(nlg);\r\n        pluginArtifacts = toMavenArtifacts(root, nlg);\r\n        pluginRealm = classRealmManager.createPluginRealm(plugin, parent, null, foreignImports, toAetherArtifacts(pluginArtifacts));\r\n        discoverPluginComponents(pluginRealm, plugin, pluginDescriptor);\r\n    }\r\n    pluginDescriptor.setClassRealm(pluginRealm);\r\n    pluginDescriptor.setArtifacts(pluginArtifacts);\r\n}","lc":0.9545454545,"pi":-0.1052631579,"ma":0.8,"nbd":0.0,"ml":0.0833333333,"d":-0.0138888889,"mi":-0.6755461593,"fo":1.0,"r":-0.0263157895,"e":0.4804412095}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1363_69b68890","label":0,"code":"private AuthInfo createAuthInfo() {\r\n    Map<String, Object> attributes = new HashMap<String, Object>();\r\n    Credentials creds;\r\n    if (credentials instanceof ImpersonationCredentials) {\r\n        creds = ((ImpersonationCredentials) credentials).getBaseCredentials();\r\n    } else {\r\n        creds = credentials;\r\n    }\r\n    if (creds instanceof SimpleCredentials) {\r\n        SimpleCredentials sc = (SimpleCredentials) creds;\r\n        for (String attrName : sc.getAttributeNames()) {\r\n            attributes.put(attrName, sc.getAttribute(attrName));\r\n        }\r\n    }\r\n    return new AuthInfoImpl(userId, attributes, principals);\r\n}","code_comment":null,"code_no_comment":"private AuthInfo createAuthInfo() {\r\n    Map<String, Object> attributes = new HashMap<String, Object>();\r\n    Credentials creds;\r\n    if (credentials instanceof ImpersonationCredentials) {\r\n        creds = ((ImpersonationCredentials) credentials).getBaseCredentials();\r\n    } else {\r\n        creds = credentials;\r\n    }\r\n    if (creds instanceof SimpleCredentials) {\r\n        SimpleCredentials sc = (SimpleCredentials) creds;\r\n        for (String attrName : sc.getAttributeNames()) {\r\n            attributes.put(attrName, sc.getAttribute(attrName));\r\n        }\r\n    }\r\n    return new AuthInfoImpl(userId, attributes, principals);\r\n}","lc":0.0909090909,"pi":0.038277512,"ma":0.0,"nbd":0.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":-0.0903453136,"fo":-0.1666666667,"r":0.0,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-738_f64b6a90","label":1,"code":"\/**\r\n * Returns the natural logarithm of the beta function B(a, b).\r\n *\r\n * @param a Parameter {@code a}.\r\n * @param b Parameter {@code b}.\r\n * @return log(B(a, b)).\r\n *\/\r\npublic static double logBeta(double a, double b) {\r\n    return logBeta(a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\r\n}","code_comment":"\/**\r\n * Returns the natural logarithm of the beta function B(a, b).\r\n *\r\n * @param a Parameter {@code a}.\r\n * @param b Parameter {@code b}.\r\n * @return log(B(a, b)).\r\n *\/\r\n","code_no_comment":"public static double logBeta(double a, double b) {\r\n    return logBeta(a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9805496829,"fo":-0.4166666667,"r":2.3421052632,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"private Set<String> getValues(PropertyRestriction restriction) {\r\n    if (restriction.firstIncluding && restriction.lastIncluding && restriction.first != null && restriction.first.equals(restriction.last)) {\r\n        \/\/ \"[property] = $value\"\r\n        return encode(restriction.first);\r\n    } else if (restriction.list != null) {\r\n        \/\/ \"[property] IN (...)\r\n        \/\/ keep order for testing\r\n        Set<String> values = newLinkedHashSet();\r\n        for (PropertyValue value : restriction.list) {\r\n            values.addAll(encode(value));\r\n        }\r\n        return values;\r\n    } else {\r\n        \/\/ processed as \"[property] is not null\"\r\n        return null;\r\n    }\r\n}","code_comment":null,"code_no_comment":"private Set<String> getValues(PropertyRestriction restriction) {\r\n    if (restriction.firstIncluding && restriction.lastIncluding && restriction.first != null && restriction.first.equals(restriction.last)) {\r\n                return encode(restriction.first);\r\n    } else if (restriction.list != null) {\r\n                        Set<String> values = newLinkedHashSet();\r\n        for (PropertyValue value : restriction.list) {\r\n            values.addAll(encode(value));\r\n        }\r\n        return values;\r\n    } else {\r\n                return null;\r\n    }\r\n}","lc":-0.0454545455,"pi":0.1818181818,"ma":0.0,"nbd":0.5,"ml":0.5,"d":0.0317460317,"mi":0.0100070472,"fo":-0.0833333333,"r":0.0,"e":0.0140177383}
{"project_name":"Closure","project_version":"148","label":2,"code":"\/**\r\n * As each segment is visited write out the appropriate line mapping.\r\n *\/\r\n\/\/ Prevent the creation of unnecessary temporary stings for often\r\n\/\/ repeated values.\r\n\/\/ Append the line mapping entries.\r\nvoid appendLineMappings() throws IOException {\r\n    Preconditions.checkState(!mappings.isEmpty());\r\n    \/\/ Start the first line.\r\n    openLine();\r\n    \/\/ And close the final line.\r\n    \/**\r\n     * Begin the entry for a new line.\r\n     *\/\r\n    \/**\r\n     * End the entry for a line.\r\n     *\/\r\n    \/**\r\n     * Add a new char position entry.\r\n     * @param id The mapping id to record.\r\n     *\/\r\n    \/**\r\n     * Mark any visited mapping as \"used\".\r\n     *\/\r\n    \/**\r\n     * @throws IOException\r\n     *\/\r\n    \/**\r\n     * @param m The mapping for the current code segment. null if the segment\r\n     *     is unmapped.\r\n     * @param line The starting line for this code segment.\r\n     * @param col The starting column for this code segment.\r\n     * @param endLine The ending line\r\n     * @param endCol The ending column\r\n     * @throws IOException\r\n     *\/\r\n    \/**\r\n     * Walk the mappings and visit each segment of the mappings, unmapped\r\n     * segments are visited with a null mapping, unused mapping are not visited.\r\n     *\/\r\n    \/\/ The last line and column written\r\n    \/\/ Append the line mapping entries.\r\n    \/\/ The mapping list is ordered as a pre-order traversal.  The mapping\r\n    \/\/ positions give us enough information to rebuild the stack and this\r\n    \/\/ allows the building of the source map in O(n) time.\r\n    Deque<Mapping> stack = new ArrayDeque<Mapping>();\r\n    for (Mapping m : mappings) {\r\n        \/\/ closed in the reverse order of when they encountered.\r\n        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\r\n            Mapping previous = stack.pop();\r\n            writeClosedMapping(previous);\r\n        }\r\n        \/\/ Any gaps between the current line position and the start of the\r\n        \/\/ current mapping belong to the parent.\r\n        Mapping parent = stack.peek();\r\n        writeCharsBetween(parent, m);\r\n        stack.push(m);\r\n    }\r\n    \/\/ mappings in the reverse order of when they encountered.\r\n    while (!stack.isEmpty()) {\r\n        Mapping m = stack.pop();\r\n        writeClosedMapping(m);\r\n    }\r\n    closeLine();\r\n}","code_comment":"\/**\r\n * As each segment is visited write out the appropriate line mapping.\r\n *\/\r\n\/**\r\n * Begin the entry for a new line.\r\n *\/\r\n\/**\r\n * End the entry for a line.\r\n *\/\r\n\/**\r\n * Add a new char position entry.\r\n * @param id The mapping id to record.\r\n *\/\r\n\/**\r\n * Mark any visited mapping as \"used\".\r\n *\/\r\n\/**\r\n * @throws IOException\r\n *\/\r\n\/**\r\n * @param m The mapping for the current code segment. null if the segment\r\n *     is unmapped.\r\n * @param line The starting line for this code segment.\r\n * @param col The starting column for this code segment.\r\n * @param endLine The ending line\r\n * @param endCol The ending column\r\n * @throws IOException\r\n *\/\r\n\/**\r\n * Walk the mappings and visit each segment of the mappings, unmapped\r\n * segments are visited with a null mapping, unused mapping are not visited.\r\n *\/\r\n","code_no_comment":"void appendLineMappings() throws IOException {\r\n    Preconditions.checkState(!mappings.isEmpty());\r\n        openLine();\r\n        \/**\r\n     * Begin the entry for a new line.\r\n     *\/\r\n    \/**\r\n     * End the entry for a line.\r\n     *\/\r\n    \/**\r\n     * Add a new char position entry.\r\n     * @param id The mapping id to record.\r\n     *\/\r\n    \/**\r\n     * Mark any visited mapping as \"used\".\r\n     *\/\r\n    \/**\r\n     * @throws IOException\r\n     *\/\r\n    \/**\r\n     * @param m The mapping for the current code segment. null if the segment\r\n     *     is unmapped.\r\n     * @param line The starting line for this code segment.\r\n     * @param col The starting column for this code segment.\r\n     * @param endLine The ending line\r\n     * @param endCol The ending column\r\n     * @throws IOException\r\n     *\/\r\n    \/**\r\n     * Walk the mappings and visit each segment of the mappings, unmapped\r\n     * segments are visited with a null mapping, unused mapping are not visited.\r\n     *\/\r\n                        Deque<Mapping> stack = new ArrayDeque<Mapping>();\r\n    for (Mapping m : mappings) {\r\n                while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\r\n            Mapping previous = stack.pop();\r\n            writeClosedMapping(previous);\r\n        }\r\n                        Mapping parent = stack.peek();\r\n        writeCharsBetween(parent, m);\r\n        stack.push(m);\r\n    }\r\n        while (!stack.isEmpty()) {\r\n        Mapping m = stack.pop();\r\n        writeClosedMapping(m);\r\n    }\r\n    closeLine();\r\n}","lc":1.5454545455,"pi":-0.3971291866,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":0.0595238095,"mi":-0.6312896406,"fo":0.75,"r":-0.0263157895,"e":0.0933432456}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2567_948b6e05","label":3,"code":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, String reusable) {\r\n    int i = startPos;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    if (quotedStringParsing && bytes[i] == quoteCharacter) {\r\n        \/\/ quoted string parsing enabled and first character Vis a quote\r\n        i++;\r\n        \/\/ search for ending quote character\r\n        while (i < limit && bytes[i] != quoteCharacter) {\r\n            i++;\r\n        }\r\n        if (i == limit) {\r\n            setErrorState(ParseErrorState.UNTERMINATED_QUOTED_STRING);\r\n            return -1;\r\n        } else {\r\n            i++;\r\n            \/\/ check for proper termination\r\n            if (i == limit) {\r\n                \/\/ either by end of line\r\n                this.result = new String(bytes, startPos + 1, i - startPos - 2);\r\n                return limit;\r\n            } else if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n                \/\/ or following field delimiter\r\n                this.result = new String(bytes, startPos + 1, i - startPos - 2);\r\n                return i + delimiter.length;\r\n            } else {\r\n                \/\/ no proper termination\r\n                setErrorState(ParseErrorState.UNQUOTED_CHARS_AFTER_QUOTED_STRING);\r\n                return -1;\r\n            }\r\n        }\r\n    } else {\r\n        \/\/ look for delimiter\r\n        while (i < delimLimit && !delimiterNext(bytes, i, delimiter)) {\r\n            i++;\r\n        }\r\n        if (i >= delimLimit) {\r\n            \/\/ no delimiter found. Take the full string\r\n            this.result = new String(bytes, startPos, limit - startPos);\r\n            return limit;\r\n        } else {\r\n            \/\/ delimiter found.\r\n            this.result = new String(bytes, startPos, i - startPos);\r\n            return i + delimiter.length;\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, String reusable) {\r\n    int i = startPos;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    if (quotedStringParsing && bytes[i] == quoteCharacter) {\r\n                i++;\r\n                while (i < limit && bytes[i] != quoteCharacter) {\r\n            i++;\r\n        }\r\n        if (i == limit) {\r\n            setErrorState(ParseErrorState.UNTERMINATED_QUOTED_STRING);\r\n            return -1;\r\n        } else {\r\n            i++;\r\n                        if (i == limit) {\r\n                                this.result = new String(bytes, startPos + 1, i - startPos - 2);\r\n                return limit;\r\n            } else if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n                                this.result = new String(bytes, startPos + 1, i - startPos - 2);\r\n                return i + delimiter.length;\r\n            } else {\r\n                                setErrorState(ParseErrorState.UNQUOTED_CHARS_AFTER_QUOTED_STRING);\r\n                return -1;\r\n            }\r\n        }\r\n    } else {\r\n                while (i < delimLimit && !delimiterNext(bytes, i, delimiter)) {\r\n            i++;\r\n        }\r\n        if (i >= delimLimit) {\r\n                        this.result = new String(bytes, startPos, limit - startPos);\r\n            return limit;\r\n        } else {\r\n                        this.result = new String(bytes, startPos, i - startPos);\r\n            return i + delimiter.length;\r\n        }\r\n    }\r\n}","lc":1.0909090909,"pi":0.7368421053,"ma":0.8,"nbd":1.0,"ml":1.1666666667,"d":3.7380952381,"mi":-0.6803382664,"fo":-0.1666666667,"r":-0.0263157895,"e":5.8442719409}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-429_c02ecef8","label":1,"code":"@SuppressWarnings(\"unchecked\")\r\n@Nonnull\r\n@Override\r\npublic PropertyBuilder<T> assignFrom(PropertyState property) {\r\n    if (property != null) {\r\n        setName(property.getName());\r\n        if (property.isArray()) {\r\n            isArray = true;\r\n            setValues((Iterable<T>) property.getValue(type.getArrayType()));\r\n        } else {\r\n            isArray = false;\r\n            setValue(property.getValue(type));\r\n        }\r\n    }\r\n    return this;\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings(\"unchecked\")\r\n@Nonnull\r\n@Override\r\npublic PropertyBuilder<T> assignFrom(PropertyState property) {\r\n    if (property != null) {\r\n        setName(property.getName());\r\n        if (property.isArray()) {\r\n            isArray = true;\r\n            setValues((Iterable<T>) property.getValue(type.getArrayType()));\r\n        } else {\r\n            isArray = false;\r\n            setValue(property.getValue(type));\r\n        }\r\n    }\r\n    return this;\r\n}","lc":0.0909090909,"pi":0.8086124402,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0773809524,"mi":-0.0522903453,"fo":0.1666666667,"r":0.0789473684,"e":-0.0551788524}
{"project_name":"Lang","project_version":"29","label":1,"code":"\/**\r\n * <p>\r\n * Converts the given Java version string to an <code>int<\/code>.\r\n * <\/p>\r\n *\r\n * <p>\r\n * Example return values:\r\n * <\/p>\r\n * <ul>\r\n * <li><code>120<\/code> for Java 1.2<\/li>\r\n * <li><code>131<\/code> for Java 1.3.1<\/li>\r\n * <li><code>160<\/code> for Java 1.6.0_20<\/li>\r\n * <\/ul>\r\n *\r\n * <p>\r\n * Patch releases are not reported.\r\n * <\/p>\r\n * <p>\r\n * This method is package private instead of private to support unit test invocation.\r\n * <\/p>\r\n *\r\n * @return the version, for example 131 for Java 1.3.1\r\n *\/\r\nstatic float toJavaVersionInt(String version) {\r\n    return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\r\n}","code_comment":"\/**\r\n * <p>\r\n * Converts the given Java version string to an <code>int<\/code>.\r\n * <\/p>\r\n *\r\n * <p>\r\n * Example return values:\r\n * <\/p>\r\n * <ul>\r\n * <li><code>120<\/code> for Java 1.2<\/li>\r\n * <li><code>131<\/code> for Java 1.3.1<\/li>\r\n * <li><code>160<\/code> for Java 1.6.0_20<\/li>\r\n * <\/ul>\r\n *\r\n * <p>\r\n * Patch releases are not reported.\r\n * <\/p>\r\n * <p>\r\n * This method is package private instead of private to support unit test invocation.\r\n * <\/p>\r\n *\r\n * @return the version, for example 131 for Java 1.3.1\r\n *\/\r\n","code_no_comment":"static float toJavaVersionInt(String version) {\r\n    return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0132487667,"fo":-0.3333333333,"r":0.4473684211,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5838_e93fdd5a","label":1,"code":"\/**\r\n *  Gets last modified date of the given {@link URL}\r\n *\r\n *  @param url\r\n *  @return last modified timestamp or <code>null<\/code> if not available\r\n *  @throws IOException\r\n *\/\r\npublic static Time getLastModified(final URL url) throws IOException {\r\n    \/\/ check if url points to a local file\r\n    final File file = Files.getLocalFileFromUrl(url);\r\n    if (file != null) {\r\n        \/\/ in that case we can get the timestamp faster\r\n        return Files.getLastModified(file);\r\n    }\r\n    \/\/ otherwise open the url and proceed\r\n    URLConnection connection = url.openConnection();\r\n    connection.setDoInput(false);\r\n    final long milliseconds;\r\n    try {\r\n        if (connection instanceof JarURLConnection) {\r\n            JarURLConnection jarUrlConnection = (JarURLConnection) connection;\r\n            URL jarFileUrl = jarUrlConnection.getJarFileURL();\r\n            URLConnection jarFileConnection = jarFileUrl.openConnection();\r\n            jarFileConnection.setDoInput(false);\r\n            \/\/ get timestamp from JAR\r\n            milliseconds = jarFileConnection.getLastModified();\r\n        } else {\r\n            \/\/ get timestamp from URL\r\n            milliseconds = connection.getLastModified();\r\n        }\r\n        \/\/ return null if timestamp is unavailable\r\n        if (milliseconds == 0) {\r\n            return null;\r\n        }\r\n        \/\/ return UNIX timestamp\r\n        return Time.millis(milliseconds);\r\n    } finally {\r\n        closeQuietly(connection);\r\n    }\r\n}","code_comment":"\/**\r\n *  Gets last modified date of the given {@link URL}\r\n *\r\n *  @param url\r\n *  @return last modified timestamp or <code>null<\/code> if not available\r\n *  @throws IOException\r\n *\/\r\n","code_no_comment":"public static Time getLastModified(final URL url) throws IOException {\r\n        final File file = Files.getLocalFileFromUrl(url);\r\n    if (file != null) {\r\n                return Files.getLastModified(file);\r\n    }\r\n        URLConnection connection = url.openConnection();\r\n    connection.setDoInput(false);\r\n    final long milliseconds;\r\n    try {\r\n        if (connection instanceof JarURLConnection) {\r\n            JarURLConnection jarUrlConnection = (JarURLConnection) connection;\r\n            URL jarFileUrl = jarUrlConnection.getJarFileURL();\r\n            URLConnection jarFileConnection = jarFileUrl.openConnection();\r\n            jarFileConnection.setDoInput(false);\r\n                        milliseconds = jarFileConnection.getLastModified();\r\n        } else {\r\n                        milliseconds = connection.getLastModified();\r\n        }\r\n                if (milliseconds == 0) {\r\n            return null;\r\n        }\r\n                return Time.millis(milliseconds);\r\n    } finally {\r\n        closeQuietly(connection);\r\n    }\r\n}","lc":0.5454545455,"pi":0.3540669856,"ma":0.0,"nbd":0.0,"ml":0.0833333333,"d":0.0714285714,"mi":-0.3758985201,"fo":0.4166666667,"r":0.1842105263,"e":0.1492712782}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2337_36a41358","label":1,"code":"\/**\r\n *  @see org.apache.wicket.util.lang.PropertyResolver.IGetAndSet#getValue(java.lang.Object)\r\n *\/\r\npublic Object getValue(Object object) {\r\n    return Array.get(object, index);\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.util.lang.PropertyResolver.IGetAndSet#getValue(java.lang.Object)\r\n *\/\r\n","code_no_comment":"public Object getValue(Object object) {\r\n    return Array.get(object, index);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9960535588,"fo":-0.4166666667,"r":1.1052631579,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1204_a56d4998","label":1,"code":"\/**\r\n * This method attempts to find two values a and b satisfying <ul>\r\n * <li> {@code lowerBound <= a < initial < b <= upperBound} <\/li>\r\n * <li> {@code f(a) * f(b) <= 0} <\/li>\r\n * <\/ul>\r\n * If {@code f} is continuous on {@code [a,b]}, this means that {@code a}\r\n * and {@code b} bracket a root of {@code f}.\r\n * <p>\r\n * The algorithm checks the sign of \\( f(l_k) \\) and \\( f(u_k) \\) for increasing\r\n * values of k, where \\( l_k = max(lower, initial - \\delta_k) \\),\r\n * \\( u_k = min(upper, initial + \\delta_k) \\), using recurrence\r\n * \\( \\delta_{k+1} = r \\delta_k + q, \\delta_0 = 0\\) and starting search with \\( k=1 \\).\r\n * The algorithm stops when one of the following happens: <ul>\r\n * <li> at least one positive and one negative value have been found --  success!<\/li>\r\n * <li> both endpoints have reached their respective limites -- NoBracketingException <\/li>\r\n * <li> {@code maximumIterations} iterations elapse -- NoBracketingException <\/li><\/ul><\/p>\r\n * <p>\r\n * If different signs are found at first iteration ({@code k=1}), then the returned\r\n * interval will be \\( [a, b] = [l_1, u_1] \\). If different signs are found at a later\r\n * iteration ({code k>1}, then the returned interval will be either\r\n * \\( [a, b] = [l_{k+1}, l_{k}] \\) or \\( [a, b] = [u_{k}, u_{k+1}] \\). A root solver called\r\n * with these parameters will therefore start with the smallest bracketing interval known\r\n * at this step.\r\n * <\/p>\r\n * <p>\r\n * Interval expansion rate is tuned by changing the recurrence parameters {@code r} and\r\n * {@code q}. When the multiplicative factor {@code r} is set to 1, the sequence is a\r\n * simple arithmetic sequence with linear increase. When the multiplicative factor {@code r}\r\n * is larger than 1, the sequence has an asymtotically exponential rate. Note than the\r\n * additive parameter {@code q} should never be set to zero, otherwise the interval would\r\n * degenerate to the single initial point for all values of {@code k}.\r\n * <\/p>\r\n * <p>\r\n * As a rule of thumb, when the location of the root is expected to be approximately known\r\n * within some error margin, {@code r} should be set to 1 and {@code q} should be set to the\r\n * order of magnitude of the error margin. When the location of the root is really a wild guess,\r\n * then {@code r} should be set to a value larger than 1 (typically 2 to double the interval\r\n * length at each iteration) and {@code q} should be set according to half the initial\r\n * search interval length.\r\n * <\/p>\r\n * <p>\r\n * As an example, if we consider the trivial function {@code f(x) = 1 - x} and use\r\n * {@code initial = 4}, {@code r = 1}, {@code q = 2}, the algorithm will compute\r\n * {@code f(4-2) = f(2) = -1} and {@code f(4+2) = f(6) = -5} for {@code k = 1}, then\r\n * {@code f(4-4) = f(0) = +1} and {@code f(4+4) = f(8) = -7} for {@code k = 2}. Then it will\r\n * return the interval {@code [0, 2]} as the smallest one known to be bracketing the root.\r\n * As shown by this example, the initial value (here {@code 4}) may lie outside of the returned\r\n * bracketing interval.\r\n * <\/p>\r\n * @param function function to check\r\n * @param initial Initial midpoint of interval being expanded to\r\n * bracket a root.\r\n * @param lowerBound Lower bound (a is never lower than this value).\r\n * @param upperBound Upper bound (b never is greater than this\r\n * value).\r\n * @param q additive offset used to compute bounds sequence (must be strictly positive)\r\n * @param r multiplicative factor used to compute bounds sequence\r\n * @param maximumIterations Maximum number of iterations to perform\r\n * @return a two element array holding the bracketing values.\r\n * @exception NoBracketingException if function cannot be bracketed in the search interval\r\n *\/\r\npublic static double[] bracket(final UnivariateFunction function, final double initial, final double lowerBound, final double upperBound, final double q, final double r, final int maximumIterations) throws NoBracketingException {\r\n    if (function == null) {\r\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\r\n    }\r\n    if (q <= 0) {\r\n        throw new NotStrictlyPositiveException(q);\r\n    }\r\n    if (maximumIterations <= 0) {\r\n        throw new NotStrictlyPositiveException(LocalizedFormats.INVALID_MAX_ITERATIONS, maximumIterations);\r\n    }\r\n    verifySequence(lowerBound, initial, upperBound);\r\n    \/\/ initialize the recurrence\r\n    double a = initial;\r\n    double b = initial;\r\n    double fa = Double.NaN;\r\n    double fb = Double.NaN;\r\n    double delta = 0;\r\n    for (int numIterations = 0; (numIterations < maximumIterations) && (a > lowerBound || b > upperBound); ++numIterations) {\r\n        final double previousA = a;\r\n        final double previousFa = fa;\r\n        final double previousB = b;\r\n        final double previousFb = fb;\r\n        delta = r * delta + q;\r\n        a = FastMath.max(initial - delta, lowerBound);\r\n        b = FastMath.min(initial + delta, upperBound);\r\n        fa = function.value(a);\r\n        fb = function.value(b);\r\n        if (numIterations == 0) {\r\n            \/\/ we simply compare both sides of the initial interval\r\n            if (fa * fb <= 0) {\r\n                \/\/ the first interval already brackets a root\r\n                return new double[] { a, b };\r\n            }\r\n        } else {\r\n            \/\/ we expect sign changes to occur at boundaries\r\n            if (fa * previousFa <= 0) {\r\n                \/\/ sign change detected at near lower bound\r\n                return new double[] { a, previousA };\r\n            } else if (fb * previousFb <= 0) {\r\n                \/\/ sign change detected at near upper bound\r\n                return new double[] { previousB, b };\r\n            }\r\n        }\r\n    }\r\n    \/\/ no bracketing found\r\n    throw new NoBracketingException(a, b, fa, fb);\r\n}","code_comment":"\/**\r\n * This method attempts to find two values a and b satisfying <ul>\r\n * <li> {@code lowerBound <= a < initial < b <= upperBound} <\/li>\r\n * <li> {@code f(a) * f(b) <= 0} <\/li>\r\n * <\/ul>\r\n * If {@code f} is continuous on {@code [a,b]}, this means that {@code a}\r\n * and {@code b} bracket a root of {@code f}.\r\n * <p>\r\n * The algorithm checks the sign of \\( f(l_k) \\) and \\( f(u_k) \\) for increasing\r\n * values of k, where \\( l_k = max(lower, initial - \\delta_k) \\),\r\n * \\( u_k = min(upper, initial + \\delta_k) \\), using recurrence\r\n * \\( \\delta_{k+1} = r \\delta_k + q, \\delta_0 = 0\\) and starting search with \\( k=1 \\).\r\n * The algorithm stops when one of the following happens: <ul>\r\n * <li> at least one positive and one negative value have been found --  success!<\/li>\r\n * <li> both endpoints have reached their respective limites -- NoBracketingException <\/li>\r\n * <li> {@code maximumIterations} iterations elapse -- NoBracketingException <\/li><\/ul><\/p>\r\n * <p>\r\n * If different signs are found at first iteration ({@code k=1}), then the returned\r\n * interval will be \\( [a, b] = [l_1, u_1] \\). If different signs are found at a later\r\n * iteration ({code k>1}, then the returned interval will be either\r\n * \\( [a, b] = [l_{k+1}, l_{k}] \\) or \\( [a, b] = [u_{k}, u_{k+1}] \\). A root solver called\r\n * with these parameters will therefore start with the smallest bracketing interval known\r\n * at this step.\r\n * <\/p>\r\n * <p>\r\n * Interval expansion rate is tuned by changing the recurrence parameters {@code r} and\r\n * {@code q}. When the multiplicative factor {@code r} is set to 1, the sequence is a\r\n * simple arithmetic sequence with linear increase. When the multiplicative factor {@code r}\r\n * is larger than 1, the sequence has an asymtotically exponential rate. Note than the\r\n * additive parameter {@code q} should never be set to zero, otherwise the interval would\r\n * degenerate to the single initial point for all values of {@code k}.\r\n * <\/p>\r\n * <p>\r\n * As a rule of thumb, when the location of the root is expected to be approximately known\r\n * within some error margin, {@code r} should be set to 1 and {@code q} should be set to the\r\n * order of magnitude of the error margin. When the location of the root is really a wild guess,\r\n * then {@code r} should be set to a value larger than 1 (typically 2 to double the interval\r\n * length at each iteration) and {@code q} should be set according to half the initial\r\n * search interval length.\r\n * <\/p>\r\n * <p>\r\n * As an example, if we consider the trivial function {@code f(x) = 1 - x} and use\r\n * {@code initial = 4}, {@code r = 1}, {@code q = 2}, the algorithm will compute\r\n * {@code f(4-2) = f(2) = -1} and {@code f(4+2) = f(6) = -5} for {@code k = 1}, then\r\n * {@code f(4-4) = f(0) = +1} and {@code f(4+4) = f(8) = -7} for {@code k = 2}. Then it will\r\n * return the interval {@code [0, 2]} as the smallest one known to be bracketing the root.\r\n * As shown by this example, the initial value (here {@code 4}) may lie outside of the returned\r\n * bracketing interval.\r\n * <\/p>\r\n * @param function function to check\r\n * @param initial Initial midpoint of interval being expanded to\r\n * bracket a root.\r\n * @param lowerBound Lower bound (a is never lower than this value).\r\n * @param upperBound Upper bound (b never is greater than this\r\n * value).\r\n * @param q additive offset used to compute bounds sequence (must be strictly positive)\r\n * @param r multiplicative factor used to compute bounds sequence\r\n * @param maximumIterations Maximum number of iterations to perform\r\n * @return a two element array holding the bracketing values.\r\n * @exception NoBracketingException if function cannot be bracketed in the search interval\r\n *\/\r\n","code_no_comment":"public static double[] bracket(final UnivariateFunction function, final double initial, final double lowerBound, final double upperBound, final double q, final double r, final int maximumIterations) throws NoBracketingException {\r\n    if (function == null) {\r\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\r\n    }\r\n    if (q <= 0) {\r\n        throw new NotStrictlyPositiveException(q);\r\n    }\r\n    if (maximumIterations <= 0) {\r\n        throw new NotStrictlyPositiveException(LocalizedFormats.INVALID_MAX_ITERATIONS, maximumIterations);\r\n    }\r\n    verifySequence(lowerBound, initial, upperBound);\r\n        double a = initial;\r\n    double b = initial;\r\n    double fa = Double.NaN;\r\n    double fb = Double.NaN;\r\n    double delta = 0;\r\n    for (int numIterations = 0; (numIterations < maximumIterations) && (a > lowerBound || b > upperBound); ++numIterations) {\r\n        final double previousA = a;\r\n        final double previousFa = fa;\r\n        final double previousB = b;\r\n        final double previousFb = fb;\r\n        delta = r * delta + q;\r\n        a = FastMath.max(initial - delta, lowerBound);\r\n        b = FastMath.min(initial + delta, upperBound);\r\n        fa = function.value(a);\r\n        fb = function.value(b);\r\n        if (numIterations == 0) {\r\n                        if (fa * fb <= 0) {\r\n                                return new double[] { a, b };\r\n            }\r\n        } else {\r\n                        if (fa * previousFa <= 0) {\r\n                                return new double[] { a, previousA };\r\n            } else if (fb * previousFb <= 0) {\r\n                                return new double[] { previousB, b };\r\n            }\r\n        }\r\n    }\r\n        throw new NoBracketingException(a, b, fa, fb);\r\n}","lc":1.1818181818,"pi":0.4449760766,"ma":1.8,"nbd":1.0,"ml":1.4166666667,"d":2.6111111111,"mi":-0.7660324172,"fo":-0.0833333333,"r":-0.0263157895,"e":5.1849610714}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2433_7fca85bf","label":1,"code":"\/\/ ----------------------------< internal >----------------------------------\r\nprivate void fetchNextIterator() {\r\n    Iterator<T> it = nextIterator();\r\n    if (it != null && it.hasNext()) {\r\n        PeekingIterator<T> pIt = Iterators.peekingIterator(it);\r\n        if (!iterators.isEmpty() && comparator.compare(pIt.peek(), lastPeek) < 0) {\r\n            throw new IllegalStateException(description() + \" First element of next iterator must be greater than previous iterator\");\r\n        }\r\n        lastPeek = pIt.peek();\r\n        iterators.add(pIt);\r\n        adjustLast();\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void fetchNextIterator() {\r\n    Iterator<T> it = nextIterator();\r\n    if (it != null && it.hasNext()) {\r\n        PeekingIterator<T> pIt = Iterators.peekingIterator(it);\r\n        if (!iterators.isEmpty() && comparator.compare(pIt.peek(), lastPeek) < 0) {\r\n            throw new IllegalStateException(description() + \" First element of next iterator must be greater than previous iterator\");\r\n        }\r\n        lastPeek = pIt.peek();\r\n        iterators.add(pIt);\r\n        adjustLast();\r\n    }\r\n}","lc":-0.0909090909,"pi":0.2248803828,"ma":0.0,"nbd":0.0,"ml":0.4166666667,"d":0.4781746032,"mi":0.0322762509,"fo":0.3333333333,"r":0.7894736842,"e":0.2506295995}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3077_17654199","label":0,"code":"\/**\r\n * Sets this class's ZooKeeper reader\/writer.\r\n *\r\n * @param izoo\r\n *          reader\/writer\r\n *\/\r\nstatic void setZooReaderWriter(IZooReaderWriter izoo) {\r\n    zoo = izoo;\r\n}","code_comment":"\/**\r\n * Sets this class's ZooKeeper reader\/writer.\r\n *\r\n * @param izoo\r\n *          reader\/writer\r\n *\/\r\n","code_no_comment":"static void setZooReaderWriter(IZooReaderWriter izoo) {\r\n    zoo = izoo;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0451021846,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"Lang","project_version":"6","label":3,"code":"\/**\r\n * Translate an input onto a Writer. This is intentionally final as its algorithm is\r\n * tightly coupled with the abstract method of this class.\r\n *\r\n * @param input CharSequence that is being translated\r\n * @param out Writer to translate the text to\r\n * @throws IOException if and only if the Writer produces an IOException\r\n *\/\r\npublic final void translate(CharSequence input, Writer out) throws IOException {\r\n    if (out == null) {\r\n        throw new IllegalArgumentException(\"The Writer must not be null\");\r\n    }\r\n    if (input == null) {\r\n        return;\r\n    }\r\n    int pos = 0;\r\n    int len = input.length();\r\n    while (pos < len) {\r\n        int consumed = translate(input, pos, out);\r\n        if (consumed == 0) {\r\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\r\n            out.write(c);\r\n            pos += c.length;\r\n            continue;\r\n        }\r\n        \/\/ \/\/ and they just took care of a surrogate pair\r\n        for (int pt = 0; pt < consumed; pt++) {\r\n            pos += Character.charCount(Character.codePointAt(input, pos));\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Translate an input onto a Writer. This is intentionally final as its algorithm is\r\n * tightly coupled with the abstract method of this class.\r\n *\r\n * @param input CharSequence that is being translated\r\n * @param out Writer to translate the text to\r\n * @throws IOException if and only if the Writer produces an IOException\r\n *\/\r\n","code_no_comment":"public final void translate(CharSequence input, Writer out) throws IOException {\r\n    if (out == null) {\r\n        throw new IllegalArgumentException(\"The Writer must not be null\");\r\n    }\r\n    if (input == null) {\r\n        return;\r\n    }\r\n    int pos = 0;\r\n    int len = input.length();\r\n    while (pos < len) {\r\n        int consumed = translate(input, pos, out);\r\n        if (consumed == 0) {\r\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\r\n            out.write(c);\r\n            pos += c.length;\r\n            continue;\r\n        }\r\n                for (int pt = 0; pt < consumed; pt++) {\r\n            pos += Character.charCount(Character.codePointAt(input, pos));\r\n        }\r\n    }\r\n}","lc":0.3636363636,"pi":0.3349282297,"ma":0.8,"nbd":0.0,"ml":0.5,"d":0.5734126984,"mi":-0.326286117,"fo":0.0833333333,"r":0.0,"e":0.5108002974}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"\/**\r\n * Ensures that the {@link #OAK_CHILD_ORDER} exists. This method will create\r\n * the property if it doesn't exist and initialize the value with the names\r\n * of the children as returned by {@link NodeBuilder#getChildNodeNames()}.\r\n *\/\r\npublic void ensureChildOrderProperty() {\r\n    PropertyState childOrder = getNodeBuilder().getProperty(OAK_CHILD_ORDER);\r\n    if (childOrder == null) {\r\n        getNodeBuilder().setProperty(MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, getNodeBuilder().getChildNodeNames()));\r\n    }\r\n}","code_comment":"\/**\r\n * Ensures that the {@link #OAK_CHILD_ORDER} exists. This method will create\r\n * the property if it doesn't exist and initialize the value with the names\r\n * of the children as returned by {@link NodeBuilder#getChildNodeNames()}.\r\n *\/\r\n","code_no_comment":"public void ensureChildOrderProperty() {\r\n    PropertyState childOrder = getNodeBuilder().getProperty(OAK_CHILD_ORDER);\r\n    if (childOrder == null) {\r\n        getNodeBuilder().setProperty(MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, getNodeBuilder().getChildNodeNames()));\r\n    }\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1011904762,"mi":0.52670895,"fo":0.0833333333,"r":2.0263157895,"e":-0.1206641195}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4927_8c827e33","label":1,"code":"@Override\r\npublic void setContentType(String mimeType) {\r\n    checkHeader();\r\n    bufferedResponse.setContentType(mimeType);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void setContentType(String mimeType) {\r\n    checkHeader();\r\n    bufferedResponse.setContentType(mimeType);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7626497533,"fo":-0.3333333333,"r":1.2368421053,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2952_11d11e0d","label":1,"code":"public boolean getMigrations(Map<TServerInstance, TabletServerStatus> current, List<TabletMigration> result) {\r\n    boolean moreBalancingNeeded = false;\r\n    try {\r\n        \/\/ no moves possible\r\n        if (current.size() < 2) {\r\n            return false;\r\n        }\r\n        final Map<String, Map<KeyExtent, TabletStats>> donerTabletStats = new HashMap<String, Map<KeyExtent, TabletStats>>();\r\n        \/\/ Sort by total number of online tablets, per server\r\n        int total = 0;\r\n        ArrayList<ServerCounts> totals = new ArrayList<ServerCounts>();\r\n        for (Entry<TServerInstance, TabletServerStatus> entry : current.entrySet()) {\r\n            int serverTotal = 0;\r\n            if (entry.getValue() != null && entry.getValue().tableMap != null) {\r\n                for (Entry<String, TableInfo> e : entry.getValue().tableMap.entrySet()) {\r\n                    \/**\r\n                     * The check below was on entry.getKey(), but that resolves to a tabletserver not a tablename. Believe it should be e.getKey() which is a tablename\r\n                     *\/\r\n                    if (tableToBalance == null || tableToBalance.equals(e.getKey()))\r\n                        serverTotal += e.getValue().onlineTablets;\r\n                }\r\n            }\r\n            totals.add(new ServerCounts(serverTotal, entry.getKey(), entry.getValue()));\r\n            total += serverTotal;\r\n        }\r\n        \/\/ order from low to high\r\n        Collections.sort(totals);\r\n        Collections.reverse(totals);\r\n        int even = total \/ totals.size();\r\n        int numServersOverEven = total % totals.size();\r\n        \/\/ Move tablets from the servers with too many to the servers with\r\n        \/\/ the fewest but only nominate tablets to move once. This allows us\r\n        \/\/ to fill new servers with tablets from a mostly balanced server\r\n        \/\/ very quickly. However, it may take several balancing passes to move\r\n        \/\/ tablets from one hugely overloaded server to many slightly\r\n        \/\/ under-loaded servers.\r\n        int end = totals.size() - 1;\r\n        int movedAlready = 0;\r\n        int tooManyIndex = 0;\r\n        while (tooManyIndex < totals.size() && end > tooManyIndex) {\r\n            ServerCounts tooMany = totals.get(tooManyIndex);\r\n            int goal = even;\r\n            if (tooManyIndex < numServersOverEven) {\r\n                goal++;\r\n            }\r\n            int needToUnload = tooMany.count - goal;\r\n            ServerCounts tooLittle = totals.get(end);\r\n            int needToLoad = goal - tooLittle.count - movedAlready;\r\n            if (needToUnload < 1 && needToLoad < 1) {\r\n                break;\r\n            }\r\n            if (needToUnload >= needToLoad) {\r\n                result.addAll(move(tooMany, tooLittle, needToLoad, donerTabletStats));\r\n                end--;\r\n                movedAlready = 0;\r\n            } else {\r\n                result.addAll(move(tooMany, tooLittle, needToUnload, donerTabletStats));\r\n                movedAlready += needToUnload;\r\n            }\r\n            if (needToUnload > needToLoad) {\r\n                moreBalancingNeeded = true;\r\n            } else {\r\n                tooManyIndex++;\r\n                donerTabletStats.clear();\r\n            }\r\n        }\r\n    } finally {\r\n        log.debug(\"balance ended with \" + result.size() + \" migrations\");\r\n    }\r\n    return moreBalancingNeeded;\r\n}","code_comment":"\/**\r\n * The check below was on entry.getKey(), but that resolves to a tabletserver not a tablename. Believe it should be e.getKey() which is a tablename\r\n *\/\r\n","code_no_comment":"public boolean getMigrations(Map<TServerInstance, TabletServerStatus> current, List<TabletMigration> result) {\r\n    boolean moreBalancingNeeded = false;\r\n    try {\r\n                if (current.size() < 2) {\r\n            return false;\r\n        }\r\n        final Map<String, Map<KeyExtent, TabletStats>> donerTabletStats = new HashMap<String, Map<KeyExtent, TabletStats>>();\r\n                int total = 0;\r\n        ArrayList<ServerCounts> totals = new ArrayList<ServerCounts>();\r\n        for (Entry<TServerInstance, TabletServerStatus> entry : current.entrySet()) {\r\n            int serverTotal = 0;\r\n            if (entry.getValue() != null && entry.getValue().tableMap != null) {\r\n                for (Entry<String, TableInfo> e : entry.getValue().tableMap.entrySet()) {\r\n                    \/**\r\n                     * The check below was on entry.getKey(), but that resolves to a tabletserver not a tablename. Believe it should be e.getKey() which is a tablename\r\n                     *\/\r\n                    if (tableToBalance == null || tableToBalance.equals(e.getKey()))\r\n                        serverTotal += e.getValue().onlineTablets;\r\n                }\r\n            }\r\n            totals.add(new ServerCounts(serverTotal, entry.getKey(), entry.getValue()));\r\n            total += serverTotal;\r\n        }\r\n                Collections.sort(totals);\r\n        Collections.reverse(totals);\r\n        int even = total \/ totals.size();\r\n        int numServersOverEven = total % totals.size();\r\n                                                        int end = totals.size() - 1;\r\n        int movedAlready = 0;\r\n        int tooManyIndex = 0;\r\n        while (tooManyIndex < totals.size() && end > tooManyIndex) {\r\n            ServerCounts tooMany = totals.get(tooManyIndex);\r\n            int goal = even;\r\n            if (tooManyIndex < numServersOverEven) {\r\n                goal++;\r\n            }\r\n            int needToUnload = tooMany.count - goal;\r\n            ServerCounts tooLittle = totals.get(end);\r\n            int needToLoad = goal - tooLittle.count - movedAlready;\r\n            if (needToUnload < 1 && needToLoad < 1) {\r\n                break;\r\n            }\r\n            if (needToUnload >= needToLoad) {\r\n                result.addAll(move(tooMany, tooLittle, needToLoad, donerTabletStats));\r\n                end--;\r\n                movedAlready = 0;\r\n            } else {\r\n                result.addAll(move(tooMany, tooLittle, needToUnload, donerTabletStats));\r\n                movedAlready += needToUnload;\r\n            }\r\n            if (needToUnload > needToLoad) {\r\n                moreBalancingNeeded = true;\r\n            } else {\r\n                tooManyIndex++;\r\n                donerTabletStats.clear();\r\n            }\r\n        }\r\n    } finally {\r\n        log.debug(\"balance ended with \" + result.size() + \" migrations\");\r\n    }\r\n    return moreBalancingNeeded;\r\n}","lc":2.1818181818,"pi":0.9090909091,"ma":1.6,"nbd":1.0,"ml":1.5833333333,"d":3.4146825397,"mi":-1.0372093023,"fo":1.75,"r":-0.0263157895,"e":11.3601793422}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5751_bcea89fc","label":1,"code":"\/**\r\n *  Reconstitute the <tt>HashMap<\/tt> instance from a stream (i.e., deserialize it).\r\n *\r\n *  @param s\r\n *  @throws IOException\r\n *  @throws ClassNotFoundException\r\n *\/\r\n@SuppressWarnings(\"unchecked\")\r\nprivate void readObject(final java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {\r\n    \/\/ Read in the threshold, loadfactor, and any hidden stuff\r\n    s.defaultReadObject();\r\n    \/\/ Read in number of buckets and allocate the bucket array;\r\n    int numBuckets = s.readInt();\r\n    table = new Entry[numBuckets];\r\n    \/\/ Give subclass a chance to do its thing.\r\n    init();\r\n    \/\/ Read in size (number of Mappings)\r\n    int size = s.readInt();\r\n    \/\/ Read the keys and values, and put the mappings in the HashMap\r\n    for (int i = 0; i < size; i++) {\r\n        int key = s.readInt();\r\n        V value = (V) s.readObject();\r\n        putForCreate(key, value);\r\n    }\r\n}","code_comment":"\/**\r\n *  Reconstitute the <tt>HashMap<\/tt> instance from a stream (i.e., deserialize it).\r\n *\r\n *  @param s\r\n *  @throws IOException\r\n *  @throws ClassNotFoundException\r\n *\/\r\n","code_no_comment":"@SuppressWarnings(\"unchecked\")\r\nprivate void readObject(final java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {\r\n        s.defaultReadObject();\r\n        int numBuckets = s.readInt();\r\n    table = new Entry[numBuckets];\r\n        init();\r\n        int size = s.readInt();\r\n        for (int i = 0; i < size; i++) {\r\n        int key = s.readInt();\r\n        V value = (V) s.readObject();\r\n        putForCreate(key, value);\r\n    }\r\n}","lc":-0.0454545455,"pi":-0.1291866029,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0376984127,"mi":0.0052149401,"fo":0.0833333333,"r":0.5,"e":0.0019017652}
{"project_name":"Closure","project_version":"159","label":2,"code":"\/**\r\n * @see #findCalledFunctions(Node)\r\n *\/\r\nprivate void findCalledFunctions(Node node, Set<String> changed) {\r\n    Preconditions.checkArgument(changed != null);\r\n    \/\/ For each referenced function, add a new reference\r\n    if (node.getType() == Token.CALL) {\r\n        Node child = node.getFirstChild();\r\n        if (child.getType() == Token.NAME) {\r\n            changed.add(child.getString());\r\n        }\r\n    }\r\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\r\n        findCalledFunctions(c, changed);\r\n    }\r\n}","code_comment":"\/**\r\n * @see #findCalledFunctions(Node)\r\n *\/\r\n","code_no_comment":"private void findCalledFunctions(Node node, Set<String> changed) {\r\n    Preconditions.checkArgument(changed != null);\r\n        if (node.getType() == Token.CALL) {\r\n        Node child = node.getFirstChild();\r\n        if (child.getType() == Token.NAME) {\r\n            changed.add(child.getString());\r\n        }\r\n    }\r\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\r\n        findCalledFunctions(c, changed);\r\n    }\r\n}","lc":-0.0909090909,"pi":0.1961722488,"ma":0.0,"nbd":0.0,"ml":0.0833333333,"d":0.0218253968,"mi":0.0345313601,"fo":0.25,"r":0.5789473684,"e":0.0242757444}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-924_b07ecae3","label":0,"code":"\/**\r\n * Computes the square-root of the weight matrix.\r\n *\r\n * @param m Symmetric, positive-definite (weight) matrix.\r\n * @return the square-root of the weight matrix.\r\n *\/\r\nprivate RealMatrix squareRoot(RealMatrix m) {\r\n    final EigenDecomposition dec = new EigenDecomposition(m);\r\n    return dec.getSquareRoot();\r\n}","code_comment":"\/**\r\n * Computes the square-root of the weight matrix.\r\n *\r\n * @param m Symmetric, positive-definite (weight) matrix.\r\n * @return the square-root of the weight matrix.\r\n *\/\r\n","code_no_comment":"private RealMatrix squareRoot(RealMatrix m) {\r\n    final EigenDecomposition dec = new EigenDecomposition(m);\r\n    return dec.getSquareRoot();\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8128259338,"fo":-0.4166666667,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-9143_08077733","label":1,"code":"protected void doStop() throws Exception {\r\n    \/\/ when stopping we intend to shutdown\r\n    ServiceHelper.stopAndShutdownServices(statistics, pool);\r\n    try {\r\n        ServiceHelper.stopAndShutdownServices(producers.values());\r\n    } finally {\r\n        \/\/ ensure producers are removed, and also from JMX\r\n        for (Producer producer : producers.values()) {\r\n            getCamelContext().removeService(producer);\r\n        }\r\n    }\r\n    producers.clear();\r\n    if (statistics != null) {\r\n        statistics.clear();\r\n    }\r\n}","code_comment":null,"code_no_comment":"protected void doStop() throws Exception {\r\n        ServiceHelper.stopAndShutdownServices(statistics, pool);\r\n    try {\r\n        ServiceHelper.stopAndShutdownServices(producers.values());\r\n    } finally {\r\n                for (Producer producer : producers.values()) {\r\n            getCamelContext().removeService(producer);\r\n        }\r\n    }\r\n    producers.clear();\r\n    if (statistics != null) {\r\n        statistics.clear();\r\n    }\r\n}","lc":0.0,"pi":0.0909090909,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.3650793651,"mi":0.0779422128,"fo":0.1666666667,"r":0.2894736842,"e":-0.1627934049}
{"project_name":"Compress","project_version":"40","label":1,"code":"\/**\r\n * Returns at most 63 bits read from the underlying stream.\r\n *\r\n * @param count the number of bits to read, must be a positive\r\n * number not bigger than 63.\r\n * @return the bits concatenated as a long using the stream's byte order.\r\n *         -1 if the end of the underlying stream has been reached before reading\r\n *         the requested number of bits\r\n * @throws IOException on error\r\n *\/\r\npublic long readBits(final int count) throws IOException {\r\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\r\n        throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\r\n    }\r\n    while (bitsCachedSize < count) {\r\n        final long nextByte = in.read();\r\n        if (nextByte < 0) {\r\n            return nextByte;\r\n        }\r\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\r\n            bitsCached |= (nextByte << bitsCachedSize);\r\n        } else {\r\n            bitsCached <<= 8;\r\n            bitsCached |= nextByte;\r\n        }\r\n        bitsCachedSize += 8;\r\n    }\r\n    \/\/ bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\r\n    final long bitsOut;\r\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\r\n        bitsOut = (bitsCached & MASKS[count]);\r\n        bitsCached >>>= count;\r\n    } else {\r\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\r\n    }\r\n    bitsCachedSize -= count;\r\n    return bitsOut;\r\n}","code_comment":"\/**\r\n * Returns at most 63 bits read from the underlying stream.\r\n *\r\n * @param count the number of bits to read, must be a positive\r\n * number not bigger than 63.\r\n * @return the bits concatenated as a long using the stream's byte order.\r\n *         -1 if the end of the underlying stream has been reached before reading\r\n *         the requested number of bits\r\n * @throws IOException on error\r\n *\/\r\n","code_no_comment":"public long readBits(final int count) throws IOException {\r\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\r\n        throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\r\n    }\r\n    while (bitsCachedSize < count) {\r\n        final long nextByte = in.read();\r\n        if (nextByte < 0) {\r\n            return nextByte;\r\n        }\r\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\r\n            bitsCached |= (nextByte << bitsCachedSize);\r\n        } else {\r\n            bitsCached <<= 8;\r\n            bitsCached |= nextByte;\r\n        }\r\n        bitsCachedSize += 8;\r\n    }\r\n        final long bitsOut;\r\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\r\n        bitsOut = (bitsCached & MASKS[count]);\r\n        bitsCached >>>= count;\r\n    } else {\r\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\r\n    }\r\n    bitsCachedSize -= count;\r\n    return bitsOut;\r\n}","lc":0.5909090909,"pi":0.1435406699,"ma":0.6,"nbd":0.0,"ml":0.4166666667,"d":3.2896825397,"mi":-0.4381959126,"fo":-0.4166666667,"r":-0.0263157895,"e":2.9480702846}
{"project_name":"Compress","project_version":"3","label":1,"code":"\/**\r\n * Put an entry on the output stream. This writes the entry's\r\n * header record and positions the output stream for writing\r\n * the contents of the entry. Once this method is called, the\r\n * stream is ready for calls to write() to write the entry's\r\n * contents. Once the contents are written, closeArchiveEntry()\r\n * <B>MUST<\/B> be called to ensure that all buffered data\r\n * is completely written to the output stream.\r\n *\r\n * @param archiveEntry The TarEntry to be written to the archive.\r\n * @throws IOException on error\r\n * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\r\n *\/\r\npublic void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\r\n    TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\r\n    if (entry.getName().length() >= TarConstants.NAMELEN) {\r\n        if (longFileMode == LONGFILE_GNU) {\r\n            \/\/ create a TarEntry for the LongLink, the contents\r\n            \/\/ of which are the entry's name\r\n            TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, TarConstants.LF_GNUTYPE_LONGNAME);\r\n            \/\/ TODO is it correct to use the default charset here?\r\n            final byte[] nameBytes = entry.getName().getBytes();\r\n            \/\/ +1 for NUL\r\n            longLinkEntry.setSize(nameBytes.length + 1);\r\n            putArchiveEntry(longLinkEntry);\r\n            write(nameBytes);\r\n            \/\/ NUL terminator\r\n            write(0);\r\n            closeArchiveEntry();\r\n        } else if (longFileMode != LONGFILE_TRUNCATE) {\r\n            throw new RuntimeException(\"file name '\" + entry.getName() + \"' is too long ( > \" + TarConstants.NAMELEN + \" bytes)\");\r\n        }\r\n    }\r\n    entry.writeEntryHeader(recordBuf);\r\n    buffer.writeRecord(recordBuf);\r\n    currBytes = 0;\r\n    if (entry.isDirectory()) {\r\n        currSize = 0;\r\n    } else {\r\n        currSize = entry.getSize();\r\n    }\r\n    currName = entry.getName();\r\n}","code_comment":"\/**\r\n * Put an entry on the output stream. This writes the entry's\r\n * header record and positions the output stream for writing\r\n * the contents of the entry. Once this method is called, the\r\n * stream is ready for calls to write() to write the entry's\r\n * contents. Once the contents are written, closeArchiveEntry()\r\n * <B>MUST<\/B> be called to ensure that all buffered data\r\n * is completely written to the output stream.\r\n *\r\n * @param archiveEntry The TarEntry to be written to the archive.\r\n * @throws IOException on error\r\n * @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry\r\n *\/\r\n","code_no_comment":"public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\r\n    TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\r\n    if (entry.getName().length() >= TarConstants.NAMELEN) {\r\n        if (longFileMode == LONGFILE_GNU) {\r\n                                    TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK, TarConstants.LF_GNUTYPE_LONGNAME);\r\n                        final byte[] nameBytes = entry.getName().getBytes();\r\n                        longLinkEntry.setSize(nameBytes.length + 1);\r\n            putArchiveEntry(longLinkEntry);\r\n            write(nameBytes);\r\n                        write(0);\r\n            closeArchiveEntry();\r\n        } else if (longFileMode != LONGFILE_TRUNCATE) {\r\n            throw new RuntimeException(\"file name '\" + entry.getName() + \"' is too long ( > \" + TarConstants.NAMELEN + \" bytes)\");\r\n        }\r\n    }\r\n    entry.writeEntryHeader(recordBuf);\r\n    buffer.writeRecord(recordBuf);\r\n    currBytes = 0;\r\n    if (entry.isDirectory()) {\r\n        currSize = 0;\r\n    } else {\r\n        currSize = entry.getSize();\r\n    }\r\n    currName = entry.getName();\r\n}","lc":0.5,"pi":0.4641148325,"ma":0.4,"nbd":0.5,"ml":0.1666666667,"d":0.3531746032,"mi":-0.4187455955,"fo":0.75,"r":-0.0263157895,"e":0.5484852152}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * The contraction criteria defines when the internal array will contract\r\n * to store only the number of elements in the element array.\r\n * If  the <code>expansionMode<\/code> is <code>MULTIPLICATIVE_MODE<\/code>,\r\n * contraction is triggered when the ratio between storage array length\r\n * and <code>numElements<\/code> exceeds <code>contractionFactor<\/code>.\r\n * If the <code>expansionMode<\/code> is <code>ADDITIVE_MODE<\/code>, the\r\n * number of excess storage locations is compared to\r\n * <code>contractionFactor.<\/code>\r\n *\r\n * @return the contraction criteria used to reclaim memory.\r\n * @deprecated As of 3.1. Please use {@link #getContractionCriterion()}\r\n * instead.\r\n *\/\r\n@Deprecated\r\npublic float getContractionCriteria() {\r\n    return (float) getContractionCriterion();\r\n}","code_comment":"\/**\r\n * The contraction criteria defines when the internal array will contract\r\n * to store only the number of elements in the element array.\r\n * If  the <code>expansionMode<\/code> is <code>MULTIPLICATIVE_MODE<\/code>,\r\n * contraction is triggered when the ratio between storage array length\r\n * and <code>numElements<\/code> exceeds <code>contractionFactor<\/code>.\r\n * If the <code>expansionMode<\/code> is <code>ADDITIVE_MODE<\/code>, the\r\n * number of excess storage locations is compared to\r\n * <code>contractionFactor.<\/code>\r\n *\r\n * @return the contraction criteria used to reclaim memory.\r\n * @deprecated As of 3.1. Please use {@link #getContractionCriterion()}\r\n * instead.\r\n *\/\r\n","code_no_comment":"@Deprecated\r\npublic float getContractionCriteria() {\r\n    return (float) getContractionCriterion();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0332628612,"fo":-0.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1467_dde7de85","label":1,"code":"private void rollback(List<UpdateOp> newDocuments, List<UpdateOp> changed, UpdateOp commitRoot) {\r\n    DocumentStore store = nodeStore.getDocumentStore();\r\n    for (UpdateOp op : changed) {\r\n        UpdateOp reverse = op.getReverseOperation();\r\n        store.createOrUpdate(NODES, reverse);\r\n    }\r\n    for (UpdateOp op : newDocuments) {\r\n        store.remove(NODES, op.id);\r\n    }\r\n    UpdateOp removeCollision = new UpdateOp(commitRoot.getId(), false);\r\n    NodeDocument.removeCollision(removeCollision, revision);\r\n    store.createOrUpdate(NODES, removeCollision);\r\n}","code_comment":null,"code_no_comment":"private void rollback(List<UpdateOp> newDocuments, List<UpdateOp> changed, UpdateOp commitRoot) {\r\n    DocumentStore store = nodeStore.getDocumentStore();\r\n    for (UpdateOp op : changed) {\r\n        UpdateOp reverse = op.getReverseOperation();\r\n        store.createOrUpdate(NODES, reverse);\r\n    }\r\n    for (UpdateOp op : newDocuments) {\r\n        store.remove(NODES, op.id);\r\n    }\r\n    UpdateOp removeCollision = new UpdateOp(commitRoot.getId(), false);\r\n    NodeDocument.removeCollision(removeCollision, revision);\r\n    store.createOrUpdate(NODES, removeCollision);\r\n}","lc":-0.0454545455,"pi":-0.2535885167,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.0097251586,"fo":0.0833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Lang","project_version":"62","label":3,"code":"\/**\r\n * <p>Unescapes the entities in a <code>String<\/code>.<\/p>\r\n *\r\n * <p>For example, if you have called addEntity(&quot;foo&quot;, 0xA1),\r\n * unescape(&quot;&amp;foo;&quot;) will return &quot;\\u00A1&quot;<\/p>\r\n *\r\n * @param str The <code>String<\/code> to escape.\r\n * @return A new escaped <code>String<\/code>.\r\n *\/\r\npublic String unescape(String str) {\r\n    int firstAmp = str.indexOf('&');\r\n    if (firstAmp < 0) {\r\n        return str;\r\n    }\r\n    StringBuffer buf = new StringBuffer(str.length());\r\n    buf.append(str.substring(0, firstAmp));\r\n    for (int i = firstAmp; i < str.length(); ++i) {\r\n        char ch = str.charAt(i);\r\n        if (ch == '&') {\r\n            int semi = str.indexOf(';', i + 1);\r\n            if (semi == -1) {\r\n                buf.append(ch);\r\n                continue;\r\n            }\r\n            int amph = str.indexOf('&', i + 1);\r\n            if (amph != -1 && amph < semi) {\r\n                \/\/ Then the text looks like &...&...;\r\n                buf.append(ch);\r\n                continue;\r\n            }\r\n            String entityName = str.substring(i + 1, semi);\r\n            int entityValue;\r\n            if (entityName.length() == 0) {\r\n                entityValue = -1;\r\n            } else if (entityName.charAt(0) == '#') {\r\n                if (entityName.length() == 1) {\r\n                    entityValue = -1;\r\n                } else {\r\n                    char charAt1 = entityName.charAt(1);\r\n                    try {\r\n                        if (charAt1 == 'x' || charAt1 == 'X') {\r\n                            entityValue = Integer.valueOf(entityName.substring(2), 16).intValue();\r\n                        } else {\r\n                            entityValue = Integer.parseInt(entityName.substring(1));\r\n                        }\r\n                    } catch (NumberFormatException ex) {\r\n                        entityValue = -1;\r\n                    }\r\n                }\r\n            } else {\r\n                entityValue = this.entityValue(entityName);\r\n            }\r\n            if (entityValue == -1) {\r\n                buf.append('&');\r\n                buf.append(entityName);\r\n                buf.append(';');\r\n            } else {\r\n                buf.append((char) (entityValue));\r\n            }\r\n            i = semi;\r\n        } else {\r\n            buf.append(ch);\r\n        }\r\n    }\r\n    return buf.toString();\r\n}","code_comment":"\/**\r\n * <p>Unescapes the entities in a <code>String<\/code>.<\/p>\r\n *\r\n * <p>For example, if you have called addEntity(&quot;foo&quot;, 0xA1),\r\n * unescape(&quot;&amp;foo;&quot;) will return &quot;\\u00A1&quot;<\/p>\r\n *\r\n * @param str The <code>String<\/code> to escape.\r\n * @return A new escaped <code>String<\/code>.\r\n *\/\r\n","code_no_comment":"public String unescape(String str) {\r\n    int firstAmp = str.indexOf('&');\r\n    if (firstAmp < 0) {\r\n        return str;\r\n    }\r\n    StringBuffer buf = new StringBuffer(str.length());\r\n    buf.append(str.substring(0, firstAmp));\r\n    for (int i = firstAmp; i < str.length(); ++i) {\r\n        char ch = str.charAt(i);\r\n        if (ch == '&') {\r\n            int semi = str.indexOf(';', i + 1);\r\n            if (semi == -1) {\r\n                buf.append(ch);\r\n                continue;\r\n            }\r\n            int amph = str.indexOf('&', i + 1);\r\n            if (amph != -1 && amph < semi) {\r\n                                buf.append(ch);\r\n                continue;\r\n            }\r\n            String entityName = str.substring(i + 1, semi);\r\n            int entityValue;\r\n            if (entityName.length() == 0) {\r\n                entityValue = -1;\r\n            } else if (entityName.charAt(0) == '#') {\r\n                if (entityName.length() == 1) {\r\n                    entityValue = -1;\r\n                } else {\r\n                    char charAt1 = entityName.charAt(1);\r\n                    try {\r\n                        if (charAt1 == 'x' || charAt1 == 'X') {\r\n                            entityValue = Integer.valueOf(entityName.substring(2), 16).intValue();\r\n                        } else {\r\n                            entityValue = Integer.parseInt(entityName.substring(1));\r\n                        }\r\n                    } catch (NumberFormatException ex) {\r\n                        entityValue = -1;\r\n                    }\r\n                }\r\n            } else {\r\n                entityValue = this.entityValue(entityName);\r\n            }\r\n            if (entityValue == -1) {\r\n                buf.append('&');\r\n                buf.append(entityName);\r\n                buf.append(';');\r\n            } else {\r\n                buf.append((char) (entityValue));\r\n            }\r\n            i = semi;\r\n        } else {\r\n            buf.append(ch);\r\n        }\r\n    }\r\n    return buf.toString();\r\n}","lc":1.9090909091,"pi":1.7177033493,"ma":2.0,"nbd":2.5,"ml":1.4166666667,"d":2.6051587302,"mi":-0.9529245948,"fo":1.75,"r":-0.0263157895,"e":6.2432876333}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-846_7acb091a","label":3,"code":"\/**\r\n * Callback for an uncommitted modification in {@link Revision}\r\n * <code>uncommitted<\/code>.\r\n *\r\n * @param uncommitted the uncommitted revision of the change.\r\n *\/\r\nabstract void uncommittedModification(Revision uncommitted);","code_comment":"\/**\r\n * Callback for an uncommitted modification in {@link Revision}\r\n * <code>uncommitted<\/code>.\r\n *\r\n * @param uncommitted the uncommitted revision of the change.\r\n *\/\r\n","code_no_comment":"abstract void uncommittedModification(Revision uncommitted);","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.666384778,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5727_ce6f0bfd","label":1,"code":"private void initProject(MavenProject project, Map<String, MavenProject> projects, ModelBuildingResult result, Map<File, Boolean> profilesXmls, ProjectBuildingRequest projectBuildingRequest) {\r\n    Model model = result.getEffectiveModel();\r\n    project.setModel(model);\r\n    project.setOriginalModel(result.getRawModel());\r\n    project.setFile(model.getPomFile());\r\n    Parent p = model.getParent();\r\n    if (p != null) {\r\n        project.setParentArtifact(repositorySystem.createProjectArtifact(p.getGroupId(), p.getArtifactId(), p.getVersion()));\r\n        \/\/ org.apache.maven.its.mng4834:parent:0.1\r\n        String parentModelId = result.getModelIds().get(1);\r\n        File parentPomFile = result.getRawModel(parentModelId).getPomFile();\r\n        MavenProject parent = projects.get(parentModelId);\r\n        if (parent == null) {\r\n            \/\/ \r\n            \/\/ At this point the DefaultModelBuildingListener has fired and it populates the\r\n            \/\/ remote repositories with those found in the pom.xml, along with the existing externally\r\n            \/\/ defined repositories.\r\n            \/\/ \r\n            projectBuildingRequest.setRemoteRepositories(project.getRemoteArtifactRepositories());\r\n            if (parentPomFile != null) {\r\n                project.setParentFile(parentPomFile);\r\n                try {\r\n                    parent = build(parentPomFile, projectBuildingRequest).getProject();\r\n                } catch (ProjectBuildingException e) {\r\n                    \/\/ MNG-4488 where let invalid parents slide on by\r\n                    logger.warn(\"Failed to build parent project for \" + project.getId());\r\n                }\r\n            } else {\r\n                Artifact parentArtifact = project.getParentArtifact();\r\n                try {\r\n                    parent = build(parentArtifact, projectBuildingRequest).getProject();\r\n                } catch (ProjectBuildingException e) {\r\n                    \/\/ MNG-4488 where let invalid parents slide on by\r\n                    logger.warn(\"Failed to build parent project for \" + project.getId());\r\n                }\r\n            }\r\n        }\r\n        project.setParent(parent);\r\n    }\r\n    Artifact projectArtifact = repositorySystem.createArtifact(project.getGroupId(), project.getArtifactId(), project.getVersion(), null, project.getPackaging());\r\n    project.setArtifact(projectArtifact);\r\n    if (project.getFile() != null) {\r\n        Build build = project.getBuild();\r\n        project.addScriptSourceRoot(build.getScriptSourceDirectory());\r\n        project.addCompileSourceRoot(build.getSourceDirectory());\r\n        project.addTestCompileSourceRoot(build.getTestSourceDirectory());\r\n    }\r\n    List<Profile> activeProfiles = new ArrayList<Profile>();\r\n    activeProfiles.addAll(result.getActivePomProfiles(result.getModelIds().get(0)));\r\n    activeProfiles.addAll(result.getActiveExternalProfiles());\r\n    project.setActiveProfiles(activeProfiles);\r\n    project.setInjectedProfileIds(\"external\", getProfileIds(result.getActiveExternalProfiles()));\r\n    for (String modelId : result.getModelIds()) {\r\n        project.setInjectedProfileIds(modelId, getProfileIds(result.getActivePomProfiles(modelId)));\r\n    }\r\n    String modelId = findProfilesXml(result, profilesXmls);\r\n    if (modelId != null) {\r\n        ModelProblem problem = new DefaultModelProblem(\"Detected profiles.xml alongside \" + modelId + \", this file is no longer supported and was ignored\" + \", please use the settings.xml instead\", ModelProblem.Severity.WARNING, ModelProblem.Version.V30, model, -1, -1, null);\r\n        result.getProblems().add(problem);\r\n    }\r\n    \/\/ \r\n    \/\/ All the parts that were taken out of MavenProject for Maven 4.0.0\r\n    \/\/ \r\n    project.setProjectBuildingRequest(projectBuildingRequest);\r\n    \/\/ pluginArtifacts\r\n    Set<Artifact> pluginArtifacts = new HashSet<Artifact>();\r\n    for (Plugin plugin : project.getBuildPlugins()) {\r\n        Artifact artifact = repositorySystem.createPluginArtifact(plugin);\r\n        if (artifact != null) {\r\n            pluginArtifacts.add(artifact);\r\n        }\r\n    }\r\n    project.setPluginArtifacts(pluginArtifacts);\r\n    \/\/ reportArtifacts\r\n    Set<Artifact> reportArtifacts = new HashSet<Artifact>();\r\n    for (ReportPlugin report : project.getReportPlugins()) {\r\n        Plugin pp = new Plugin();\r\n        pp.setGroupId(report.getGroupId());\r\n        pp.setArtifactId(report.getArtifactId());\r\n        pp.setVersion(report.getVersion());\r\n        Artifact artifact = repositorySystem.createPluginArtifact(pp);\r\n        if (artifact != null) {\r\n            reportArtifacts.add(artifact);\r\n        }\r\n    }\r\n    project.setReportArtifacts(reportArtifacts);\r\n    \/\/ extensionArtifacts\r\n    Set<Artifact> extensionArtifacts = new HashSet<Artifact>();\r\n    List<Extension> extensions = project.getBuildExtensions();\r\n    if (extensions != null) {\r\n        for (Extension ext : extensions) {\r\n            String version;\r\n            if (StringUtils.isEmpty(ext.getVersion())) {\r\n                version = \"RELEASE\";\r\n            } else {\r\n                version = ext.getVersion();\r\n            }\r\n            Artifact artifact = repositorySystem.createArtifact(ext.getGroupId(), ext.getArtifactId(), version, null, \"jar\");\r\n            if (artifact != null) {\r\n                extensionArtifacts.add(artifact);\r\n            }\r\n        }\r\n    }\r\n    project.setExtensionArtifacts(extensionArtifacts);\r\n    \/\/ managedVersionMap\r\n    Map<String, Artifact> map = null;\r\n    if (repositorySystem != null) {\r\n        List<Dependency> deps;\r\n        DependencyManagement dependencyManagement = project.getDependencyManagement();\r\n        if ((dependencyManagement != null) && ((deps = dependencyManagement.getDependencies()) != null) && (deps.size() > 0)) {\r\n            map = new HashMap<String, Artifact>();\r\n            for (Dependency d : dependencyManagement.getDependencies()) {\r\n                Artifact artifact = repositorySystem.createDependencyArtifact(d);\r\n                if (artifact == null) {\r\n                    map = Collections.emptyMap();\r\n                }\r\n                map.put(d.getManagementKey(), artifact);\r\n            }\r\n        } else {\r\n            map = Collections.emptyMap();\r\n        }\r\n    }\r\n    project.setManagedVersionMap(map);\r\n    \/\/ release artifact repository\r\n    if (project.getDistributionManagement() != null && project.getDistributionManagement().getRepository() != null) {\r\n        try {\r\n            DeploymentRepository r = project.getDistributionManagement().getRepository();\r\n            if (!StringUtils.isEmpty(r.getId()) && !StringUtils.isEmpty(r.getUrl())) {\r\n                ArtifactRepository repo = repositorySystem.buildArtifactRepository(project.getDistributionManagement().getRepository());\r\n                repositorySystem.injectProxy(projectBuildingRequest.getRepositorySession(), Arrays.asList(repo));\r\n                repositorySystem.injectAuthentication(projectBuildingRequest.getRepositorySession(), Arrays.asList(repo));\r\n                project.setReleaseArtifactRepository(repo);\r\n            }\r\n        } catch (InvalidRepositoryException e) {\r\n            throw new IllegalStateException(\"Failed to create release distribution repository for \" + project.getId(), e);\r\n        }\r\n    }\r\n    \/\/ snapshot artifact repository\r\n    if (project.getDistributionManagement() != null && project.getDistributionManagement().getSnapshotRepository() != null) {\r\n        try {\r\n            DeploymentRepository r = project.getDistributionManagement().getSnapshotRepository();\r\n            if (!StringUtils.isEmpty(r.getId()) && !StringUtils.isEmpty(r.getUrl())) {\r\n                ArtifactRepository repo = repositorySystem.buildArtifactRepository(project.getDistributionManagement().getSnapshotRepository());\r\n                repositorySystem.injectProxy(projectBuildingRequest.getRepositorySession(), Arrays.asList(repo));\r\n                repositorySystem.injectAuthentication(projectBuildingRequest.getRepositorySession(), Arrays.asList(repo));\r\n                project.setSnapshotArtifactRepository(repo);\r\n            }\r\n        } catch (InvalidRepositoryException e) {\r\n            throw new IllegalStateException(\"Failed to create snapshot distribution repository for \" + project.getId(), e);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void initProject(MavenProject project, Map<String, MavenProject> projects, ModelBuildingResult result, Map<File, Boolean> profilesXmls, ProjectBuildingRequest projectBuildingRequest) {\r\n    Model model = result.getEffectiveModel();\r\n    project.setModel(model);\r\n    project.setOriginalModel(result.getRawModel());\r\n    project.setFile(model.getPomFile());\r\n    Parent p = model.getParent();\r\n    if (p != null) {\r\n        project.setParentArtifact(repositorySystem.createProjectArtifact(p.getGroupId(), p.getArtifactId(), p.getVersion()));\r\n                String parentModelId = result.getModelIds().get(1);\r\n        File parentPomFile = result.getRawModel(parentModelId).getPomFile();\r\n        MavenProject parent = projects.get(parentModelId);\r\n        if (parent == null) {\r\n                                                                        projectBuildingRequest.setRemoteRepositories(project.getRemoteArtifactRepositories());\r\n            if (parentPomFile != null) {\r\n                project.setParentFile(parentPomFile);\r\n                try {\r\n                    parent = build(parentPomFile, projectBuildingRequest).getProject();\r\n                } catch (ProjectBuildingException e) {\r\n                                        logger.warn(\"Failed to build parent project for \" + project.getId());\r\n                }\r\n            } else {\r\n                Artifact parentArtifact = project.getParentArtifact();\r\n                try {\r\n                    parent = build(parentArtifact, projectBuildingRequest).getProject();\r\n                } catch (ProjectBuildingException e) {\r\n                                        logger.warn(\"Failed to build parent project for \" + project.getId());\r\n                }\r\n            }\r\n        }\r\n        project.setParent(parent);\r\n    }\r\n    Artifact projectArtifact = repositorySystem.createArtifact(project.getGroupId(), project.getArtifactId(), project.getVersion(), null, project.getPackaging());\r\n    project.setArtifact(projectArtifact);\r\n    if (project.getFile() != null) {\r\n        Build build = project.getBuild();\r\n        project.addScriptSourceRoot(build.getScriptSourceDirectory());\r\n        project.addCompileSourceRoot(build.getSourceDirectory());\r\n        project.addTestCompileSourceRoot(build.getTestSourceDirectory());\r\n    }\r\n    List<Profile> activeProfiles = new ArrayList<Profile>();\r\n    activeProfiles.addAll(result.getActivePomProfiles(result.getModelIds().get(0)));\r\n    activeProfiles.addAll(result.getActiveExternalProfiles());\r\n    project.setActiveProfiles(activeProfiles);\r\n    project.setInjectedProfileIds(\"external\", getProfileIds(result.getActiveExternalProfiles()));\r\n    for (String modelId : result.getModelIds()) {\r\n        project.setInjectedProfileIds(modelId, getProfileIds(result.getActivePomProfiles(modelId)));\r\n    }\r\n    String modelId = findProfilesXml(result, profilesXmls);\r\n    if (modelId != null) {\r\n        ModelProblem problem = new DefaultModelProblem(\"Detected profiles.xml alongside \" + modelId + \", this file is no longer supported and was ignored\" + \", please use the settings.xml instead\", ModelProblem.Severity.WARNING, ModelProblem.Version.V30, model, -1, -1, null);\r\n        result.getProblems().add(problem);\r\n    }\r\n                project.setProjectBuildingRequest(projectBuildingRequest);\r\n        Set<Artifact> pluginArtifacts = new HashSet<Artifact>();\r\n    for (Plugin plugin : project.getBuildPlugins()) {\r\n        Artifact artifact = repositorySystem.createPluginArtifact(plugin);\r\n        if (artifact != null) {\r\n            pluginArtifacts.add(artifact);\r\n        }\r\n    }\r\n    project.setPluginArtifacts(pluginArtifacts);\r\n        Set<Artifact> reportArtifacts = new HashSet<Artifact>();\r\n    for (ReportPlugin report : project.getReportPlugins()) {\r\n        Plugin pp = new Plugin();\r\n        pp.setGroupId(report.getGroupId());\r\n        pp.setArtifactId(report.getArtifactId());\r\n        pp.setVersion(report.getVersion());\r\n        Artifact artifact = repositorySystem.createPluginArtifact(pp);\r\n        if (artifact != null) {\r\n            reportArtifacts.add(artifact);\r\n        }\r\n    }\r\n    project.setReportArtifacts(reportArtifacts);\r\n        Set<Artifact> extensionArtifacts = new HashSet<Artifact>();\r\n    List<Extension> extensions = project.getBuildExtensions();\r\n    if (extensions != null) {\r\n        for (Extension ext : extensions) {\r\n            String version;\r\n            if (StringUtils.isEmpty(ext.getVersion())) {\r\n                version = \"RELEASE\";\r\n            } else {\r\n                version = ext.getVersion();\r\n            }\r\n            Artifact artifact = repositorySystem.createArtifact(ext.getGroupId(), ext.getArtifactId(), version, null, \"jar\");\r\n            if (artifact != null) {\r\n                extensionArtifacts.add(artifact);\r\n            }\r\n        }\r\n    }\r\n    project.setExtensionArtifacts(extensionArtifacts);\r\n        Map<String, Artifact> map = null;\r\n    if (repositorySystem != null) {\r\n        List<Dependency> deps;\r\n        DependencyManagement dependencyManagement = project.getDependencyManagement();\r\n        if ((dependencyManagement != null) && ((deps = dependencyManagement.getDependencies()) != null) && (deps.size() > 0)) {\r\n            map = new HashMap<String, Artifact>();\r\n            for (Dependency d : dependencyManagement.getDependencies()) {\r\n                Artifact artifact = repositorySystem.createDependencyArtifact(d);\r\n                if (artifact == null) {\r\n                    map = Collections.emptyMap();\r\n                }\r\n                map.put(d.getManagementKey(), artifact);\r\n            }\r\n        } else {\r\n            map = Collections.emptyMap();\r\n        }\r\n    }\r\n    project.setManagedVersionMap(map);\r\n        if (project.getDistributionManagement() != null && project.getDistributionManagement().getRepository() != null) {\r\n        try {\r\n            DeploymentRepository r = project.getDistributionManagement().getRepository();\r\n            if (!StringUtils.isEmpty(r.getId()) && !StringUtils.isEmpty(r.getUrl())) {\r\n                ArtifactRepository repo = repositorySystem.buildArtifactRepository(project.getDistributionManagement().getRepository());\r\n                repositorySystem.injectProxy(projectBuildingRequest.getRepositorySession(), Arrays.asList(repo));\r\n                repositorySystem.injectAuthentication(projectBuildingRequest.getRepositorySession(), Arrays.asList(repo));\r\n                project.setReleaseArtifactRepository(repo);\r\n            }\r\n        } catch (InvalidRepositoryException e) {\r\n            throw new IllegalStateException(\"Failed to create release distribution repository for \" + project.getId(), e);\r\n        }\r\n    }\r\n        if (project.getDistributionManagement() != null && project.getDistributionManagement().getSnapshotRepository() != null) {\r\n        try {\r\n            DeploymentRepository r = project.getDistributionManagement().getSnapshotRepository();\r\n            if (!StringUtils.isEmpty(r.getId()) && !StringUtils.isEmpty(r.getUrl())) {\r\n                ArtifactRepository repo = repositorySystem.buildArtifactRepository(project.getDistributionManagement().getSnapshotRepository());\r\n                repositorySystem.injectProxy(projectBuildingRequest.getRepositorySession(), Arrays.asList(repo));\r\n                repositorySystem.injectAuthentication(projectBuildingRequest.getRepositorySession(), Arrays.asList(repo));\r\n                project.setSnapshotArtifactRepository(repo);\r\n            }\r\n        } catch (InvalidRepositoryException e) {\r\n            throw new IllegalStateException(\"Failed to create snapshot distribution repository for \" + project.getId(), e);\r\n        }\r\n    }\r\n}","lc":5.5,"pi":0.9090909091,"ma":5.0,"nbd":1.0,"ml":3.0833333333,"d":1.9801587302,"mi":-1.6641296688,"fo":10.75,"r":-0.0263157895,"e":21.3437596169}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5137_afa1d132","label":3,"code":"@Override\r\nprotected void doStart() throws Exception {\r\n    task = new TimerTask() {\r\n\r\n        \/\/ counter\r\n        private final AtomicLong counter = new AtomicLong();\r\n\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                long count = counter.incrementAndGet();\r\n                boolean fire = endpoint.getRepeatCount() <= 0 || count <= endpoint.getRepeatCount();\r\n                if (fire) {\r\n                    sendTimerExchange(count);\r\n                } else {\r\n                    \/\/ no need to fire anymore as we exceeded repeat count\r\n                    LOG.debug(\"Cancelling {} timer as repeat count limit reached after {} counts.\", endpoint.getTimerName(), endpoint.getRepeatCount());\r\n                    cancel();\r\n                }\r\n            } catch (Throwable e) {\r\n                \/\/ catch all to avoid the JVM closing the thread and not firing again\r\n                LOG.warn(\"Error processing exchange. This exception will be ignored, to let the timer be able to trigger again.\", e);\r\n            }\r\n        }\r\n    };\r\n    Timer timer = endpoint.getTimer();\r\n    configureTask(task, timer);\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void doStart() throws Exception {\r\n    task = new TimerTask() {\r\n\r\n                private final AtomicLong counter = new AtomicLong();\r\n\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                long count = counter.incrementAndGet();\r\n                boolean fire = endpoint.getRepeatCount() <= 0 || count <= endpoint.getRepeatCount();\r\n                if (fire) {\r\n                    sendTimerExchange(count);\r\n                } else {\r\n                                        LOG.debug(\"Cancelling {} timer as repeat count limit reached after {} counts.\", endpoint.getTimerName(), endpoint.getRepeatCount());\r\n                    cancel();\r\n                }\r\n            } catch (Throwable e) {\r\n                                LOG.warn(\"Error processing exchange. This exception will be ignored, to let the timer be able to trigger again.\", e);\r\n            }\r\n        }\r\n    };\r\n    Timer timer = endpoint.getTimer();\r\n    configureTask(task, timer);\r\n}","lc":0.4090909091,"pi":1.6985645933,"ma":-0.2,"nbd":0.5,"ml":-0.25,"d":-0.0575396825,"mi":-0.2916138125,"fo":0.4166666667,"r":0.0263157895,"e":0.0267883796}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5613_bef7fac6","label":1,"code":"\/\/ \r\n\/\/ 1) Setup initial properties.\r\n\/\/ \r\n\/\/ 2) Validate local repository directory is accessible.\r\n\/\/ \r\n\/\/ 3) Create RepositorySystemSession.\r\n\/\/ \r\n\/\/ 4) Create MavenSession.\r\n\/\/ \r\n\/\/ 5) Execute AbstractLifecycleParticipant.afterSessionStart(session)\r\n\/\/ \r\n\/\/ 6) Get reactor projects looking for general POM errors\r\n\/\/ \r\n\/\/ 7) Create ProjectDependencyGraph using trimming which takes into account --projects and reactor mode. This ensures\r\n\/\/ that the projects passed into the ReactorReader are only those specified.\r\n\/\/ \r\n\/\/ 8) Create ReactorReader with the getProjectMap( projects ). NOTE that getProjectMap(projects) is the code that\r\n\/\/ checks for duplicate projects definitions in the build. Ideally this type of duplicate checking should be part of\r\n\/\/ getting the reactor projects in 6). The duplicate checking is conflated with getProjectMap(projects).\r\n\/\/ \r\n\/\/ 9) Execute AbstractLifecycleParticipant.afterProjectsRead(session)\r\n\/\/ \r\n\/\/ 10) Create ProjectDependencyGraph without trimming (as trimming was done in 7). A new topological sort is required after\r\n\/\/ the execution of 9) as the AbstractLifecycleParticipants are free to mutate the MavenProject instances, which may change\r\n\/\/ dependencies which can, in turn, affect the build order.\r\n\/\/ \r\n\/\/ 11) Execute LifecycleStarter.start()\r\n\/\/ \r\nprivate MavenExecutionResult doExecute(MavenExecutionRequest request) {\r\n    if (request.getStartTime() != null) {\r\n        request.getSystemProperties().put(\"${build.timestamp}\", new SimpleDateFormat(\"yyyyMMdd-hhmm\").format(request.getStartTime()));\r\n    }\r\n    request.setStartTime(new Date());\r\n    MavenExecutionResult result = new DefaultMavenExecutionResult();\r\n    try {\r\n        validateLocalRepository(request);\r\n    } catch (LocalRepositoryNotAccessibleException e) {\r\n        return addExceptionToResult(result, e);\r\n    }\r\n    DefaultRepositorySystemSession repoSession = (DefaultRepositorySystemSession) newRepositorySession(request);\r\n    MavenSession session = new MavenSession(container, repoSession, request, result);\r\n    legacySupport.setSession(session);\r\n    try {\r\n        for (AbstractMavenLifecycleParticipant listener : getLifecycleParticipants(Collections.<MavenProject>emptyList())) {\r\n            listener.afterSessionStart(session);\r\n        }\r\n    } catch (MavenExecutionException e) {\r\n        return addExceptionToResult(result, e);\r\n    }\r\n    eventCatapult.fire(ExecutionEvent.Type.ProjectDiscoveryStarted, session, null);\r\n    List<MavenProject> projects;\r\n    try {\r\n        projects = getProjectsForMavenReactor(session);\r\n        \/\/ \r\n        \/\/ Capture the full set of projects before any potential constraining is performed by --projects\r\n        \/\/ \r\n        session.setAllProjects(projects);\r\n    } catch (ProjectBuildingException e) {\r\n        return addExceptionToResult(result, e);\r\n    }\r\n    validateProjects(projects);\r\n    \/\/ \r\n    \/\/ This creates the graph and trims the projects down based on the user request using something like:\r\n    \/\/ \r\n    \/\/ -pl project0,project2 eclipse:eclipse\r\n    \/\/ \r\n    ProjectDependencyGraph projectDependencyGraph = createProjectDependencyGraph(projects, request, result, true);\r\n    session.setProjects(projectDependencyGraph.getSortedProjects());\r\n    if (result.hasExceptions()) {\r\n        return result;\r\n    }\r\n    try {\r\n        session.setProjectMap(getProjectMap(session.getProjects()));\r\n    } catch (DuplicateProjectException e) {\r\n        return addExceptionToResult(result, e);\r\n    }\r\n    WorkspaceReader reactorWorkspace;\r\n    sessionScope.enter();\r\n    sessionScope.seed(MavenSession.class, session);\r\n    try {\r\n        reactorWorkspace = container.lookup(WorkspaceReader.class, ReactorReader.HINT);\r\n    } catch (ComponentLookupException e) {\r\n        return addExceptionToResult(result, e);\r\n    }\r\n    \/\/ \r\n    \/\/ Desired order of precedence for local artifact repositories\r\n    \/\/ \r\n    \/\/ Reactor\r\n    \/\/ Workspace\r\n    \/\/ User Local Repository\r\n    \/\/ \r\n    repoSession.setWorkspaceReader(ChainedWorkspaceReader.newInstance(reactorWorkspace, repoSession.getWorkspaceReader()));\r\n    repoSession.setReadOnly();\r\n    ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();\r\n    try {\r\n        for (AbstractMavenLifecycleParticipant listener : getLifecycleParticipants(projects)) {\r\n            Thread.currentThread().setContextClassLoader(listener.getClass().getClassLoader());\r\n            listener.afterProjectsRead(session);\r\n        }\r\n    } catch (MavenExecutionException e) {\r\n        return addExceptionToResult(result, e);\r\n    } finally {\r\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\r\n    }\r\n    \/\/ \r\n    \/\/ The projects need to be topologically after the participants have run their afterProjectsRead(session)\r\n    \/\/ because the participant is free to change the dependencies of a project which can potentially change the\r\n    \/\/ topological order of the projects, and therefore can potentially change the build order.\r\n    \/\/ \r\n    \/\/ Note that participants may affect the topological order of the projects but it is\r\n    \/\/ not expected that a participant will add or remove projects from the session.\r\n    \/\/ \r\n    projectDependencyGraph = createProjectDependencyGraph(session.getProjects(), request, result, false);\r\n    if (result.hasExceptions()) {\r\n        try {\r\n            afterSessionEnd(projects, session);\r\n        } catch (MavenExecutionException e) {\r\n            return addExceptionToResult(result, e);\r\n        }\r\n        return result;\r\n    }\r\n    session.setProjects(projectDependencyGraph.getSortedProjects());\r\n    session.setProjectDependencyGraph(projectDependencyGraph);\r\n    result.setTopologicallySortedProjects(session.getProjects());\r\n    result.setProject(session.getTopLevelProject());\r\n    lifecycleStarter.execute(session);\r\n    validateActivatedProfiles(session.getProjects(), request.getActiveProfiles());\r\n    if (session.getResult().hasExceptions()) {\r\n        return addExceptionToResult(result, session.getResult().getExceptions().get(0));\r\n    }\r\n    try {\r\n        afterSessionEnd(projects, session);\r\n    } catch (MavenExecutionException e) {\r\n        return addExceptionToResult(result, e);\r\n    }\r\n    sessionScope.exit();\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"private MavenExecutionResult doExecute(MavenExecutionRequest request) {\r\n    if (request.getStartTime() != null) {\r\n        request.getSystemProperties().put(\"${build.timestamp}\", new SimpleDateFormat(\"yyyyMMdd-hhmm\").format(request.getStartTime()));\r\n    }\r\n    request.setStartTime(new Date());\r\n    MavenExecutionResult result = new DefaultMavenExecutionResult();\r\n    try {\r\n        validateLocalRepository(request);\r\n    } catch (LocalRepositoryNotAccessibleException e) {\r\n        return addExceptionToResult(result, e);\r\n    }\r\n    DefaultRepositorySystemSession repoSession = (DefaultRepositorySystemSession) newRepositorySession(request);\r\n    MavenSession session = new MavenSession(container, repoSession, request, result);\r\n    legacySupport.setSession(session);\r\n    try {\r\n        for (AbstractMavenLifecycleParticipant listener : getLifecycleParticipants(Collections.<MavenProject>emptyList())) {\r\n            listener.afterSessionStart(session);\r\n        }\r\n    } catch (MavenExecutionException e) {\r\n        return addExceptionToResult(result, e);\r\n    }\r\n    eventCatapult.fire(ExecutionEvent.Type.ProjectDiscoveryStarted, session, null);\r\n    List<MavenProject> projects;\r\n    try {\r\n        projects = getProjectsForMavenReactor(session);\r\n                                session.setAllProjects(projects);\r\n    } catch (ProjectBuildingException e) {\r\n        return addExceptionToResult(result, e);\r\n    }\r\n    validateProjects(projects);\r\n                        ProjectDependencyGraph projectDependencyGraph = createProjectDependencyGraph(projects, request, result, true);\r\n    session.setProjects(projectDependencyGraph.getSortedProjects());\r\n    if (result.hasExceptions()) {\r\n        return result;\r\n    }\r\n    try {\r\n        session.setProjectMap(getProjectMap(session.getProjects()));\r\n    } catch (DuplicateProjectException e) {\r\n        return addExceptionToResult(result, e);\r\n    }\r\n    WorkspaceReader reactorWorkspace;\r\n    sessionScope.enter();\r\n    sessionScope.seed(MavenSession.class, session);\r\n    try {\r\n        reactorWorkspace = container.lookup(WorkspaceReader.class, ReactorReader.HINT);\r\n    } catch (ComponentLookupException e) {\r\n        return addExceptionToResult(result, e);\r\n    }\r\n                                repoSession.setWorkspaceReader(ChainedWorkspaceReader.newInstance(reactorWorkspace, repoSession.getWorkspaceReader()));\r\n    repoSession.setReadOnly();\r\n    ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();\r\n    try {\r\n        for (AbstractMavenLifecycleParticipant listener : getLifecycleParticipants(projects)) {\r\n            Thread.currentThread().setContextClassLoader(listener.getClass().getClassLoader());\r\n            listener.afterProjectsRead(session);\r\n        }\r\n    } catch (MavenExecutionException e) {\r\n        return addExceptionToResult(result, e);\r\n    } finally {\r\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\r\n    }\r\n                                    projectDependencyGraph = createProjectDependencyGraph(session.getProjects(), request, result, false);\r\n    if (result.hasExceptions()) {\r\n        try {\r\n            afterSessionEnd(projects, session);\r\n        } catch (MavenExecutionException e) {\r\n            return addExceptionToResult(result, e);\r\n        }\r\n        return result;\r\n    }\r\n    session.setProjects(projectDependencyGraph.getSortedProjects());\r\n    session.setProjectDependencyGraph(projectDependencyGraph);\r\n    result.setTopologicallySortedProjects(session.getProjects());\r\n    result.setProject(session.getTopLevelProject());\r\n    lifecycleStarter.execute(session);\r\n    validateActivatedProfiles(session.getProjects(), request.getActiveProfiles());\r\n    if (session.getResult().hasExceptions()) {\r\n        return addExceptionToResult(result, session.getResult().getExceptions().get(0));\r\n    }\r\n    try {\r\n        afterSessionEnd(projects, session);\r\n    } catch (MavenExecutionException e) {\r\n        return addExceptionToResult(result, e);\r\n    }\r\n    sessionScope.exit();\r\n    return result;\r\n}","lc":3.3181818182,"pi":-0.2248803828,"ma":2.2,"nbd":0.0,"ml":0.1666666667,"d":0.0912698413,"mi":-1.2348132488,"fo":5.4166666667,"r":-0.0263157895,"e":1.467348997}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2172_ea4a3f8a","label":3,"code":"\/**\r\n *  @see IValueMap#getAsTime(String, Time)\r\n *\/\r\npublic Time getAsTime(String key, Time defaultValue) {\r\n    if (!containsKey(key))\r\n        return defaultValue;\r\n    try {\r\n        return getTime(key);\r\n    } catch (StringValueConversionException ignored) {\r\n        return defaultValue;\r\n    }\r\n}","code_comment":"\/**\r\n *  @see IValueMap#getAsTime(String, Time)\r\n *\/\r\n","code_no_comment":"public Time getAsTime(String key, Time defaultValue) {\r\n    if (!containsKey(key))\r\n        return defaultValue;\r\n    try {\r\n        return getTime(key);\r\n    } catch (StringValueConversionException ignored) {\r\n        return defaultValue;\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.3663143058,"fo":-0.3333333333,"r":2.2105263158,"e":-0.1627934049}
{"project_name":"Closure","project_version":"171","label":2,"code":"\/**\r\n * Determines whether a qualified name is inferred.\r\n * NOTE(nicksantos): Determining whether a property is declared or not\r\n * is really really obnoxious.\r\n *\r\n * The problem is that there are two (equally valid) coding styles:\r\n *\r\n * (function() {\r\n *   \/* The authoritative definition of goog.bar. \/\r\n *   goog.bar = function() {};\r\n * })();\r\n *\r\n * function f() {\r\n *   goog.bar();\r\n *   \/* Reset goog.bar to a no-op. \/\r\n *   goog.bar = function() {};\r\n * }\r\n *\r\n * In a dynamic language with first-class functions, it's very difficult\r\n * to know which one the user intended without looking at lots of\r\n * contextual information (the second example demonstrates a small case\r\n * of this, but there are some really pathological cases as well).\r\n *\r\n * The current algorithm checks if either the declaration has\r\n * JsDoc type information, or @const with a known type,\r\n * or a function literal with a name we haven't seen before.\r\n *\/\r\nprivate boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\r\n    if (valueType == null) {\r\n        return true;\r\n    }\r\n    \/\/ Prototype sets are always declared.\r\n    boolean inferred = true;\r\n    if (info != null) {\r\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\r\n    }\r\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\r\n        if (info != null) {\r\n            return false;\r\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\r\n            \/\/ Functions assigned in conditional blocks are inferred.\r\n            for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\r\n                if (NodeUtil.isControlStructure(current)) {\r\n                    return true;\r\n                }\r\n            }\r\n            \/\/ Check if this is assigned in an inner scope.\r\n            \/\/ Functions assigned in inner scopes are inferred.\r\n            AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\r\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return inferred;\r\n}","code_comment":"\/**\r\n * Determines whether a qualified name is inferred.\r\n * NOTE(nicksantos): Determining whether a property is declared or not\r\n * is really really obnoxious.\r\n *\r\n * The problem is that there are two (equally valid) coding styles:\r\n *\r\n * (function() {\r\n *   \/* The authoritative definition of goog.bar. \/\r\n *   goog.bar = function() {};\r\n * })();\r\n *\r\n * function f() {\r\n *   goog.bar();\r\n *   \/* Reset goog.bar to a no-op. \/\r\n *   goog.bar = function() {};\r\n * }\r\n *\r\n * In a dynamic language with first-class functions, it's very difficult\r\n * to know which one the user intended without looking at lots of\r\n * contextual information (the second example demonstrates a small case\r\n * of this, but there are some really pathological cases as well).\r\n *\r\n * The current algorithm checks if either the declaration has\r\n * JsDoc type information, or @const with a known type,\r\n * or a function literal with a name we haven't seen before.\r\n *\/\r\n","code_no_comment":"private boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\r\n    if (valueType == null) {\r\n        return true;\r\n    }\r\n        boolean inferred = true;\r\n    if (info != null) {\r\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\r\n    }\r\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\r\n        if (info != null) {\r\n            return false;\r\n        } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\r\n                        for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) {\r\n                if (NodeUtil.isControlStructure(current)) {\r\n                    return true;\r\n                }\r\n            }\r\n                                    AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\r\n            if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return inferred;\r\n}","lc":0.5,"pi":1.0669856459,"ma":1.0,"nbd":1.5,"ml":1.8333333333,"d":0.8908730159,"mi":-0.4725863284,"fo":0.9166666667,"r":-0.0263157895,"e":1.4116975848}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7213_336663c9","label":1,"code":"@Converter\r\npublic static ByteBuffer toByteBuffer(Integer value) {\r\n    ByteBuffer buf = ByteBuffer.allocate(4);\r\n    buf.putInt(value);\r\n    return buf;\r\n}","code_comment":null,"code_no_comment":"@Converter\r\npublic static ByteBuffer toByteBuffer(Integer value) {\r\n    ByteBuffer buf = ByteBuffer.allocate(4);\r\n    buf.putInt(value);\r\n    return buf;\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5644820296,"fo":-0.3333333333,"r":1.1315789474,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5131_4b7367ef","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic void respond(final IRequestCycle requestCycle) {\r\n    final String location;\r\n    if (redirectUrl.startsWith(\"\/\")) {\r\n        \/\/ context-absolute url\r\n        location = requestCycle.getUrlRenderer().renderContextRelativeUrl(redirectUrl);\r\n    } else {\r\n        \/\/ if relative url, servlet container will translate to absolute as\r\n        \/\/ per the servlet spec\r\n        \/\/ if absolute url still do the same\r\n        location = redirectUrl;\r\n    }\r\n    WebResponse response = (WebResponse) requestCycle.getResponse();\r\n    if (status == HttpServletResponse.SC_MOVED_TEMPORARILY) {\r\n        response.sendRedirect(location);\r\n    } else {\r\n        response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);\r\n        response.setHeader(\"Location\", location);\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public void respond(final IRequestCycle requestCycle) {\r\n    final String location;\r\n    if (redirectUrl.startsWith(\"\/\")) {\r\n                location = requestCycle.getUrlRenderer().renderContextRelativeUrl(redirectUrl);\r\n    } else {\r\n                                location = redirectUrl;\r\n    }\r\n    WebResponse response = (WebResponse) requestCycle.getResponse();\r\n    if (status == HttpServletResponse.SC_MOVED_TEMPORARILY) {\r\n        response.sendRedirect(location);\r\n    } else {\r\n        response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);\r\n        response.setHeader(\"Location\", location);\r\n    }\r\n}","lc":0.0454545455,"pi":-0.1818181818,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0496031746,"mi":-0.0387596899,"fo":0.0833333333,"r":0.2894736842,"e":-0.0316384571}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  Registers an fatal error feedback message for this component\r\n *\r\n *  @param message\r\n *             The feedback message\r\n *\/\r\npublic final void fatal(final String message) {\r\n    getPage().getFeedbackMessages().fatal(this, message);\r\n}","code_comment":"\/**\r\n *  Registers an fatal error feedback message for this component\r\n *\r\n *  @param message\r\n *             The feedback message\r\n *\/\r\n","code_no_comment":"public final void fatal(final String message) {\r\n    getPage().getFeedbackMessages().fatal(this, message);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0253699789,"fo":-0.25,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1122_5286861d","label":3,"code":"public String commit(String path, String jsonDiff, String revisionId, String message) throws MicroKernelException {\r\n    if (rep == null) {\r\n        throw new IllegalStateException(\"this instance has already been disposed\");\r\n    }\r\n    if (path.length() > 0 && !PathUtils.isAbsolute(path)) {\r\n        throw new IllegalArgumentException(\"absolute path expected: \" + path);\r\n    }\r\n    if (jsonDiff == null || jsonDiff.length() == 0) {\r\n        return getHeadRevision();\r\n    }\r\n    Id revId = revisionId == null ? getHeadRevisionId() : Id.fromString(revisionId);\r\n    try {\r\n        JsopTokenizer t = new JsopTokenizer(jsonDiff);\r\n        CommitBuilder cb = rep.getCommitBuilder(revId, message);\r\n        while (true) {\r\n            int r = t.read();\r\n            if (r == JsopReader.END) {\r\n                break;\r\n            }\r\n            \/\/ used for error reporting\r\n            int pos;\r\n            switch(r) {\r\n                case '+':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        t.read(':');\r\n                        t.read('{');\r\n                        String nodePath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(nodePath)) {\r\n                            throw new Exception(\"absolute path expected: \" + nodePath + \", pos: \" + pos);\r\n                        }\r\n                        String parentPath = PathUtils.getParentPath(nodePath);\r\n                        String nodeName = PathUtils.getName(nodePath);\r\n                        cb.addNode(parentPath, nodeName, JsonObject.create(t));\r\n                        break;\r\n                    }\r\n                case '-':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        String targetPath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(targetPath)) {\r\n                            throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                        }\r\n                        cb.removeNode(targetPath);\r\n                        break;\r\n                    }\r\n                case '^':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        t.read(':');\r\n                        String value;\r\n                        if (t.matches(JsopReader.NULL)) {\r\n                            value = null;\r\n                        } else {\r\n                            value = t.readRawValue().trim();\r\n                        }\r\n                        String targetPath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(targetPath)) {\r\n                            throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                        }\r\n                        String parentPath = PathUtils.getParentPath(targetPath);\r\n                        String propName = PathUtils.getName(targetPath);\r\n                        cb.setProperty(parentPath, propName, value);\r\n                        break;\r\n                    }\r\n                case '>':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        String srcPath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(srcPath)) {\r\n                            throw new Exception(\"absolute path expected: \" + srcPath + \", pos: \" + pos);\r\n                        }\r\n                        t.read(':');\r\n                        pos = t.getLastPos();\r\n                        String targetPath = t.readString();\r\n                        if (!PathUtils.isAbsolute(targetPath)) {\r\n                            targetPath = PathUtils.concat(path, targetPath);\r\n                            if (!PathUtils.isAbsolute(targetPath)) {\r\n                                throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                            }\r\n                        }\r\n                        cb.moveNode(srcPath, targetPath);\r\n                        break;\r\n                    }\r\n                case '*':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        String srcPath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(srcPath)) {\r\n                            throw new Exception(\"absolute path expected: \" + srcPath + \", pos: \" + pos);\r\n                        }\r\n                        t.read(':');\r\n                        pos = t.getLastPos();\r\n                        String targetPath = t.readString();\r\n                        if (!PathUtils.isAbsolute(targetPath)) {\r\n                            targetPath = PathUtils.concat(path, targetPath);\r\n                            if (!PathUtils.isAbsolute(targetPath)) {\r\n                                throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                            }\r\n                        }\r\n                        cb.copyNode(srcPath, targetPath);\r\n                        break;\r\n                    }\r\n                default:\r\n                    throw new IllegalArgumentException(\"jsonDiff: illegal token '\" + t.getToken() + \"' at pos: \" + t.getLastPos());\r\n            }\r\n        }\r\n        Id newHead = cb.doCommit();\r\n        if (!newHead.equals(revId)) {\r\n            \/\/ non-empty commit\r\n            if (rep.getCommit(newHead).getBranchRootId() == null) {\r\n                \/\/ OAK-265: only trigger commit gate for non-branch commits\r\n                gate.commit(newHead.toString());\r\n            }\r\n        }\r\n        return newHead.toString();\r\n    } catch (Exception e) {\r\n        throw new MicroKernelException(e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public String commit(String path, String jsonDiff, String revisionId, String message) throws MicroKernelException {\r\n    if (rep == null) {\r\n        throw new IllegalStateException(\"this instance has already been disposed\");\r\n    }\r\n    if (path.length() > 0 && !PathUtils.isAbsolute(path)) {\r\n        throw new IllegalArgumentException(\"absolute path expected: \" + path);\r\n    }\r\n    if (jsonDiff == null || jsonDiff.length() == 0) {\r\n        return getHeadRevision();\r\n    }\r\n    Id revId = revisionId == null ? getHeadRevisionId() : Id.fromString(revisionId);\r\n    try {\r\n        JsopTokenizer t = new JsopTokenizer(jsonDiff);\r\n        CommitBuilder cb = rep.getCommitBuilder(revId, message);\r\n        while (true) {\r\n            int r = t.read();\r\n            if (r == JsopReader.END) {\r\n                break;\r\n            }\r\n                        int pos;\r\n            switch(r) {\r\n                case '+':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        t.read(':');\r\n                        t.read('{');\r\n                        String nodePath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(nodePath)) {\r\n                            throw new Exception(\"absolute path expected: \" + nodePath + \", pos: \" + pos);\r\n                        }\r\n                        String parentPath = PathUtils.getParentPath(nodePath);\r\n                        String nodeName = PathUtils.getName(nodePath);\r\n                        cb.addNode(parentPath, nodeName, JsonObject.create(t));\r\n                        break;\r\n                    }\r\n                case '-':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        String targetPath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(targetPath)) {\r\n                            throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                        }\r\n                        cb.removeNode(targetPath);\r\n                        break;\r\n                    }\r\n                case '^':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        t.read(':');\r\n                        String value;\r\n                        if (t.matches(JsopReader.NULL)) {\r\n                            value = null;\r\n                        } else {\r\n                            value = t.readRawValue().trim();\r\n                        }\r\n                        String targetPath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(targetPath)) {\r\n                            throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                        }\r\n                        String parentPath = PathUtils.getParentPath(targetPath);\r\n                        String propName = PathUtils.getName(targetPath);\r\n                        cb.setProperty(parentPath, propName, value);\r\n                        break;\r\n                    }\r\n                case '>':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        String srcPath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(srcPath)) {\r\n                            throw new Exception(\"absolute path expected: \" + srcPath + \", pos: \" + pos);\r\n                        }\r\n                        t.read(':');\r\n                        pos = t.getLastPos();\r\n                        String targetPath = t.readString();\r\n                        if (!PathUtils.isAbsolute(targetPath)) {\r\n                            targetPath = PathUtils.concat(path, targetPath);\r\n                            if (!PathUtils.isAbsolute(targetPath)) {\r\n                                throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                            }\r\n                        }\r\n                        cb.moveNode(srcPath, targetPath);\r\n                        break;\r\n                    }\r\n                case '*':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        String srcPath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(srcPath)) {\r\n                            throw new Exception(\"absolute path expected: \" + srcPath + \", pos: \" + pos);\r\n                        }\r\n                        t.read(':');\r\n                        pos = t.getLastPos();\r\n                        String targetPath = t.readString();\r\n                        if (!PathUtils.isAbsolute(targetPath)) {\r\n                            targetPath = PathUtils.concat(path, targetPath);\r\n                            if (!PathUtils.isAbsolute(targetPath)) {\r\n                                throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                            }\r\n                        }\r\n                        cb.copyNode(srcPath, targetPath);\r\n                        break;\r\n                    }\r\n                default:\r\n                    throw new IllegalArgumentException(\"jsonDiff: illegal token '\" + t.getToken() + \"' at pos: \" + t.getLastPos());\r\n            }\r\n        }\r\n        Id newHead = cb.doCommit();\r\n        if (!newHead.equals(revId)) {\r\n                        if (rep.getCommit(newHead).getBranchRootId() == null) {\r\n                                gate.commit(newHead.toString());\r\n            }\r\n        }\r\n        return newHead.toString();\r\n    } catch (Exception e) {\r\n        throw new MicroKernelException(e);\r\n    }\r\n}","lc":4.9090909091,"pi":2.3636363636,"ma":7.8,"nbd":2.0,"ml":3.1666666667,"d":2.0238095238,"mi":-1.6356589147,"fo":4.9166666667,"r":-0.0263157895,"e":13.1415132288}
{"project_name":"JxPath","project_version":"7","label":1,"code":"public Object computeValue(EvalContext context) {\r\n    double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\r\n    double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\r\n    return l >= r ? Boolean.TRUE : Boolean.FALSE;\r\n}","code_comment":null,"code_no_comment":"public Object computeValue(EvalContext context) {\r\n    double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\r\n    double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\r\n    return l >= r ? Boolean.TRUE : Boolean.FALSE;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.4,"nbd":-1.0,"ml":-0.1666666667,"d":-0.0337301587,"mi":0.5348837209,"fo":-0.1666666667,"r":0.1842105263,"e":-0.0748511725}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"public void read(org.apache.thrift.protocol.TProtocol iprot, update_result struct) throws org.apache.thrift.TException {\r\n    org.apache.thrift.protocol.TField schemeField;\r\n    iprot.readStructBegin();\r\n    while (true) {\r\n        schemeField = iprot.readFieldBegin();\r\n        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {\r\n            break;\r\n        }\r\n        switch(schemeField.id) {\r\n            case \/\/ OUCH1\r\n            1:\r\n                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\r\n                    struct.ouch1 = new UnknownWriter();\r\n                    struct.ouch1.read(iprot);\r\n                    struct.setOuch1IsSet(true);\r\n                } else {\r\n                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n                }\r\n                break;\r\n            case \/\/ OUCH2\r\n            2:\r\n                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\r\n                    struct.ouch2 = new MutationsRejectedException();\r\n                    struct.ouch2.read(iprot);\r\n                    struct.setOuch2IsSet(true);\r\n                } else {\r\n                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n                }\r\n                break;\r\n            default:\r\n                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n        }\r\n        iprot.readFieldEnd();\r\n    }\r\n    iprot.readStructEnd();\r\n    \/\/ check for required fields of primitive type, which can't be checked in the validate method\r\n    struct.validate();\r\n}","code_comment":null,"code_no_comment":"public void read(org.apache.thrift.protocol.TProtocol iprot, update_result struct) throws org.apache.thrift.TException {\r\n    org.apache.thrift.protocol.TField schemeField;\r\n    iprot.readStructBegin();\r\n    while (true) {\r\n        schemeField = iprot.readFieldBegin();\r\n        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {\r\n            break;\r\n        }\r\n        switch(schemeField.id) {\r\n            case             1:\r\n                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\r\n                    struct.ouch1 = new UnknownWriter();\r\n                    struct.ouch1.read(iprot);\r\n                    struct.setOuch1IsSet(true);\r\n                } else {\r\n                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n                }\r\n                break;\r\n            case             2:\r\n                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\r\n                    struct.ouch2 = new MutationsRejectedException();\r\n                    struct.ouch2.read(iprot);\r\n                    struct.setOuch2IsSet(true);\r\n                } else {\r\n                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n                }\r\n                break;\r\n            default:\r\n                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n        }\r\n        iprot.readFieldEnd();\r\n    }\r\n    iprot.readStructEnd();\r\n        struct.validate();\r\n}","lc":1.0454545455,"pi":1.5358851675,"ma":1.4,"nbd":1.0,"ml":0.25,"d":0.2599206349,"mi":-0.6763918252,"fo":0.5,"r":-0.0263157895,"e":0.6848267953}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-724_9c8bb934","label":1,"code":"\/**\r\n * Generate a random long value uniformly distributed between\r\n * <code>lower<\/code> and <code>upper<\/code>, inclusive.\r\n *\r\n * @param lower\r\n *            the lower bound.\r\n * @param upper\r\n *            the upper bound.\r\n * @return the random integer.\r\n * @throws NumberIsTooLargeException if {@code lower >= upper}.\r\n *\/\r\npublic long nextLong(long lower, long upper) {\r\n    if (lower >= upper) {\r\n        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false);\r\n    }\r\n    double r = getRan().nextDouble();\r\n    return (long) ((r * upper) + ((1.0 - r) * lower) + r);\r\n}","code_comment":"\/**\r\n * Generate a random long value uniformly distributed between\r\n * <code>lower<\/code> and <code>upper<\/code>, inclusive.\r\n *\r\n * @param lower\r\n *            the lower bound.\r\n * @param upper\r\n *            the upper bound.\r\n * @return the random integer.\r\n * @throws NumberIsTooLargeException if {@code lower >= upper}.\r\n *\/\r\n","code_no_comment":"public long nextLong(long lower, long upper) {\r\n    if (lower >= upper) {\r\n        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false);\r\n    }\r\n    double r = getRan().nextDouble();\r\n    return (long) ((r * upper) + ((1.0 - r) * lower) + r);\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":0.3293650794,"mi":0.3801268499,"fo":-0.3333333333,"r":0.5263157895,"e":0.0152901921}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-293_ca59ece6","label":1,"code":"private LoggerContext locateContext(final ClassLoader loader, final URI configLocation) {\r\n    final String name = loader.toString();\r\n    AtomicReference<WeakReference<LoggerContext>> ref = CONTEXT_MAP.get(name);\r\n    if (ref == null) {\r\n        if (configLocation == null) {\r\n            ClassLoader parent = loader.getParent();\r\n            while (parent != null) {\r\n                ref = CONTEXT_MAP.get(parent.toString());\r\n                if (ref != null) {\r\n                    final WeakReference<LoggerContext> r = ref.get();\r\n                    final LoggerContext ctx = r.get();\r\n                    if (ctx != null) {\r\n                        return ctx;\r\n                    }\r\n                }\r\n                parent = parent.getParent();\r\n            \/*  In Tomcat 6 the parent of the JSP classloader is the webapp classloader which would be\r\n                    configured by the WebAppContextListener. The WebAppClassLoader is also the ThreadContextClassLoader.\r\n                    In JBoss 5 the parent of the JSP ClassLoader is the WebAppClassLoader which is also the\r\n                    ThreadContextClassLoader. However, the parent of the WebAppClassLoader is the ClassLoader\r\n                    that is configured by the WebAppContextListener.\r\n\r\n                    ClassLoader threadLoader = null;\r\n                    try {\r\n                        threadLoader = Thread.currentThread().getContextClassLoader();\r\n                    } catch (Exception ex) {\r\n                        \/\/ Ignore SecurityException\r\n                    }\r\n                    if (threadLoader != null && threadLoader == parent) {\r\n                        break;\r\n                    } else {\r\n                        parent = parent.getParent();\r\n                    } *\/\r\n            }\r\n        }\r\n        LoggerContext ctx = new LoggerContext(name, null, configLocation);\r\n        final AtomicReference<WeakReference<LoggerContext>> r = new AtomicReference<WeakReference<LoggerContext>>();\r\n        r.set(new WeakReference<LoggerContext>(ctx));\r\n        CONTEXT_MAP.putIfAbsent(loader.toString(), r);\r\n        ctx = CONTEXT_MAP.get(name).get().get();\r\n        return ctx;\r\n    }\r\n    final WeakReference<LoggerContext> r = ref.get();\r\n    LoggerContext ctx = r.get();\r\n    if (ctx != null) {\r\n        return ctx;\r\n    }\r\n    ctx = new LoggerContext(name, null, configLocation);\r\n    ref.compareAndSet(r, new WeakReference<LoggerContext>(ctx));\r\n    return ctx;\r\n}","code_comment":null,"code_no_comment":"private LoggerContext locateContext(final ClassLoader loader, final URI configLocation) {\r\n    final String name = loader.toString();\r\n    AtomicReference<WeakReference<LoggerContext>> ref = CONTEXT_MAP.get(name);\r\n    if (ref == null) {\r\n        if (configLocation == null) {\r\n            ClassLoader parent = loader.getParent();\r\n            while (parent != null) {\r\n                ref = CONTEXT_MAP.get(parent.toString());\r\n                if (ref != null) {\r\n                    final WeakReference<LoggerContext> r = ref.get();\r\n                    final LoggerContext ctx = r.get();\r\n                    if (ctx != null) {\r\n                        return ctx;\r\n                    }\r\n                }\r\n                parent = parent.getParent();\r\n                        }\r\n        }\r\n        LoggerContext ctx = new LoggerContext(name, null, configLocation);\r\n        final AtomicReference<WeakReference<LoggerContext>> r = new AtomicReference<WeakReference<LoggerContext>>();\r\n        r.set(new WeakReference<LoggerContext>(ctx));\r\n        CONTEXT_MAP.putIfAbsent(loader.toString(), r);\r\n        ctx = CONTEXT_MAP.get(name).get().get();\r\n        return ctx;\r\n    }\r\n    final WeakReference<LoggerContext> r = ref.get();\r\n    LoggerContext ctx = r.get();\r\n    if (ctx != null) {\r\n        return ctx;\r\n    }\r\n    ctx = new LoggerContext(name, null, configLocation);\r\n    ref.compareAndSet(r, new WeakReference<LoggerContext>(ctx));\r\n    return ctx;\r\n}","lc":0.9090909091,"pi":1.6076555024,"ma":0.6,"nbd":1.5,"ml":0.4166666667,"d":0.5317460317,"mi":-0.6104298802,"fo":0.9166666667,"r":-0.0263157895,"e":1.042469298}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2900_0e70ce39","label":3,"code":"\/**\r\n *  Returns the name of the Bean as registered to Spring. Throws IllegalState exception if none\r\n *  or more than one beans are found.\r\n *\r\n *  @param ctx\r\n *             spring application context\r\n *  @param clazz\r\n *             bean class\r\n *  @throws IllegalStateException\r\n *  @return spring name of the bean\r\n *\/\r\nprivate final String getBeanNameOfClass(final ApplicationContext ctx, final Class<?> clazz) {\r\n    \/\/ get the list of all possible matching beans\r\n    List<String> names = new ArrayList<String>(Arrays.asList(BeanFactoryUtils.beanNamesForTypeIncludingAncestors(ctx, clazz)));\r\n    Iterator<String> it = names.iterator();\r\n    \/\/ filter out beans that are not candidates for autowiring\r\n    while (it.hasNext()) {\r\n        final String possibility = it.next();\r\n        BeanDefinition beanDef = ((AbstractApplicationContext) ctx).getBeanFactory().getBeanDefinition(possibility);\r\n        if (BeanFactoryUtils.isFactoryDereference(possibility) || possibility.startsWith(\"scopedTarget.\") || !beanDef.isAutowireCandidate()) {\r\n            it.remove();\r\n        }\r\n    }\r\n    if (names.isEmpty()) {\r\n        throw new IllegalStateException(\"bean of type [\" + clazz.getName() + \"] not found\");\r\n    } else if (names.size() > 1) {\r\n        if (ctx instanceof AbstractApplicationContext) {\r\n            for (String name : names) {\r\n                BeanDefinition beanDef = ((AbstractApplicationContext) ctx).getBeanFactory().getBeanDefinition(name);\r\n                if (beanDef instanceof AbstractBeanDefinition) {\r\n                    if (((AbstractBeanDefinition) beanDef).isPrimary()) {\r\n                        return name;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        StringBuilder msg = new StringBuilder();\r\n        msg.append(\"More than one bean of type [\");\r\n        msg.append(clazz.getName());\r\n        msg.append(\"] found, you have to specify the name of the bean \");\r\n        msg.append(\"(@SpringBean(name=\\\"foo\\\")) in order to resolve this conflict. \");\r\n        msg.append(\"Matched beans: \");\r\n        msg.append(Strings.join(\",\", names.toArray(new String[0])));\r\n        throw new IllegalStateException(msg.toString());\r\n    } else {\r\n        return names.get(0);\r\n    }\r\n}","code_comment":"\/**\r\n *  Returns the name of the Bean as registered to Spring. Throws IllegalState exception if none\r\n *  or more than one beans are found.\r\n *\r\n *  @param ctx\r\n *             spring application context\r\n *  @param clazz\r\n *             bean class\r\n *  @throws IllegalStateException\r\n *  @return spring name of the bean\r\n *\/\r\n","code_no_comment":"private final String getBeanNameOfClass(final ApplicationContext ctx, final Class<?> clazz) {\r\n        List<String> names = new ArrayList<String>(Arrays.asList(BeanFactoryUtils.beanNamesForTypeIncludingAncestors(ctx, clazz)));\r\n    Iterator<String> it = names.iterator();\r\n        while (it.hasNext()) {\r\n        final String possibility = it.next();\r\n        BeanDefinition beanDef = ((AbstractApplicationContext) ctx).getBeanFactory().getBeanDefinition(possibility);\r\n        if (BeanFactoryUtils.isFactoryDereference(possibility) || possibility.startsWith(\"scopedTarget.\") || !beanDef.isAutowireCandidate()) {\r\n            it.remove();\r\n        }\r\n    }\r\n    if (names.isEmpty()) {\r\n        throw new IllegalStateException(\"bean of type [\" + clazz.getName() + \"] not found\");\r\n    } else if (names.size() > 1) {\r\n        if (ctx instanceof AbstractApplicationContext) {\r\n            for (String name : names) {\r\n                BeanDefinition beanDef = ((AbstractApplicationContext) ctx).getBeanFactory().getBeanDefinition(name);\r\n                if (beanDef instanceof AbstractBeanDefinition) {\r\n                    if (((AbstractBeanDefinition) beanDef).isPrimary()) {\r\n                        return name;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        StringBuilder msg = new StringBuilder();\r\n        msg.append(\"More than one bean of type [\");\r\n        msg.append(clazz.getName());\r\n        msg.append(\"] found, you have to specify the name of the bean \");\r\n        msg.append(\"(@SpringBean(name=\\\"foo\\\")) in order to resolve this conflict. \");\r\n        msg.append(\"Matched beans: \");\r\n        msg.append(Strings.join(\",\", names.toArray(new String[0])));\r\n        throw new IllegalStateException(msg.toString());\r\n    } else {\r\n        return names.get(0);\r\n    }\r\n}","lc":0.9545454545,"pi":1.1483253589,"ma":1.4,"nbd":2.0,"ml":1.1666666667,"d":0.4285714286,"mi":-0.6763918252,"fo":1.8333333333,"r":-0.0263157895,"e":1.1173181653}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2235_29d3d8f1","label":3,"code":"\/**\r\n * close writer if it's not null\r\n *\/\r\nvoid closeWriter() throws IOException {\r\n    if (writer != null) {\r\n        writer.close();\r\n        \/\/ OAK-2029 Record the last updated status so\r\n        \/\/ as to make IndexTracker detect changes when index\r\n        \/\/ is stored in file system\r\n        NodeBuilder status = definitionBuilder.child(\":status\");\r\n        status.setProperty(\"lastUpdated\", ISO8601.format(Calendar.getInstance()), Type.DATE);\r\n        status.setProperty(\"indexedNodes\", indexedNodes);\r\n    }\r\n}","code_comment":"\/**\r\n * close writer if it's not null\r\n *\/\r\n","code_no_comment":"void closeWriter() throws IOException {\r\n    if (writer != null) {\r\n        writer.close();\r\n                                NodeBuilder status = definitionBuilder.child(\":status\");\r\n        status.setProperty(\"lastUpdated\", ISO8601.format(Calendar.getInstance()), Type.DATE);\r\n        status.setProperty(\"indexedNodes\", indexedNodes);\r\n    }\r\n}","lc":-0.2727272727,"pi":0.1578947368,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1170634921,"mi":0.3127554616,"fo":0.0,"r":1.1315789474,"e":-0.09340318}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3367_06812d25","label":1,"code":"private Map<String, PropertyDefinition> collectPropConfigs(NodeState config, List<NamePattern> patterns, List<Aggregate.Include> propAggregate, List<PropertyDefinition> nonExistentProperties, List<PropertyDefinition> existentProperties, List<PropertyDefinition> boostedProps) {\r\n    Map<String, PropertyDefinition> propDefns = newHashMap();\r\n    NodeState propNode = config.getChildNode(LuceneIndexConstants.PROP_NODE);\r\n    if (!propNode.exists()) {\r\n        return Collections.emptyMap();\r\n    }\r\n    if (!hasOrderableChildren(propNode)) {\r\n        log.warn(\"Properties node for [{}] does not have orderable \" + \"children in [{}]\", this, IndexDefinition.this);\r\n    }\r\n    \/\/ Include all immediate child nodes to 'properties' node by default\r\n    Tree propTree = TreeFactory.createReadOnlyTree(propNode);\r\n    for (Tree prop : propTree.getChildren()) {\r\n        String propName = prop.getName();\r\n        NodeState propDefnNode = propNode.getChildNode(propName);\r\n        if (propDefnNode.exists() && !propDefns.containsKey(propName)) {\r\n            PropertyDefinition pd = new PropertyDefinition(this, propName, propDefnNode);\r\n            if (pd.isRegexp) {\r\n                patterns.add(new NamePattern(pd.name, pd));\r\n            } else {\r\n                propDefns.put(pd.name.toLowerCase(Locale.ENGLISH), pd);\r\n            }\r\n            if (pd.relative) {\r\n                propAggregate.add(new Aggregate.PropertyInclude(pd));\r\n            }\r\n            if (pd.nullCheckEnabled) {\r\n                nonExistentProperties.add(pd);\r\n            }\r\n            if (pd.notNullCheckEnabled) {\r\n                existentProperties.add(pd);\r\n            }\r\n            \/\/ Include props with name, boosted and nodeScopeIndex\r\n            if (pd.nodeScopeIndex && pd.boost != PropertyDefinition.DEFAULT_BOOST && pd.analyzed && !pd.isRegexp) {\r\n                boostedProps.add(pd);\r\n            }\r\n        }\r\n    }\r\n    return ImmutableMap.copyOf(propDefns);\r\n}","code_comment":null,"code_no_comment":"private Map<String, PropertyDefinition> collectPropConfigs(NodeState config, List<NamePattern> patterns, List<Aggregate.Include> propAggregate, List<PropertyDefinition> nonExistentProperties, List<PropertyDefinition> existentProperties, List<PropertyDefinition> boostedProps) {\r\n    Map<String, PropertyDefinition> propDefns = newHashMap();\r\n    NodeState propNode = config.getChildNode(LuceneIndexConstants.PROP_NODE);\r\n    if (!propNode.exists()) {\r\n        return Collections.emptyMap();\r\n    }\r\n    if (!hasOrderableChildren(propNode)) {\r\n        log.warn(\"Properties node for [{}] does not have orderable \" + \"children in [{}]\", this, IndexDefinition.this);\r\n    }\r\n        Tree propTree = TreeFactory.createReadOnlyTree(propNode);\r\n    for (Tree prop : propTree.getChildren()) {\r\n        String propName = prop.getName();\r\n        NodeState propDefnNode = propNode.getChildNode(propName);\r\n        if (propDefnNode.exists() && !propDefns.containsKey(propName)) {\r\n            PropertyDefinition pd = new PropertyDefinition(this, propName, propDefnNode);\r\n            if (pd.isRegexp) {\r\n                patterns.add(new NamePattern(pd.name, pd));\r\n            } else {\r\n                propDefns.put(pd.name.toLowerCase(Locale.ENGLISH), pd);\r\n            }\r\n            if (pd.relative) {\r\n                propAggregate.add(new Aggregate.PropertyInclude(pd));\r\n            }\r\n            if (pd.nullCheckEnabled) {\r\n                nonExistentProperties.add(pd);\r\n            }\r\n            if (pd.notNullCheckEnabled) {\r\n                existentProperties.add(pd);\r\n            }\r\n                        if (pd.nodeScopeIndex && pd.boost != PropertyDefinition.DEFAULT_BOOST && pd.analyzed && !pd.isRegexp) {\r\n                boostedProps.add(pd);\r\n            }\r\n        }\r\n    }\r\n    return ImmutableMap.copyOf(propDefns);\r\n}","lc":1.0,"pi":0.8516746411,"ma":1.2,"nbd":0.5,"ml":1.6666666667,"d":0.4563492063,"mi":-0.7085271318,"fo":1.1666666667,"r":-0.0263157895,"e":1.4159114354}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3727_ff2713d1","label":1,"code":"protected void doStart() throws Exception {\r\n    if (isParallelProcessing() && executorService == null) {\r\n        throw new IllegalArgumentException(\"ParallelProcessing is enabled but ExecutorService has not been set\");\r\n    }\r\n    if (timeout > 0 && !isParallelProcessing()) {\r\n        throw new IllegalArgumentException(\"Timeout is used but ParallelProcessing has not been enabled\");\r\n    }\r\n    if (isParallelProcessing() && aggregateExecutorService == null) {\r\n        \/\/ use unbounded thread pool so we ensure the aggregate on-the-fly task always will have assigned a thread\r\n        \/\/ and run the tasks when the task is submitted. If not then the aggregate task may not be able to run\r\n        \/\/ and signal completion during processing, which would lead to a dead-lock\r\n        \/\/ keep at least one thread in the pool so we re-use the thread avoiding to create new threads because\r\n        \/\/ the pool shrank to zero.\r\n        String name = getClass().getSimpleName() + \"-AggregateTask\";\r\n        aggregateExecutorService = camelContext.getExecutorServiceStrategy().newThreadPool(this, name, 1, Integer.MAX_VALUE);\r\n    }\r\n    ServiceHelper.startServices(processors);\r\n}","code_comment":null,"code_no_comment":"protected void doStart() throws Exception {\r\n    if (isParallelProcessing() && executorService == null) {\r\n        throw new IllegalArgumentException(\"ParallelProcessing is enabled but ExecutorService has not been set\");\r\n    }\r\n    if (timeout > 0 && !isParallelProcessing()) {\r\n        throw new IllegalArgumentException(\"Timeout is used but ParallelProcessing has not been enabled\");\r\n    }\r\n    if (isParallelProcessing() && aggregateExecutorService == null) {\r\n                                                String name = getClass().getSimpleName() + \"-AggregateTask\";\r\n        aggregateExecutorService = camelContext.getExecutorServiceStrategy().newThreadPool(this, name, 1, Integer.MAX_VALUE);\r\n    }\r\n    ServiceHelper.startServices(processors);\r\n}","lc":-0.0454545455,"pi":-0.1626794258,"ma":0.4,"nbd":-0.5,"ml":0.4166666667,"d":0.3670634921,"mi":-0.0164904863,"fo":0.1666666667,"r":-0.0263157895,"e":0.1946831256}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-293_59a0da9c","label":1,"code":"\/**\r\n * Get the original number of decision variables.\r\n * @return original number of decision variables\r\n * @see #getNumDecisionVariables()\r\n *\/\r\nprotected final int getOriginalNumDecisionVariables() {\r\n    return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;\r\n}","code_comment":"\/**\r\n * Get the original number of decision variables.\r\n * @return original number of decision variables\r\n * @see #getNumDecisionVariables()\r\n *\/\r\n","code_no_comment":"protected final int getOriginalNumDecisionVariables() {\r\n    return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.3650793651,"mi":1.0386187456,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"Closure","project_version":"73","label":2,"code":"\/**\r\n * Helper to escape javascript string as well as regular expression\r\n *\/\r\nstatic String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {\r\n    StringBuilder sb = new StringBuilder(s.length() + 2);\r\n    sb.append(quote);\r\n    for (int i = 0; i < s.length(); i++) {\r\n        char c = s.charAt(i);\r\n        switch(c) {\r\n            case '\\0':\r\n                sb.append(\"\\\\0\");\r\n                break;\r\n            case '\\n':\r\n                sb.append(\"\\\\n\");\r\n                break;\r\n            case '\\r':\r\n                sb.append(\"\\\\r\");\r\n                break;\r\n            case '\\t':\r\n                sb.append(\"\\\\t\");\r\n                break;\r\n            case '\\\\':\r\n                sb.append(backslashEscape);\r\n                break;\r\n            case '\\\"':\r\n                sb.append(doublequoteEscape);\r\n                break;\r\n            case '\\'':\r\n                sb.append(singlequoteEscape);\r\n                break;\r\n            case \/\/ Break --> into --\\> or ]]> into ]]\\>\r\n            '>':\r\n                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\r\n                    sb.append(\"\\\\>\");\r\n                } else {\r\n                    sb.append(c);\r\n                }\r\n                break;\r\n            case '<':\r\n                \/\/ Break <\/script into <\\\/script\r\n                final String END_SCRIPT = \"\/script\";\r\n                \/\/ Break <!-- into <\\!--\r\n                final String START_COMMENT = \"!--\";\r\n                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {\r\n                    sb.append(\"<\\\\\");\r\n                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {\r\n                    sb.append(\"<\\\\\");\r\n                } else {\r\n                    sb.append(c);\r\n                }\r\n                break;\r\n            default:\r\n                \/\/ character can be represented in this character set.\r\n                if (outputCharsetEncoder != null) {\r\n                    if (outputCharsetEncoder.canEncode(c)) {\r\n                        sb.append(c);\r\n                    } else {\r\n                        \/\/ Unicode-escape the character.\r\n                        appendHexJavaScriptRepresentation(sb, c);\r\n                    }\r\n                } else {\r\n                    \/\/ check is measurably faster than using the CharsetEncoder.\r\n                    if (c > 0x1f && c <= 0x7f) {\r\n                        sb.append(c);\r\n                    } else {\r\n                        \/\/ Other characters can be misinterpreted by some js parsers,\r\n                        \/\/ or perhaps mangled by proxies along the way,\r\n                        \/\/ so we play it safe and unicode escape them.\r\n                        appendHexJavaScriptRepresentation(sb, c);\r\n                    }\r\n                }\r\n        }\r\n    }\r\n    sb.append(quote);\r\n    return sb.toString();\r\n}","code_comment":"\/**\r\n * Helper to escape javascript string as well as regular expression\r\n *\/\r\n","code_no_comment":"static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {\r\n    StringBuilder sb = new StringBuilder(s.length() + 2);\r\n    sb.append(quote);\r\n    for (int i = 0; i < s.length(); i++) {\r\n        char c = s.charAt(i);\r\n        switch(c) {\r\n            case '\\0':\r\n                sb.append(\"\\\\0\");\r\n                break;\r\n            case '\\n':\r\n                sb.append(\"\\\\n\");\r\n                break;\r\n            case '\\r':\r\n                sb.append(\"\\\\r\");\r\n                break;\r\n            case '\\t':\r\n                sb.append(\"\\\\t\");\r\n                break;\r\n            case '\\\\':\r\n                sb.append(backslashEscape);\r\n                break;\r\n            case '\\\"':\r\n                sb.append(doublequoteEscape);\r\n                break;\r\n            case '\\'':\r\n                sb.append(singlequoteEscape);\r\n                break;\r\n            case             '>':\r\n                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\r\n                    sb.append(\"\\\\>\");\r\n                } else {\r\n                    sb.append(c);\r\n                }\r\n                break;\r\n            case '<':\r\n                                final String END_SCRIPT = \"\/script\";\r\n                                final String START_COMMENT = \"!--\";\r\n                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {\r\n                    sb.append(\"<\\\\\");\r\n                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {\r\n                    sb.append(\"<\\\\\");\r\n                } else {\r\n                    sb.append(c);\r\n                }\r\n                break;\r\n            default:\r\n                                if (outputCharsetEncoder != null) {\r\n                    if (outputCharsetEncoder.canEncode(c)) {\r\n                        sb.append(c);\r\n                    } else {\r\n                                                appendHexJavaScriptRepresentation(sb, c);\r\n                    }\r\n                } else {\r\n                                        if (c > 0x1f && c <= 0x7f) {\r\n                        sb.append(c);\r\n                    } else {\r\n                                                                                                appendHexJavaScriptRepresentation(sb, c);\r\n                    }\r\n                }\r\n        }\r\n    }\r\n    sb.append(quote);\r\n    return sb.toString();\r\n}","lc":2.3181818182,"pi":1.2440191388,"ma":4.6,"nbd":1.5,"ml":2.25,"d":3.2301587302,"mi":-1.1248766737,"fo":2.0833333333,"r":-0.0263157895,"e":8.6911014678}
{"project_name":"Closure","project_version":"148","label":2,"code":"\/**\r\n * Whether the mapping is actually used by the source map.\r\n *\/\r\n\/**\r\n * Cache of escaped source file name.\r\n *\/\r\n\/**\r\n * Appends the mapping to the given buffer.\r\n *\/\r\nvoid appendTo(Appendable out) throws IOException {\r\n    out.append(\"[\");\r\n    out.append(sourceFile);\r\n    \/\/ The source file rarely changes, so cache the escaped string.\r\n    out.append(\",\");\r\n    out.append(String.valueOf(originalPosition.getLineNumber()));\r\n    out.append(\",\");\r\n    out.append(String.valueOf(originalPosition.getCharacterIndex()));\r\n    if (originalName != null) {\r\n        out.append(\",\");\r\n        out.append(originalName);\r\n    }\r\n    out.append(\"]\");\r\n}","code_comment":"\/**\r\n * Whether the mapping is actually used by the source map.\r\n *\/\r\n\/**\r\n * Cache of escaped source file name.\r\n *\/\r\n\/**\r\n * Appends the mapping to the given buffer.\r\n *\/\r\n","code_no_comment":"void appendTo(Appendable out) throws IOException {\r\n    out.append(\"[\");\r\n    out.append(sourceFile);\r\n        out.append(\",\");\r\n    out.append(String.valueOf(originalPosition.getLineNumber()));\r\n    out.append(\",\");\r\n    out.append(String.valueOf(originalPosition.getCharacterIndex()));\r\n    if (originalName != null) {\r\n        out.append(\",\");\r\n        out.append(originalName);\r\n    }\r\n    out.append(\"]\");\r\n}","lc":-0.0454545455,"pi":-0.3684210526,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.0396053559,"fo":0.5833333333,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3324_5f863af6","label":1,"code":"private boolean hasPermissions(@Nonnull Iterator<PermissionEntry> entries, long permissions, @Nullable String path) {\r\n    \/\/ calculate readable paths if the given permissions includes any read permission.\r\n    boolean isReadable = Permissions.diff(Permissions.READ, permissions) != Permissions.READ && readPolicy.isReadablePath(path, false);\r\n    if (!entries.hasNext() && !isReadable) {\r\n        return false;\r\n    }\r\n    boolean respectParent = (path != null) && Permissions.respectParentPermissions(permissions);\r\n    long allows = (isReadable) ? Permissions.READ : Permissions.NO_PERMISSION;\r\n    long denies = Permissions.NO_PERMISSION;\r\n    PrivilegeBits allowBits = PrivilegeBits.getInstance();\r\n    if (isReadable) {\r\n        allowBits.add(bitsProvider.getBits(PrivilegeConstants.JCR_READ));\r\n    }\r\n    PrivilegeBits denyBits = PrivilegeBits.getInstance();\r\n    PrivilegeBits parentAllowBits;\r\n    PrivilegeBits parentDenyBits;\r\n    String parentPath;\r\n    if (respectParent) {\r\n        parentAllowBits = PrivilegeBits.getInstance();\r\n        parentDenyBits = PrivilegeBits.getInstance();\r\n        parentPath = PermissionUtil.getParentPathOrNull(path);\r\n    } else {\r\n        parentAllowBits = PrivilegeBits.EMPTY;\r\n        parentDenyBits = PrivilegeBits.EMPTY;\r\n        parentPath = null;\r\n    }\r\n    while (entries.hasNext()) {\r\n        PermissionEntry entry = entries.next();\r\n        if (respectParent && (parentPath != null)) {\r\n            boolean matchesParent = entry.matchesParent(parentPath);\r\n            if (matchesParent) {\r\n                if (entry.isAllow) {\r\n                    parentAllowBits.addDifference(entry.privilegeBits, parentDenyBits);\r\n                } else {\r\n                    parentDenyBits.addDifference(entry.privilegeBits, parentAllowBits);\r\n                }\r\n            }\r\n        }\r\n        if (entry.isAllow) {\r\n            allowBits.addDifference(entry.privilegeBits, denyBits);\r\n            long ap = PrivilegeBits.calculatePermissions(allowBits, parentAllowBits, true);\r\n            allows |= Permissions.diff(ap, denies);\r\n            if ((allows | ~permissions) == -1) {\r\n                return true;\r\n            }\r\n        } else {\r\n            denyBits.addDifference(entry.privilegeBits, allowBits);\r\n            long dp = PrivilegeBits.calculatePermissions(denyBits, parentDenyBits, false);\r\n            denies |= Permissions.diff(dp, allows);\r\n            if (Permissions.includes(denies, permissions)) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return (allows | ~permissions) == -1;\r\n}","code_comment":null,"code_no_comment":"private boolean hasPermissions(@Nonnull Iterator<PermissionEntry> entries, long permissions, @Nullable String path) {\r\n        boolean isReadable = Permissions.diff(Permissions.READ, permissions) != Permissions.READ && readPolicy.isReadablePath(path, false);\r\n    if (!entries.hasNext() && !isReadable) {\r\n        return false;\r\n    }\r\n    boolean respectParent = (path != null) && Permissions.respectParentPermissions(permissions);\r\n    long allows = (isReadable) ? Permissions.READ : Permissions.NO_PERMISSION;\r\n    long denies = Permissions.NO_PERMISSION;\r\n    PrivilegeBits allowBits = PrivilegeBits.getInstance();\r\n    if (isReadable) {\r\n        allowBits.add(bitsProvider.getBits(PrivilegeConstants.JCR_READ));\r\n    }\r\n    PrivilegeBits denyBits = PrivilegeBits.getInstance();\r\n    PrivilegeBits parentAllowBits;\r\n    PrivilegeBits parentDenyBits;\r\n    String parentPath;\r\n    if (respectParent) {\r\n        parentAllowBits = PrivilegeBits.getInstance();\r\n        parentDenyBits = PrivilegeBits.getInstance();\r\n        parentPath = PermissionUtil.getParentPathOrNull(path);\r\n    } else {\r\n        parentAllowBits = PrivilegeBits.EMPTY;\r\n        parentDenyBits = PrivilegeBits.EMPTY;\r\n        parentPath = null;\r\n    }\r\n    while (entries.hasNext()) {\r\n        PermissionEntry entry = entries.next();\r\n        if (respectParent && (parentPath != null)) {\r\n            boolean matchesParent = entry.matchesParent(parentPath);\r\n            if (matchesParent) {\r\n                if (entry.isAllow) {\r\n                    parentAllowBits.addDifference(entry.privilegeBits, parentDenyBits);\r\n                } else {\r\n                    parentDenyBits.addDifference(entry.privilegeBits, parentAllowBits);\r\n                }\r\n            }\r\n        }\r\n        if (entry.isAllow) {\r\n            allowBits.addDifference(entry.privilegeBits, denyBits);\r\n            long ap = PrivilegeBits.calculatePermissions(allowBits, parentAllowBits, true);\r\n            allows |= Permissions.diff(ap, denies);\r\n            if ((allows | ~permissions) == -1) {\r\n                return true;\r\n            }\r\n        } else {\r\n            denyBits.addDifference(entry.privilegeBits, allowBits);\r\n            long dp = PrivilegeBits.calculatePermissions(denyBits, parentDenyBits, false);\r\n            denies |= Permissions.diff(dp, allows);\r\n            if (Permissions.includes(denies, permissions)) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return (allows | ~permissions) == -1;\r\n}","lc":1.8636363636,"pi":0.8373205742,"ma":1.6,"nbd":1.0,"ml":1.5,"d":2.0158730159,"mi":-0.9579985906,"fo":1.4166666667,"r":-0.0263157895,"e":5.9809224137}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1244_b4a93c81","label":3,"code":"@Override\r\npublic void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos) throws RepositoryException {\r\n    Tree parent = parents.peek();\r\n    Tree tree = null;\r\n    String id = nodeInfo.getUUID();\r\n    String nodeName = nodeInfo.getName();\r\n    String ntName = nodeInfo.getPrimaryTypeName();\r\n    if (parent == null) {\r\n        log.debug(\"Skipping node: \" + nodeName);\r\n        \/\/ parent node was skipped, skip this child node too\r\n        \/\/ push null onto stack for skipped node\r\n        parents.push(null);\r\n        \/\/ notify the p-i-importer\r\n        if (pnImporter != null) {\r\n            pnImporter.startChildInfo(nodeInfo, propInfos);\r\n        }\r\n        return;\r\n    }\r\n    NodeDefinition parentDef = getDefinition(parent);\r\n    if (parentDef.isProtected()) {\r\n        \/\/ skip protected node\r\n        parents.push(null);\r\n        log.debug(\"Skipping protected node: \" + nodeName);\r\n        if (pnImporter != null) {\r\n            \/\/ pnImporter was already started (current nodeInfo is a sibling)\r\n            \/\/ notify it about this child node.\r\n            pnImporter.startChildInfo(nodeInfo, propInfos);\r\n        } else {\r\n            \/\/ potentially is able to deal with it, notify it about the child node.\r\n            for (ProtectedItemImporter pni : pItemImporters) {\r\n                if (pni instanceof ProtectedNodeImporter && ((ProtectedNodeImporter) pni).start(parent)) {\r\n                    log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\r\n                    pnImporter = (ProtectedNodeImporter) pni;\r\n                    pnImporter.startChildInfo(nodeInfo, propInfos);\r\n                    break;\r\n                }\r\n            \/* else: p-i-Importer isn't able to deal with the protected tree.\r\n                     try next. and if none can handle the passed parent the\r\n                     tree below will be skipped *\/\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    if (parent.hasChild(nodeName)) {\r\n        \/\/ a node with that name already exists...\r\n        Tree existing = parent.getChild(nodeName);\r\n        NodeDefinition def = getDefinition(existing);\r\n        if (!def.allowsSameNameSiblings()) {\r\n            \/\/ check for potential conflicts\r\n            if (def.isProtected() && isNodeType(existing, ntName)) {\r\n                \/*\r\n                     use the existing node as parent for the possible subsequent\r\n                     import of a protected tree, that the protected node importer\r\n                     may or may not be able to deal with.\r\n                     -> upon the next 'startNode' the check for the parent being\r\n                        protected will notify the protected node importer.\r\n                     -> if the importer is able to deal with that node it needs\r\n                        to care of the complete subtree until it is notified\r\n                        during the 'endNode' call.\r\n                     -> if the import can't deal with that node or if that node\r\n                        is the a leaf in the tree to be imported 'end' will\r\n                        not have an effect on the importer, that was never started.\r\n                    *\/\r\n                log.debug(\"Skipping protected node: \" + existing);\r\n                parents.push(existing);\r\n                return;\r\n            }\r\n            if (def.isAutoCreated() && isNodeType(existing, ntName)) {\r\n                \/\/ this node has already been auto-created, no need to create it\r\n                tree = existing;\r\n            } else {\r\n                \/\/ edge case: colliding node does have same uuid\r\n                \/\/ (see http:\/\/issues.apache.org\/jira\/browse\/JCR-1128)\r\n                String existingIdentifier = IdentifierManager.getIdentifier(existing);\r\n                if (!(existingIdentifier.equals(id) && (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING || uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING))) {\r\n                    throw new ItemExistsException(\"Node with the same UUID exists:\" + existing);\r\n                }\r\n            \/\/ fall through\r\n            }\r\n        }\r\n    }\r\n    if (tree == null) {\r\n        \/\/ create node\r\n        if (id == null) {\r\n            \/\/ no potential uuid conflict, always add new node\r\n            tree = createTree(parent, nodeInfo, id);\r\n        } else {\r\n            \/\/ 1. First check from base state that tree corresponding to\r\n            \/\/ this id exist\r\n            Tree conflicting = baseStateIdManager.getTree(id);\r\n            if (conflicting == null) {\r\n                \/\/ 1.a. Check if id is found in newly created nodes\r\n                if (uuids.contains(id)) {\r\n                    conflicting = currentStateIdManager.getTree(id);\r\n                }\r\n            } else {\r\n                \/\/ 1.b Re obtain the conflicting tree from Id Manager\r\n                \/\/ associated with current root. Such that any operation\r\n                \/\/ on it gets reflected in later operations\r\n                \/\/ In case a tree with same id was removed earlier then it\r\n                \/\/ would return null\r\n                conflicting = currentStateIdManager.getTree(id);\r\n            }\r\n            if (conflicting != null && conflicting.exists()) {\r\n                \/\/ resolve uuid conflict\r\n                tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\r\n                if (tree == null) {\r\n                    \/\/ no new node has been created, so skip this node\r\n                    \/\/ push null onto stack for skipped node\r\n                    parents.push(null);\r\n                    log.debug(\"Skipping existing node \" + nodeInfo.getName());\r\n                    return;\r\n                }\r\n            } else {\r\n                \/\/ create new with given uuid\r\n                tree = createTree(parent, nodeInfo, id);\r\n            }\r\n        }\r\n    }\r\n    \/\/ process properties\r\n    for (PropInfo pi : propInfos) {\r\n        \/\/ find applicable definition\r\n        \/\/ TODO find better heuristics?\r\n        PropertyDefinition def = pi.getPropertyDef(effectiveNodeTypeProvider.getEffectiveNodeType(tree));\r\n        if (def.isProtected()) {\r\n            \/\/ skip protected property\r\n            log.debug(\"Skipping protected property \" + pi.getName());\r\n            \/\/ notify the ProtectedPropertyImporter.\r\n            for (ProtectedItemImporter ppi : pItemImporters) {\r\n                if (ppi instanceof ProtectedPropertyImporter && ((ProtectedPropertyImporter) ppi).handlePropInfo(tree, pi, def)) {\r\n                    log.debug(\"Protected property -> delegated to ProtectedPropertyImporter\");\r\n                    break;\r\n                }\r\n            \/* else: p-i-Importer isn't able to deal with this property.\r\n                             try next pp-importer *\/\r\n            }\r\n        } else {\r\n            \/\/ regular property -> create the property\r\n            createProperty(tree, pi, def);\r\n        }\r\n    }\r\n    parents.push(tree);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos) throws RepositoryException {\r\n    Tree parent = parents.peek();\r\n    Tree tree = null;\r\n    String id = nodeInfo.getUUID();\r\n    String nodeName = nodeInfo.getName();\r\n    String ntName = nodeInfo.getPrimaryTypeName();\r\n    if (parent == null) {\r\n        log.debug(\"Skipping node: \" + nodeName);\r\n                        parents.push(null);\r\n                if (pnImporter != null) {\r\n            pnImporter.startChildInfo(nodeInfo, propInfos);\r\n        }\r\n        return;\r\n    }\r\n    NodeDefinition parentDef = getDefinition(parent);\r\n    if (parentDef.isProtected()) {\r\n                parents.push(null);\r\n        log.debug(\"Skipping protected node: \" + nodeName);\r\n        if (pnImporter != null) {\r\n                                    pnImporter.startChildInfo(nodeInfo, propInfos);\r\n        } else {\r\n                        for (ProtectedItemImporter pni : pItemImporters) {\r\n                if (pni instanceof ProtectedNodeImporter && ((ProtectedNodeImporter) pni).start(parent)) {\r\n                    log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\r\n                    pnImporter = (ProtectedNodeImporter) pni;\r\n                    pnImporter.startChildInfo(nodeInfo, propInfos);\r\n                    break;\r\n                }\r\n                        }\r\n        }\r\n        return;\r\n    }\r\n    if (parent.hasChild(nodeName)) {\r\n                Tree existing = parent.getChild(nodeName);\r\n        NodeDefinition def = getDefinition(existing);\r\n        if (!def.allowsSameNameSiblings()) {\r\n                        if (def.isProtected() && isNodeType(existing, ntName)) {\r\n                                log.debug(\"Skipping protected node: \" + existing);\r\n                parents.push(existing);\r\n                return;\r\n            }\r\n            if (def.isAutoCreated() && isNodeType(existing, ntName)) {\r\n                                tree = existing;\r\n            } else {\r\n                                                String existingIdentifier = IdentifierManager.getIdentifier(existing);\r\n                if (!(existingIdentifier.equals(id) && (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING || uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING))) {\r\n                    throw new ItemExistsException(\"Node with the same UUID exists:\" + existing);\r\n                }\r\n                        }\r\n        }\r\n    }\r\n    if (tree == null) {\r\n                if (id == null) {\r\n                        tree = createTree(parent, nodeInfo, id);\r\n        } else {\r\n                                    Tree conflicting = baseStateIdManager.getTree(id);\r\n            if (conflicting == null) {\r\n                                if (uuids.contains(id)) {\r\n                    conflicting = currentStateIdManager.getTree(id);\r\n                }\r\n            } else {\r\n                                                                                                conflicting = currentStateIdManager.getTree(id);\r\n            }\r\n            if (conflicting != null && conflicting.exists()) {\r\n                                tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\r\n                if (tree == null) {\r\n                                                            parents.push(null);\r\n                    log.debug(\"Skipping existing node \" + nodeInfo.getName());\r\n                    return;\r\n                }\r\n            } else {\r\n                                tree = createTree(parent, nodeInfo, id);\r\n            }\r\n        }\r\n    }\r\n        for (PropInfo pi : propInfos) {\r\n                        PropertyDefinition def = pi.getPropertyDef(effectiveNodeTypeProvider.getEffectiveNodeType(tree));\r\n        if (def.isProtected()) {\r\n                        log.debug(\"Skipping protected property \" + pi.getName());\r\n                        for (ProtectedItemImporter ppi : pItemImporters) {\r\n                if (ppi instanceof ProtectedPropertyImporter && ((ProtectedPropertyImporter) ppi).handlePropInfo(tree, pi, def)) {\r\n                    log.debug(\"Protected property -> delegated to ProtectedPropertyImporter\");\r\n                    break;\r\n                }\r\n                        }\r\n        } else {\r\n                        createProperty(tree, pi, def);\r\n        }\r\n    }\r\n    parents.push(tree);\r\n}","lc":3.5454545455,"pi":1.1866028708,"ma":4.2,"nbd":1.0,"ml":3.6666666667,"d":1.3432539683,"mi":-1.3385482734,"fo":3.4166666667,"r":-0.0263157895,"e":6.5363300542}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"@Override\r\npublic boolean copyTo(NodeStateBuilder destParent, String destName) {\r\n    if (!(destParent instanceof KernelNodeStateBuilder)) {\r\n        throw new IllegalArgumentException(\"Alien builder for destParent\");\r\n    }\r\n    if (destParent.getChildBuilder(destName) != null) {\r\n        return false;\r\n    }\r\n    KernelNodeStateBuilder destParentBuilder = (KernelNodeStateBuilder) destParent;\r\n    String destPath = PathUtils.concat(destParentBuilder.path, destName);\r\n    context.copyNode(path, destPath);\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean copyTo(NodeStateBuilder destParent, String destName) {\r\n    if (!(destParent instanceof KernelNodeStateBuilder)) {\r\n        throw new IllegalArgumentException(\"Alien builder for destParent\");\r\n    }\r\n    if (destParent.getChildBuilder(destName) != null) {\r\n        return false;\r\n    }\r\n    KernelNodeStateBuilder destParentBuilder = (KernelNodeStateBuilder) destParent;\r\n    String destPath = PathUtils.concat(destParentBuilder.path, destName);\r\n    context.copyNode(path, destPath);\r\n    return true;\r\n}","lc":-0.0454545455,"pi":-0.2535885167,"ma":0.0,"nbd":-0.5,"ml":0.0,"d":-0.0634920635,"mi":0.0319943622,"fo":-0.25,"r":0.0,"e":-0.0468341373}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3630_fcd64766","label":3,"code":"public void collectAggregates(NodeState root, ResultCollector collector) {\r\n    if (nodeTypeName.equals(ConfigUtil.getPrimaryTypeName(root))) {\r\n        List<Matcher> matchers = createMatchers();\r\n        collectAggregates(root, matchers, collector);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void collectAggregates(NodeState root, ResultCollector collector) {\r\n    if (nodeTypeName.equals(ConfigUtil.getPrimaryTypeName(root))) {\r\n        List<Matcher> matchers = createMatchers();\r\n        collectAggregates(root, matchers, collector);\r\n    }\r\n}","lc":-0.3636363636,"pi":0.1339712919,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.5075405215,"fo":-0.1666666667,"r":0.0789473684,"e":-0.1627934049}
{"project_name":"Math","project_version":"79","label":1,"code":"\/**\r\n * Calculates the L<sub>2<\/sub> (Euclidean) distance between two points.\r\n *\r\n * @param p1 the first point\r\n * @param p2 the second point\r\n * @return the L<sub>2<\/sub> distance between the two points\r\n *\/\r\npublic static double distance(int[] p1, int[] p2) {\r\n    int sum = 0;\r\n    for (int i = 0; i < p1.length; i++) {\r\n        final int dp = p1[i] - p2[i];\r\n        sum += dp * dp;\r\n    }\r\n    return Math.sqrt(sum);\r\n}","code_comment":"\/**\r\n * Calculates the L<sub>2<\/sub> (Euclidean) distance between two points.\r\n *\r\n * @param p1 the first point\r\n * @param p2 the second point\r\n * @return the L<sub>2<\/sub> distance between the two points\r\n *\/\r\n","code_no_comment":"public static double distance(int[] p1, int[] p2) {\r\n    int sum = 0;\r\n    for (int i = 0; i < p1.length; i++) {\r\n        final int dp = p1[i] - p2[i];\r\n        sum += dp * dp;\r\n    }\r\n    return Math.sqrt(sum);\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":0.878968254,"mi":0.3054263566,"fo":-0.4166666667,"r":1.9736842105,"e":0.2036502366}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4119_bb7a6995","label":1,"code":"\/**\r\n *  @see org.apache.wicket.request.resource.AbstractResource#newResourceResponse(org.apache.wicket.request.resource.IResource.Attributes)\r\n *\/\r\n@Override\r\nprotected ResourceResponse newResourceResponse(final Attributes attributes) {\r\n    final ResourceResponse response = new ResourceResponse();\r\n    response.setContentType(contentType);\r\n    response.setLastModified(lastModified);\r\n    final byte[] data = getData(attributes);\r\n    if (data == null) {\r\n        throw new WicketRuntimeException(\"ByteArrayResource's data cannot be 'null'.\");\r\n    }\r\n    response.setContentLength(data.length);\r\n    if (response.dataNeedsToBeWritten(attributes)) {\r\n        if (filename != null) {\r\n            response.setFileName(filename);\r\n            response.setContentDisposition(ContentDisposition.ATTACHMENT);\r\n        } else {\r\n            response.setContentDisposition(ContentDisposition.INLINE);\r\n        }\r\n        response.setWriteCallback(new WriteCallback() {\r\n\r\n            @Override\r\n            public void writeData(final Attributes attributes) {\r\n                attributes.getResponse().write(data);\r\n            }\r\n        });\r\n        configureResponse(response, attributes);\r\n    }\r\n    return response;\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.request.resource.AbstractResource#newResourceResponse(org.apache.wicket.request.resource.IResource.Attributes)\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected ResourceResponse newResourceResponse(final Attributes attributes) {\r\n    final ResourceResponse response = new ResourceResponse();\r\n    response.setContentType(contentType);\r\n    response.setLastModified(lastModified);\r\n    final byte[] data = getData(attributes);\r\n    if (data == null) {\r\n        throw new WicketRuntimeException(\"ByteArrayResource's data cannot be 'null'.\");\r\n    }\r\n    response.setContentLength(data.length);\r\n    if (response.dataNeedsToBeWritten(attributes)) {\r\n        if (filename != null) {\r\n            response.setFileName(filename);\r\n            response.setContentDisposition(ContentDisposition.ATTACHMENT);\r\n        } else {\r\n            response.setContentDisposition(ContentDisposition.INLINE);\r\n        }\r\n        response.setWriteCallback(new WriteCallback() {\r\n\r\n            @Override\r\n            public void writeData(final Attributes attributes) {\r\n                attributes.getResponse().write(data);\r\n            }\r\n        });\r\n        configureResponse(response, attributes);\r\n    }\r\n    return response;\r\n}","lc":0.5909090909,"pi":0.5741626794,"ma":0.2,"nbd":0.0,"ml":0.1666666667,"d":0.0,"mi":-0.4009866103,"fo":0.5,"r":-0.0263157895,"e":0.100281807}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5209_87884c7b","label":3,"code":"public List<String> getSystemClasspathElements() throws DependencyResolutionRequiredException {\r\n    List<String> list = new ArrayList<String>(getArtifacts().size());\r\n    list.add(getBuild().getOutputDirectory());\r\n    for (Artifact a : getArtifacts()) {\r\n        if (a.getArtifactHandler().isAddedToClasspath()) {\r\n            \/\/ TODO: let the scope handler deal with this\r\n            if (Artifact.SCOPE_SYSTEM.equals(a.getScope())) {\r\n                addArtifactPath(a, list);\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}","code_comment":null,"code_no_comment":"public List<String> getSystemClasspathElements() throws DependencyResolutionRequiredException {\r\n    List<String> list = new ArrayList<String>(getArtifacts().size());\r\n    list.add(getBuild().getOutputDirectory());\r\n    for (Artifact a : getArtifacts()) {\r\n        if (a.getArtifactHandler().isAddedToClasspath()) {\r\n                        if (Artifact.SCOPE_SYSTEM.equals(a.getScope())) {\r\n                addArtifactPath(a, list);\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}","lc":-0.0909090909,"pi":0.8421052632,"ma":0.0,"nbd":0.5,"ml":0.0,"d":-0.3650793651,"mi":0.0920366455,"fo":0.4166666667,"r":0.0526315789,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7364_7bbb88ba","label":1,"code":"public RestConfigurationDefinition property(String key, String value) {\r\n    \/*PropertyDefinition prop = new PropertyDefinition();\r\n        prop.setKey(key);\r\n        prop.setValue(value);\r\n        getProperties().add(prop);*\/\r\n    return this;\r\n}","code_comment":null,"code_no_comment":"public RestConfigurationDefinition property(String key, String value) {\r\n        return this;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0451021846,"fo":-0.5,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"\/**\r\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\r\n *  OVERRIDE.\r\n *\r\n *  Called when a request ends.\r\n *\/\r\n@Override\r\npublic void internalDetach() {\r\n    \/\/ Handle end request for the container itself\r\n    super.internalDetach();\r\n    \/\/ Loop through child components\r\n    for (Component child : this) {\r\n        \/\/ Call end request on the child\r\n        child.internalDetach();\r\n    }\r\n}","code_comment":"\/**\r\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\r\n *  OVERRIDE.\r\n *\r\n *  Called when a request ends.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void internalDetach() {\r\n        super.internalDetach();\r\n        for (Component child : this) {\r\n                child.internalDetach();\r\n    }\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6476391825,"fo":-0.3333333333,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5645_af1ecd5f","label":3,"code":"private static Integer getNextIntegerToken(StringTokenizer tok) {\r\n    String s = tok.nextToken();\r\n    if ((s.length() > 1) && s.startsWith(\"0\")) {\r\n        throw new NumberFormatException(\"Number part has a leading 0: '\" + s + \"'\");\r\n    }\r\n    return Integer.valueOf(s);\r\n}","code_comment":null,"code_no_comment":"private static Integer getNextIntegerToken(StringTokenizer tok) {\r\n    String s = tok.nextToken();\r\n    if ((s.length() > 1) && s.startsWith(\"0\")) {\r\n        throw new NumberFormatException(\"Number part has a leading 0: '\" + s + \"'\");\r\n    }\r\n    return Integer.valueOf(s);\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":0.1805555556,"mi":0.3773079634,"fo":-0.1666666667,"r":0.9210526316,"e":-0.0203246832}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2839_15477252","label":1,"code":"@Override\r\npublic void write(byte[] b, int off, int len) throws IOException {\r\n    if (off == 0 || len == b.length) {\r\n        write(b);\r\n    } else {\r\n        byte[] copy = new byte[len];\r\n        System.arraycopy(b, off, copy, 0, len);\r\n        write(copy);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void write(byte[] b, int off, int len) throws IOException {\r\n    if (off == 0 || len == b.length) {\r\n        write(b);\r\n    } else {\r\n        byte[] copy = new byte[len];\r\n        System.arraycopy(b, off, copy, 0, len);\r\n        write(copy);\r\n    }\r\n}","lc":-0.1818181818,"pi":0.1578947368,"ma":-0.4,"nbd":-0.5,"ml":0.0,"d":0.0476190476,"mi":0.2197322058,"fo":-0.25,"r":0.0789473684,"e":-0.0539709433}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1922_ccd574a4","label":1,"code":"public void deployToSlot(final SimpleSlot slot) throws JobException {\r\n    \/\/ sanity checks\r\n    if (slot == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    if (!slot.isAlive()) {\r\n        throw new JobException(\"Target slot for deployment is not alive.\");\r\n    }\r\n    \/\/ make sure exactly one deployment call happens from the correct state\r\n    \/\/ note: the transition from CREATED to DEPLOYING is for testing purposes only\r\n    ExecutionState previous = this.state;\r\n    if (previous == SCHEDULED || previous == CREATED) {\r\n        if (!transitionState(previous, DEPLOYING)) {\r\n            \/\/ this should actually not happen and indicates a race somewhere else\r\n            throw new IllegalStateException(\"Cannot deploy task: Concurrent deployment call race.\");\r\n        }\r\n    } else {\r\n        \/\/ vertex may have been cancelled, or it was already scheduled\r\n        throw new IllegalStateException(\"The vertex must be in CREATED or SCHEDULED state to be deployed. Found state \" + previous);\r\n    }\r\n    try {\r\n        \/\/ good, we are allowed to deploy\r\n        if (!slot.setExecutedVertex(this)) {\r\n            throw new JobException(\"Could not assign the ExecutionVertex to the slot \" + slot);\r\n        }\r\n        this.assignedResource = slot;\r\n        this.assignedResourceLocation = slot.getInstance().getInstanceConnectionInfo();\r\n        \/\/ race double check, did we fail\/cancel and do we need to release the slot?\r\n        if (this.state != DEPLOYING) {\r\n            slot.releaseSlot();\r\n            return;\r\n        }\r\n        if (LOG.isInfoEnabled()) {\r\n            LOG.info(String.format(\"Deploying %s (attempt #%d) to %s\", vertex.getSimpleName(), attemptNumber, slot.getInstance().getInstanceConnectionInfo().getHostname()));\r\n        }\r\n        final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(attemptId, slot);\r\n        \/\/ register this execution at the execution graph, to receive call backs\r\n        vertex.getExecutionGraph().registerExecution(this);\r\n        Instance instance = slot.getInstance();\r\n        Future<Object> deployAction = Patterns.ask(instance.getTaskManager(), new SubmitTask(deployment), new Timeout(timeout));\r\n        deployAction.onComplete(new OnComplete<Object>() {\r\n\r\n            @Override\r\n            public void onComplete(Throwable failure, Object success) throws Throwable {\r\n                if (failure != null) {\r\n                    if (failure instanceof TimeoutException) {\r\n                        markFailed(new Exception(\"Cannot deploy task - TaskManager not responding.\", failure));\r\n                    } else {\r\n                        markFailed(failure);\r\n                    }\r\n                } else {\r\n                    if (success == null) {\r\n                        markFailed(new Exception(\"Failed to deploy the task to slot \" + slot + \": TaskOperationResult was null\"));\r\n                    }\r\n                    if (success instanceof TaskOperationResult) {\r\n                        TaskOperationResult result = (TaskOperationResult) success;\r\n                        if (!result.executionID().equals(attemptId)) {\r\n                            markFailed(new Exception(\"Answer execution id does not match the request execution id.\"));\r\n                        } else if (result.success()) {\r\n                            switchToRunning();\r\n                        } else {\r\n                            \/\/ deployment failed :(\r\n                            markFailed(new Exception(\"Failed to deploy the task \" + getVertexWithAttempt() + \" to slot \" + slot + \": \" + result.description()));\r\n                        }\r\n                    } else {\r\n                        markFailed(new Exception(\"Failed to deploy the task to slot \" + slot + \": Response was not of type TaskOperationResult\"));\r\n                    }\r\n                }\r\n            }\r\n        }, AkkaUtils.globalExecutionContext());\r\n    } catch (Throwable t) {\r\n        markFailed(t);\r\n        ExceptionUtils.rethrow(t);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void deployToSlot(final SimpleSlot slot) throws JobException {\r\n        if (slot == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    if (!slot.isAlive()) {\r\n        throw new JobException(\"Target slot for deployment is not alive.\");\r\n    }\r\n            ExecutionState previous = this.state;\r\n    if (previous == SCHEDULED || previous == CREATED) {\r\n        if (!transitionState(previous, DEPLOYING)) {\r\n                        throw new IllegalStateException(\"Cannot deploy task: Concurrent deployment call race.\");\r\n        }\r\n    } else {\r\n                throw new IllegalStateException(\"The vertex must be in CREATED or SCHEDULED state to be deployed. Found state \" + previous);\r\n    }\r\n    try {\r\n                if (!slot.setExecutedVertex(this)) {\r\n            throw new JobException(\"Could not assign the ExecutionVertex to the slot \" + slot);\r\n        }\r\n        this.assignedResource = slot;\r\n        this.assignedResourceLocation = slot.getInstance().getInstanceConnectionInfo();\r\n                if (this.state != DEPLOYING) {\r\n            slot.releaseSlot();\r\n            return;\r\n        }\r\n        if (LOG.isInfoEnabled()) {\r\n            LOG.info(String.format(\"Deploying %s (attempt #%d) to %s\", vertex.getSimpleName(), attemptNumber, slot.getInstance().getInstanceConnectionInfo().getHostname()));\r\n        }\r\n        final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(attemptId, slot);\r\n                vertex.getExecutionGraph().registerExecution(this);\r\n        Instance instance = slot.getInstance();\r\n        Future<Object> deployAction = Patterns.ask(instance.getTaskManager(), new SubmitTask(deployment), new Timeout(timeout));\r\n        deployAction.onComplete(new OnComplete<Object>() {\r\n\r\n            @Override\r\n            public void onComplete(Throwable failure, Object success) throws Throwable {\r\n                if (failure != null) {\r\n                    if (failure instanceof TimeoutException) {\r\n                        markFailed(new Exception(\"Cannot deploy task - TaskManager not responding.\", failure));\r\n                    } else {\r\n                        markFailed(failure);\r\n                    }\r\n                } else {\r\n                    if (success == null) {\r\n                        markFailed(new Exception(\"Failed to deploy the task to slot \" + slot + \": TaskOperationResult was null\"));\r\n                    }\r\n                    if (success instanceof TaskOperationResult) {\r\n                        TaskOperationResult result = (TaskOperationResult) success;\r\n                        if (!result.executionID().equals(attemptId)) {\r\n                            markFailed(new Exception(\"Answer execution id does not match the request execution id.\"));\r\n                        } else if (result.success()) {\r\n                            switchToRunning();\r\n                        } else {\r\n                                                        markFailed(new Exception(\"Failed to deploy the task \" + getVertexWithAttempt() + \" to slot \" + slot + \": \" + result.description()));\r\n                        }\r\n                    } else {\r\n                        markFailed(new Exception(\"Failed to deploy the task to slot \" + slot + \": Response was not of type TaskOperationResult\"));\r\n                    }\r\n                }\r\n            }\r\n        }, AkkaUtils.globalExecutionContext());\r\n    } catch (Throwable t) {\r\n        markFailed(t);\r\n        ExceptionUtils.rethrow(t);\r\n    }\r\n}","lc":2.3181818182,"pi":2.2918660287,"ma":3.2,"nbd":2.0,"ml":1.75,"d":0.7023809524,"mi":-1.0845665962,"fo":2.4166666667,"r":-0.0263157895,"e":2.5599119425}
{"project_name":"Collections","project_version":"25","label":1,"code":"\/**\r\n * Gets an iterator that provides an ordered iteration over the elements\r\n * contained in an array of {@link Iterator}s.\r\n * <p>\r\n * Given two ordered {@link Iterator}s <code>A<\/code> and <code>B<\/code>,\r\n * the {@link Iterator#next()} method will return the lesser of\r\n * <code>A.next()<\/code> and <code>B.next()<\/code> and so on.\r\n * <p>\r\n * The comparator is optional. If null is specified then natural order is used.\r\n *\r\n * @param <E>  the element type\r\n * @param comparator  the comparator to use, may be null for natural order\r\n * @param iterators  the iterators to use, not null or empty or contain nulls\r\n * @return a combination iterator over the iterators\r\n * @throws NullPointerException if iterators array is null or contains a null value\r\n *\/\r\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E>... iterators) {\r\n    return new CollatingIterator<E>(comparator, iterators);\r\n}","code_comment":"\/**\r\n * Gets an iterator that provides an ordered iteration over the elements\r\n * contained in an array of {@link Iterator}s.\r\n * <p>\r\n * Given two ordered {@link Iterator}s <code>A<\/code> and <code>B<\/code>,\r\n * the {@link Iterator#next()} method will return the lesser of\r\n * <code>A.next()<\/code> and <code>B.next()<\/code> and so on.\r\n * <p>\r\n * The comparator is optional. If null is specified then natural order is used.\r\n *\r\n * @param <E>  the element type\r\n * @param comparator  the comparator to use, may be null for natural order\r\n * @param iterators  the iterators to use, not null or empty or contain nulls\r\n * @return a combination iterator over the iterators\r\n * @throws NullPointerException if iterators array is null or contains a null value\r\n *\/\r\n","code_no_comment":"public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E>... iterators) {\r\n    return new CollatingIterator<E>(comparator, iterators);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9114869626,"fo":-0.5,"r":0.0526315789,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1822_3e83a4c1","label":1,"code":"\/**\r\n * Add a new or update an existing map entry.\r\n * The property is a map of revisions \/ values.\r\n *\r\n * @param property the property\r\n * @param revision the revision\r\n * @param value the value\r\n *\/\r\nvoid setMapEntry(@Nonnull String property, @Nonnull Revision revision, String value) {\r\n    Operation op = new Operation();\r\n    op.type = Operation.Type.SET_MAP_ENTRY;\r\n    op.value = value;\r\n    changes.put(new Key(property, checkNotNull(revision)), op);\r\n}","code_comment":"\/**\r\n * Add a new or update an existing map entry.\r\n * The property is a map of revisions \/ values.\r\n *\r\n * @param property the property\r\n * @param revision the revision\r\n * @param value the value\r\n *\/\r\n","code_no_comment":"void setMapEntry(@Nonnull String property, @Nonnull Revision revision, String value) {\r\n    Operation op = new Operation();\r\n    op.type = Operation.Type.SET_MAP_ENTRY;\r\n    op.value = value;\r\n    changes.put(new Key(property, checkNotNull(revision)), op);\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4401691332,"fo":-0.3333333333,"r":2.0,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2962_023be574","label":0,"code":"@Override\r\npublic void write(DataOutput out) throws IOException {\r\n    range.write(out);\r\n    out.writeInt(locations.length);\r\n    for (int i = 0; i < locations.length; ++i) out.writeUTF(locations[i]);\r\n    out.writeBoolean(null != isolatedScan);\r\n    if (null != isolatedScan) {\r\n        out.writeBoolean(isolatedScan);\r\n    }\r\n    out.writeBoolean(null != offline);\r\n    if (null != offline) {\r\n        out.writeBoolean(offline);\r\n    }\r\n    out.writeBoolean(null != localIterators);\r\n    if (null != localIterators) {\r\n        out.writeBoolean(localIterators);\r\n    }\r\n    out.writeBoolean(null != mockInstance);\r\n    if (null != mockInstance) {\r\n        out.writeBoolean(mockInstance);\r\n    }\r\n    out.writeBoolean(null != fetchedColumns);\r\n    if (null != fetchedColumns) {\r\n        String[] cols = InputConfigurator.serializeColumns(fetchedColumns);\r\n        out.writeInt(cols.length);\r\n        for (String col : cols) {\r\n            out.writeUTF(col);\r\n        }\r\n    }\r\n    out.writeBoolean(null != auths);\r\n    if (null != auths) {\r\n        out.writeUTF(auths.serialize());\r\n    }\r\n    out.writeBoolean(null != principal);\r\n    if (null != principal) {\r\n        out.writeUTF(principal);\r\n    }\r\n    out.writeBoolean(null != token);\r\n    if (null != token) {\r\n        out.writeUTF(token.getClass().getCanonicalName());\r\n        try {\r\n            out.writeUTF(CredentialHelper.tokenAsBase64(token));\r\n        } catch (AccumuloSecurityException e) {\r\n            throw new IOException(e);\r\n        }\r\n    }\r\n    out.writeBoolean(null != instanceName);\r\n    if (null != instanceName) {\r\n        out.writeUTF(instanceName);\r\n    }\r\n    out.writeBoolean(null != zooKeepers);\r\n    if (null != zooKeepers) {\r\n        out.writeUTF(zooKeepers);\r\n    }\r\n    out.writeBoolean(null != level);\r\n    if (null != level) {\r\n        out.writeInt(level.toInt());\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void write(DataOutput out) throws IOException {\r\n    range.write(out);\r\n    out.writeInt(locations.length);\r\n    for (int i = 0; i < locations.length; ++i) out.writeUTF(locations[i]);\r\n    out.writeBoolean(null != isolatedScan);\r\n    if (null != isolatedScan) {\r\n        out.writeBoolean(isolatedScan);\r\n    }\r\n    out.writeBoolean(null != offline);\r\n    if (null != offline) {\r\n        out.writeBoolean(offline);\r\n    }\r\n    out.writeBoolean(null != localIterators);\r\n    if (null != localIterators) {\r\n        out.writeBoolean(localIterators);\r\n    }\r\n    out.writeBoolean(null != mockInstance);\r\n    if (null != mockInstance) {\r\n        out.writeBoolean(mockInstance);\r\n    }\r\n    out.writeBoolean(null != fetchedColumns);\r\n    if (null != fetchedColumns) {\r\n        String[] cols = InputConfigurator.serializeColumns(fetchedColumns);\r\n        out.writeInt(cols.length);\r\n        for (String col : cols) {\r\n            out.writeUTF(col);\r\n        }\r\n    }\r\n    out.writeBoolean(null != auths);\r\n    if (null != auths) {\r\n        out.writeUTF(auths.serialize());\r\n    }\r\n    out.writeBoolean(null != principal);\r\n    if (null != principal) {\r\n        out.writeUTF(principal);\r\n    }\r\n    out.writeBoolean(null != token);\r\n    if (null != token) {\r\n        out.writeUTF(token.getClass().getCanonicalName());\r\n        try {\r\n            out.writeUTF(CredentialHelper.tokenAsBase64(token));\r\n        } catch (AccumuloSecurityException e) {\r\n            throw new IOException(e);\r\n        }\r\n    }\r\n    out.writeBoolean(null != instanceName);\r\n    if (null != instanceName) {\r\n        out.writeUTF(instanceName);\r\n    }\r\n    out.writeBoolean(null != zooKeepers);\r\n    if (null != zooKeepers) {\r\n        out.writeUTF(zooKeepers);\r\n    }\r\n    out.writeBoolean(null != level);\r\n    if (null != level) {\r\n        out.writeInt(level.toInt());\r\n    }\r\n}","lc":2.0454545455,"pi":-0.1770334928,"ma":2.4,"nbd":0.0,"ml":1.6666666667,"d":1.130952381,"mi":-0.9915433404,"fo":2.25,"r":-0.0263157895,"e":3.0997965688}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public void removeConstraint(ByteBuffer login, String tableName, int constraint) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\r\n    send_removeConstraint(login, tableName, constraint);\r\n    recv_removeConstraint();\r\n}","code_comment":null,"code_no_comment":"public void removeConstraint(ByteBuffer login, String tableName, int constraint) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\r\n    send_removeConstraint(login, tableName, constraint);\r\n    recv_removeConstraint();\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7147286822,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Compress","project_version":"43","label":3,"code":"\/**\r\n * Writes the data descriptor entry.\r\n * @param ze the entry to write\r\n * @throws IOException on error\r\n *\/\r\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\r\n    if (ze.getMethod() != DEFLATED || channel != null) {\r\n        return;\r\n    }\r\n    writeCounted(DD_SIG);\r\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\r\n    if (!hasZip64Extra(ze)) {\r\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\r\n        writeCounted(ZipLong.getBytes(ze.getSize()));\r\n    } else {\r\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\r\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\r\n    }\r\n}","code_comment":"\/**\r\n * Writes the data descriptor entry.\r\n * @param ze the entry to write\r\n * @throws IOException on error\r\n *\/\r\n","code_no_comment":"protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\r\n    if (ze.getMethod() != DEFLATED || channel != null) {\r\n        return;\r\n    }\r\n    writeCounted(DD_SIG);\r\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\r\n    if (!hasZip64Extra(ze)) {\r\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\r\n        writeCounted(ZipLong.getBytes(ze.getSize()));\r\n    } else {\r\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\r\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\r\n    }\r\n}","lc":0.0,"pi":-0.1387559809,"ma":-0.2,"nbd":-0.5,"ml":0.1666666667,"d":0.0654761905,"mi":-0.0153629316,"fo":1.0,"r":0.0,"e":0.025870922}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5265_0eb596df","label":1,"code":"@Override\r\nprotected void onRemove() {\r\n    super.onRemove();\r\n    if (fence != null) {\r\n        \/\/ decrement the fence count\r\n        Integer count = fence.getMetaData(FENCE_KEY);\r\n        count = (count == null || count == 1) ? null : count - 1;\r\n        fence.setMetaData(FENCE_KEY, count);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void onRemove() {\r\n    super.onRemove();\r\n    if (fence != null) {\r\n                Integer count = fence.getMetaData(FENCE_KEY);\r\n        count = (count == null || count == 1) ? null : count - 1;\r\n        fence.setMetaData(FENCE_KEY, count);\r\n    }\r\n}","lc":-0.2272727273,"pi":0.1339712919,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":0.4642857143,"mi":0.2529950669,"fo":-0.25,"r":0.4473684211,"e":0.0685626689}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5565_204849bc","label":1,"code":"\/**\r\n *  @see IRequestMapper#getCompatibilityScore(Request)\r\n *\/\r\n@Override\r\npublic abstract int getCompatibilityScore(Request request);","code_comment":"\/**\r\n *  @see IRequestMapper#getCompatibilityScore(Request)\r\n *\/\r\n","code_no_comment":"@Override\r\npublic abstract int getCompatibilityScore(Request request);","lc":-0.5454545455,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.2951374207,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2238_a28098fd","label":1,"code":"\/**\r\n * Returns the node or property delegate at the given path.\r\n *\r\n * @param path Oak path\r\n * @return node or property delegate, or {@code null} if none exists\r\n *\/\r\n@CheckForNull\r\npublic ItemDelegate getItem(String path) {\r\n    String name = PathUtils.getName(path);\r\n    if (name.isEmpty()) {\r\n        return getRootNode();\r\n    } else {\r\n        Tree parent = root.getTree(PathUtils.getParentPath(path));\r\n        if (parent.hasProperty(name)) {\r\n            return new PropertyDelegate(this, parent, name);\r\n        }\r\n        Tree child = parent.getChild(name);\r\n        if (child.exists()) {\r\n            return new NodeDelegate(this, child);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Returns the node or property delegate at the given path.\r\n *\r\n * @param path Oak path\r\n * @return node or property delegate, or {@code null} if none exists\r\n *\/\r\n","code_no_comment":"@CheckForNull\r\npublic ItemDelegate getItem(String path) {\r\n    String name = PathUtils.getName(path);\r\n    if (name.isEmpty()) {\r\n        return getRootNode();\r\n    } else {\r\n        Tree parent = root.getTree(PathUtils.getParentPath(path));\r\n        if (parent.hasProperty(name)) {\r\n            return new PropertyDelegate(this, parent, name);\r\n        }\r\n        Tree child = parent.getChild(name);\r\n        if (child.exists()) {\r\n            return new NodeDelegate(this, child);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}","lc":0.1818181818,"pi":0.3875598086,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":-0.3650793651,"mi":-0.1320648344,"fo":0.1666666667,"r":0.1052631579,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-699_b2e24119","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic double inverseCumulativeProbability(final double p) throws OutOfRangeException {\r\n    if (p < 0.0 || p > 1.0) {\r\n        throw new OutOfRangeException(p, 0, 1);\r\n    }\r\n    \/\/ by default, do simple root finding using bracketing and default solver.\r\n    \/\/ subclasses can override if there is a better method.\r\n    UnivariateFunction rootFindingFunction = new UnivariateFunction() {\r\n\r\n        public double value(double x) {\r\n            return cumulativeProbability(x) - p;\r\n        }\r\n    };\r\n    \/\/ Try to bracket root, test domain endpoints if this fails\r\n    double lowerBound = getDomainLowerBound(p);\r\n    double upperBound = getDomainUpperBound(p);\r\n    double[] bracket = null;\r\n    try {\r\n        bracket = UnivariateRealSolverUtils.bracket(rootFindingFunction, getInitialDomain(p), lowerBound, upperBound);\r\n    } catch (NumberIsTooLargeException ex) {\r\n        \/*\r\n             * Check domain endpoints to see if one gives value that is within\r\n             * the default solver's defaultAbsoluteAccuracy of 0 (will be the\r\n             * case if density has bounded support and p is 0 or 1).\r\n             *\/\r\n        if (FastMath.abs(rootFindingFunction.value(lowerBound)) < getSolverAbsoluteAccuracy()) {\r\n            return lowerBound;\r\n        }\r\n        if (FastMath.abs(rootFindingFunction.value(upperBound)) < getSolverAbsoluteAccuracy()) {\r\n            return upperBound;\r\n        }\r\n        \/\/ Failed bracket convergence was not because of corner solution\r\n        throw new MathInternalError(ex);\r\n    }\r\n    \/\/ find root\r\n    double root = UnivariateRealSolverUtils.solve(rootFindingFunction, \/\/ absolute accuracy different from the default.\r\n    bracket[0], bracket[1], getSolverAbsoluteAccuracy());\r\n    return root;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\r\n    if (p < 0.0 || p > 1.0) {\r\n        throw new OutOfRangeException(p, 0, 1);\r\n    }\r\n            UnivariateFunction rootFindingFunction = new UnivariateFunction() {\r\n\r\n        public double value(double x) {\r\n            return cumulativeProbability(x) - p;\r\n        }\r\n    };\r\n        double lowerBound = getDomainLowerBound(p);\r\n    double upperBound = getDomainUpperBound(p);\r\n    double[] bracket = null;\r\n    try {\r\n        bracket = UnivariateRealSolverUtils.bracket(rootFindingFunction, getInitialDomain(p), lowerBound, upperBound);\r\n    } catch (NumberIsTooLargeException ex) {\r\n                if (FastMath.abs(rootFindingFunction.value(lowerBound)) < getSolverAbsoluteAccuracy()) {\r\n            return lowerBound;\r\n        }\r\n        if (FastMath.abs(rootFindingFunction.value(upperBound)) < getSolverAbsoluteAccuracy()) {\r\n            return upperBound;\r\n        }\r\n                throw new MathInternalError(ex);\r\n    }\r\n        double root = UnivariateRealSolverUtils.solve(rootFindingFunction,     bracket[0], bracket[1], getSolverAbsoluteAccuracy());\r\n    return root;\r\n}","lc":0.5909090909,"pi":0.0765550239,"ma":0.6,"nbd":0.0,"ml":0.5833333333,"d":0.5099206349,"mi":-0.4460887949,"fo":0.5833333333,"r":-0.0263157895,"e":0.6239979715}
{"project_name":"Lang","project_version":"11","label":3,"code":"\/**\r\n * <p>Creates a random string based on a variety of options, using\r\n * supplied source of randomness.<\/p>\r\n *\r\n * <p>If start and end are both {@code 0}, start and end are set\r\n * to {@code ' '} and {@code 'z'}, the ASCII printable\r\n * characters, will be used, unless letters and numbers are both\r\n * {@code false}, in which case, start and end are set to\r\n * {@code 0} and {@code Integer.MAX_VALUE}.\r\n *\r\n * <p>If set is not {@code null}, characters between start and\r\n * end are chosen.<\/p>\r\n *\r\n * <p>This method accepts a user-supplied {@link Random}\r\n * instance to use as a source of randomness. By seeding a single\r\n * {@link Random} instance with a fixed seed and using it for each call,\r\n * the same random sequence of strings can be generated repeatedly\r\n * and predictably.<\/p>\r\n *\r\n * @param count  the length of random string to create\r\n * @param start  the position in set of chars to start at\r\n * @param end  the position in set of chars to end before\r\n * @param letters  only allow letters?\r\n * @param numbers  only allow numbers?\r\n * @param chars  the set of chars to choose randoms from, must not be empty.\r\n *  If {@code null}, then it will use the set of all chars.\r\n * @param random  a source of randomness.\r\n * @return the random string\r\n * @throws ArrayIndexOutOfBoundsException if there are not\r\n *  {@code (end - start) + 1} characters in the set array.\r\n * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\r\n * @since 2.0\r\n *\/\r\npublic static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\r\n    if (count == 0) {\r\n        return \"\";\r\n    } else if (count < 0) {\r\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\r\n    }\r\n    if (chars != null && chars.length == 0) {\r\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\r\n    }\r\n    if (start == 0 && end == 0) {\r\n        if (chars != null) {\r\n            end = chars.length;\r\n        } else {\r\n            if (!letters && !numbers) {\r\n                end = Integer.MAX_VALUE;\r\n            } else {\r\n                end = 'z' + 1;\r\n                start = ' ';\r\n            }\r\n        }\r\n    }\r\n    char[] buffer = new char[count];\r\n    int gap = end - start;\r\n    while (count-- != 0) {\r\n        char ch;\r\n        if (chars == null) {\r\n            ch = (char) (random.nextInt(gap) + start);\r\n        } else {\r\n            ch = chars[random.nextInt(gap) + start];\r\n        }\r\n        if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) {\r\n            if (ch >= 56320 && ch <= 57343) {\r\n                if (count == 0) {\r\n                    count++;\r\n                } else {\r\n                    \/\/ low surrogate, insert high surrogate after putting it in\r\n                    buffer[count] = ch;\r\n                    count--;\r\n                    buffer[count] = (char) (55296 + random.nextInt(128));\r\n                }\r\n            } else if (ch >= 55296 && ch <= 56191) {\r\n                if (count == 0) {\r\n                    count++;\r\n                } else {\r\n                    \/\/ high surrogate, insert low surrogate before putting it in\r\n                    buffer[count] = (char) (56320 + random.nextInt(128));\r\n                    count--;\r\n                    buffer[count] = ch;\r\n                }\r\n            } else if (ch >= 56192 && ch <= 56319) {\r\n                \/\/ private high surrogate, no effing clue, so skip it\r\n                count++;\r\n            } else {\r\n                buffer[count] = ch;\r\n            }\r\n        } else {\r\n            count++;\r\n        }\r\n    }\r\n    return new String(buffer);\r\n}","code_comment":"\/**\r\n * <p>Creates a random string based on a variety of options, using\r\n * supplied source of randomness.<\/p>\r\n *\r\n * <p>If start and end are both {@code 0}, start and end are set\r\n * to {@code ' '} and {@code 'z'}, the ASCII printable\r\n * characters, will be used, unless letters and numbers are both\r\n * {@code false}, in which case, start and end are set to\r\n * {@code 0} and {@code Integer.MAX_VALUE}.\r\n *\r\n * <p>If set is not {@code null}, characters between start and\r\n * end are chosen.<\/p>\r\n *\r\n * <p>This method accepts a user-supplied {@link Random}\r\n * instance to use as a source of randomness. By seeding a single\r\n * {@link Random} instance with a fixed seed and using it for each call,\r\n * the same random sequence of strings can be generated repeatedly\r\n * and predictably.<\/p>\r\n *\r\n * @param count  the length of random string to create\r\n * @param start  the position in set of chars to start at\r\n * @param end  the position in set of chars to end before\r\n * @param letters  only allow letters?\r\n * @param numbers  only allow numbers?\r\n * @param chars  the set of chars to choose randoms from, must not be empty.\r\n *  If {@code null}, then it will use the set of all chars.\r\n * @param random  a source of randomness.\r\n * @return the random string\r\n * @throws ArrayIndexOutOfBoundsException if there are not\r\n *  {@code (end - start) + 1} characters in the set array.\r\n * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\r\n * @since 2.0\r\n *\/\r\n","code_no_comment":"public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\r\n    if (count == 0) {\r\n        return \"\";\r\n    } else if (count < 0) {\r\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\r\n    }\r\n    if (chars != null && chars.length == 0) {\r\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\r\n    }\r\n    if (start == 0 && end == 0) {\r\n        if (chars != null) {\r\n            end = chars.length;\r\n        } else {\r\n            if (!letters && !numbers) {\r\n                end = Integer.MAX_VALUE;\r\n            } else {\r\n                end = 'z' + 1;\r\n                start = ' ';\r\n            }\r\n        }\r\n    }\r\n    char[] buffer = new char[count];\r\n    int gap = end - start;\r\n    while (count-- != 0) {\r\n        char ch;\r\n        if (chars == null) {\r\n            ch = (char) (random.nextInt(gap) + start);\r\n        } else {\r\n            ch = chars[random.nextInt(gap) + start];\r\n        }\r\n        if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) {\r\n            if (ch >= 56320 && ch <= 57343) {\r\n                if (count == 0) {\r\n                    count++;\r\n                } else {\r\n                                        buffer[count] = ch;\r\n                    count--;\r\n                    buffer[count] = (char) (55296 + random.nextInt(128));\r\n                }\r\n            } else if (ch >= 55296 && ch <= 56191) {\r\n                if (count == 0) {\r\n                    count++;\r\n                } else {\r\n                                        buffer[count] = (char) (56320 + random.nextInt(128));\r\n                    count--;\r\n                    buffer[count] = ch;\r\n                }\r\n            } else if (ch >= 56192 && ch <= 56319) {\r\n                                count++;\r\n            } else {\r\n                buffer[count] = ch;\r\n            }\r\n        } else {\r\n            count++;\r\n        }\r\n    }\r\n    return new String(buffer);\r\n}","lc":2.0,"pi":1.2966507177,"ma":2.6,"nbd":1.5,"ml":2.5,"d":3.5595238095,"mi":-1.0025369979,"fo":0.0,"r":-0.0263157895,"e":9.1546526973}
{"project_name":"Cli","project_version":"14","label":1,"code":"public void validate(final WriteableCommandLine commandLine) throws OptionException {\r\n    \/\/ number of options found\r\n    int present = 0;\r\n    \/\/ reference to first unexpected option\r\n    Option unexpected = null;\r\n    for (final Iterator i = options.iterator(); i.hasNext(); ) {\r\n        final Option option = (Option) i.next();\r\n        \/\/ needs validation?\r\n        boolean validate = option.isRequired() || option instanceof Group;\r\n        if (validate) {\r\n            option.validate(commandLine);\r\n        }\r\n        \/\/ if the child option is present then validate it\r\n        if (commandLine.hasOption(option)) {\r\n            if (++present > maximum) {\r\n                unexpected = option;\r\n                break;\r\n            }\r\n            option.validate(commandLine);\r\n        }\r\n    }\r\n    \/\/ too many options\r\n    if (unexpected != null) {\r\n        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, unexpected.getPreferredName());\r\n    }\r\n    \/\/ too few option\r\n    if (present < minimum) {\r\n        throw new OptionException(this, ResourceConstants.MISSING_OPTION);\r\n    }\r\n    \/\/ validate each anonymous argument\r\n    for (final Iterator i = anonymous.iterator(); i.hasNext(); ) {\r\n        final Option option = (Option) i.next();\r\n        option.validate(commandLine);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void validate(final WriteableCommandLine commandLine) throws OptionException {\r\n        int present = 0;\r\n        Option unexpected = null;\r\n    for (final Iterator i = options.iterator(); i.hasNext(); ) {\r\n        final Option option = (Option) i.next();\r\n                boolean validate = option.isRequired() || option instanceof Group;\r\n        if (validate) {\r\n            option.validate(commandLine);\r\n        }\r\n                if (commandLine.hasOption(option)) {\r\n            if (++present > maximum) {\r\n                unexpected = option;\r\n                break;\r\n            }\r\n            option.validate(commandLine);\r\n        }\r\n    }\r\n        if (unexpected != null) {\r\n        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, unexpected.getPreferredName());\r\n    }\r\n        if (present < minimum) {\r\n        throw new OptionException(this, ResourceConstants.MISSING_OPTION);\r\n    }\r\n        for (final Iterator i = anonymous.iterator(); i.hasNext(); ) {\r\n        final Option option = (Option) i.next();\r\n        option.validate(commandLine);\r\n    }\r\n}","lc":0.6363636364,"pi":0.5071770335,"ma":1.4,"nbd":0.5,"ml":0.8333333333,"d":1.0892857143,"mi":-0.4931642001,"fo":0.5,"r":-0.0263157895,"e":1.1845276995}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-843_65390f8c","label":3,"code":"@Override\r\npublic void merge(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n    throw new NotImplementedException();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void merge(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n    throw new NotImplementedException();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.4,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7685694151,"fo":-0.5,"r":0.0789473684,"e":-0.1627934049}
{"project_name":"Compress","project_version":"4","label":1,"code":"\/**\r\n * Performs all changes collected in this ChangeSet on the input stream and\r\n * streams the result to the output stream. Perform may be called more than once.\r\n *\r\n * This method finishes the stream, no other entries should be added\r\n * after that.\r\n *\r\n * @param in\r\n *            the InputStream to perform the changes on\r\n * @param out\r\n *            the resulting OutputStream with all modifications\r\n * @throws IOException\r\n *             if an read\/write error occurs\r\n * @return the results of this operation\r\n *\/\r\npublic ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {\r\n    ChangeSetResults results = new ChangeSetResults();\r\n    Set workingSet = new LinkedHashSet(changes);\r\n    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {\r\n        Change change = (Change) it.next();\r\n        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\r\n            copyStream(change.getInput(), out, change.getEntry());\r\n            it.remove();\r\n            results.addedFromChangeSet(change.getEntry().getName());\r\n        }\r\n    }\r\n    ArchiveEntry entry = null;\r\n    while ((entry = in.getNextEntry()) != null) {\r\n        boolean copy = true;\r\n        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {\r\n            Change change = (Change) it.next();\r\n            final int type = change.type();\r\n            final String name = entry.getName();\r\n            if (type == Change.TYPE_DELETE && name != null) {\r\n                if (name.equals(change.targetFile())) {\r\n                    copy = false;\r\n                    it.remove();\r\n                    results.deleted(name);\r\n                    break;\r\n                }\r\n            } else if (type == Change.TYPE_DELETE_DIR && name != null) {\r\n                if (name.startsWith(change.targetFile() + \"\/\")) {\r\n                    copy = false;\r\n                    results.deleted(name);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (copy) {\r\n            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\r\n                copyStream(in, out, entry);\r\n                results.addedFromStream(entry.getName());\r\n            }\r\n        }\r\n    }\r\n    \/\/ Adds files which hasn't been added from the original and do not have replace mode on\r\n    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {\r\n        Change change = (Change) it.next();\r\n        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {\r\n            copyStream(change.getInput(), out, change.getEntry());\r\n            it.remove();\r\n            results.addedFromChangeSet(change.getEntry().getName());\r\n        }\r\n    }\r\n    return results;\r\n}","code_comment":"\/**\r\n * Performs all changes collected in this ChangeSet on the input stream and\r\n * streams the result to the output stream. Perform may be called more than once.\r\n *\r\n * This method finishes the stream, no other entries should be added\r\n * after that.\r\n *\r\n * @param in\r\n *            the InputStream to perform the changes on\r\n * @param out\r\n *            the resulting OutputStream with all modifications\r\n * @throws IOException\r\n *             if an read\/write error occurs\r\n * @return the results of this operation\r\n *\/\r\n","code_no_comment":"public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException {\r\n    ChangeSetResults results = new ChangeSetResults();\r\n    Set workingSet = new LinkedHashSet(changes);\r\n    for (Iterator it = workingSet.iterator(); it.hasNext(); ) {\r\n        Change change = (Change) it.next();\r\n        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\r\n            copyStream(change.getInput(), out, change.getEntry());\r\n            it.remove();\r\n            results.addedFromChangeSet(change.getEntry().getName());\r\n        }\r\n    }\r\n    ArchiveEntry entry = null;\r\n    while ((entry = in.getNextEntry()) != null) {\r\n        boolean copy = true;\r\n        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {\r\n            Change change = (Change) it.next();\r\n            final int type = change.type();\r\n            final String name = entry.getName();\r\n            if (type == Change.TYPE_DELETE && name != null) {\r\n                if (name.equals(change.targetFile())) {\r\n                    copy = false;\r\n                    it.remove();\r\n                    results.deleted(name);\r\n                    break;\r\n                }\r\n            } else if (type == Change.TYPE_DELETE_DIR && name != null) {\r\n                if (name.startsWith(change.targetFile() + \"\/\")) {\r\n                    copy = false;\r\n                    results.deleted(name);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (copy) {\r\n            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\r\n                copyStream(in, out, entry);\r\n                results.addedFromStream(entry.getName());\r\n            }\r\n        }\r\n    }\r\n        for (Iterator it = workingSet.iterator(); it.hasNext(); ) {\r\n        Change change = (Change) it.next();\r\n        if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) {\r\n            copyStream(change.getInput(), out, change.getEntry());\r\n            it.remove();\r\n            results.addedFromChangeSet(change.getEntry().getName());\r\n        }\r\n    }\r\n    return results;\r\n}","lc":1.6363636364,"pi":1.2392344498,"ma":2.2,"nbd":1.5,"ml":2.4166666667,"d":1.5575396825,"mi":-0.9300916138,"fo":3.3333333333,"r":-0.0263157895,"e":4.6693452741}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5701_087c0a26","label":1,"code":"@Override\r\npublic void run() {\r\n    if (pageId != NO_PAGE_ID) {\r\n        page.send(application, Broadcast.BREADTH, payload);\r\n    } else {\r\n        ResourceReference reference = new SharedResourceReference(resourceName);\r\n        IResource resource = reference.getResource();\r\n        if (resource instanceof WebSocketResource) {\r\n            WebSocketResource wsResource = (WebSocketResource) resource;\r\n            wsResource.onPayload(payload);\r\n        } else {\r\n            throw new IllegalStateException(String.format(\"Shared resource with name '%s' is not a %s but %s\", resourceName, WebSocketResource.class.getSimpleName(), Classes.name(resource.getClass())));\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void run() {\r\n    if (pageId != NO_PAGE_ID) {\r\n        page.send(application, Broadcast.BREADTH, payload);\r\n    } else {\r\n        ResourceReference reference = new SharedResourceReference(resourceName);\r\n        IResource resource = reference.getResource();\r\n        if (resource instanceof WebSocketResource) {\r\n            WebSocketResource wsResource = (WebSocketResource) resource;\r\n            wsResource.onPayload(payload);\r\n        } else {\r\n            throw new IllegalStateException(String.format(\"Shared resource with name '%s' is not a %s but %s\", resourceName, WebSocketResource.class.getSimpleName(), Classes.name(resource.getClass())));\r\n        }\r\n    }\r\n}","lc":0.0454545455,"pi":0.5215311005,"ma":0.0,"nbd":0.0,"ml":-0.0833333333,"d":-0.0992063492,"mi":-0.0708949965,"fo":0.0833333333,"r":-0.0263157895,"e":-0.0307117788}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-393_d4b02f6a","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic double getResult() {\r\n    return optimizer.getResult();\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public double getResult() {\r\n    return optimizer.getResult();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1987315011,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6964_6b2ffb30","label":1,"code":"\/**\r\n * Strategy when the file was not processed and a rollback should be executed.\r\n *\r\n * @param processStrategy the strategy to perform the commit\r\n * @param exchange        the exchange\r\n * @param file            the file processed\r\n *\/\r\nprotected void processStrategyRollback(GenericFileProcessStrategy<T> processStrategy, Exchange exchange, GenericFile<T> file) {\r\n    if (log.isWarnEnabled()) {\r\n        log.warn(\"Rollback file strategy: \" + processStrategy + \" for file: \" + file);\r\n    }\r\n    try {\r\n        processStrategy.rollback(operations, endpoint, exchange, file);\r\n    } catch (Exception e) {\r\n        handleException(\"Error during rollback\", exchange, e);\r\n    }\r\n}","code_comment":"\/**\r\n * Strategy when the file was not processed and a rollback should be executed.\r\n *\r\n * @param processStrategy the strategy to perform the commit\r\n * @param exchange        the exchange\r\n * @param file            the file processed\r\n *\/\r\n","code_no_comment":"protected void processStrategyRollback(GenericFileProcessStrategy<T> processStrategy, Exchange exchange, GenericFile<T> file) {\r\n    if (log.isWarnEnabled()) {\r\n        log.warn(\"Rollback file strategy: \" + processStrategy + \" for file: \" + file);\r\n    }\r\n    try {\r\n        processStrategy.rollback(operations, endpoint, exchange, file);\r\n    } catch (Exception e) {\r\n        handleException(\"Error during rollback\", exchange, e);\r\n    }\r\n}","lc":-0.1818181818,"pi":-0.0909090909,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.1842142354,"fo":-0.1666666667,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3789_9319e139","label":1,"code":"public boolean buildDirectory(String directory, boolean absolute) throws GenericFileOperationFailedException {\r\n    ObjectHelper.notNull(endpoint, \"endpoint\");\r\n    \/\/ always create endpoint defined directory\r\n    if (endpoint.isAutoCreate() && !endpoint.getFile().exists()) {\r\n        LOG.trace(\"Building starting directory: {}\", endpoint.getFile());\r\n        endpoint.getFile().mkdirs();\r\n    }\r\n    if (ObjectHelper.isEmpty(directory)) {\r\n        \/\/ no directory to build so return true to indicate ok\r\n        return true;\r\n    }\r\n    File endpointPath = endpoint.getFile();\r\n    File target = new File(directory);\r\n    File path;\r\n    if (absolute) {\r\n        \/\/ absolute path\r\n        path = target;\r\n    } else if (endpointPath.equals(target)) {\r\n        \/\/ its just the root of the endpoint path\r\n        path = endpointPath;\r\n    } else {\r\n        \/\/ relative after the endpoint path\r\n        String afterRoot = ObjectHelper.after(directory, endpointPath.getPath() + File.separator);\r\n        if (ObjectHelper.isNotEmpty(afterRoot)) {\r\n            \/\/ dir is under the root path\r\n            path = new File(endpoint.getFile(), afterRoot);\r\n        } else {\r\n            \/\/ dir is relative to the root path\r\n            path = new File(endpoint.getFile(), directory);\r\n        }\r\n    }\r\n    if (path.isDirectory() && path.exists()) {\r\n        \/\/ the directory already exists\r\n        return true;\r\n    } else {\r\n        LOG.trace(\"Building directory: {}\", path);\r\n        return path.mkdirs();\r\n    }\r\n}","code_comment":null,"code_no_comment":"public boolean buildDirectory(String directory, boolean absolute) throws GenericFileOperationFailedException {\r\n    ObjectHelper.notNull(endpoint, \"endpoint\");\r\n        if (endpoint.isAutoCreate() && !endpoint.getFile().exists()) {\r\n        LOG.trace(\"Building starting directory: {}\", endpoint.getFile());\r\n        endpoint.getFile().mkdirs();\r\n    }\r\n    if (ObjectHelper.isEmpty(directory)) {\r\n                return true;\r\n    }\r\n    File endpointPath = endpoint.getFile();\r\n    File target = new File(directory);\r\n    File path;\r\n    if (absolute) {\r\n                path = target;\r\n    } else if (endpointPath.equals(target)) {\r\n                path = endpointPath;\r\n    } else {\r\n                String afterRoot = ObjectHelper.after(directory, endpointPath.getPath() + File.separator);\r\n        if (ObjectHelper.isNotEmpty(afterRoot)) {\r\n                        path = new File(endpoint.getFile(), afterRoot);\r\n        } else {\r\n                        path = new File(endpoint.getFile(), directory);\r\n        }\r\n    }\r\n    if (path.isDirectory() && path.exists()) {\r\n                return true;\r\n    } else {\r\n        LOG.trace(\"Building directory: {}\", path);\r\n        return path.mkdirs();\r\n    }\r\n}","lc":0.7727272727,"pi":-0.0717703349,"ma":0.6,"nbd":0.5,"ml":1.1666666667,"d":0.6666666667,"mi":-0.532346723,"fo":1.1666666667,"r":-0.0263157895,"e":0.9227018897}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5809_b1f4e6a3","label":3,"code":"\/**\r\n *  Parses the given URL string.\r\n *\r\n *  @param _url\r\n *             absolute or relative url with query string\r\n *  @param charset\r\n *  @param isFullHint\r\n *             a hint whether to try to parse the protocol, host and port part of the url\r\n *  @return Url object\r\n *\/\r\npublic static Url parse(CharSequence _url, Charset charset, boolean isFullHint) {\r\n    Args.notNull(_url, \"_url\");\r\n    final Url result = new Url(charset);\r\n    \/\/ the url object resolved the charset, use that\r\n    charset = result.getCharset();\r\n    String url = _url.toString();\r\n    \/\/ extract query string part\r\n    final String queryString;\r\n    final String absoluteUrl;\r\n    final int fragmentAt = url.indexOf('#');\r\n    \/\/ matches url fragment, but doesn't match optional path parameter (e.g. ...\/#{optional}\/...)\r\n    if (fragmentAt > -1 && url.length() > fragmentAt + 1 && url.charAt(fragmentAt + 1) != '{') {\r\n        result.fragment = url.substring(fragmentAt + 1);\r\n        url = url.substring(0, fragmentAt);\r\n    }\r\n    final int queryAt = url.indexOf('?');\r\n    if (queryAt == -1) {\r\n        queryString = \"\";\r\n        absoluteUrl = url;\r\n    } else {\r\n        absoluteUrl = url.substring(0, queryAt);\r\n        queryString = url.substring(queryAt + 1);\r\n    }\r\n    \/\/ get absolute \/ relative part of url\r\n    String relativeUrl;\r\n    final int idxOfFirstSlash = absoluteUrl.indexOf('\/');\r\n    final int protocolAt = absoluteUrl.indexOf(\":\/\/\");\r\n    \/\/ full urls start either with a \"scheme:\/\/\" or with \"\/\/\"\r\n    boolean protocolLess = absoluteUrl.startsWith(\"\/\/\");\r\n    final boolean isFull = (protocolAt > 1 && (protocolAt < idxOfFirstSlash)) || protocolLess;\r\n    if (isFull && isFullHint) {\r\n        if (protocolLess == false) {\r\n            result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\r\n        }\r\n        final String afterProto = absoluteUrl.substring(protocolAt + 3);\r\n        final String hostAndPort;\r\n        int relativeAt = afterProto.indexOf('\/');\r\n        if (relativeAt == -1) {\r\n            relativeAt = afterProto.indexOf(';');\r\n        }\r\n        if (relativeAt == -1) {\r\n            relativeUrl = \"\";\r\n            hostAndPort = afterProto;\r\n        } else {\r\n            relativeUrl = afterProto.substring(relativeAt);\r\n            hostAndPort = afterProto.substring(0, relativeAt);\r\n        }\r\n        final int credentialsAt = hostAndPort.lastIndexOf('@') + 1;\r\n        final int portAt = hostAndPort.substring(credentialsAt).lastIndexOf(':');\r\n        if (portAt == -1) {\r\n            result.host = hostAndPort;\r\n            result.port = getDefaultPortForProtocol(result.protocol);\r\n        } else {\r\n            result.host = hostAndPort.substring(0, portAt + credentialsAt);\r\n            result.port = Integer.parseInt(hostAndPort.substring(portAt + credentialsAt + 1));\r\n        }\r\n        if (relativeAt < 0) {\r\n            relativeUrl = \"\/\";\r\n        }\r\n    } else {\r\n        relativeUrl = absoluteUrl;\r\n    }\r\n    if (relativeUrl.length() > 0) {\r\n        boolean removeLast = false;\r\n        if (relativeUrl.endsWith(\"\/\")) {\r\n            \/\/ we need to append something and remove it after splitting\r\n            \/\/ because otherwise the\r\n            \/\/ trailing slashes will be lost\r\n            relativeUrl += \"\/x\";\r\n            removeLast = true;\r\n        }\r\n        String[] segmentArray = Strings.split(relativeUrl, '\/');\r\n        if (removeLast) {\r\n            segmentArray[segmentArray.length - 1] = null;\r\n        }\r\n        for (String s : segmentArray) {\r\n            if (s != null) {\r\n                result.segments.add(decodeSegment(s, charset));\r\n            }\r\n        }\r\n    }\r\n    if (queryString.length() > 0) {\r\n        String[] queryArray = Strings.split(queryString, '&');\r\n        for (String s : queryArray) {\r\n            if (Strings.isEmpty(s) == false) {\r\n                result.parameters.add(parseQueryParameter(s, charset));\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n *  Parses the given URL string.\r\n *\r\n *  @param _url\r\n *             absolute or relative url with query string\r\n *  @param charset\r\n *  @param isFullHint\r\n *             a hint whether to try to parse the protocol, host and port part of the url\r\n *  @return Url object\r\n *\/\r\n","code_no_comment":"public static Url parse(CharSequence _url, Charset charset, boolean isFullHint) {\r\n    Args.notNull(_url, \"_url\");\r\n    final Url result = new Url(charset);\r\n        charset = result.getCharset();\r\n    String url = _url.toString();\r\n        final String queryString;\r\n    final String absoluteUrl;\r\n    final int fragmentAt = url.indexOf('#');\r\n        if (fragmentAt > -1 && url.length() > fragmentAt + 1 && url.charAt(fragmentAt + 1) != '{') {\r\n        result.fragment = url.substring(fragmentAt + 1);\r\n        url = url.substring(0, fragmentAt);\r\n    }\r\n    final int queryAt = url.indexOf('?');\r\n    if (queryAt == -1) {\r\n        queryString = \"\";\r\n        absoluteUrl = url;\r\n    } else {\r\n        absoluteUrl = url.substring(0, queryAt);\r\n        queryString = url.substring(queryAt + 1);\r\n    }\r\n        String relativeUrl;\r\n    final int idxOfFirstSlash = absoluteUrl.indexOf('\/');\r\n    final int protocolAt = absoluteUrl.indexOf(\":\/\/\");\r\n        boolean protocolLess = absoluteUrl.startsWith(\"\/\/\");\r\n    final boolean isFull = (protocolAt > 1 && (protocolAt < idxOfFirstSlash)) || protocolLess;\r\n    if (isFull && isFullHint) {\r\n        if (protocolLess == false) {\r\n            result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\r\n        }\r\n        final String afterProto = absoluteUrl.substring(protocolAt + 3);\r\n        final String hostAndPort;\r\n        int relativeAt = afterProto.indexOf('\/');\r\n        if (relativeAt == -1) {\r\n            relativeAt = afterProto.indexOf(';');\r\n        }\r\n        if (relativeAt == -1) {\r\n            relativeUrl = \"\";\r\n            hostAndPort = afterProto;\r\n        } else {\r\n            relativeUrl = afterProto.substring(relativeAt);\r\n            hostAndPort = afterProto.substring(0, relativeAt);\r\n        }\r\n        final int credentialsAt = hostAndPort.lastIndexOf('@') + 1;\r\n        final int portAt = hostAndPort.substring(credentialsAt).lastIndexOf(':');\r\n        if (portAt == -1) {\r\n            result.host = hostAndPort;\r\n            result.port = getDefaultPortForProtocol(result.protocol);\r\n        } else {\r\n            result.host = hostAndPort.substring(0, portAt + credentialsAt);\r\n            result.port = Integer.parseInt(hostAndPort.substring(portAt + credentialsAt + 1));\r\n        }\r\n        if (relativeAt < 0) {\r\n            relativeUrl = \"\/\";\r\n        }\r\n    } else {\r\n        relativeUrl = absoluteUrl;\r\n    }\r\n    if (relativeUrl.length() > 0) {\r\n        boolean removeLast = false;\r\n        if (relativeUrl.endsWith(\"\/\")) {\r\n                                                relativeUrl += \"\/x\";\r\n            removeLast = true;\r\n        }\r\n        String[] segmentArray = Strings.split(relativeUrl, '\/');\r\n        if (removeLast) {\r\n            segmentArray[segmentArray.length - 1] = null;\r\n        }\r\n        for (String s : segmentArray) {\r\n            if (s != null) {\r\n                result.segments.add(decodeSegment(s, charset));\r\n            }\r\n        }\r\n    }\r\n    if (queryString.length() > 0) {\r\n        String[] queryArray = Strings.split(queryString, '&');\r\n        for (String s : queryArray) {\r\n            if (Strings.isEmpty(s) == false) {\r\n                result.parameters.add(parseQueryParameter(s, charset));\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}","lc":3.1363636364,"pi":0.1866028708,"ma":2.6,"nbd":0.5,"ml":2.25,"d":2.7678571429,"mi":-1.2646934461,"fo":2.6666666667,"r":-0.0263157895,"e":14.3857517447}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-724_9c8bb934","label":1,"code":"\/**\r\n * Generate a random long value uniformly distributed between\r\n * <code>lower<\/code> and <code>upper<\/code>, inclusive. This algorithm uses\r\n * a secure random number generator.\r\n *\r\n * @param lower\r\n *            the lower bound.\r\n * @param upper\r\n *            the upper bound.\r\n * @return the random integer.\r\n * @throws NumberIsTooLargeException if {@code lower >= upper}.\r\n *\/\r\npublic long nextSecureLong(long lower, long upper) {\r\n    if (lower >= upper) {\r\n        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false);\r\n    }\r\n    SecureRandom sec = getSecRan();\r\n    return lower + (long) (sec.nextDouble() * (upper - lower + 1));\r\n}","code_comment":"\/**\r\n * Generate a random long value uniformly distributed between\r\n * <code>lower<\/code> and <code>upper<\/code>, inclusive. This algorithm uses\r\n * a secure random number generator.\r\n *\r\n * @param lower\r\n *            the lower bound.\r\n * @param upper\r\n *            the upper bound.\r\n * @return the random integer.\r\n * @throws NumberIsTooLargeException if {@code lower >= upper}.\r\n *\/\r\n","code_no_comment":"public long nextSecureLong(long lower, long upper) {\r\n    if (lower >= upper) {\r\n        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false);\r\n    }\r\n    SecureRandom sec = getSecRan();\r\n    return lower + (long) (sec.nextDouble() * (upper - lower + 1));\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":0.2757936508,"mi":0.3770260747,"fo":-0.3333333333,"r":0.2631578947,"e":0.0049077068}
{"project_name":"Closure","project_version":"156","label":2,"code":"\/**\r\n * Updates the first initialization (a.k.a \"declaration\") of a global name.\r\n * This involves flattening the global name (if it's not just a global\r\n * variable name already), collapsing object literal keys into global\r\n * variables, declaring stub global variables for properties added later\r\n * in a local scope.\r\n *\r\n * It may seem odd that this function also takes care of declaring stubs\r\n * for direct children. The ultimate goal of this function is to eliminate\r\n * the global name entirely (when possible), so that \"middlemen\" namespaces\r\n * disappear, and to do that we need to make sure that all the direct children\r\n * will be collapsed as well.\r\n *\r\n * @param n An object representing a global name (e.g. \"a\", \"a.b.c\")\r\n * @param alias The flattened name for {@code n} (e.g. \"a\", \"a$b$c\")\r\n * @param canCollapseChildNames Whether it's possible to collapse children of\r\n *     this name. (This is mostly passed for convenience; it's equivalent to\r\n *     n.canCollapseChildNames()).\r\n *\/\r\nprivate void updateObjLitOrFunctionDeclaration(Name n, String alias) {\r\n    if (n.declaration == null) {\r\n        \/\/ are only defined in local scopes.\r\n        return;\r\n    }\r\n    if (n.declaration.getTwin() != null) {\r\n        \/\/ are handled.\r\n        return;\r\n    }\r\n    switch(n.declaration.node.getParent().getType()) {\r\n        case Token.ASSIGN:\r\n            updateObjLitOrFunctionDeclarationAtAssignNode(n, alias);\r\n            break;\r\n        case Token.VAR:\r\n            updateObjLitOrFunctionDeclarationAtVarNode(n);\r\n            break;\r\n        case Token.FUNCTION:\r\n            updateFunctionDeclarationAtFunctionNode(n);\r\n            break;\r\n    }\r\n}","code_comment":"\/**\r\n * Updates the first initialization (a.k.a \"declaration\") of a global name.\r\n * This involves flattening the global name (if it's not just a global\r\n * variable name already), collapsing object literal keys into global\r\n * variables, declaring stub global variables for properties added later\r\n * in a local scope.\r\n *\r\n * It may seem odd that this function also takes care of declaring stubs\r\n * for direct children. The ultimate goal of this function is to eliminate\r\n * the global name entirely (when possible), so that \"middlemen\" namespaces\r\n * disappear, and to do that we need to make sure that all the direct children\r\n * will be collapsed as well.\r\n *\r\n * @param n An object representing a global name (e.g. \"a\", \"a.b.c\")\r\n * @param alias The flattened name for {@code n} (e.g. \"a\", \"a$b$c\")\r\n * @param canCollapseChildNames Whether it's possible to collapse children of\r\n *     this name. (This is mostly passed for convenience; it's equivalent to\r\n *     n.canCollapseChildNames()).\r\n *\/\r\n","code_no_comment":"private void updateObjLitOrFunctionDeclaration(Name n, String alias) {\r\n    if (n.declaration == null) {\r\n                return;\r\n    }\r\n    if (n.declaration.getTwin() != null) {\r\n                return;\r\n    }\r\n    switch(n.declaration.node.getParent().getType()) {\r\n        case Token.ASSIGN:\r\n            updateObjLitOrFunctionDeclarationAtAssignNode(n, alias);\r\n            break;\r\n        case Token.VAR:\r\n            updateObjLitOrFunctionDeclarationAtVarNode(n);\r\n            break;\r\n        case Token.FUNCTION:\r\n            updateFunctionDeclarationAtFunctionNode(n);\r\n            break;\r\n    }\r\n}","lc":0.2272727273,"pi":0.4928229665,"ma":1.0,"nbd":0.0,"ml":0.25,"d":-0.0416666667,"mi":-0.1548978154,"fo":0.0,"r":-0.0263157895,"e":-0.053763478}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-579_7d72e6ed","label":3,"code":"public abstract boolean evaluate();","code_comment":null,"code_no_comment":"public abstract boolean evaluate();","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.8696264975,"fo":-0.5,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5003_a7d9b689","label":1,"code":"public synchronized void setupPluginRealm(PluginDescriptor pluginDescriptor, MavenSession session, ClassLoader parent, List<String> imports, DependencyFilter filter) throws PluginResolutionException, PluginContainerException {\r\n    Plugin plugin = pluginDescriptor.getPlugin();\r\n    MavenProject project = session.getCurrentProject();\r\n    Map<String, ClassLoader> foreignImports = calcImports(project, parent, imports);\r\n    PluginRealmCache.Key cacheKey = pluginRealmCache.createKey(plugin, parent, foreignImports, filter, project.getRemotePluginRepositories(), session.getRepositorySession());\r\n    PluginRealmCache.CacheRecord cacheRecord = pluginRealmCache.get(cacheKey);\r\n    if (cacheRecord != null) {\r\n        pluginDescriptor.setClassRealm(cacheRecord.realm);\r\n        pluginDescriptor.setArtifacts(new ArrayList<Artifact>(cacheRecord.artifacts));\r\n    } else {\r\n        createPluginRealm(pluginDescriptor, session, parent, foreignImports, filter);\r\n        cacheRecord = pluginRealmCache.put(cacheKey, pluginDescriptor.getClassRealm(), pluginDescriptor.getArtifacts());\r\n    }\r\n    pluginRealmCache.register(project, cacheRecord);\r\n}","code_comment":null,"code_no_comment":"public synchronized void setupPluginRealm(PluginDescriptor pluginDescriptor, MavenSession session, ClassLoader parent, List<String> imports, DependencyFilter filter) throws PluginResolutionException, PluginContainerException {\r\n    Plugin plugin = pluginDescriptor.getPlugin();\r\n    MavenProject project = session.getCurrentProject();\r\n    Map<String, ClassLoader> foreignImports = calcImports(project, parent, imports);\r\n    PluginRealmCache.Key cacheKey = pluginRealmCache.createKey(plugin, parent, foreignImports, filter, project.getRemotePluginRepositories(), session.getRepositorySession());\r\n    PluginRealmCache.CacheRecord cacheRecord = pluginRealmCache.get(cacheKey);\r\n    if (cacheRecord != null) {\r\n        pluginDescriptor.setClassRealm(cacheRecord.realm);\r\n        pluginDescriptor.setArtifacts(new ArrayList<Artifact>(cacheRecord.artifacts));\r\n    } else {\r\n        createPluginRealm(pluginDescriptor, session, parent, foreignImports, filter);\r\n        cacheRecord = pluginRealmCache.put(cacheKey, pluginDescriptor.getClassRealm(), pluginDescriptor.getArtifacts());\r\n    }\r\n    pluginRealmCache.register(project, cacheRecord);\r\n}","lc":0.0454545455,"pi":-0.2488038278,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0198412698,"mi":-0.178858351,"fo":0.6666666667,"r":-0.0263157895,"e":0.2267941426}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5147_184e51e9","label":1,"code":"private IRequestHandler internalMap(Exception e) {\r\n    final Application application = Application.get();\r\n    \/\/ check if we are processing an Ajax request and if we want to invoke the failure handler\r\n    if (isProcessingAjaxRequest()) {\r\n        switch(application.getExceptionSettings().getAjaxErrorHandlingStrategy()) {\r\n            case INVOKE_FAILURE_HANDLER:\r\n                return new ErrorCodeRequestHandler(500);\r\n        }\r\n    }\r\n    if (e instanceof StalePageException) {\r\n        \/\/ (the url should always be updated by an redirect in that case)\r\n        return new RenderPageRequestHandler(new PageProvider(((StalePageException) e).getPage()));\r\n    } else if (e instanceof PageExpiredException) {\r\n        return createPageRequestHandler(new PageProvider(Application.get().getApplicationSettings().getPageExpiredErrorPage()));\r\n    } else if (e instanceof AuthorizationException || e instanceof ListenerInvocationNotAllowedException) {\r\n        return createPageRequestHandler(new PageProvider(Application.get().getApplicationSettings().getAccessDeniedPage()));\r\n    } else if (e instanceof ResponseIOException) {\r\n        logger.error(\"Connection lost, give up responding.\", e);\r\n        return new EmptyRequestHandler();\r\n    } else {\r\n        final UnexpectedExceptionDisplay unexpectedExceptionDisplay = application.getExceptionSettings().getUnexpectedExceptionDisplay();\r\n        logger.error(\"Unexpected error occurred\", e);\r\n        if (IExceptionSettings.SHOW_EXCEPTION_PAGE.equals(unexpectedExceptionDisplay)) {\r\n            Page currentPage = extractCurrentPage();\r\n            return createPageRequestHandler(new PageProvider(new ExceptionErrorPage(e, currentPage)));\r\n        } else if (IExceptionSettings.SHOW_INTERNAL_ERROR_PAGE.equals(unexpectedExceptionDisplay)) {\r\n            return createPageRequestHandler(new PageProvider(application.getApplicationSettings().getInternalErrorPage()));\r\n        } else {\r\n            \/\/ IExceptionSettings.SHOW_NO_EXCEPTION_PAGE\r\n            return new ErrorCodeRequestHandler(500);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private IRequestHandler internalMap(Exception e) {\r\n    final Application application = Application.get();\r\n        if (isProcessingAjaxRequest()) {\r\n        switch(application.getExceptionSettings().getAjaxErrorHandlingStrategy()) {\r\n            case INVOKE_FAILURE_HANDLER:\r\n                return new ErrorCodeRequestHandler(500);\r\n        }\r\n    }\r\n    if (e instanceof StalePageException) {\r\n                return new RenderPageRequestHandler(new PageProvider(((StalePageException) e).getPage()));\r\n    } else if (e instanceof PageExpiredException) {\r\n        return createPageRequestHandler(new PageProvider(Application.get().getApplicationSettings().getPageExpiredErrorPage()));\r\n    } else if (e instanceof AuthorizationException || e instanceof ListenerInvocationNotAllowedException) {\r\n        return createPageRequestHandler(new PageProvider(Application.get().getApplicationSettings().getAccessDeniedPage()));\r\n    } else if (e instanceof ResponseIOException) {\r\n        logger.error(\"Connection lost, give up responding.\", e);\r\n        return new EmptyRequestHandler();\r\n    } else {\r\n        final UnexpectedExceptionDisplay unexpectedExceptionDisplay = application.getExceptionSettings().getUnexpectedExceptionDisplay();\r\n        logger.error(\"Unexpected error occurred\", e);\r\n        if (IExceptionSettings.SHOW_EXCEPTION_PAGE.equals(unexpectedExceptionDisplay)) {\r\n            Page currentPage = extractCurrentPage();\r\n            return createPageRequestHandler(new PageProvider(new ExceptionErrorPage(e, currentPage)));\r\n        } else if (IExceptionSettings.SHOW_INTERNAL_ERROR_PAGE.equals(unexpectedExceptionDisplay)) {\r\n            return createPageRequestHandler(new PageProvider(application.getApplicationSettings().getInternalErrorPage()));\r\n        } else {\r\n                        return new ErrorCodeRequestHandler(500);\r\n        }\r\n    }\r\n}","lc":0.7272727273,"pi":0.3110047847,"ma":1.0,"nbd":2.0,"ml":0.8333333333,"d":0.003968254,"mi":-0.533192389,"fo":1.5,"r":-0.0263157895,"e":0.2328936222}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-2712_06090da4","label":1,"code":"public void resolve(RepositoryMetadata metadata, List remoteRepositories, ArtifactRepository localRepository) throws RepositoryMetadataResolutionException {\r\n    boolean alreadyResolved = alreadyResolved(metadata);\r\n    if (!alreadyResolved) {\r\n        for (Iterator i = remoteRepositories.iterator(); i.hasNext(); ) {\r\n            ArtifactRepository repository = (ArtifactRepository) i.next();\r\n            ArtifactRepositoryPolicy policy = metadata.isSnapshot() ? repository.getSnapshots() : repository.getReleases();\r\n            if (!policy.isEnabled()) {\r\n                getLogger().debug(\"Skipping disabled repository \" + repository.getId());\r\n            } else if (repository.isBlacklisted()) {\r\n                getLogger().debug(\"Skipping blacklisted repository \" + repository.getId());\r\n            } else {\r\n                File file = new File(localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata(metadata, repository));\r\n                boolean checkForUpdates = policy.checkOutOfDate(new Date(file.lastModified())) || !file.exists();\r\n                boolean metadataIsEmpty = true;\r\n                if (checkForUpdates) {\r\n                    getLogger().info(metadata.getKey() + \": checking for updates from \" + repository.getId());\r\n                    try {\r\n                        resolveAlways(metadata, repository, file, policy.getChecksumPolicy(), true);\r\n                        metadataIsEmpty = false;\r\n                    } catch (TransferFailedException e) {\r\n                        \/\/ TODO: [jc; 08-Nov-2005] revisit this for 2.1\r\n                        \/\/ suppressing logging to avoid logging this error twice.\r\n                        metadataIsEmpty = true;\r\n                    }\r\n                }\r\n                \/\/ touch file so that this is not checked again until interval has passed\r\n                if (file.exists()) {\r\n                    file.setLastModified(System.currentTimeMillis());\r\n                } else if (!metadataIsEmpty) {\r\n                    \/\/ this ensures that files are not continuously checked when they don't exist remotely\r\n                    try {\r\n                        metadata.storeInLocalRepository(localRepository, repository);\r\n                    } catch (RepositoryMetadataStoreException e) {\r\n                        throw new RepositoryMetadataResolutionException(\"Unable to store local copy of metadata: \" + e.getMessage(), e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        cachedMetadata.add(metadata.getKey());\r\n    }\r\n    try {\r\n        mergeMetadata(metadata, remoteRepositories, localRepository);\r\n    } catch (RepositoryMetadataStoreException e) {\r\n        throw new RepositoryMetadataResolutionException(\"Unable to store local copy of metadata: \" + e.getMessage(), e);\r\n    } catch (RepositoryMetadataReadException e) {\r\n        throw new RepositoryMetadataResolutionException(\"Unable to read local copy of metadata: \" + e.getMessage(), e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void resolve(RepositoryMetadata metadata, List remoteRepositories, ArtifactRepository localRepository) throws RepositoryMetadataResolutionException {\r\n    boolean alreadyResolved = alreadyResolved(metadata);\r\n    if (!alreadyResolved) {\r\n        for (Iterator i = remoteRepositories.iterator(); i.hasNext(); ) {\r\n            ArtifactRepository repository = (ArtifactRepository) i.next();\r\n            ArtifactRepositoryPolicy policy = metadata.isSnapshot() ? repository.getSnapshots() : repository.getReleases();\r\n            if (!policy.isEnabled()) {\r\n                getLogger().debug(\"Skipping disabled repository \" + repository.getId());\r\n            } else if (repository.isBlacklisted()) {\r\n                getLogger().debug(\"Skipping blacklisted repository \" + repository.getId());\r\n            } else {\r\n                File file = new File(localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata(metadata, repository));\r\n                boolean checkForUpdates = policy.checkOutOfDate(new Date(file.lastModified())) || !file.exists();\r\n                boolean metadataIsEmpty = true;\r\n                if (checkForUpdates) {\r\n                    getLogger().info(metadata.getKey() + \": checking for updates from \" + repository.getId());\r\n                    try {\r\n                        resolveAlways(metadata, repository, file, policy.getChecksumPolicy(), true);\r\n                        metadataIsEmpty = false;\r\n                    } catch (TransferFailedException e) {\r\n                                                                        metadataIsEmpty = true;\r\n                    }\r\n                }\r\n                                if (file.exists()) {\r\n                    file.setLastModified(System.currentTimeMillis());\r\n                } else if (!metadataIsEmpty) {\r\n                                        try {\r\n                        metadata.storeInLocalRepository(localRepository, repository);\r\n                    } catch (RepositoryMetadataStoreException e) {\r\n                        throw new RepositoryMetadataResolutionException(\"Unable to store local copy of metadata: \" + e.getMessage(), e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        cachedMetadata.add(metadata.getKey());\r\n    }\r\n    try {\r\n        mergeMetadata(metadata, remoteRepositories, localRepository);\r\n    } catch (RepositoryMetadataStoreException e) {\r\n        throw new RepositoryMetadataResolutionException(\"Unable to store local copy of metadata: \" + e.getMessage(), e);\r\n    } catch (RepositoryMetadataReadException e) {\r\n        throw new RepositoryMetadataResolutionException(\"Unable to read local copy of metadata: \" + e.getMessage(), e);\r\n    }\r\n}","lc":1.3636363636,"pi":1.9090909091,"ma":2.4,"nbd":2.5,"ml":0.9166666667,"d":0.4821428571,"mi":-0.8469344609,"fo":2.5,"r":-0.0263157895,"e":1.5556600566}
{"project_name":"Math","project_version":"70","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    return solve(min, max);\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    return solve(min, max);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9360112755,"fo":-0.4166666667,"r":1.9736842105,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5251_6ce34ccf","label":1,"code":"\/**\r\n *  @return How the minified file should be named.\r\n *\/\r\nprotected String getMinifiedName() {\r\n    String name = super.getName();\r\n    String minifiedName;\r\n    int idxOfExtension = name.lastIndexOf('.');\r\n    if (idxOfExtension > -1) {\r\n        String extension = name.substring(idxOfExtension);\r\n        minifiedName = name.substring(0, name.length() - extension.length() + 1) + \"min\" + extension;\r\n    } else {\r\n        minifiedName = name + \".min\";\r\n    }\r\n    return minifiedName;\r\n}","code_comment":"\/**\r\n *  @return How the minified file should be named.\r\n *\/\r\n","code_no_comment":"protected String getMinifiedName() {\r\n    String name = super.getName();\r\n    String minifiedName;\r\n    int idxOfExtension = name.lastIndexOf('.');\r\n    if (idxOfExtension > -1) {\r\n        String extension = name.substring(idxOfExtension);\r\n        minifiedName = name.substring(0, name.length() - extension.length() + 1) + \"min\" + extension;\r\n    } else {\r\n        minifiedName = name + \".min\";\r\n    }\r\n    return minifiedName;\r\n}","lc":-0.0909090909,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.4781746032,"mi":0.0573643411,"fo":0.0,"r":0.2368421053,"e":0.2182834552}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1531_21f47d9c","label":3,"code":"@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic T deserialize(DataInputView source) throws IOException {\r\n    checkKryoInitialized();\r\n    if (source != previousIn) {\r\n        DataInputViewStream inputStream = new DataInputViewStream(source);\r\n        input = new NoFetchingInput(inputStream);\r\n        previousIn = source;\r\n    }\r\n    return (T) kryo.readClassAndObject(input);\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic T deserialize(DataInputView source) throws IOException {\r\n    checkKryoInitialized();\r\n    if (source != previousIn) {\r\n        DataInputViewStream inputStream = new DataInputViewStream(source);\r\n        input = new NoFetchingInput(inputStream);\r\n        previousIn = source;\r\n    }\r\n    return (T) kryo.readClassAndObject(input);\r\n}","lc":-0.1363636364,"pi":0.0861244019,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0734126984,"mi":0.1639182523,"fo":-0.3333333333,"r":1.3157894737,"e":-0.0792724884}
{"project_name":"Closure","project_version":"36","label":2,"code":"\/**\r\n * @return true if the provided reference and declaration can be safely\r\n *         inlined according to our criteria\r\n *\/\r\nprivate boolean canInline(Reference declaration, Reference initialization, Reference reference) {\r\n    if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) {\r\n        return false;\r\n    }\r\n    \/\/ ASSIGN expressions parents do.\r\n    if (declaration != initialization && !initialization.getGrandparent().isExprResult()) {\r\n        return false;\r\n    }\r\n    \/\/ scope boundaries\r\n    if (declaration.getBasicBlock() != initialization.getBasicBlock() || declaration.getBasicBlock() != reference.getBasicBlock()) {\r\n        return false;\r\n    }\r\n    \/\/ Do not inline into a call node. This would change\r\n    \/\/ the context in which it was being called. For example,\r\n    \/\/ var a = b.c;\r\n    \/\/ a();\r\n    \/\/ should not be inlined, because it calls a in the context of b\r\n    \/\/ rather than the context of the window.\r\n    \/\/ var a = b.c;\r\n    \/\/ f(a)\r\n    \/\/ is ok.\r\n    Node value = initialization.getAssignedValue();\r\n    Preconditions.checkState(value != null);\r\n    if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) {\r\n        return false;\r\n    }\r\n    if (value.isFunction()) {\r\n        Node callNode = reference.getParent();\r\n        if (reference.getParent().isCall()) {\r\n            CodingConvention convention = compiler.getCodingConvention();\r\n            \/\/ Bug 2388531: Don't inline subclass definitions into class defining\r\n            \/\/ calls as this confused class removing logic.\r\n            SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode);\r\n            if (relationship != null) {\r\n                return false;\r\n            }\r\n        \/\/ issue 668: Don't inline singleton getter methods\r\n        \/\/ calls as this confused class removing logic.\r\n        }\r\n    }\r\n    return canMoveAggressively(value) || canMoveModerately(initialization, reference);\r\n}","code_comment":"\/**\r\n * @return true if the provided reference and declaration can be safely\r\n *         inlined according to our criteria\r\n *\/\r\n","code_no_comment":"private boolean canInline(Reference declaration, Reference initialization, Reference reference) {\r\n    if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) {\r\n        return false;\r\n    }\r\n        if (declaration != initialization && !initialization.getGrandparent().isExprResult()) {\r\n        return false;\r\n    }\r\n        if (declaration.getBasicBlock() != initialization.getBasicBlock() || declaration.getBasicBlock() != reference.getBasicBlock()) {\r\n        return false;\r\n    }\r\n                                        Node value = initialization.getAssignedValue();\r\n    Preconditions.checkState(value != null);\r\n    if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) {\r\n        return false;\r\n    }\r\n    if (value.isFunction()) {\r\n        Node callNode = reference.getParent();\r\n        if (reference.getParent().isCall()) {\r\n            CodingConvention convention = compiler.getCodingConvention();\r\n                                    SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode);\r\n            if (relationship != null) {\r\n                return false;\r\n            }\r\n                        }\r\n    }\r\n    return canMoveAggressively(value) || canMoveModerately(initialization, reference);\r\n}","lc":0.5909090909,"pi":0.3923444976,"ma":0.8,"nbd":0.5,"ml":2.0,"d":0.9107142857,"mi":-0.4914728682,"fo":1.5833333333,"r":-0.0263157895,"e":1.3297995078}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-320_c06cc933","label":1,"code":"\/**\r\n * Solve the linear equation A &times; X = B in least square sense.\r\n * <p>The m&times;n matrix A may not be square, the solution X is\r\n * such that ||A &times; X - B|| is minimal.<\/p>\r\n * @param b right-hand side of the equation A &times; X = B\r\n * @return a vector X that minimizes the two norm of A &times; X - B\r\n * @exception IllegalArgumentException if matrices dimensions don't match\r\n * @exception InvalidMatrixException if decomposed matrix is singular\r\n *\/\r\npublic double[] solve(final double[] b) throws IllegalArgumentException, InvalidMatrixException {\r\n    if (b.length != uT.getColumnDimension()) {\r\n        throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch: got {0} but expected {1}\", b.length, uT.getColumnDimension());\r\n    }\r\n    final double[] w = uT.operate(b);\r\n    for (int i = 0; i < singularValues.length; ++i) {\r\n        final double si = singularValues[i];\r\n        if (si == 0) {\r\n            throw new SingularMatrixException();\r\n        }\r\n        w[i] \/= si;\r\n    }\r\n    return v.operate(w);\r\n}","code_comment":"\/**\r\n * Solve the linear equation A &times; X = B in least square sense.\r\n * <p>The m&times;n matrix A may not be square, the solution X is\r\n * such that ||A &times; X - B|| is minimal.<\/p>\r\n * @param b right-hand side of the equation A &times; X = B\r\n * @return a vector X that minimizes the two norm of A &times; X - B\r\n * @exception IllegalArgumentException if matrices dimensions don't match\r\n * @exception InvalidMatrixException if decomposed matrix is singular\r\n *\/\r\n","code_no_comment":"public double[] solve(final double[] b) throws IllegalArgumentException, InvalidMatrixException {\r\n    if (b.length != uT.getColumnDimension()) {\r\n        throw MathRuntimeException.createIllegalArgumentException(\"vector length mismatch: got {0} but expected {1}\", b.length, uT.getColumnDimension());\r\n    }\r\n    final double[] w = uT.operate(b);\r\n    for (int i = 0; i < singularValues.length; ++i) {\r\n        final double si = singularValues[i];\r\n        if (si == 0) {\r\n            throw new SingularMatrixException();\r\n        }\r\n        w[i] \/= si;\r\n    }\r\n    return v.operate(w);\r\n}","lc":0.0,"pi":0.1244019139,"ma":0.4,"nbd":0.0,"ml":0.25,"d":0.8253968254,"mi":-0.0528541226,"fo":-0.0833333333,"r":0.3947368421,"e":0.4281138523}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1877_716e1237","label":0,"code":"@Override\r\npublic void indexUpdate() throws CommitFailedException {\r\n    if (!dirty) {\r\n        dirty = true;\r\n        preAsyncRun(store, name);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void indexUpdate() throws CommitFailedException {\r\n    if (!dirty) {\r\n        dirty = true;\r\n        preAsyncRun(store, name);\r\n    }\r\n}","lc":-0.3181818182,"pi":0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1448412698,"mi":0.5298097252,"fo":-0.4166666667,"r":1.7631578947,"e":-0.1415259072}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2494_0dc92ca1","label":1,"code":"public void addStat(long stat) {\r\n    if (stat > max)\r\n        max = stat;\r\n    if (stat < min)\r\n        min = stat;\r\n    sum += stat;\r\n    partialStdDev += stat * stat;\r\n    count++;\r\n}","code_comment":null,"code_no_comment":"public void addStat(long stat) {\r\n    if (stat > max)\r\n        max = stat;\r\n    if (stat < min)\r\n        min = stat;\r\n    sum += stat;\r\n    partialStdDev += stat * stat;\r\n    count++;\r\n}","lc":-0.2272727273,"pi":-0.1531100478,"ma":-0.2,"nbd":-1.0,"ml":0.0,"d":0.9007936508,"mi":0.2868217054,"fo":-0.5,"r":0.5526315789,"e":0.1169620166}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3222_5729ed90","label":1,"code":"\/**\r\n *  Remove all comment sections (&lt;!-- .. --&gt;) from the raw markup.\r\n *\r\n *  @param rawMarkup\r\n *  @return raw markup\r\n *\/\r\nprivate String removeComment(String rawMarkup) {\r\n    \/\/ For reasons I don't understand, the following regex <code>\"<!--(.|\\n|\\r)*?-->\"<code>\r\n    \/\/ causes a stack overflow in some circumstances (jdk 1.5)\r\n    \/\/ See http:\/\/bugs.sun.com\/bugdatabase\/view_bug.do?bug_id=5050507\r\n    \/\/ See http:\/\/bugs.sun.com\/bugdatabase\/view_bug.do?bug_id=6337993\r\n    int pos1 = rawMarkup.indexOf(\"<!--\");\r\n    while (pos1 != -1) {\r\n        final int pos2 = rawMarkup.indexOf(\"-->\", pos1 + 4);\r\n        final AppendingStringBuffer buf = new AppendingStringBuffer(rawMarkup.length());\r\n        if (pos2 != -1) {\r\n            final String comment = rawMarkup.substring(pos1 + 4, pos2);\r\n            \/\/ See http:\/\/bugs.sun.com\/bugdatabase\/view_bug.do?bug_id=6337993\r\n            if (CONDITIONAL_COMMENT.matcher(comment).matches() == false) {\r\n                buf.append(rawMarkup.substring(0, pos1));\r\n                if (rawMarkup.length() >= pos2 + 3) {\r\n                    buf.append(rawMarkup.substring(pos2 + 3));\r\n                }\r\n                rawMarkup = buf.toString();\r\n            }\r\n        }\r\n        pos1 = rawMarkup.length() <= pos1 + 2 ? -1 : rawMarkup.indexOf(\"<!--\", pos1 + 4);\r\n    }\r\n    return rawMarkup;\r\n}","code_comment":"\/**\r\n *  Remove all comment sections (&lt;!-- .. --&gt;) from the raw markup.\r\n *\r\n *  @param rawMarkup\r\n *  @return raw markup\r\n *\/\r\n","code_no_comment":"private String removeComment(String rawMarkup) {\r\n                    int pos1 = rawMarkup.indexOf(\"<!--\");\r\n    while (pos1 != -1) {\r\n        final int pos2 = rawMarkup.indexOf(\"-->\", pos1 + 4);\r\n        final AppendingStringBuffer buf = new AppendingStringBuffer(rawMarkup.length());\r\n        if (pos2 != -1) {\r\n            final String comment = rawMarkup.substring(pos1 + 4, pos2);\r\n                        if (CONDITIONAL_COMMENT.matcher(comment).matches() == false) {\r\n                buf.append(rawMarkup.substring(0, pos1));\r\n                if (rawMarkup.length() >= pos2 + 3) {\r\n                    buf.append(rawMarkup.substring(pos2 + 3));\r\n                }\r\n                rawMarkup = buf.toString();\r\n            }\r\n        }\r\n        pos1 = rawMarkup.length() <= pos1 + 2 ? -1 : rawMarkup.indexOf(\"<!--\", pos1 + 4);\r\n    }\r\n    return rawMarkup;\r\n}","lc":0.2272727273,"pi":1.2775119617,"ma":0.4,"nbd":1.0,"ml":0.3333333333,"d":1.2301587302,"mi":-0.2964059197,"fo":0.6666666667,"r":-0.0263157895,"e":1.4496268506}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1894_35562cce","label":1,"code":"@Override\r\npublic String getPlan(Filter filter, NodeState root) {\r\n    StringBuilder buff = new StringBuilder(\"property\");\r\n    StringBuilder notIndexed = new StringBuilder();\r\n    PropertyIndexLookup lookup = getLookup(root);\r\n    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\r\n        String propertyName = PathUtils.getName(pr.propertyName);\r\n        \/\/ currently, only indexes on the root node are supported\r\n        if (lookup.isIndexed(propertyName, \"\/\", filter)) {\r\n            if (pr.firstIncluding && pr.lastIncluding && pr.first != null && pr.first.equals(pr.last)) {\r\n                buff.append(' ').append(propertyName).append('=').append(pr.first);\r\n            } else {\r\n                buff.append(' ').append(propertyName);\r\n            }\r\n        } else if (pr.list != null) {\r\n            buff.append(' ').append(propertyName).append(\" IN(\");\r\n            int i = 0;\r\n            for (PropertyValue pv : pr.list) {\r\n                if (i++ > 0) {\r\n                    buff.append(\", \");\r\n                }\r\n                buff.append(pv);\r\n            }\r\n            buff.append(')');\r\n        } else {\r\n            notIndexed.append(' ').append(propertyName);\r\n            if (!pr.toString().isEmpty()) {\r\n                notIndexed.append(':').append(pr);\r\n            }\r\n        }\r\n    }\r\n    if (notIndexed.length() > 0) {\r\n        buff.append(\" (\").append(notIndexed.toString().trim()).append(\")\");\r\n    }\r\n    return buff.toString();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String getPlan(Filter filter, NodeState root) {\r\n    StringBuilder buff = new StringBuilder(\"property\");\r\n    StringBuilder notIndexed = new StringBuilder();\r\n    PropertyIndexLookup lookup = getLookup(root);\r\n    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\r\n        String propertyName = PathUtils.getName(pr.propertyName);\r\n                if (lookup.isIndexed(propertyName, \"\/\", filter)) {\r\n            if (pr.firstIncluding && pr.lastIncluding && pr.first != null && pr.first.equals(pr.last)) {\r\n                buff.append(' ').append(propertyName).append('=').append(pr.first);\r\n            } else {\r\n                buff.append(' ').append(propertyName);\r\n            }\r\n        } else if (pr.list != null) {\r\n            buff.append(' ').append(propertyName).append(\" IN(\");\r\n            int i = 0;\r\n            for (PropertyValue pv : pr.list) {\r\n                if (i++ > 0) {\r\n                    buff.append(\", \");\r\n                }\r\n                buff.append(pv);\r\n            }\r\n            buff.append(')');\r\n        } else {\r\n            notIndexed.append(' ').append(propertyName);\r\n            if (!pr.toString().isEmpty()) {\r\n                notIndexed.append(':').append(pr);\r\n            }\r\n        }\r\n    }\r\n    if (notIndexed.length() > 0) {\r\n        buff.append(\" (\").append(notIndexed.toString().trim()).append(\")\");\r\n    }\r\n    return buff.toString();\r\n}","lc":0.9545454545,"pi":1.0717703349,"ma":1.0,"nbd":1.5,"ml":1.3333333333,"d":1.123015873,"mi":-0.6707540521,"fo":2.0,"r":-0.0263157895,"e":2.3601781896}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1133_27e40205","label":1,"code":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nprivate <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoWithTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\r\n    \/\/ check if type is a subclass of tuple\r\n    if ((t instanceof Class<?> && Tuple.class.isAssignableFrom((Class<?>) t)) || (t instanceof ParameterizedType && Tuple.class.isAssignableFrom((Class<?>) ((ParameterizedType) t).getRawType()))) {\r\n        Type curT = t;\r\n        \/\/ do not allow usage of Tuple as type\r\n        if (curT instanceof Class<?> && ((Class<?>) curT).equals(Tuple.class)) {\r\n            throw new InvalidTypesException(\"Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.\");\r\n        }\r\n        \/\/ collect the types while moving up for a later top-down\r\n        while (!(curT instanceof ParameterizedType && ((Class<?>) ((ParameterizedType) curT).getRawType()).getSuperclass().equals(Tuple.class)) && !(curT instanceof Class<?> && ((Class<?>) curT).getSuperclass().equals(Tuple.class))) {\r\n            typeHierarchy.add(curT);\r\n            \/\/ parameterized type\r\n            if (curT instanceof ParameterizedType) {\r\n                curT = ((Class<?>) ((ParameterizedType) curT).getRawType()).getGenericSuperclass();\r\n            } else \/\/ class\r\n            {\r\n                curT = ((Class<?>) curT).getGenericSuperclass();\r\n            }\r\n        }\r\n        \/\/ check if immediate child of Tuple has generics\r\n        if (curT instanceof Class<?>) {\r\n            throw new InvalidTypesException(\"Tuple needs to be parameterized by using generics.\");\r\n        }\r\n        ParameterizedType tupleChild = (ParameterizedType) curT;\r\n        Type[] subtypes = new Type[tupleChild.getActualTypeArguments().length];\r\n        \/\/ materialize possible type variables\r\n        for (int i = 0; i < subtypes.length; i++) {\r\n            \/\/ materialize immediate TypeVariables\r\n            if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {\r\n                subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) tupleChild.getActualTypeArguments()[i]);\r\n            } else \/\/ class or parameterized type\r\n            {\r\n                subtypes[i] = tupleChild.getActualTypeArguments()[i];\r\n            }\r\n        }\r\n        TypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];\r\n        for (int i = 0; i < subtypes.length; i++) {\r\n            \/\/ try to derive the type info of the TypeVariable from the immediate base child input as a last attempt\r\n            if (subtypes[i] instanceof TypeVariable<?>) {\r\n                tupleSubTypes[i] = createTypeInfoFromInput((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);\r\n                \/\/ variable could not be determined\r\n                if (tupleSubTypes[i] == null) {\r\n                    throw new InvalidTypesException(\"Type of TypeVariable '\" + ((TypeVariable<?>) subtypes[i]).getName() + \"' in '\" + ((TypeVariable<?>) subtypes[i]).getGenericDeclaration() + \"' could not be determined. This is most likely a type erasure problem. \" + \"The type extraction currently supports types with generic variables only in cases where \" + \"all variables in the return type can be deduced from the input type(s).\");\r\n                }\r\n            } else {\r\n                tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);\r\n            }\r\n        }\r\n        if (t instanceof Class<?>) {\r\n            return new TupleTypeInfo(((Class<? extends Tuple>) t), tupleSubTypes);\r\n        } else if (t instanceof ParameterizedType) {\r\n            return new TupleTypeInfo(((Class<? extends Tuple>) ((ParameterizedType) t).getRawType()), tupleSubTypes);\r\n        }\r\n    } else \/\/ e.g. class MyMapper<E> extends MapFunction<String, E>\r\n    if (t instanceof TypeVariable) {\r\n        Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) t);\r\n        if (!(typeVar instanceof TypeVariable)) {\r\n            return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);\r\n        } else \/\/ try to derive the type info of the TypeVariable from the immediate base child input as a last attempt\r\n        {\r\n            TypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInput((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);\r\n            if (typeInfo != null) {\r\n                return typeInfo;\r\n            } else {\r\n                throw new InvalidTypesException(\"Type of TypeVariable '\" + ((TypeVariable<?>) t).getName() + \"' in '\" + ((TypeVariable<?>) t).getGenericDeclaration() + \"' could not be determined. This is most likely a type erasure problem. \" + \"The type extraction currently supports types with generic variables only in cases where \" + \"all variables in the return type can be deduced from the input type(s).\");\r\n            }\r\n        }\r\n    } else \/\/ arrays with generics\r\n    if (t instanceof GenericArrayType) {\r\n        GenericArrayType genericArray = (GenericArrayType) t;\r\n        Type componentType = genericArray.getGenericComponentType();\r\n        \/\/ due to a Java 6 bug, it is possible that the JVM classifies e.g. String[] or int[] as GenericArrayType instead of Class\r\n        if (componentType instanceof Class) {\r\n            Class<?> componentClass = (Class<?>) componentType;\r\n            String className;\r\n            \/\/ for int[], double[] etc.\r\n            if (componentClass.isPrimitive()) {\r\n                className = encodePrimitiveClass(componentClass);\r\n            } else \/\/ for String[], Integer[] etc.\r\n            {\r\n                className = \"L\" + componentClass.getName() + \";\";\r\n            }\r\n            Class<OUT> classArray = null;\r\n            try {\r\n                classArray = (Class<OUT>) Class.forName(\"[\" + className);\r\n            } catch (ClassNotFoundException e) {\r\n                throw new InvalidTypesException(\"Could not convert GenericArrayType to Class.\");\r\n            }\r\n            return getForClass(classArray);\r\n        }\r\n        TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);\r\n        return ObjectArrayTypeInfo.getInfoFor(t, componentInfo);\r\n    } else \/\/ objects with generics are treated as raw type\r\n    if (t instanceof ParameterizedType) {\r\n        return privateGetForClass((Class<OUT>) ((ParameterizedType) t).getRawType());\r\n    } else \/\/ no tuple, no TypeVariable, no generic type\r\n    if (t instanceof Class) {\r\n        return privateGetForClass((Class<OUT>) t);\r\n    }\r\n    throw new InvalidTypesException(\"Type Information could not be created.\");\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nprivate <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoWithTypeHierarchy(ArrayList<Type> typeHierarchy, Type t, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\r\n        if ((t instanceof Class<?> && Tuple.class.isAssignableFrom((Class<?>) t)) || (t instanceof ParameterizedType && Tuple.class.isAssignableFrom((Class<?>) ((ParameterizedType) t).getRawType()))) {\r\n        Type curT = t;\r\n                if (curT instanceof Class<?> && ((Class<?>) curT).equals(Tuple.class)) {\r\n            throw new InvalidTypesException(\"Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.\");\r\n        }\r\n                while (!(curT instanceof ParameterizedType && ((Class<?>) ((ParameterizedType) curT).getRawType()).getSuperclass().equals(Tuple.class)) && !(curT instanceof Class<?> && ((Class<?>) curT).getSuperclass().equals(Tuple.class))) {\r\n            typeHierarchy.add(curT);\r\n                        if (curT instanceof ParameterizedType) {\r\n                curT = ((Class<?>) ((ParameterizedType) curT).getRawType()).getGenericSuperclass();\r\n            } else             {\r\n                curT = ((Class<?>) curT).getGenericSuperclass();\r\n            }\r\n        }\r\n                if (curT instanceof Class<?>) {\r\n            throw new InvalidTypesException(\"Tuple needs to be parameterized by using generics.\");\r\n        }\r\n        ParameterizedType tupleChild = (ParameterizedType) curT;\r\n        Type[] subtypes = new Type[tupleChild.getActualTypeArguments().length];\r\n                for (int i = 0; i < subtypes.length; i++) {\r\n                        if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {\r\n                subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) tupleChild.getActualTypeArguments()[i]);\r\n            } else             {\r\n                subtypes[i] = tupleChild.getActualTypeArguments()[i];\r\n            }\r\n        }\r\n        TypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];\r\n        for (int i = 0; i < subtypes.length; i++) {\r\n                        if (subtypes[i] instanceof TypeVariable<?>) {\r\n                tupleSubTypes[i] = createTypeInfoFromInput((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);\r\n                                if (tupleSubTypes[i] == null) {\r\n                    throw new InvalidTypesException(\"Type of TypeVariable '\" + ((TypeVariable<?>) subtypes[i]).getName() + \"' in '\" + ((TypeVariable<?>) subtypes[i]).getGenericDeclaration() + \"' could not be determined. This is most likely a type erasure problem. \" + \"The type extraction currently supports types with generic variables only in cases where \" + \"all variables in the return type can be deduced from the input type(s).\");\r\n                }\r\n            } else {\r\n                tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);\r\n            }\r\n        }\r\n        if (t instanceof Class<?>) {\r\n            return new TupleTypeInfo(((Class<? extends Tuple>) t), tupleSubTypes);\r\n        } else if (t instanceof ParameterizedType) {\r\n            return new TupleTypeInfo(((Class<? extends Tuple>) ((ParameterizedType) t).getRawType()), tupleSubTypes);\r\n        }\r\n    } else     if (t instanceof TypeVariable) {\r\n        Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) t);\r\n        if (!(typeVar instanceof TypeVariable)) {\r\n            return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);\r\n        } else         {\r\n            TypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInput((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);\r\n            if (typeInfo != null) {\r\n                return typeInfo;\r\n            } else {\r\n                throw new InvalidTypesException(\"Type of TypeVariable '\" + ((TypeVariable<?>) t).getName() + \"' in '\" + ((TypeVariable<?>) t).getGenericDeclaration() + \"' could not be determined. This is most likely a type erasure problem. \" + \"The type extraction currently supports types with generic variables only in cases where \" + \"all variables in the return type can be deduced from the input type(s).\");\r\n            }\r\n        }\r\n    } else     if (t instanceof GenericArrayType) {\r\n        GenericArrayType genericArray = (GenericArrayType) t;\r\n        Type componentType = genericArray.getGenericComponentType();\r\n                if (componentType instanceof Class) {\r\n            Class<?> componentClass = (Class<?>) componentType;\r\n            String className;\r\n                        if (componentClass.isPrimitive()) {\r\n                className = encodePrimitiveClass(componentClass);\r\n            } else             {\r\n                className = \"L\" + componentClass.getName() + \";\";\r\n            }\r\n            Class<OUT> classArray = null;\r\n            try {\r\n                classArray = (Class<OUT>) Class.forName(\"[\" + className);\r\n            } catch (ClassNotFoundException e) {\r\n                throw new InvalidTypesException(\"Could not convert GenericArrayType to Class.\");\r\n            }\r\n            return getForClass(classArray);\r\n        }\r\n        TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);\r\n        return ObjectArrayTypeInfo.getInfoFor(t, componentInfo);\r\n    } else     if (t instanceof ParameterizedType) {\r\n        return privateGetForClass((Class<OUT>) ((ParameterizedType) t).getRawType());\r\n    } else     if (t instanceof Class) {\r\n        return privateGetForClass((Class<OUT>) t);\r\n    }\r\n    throw new InvalidTypesException(\"Type Information could not be created.\");\r\n}","lc":3.5,"pi":0.5406698565,"ma":4.8,"nbd":1.5,"ml":2.9166666667,"d":2.875,"mi":-1.3873150106,"fo":2.8333333333,"r":-0.0263157895,"e":15.8780081027}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3897_94c6c575","label":1,"code":"@Nonnull\r\npublic String reset(@Nonnull String branchRevisionId, @Nonnull String ancestorRevisionId) throws DocumentStoreException {\r\n    RevisionVector branch = RevisionVector.fromString(branchRevisionId);\r\n    if (!branch.isBranch()) {\r\n        throw new DocumentStoreException(\"Not a branch revision: \" + branchRevisionId);\r\n    }\r\n    RevisionVector ancestor = RevisionVector.fromString(ancestorRevisionId);\r\n    if (!ancestor.isBranch()) {\r\n        throw new DocumentStoreException(\"Not a branch revision: \" + ancestorRevisionId);\r\n    }\r\n    try {\r\n        return nodeStore.reset(branch, ancestor, null).toString();\r\n    } catch (DocumentStoreException e) {\r\n        throw new DocumentStoreException(e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\npublic String reset(@Nonnull String branchRevisionId, @Nonnull String ancestorRevisionId) throws DocumentStoreException {\r\n    RevisionVector branch = RevisionVector.fromString(branchRevisionId);\r\n    if (!branch.isBranch()) {\r\n        throw new DocumentStoreException(\"Not a branch revision: \" + branchRevisionId);\r\n    }\r\n    RevisionVector ancestor = RevisionVector.fromString(ancestorRevisionId);\r\n    if (!ancestor.isBranch()) {\r\n        throw new DocumentStoreException(\"Not a branch revision: \" + ancestorRevisionId);\r\n    }\r\n    try {\r\n        return nodeStore.reset(branch, ancestor, null).toString();\r\n    } catch (DocumentStoreException e) {\r\n        throw new DocumentStoreException(e);\r\n    }\r\n}","lc":0.0909090909,"pi":-0.1722488038,"ma":0.6,"nbd":-0.5,"ml":-0.0833333333,"d":0.1130952381,"mi":-0.1128964059,"fo":0.0,"r":0.0263157895,"e":0.0630671438}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7018_3244c1e5","label":1,"code":"\/**\r\n * Gets the {@link ModelMBeanInfo} for the given managed bean\r\n *\r\n * @param defaultManagedBean  the default managed bean\r\n * @param customManagedBean   an optional custom managed bean\r\n * @param objectName   the object name\r\n * @return the model info, or <tt>null<\/tt> if not possible to create, for example due the managed bean is a proxy class\r\n * @throws JMException is thrown if error creating the model info\r\n *\/\r\npublic ModelMBeanInfo getMBeanInfo(Object defaultManagedBean, Object customManagedBean, String objectName) throws JMException {\r\n    \/\/ skip proxy classes\r\n    if (Proxy.isProxyClass(defaultManagedBean.getClass())) {\r\n        LOG.trace(\"Skip creating ModelMBeanInfo due proxy class {}\", defaultManagedBean.getClass());\r\n        return null;\r\n    }\r\n    \/\/ maps and lists to contain information about attributes and operations\r\n    Map<String, ManagedAttributeInfo> attributes = new LinkedHashMap<String, ManagedAttributeInfo>();\r\n    Set<ManagedOperationInfo> operations = new LinkedHashSet<ManagedOperationInfo>();\r\n    Set<ModelMBeanAttributeInfo> mBeanAttributes = new LinkedHashSet<ModelMBeanAttributeInfo>();\r\n    Set<ModelMBeanOperationInfo> mBeanOperations = new LinkedHashSet<ModelMBeanOperationInfo>();\r\n    Set<ModelMBeanNotificationInfo> mBeanNotifications = new LinkedHashSet<ModelMBeanNotificationInfo>();\r\n    \/\/ extract details from default managed bean\r\n    extractAttributesAndOperations(defaultManagedBean.getClass(), attributes, operations);\r\n    extractMbeanAttributes(defaultManagedBean, attributes, mBeanAttributes, mBeanOperations);\r\n    extractMbeanOperations(defaultManagedBean, operations, mBeanOperations);\r\n    extractMbeanNotifications(defaultManagedBean, mBeanNotifications);\r\n    \/\/ extract details from custom managed bean\r\n    if (customManagedBean != null) {\r\n        extractAttributesAndOperations(customManagedBean.getClass(), attributes, operations);\r\n        extractMbeanAttributes(customManagedBean, attributes, mBeanAttributes, mBeanOperations);\r\n        extractMbeanOperations(customManagedBean, operations, mBeanOperations);\r\n        extractMbeanNotifications(customManagedBean, mBeanNotifications);\r\n    }\r\n    \/\/ create the ModelMBeanInfo\r\n    String name = getName(customManagedBean != null ? customManagedBean : defaultManagedBean, objectName);\r\n    String description = getDescription(customManagedBean != null ? customManagedBean : defaultManagedBean, objectName);\r\n    ModelMBeanAttributeInfo[] arrayAttributes = mBeanAttributes.toArray(new ModelMBeanAttributeInfo[mBeanAttributes.size()]);\r\n    ModelMBeanOperationInfo[] arrayOperations = mBeanOperations.toArray(new ModelMBeanOperationInfo[mBeanOperations.size()]);\r\n    ModelMBeanNotificationInfo[] arrayNotifications = mBeanNotifications.toArray(new ModelMBeanNotificationInfo[mBeanNotifications.size()]);\r\n    ModelMBeanInfo info = new ModelMBeanInfoSupport(name, description, arrayAttributes, null, arrayOperations, arrayNotifications);\r\n    LOG.trace(\"Created ModelMBeanInfo {}\", info);\r\n    return info;\r\n}","code_comment":"\/**\r\n * Gets the {@link ModelMBeanInfo} for the given managed bean\r\n *\r\n * @param defaultManagedBean  the default managed bean\r\n * @param customManagedBean   an optional custom managed bean\r\n * @param objectName   the object name\r\n * @return the model info, or <tt>null<\/tt> if not possible to create, for example due the managed bean is a proxy class\r\n * @throws JMException is thrown if error creating the model info\r\n *\/\r\n","code_no_comment":"public ModelMBeanInfo getMBeanInfo(Object defaultManagedBean, Object customManagedBean, String objectName) throws JMException {\r\n        if (Proxy.isProxyClass(defaultManagedBean.getClass())) {\r\n        LOG.trace(\"Skip creating ModelMBeanInfo due proxy class {}\", defaultManagedBean.getClass());\r\n        return null;\r\n    }\r\n        Map<String, ManagedAttributeInfo> attributes = new LinkedHashMap<String, ManagedAttributeInfo>();\r\n    Set<ManagedOperationInfo> operations = new LinkedHashSet<ManagedOperationInfo>();\r\n    Set<ModelMBeanAttributeInfo> mBeanAttributes = new LinkedHashSet<ModelMBeanAttributeInfo>();\r\n    Set<ModelMBeanOperationInfo> mBeanOperations = new LinkedHashSet<ModelMBeanOperationInfo>();\r\n    Set<ModelMBeanNotificationInfo> mBeanNotifications = new LinkedHashSet<ModelMBeanNotificationInfo>();\r\n        extractAttributesAndOperations(defaultManagedBean.getClass(), attributes, operations);\r\n    extractMbeanAttributes(defaultManagedBean, attributes, mBeanAttributes, mBeanOperations);\r\n    extractMbeanOperations(defaultManagedBean, operations, mBeanOperations);\r\n    extractMbeanNotifications(defaultManagedBean, mBeanNotifications);\r\n        if (customManagedBean != null) {\r\n        extractAttributesAndOperations(customManagedBean.getClass(), attributes, operations);\r\n        extractMbeanAttributes(customManagedBean, attributes, mBeanAttributes, mBeanOperations);\r\n        extractMbeanOperations(customManagedBean, operations, mBeanOperations);\r\n        extractMbeanNotifications(customManagedBean, mBeanNotifications);\r\n    }\r\n        String name = getName(customManagedBean != null ? customManagedBean : defaultManagedBean, objectName);\r\n    String description = getDescription(customManagedBean != null ? customManagedBean : defaultManagedBean, objectName);\r\n    ModelMBeanAttributeInfo[] arrayAttributes = mBeanAttributes.toArray(new ModelMBeanAttributeInfo[mBeanAttributes.size()]);\r\n    ModelMBeanOperationInfo[] arrayOperations = mBeanOperations.toArray(new ModelMBeanOperationInfo[mBeanOperations.size()]);\r\n    ModelMBeanNotificationInfo[] arrayNotifications = mBeanNotifications.toArray(new ModelMBeanNotificationInfo[mBeanNotifications.size()]);\r\n    ModelMBeanInfo info = new ModelMBeanInfoSupport(name, description, arrayAttributes, null, arrayOperations, arrayNotifications);\r\n    LOG.trace(\"Created ModelMBeanInfo {}\", info);\r\n    return info;\r\n}","lc":0.6818181818,"pi":-0.4593301435,"ma":0.2,"nbd":-0.5,"ml":0.1666666667,"d":0.2123015873,"mi":-0.577167019,"fo":1.4166666667,"r":-0.0263157895,"e":0.9473072734}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3280_295e73bd","label":1,"code":"\/**\r\n *  @param response\r\n *\/\r\nprivate void fireOnAfterRespondListeners(final WebResponse response) {\r\n    \/\/ invoke onafterresponse event on listeners\r\n    if (listeners != null) {\r\n        final Map<String, Component> components = Collections.unmodifiableMap(markupIdToComponent);\r\n        \/\/ create response that will be used by listeners to append\r\n        \/\/ javascript\r\n        final IJavaScriptResponse jsresponse = new IJavaScriptResponse() {\r\n\r\n            public void addJavaScript(String script) {\r\n                respondInvocation(response, script);\r\n            }\r\n        };\r\n        for (IListener listener : listeners) {\r\n            listener.onAfterRespond(components, jsresponse);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  @param response\r\n *\/\r\n","code_no_comment":"private void fireOnAfterRespondListeners(final WebResponse response) {\r\n        if (listeners != null) {\r\n        final Map<String, Component> components = Collections.unmodifiableMap(markupIdToComponent);\r\n                        final IJavaScriptResponse jsresponse = new IJavaScriptResponse() {\r\n\r\n            public void addJavaScript(String script) {\r\n                respondInvocation(response, script);\r\n            }\r\n        };\r\n        for (IListener listener : listeners) {\r\n            listener.onAfterRespond(components, jsresponse);\r\n        }\r\n    }\r\n}","lc":-0.0454545455,"pi":0.7511961722,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.0912698413,"mi":0.0576462297,"fo":-0.25,"r":1.4473684211,"e":-0.0706327115}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3006_d6472040","label":0,"code":"public static VolumeManager get(AccumuloConfiguration conf) throws IOException {\r\n    final Map<String, Volume> volumes = new HashMap<String, Volume>();\r\n    final Configuration hadoopConf = CachedConfiguration.getInstance();\r\n    \/\/ The \"default\" Volume for Accumulo (in case no volumes are specified)\r\n    for (String volumeUriOrDir : VolumeConfiguration.getVolumeUris(conf)) {\r\n        if (volumeUriOrDir.equals(DEFAULT))\r\n            \/\/ Cannot re-define the default volume\r\n            throw new IllegalArgumentException();\r\n        \/\/ We require a URI here, fail if it doesn't look like one\r\n        if (volumeUriOrDir.contains(\":\")) {\r\n            volumes.put(volumeUriOrDir, VolumeConfiguration.create(new Path(volumeUriOrDir), hadoopConf));\r\n        } else {\r\n            throw new IllegalArgumentException(\"Expected fully qualified URI for \" + Property.INSTANCE_VOLUMES.getKey() + \" got \" + volumeUriOrDir);\r\n        }\r\n    }\r\n    return new VolumeManagerImpl(volumes, VolumeConfiguration.getDefaultVolume(hadoopConf, conf), conf);\r\n}","code_comment":null,"code_no_comment":"public static VolumeManager get(AccumuloConfiguration conf) throws IOException {\r\n    final Map<String, Volume> volumes = new HashMap<String, Volume>();\r\n    final Configuration hadoopConf = CachedConfiguration.getInstance();\r\n        for (String volumeUriOrDir : VolumeConfiguration.getVolumeUris(conf)) {\r\n        if (volumeUriOrDir.equals(DEFAULT))\r\n                        throw new IllegalArgumentException();\r\n                if (volumeUriOrDir.contains(\":\")) {\r\n            volumes.put(volumeUriOrDir, VolumeConfiguration.create(new Path(volumeUriOrDir), hadoopConf));\r\n        } else {\r\n            throw new IllegalArgumentException(\"Expected fully qualified URI for \" + Property.INSTANCE_VOLUMES.getKey() + \" got \" + volumeUriOrDir);\r\n        }\r\n    }\r\n    return new VolumeManagerImpl(volumes, VolumeConfiguration.getDefaultVolume(hadoopConf, conf), conf);\r\n}","lc":0.0,"pi":0.4449760766,"ma":0.4,"nbd":0.0,"ml":-0.0833333333,"d":-0.0575396825,"mi":-0.0909090909,"fo":0.1666666667,"r":-0.0263157895,"e":0.0345568023}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-942_0d057fc6","label":1,"code":"\/**\r\n * Generate a random sample from the distribution.\r\n *\r\n * @param sampleSize the number of random values to generate.\r\n * @return an array representing the random sample.\r\n * @throws NotStrictlyPositiveException if {@code sampleSize} is not\r\n * positive.\r\n *\/\r\npublic T[] sample(int sampleSize) throws NotStrictlyPositiveException {\r\n    if (sampleSize <= 0) {\r\n        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    final T[] out = (T[]) Array.newInstance(singletons.get(0).getClass(), sampleSize);\r\n    for (int i = 0; i < sampleSize; i++) {\r\n        out[i] = sample();\r\n    }\r\n    return out;\r\n}","code_comment":"\/**\r\n * Generate a random sample from the distribution.\r\n *\r\n * @param sampleSize the number of random values to generate.\r\n * @return an array representing the random sample.\r\n * @throws NotStrictlyPositiveException if {@code sampleSize} is not\r\n * positive.\r\n *\/\r\n","code_no_comment":"public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\r\n    if (sampleSize <= 0) {\r\n        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    final T[] out = (T[]) Array.newInstance(singletons.get(0).getClass(), sampleSize);\r\n    for (int i = 0; i < sampleSize; i++) {\r\n        out[i] = sample();\r\n    }\r\n    return out;\r\n}","lc":-0.1363636364,"pi":-0.2775119617,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":0.380952381,"mi":0.1064129669,"fo":-0.1666666667,"r":0.6842105263,"e":0.1269019093}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5655_96337372","label":1,"code":"public void afterExecutionFailure(MojoExecutionEvent event) {\r\n    for (Object provided : getScopeState().provided.values()) {\r\n        if (provided instanceof WeakMojoExecutionListener) {\r\n            ((WeakMojoExecutionListener) provided).afterExecutionFailure(event);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void afterExecutionFailure(MojoExecutionEvent event) {\r\n    for (Object provided : getScopeState().provided.values()) {\r\n        if (provided instanceof WeakMojoExecutionListener) {\r\n            ((WeakMojoExecutionListener) provided).afterExecutionFailure(event);\r\n        }\r\n    }\r\n}","lc":-0.3181818182,"pi":0.5406698565,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.3650793651,"mi":0.5035940803,"fo":-0.25,"r":0.1315789474,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7213_336663c9","label":1,"code":"@Converter\r\npublic static ByteBuffer toByteBuffer(Float value) {\r\n    ByteBuffer buf = ByteBuffer.allocate(4);\r\n    buf.putFloat(value);\r\n    return buf;\r\n}","code_comment":null,"code_no_comment":"@Converter\r\npublic static ByteBuffer toByteBuffer(Float value) {\r\n    ByteBuffer buf = ByteBuffer.allocate(4);\r\n    buf.putFloat(value);\r\n    return buf;\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5644820296,"fo":-0.3333333333,"r":1.2105263158,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3634_90ad50da","label":1,"code":"@CheckForNull\r\nprivate <T extends Document> void internalUpdate(Collection<T> collection, List<String> ids, UpdateOp update) {\r\n    if (isAppendableUpdate(update) && !requiresPreviousState(update)) {\r\n        Operation modOperation = update.getChanges().get(MODIFIEDKEY);\r\n        long modified = getModifiedFromOperation(modOperation);\r\n        boolean modifiedIsConditional = modOperation == null || modOperation.type != UpdateOp.Operation.Type.SET;\r\n        String appendData = ser.asString(update);\r\n        for (List<String> chunkedIds : Lists.partition(ids, CHUNKSIZE)) {\r\n            Set<QueryContext> seenQueryContext = Collections.emptySet();\r\n            Map<String, NodeDocument> cachedDocs = Collections.emptyMap();\r\n            if (collection == Collection.NODES) {\r\n                \/\/ remember what we already have in the cache\r\n                cachedDocs = new HashMap<String, NodeDocument>();\r\n                for (String key : chunkedIds) {\r\n                    cachedDocs.put(key, nodesCache.getIfPresent(key));\r\n                }\r\n                \/\/ keep concurrently running queries from updating\r\n                \/\/ the cache entry for this key\r\n                seenQueryContext = new HashSet<QueryContext>();\r\n                for (QueryContext qc : qmap.values()) {\r\n                    qc.addKeys(chunkedIds);\r\n                    seenQueryContext.add(qc);\r\n                }\r\n            }\r\n            Connection connection = null;\r\n            RDBTableMetaData tmd = getTable(collection);\r\n            boolean success = false;\r\n            try {\r\n                connection = this.ch.getRWConnection();\r\n                success = db.batchedAppendingUpdate(connection, tmd, chunkedIds, modified, modifiedIsConditional, appendData);\r\n                connection.commit();\r\n            } catch (SQLException ex) {\r\n                success = false;\r\n                this.ch.rollbackConnection(connection);\r\n            } finally {\r\n                this.ch.closeConnection(connection);\r\n            }\r\n            if (success) {\r\n                if (collection == Collection.NODES) {\r\n                    \/\/ the cache entry for this key\r\n                    for (QueryContext qc : qmap.values()) {\r\n                        if (!seenQueryContext.contains(qc)) {\r\n                            qc.addKeys(chunkedIds);\r\n                        }\r\n                    }\r\n                }\r\n                for (Entry<String, NodeDocument> entry : cachedDocs.entrySet()) {\r\n                    T oldDoc = castAsT(entry.getValue());\r\n                    String id = entry.getKey();\r\n                    Lock lock = locks.acquire(id);\r\n                    try {\r\n                        if (oldDoc == null) {\r\n                            \/\/ make sure concurrently loaded document is\r\n                            \/\/ invalidated\r\n                            nodesCache.invalidate(id);\r\n                        } else {\r\n                            addUpdateCounters(update);\r\n                            T newDoc = createNewDocument(collection, oldDoc, update);\r\n                            nodesCache.replaceCachedDocument((NodeDocument) oldDoc, (NodeDocument) newDoc);\r\n                        }\r\n                    } finally {\r\n                        lock.unlock();\r\n                    }\r\n                }\r\n            } else {\r\n                for (String id : chunkedIds) {\r\n                    UpdateOp up = update.copy();\r\n                    up = up.shallowCopy(id);\r\n                    internalCreateOrUpdate(collection, up, false, true);\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        for (String id : ids) {\r\n            UpdateOp up = update.copy();\r\n            up = up.shallowCopy(id);\r\n            internalCreateOrUpdate(collection, up, false, true);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@CheckForNull\r\nprivate <T extends Document> void internalUpdate(Collection<T> collection, List<String> ids, UpdateOp update) {\r\n    if (isAppendableUpdate(update) && !requiresPreviousState(update)) {\r\n        Operation modOperation = update.getChanges().get(MODIFIEDKEY);\r\n        long modified = getModifiedFromOperation(modOperation);\r\n        boolean modifiedIsConditional = modOperation == null || modOperation.type != UpdateOp.Operation.Type.SET;\r\n        String appendData = ser.asString(update);\r\n        for (List<String> chunkedIds : Lists.partition(ids, CHUNKSIZE)) {\r\n            Set<QueryContext> seenQueryContext = Collections.emptySet();\r\n            Map<String, NodeDocument> cachedDocs = Collections.emptyMap();\r\n            if (collection == Collection.NODES) {\r\n                                cachedDocs = new HashMap<String, NodeDocument>();\r\n                for (String key : chunkedIds) {\r\n                    cachedDocs.put(key, nodesCache.getIfPresent(key));\r\n                }\r\n                                                seenQueryContext = new HashSet<QueryContext>();\r\n                for (QueryContext qc : qmap.values()) {\r\n                    qc.addKeys(chunkedIds);\r\n                    seenQueryContext.add(qc);\r\n                }\r\n            }\r\n            Connection connection = null;\r\n            RDBTableMetaData tmd = getTable(collection);\r\n            boolean success = false;\r\n            try {\r\n                connection = this.ch.getRWConnection();\r\n                success = db.batchedAppendingUpdate(connection, tmd, chunkedIds, modified, modifiedIsConditional, appendData);\r\n                connection.commit();\r\n            } catch (SQLException ex) {\r\n                success = false;\r\n                this.ch.rollbackConnection(connection);\r\n            } finally {\r\n                this.ch.closeConnection(connection);\r\n            }\r\n            if (success) {\r\n                if (collection == Collection.NODES) {\r\n                                        for (QueryContext qc : qmap.values()) {\r\n                        if (!seenQueryContext.contains(qc)) {\r\n                            qc.addKeys(chunkedIds);\r\n                        }\r\n                    }\r\n                }\r\n                for (Entry<String, NodeDocument> entry : cachedDocs.entrySet()) {\r\n                    T oldDoc = castAsT(entry.getValue());\r\n                    String id = entry.getKey();\r\n                    Lock lock = locks.acquire(id);\r\n                    try {\r\n                        if (oldDoc == null) {\r\n                                                                                    nodesCache.invalidate(id);\r\n                        } else {\r\n                            addUpdateCounters(update);\r\n                            T newDoc = createNewDocument(collection, oldDoc, update);\r\n                            nodesCache.replaceCachedDocument((NodeDocument) oldDoc, (NodeDocument) newDoc);\r\n                        }\r\n                    } finally {\r\n                        lock.unlock();\r\n                    }\r\n                }\r\n            } else {\r\n                for (String id : chunkedIds) {\r\n                    UpdateOp up = update.copy();\r\n                    up = up.shallowCopy(id);\r\n                    internalCreateOrUpdate(collection, up, false, true);\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        for (String id : ids) {\r\n            UpdateOp up = update.copy();\r\n            up = up.shallowCopy(id);\r\n            internalCreateOrUpdate(collection, up, false, true);\r\n        }\r\n    }\r\n}","lc":2.7272727273,"pi":1.7511961722,"ma":2.2,"nbd":2.0,"ml":0.8333333333,"d":0.9464285714,"mi":-1.1649048626,"fo":2.75,"r":-0.0263157895,"e":4.6532874605}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2426_920f32d0","label":1,"code":"public void collectResults(ResultCollector results) throws CommitFailedException {\r\n    checkArgument(status == Status.MATCH_FOUND);\r\n    String rootIncludePath = aggregateStack.isEmpty() ? null : aggregateStack.get(0);\r\n    currentInclude.collectResults(rootState.rootInclude, rootIncludePath, currentPath, matchedNodeState, results);\r\n}","code_comment":null,"code_no_comment":"public void collectResults(ResultCollector results) throws CommitFailedException {\r\n    checkArgument(status == Status.MATCH_FOUND);\r\n    String rootIncludePath = aggregateStack.isEmpty() ? null : aggregateStack.get(0);\r\n    currentInclude.collectResults(rootState.rootInclude, rootIncludePath, currentPath, matchedNodeState, results);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.128968254,"mi":0.5252995067,"fo":-0.1666666667,"r":0.0,"e":-0.0957590636}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4370_7ca927c1","label":3,"code":"\/**\r\n *  Get the sessions.\r\n *\r\n *  @return The session\r\n *\/\r\n@Override\r\npublic HttpSession getSession() {\r\n    if (session instanceof MockHttpSession && ((MockHttpSession) session).isTemporary()) {\r\n        return null;\r\n    }\r\n    return session;\r\n}","code_comment":"\/**\r\n *  Get the sessions.\r\n *\r\n *  @return The session\r\n *\/\r\n","code_no_comment":"@Override\r\npublic HttpSession getSession() {\r\n    if (session instanceof MockHttpSession && ((MockHttpSession) session).isTemporary()) {\r\n        return null;\r\n    }\r\n    return session;\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.5427766032,"fo":-0.4166666667,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6593_7f8a295a","label":3,"code":"@Override\r\nprotected void preCreateProcessor() {\r\n    Expression exp = expression;\r\n    if (expression != null && expression.getExpressionValue() != null) {\r\n        exp = expression.getExpressionValue();\r\n    }\r\n    if (exp instanceof ExpressionClause) {\r\n        ExpressionClause<?> clause = (ExpressionClause<?>) exp;\r\n        if (clause.getExpressionType() != null) {\r\n            \/\/ if using the Java DSL then the expression may have been set using the\r\n            \/\/ ExpressionClause which is a fancy builder to define expressions and predicates\r\n            \/\/ using fluent builders in the DSL. However we need afterwards a callback to\r\n            \/\/ reset the expression to the expression type the ExpressionClause did build for us\r\n            expression = clause.getExpressionType();\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void preCreateProcessor() {\r\n    Expression exp = expression;\r\n    if (expression != null && expression.getExpressionValue() != null) {\r\n        exp = expression.getExpressionValue();\r\n    }\r\n    if (exp instanceof ExpressionClause) {\r\n        ExpressionClause<?> clause = (ExpressionClause<?>) exp;\r\n        if (clause.getExpressionType() != null) {\r\n                                                            expression = clause.getExpressionType();\r\n        }\r\n    }\r\n}","lc":-0.0454545455,"pi":0.2727272727,"ma":0.0,"nbd":0.0,"ml":0.25,"d":0.1031746032,"mi":0.0675123326,"fo":-0.1666666667,"r":0.0263157895,"e":-0.0217308368}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3764_48454f4d","label":1,"code":"private void internalAdd(final Behavior behavior) {\r\n    component.data_add(behavior);\r\n    if (behavior.isStateless(component)) {\r\n        getBehaviorId(behavior);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void internalAdd(final Behavior behavior) {\r\n    component.data_add(behavior);\r\n    if (behavior.isStateless(component)) {\r\n        getBehaviorId(behavior);\r\n    }\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.621141649,"fo":-0.25,"r":0.7894736842,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3872_c13708e3","label":1,"code":"@Override\r\npublic long countDeleteChunks(List<String> chunkIds, long maxLastModifiedTime) throws Exception {\r\n    long count = 0;\r\n    for (List<String> chunk : Lists.partition(chunkIds, RDBJDBCTools.MAX_IN_CLAUSE)) {\r\n        Connection con = this.ch.getRWConnection();\r\n        PreparedStatement prepMeta = null;\r\n        PreparedStatement prepData = null;\r\n        try {\r\n            PreparedStatementComponent inClause = RDBJDBCTools.createInStatement(\"ID\", chunk, false);\r\n            StringBuilder metaStatement = new StringBuilder(\"delete from \" + this.tnMeta + \" where \").append(inClause.getStatementComponent());\r\n            StringBuilder dataStatement = new StringBuilder(\"delete from \" + this.tnData + \" where \").append(inClause.getStatementComponent());\r\n            if (maxLastModifiedTime > 0) {\r\n                metaStatement.append(\" and LASTMOD <= ?\");\r\n                dataStatement.append(\" and not exists(select * from \" + this.tnMeta + \" m where ID = m.ID and m.LASTMOD <= ?)\");\r\n            }\r\n            prepMeta = con.prepareStatement(metaStatement.toString());\r\n            prepData = con.prepareStatement(dataStatement.toString());\r\n            int mindex = 1, dindex = 1;\r\n            mindex = inClause.setParameters(prepMeta, mindex);\r\n            dindex = inClause.setParameters(prepData, dindex);\r\n            if (maxLastModifiedTime > 0) {\r\n                prepMeta.setLong(mindex, maxLastModifiedTime);\r\n                prepData.setLong(dindex, maxLastModifiedTime);\r\n            }\r\n            count += prepMeta.executeUpdate();\r\n            prepData.execute();\r\n        } finally {\r\n            closeStatement(prepMeta);\r\n            closeStatement(prepData);\r\n            con.commit();\r\n            this.ch.closeConnection(con);\r\n        }\r\n    }\r\n    return count;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic long countDeleteChunks(List<String> chunkIds, long maxLastModifiedTime) throws Exception {\r\n    long count = 0;\r\n    for (List<String> chunk : Lists.partition(chunkIds, RDBJDBCTools.MAX_IN_CLAUSE)) {\r\n        Connection con = this.ch.getRWConnection();\r\n        PreparedStatement prepMeta = null;\r\n        PreparedStatement prepData = null;\r\n        try {\r\n            PreparedStatementComponent inClause = RDBJDBCTools.createInStatement(\"ID\", chunk, false);\r\n            StringBuilder metaStatement = new StringBuilder(\"delete from \" + this.tnMeta + \" where \").append(inClause.getStatementComponent());\r\n            StringBuilder dataStatement = new StringBuilder(\"delete from \" + this.tnData + \" where \").append(inClause.getStatementComponent());\r\n            if (maxLastModifiedTime > 0) {\r\n                metaStatement.append(\" and LASTMOD <= ?\");\r\n                dataStatement.append(\" and not exists(select * from \" + this.tnMeta + \" m where ID = m.ID and m.LASTMOD <= ?)\");\r\n            }\r\n            prepMeta = con.prepareStatement(metaStatement.toString());\r\n            prepData = con.prepareStatement(dataStatement.toString());\r\n            int mindex = 1, dindex = 1;\r\n            mindex = inClause.setParameters(prepMeta, mindex);\r\n            dindex = inClause.setParameters(prepData, dindex);\r\n            if (maxLastModifiedTime > 0) {\r\n                prepMeta.setLong(mindex, maxLastModifiedTime);\r\n                prepData.setLong(dindex, maxLastModifiedTime);\r\n            }\r\n            count += prepMeta.executeUpdate();\r\n            prepData.execute();\r\n        } finally {\r\n            closeStatement(prepMeta);\r\n            closeStatement(prepData);\r\n            con.commit();\r\n            this.ch.closeConnection(con);\r\n        }\r\n    }\r\n    return count;\r\n}","lc":0.9545454545,"pi":0.6842105263,"ma":0.0,"nbd":0.5,"ml":-0.1666666667,"d":0.4900793651,"mi":-0.6445384073,"fo":1.4166666667,"r":-0.0263157895,"e":1.3480795053}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1008_0c20bfd8","label":1,"code":"\/**\r\n * Scans for classes starting at the package provided and descending into subpackages.\r\n * Each class is offered up to the Test as it is discovered, and if the Test returns\r\n * true the class is retained.  Accumulated classes can be fetched by calling\r\n * {@link #getClasses()}.\r\n *\r\n * @param test an instance of {@link Test} that will be used to filter classes\r\n * @param packageName the name of the package from which to start scanning for\r\n *        classes, e.g. {@code net.sourceforge.stripes}\r\n *\/\r\npublic void findInPackage(final Test test, String packageName) {\r\n    packageName = packageName.replace('.', '\/');\r\n    final ClassLoader loader = getClassLoader();\r\n    Enumeration<URL> urls;\r\n    try {\r\n        urls = loader.getResources(packageName);\r\n    } catch (final IOException ioe) {\r\n        LOGGER.warn(\"Could not read package: \" + packageName, ioe);\r\n        return;\r\n    }\r\n    while (urls.hasMoreElements()) {\r\n        try {\r\n            final URL url = urls.nextElement();\r\n            final String urlPath = extractPath(url);\r\n            LOGGER.info(\"Scanning for classes in [\" + urlPath + \"] matching criteria: \" + test);\r\n            \/\/ Check for a jar in a war in JBoss\r\n            if (VFSZIP.equals(url.getProtocol())) {\r\n                final String path = urlPath.substring(0, urlPath.length() - packageName.length() - 2);\r\n                final URL newURL = new URL(url.getProtocol(), url.getHost(), path);\r\n                @SuppressWarnings(\"resource\")\r\n                final JarInputStream stream = new JarInputStream(newURL.openStream());\r\n                try {\r\n                    loadImplementationsInJar(test, packageName, path, stream);\r\n                } finally {\r\n                    close(stream, newURL);\r\n                }\r\n            } else if (BUNDLE_RESOURCE.equals(url.getProtocol())) {\r\n                loadImplementationsInBundle(test, packageName);\r\n            } else {\r\n                final File file = new File(urlPath);\r\n                if (file.isDirectory()) {\r\n                    loadImplementationsInDirectory(test, packageName, file);\r\n                } else {\r\n                    loadImplementationsInJar(test, packageName, file);\r\n                }\r\n            }\r\n        } catch (final IOException ioe) {\r\n            LOGGER.warn(\"could not read entries\", ioe);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Scans for classes starting at the package provided and descending into subpackages.\r\n * Each class is offered up to the Test as it is discovered, and if the Test returns\r\n * true the class is retained.  Accumulated classes can be fetched by calling\r\n * {@link #getClasses()}.\r\n *\r\n * @param test an instance of {@link Test} that will be used to filter classes\r\n * @param packageName the name of the package from which to start scanning for\r\n *        classes, e.g. {@code net.sourceforge.stripes}\r\n *\/\r\n","code_no_comment":"public void findInPackage(final Test test, String packageName) {\r\n    packageName = packageName.replace('.', '\/');\r\n    final ClassLoader loader = getClassLoader();\r\n    Enumeration<URL> urls;\r\n    try {\r\n        urls = loader.getResources(packageName);\r\n    } catch (final IOException ioe) {\r\n        LOGGER.warn(\"Could not read package: \" + packageName, ioe);\r\n        return;\r\n    }\r\n    while (urls.hasMoreElements()) {\r\n        try {\r\n            final URL url = urls.nextElement();\r\n            final String urlPath = extractPath(url);\r\n            LOGGER.info(\"Scanning for classes in [\" + urlPath + \"] matching criteria: \" + test);\r\n                        if (VFSZIP.equals(url.getProtocol())) {\r\n                final String path = urlPath.substring(0, urlPath.length() - packageName.length() - 2);\r\n                final URL newURL = new URL(url.getProtocol(), url.getHost(), path);\r\n                @SuppressWarnings(\"resource\")\r\n                final JarInputStream stream = new JarInputStream(newURL.openStream());\r\n                try {\r\n                    loadImplementationsInJar(test, packageName, path, stream);\r\n                } finally {\r\n                    close(stream, newURL);\r\n                }\r\n            } else if (BUNDLE_RESOURCE.equals(url.getProtocol())) {\r\n                loadImplementationsInBundle(test, packageName);\r\n            } else {\r\n                final File file = new File(urlPath);\r\n                if (file.isDirectory()) {\r\n                    loadImplementationsInDirectory(test, packageName, file);\r\n                } else {\r\n                    loadImplementationsInJar(test, packageName, file);\r\n                }\r\n            }\r\n        } catch (final IOException ioe) {\r\n            LOGGER.warn(\"could not read entries\", ioe);\r\n        }\r\n    }\r\n}","lc":1.1818181818,"pi":1.3157894737,"ma":0.6,"nbd":1.5,"ml":0.3333333333,"d":0.0396825397,"mi":-0.7119097956,"fo":1.5833333333,"r":-0.0263157895,"e":0.4919025144}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  @return The current ajax version number of this page.\r\n *\/\r\npublic final int getAjaxVersionNumber() {\r\n    return versionManager == null ? 0 : versionManager.getAjaxVersionNumber();\r\n}","code_comment":"\/**\r\n *  @return The current ajax version number of this page.\r\n *\/\r\n","code_no_comment":"public final int getAjaxVersionNumber() {\r\n    return versionManager == null ? 0 : versionManager.getAjaxVersionNumber();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.3650793651,"mi":1.0188865398,"fo":-0.4166666667,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5570_57d8f051","label":1,"code":"@Override\r\npublic void renderHead(Component component, IHeaderResponse response) {\r\n    super.renderHead(component, response);\r\n    response.render(JavaScriptHeaderItem.forScript(\"if (typeof(Wicket.TimerHandles) === 'undefined') {Wicket.TimerHandles = {}}\", WICKET_TIMERS_ID));\r\n    if (component.getRequestCycle().find(AjaxRequestTarget.class) == null) {\r\n        \/\/ complete page is rendered, so timeout has to be rendered again\r\n        hasTimeout = false;\r\n    }\r\n    if (isStopped() == false) {\r\n        addTimeout(response);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void renderHead(Component component, IHeaderResponse response) {\r\n    super.renderHead(component, response);\r\n    response.render(JavaScriptHeaderItem.forScript(\"if (typeof(Wicket.TimerHandles) === 'undefined') {Wicket.TimerHandles = {}}\", WICKET_TIMERS_ID));\r\n    if (component.getRequestCycle().find(AjaxRequestTarget.class) == null) {\r\n                hasTimeout = false;\r\n    }\r\n    if (isStopped() == false) {\r\n        addTimeout(response);\r\n    }\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0972222222,"mi":0.1453136011,"fo":0.0833333333,"r":0.0,"e":-0.0795260571}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1363_69b68890","label":0,"code":"@Override\r\npublic boolean commit() throws LoginException {\r\n    if (tokenCredentials != null) {\r\n        updateSubject(tokenCredentials, getAuthInfo(tokenInfo), principals);\r\n        return true;\r\n    }\r\n    if (tokenProvider != null && sharedState.containsKey(SHARED_KEY_CREDENTIALS)) {\r\n        Credentials shared = getSharedCredentials();\r\n        if (shared != null && tokenProvider.doCreateToken(shared)) {\r\n            TokenInfo ti = tokenProvider.createToken(shared);\r\n            if (ti != null) {\r\n                TokenCredentials tc = new TokenCredentials(ti.getToken());\r\n                Map<String, String> attributes = ti.getPrivateAttributes();\r\n                for (String name : attributes.keySet()) {\r\n                    tc.setAttribute(name, attributes.get(name));\r\n                }\r\n                attributes = ti.getPublicAttributes();\r\n                for (String name : attributes.keySet()) {\r\n                    tc.setAttribute(name, attributes.get(name));\r\n                }\r\n                updateSubject(tc, getAuthInfo(ti), null);\r\n            } else {\r\n                \/\/ failed to create token -> fail commit()\r\n                log.debug(\"TokenProvider failed to create a login token for user \" + userId);\r\n                throw new LoginException(\"Failed to create login token for user \" + userId);\r\n            }\r\n        }\r\n    }\r\n    \/\/ the login attempt on this module did not succeed: clear state\r\n    clearState();\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean commit() throws LoginException {\r\n    if (tokenCredentials != null) {\r\n        updateSubject(tokenCredentials, getAuthInfo(tokenInfo), principals);\r\n        return true;\r\n    }\r\n    if (tokenProvider != null && sharedState.containsKey(SHARED_KEY_CREDENTIALS)) {\r\n        Credentials shared = getSharedCredentials();\r\n        if (shared != null && tokenProvider.doCreateToken(shared)) {\r\n            TokenInfo ti = tokenProvider.createToken(shared);\r\n            if (ti != null) {\r\n                TokenCredentials tc = new TokenCredentials(ti.getToken());\r\n                Map<String, String> attributes = ti.getPrivateAttributes();\r\n                for (String name : attributes.keySet()) {\r\n                    tc.setAttribute(name, attributes.get(name));\r\n                }\r\n                attributes = ti.getPublicAttributes();\r\n                for (String name : attributes.keySet()) {\r\n                    tc.setAttribute(name, attributes.get(name));\r\n                }\r\n                updateSubject(tc, getAuthInfo(ti), null);\r\n            } else {\r\n                                log.debug(\"TokenProvider failed to create a login token for user \" + userId);\r\n                throw new LoginException(\"Failed to create login token for user \" + userId);\r\n            }\r\n        }\r\n    }\r\n        clearState();\r\n    return false;\r\n}","lc":0.7272727273,"pi":1.4784688995,"ma":0.8,"nbd":1.0,"ml":0.5833333333,"d":0.4087301587,"mi":-0.5416490486,"fo":1.0833333333,"r":-0.0263157895,"e":0.7561118699}
{"project_name":"Lang","project_version":"12","label":0,"code":"\/**\r\n * <p>Creates a random string based on a variety of options, using\r\n * supplied source of randomness.<\/p>\r\n *\r\n * <p>If start and end are both {@code 0}, start and end are set\r\n * to {@code ' '} and {@code 'z'}, the ASCII printable\r\n * characters, will be used, unless letters and numbers are both\r\n * {@code false}, in which case, start and end are set to\r\n * {@code 0} and {@code Integer.MAX_VALUE}.\r\n *\r\n * <p>If set is not {@code null}, characters between start and\r\n * end are chosen.<\/p>\r\n *\r\n * <p>This method accepts a user-supplied {@link Random}\r\n * instance to use as a source of randomness. By seeding a single\r\n * {@link Random} instance with a fixed seed and using it for each call,\r\n * the same random sequence of strings can be generated repeatedly\r\n * and predictably.<\/p>\r\n *\r\n * @param count  the length of random string to create\r\n * @param start  the position in set of chars to start at\r\n * @param end  the position in set of chars to end before\r\n * @param letters  only allow letters?\r\n * @param numbers  only allow numbers?\r\n * @param chars  the set of chars to choose randoms from, must not be empty.\r\n *  If {@code null}, then it will use the set of all chars.\r\n * @param random  a source of randomness.\r\n * @return the random string\r\n * @throws ArrayIndexOutOfBoundsException if there are not\r\n *  {@code (end - start) + 1} characters in the set array.\r\n * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\r\n * @since 2.0\r\n *\/\r\npublic static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\r\n    if (count == 0) {\r\n        return \"\";\r\n    } else if (count < 0) {\r\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\r\n    }\r\n    if (start == 0 && end == 0) {\r\n        if (!letters && !numbers) {\r\n            end = Integer.MAX_VALUE;\r\n        } else {\r\n            end = 'z' + 1;\r\n            start = ' ';\r\n        }\r\n    }\r\n    char[] buffer = new char[count];\r\n    int gap = end - start;\r\n    while (count-- != 0) {\r\n        char ch;\r\n        if (chars == null) {\r\n            ch = (char) (random.nextInt(gap) + start);\r\n        } else {\r\n            ch = chars[random.nextInt(gap) + start];\r\n        }\r\n        if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) {\r\n            if (ch >= 56320 && ch <= 57343) {\r\n                if (count == 0) {\r\n                    count++;\r\n                } else {\r\n                    \/\/ low surrogate, insert high surrogate after putting it in\r\n                    buffer[count] = ch;\r\n                    count--;\r\n                    buffer[count] = (char) (55296 + random.nextInt(128));\r\n                }\r\n            } else if (ch >= 55296 && ch <= 56191) {\r\n                if (count == 0) {\r\n                    count++;\r\n                } else {\r\n                    \/\/ high surrogate, insert low surrogate before putting it in\r\n                    buffer[count] = (char) (56320 + random.nextInt(128));\r\n                    count--;\r\n                    buffer[count] = ch;\r\n                }\r\n            } else if (ch >= 56192 && ch <= 56319) {\r\n                \/\/ private high surrogate, no effing clue, so skip it\r\n                count++;\r\n            } else {\r\n                buffer[count] = ch;\r\n            }\r\n        } else {\r\n            count++;\r\n        }\r\n    }\r\n    return new String(buffer);\r\n}","code_comment":"\/**\r\n * <p>Creates a random string based on a variety of options, using\r\n * supplied source of randomness.<\/p>\r\n *\r\n * <p>If start and end are both {@code 0}, start and end are set\r\n * to {@code ' '} and {@code 'z'}, the ASCII printable\r\n * characters, will be used, unless letters and numbers are both\r\n * {@code false}, in which case, start and end are set to\r\n * {@code 0} and {@code Integer.MAX_VALUE}.\r\n *\r\n * <p>If set is not {@code null}, characters between start and\r\n * end are chosen.<\/p>\r\n *\r\n * <p>This method accepts a user-supplied {@link Random}\r\n * instance to use as a source of randomness. By seeding a single\r\n * {@link Random} instance with a fixed seed and using it for each call,\r\n * the same random sequence of strings can be generated repeatedly\r\n * and predictably.<\/p>\r\n *\r\n * @param count  the length of random string to create\r\n * @param start  the position in set of chars to start at\r\n * @param end  the position in set of chars to end before\r\n * @param letters  only allow letters?\r\n * @param numbers  only allow numbers?\r\n * @param chars  the set of chars to choose randoms from, must not be empty.\r\n *  If {@code null}, then it will use the set of all chars.\r\n * @param random  a source of randomness.\r\n * @return the random string\r\n * @throws ArrayIndexOutOfBoundsException if there are not\r\n *  {@code (end - start) + 1} characters in the set array.\r\n * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\r\n * @since 2.0\r\n *\/\r\n","code_no_comment":"public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars, Random random) {\r\n    if (count == 0) {\r\n        return \"\";\r\n    } else if (count < 0) {\r\n        throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\r\n    }\r\n    if (start == 0 && end == 0) {\r\n        if (!letters && !numbers) {\r\n            end = Integer.MAX_VALUE;\r\n        } else {\r\n            end = 'z' + 1;\r\n            start = ' ';\r\n        }\r\n    }\r\n    char[] buffer = new char[count];\r\n    int gap = end - start;\r\n    while (count-- != 0) {\r\n        char ch;\r\n        if (chars == null) {\r\n            ch = (char) (random.nextInt(gap) + start);\r\n        } else {\r\n            ch = chars[random.nextInt(gap) + start];\r\n        }\r\n        if (letters && Character.isLetter(ch) || numbers && Character.isDigit(ch) || !letters && !numbers) {\r\n            if (ch >= 56320 && ch <= 57343) {\r\n                if (count == 0) {\r\n                    count++;\r\n                } else {\r\n                                        buffer[count] = ch;\r\n                    count--;\r\n                    buffer[count] = (char) (55296 + random.nextInt(128));\r\n                }\r\n            } else if (ch >= 55296 && ch <= 56191) {\r\n                if (count == 0) {\r\n                    count++;\r\n                } else {\r\n                                        buffer[count] = (char) (56320 + random.nextInt(128));\r\n                    count--;\r\n                    buffer[count] = ch;\r\n                }\r\n            } else if (ch >= 56192 && ch <= 56319) {\r\n                                count++;\r\n            } else {\r\n                buffer[count] = ch;\r\n            }\r\n        } else {\r\n            count++;\r\n        }\r\n    }\r\n    return new String(buffer);\r\n}","lc":1.6818181818,"pi":1.3301435407,"ma":2.0,"nbd":1.5,"ml":2.1666666667,"d":3.376984127,"mi":-0.9083861875,"fo":0.0,"r":-0.0263157895,"e":7.8001394628}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3424_f4349a96","label":1,"code":"private static ClusterNodeInfo createInstance(DocumentStore store, String machineId, String instanceId, int configuredClusterId) {\r\n    long now = getCurrentTime();\r\n    int clusterNodeId = 0;\r\n    int maxId = 0;\r\n    ClusterNodeState state = ClusterNodeState.NONE;\r\n    Long prevLeaseEnd = null;\r\n    boolean newEntry = false;\r\n    ClusterNodeInfoDocument alreadyExistingConfigured = null;\r\n    String reuseFailureReason = \"\";\r\n    List<ClusterNodeInfoDocument> list = ClusterNodeInfoDocument.all(store);\r\n    for (ClusterNodeInfoDocument doc : list) {\r\n        String key = doc.getId();\r\n        int id;\r\n        try {\r\n            id = doc.getClusterId();\r\n        } catch (Exception e) {\r\n            LOG.debug(\"Skipping cluster node info document {} because ID is invalid\", key);\r\n            continue;\r\n        }\r\n        maxId = Math.max(maxId, id);\r\n        \/\/ not match\r\n        if (configuredClusterId != 0) {\r\n            if (configuredClusterId != id) {\r\n                continue;\r\n            } else {\r\n                alreadyExistingConfigured = doc;\r\n            }\r\n        }\r\n        Long leaseEnd = (Long) doc.get(LEASE_END_KEY);\r\n        if (leaseEnd != null && leaseEnd > now) {\r\n            \/\/ TODO wait for lease end, see OAK-3449\r\n            reuseFailureReason = \"leaseEnd \" + leaseEnd + \" > \" + now + \" - \" + (leaseEnd - now) + \"ms in the future\";\r\n            continue;\r\n        }\r\n        String mId = \"\" + doc.get(MACHINE_ID_KEY);\r\n        String iId = \"\" + doc.get(INSTANCE_ID_KEY);\r\n        \/\/ remove entries with \"random:\" keys if not in use (no lease at all)\r\n        if (mId.startsWith(RANDOM_PREFIX) && leaseEnd == null) {\r\n            store.remove(Collection.CLUSTER_NODES, key);\r\n            LOG.debug(\"Cleaned up cluster node info for clusterNodeId {} [machineId: {}, leaseEnd: {}]\", id, mId, leaseEnd == null ? \"n\/a\" : Utils.timestampToString(leaseEnd));\r\n            if (alreadyExistingConfigured == doc) {\r\n                \/\/ we removed it, so we can't re-use it after all\r\n                alreadyExistingConfigured = null;\r\n            }\r\n            continue;\r\n        }\r\n        if (!mId.equals(machineId) || !iId.equals(instanceId)) {\r\n            \/\/ a different machine or instance\r\n            reuseFailureReason = \"machineId\/instanceId do not match: \" + mId + \"\/\" + iId + \" != \" + machineId + \"\/\" + instanceId;\r\n            continue;\r\n        }\r\n        \/\/ not being used\r\n        if (clusterNodeId == 0 || id < clusterNodeId) {\r\n            \/\/ if there are multiple, use the smallest value\r\n            clusterNodeId = id;\r\n            state = ClusterNodeState.fromString((String) doc.get(STATE));\r\n            prevLeaseEnd = leaseEnd;\r\n        }\r\n    }\r\n    \/\/ create a new entry\r\n    if (clusterNodeId == 0) {\r\n        newEntry = true;\r\n        if (configuredClusterId != 0) {\r\n            if (alreadyExistingConfigured != null) {\r\n                throw new DocumentStoreException(\"Configured cluster node id \" + configuredClusterId + \" already in use: \" + reuseFailureReason);\r\n            }\r\n            clusterNodeId = configuredClusterId;\r\n        } else {\r\n            clusterNodeId = maxId + 1;\r\n        }\r\n    }\r\n    \/\/ that _lastRev recovery if needed is done.\r\n    return new ClusterNodeInfo(clusterNodeId, store, machineId, instanceId, state, RecoverLockState.NONE, prevLeaseEnd, newEntry);\r\n}","code_comment":null,"code_no_comment":"private static ClusterNodeInfo createInstance(DocumentStore store, String machineId, String instanceId, int configuredClusterId) {\r\n    long now = getCurrentTime();\r\n    int clusterNodeId = 0;\r\n    int maxId = 0;\r\n    ClusterNodeState state = ClusterNodeState.NONE;\r\n    Long prevLeaseEnd = null;\r\n    boolean newEntry = false;\r\n    ClusterNodeInfoDocument alreadyExistingConfigured = null;\r\n    String reuseFailureReason = \"\";\r\n    List<ClusterNodeInfoDocument> list = ClusterNodeInfoDocument.all(store);\r\n    for (ClusterNodeInfoDocument doc : list) {\r\n        String key = doc.getId();\r\n        int id;\r\n        try {\r\n            id = doc.getClusterId();\r\n        } catch (Exception e) {\r\n            LOG.debug(\"Skipping cluster node info document {} because ID is invalid\", key);\r\n            continue;\r\n        }\r\n        maxId = Math.max(maxId, id);\r\n                if (configuredClusterId != 0) {\r\n            if (configuredClusterId != id) {\r\n                continue;\r\n            } else {\r\n                alreadyExistingConfigured = doc;\r\n            }\r\n        }\r\n        Long leaseEnd = (Long) doc.get(LEASE_END_KEY);\r\n        if (leaseEnd != null && leaseEnd > now) {\r\n                        reuseFailureReason = \"leaseEnd \" + leaseEnd + \" > \" + now + \" - \" + (leaseEnd - now) + \"ms in the future\";\r\n            continue;\r\n        }\r\n        String mId = \"\" + doc.get(MACHINE_ID_KEY);\r\n        String iId = \"\" + doc.get(INSTANCE_ID_KEY);\r\n                if (mId.startsWith(RANDOM_PREFIX) && leaseEnd == null) {\r\n            store.remove(Collection.CLUSTER_NODES, key);\r\n            LOG.debug(\"Cleaned up cluster node info for clusterNodeId {} [machineId: {}, leaseEnd: {}]\", id, mId, leaseEnd == null ? \"n\/a\" : Utils.timestampToString(leaseEnd));\r\n            if (alreadyExistingConfigured == doc) {\r\n                                alreadyExistingConfigured = null;\r\n            }\r\n            continue;\r\n        }\r\n        if (!mId.equals(machineId) || !iId.equals(instanceId)) {\r\n                        reuseFailureReason = \"machineId\/instanceId do not match: \" + mId + \"\/\" + iId + \" != \" + machineId + \"\/\" + instanceId;\r\n            continue;\r\n        }\r\n                if (clusterNodeId == 0 || id < clusterNodeId) {\r\n                        clusterNodeId = id;\r\n            state = ClusterNodeState.fromString((String) doc.get(STATE));\r\n            prevLeaseEnd = leaseEnd;\r\n        }\r\n    }\r\n        if (clusterNodeId == 0) {\r\n        newEntry = true;\r\n        if (configuredClusterId != 0) {\r\n            if (alreadyExistingConfigured != null) {\r\n                throw new DocumentStoreException(\"Configured cluster node id \" + configuredClusterId + \" already in use: \" + reuseFailureReason);\r\n            }\r\n            clusterNodeId = configuredClusterId;\r\n        } else {\r\n            clusterNodeId = maxId + 1;\r\n        }\r\n    }\r\n        return new ClusterNodeInfo(clusterNodeId, store, machineId, instanceId, state, RecoverLockState.NONE, prevLeaseEnd, newEntry);\r\n}","lc":2.3181818182,"pi":0.3732057416,"ma":3.2,"nbd":0.5,"ml":1.8333333333,"d":2.0674603175,"mi":-1.126286117,"fo":0.9166666667,"r":-0.0263157895,"e":8.0890602399}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4761_8cdb461f","label":1,"code":"public List<Artifact> resolve(Plugin plugin, Artifact pluginArtifact, ArtifactResolutionRequest request, ArtifactFilter dependencyFilter) throws PluginResolutionException {\r\n    if (pluginArtifact == null) {\r\n        pluginArtifact = repositorySystem.createPluginArtifact(plugin);\r\n    }\r\n    Set<Artifact> overrideArtifacts = new LinkedHashSet<Artifact>();\r\n    for (Dependency dependency : plugin.getDependencies()) {\r\n        dependency.setScope(Artifact.SCOPE_RUNTIME);\r\n        overrideArtifacts.add(repositorySystem.createDependencyArtifact(dependency));\r\n    }\r\n    ArtifactFilter collectionFilter = new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME_PLUS_SYSTEM);\r\n    ArtifactFilter resolutionFilter = artifactFilterManager.getCoreArtifactFilter();\r\n    PluginDependencyResolutionListener listener = new PluginDependencyResolutionListener(resolutionFilter);\r\n    if (dependencyFilter != null) {\r\n        resolutionFilter = new AndArtifactFilter(Arrays.asList(resolutionFilter, dependencyFilter));\r\n    }\r\n    request.setArtifact(pluginArtifact);\r\n    request.setArtifactDependencies(overrideArtifacts);\r\n    request.setCollectionFilter(collectionFilter);\r\n    request.setResolutionFilter(resolutionFilter);\r\n    request.setResolveRoot(true);\r\n    request.setResolveTransitively(true);\r\n    request.addListener(listener);\r\n    ArtifactResolutionResult result = repositorySystem.resolve(request);\r\n    try {\r\n        resolutionErrorHandler.throwErrors(request, result);\r\n    } catch (ArtifactResolutionException e) {\r\n        throw new PluginResolutionException(plugin, e);\r\n    }\r\n    List<Artifact> pluginArtifacts = new ArrayList<Artifact>(result.getArtifacts());\r\n    listener.removeBannedDependencies(pluginArtifacts);\r\n    addPlexusUtils(pluginArtifacts, plugin, request);\r\n    return pluginArtifacts;\r\n}","code_comment":null,"code_no_comment":"public List<Artifact> resolve(Plugin plugin, Artifact pluginArtifact, ArtifactResolutionRequest request, ArtifactFilter dependencyFilter) throws PluginResolutionException {\r\n    if (pluginArtifact == null) {\r\n        pluginArtifact = repositorySystem.createPluginArtifact(plugin);\r\n    }\r\n    Set<Artifact> overrideArtifacts = new LinkedHashSet<Artifact>();\r\n    for (Dependency dependency : plugin.getDependencies()) {\r\n        dependency.setScope(Artifact.SCOPE_RUNTIME);\r\n        overrideArtifacts.add(repositorySystem.createDependencyArtifact(dependency));\r\n    }\r\n    ArtifactFilter collectionFilter = new ScopeArtifactFilter(Artifact.SCOPE_RUNTIME_PLUS_SYSTEM);\r\n    ArtifactFilter resolutionFilter = artifactFilterManager.getCoreArtifactFilter();\r\n    PluginDependencyResolutionListener listener = new PluginDependencyResolutionListener(resolutionFilter);\r\n    if (dependencyFilter != null) {\r\n        resolutionFilter = new AndArtifactFilter(Arrays.asList(resolutionFilter, dependencyFilter));\r\n    }\r\n    request.setArtifact(pluginArtifact);\r\n    request.setArtifactDependencies(overrideArtifacts);\r\n    request.setCollectionFilter(collectionFilter);\r\n    request.setResolutionFilter(resolutionFilter);\r\n    request.setResolveRoot(true);\r\n    request.setResolveTransitively(true);\r\n    request.addListener(listener);\r\n    ArtifactResolutionResult result = repositorySystem.resolve(request);\r\n    try {\r\n        resolutionErrorHandler.throwErrors(request, result);\r\n    } catch (ArtifactResolutionException e) {\r\n        throw new PluginResolutionException(plugin, e);\r\n    }\r\n    List<Artifact> pluginArtifacts = new ArrayList<Artifact>(result.getArtifacts());\r\n    listener.removeBannedDependencies(pluginArtifacts);\r\n    addPlexusUtils(pluginArtifacts, plugin, request);\r\n    return pluginArtifacts;\r\n}","lc":0.8636363636,"pi":-0.5167464115,"ma":0.4,"nbd":-0.5,"ml":-0.0833333333,"d":0.0238095238,"mi":-0.6163495419,"fo":1.0833333333,"r":-0.0263157895,"e":0.4629910732}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"@Override\r\npublic <T> void setProperty(String name, T value, Type<T> type) {\r\n    root.checkLive();\r\n    NodeBuilder builder = getNodeBuilder();\r\n    builder.setProperty(name, value, type);\r\n    root.updated();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic <T> void setProperty(String name, T value, Type<T> type) {\r\n    root.checkLive();\r\n    NodeBuilder builder = getNodeBuilder();\r\n    builder.setProperty(name, value, type);\r\n    root.updated();\r\n}","lc":-0.3181818182,"pi":-0.4832535885,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4133897111,"fo":-0.1666666667,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1008_0c20bfd8","label":1,"code":"\/**\r\n * Provides access to the classes discovered so far. If no calls have been made to\r\n * any of the {@code find()} methods, this set will be empty.\r\n *\r\n * @return the set of classes that have been discovered.\r\n *\/\r\npublic Set<Class<?>> getClasses() {\r\n    return classMatches;\r\n}","code_comment":"\/**\r\n * Provides access to the classes discovered so far. If no calls have been made to\r\n * any of the {@code find()} methods, this set will be empty.\r\n *\r\n * @return the set of classes that have been discovered.\r\n *\/\r\n","code_no_comment":"public Set<Class<?>> getClasses() {\r\n    return classMatches;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.5,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-519_26a61077","label":1,"code":"\/**\r\n * Guesses the parameters based on the specified observed points.\r\n *\r\n * @param points observed points upon which should base guess\r\n *\r\n * @return guessed parameters array <code>{norm, mean, sigma}<\/code>\r\n *\/\r\nprivate double[] basicGuess(WeightedObservedPoint[] points) {\r\n    Arrays.sort(points, createWeightedObservedPointComparator());\r\n    double[] params = new double[3];\r\n    int maxYIdx = findMaxY(points);\r\n    params[0] = points[maxYIdx].getY();\r\n    params[1] = points[maxYIdx].getX();\r\n    double fwhmApprox;\r\n    try {\r\n        double halfY = params[0] + ((params[1] - params[0]) \/ 2.0);\r\n        double fwhmX1 = interpolateXAtY(points, maxYIdx, -1, halfY);\r\n        double fwhmX2 = interpolateXAtY(points, maxYIdx, +1, halfY);\r\n        fwhmApprox = fwhmX2 - fwhmX1;\r\n    } catch (OutOfRangeException e) {\r\n        fwhmApprox = points[points.length - 1].getX() - points[0].getX();\r\n    }\r\n    params[2] = fwhmApprox \/ (2.0 * Math.sqrt(2.0 * Math.log(2.0)));\r\n    return params;\r\n}","code_comment":"\/**\r\n * Guesses the parameters based on the specified observed points.\r\n *\r\n * @param points observed points upon which should base guess\r\n *\r\n * @return guessed parameters array <code>{norm, mean, sigma}<\/code>\r\n *\/\r\n","code_no_comment":"private double[] basicGuess(WeightedObservedPoint[] points) {\r\n    Arrays.sort(points, createWeightedObservedPointComparator());\r\n    double[] params = new double[3];\r\n    int maxYIdx = findMaxY(points);\r\n    params[0] = points[maxYIdx].getY();\r\n    params[1] = points[maxYIdx].getX();\r\n    double fwhmApprox;\r\n    try {\r\n        double halfY = params[0] + ((params[1] - params[0]) \/ 2.0);\r\n        double fwhmX1 = interpolateXAtY(points, maxYIdx, -1, halfY);\r\n        double fwhmX2 = interpolateXAtY(points, maxYIdx, +1, halfY);\r\n        fwhmApprox = fwhmX2 - fwhmX1;\r\n    } catch (OutOfRangeException e) {\r\n        fwhmApprox = points[points.length - 1].getX() - points[0].getX();\r\n    }\r\n    params[2] = fwhmApprox \/ (2.0 * Math.sqrt(2.0 * Math.log(2.0)));\r\n    return params;\r\n}","lc":0.1818181818,"pi":-0.2822966507,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":0.6130952381,"mi":-0.252149401,"fo":0.4166666667,"r":-0.0263157895,"e":0.8687931859}
{"project_name":"Closure","project_version":"160","label":2,"code":"\/**\r\n * Initialize the compiler options. Only necessary if you're not doing\r\n * a normal compile() job.\r\n *\/\r\npublic void initOptions(CompilerOptions options) {\r\n    this.options = options;\r\n    if (errorManager == null) {\r\n        if (outStream == null) {\r\n            setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger));\r\n        } else {\r\n            PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream);\r\n            printer.setSummaryDetailLevel(options.summaryDetailLevel);\r\n            setErrorManager(printer);\r\n        }\r\n    }\r\n    \/\/ DiagnosticGroups override the plain checkTypes option.\r\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\r\n        options.checkTypes = true;\r\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\r\n        options.checkTypes = false;\r\n    } else if (!options.checkTypes) {\r\n        \/\/ If DiagnosticGroups did not override the plain checkTypes\r\n        \/\/ option, and checkTypes is enabled, then turn off the\r\n        \/\/ parser type warnings.\r\n        options.setWarningLevel(DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF);\r\n    }\r\n    if (options.checkGlobalThisLevel.isOn()) {\r\n        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);\r\n    }\r\n    \/\/ Initialize the warnings guard.\r\n    List<WarningsGuard> guards = Lists.newArrayList();\r\n    guards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));\r\n    guards.add(options.getWarningsGuard());\r\n    \/\/ error off.\r\n    if (!options.checkSymbols && (warningsGuard == null || !warningsGuard.disables(DiagnosticGroups.CHECK_VARIABLES))) {\r\n        guards.add(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\r\n    }\r\n    this.warningsGuard = new ComposeWarningsGuard(guards);\r\n}","code_comment":"\/**\r\n * Initialize the compiler options. Only necessary if you're not doing\r\n * a normal compile() job.\r\n *\/\r\n","code_no_comment":"public void initOptions(CompilerOptions options) {\r\n    this.options = options;\r\n    if (errorManager == null) {\r\n        if (outStream == null) {\r\n            setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger));\r\n        } else {\r\n            PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream);\r\n            printer.setSummaryDetailLevel(options.summaryDetailLevel);\r\n            setErrorManager(printer);\r\n        }\r\n    }\r\n        if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\r\n        options.checkTypes = true;\r\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\r\n        options.checkTypes = false;\r\n    } else if (!options.checkTypes) {\r\n                                options.setWarningLevel(DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF);\r\n    }\r\n    if (options.checkGlobalThisLevel.isOn()) {\r\n        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);\r\n    }\r\n        List<WarningsGuard> guards = Lists.newArrayList();\r\n    guards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));\r\n    guards.add(options.getWarningsGuard());\r\n        if (!options.checkSymbols && (warningsGuard == null || !warningsGuard.disables(DiagnosticGroups.CHECK_VARIABLES))) {\r\n        guards.add(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\r\n    }\r\n    this.warningsGuard = new ComposeWarningsGuard(guards);\r\n}","lc":0.6818181818,"pi":0.1291866029,"ma":0.8,"nbd":0.5,"ml":1.0833333333,"d":0.3948412698,"mi":-0.547850599,"fo":1.0833333333,"r":-0.0263157895,"e":0.8839704247}
{"project_name":"Math","project_version":"69","label":1,"code":"\/**\r\n * Returns a matrix of p-values associated with the (two-sided) null\r\n * hypothesis that the corresponding correlation coefficient is zero.\r\n * <p><code>getCorrelationPValues().getEntry(i,j)<\/code> is the probability\r\n * that a random variable distributed as <code>t<sub>n-2<\/sub><\/code> takes\r\n * a value with absolute value greater than or equal to <br>\r\n * <code>|r|((n - 2) \/ (1 - r<sup>2<\/sup>))<sup>1\/2<\/sup><\/code><\/p>\r\n * <p>The values in the matrix are sometimes referred to as the\r\n * <i>significance<\/i> of the corresponding correlation coefficients.<\/p>\r\n *\r\n * @return matrix of p-values\r\n * @throws MathException if an error occurs estimating probabilities\r\n *\/\r\npublic RealMatrix getCorrelationPValues() throws MathException {\r\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\r\n    int nVars = correlationMatrix.getColumnDimension();\r\n    double[][] out = new double[nVars][nVars];\r\n    for (int i = 0; i < nVars; i++) {\r\n        for (int j = 0; j < nVars; j++) {\r\n            if (i == j) {\r\n                out[i][j] = 0d;\r\n            } else {\r\n                double r = correlationMatrix.getEntry(i, j);\r\n                double t = Math.abs(r * Math.sqrt((nObs - 2) \/ (1 - r * r)));\r\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\r\n            }\r\n        }\r\n    }\r\n    return new BlockRealMatrix(out);\r\n}","code_comment":"\/**\r\n * Returns a matrix of p-values associated with the (two-sided) null\r\n * hypothesis that the corresponding correlation coefficient is zero.\r\n * <p><code>getCorrelationPValues().getEntry(i,j)<\/code> is the probability\r\n * that a random variable distributed as <code>t<sub>n-2<\/sub><\/code> takes\r\n * a value with absolute value greater than or equal to <br>\r\n * <code>|r|((n - 2) \/ (1 - r<sup>2<\/sup>))<sup>1\/2<\/sup><\/code><\/p>\r\n * <p>The values in the matrix are sometimes referred to as the\r\n * <i>significance<\/i> of the corresponding correlation coefficients.<\/p>\r\n *\r\n * @return matrix of p-values\r\n * @throws MathException if an error occurs estimating probabilities\r\n *\/\r\n","code_no_comment":"public RealMatrix getCorrelationPValues() throws MathException {\r\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\r\n    int nVars = correlationMatrix.getColumnDimension();\r\n    double[][] out = new double[nVars][nVars];\r\n    for (int i = 0; i < nVars; i++) {\r\n        for (int j = 0; j < nVars; j++) {\r\n            if (i == j) {\r\n                out[i][j] = 0d;\r\n            } else {\r\n                double r = correlationMatrix.getEntry(i, j);\r\n                double t = Math.abs(r * Math.sqrt((nObs - 2) \/ (1 - r * r)));\r\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\r\n            }\r\n        }\r\n    }\r\n    return new BlockRealMatrix(out);\r\n}","lc":0.1363636364,"pi":1.2344497608,"ma":0.0,"nbd":0.5,"ml":0.0833333333,"d":0.9404761905,"mi":-0.2197322058,"fo":-0.0833333333,"r":0.0263157895,"e":1.0455536154}
