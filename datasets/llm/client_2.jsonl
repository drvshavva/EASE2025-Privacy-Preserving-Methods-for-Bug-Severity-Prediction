{"project_name":"Closure","project_version":"175","label":2,"code":"\/**\r\n * Determines whether a function can be inlined at a particular call site.\r\n * There are several criteria that the function and reference must hold in\r\n * order for the functions to be inlined:\r\n * 1) If a call's arguments have side effects,\r\n * the corresponding argument in the function must only be referenced once.\r\n * For instance, this will not be inlined:\r\n * <pre>\r\n *     function foo(a) { return a + a }\r\n *     x = foo(i++);\r\n * <\/pre>\r\n *\/\r\nprivate CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\r\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\r\n        return CanInlineResult.NO;\r\n    }\r\n    Node block = fnNode.getLastChild();\r\n    \/\/ CALL NODE: [ NAME, ARG1, ARG2, ... ]\r\n    Node cArg = callNode.getFirstChild().getNext();\r\n    \/\/ parameter list.\r\n    if (!callNode.getFirstChild().isName()) {\r\n        if (NodeUtil.isFunctionObjectCall(callNode)) {\r\n            \/\/ TODO(johnlenz): Support replace this with a value.\r\n            if (cArg == null || !cArg.isThis()) {\r\n                return CanInlineResult.NO;\r\n            }\r\n            cArg = cArg.getNext();\r\n        } else {\r\n            \/\/ \".apply\" call should be filtered before this.\r\n            Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\r\n        }\r\n    }\r\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\r\n    while (cArg != null || fnParam != null) {\r\n        if (fnParam != null) {\r\n            if (cArg != null) {\r\n                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\r\n                    return CanInlineResult.NO;\r\n                }\r\n            }\r\n            fnParam = fnParam.getNext();\r\n        }\r\n        \/\/ Limit the inlining\r\n        if (cArg != null) {\r\n            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\r\n                return CanInlineResult.NO;\r\n            }\r\n            cArg = cArg.getNext();\r\n        }\r\n    }\r\n    return CanInlineResult.YES;\r\n}","code_comment":"\/**\r\n * Determines whether a function can be inlined at a particular call site.\r\n * There are several criteria that the function and reference must hold in\r\n * order for the functions to be inlined:\r\n * 1) If a call's arguments have side effects,\r\n * the corresponding argument in the function must only be referenced once.\r\n * For instance, this will not be inlined:\r\n * <pre>\r\n *     function foo(a) { return a + a }\r\n *     x = foo(i++);\r\n * <\/pre>\r\n *\/\r\n","code_no_comment":"private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\r\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\r\n        return CanInlineResult.NO;\r\n    }\r\n    Node block = fnNode.getLastChild();\r\n        Node cArg = callNode.getFirstChild().getNext();\r\n        if (!callNode.getFirstChild().isName()) {\r\n        if (NodeUtil.isFunctionObjectCall(callNode)) {\r\n                        if (cArg == null || !cArg.isThis()) {\r\n                return CanInlineResult.NO;\r\n            }\r\n            cArg = cArg.getNext();\r\n        } else {\r\n                        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\r\n        }\r\n    }\r\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\r\n    while (cArg != null || fnParam != null) {\r\n        if (fnParam != null) {\r\n            if (cArg != null) {\r\n                if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\r\n                    return CanInlineResult.NO;\r\n                }\r\n            }\r\n            fnParam = fnParam.getNext();\r\n        }\r\n                if (cArg != null) {\r\n            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\r\n                return CanInlineResult.NO;\r\n            }\r\n            cArg = cArg.getNext();\r\n        }\r\n    }\r\n    return CanInlineResult.YES;\r\n}","lc":0.9545454545,"pi":0.8947368421,"ma":1.4,"nbd":1.0,"ml":1.8333333333,"d":1.2619047619,"mi":-0.6372093023,"fo":1.0833333333,"r":-0.0263157895,"e":1.8460192597}
{"project_name":"Closure","project_version":"133","label":2,"code":"\/**\r\n * Returns the remainder of the line.\r\n *\/\r\nprivate String getRemainingJSDocLine() {\r\n    String result = stream.getRemainingJSDocLine();\r\n    return result;\r\n}","code_comment":"\/**\r\n * Returns the remainder of the line.\r\n *\/\r\n","code_no_comment":"private String getRemainingJSDocLine() {\r\n    String result = stream.getRemainingJSDocLine();\r\n    return result;\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8768146582,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * The expansion factor controls the size of a new array when an array\r\n * needs to be expanded.  The <code>expansionMode<\/code>\r\n * determines whether the size of the array is multiplied by the\r\n * <code>expansionFactor<\/code> (MULTIPLICATIVE_MODE) or if\r\n * the expansion is additive (ADDITIVE_MODE -- <code>expansionFactor<\/code>\r\n * storage locations added).  The default <code>expansionMode<\/code> is\r\n * MULTIPLICATIVE_MODE and the default <code>expansionFactor<\/code>\r\n * is 2.0.\r\n *\r\n * @return the expansion factor of this expandable double array\r\n * @deprecated As of 3.1. Return type will be changed to \"double\" in 4.0.\r\n *\/\r\n@Deprecated\r\npublic float getExpansionFactor() {\r\n    return (float) expansionFactor;\r\n}","code_comment":"\/**\r\n * The expansion factor controls the size of a new array when an array\r\n * needs to be expanded.  The <code>expansionMode<\/code>\r\n * determines whether the size of the array is multiplied by the\r\n * <code>expansionFactor<\/code> (MULTIPLICATIVE_MODE) or if\r\n * the expansion is additive (ADDITIVE_MODE -- <code>expansionFactor<\/code>\r\n * storage locations added).  The default <code>expansionMode<\/code> is\r\n * MULTIPLICATIVE_MODE and the default <code>expansionFactor<\/code>\r\n * is 2.0.\r\n *\r\n * @return the expansion factor of this expandable double array\r\n * @deprecated As of 3.1. Return type will be changed to \"double\" in 4.0.\r\n *\/\r\n","code_no_comment":"@Deprecated\r\npublic float getExpansionFactor() {\r\n    return (float) expansionFactor;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0332628612,"fo":-0.5,"r":0.2105263158,"e":-0.1627934049}
{"project_name":"Closure","project_version":"169","label":2,"code":"\/**\r\n * Checks if two types are invariant.\r\n * @see EquivalenceMethod\r\n *\/\r\npublic final boolean isInvariant(JSType that) {\r\n    return checkEquivalenceHelper(that, false);\r\n}","code_comment":"\/**\r\n * Checks if two types are invariant.\r\n * @see EquivalenceMethod\r\n *\/\r\n","code_no_comment":"public final boolean isInvariant(JSType that) {\r\n    return checkEquivalenceHelper(that, false);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0451021846,"fo":-0.4166666667,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"Compress","project_version":"29","label":1,"code":"\/**\r\n * Create an archive output stream from an archiver name and an output stream.\r\n *\r\n * @param archiverName the archive name,\r\n * i.e. {@value #AR}, {@value #ZIP}, {@value #TAR}, {@value #JAR} or {@value #CPIO}\r\n * @param out the output stream\r\n * @return the archive output stream\r\n * @throws ArchiveException if the archiver name is not known\r\n * @throws StreamingNotSupportedException if the format cannot be\r\n * written to a stream\r\n * @throws IllegalArgumentException if the archiver name or stream is null\r\n *\/\r\npublic ArchiveOutputStream createArchiveOutputStream(final String archiverName, final OutputStream out) throws ArchiveException {\r\n    if (archiverName == null) {\r\n        throw new IllegalArgumentException(\"Archivername must not be null.\");\r\n    }\r\n    if (out == null) {\r\n        throw new IllegalArgumentException(\"OutputStream must not be null.\");\r\n    }\r\n    if (AR.equalsIgnoreCase(archiverName)) {\r\n        return new ArArchiveOutputStream(out);\r\n    }\r\n    if (ZIP.equalsIgnoreCase(archiverName)) {\r\n        ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\r\n        if (entryEncoding != null) {\r\n            zip.setEncoding(entryEncoding);\r\n        }\r\n        return zip;\r\n    }\r\n    if (TAR.equalsIgnoreCase(archiverName)) {\r\n        if (entryEncoding != null) {\r\n            return new TarArchiveOutputStream(out, entryEncoding);\r\n        } else {\r\n            return new TarArchiveOutputStream(out);\r\n        }\r\n    }\r\n    if (JAR.equalsIgnoreCase(archiverName)) {\r\n        return new JarArchiveOutputStream(out);\r\n    }\r\n    if (CPIO.equalsIgnoreCase(archiverName)) {\r\n        if (entryEncoding != null) {\r\n            return new CpioArchiveOutputStream(out, entryEncoding);\r\n        } else {\r\n            return new CpioArchiveOutputStream(out);\r\n        }\r\n    }\r\n    if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\r\n        throw new StreamingNotSupportedException(SEVEN_Z);\r\n    }\r\n    throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\r\n}","code_comment":"\/**\r\n * Create an archive output stream from an archiver name and an output stream.\r\n *\r\n * @param archiverName the archive name,\r\n * i.e. {@value #AR}, {@value #ZIP}, {@value #TAR}, {@value #JAR} or {@value #CPIO}\r\n * @param out the output stream\r\n * @return the archive output stream\r\n * @throws ArchiveException if the archiver name is not known\r\n * @throws StreamingNotSupportedException if the format cannot be\r\n * written to a stream\r\n * @throws IllegalArgumentException if the archiver name or stream is null\r\n *\/\r\n","code_no_comment":"public ArchiveOutputStream createArchiveOutputStream(final String archiverName, final OutputStream out) throws ArchiveException {\r\n    if (archiverName == null) {\r\n        throw new IllegalArgumentException(\"Archivername must not be null.\");\r\n    }\r\n    if (out == null) {\r\n        throw new IllegalArgumentException(\"OutputStream must not be null.\");\r\n    }\r\n    if (AR.equalsIgnoreCase(archiverName)) {\r\n        return new ArArchiveOutputStream(out);\r\n    }\r\n    if (ZIP.equalsIgnoreCase(archiverName)) {\r\n        ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\r\n        if (entryEncoding != null) {\r\n            zip.setEncoding(entryEncoding);\r\n        }\r\n        return zip;\r\n    }\r\n    if (TAR.equalsIgnoreCase(archiverName)) {\r\n        if (entryEncoding != null) {\r\n            return new TarArchiveOutputStream(out, entryEncoding);\r\n        } else {\r\n            return new TarArchiveOutputStream(out);\r\n        }\r\n    }\r\n    if (JAR.equalsIgnoreCase(archiverName)) {\r\n        return new JarArchiveOutputStream(out);\r\n    }\r\n    if (CPIO.equalsIgnoreCase(archiverName)) {\r\n        if (entryEncoding != null) {\r\n            return new CpioArchiveOutputStream(out, entryEncoding);\r\n        } else {\r\n            return new CpioArchiveOutputStream(out);\r\n        }\r\n    }\r\n    if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\r\n        throw new StreamingNotSupportedException(SEVEN_Z);\r\n    }\r\n    throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\r\n}","lc":1.1363636364,"pi":0.0526315789,"ma":2.4,"nbd":0.0,"ml":1.25,"d":0.5337301587,"mi":-0.6704721635,"fo":0.0833333333,"r":-0.0263157895,"e":0.6346755185}
{"project_name":"Closure","project_version":"43","label":2,"code":"private void attachLiteralTypes(NodeTraversal t, Node n) {\r\n    switch(n.getType()) {\r\n        case Token.NULL:\r\n            n.setJSType(getNativeType(NULL_TYPE));\r\n            break;\r\n        case Token.VOID:\r\n            n.setJSType(getNativeType(VOID_TYPE));\r\n            break;\r\n        case Token.STRING:\r\n            \/\/ Defer keys to the Token.OBJECTLIT case\r\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\r\n                n.setJSType(getNativeType(STRING_TYPE));\r\n            }\r\n            break;\r\n        case Token.NUMBER:\r\n            n.setJSType(getNativeType(NUMBER_TYPE));\r\n            break;\r\n        case Token.TRUE:\r\n        case Token.FALSE:\r\n            n.setJSType(getNativeType(BOOLEAN_TYPE));\r\n            break;\r\n        case Token.REGEXP:\r\n            n.setJSType(getNativeType(REGEXP_TYPE));\r\n            break;\r\n        case Token.OBJECTLIT:\r\n            defineObjectLiteral(n);\r\n            break;\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void attachLiteralTypes(NodeTraversal t, Node n) {\r\n    switch(n.getType()) {\r\n        case Token.NULL:\r\n            n.setJSType(getNativeType(NULL_TYPE));\r\n            break;\r\n        case Token.VOID:\r\n            n.setJSType(getNativeType(VOID_TYPE));\r\n            break;\r\n        case Token.STRING:\r\n                        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\r\n                n.setJSType(getNativeType(STRING_TYPE));\r\n            }\r\n            break;\r\n        case Token.NUMBER:\r\n            n.setJSType(getNativeType(NUMBER_TYPE));\r\n            break;\r\n        case Token.TRUE:\r\n        case Token.FALSE:\r\n            n.setJSType(getNativeType(BOOLEAN_TYPE));\r\n            break;\r\n        case Token.REGEXP:\r\n            n.setJSType(getNativeType(REGEXP_TYPE));\r\n            break;\r\n        case Token.OBJECTLIT:\r\n            defineObjectLiteral(n);\r\n            break;\r\n    }\r\n}","lc":0.6363636364,"pi":0.3684210526,"ma":2.6,"nbd":0.5,"ml":0.6666666667,"d":-0.3650793651,"mi":-0.4759689922,"fo":0.8333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Returns a copy of the ResizableDoubleArray.  Does not contract before\r\n * the copy, so the returned object is an exact copy of this.\r\n *\r\n * @return a new ResizableDoubleArray with the same data and configuration\r\n * properties as this\r\n * @since 2.0\r\n *\/\r\npublic synchronized ResizableDoubleArray copy() {\r\n    final ResizableDoubleArray result = new ResizableDoubleArray();\r\n    copy(this, result);\r\n    return result;\r\n}","code_comment":"\/**\r\n * Returns a copy of the ResizableDoubleArray.  Does not contract before\r\n * the copy, so the returned object is an exact copy of this.\r\n *\r\n * @return a new ResizableDoubleArray with the same data and configuration\r\n * properties as this\r\n * @since 2.0\r\n *\/\r\n","code_no_comment":"public synchronized ResizableDoubleArray copy() {\r\n    final ResizableDoubleArray result = new ResizableDoubleArray();\r\n    copy(this, result);\r\n    return result;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7750528541,"fo":-0.4166666667,"r":2.3947368421,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2494_0dc92ca1","label":1,"code":"public long getMax() {\r\n    return max;\r\n}","code_comment":null,"code_no_comment":"public long getMax() {\r\n    return max;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.2407329105,"fo":-0.5,"r":2.5,"e":-0.1627934049}
{"project_name":"Closure","project_version":"92","label":2,"code":"\/**\r\n * Replace the provide statement.\r\n *\r\n * If we're providing a name with no definition, then create one.\r\n * If we're providing a name with a duplicate definition, then make sure\r\n * that definition becomes a declaration.\r\n *\/\r\nvoid replace() {\r\n    if (firstNode == null) {\r\n        \/\/ Don't touch the base case ('goog').\r\n        replacementNode = candidateDefinition;\r\n        return;\r\n    }\r\n    \/\/ provided symbol.\r\n    if (candidateDefinition != null && explicitNode != null) {\r\n        explicitNode.detachFromParent();\r\n        compiler.reportCodeChange();\r\n        \/\/ Does this need a VAR keyword?\r\n        replacementNode = candidateDefinition;\r\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\r\n            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\r\n            Node assignNode = candidateDefinition.getFirstChild();\r\n            Node nameNode = assignNode.getFirstChild();\r\n            if (nameNode.getType() == Token.NAME) {\r\n                \/\/ Need to convert this assign to a var declaration.\r\n                Node valueNode = nameNode.getNext();\r\n                assignNode.removeChild(nameNode);\r\n                assignNode.removeChild(valueNode);\r\n                nameNode.addChildToFront(valueNode);\r\n                Node varNode = new Node(Token.VAR, nameNode);\r\n                varNode.copyInformationFrom(candidateDefinition);\r\n                candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);\r\n                nameNode.setJSDocInfo(assignNode.getJSDocInfo());\r\n                compiler.reportCodeChange();\r\n                replacementNode = varNode;\r\n            }\r\n        }\r\n    } else {\r\n        \/\/ Handle the case where there's not a duplicate definition.\r\n        replacementNode = createDeclarationNode();\r\n        if (firstModule == minimumModule) {\r\n            firstNode.getParent().addChildBefore(replacementNode, firstNode);\r\n        } else {\r\n            \/\/ In this case, the name was implicitly provided by two independent\r\n            \/\/ modules. We need to move this code up to a common module.\r\n            int indexOfDot = namespace.indexOf('.');\r\n            if (indexOfDot == -1) {\r\n                \/\/ Any old place is fine.\r\n                compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);\r\n            } else {\r\n                \/\/ Add it after the parent namespace.\r\n                ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot));\r\n                Preconditions.checkNotNull(parentName);\r\n                Preconditions.checkNotNull(parentName.replacementNode);\r\n                parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);\r\n            }\r\n        }\r\n        if (explicitNode != null) {\r\n            explicitNode.detachFromParent();\r\n        }\r\n        compiler.reportCodeChange();\r\n    }\r\n}","code_comment":"\/**\r\n * Replace the provide statement.\r\n *\r\n * If we're providing a name with no definition, then create one.\r\n * If we're providing a name with a duplicate definition, then make sure\r\n * that definition becomes a declaration.\r\n *\/\r\n","code_no_comment":"void replace() {\r\n    if (firstNode == null) {\r\n                replacementNode = candidateDefinition;\r\n        return;\r\n    }\r\n        if (candidateDefinition != null && explicitNode != null) {\r\n        explicitNode.detachFromParent();\r\n        compiler.reportCodeChange();\r\n                replacementNode = candidateDefinition;\r\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\r\n            candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\r\n            Node assignNode = candidateDefinition.getFirstChild();\r\n            Node nameNode = assignNode.getFirstChild();\r\n            if (nameNode.getType() == Token.NAME) {\r\n                                Node valueNode = nameNode.getNext();\r\n                assignNode.removeChild(nameNode);\r\n                assignNode.removeChild(valueNode);\r\n                nameNode.addChildToFront(valueNode);\r\n                Node varNode = new Node(Token.VAR, nameNode);\r\n                varNode.copyInformationFrom(candidateDefinition);\r\n                candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);\r\n                nameNode.setJSDocInfo(assignNode.getJSDocInfo());\r\n                compiler.reportCodeChange();\r\n                replacementNode = varNode;\r\n            }\r\n        }\r\n    } else {\r\n                replacementNode = createDeclarationNode();\r\n        if (firstModule == minimumModule) {\r\n            firstNode.getParent().addChildBefore(replacementNode, firstNode);\r\n        } else {\r\n                                    int indexOfDot = namespace.indexOf('.');\r\n            if (indexOfDot == -1) {\r\n                                compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);\r\n            } else {\r\n                                ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot));\r\n                Preconditions.checkNotNull(parentName);\r\n                Preconditions.checkNotNull(parentName.replacementNode);\r\n                parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);\r\n            }\r\n        }\r\n        if (explicitNode != null) {\r\n            explicitNode.detachFromParent();\r\n        }\r\n        compiler.reportCodeChange();\r\n    }\r\n}","lc":1.5,"pi":0.7703349282,"ma":0.8,"nbd":0.5,"ml":0.9166666667,"d":0.5257936508,"mi":-0.8139534884,"fo":2.0833333333,"r":-0.0263157895,"e":1.510842943}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1789_07646fba","label":1,"code":"\/**\r\n * Copies the full content from the source to the target repository.\r\n * <p>\r\n * The source repository <strong>must not be modified<\/strong> while\r\n * the copy operation is running to avoid an inconsistent copy.\r\n * <p>\r\n * Note that both the source and the target repository must be closed\r\n * during the copy operation as this method requires exclusive access\r\n * to the repositories.\r\n *\r\n * @param initializer optional extra repository initializer to use\r\n * @throws RepositoryException if the copy operation fails\r\n *\/\r\npublic void copy(RepositoryInitializer initializer) throws RepositoryException {\r\n    RepositoryConfig config = source.getRepositoryConfig();\r\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\r\n    try {\r\n        NodeBuilder builder = target.getRoot().builder();\r\n        String workspace = source.getRepositoryConfig().getDefaultWorkspaceName();\r\n        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\r\n        \/\/ init target repository first\r\n        new InitialContent().initialize(builder);\r\n        if (initializer != null) {\r\n            initializer.initialize(builder);\r\n        }\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            sc.getWorkspaceInitializer().initialize(builder, workspace);\r\n        }\r\n        HashBiMap<String, String> uriToPrefix = HashBiMap.create();\r\n        Map<Integer, String> idxToPrefix = newHashMap();\r\n        copyNamespaces(builder, uriToPrefix, idxToPrefix);\r\n        copyNodeTypes(builder, uriToPrefix.inverse());\r\n        copyPrivileges(builder);\r\n        NodeState root = builder.getNodeState();\r\n        copyVersionStore(builder, root, uriToPrefix, idxToPrefix);\r\n        copyWorkspace(builder, root, workspace, uriToPrefix, idxToPrefix);\r\n        logger.info(\"Applying default commit hooks\");\r\n        \/\/ TODO: default hooks?\r\n        List<CommitHook> hooks = newArrayList();\r\n        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);\r\n        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\r\n        \/\/ hooks specific to the upgrade, need to run first\r\n        hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath))));\r\n        \/\/ security-related hooks\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            hooks.addAll(sc.getCommitHooks(workspace));\r\n        }\r\n        \/\/ type validation, reference and indexing hooks\r\n        hooks.add(new EditorHook(new CompositeEditorProvider(new TypeEditorProvider(false), new IndexUpdateProvider(new CompositeIndexEditorProvider(new ReferenceEditorProvider(), new PropertyIndexEditorProvider())))));\r\n        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);\r\n    } catch (Exception e) {\r\n        throw new RepositoryException(\"Failed to copy content\", e);\r\n    }\r\n}","code_comment":"\/**\r\n * Copies the full content from the source to the target repository.\r\n * <p>\r\n * The source repository <strong>must not be modified<\/strong> while\r\n * the copy operation is running to avoid an inconsistent copy.\r\n * <p>\r\n * Note that both the source and the target repository must be closed\r\n * during the copy operation as this method requires exclusive access\r\n * to the repositories.\r\n *\r\n * @param initializer optional extra repository initializer to use\r\n * @throws RepositoryException if the copy operation fails\r\n *\/\r\n","code_no_comment":"public void copy(RepositoryInitializer initializer) throws RepositoryException {\r\n    RepositoryConfig config = source.getRepositoryConfig();\r\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\r\n    try {\r\n        NodeBuilder builder = target.getRoot().builder();\r\n        String workspace = source.getRepositoryConfig().getDefaultWorkspaceName();\r\n        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\r\n                new InitialContent().initialize(builder);\r\n        if (initializer != null) {\r\n            initializer.initialize(builder);\r\n        }\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            sc.getWorkspaceInitializer().initialize(builder, workspace);\r\n        }\r\n        HashBiMap<String, String> uriToPrefix = HashBiMap.create();\r\n        Map<Integer, String> idxToPrefix = newHashMap();\r\n        copyNamespaces(builder, uriToPrefix, idxToPrefix);\r\n        copyNodeTypes(builder, uriToPrefix.inverse());\r\n        copyPrivileges(builder);\r\n        NodeState root = builder.getNodeState();\r\n        copyVersionStore(builder, root, uriToPrefix, idxToPrefix);\r\n        copyWorkspace(builder, root, workspace, uriToPrefix, idxToPrefix);\r\n        logger.info(\"Applying default commit hooks\");\r\n                List<CommitHook> hooks = newArrayList();\r\n        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);\r\n        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\r\n                hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath))));\r\n                for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            hooks.addAll(sc.getCommitHooks(workspace));\r\n        }\r\n                hooks.add(new EditorHook(new CompositeEditorProvider(new TypeEditorProvider(false), new IndexUpdateProvider(new CompositeIndexEditorProvider(new ReferenceEditorProvider(), new PropertyIndexEditorProvider())))));\r\n        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);\r\n    } catch (Exception e) {\r\n        throw new RepositoryException(\"Failed to copy content\", e);\r\n    }\r\n}","lc":1.0,"pi":-0.1961722488,"ma":0.4,"nbd":0.0,"ml":-0.25,"d":-0.0198412698,"mi":-0.7079633545,"fo":2.4166666667,"r":-0.0263157895,"e":0.6286774664}
{"project_name":"Math","project_version":"67","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic double getFunctionValue() {\r\n    return optimizer.getFunctionValue();\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public double getFunctionValue() {\r\n    return optimizer.getFunctionValue();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1987315011,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4753_21a47387","label":1,"code":"\/**\r\n *  Resolves the actual item that needs to be rendered for the given item. This can be a\r\n *  {@link NoHeaderItem} when the item was already rendered. It can also be a bundle or the item\r\n *  itself, when it is not part of a bundle.\r\n *\r\n *  @param item\r\n *  @return The item to be rendered\r\n *\/\r\nprivate HeaderItem getItemToBeRendered(HeaderItem item) {\r\n    if (getRealResponse().wasRendered(item)) {\r\n        return NoHeaderItem.get();\r\n    }\r\n    getRealResponse().markRendered(item);\r\n    HeaderItem bundle = Application.get().getResourceBundles().findBundle(item);\r\n    if (bundle == null) {\r\n        return item;\r\n    }\r\n    for (HeaderItem curProvided : bundle.getProvidedResources()) {\r\n        getRealResponse().markRendered(curProvided);\r\n    }\r\n    return bundle;\r\n}","code_comment":"\/**\r\n *  Resolves the actual item that needs to be rendered for the given item. This can be a\r\n *  {@link NoHeaderItem} when the item was already rendered. It can also be a bundle or the item\r\n *  itself, when it is not part of a bundle.\r\n *\r\n *  @param item\r\n *  @return The item to be rendered\r\n *\/\r\n","code_no_comment":"private HeaderItem getItemToBeRendered(HeaderItem item) {\r\n    if (getRealResponse().wasRendered(item)) {\r\n        return NoHeaderItem.get();\r\n    }\r\n    getRealResponse().markRendered(item);\r\n    HeaderItem bundle = Application.get().getResourceBundles().findBundle(item);\r\n    if (bundle == null) {\r\n        return item;\r\n    }\r\n    for (HeaderItem curProvided : bundle.getProvidedResources()) {\r\n        getRealResponse().markRendered(curProvided);\r\n    }\r\n    return bundle;\r\n}","lc":0.0,"pi":-0.2966507177,"ma":0.0,"nbd":-0.5,"ml":0.0,"d":0.0198412698,"mi":0.0246652572,"fo":0.4166666667,"r":-0.0263157895,"e":-0.0398771344}
{"project_name":"Closure","project_version":"107","label":2,"code":"@Override\r\nprotected CompilerOptions createOptions() {\r\n    CompilerOptions options = new CompilerOptions();\r\n    if (flags.processJqueryPrimitives) {\r\n        options.setCodingConvention(new JqueryCodingConvention());\r\n    } else {\r\n        options.setCodingConvention(new ClosureCodingConvention());\r\n    }\r\n    options.setExtraAnnotationNames(flags.extraAnnotationName);\r\n    CompilationLevel level = flags.compilationLevel;\r\n    level.setOptionsForCompilationLevel(options);\r\n    if (flags.debug) {\r\n        level.setDebugOptionsForCompilationLevel(options);\r\n    }\r\n    if (flags.useTypesForOptimization) {\r\n        level.setTypeBasedOptimizationOptions(options);\r\n    }\r\n    if (flags.generateExports) {\r\n        options.setGenerateExports(flags.generateExports);\r\n    }\r\n    WarningLevel wLevel = flags.warningLevel;\r\n    wLevel.setOptionsForWarningLevel(options);\r\n    for (FormattingOption formattingOption : flags.formatting) {\r\n        formattingOption.applyToOptions(options);\r\n    }\r\n    options.closurePass = flags.processClosurePrimitives;\r\n    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level && flags.processJqueryPrimitives;\r\n    options.angularPass = flags.angularPass;\r\n    if (!flags.translationsFile.isEmpty()) {\r\n        try {\r\n            options.messageBundle = new XtbMessageBundle(new FileInputStream(flags.translationsFile), flags.translationsProject);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(\"Reading XTB file\", e);\r\n        }\r\n    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\r\n        \/\/ In SIMPLE or WHITESPACE mode, if the user hasn't specified a\r\n        \/\/ translations file, they might reasonably try to write their own\r\n        \/\/ implementation of goog.getMsg that makes the substitution at\r\n        \/\/ run-time.\r\n        \/\/ \r\n        \/\/ In ADVANCED mode, goog.getMsg is going to be renamed anyway,\r\n        \/\/ so we might as well inline it. But shut off the i18n warnings,\r\n        \/\/ because the user didn't really ask for i18n.\r\n        options.messageBundle = new EmptyMessageBundle();\r\n    }\r\n    return options;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected CompilerOptions createOptions() {\r\n    CompilerOptions options = new CompilerOptions();\r\n    if (flags.processJqueryPrimitives) {\r\n        options.setCodingConvention(new JqueryCodingConvention());\r\n    } else {\r\n        options.setCodingConvention(new ClosureCodingConvention());\r\n    }\r\n    options.setExtraAnnotationNames(flags.extraAnnotationName);\r\n    CompilationLevel level = flags.compilationLevel;\r\n    level.setOptionsForCompilationLevel(options);\r\n    if (flags.debug) {\r\n        level.setDebugOptionsForCompilationLevel(options);\r\n    }\r\n    if (flags.useTypesForOptimization) {\r\n        level.setTypeBasedOptimizationOptions(options);\r\n    }\r\n    if (flags.generateExports) {\r\n        options.setGenerateExports(flags.generateExports);\r\n    }\r\n    WarningLevel wLevel = flags.warningLevel;\r\n    wLevel.setOptionsForWarningLevel(options);\r\n    for (FormattingOption formattingOption : flags.formatting) {\r\n        formattingOption.applyToOptions(options);\r\n    }\r\n    options.closurePass = flags.processClosurePrimitives;\r\n    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level && flags.processJqueryPrimitives;\r\n    options.angularPass = flags.angularPass;\r\n    if (!flags.translationsFile.isEmpty()) {\r\n        try {\r\n            options.messageBundle = new XtbMessageBundle(new FileInputStream(flags.translationsFile), flags.translationsProject);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(\"Reading XTB file\", e);\r\n        }\r\n    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\r\n                                                                        options.messageBundle = new EmptyMessageBundle();\r\n    }\r\n    return options;\r\n}","lc":1.1363636364,"pi":-0.1339712919,"ma":1.2,"nbd":0.0,"ml":0.5833333333,"d":0.4464285714,"mi":-0.6975334743,"fo":0.3333333333,"r":-0.0263157895,"e":0.9644439066}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1364_05c89637","label":1,"code":"boolean containsValue(Object value) {\r\n    for (Segment<K, V> s : segments) {\r\n        for (K k : s.keySet()) {\r\n            V v = find(k).value;\r\n            if (v != null && v.equals(value)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"boolean containsValue(Object value) {\r\n    for (Segment<K, V> s : segments) {\r\n        for (K k : s.keySet()) {\r\n            V v = find(k).value;\r\n            if (v != null && v.equals(value)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}","lc":-0.1363636364,"pi":0.990430622,"ma":0.0,"nbd":0.5,"ml":0.0,"d":-0.0734126984,"mi":0.1537702607,"fo":-0.25,"r":0.6052631579,"e":-0.0807477971}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5187_8cadc344","label":3,"code":"public boolean isRegistered(ObjectName name) {\r\n    return server.isRegistered(name);\r\n}","code_comment":null,"code_no_comment":"public boolean isRegistered(ObjectName name) {\r\n    return server.isRegistered(name);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0606060606,"fo":-0.4166666667,"r":1.6578947368,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3281_f7dd2fff","label":1,"code":"\/**\r\n * Installs the given <a href=\"http:\/\/camel.apache.org\/error-handler.html\">error handler<\/a> builder\r\n *\r\n * @param errorHandlerBuilder  the error handler to be used by default for all child routes\r\n * @return the current builder with the error handler configured\r\n *\/\r\npublic RouteBuilder errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {\r\n    routeCollection.setCamelContext(getContext());\r\n    setErrorHandlerBuilder(errorHandlerBuilder);\r\n    return this;\r\n}","code_comment":"\/**\r\n * Installs the given <a href=\"http:\/\/camel.apache.org\/error-handler.html\">error handler<\/a> builder\r\n *\r\n * @param errorHandlerBuilder  the error handler to be used by default for all child routes\r\n * @return the current builder with the error handler configured\r\n *\/\r\n","code_no_comment":"public RouteBuilder errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {\r\n    routeCollection.setCamelContext(getContext());\r\n    setErrorHandlerBuilder(errorHandlerBuilder);\r\n    return this;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7293868922,"fo":-0.25,"r":2.2368421053,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3028_89317b28","label":0,"code":"\/**\r\n * Apply the changes to the document store.\r\n *\r\n * @param baseBranchRevision the base revision of this commit. Currently only\r\n *                     used for branch commits.\r\n *\/\r\nprivate void applyToDocumentStore(Revision baseBranchRevision) {\r\n    \/\/ the value in _revisions.<revision> property of the commit root node\r\n    \/\/ regular commits use \"c\", which makes the commit visible to\r\n    \/\/ other readers. branch commits use the base revision to indicate\r\n    \/\/ the visibility of the commit\r\n    String commitValue = baseBranchRevision != null ? baseBranchRevision.toString() : \"c\";\r\n    DocumentStore store = nodeStore.getDocumentStore();\r\n    String commitRootPath = null;\r\n    if (baseBranchRevision != null) {\r\n        \/\/ branch commits always use root node as commit root\r\n        commitRootPath = \"\/\";\r\n    }\r\n    ArrayList<UpdateOp> newNodes = new ArrayList<UpdateOp>();\r\n    ArrayList<UpdateOp> changedNodes = new ArrayList<UpdateOp>();\r\n    \/\/ operations are added to this list before they are executed,\r\n    \/\/ so that all operations can be rolled back if there is a conflict\r\n    ArrayList<UpdateOp> opLog = new ArrayList<UpdateOp>();\r\n    \/\/ Compute the commit root\r\n    for (String p : operations.keySet()) {\r\n        markChanged(p);\r\n        if (commitRootPath == null) {\r\n            commitRootPath = p;\r\n        } else {\r\n            while (!PathUtils.isAncestor(commitRootPath, p)) {\r\n                commitRootPath = PathUtils.getParentPath(commitRootPath);\r\n                if (denotesRoot(commitRootPath)) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \/\/ push branch changes to journal\r\n    if (baseBranchRevision != null) {\r\n        \/\/ store as external change\r\n        JournalEntry doc = JOURNAL.newDocument(store);\r\n        doc.modified(modifiedNodes);\r\n        Revision r = revision.asBranchRevision();\r\n        store.create(JOURNAL, singletonList(doc.asUpdateOp(r)));\r\n    }\r\n    int commitRootDepth = PathUtils.getDepth(commitRootPath);\r\n    \/\/ check if there are real changes on the commit root\r\n    boolean commitRootHasChanges = operations.containsKey(commitRootPath);\r\n    \/\/ create a \"root of the commit\" if there is none\r\n    UpdateOp commitRoot = getUpdateOperationForNode(commitRootPath);\r\n    for (String p : operations.keySet()) {\r\n        UpdateOp op = operations.get(p);\r\n        if (op.isNew()) {\r\n            NodeDocument.setDeleted(op, revision, false);\r\n        }\r\n        if (op == commitRoot) {\r\n            if (!op.isNew() && commitRootHasChanges) {\r\n                \/\/ commit root already exists and this is an update\r\n                changedNodes.add(op);\r\n            }\r\n        } else {\r\n            NodeDocument.setCommitRoot(op, revision, commitRootDepth);\r\n            if (op.isNew()) {\r\n                newNodes.add(op);\r\n            } else {\r\n                changedNodes.add(op);\r\n            }\r\n        }\r\n    }\r\n    if (changedNodes.size() == 0 && commitRoot.isNew()) {\r\n        \/\/ no updates and root of commit is also new. that is,\r\n        \/\/ it is the root of a subtree added in a commit.\r\n        \/\/ so we try to add the root like all other nodes\r\n        NodeDocument.setRevision(commitRoot, revision, commitValue);\r\n        newNodes.add(commitRoot);\r\n    }\r\n    try {\r\n        if (newNodes.size() > 0) {\r\n            \/\/ set commit root on new nodes\r\n            if (!store.create(NODES, newNodes)) {\r\n                \/\/ try to apply all changes one by one\r\n                for (UpdateOp op : newNodes) {\r\n                    if (op == commitRoot) {\r\n                        \/\/ don't write the commit root just yet\r\n                        \/\/ (because there might be a conflict)\r\n                        NodeDocument.unsetRevision(commitRoot, revision);\r\n                    }\r\n                    changedNodes.add(op);\r\n                }\r\n                newNodes.clear();\r\n            }\r\n        }\r\n        for (UpdateOp op : changedNodes) {\r\n            \/\/ set commit root on changed nodes. this may even apply\r\n            \/\/ to the commit root. the _commitRoot entry is removed\r\n            \/\/ again when the _revisions entry is set at the end\r\n            NodeDocument.setCommitRoot(op, revision, commitRootDepth);\r\n            opLog.add(op);\r\n            createOrUpdateNode(store, op);\r\n        }\r\n        \/\/ the revision, with the revision property set)\r\n        if (changedNodes.size() > 0 || !commitRoot.isNew()) {\r\n            \/\/ set revision to committed\r\n            NodeDocument.setRevision(commitRoot, revision, commitValue);\r\n            if (commitRootHasChanges) {\r\n                \/\/ remove previously added commit root\r\n                NodeDocument.removeCommitRoot(commitRoot, revision);\r\n            }\r\n            opLog.add(commitRoot);\r\n            if (baseBranchRevision == null) {\r\n                \/\/ create a clone of the commitRoot in order\r\n                \/\/ to set isNew to false. If we get here the\r\n                \/\/ commitRoot document already exists and\r\n                \/\/ only needs an update\r\n                UpdateOp commit = commitRoot.shallowCopy(commitRoot.getId());\r\n                commit.setNew(false);\r\n                \/\/ only set revision on commit root when there is\r\n                \/\/ no collision for this commit revision\r\n                commit.containsMapEntry(COLLISIONS, revision, false);\r\n                NodeDocument before = nodeStore.updateCommitRoot(commit);\r\n                if (before == null) {\r\n                    String msg = \"Conflicting concurrent change. \" + \"Update operation failed: \" + commitRoot;\r\n                    throw new DocumentStoreException(msg);\r\n                } else {\r\n                    \/\/ if we get here the commit was successful and\r\n                    \/\/ the commit revision is set on the commitRoot\r\n                    \/\/ document for this commit.\r\n                    \/\/ now check for conflicts\/collisions by other commits.\r\n                    \/\/ use original commitRoot operation with\r\n                    \/\/ correct isNew flag.\r\n                    checkConflicts(commitRoot, before);\r\n                    checkSplitCandidate(before);\r\n                }\r\n            } else {\r\n                \/\/ this is a branch commit, do not fail on collisions now\r\n                \/\/ trying to merge the branch will fail later\r\n                createOrUpdateNode(store, commitRoot);\r\n            }\r\n            operations.put(commitRootPath, commitRoot);\r\n        }\r\n    } catch (DocumentStoreException e) {\r\n        rollback(newNodes, opLog, commitRoot);\r\n        throw e;\r\n    }\r\n}","code_comment":"\/**\r\n * Apply the changes to the document store.\r\n *\r\n * @param baseBranchRevision the base revision of this commit. Currently only\r\n *                     used for branch commits.\r\n *\/\r\n","code_no_comment":"private void applyToDocumentStore(Revision baseBranchRevision) {\r\n                    String commitValue = baseBranchRevision != null ? baseBranchRevision.toString() : \"c\";\r\n    DocumentStore store = nodeStore.getDocumentStore();\r\n    String commitRootPath = null;\r\n    if (baseBranchRevision != null) {\r\n                commitRootPath = \"\/\";\r\n    }\r\n    ArrayList<UpdateOp> newNodes = new ArrayList<UpdateOp>();\r\n    ArrayList<UpdateOp> changedNodes = new ArrayList<UpdateOp>();\r\n            ArrayList<UpdateOp> opLog = new ArrayList<UpdateOp>();\r\n        for (String p : operations.keySet()) {\r\n        markChanged(p);\r\n        if (commitRootPath == null) {\r\n            commitRootPath = p;\r\n        } else {\r\n            while (!PathUtils.isAncestor(commitRootPath, p)) {\r\n                commitRootPath = PathUtils.getParentPath(commitRootPath);\r\n                if (denotesRoot(commitRootPath)) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n        if (baseBranchRevision != null) {\r\n                JournalEntry doc = JOURNAL.newDocument(store);\r\n        doc.modified(modifiedNodes);\r\n        Revision r = revision.asBranchRevision();\r\n        store.create(JOURNAL, singletonList(doc.asUpdateOp(r)));\r\n    }\r\n    int commitRootDepth = PathUtils.getDepth(commitRootPath);\r\n        boolean commitRootHasChanges = operations.containsKey(commitRootPath);\r\n        UpdateOp commitRoot = getUpdateOperationForNode(commitRootPath);\r\n    for (String p : operations.keySet()) {\r\n        UpdateOp op = operations.get(p);\r\n        if (op.isNew()) {\r\n            NodeDocument.setDeleted(op, revision, false);\r\n        }\r\n        if (op == commitRoot) {\r\n            if (!op.isNew() && commitRootHasChanges) {\r\n                                changedNodes.add(op);\r\n            }\r\n        } else {\r\n            NodeDocument.setCommitRoot(op, revision, commitRootDepth);\r\n            if (op.isNew()) {\r\n                newNodes.add(op);\r\n            } else {\r\n                changedNodes.add(op);\r\n            }\r\n        }\r\n    }\r\n    if (changedNodes.size() == 0 && commitRoot.isNew()) {\r\n                                NodeDocument.setRevision(commitRoot, revision, commitValue);\r\n        newNodes.add(commitRoot);\r\n    }\r\n    try {\r\n        if (newNodes.size() > 0) {\r\n                        if (!store.create(NODES, newNodes)) {\r\n                                for (UpdateOp op : newNodes) {\r\n                    if (op == commitRoot) {\r\n                                                                        NodeDocument.unsetRevision(commitRoot, revision);\r\n                    }\r\n                    changedNodes.add(op);\r\n                }\r\n                newNodes.clear();\r\n            }\r\n        }\r\n        for (UpdateOp op : changedNodes) {\r\n                                                NodeDocument.setCommitRoot(op, revision, commitRootDepth);\r\n            opLog.add(op);\r\n            createOrUpdateNode(store, op);\r\n        }\r\n                if (changedNodes.size() > 0 || !commitRoot.isNew()) {\r\n                        NodeDocument.setRevision(commitRoot, revision, commitValue);\r\n            if (commitRootHasChanges) {\r\n                                NodeDocument.removeCommitRoot(commitRoot, revision);\r\n            }\r\n            opLog.add(commitRoot);\r\n            if (baseBranchRevision == null) {\r\n                                                                                UpdateOp commit = commitRoot.shallowCopy(commitRoot.getId());\r\n                commit.setNew(false);\r\n                                                commit.containsMapEntry(COLLISIONS, revision, false);\r\n                NodeDocument before = nodeStore.updateCommitRoot(commit);\r\n                if (before == null) {\r\n                    String msg = \"Conflicting concurrent change. \" + \"Update operation failed: \" + commitRoot;\r\n                    throw new DocumentStoreException(msg);\r\n                } else {\r\n                                                                                                                                            checkConflicts(commitRoot, before);\r\n                    checkSplitCandidate(before);\r\n                }\r\n            } else {\r\n                                                createOrUpdateNode(store, commitRoot);\r\n            }\r\n            operations.put(commitRootPath, commitRoot);\r\n        }\r\n    } catch (DocumentStoreException e) {\r\n        rollback(newNodes, opLog, commitRoot);\r\n        throw e;\r\n    }\r\n}","lc":3.8636363636,"pi":1.1148325359,"ma":4.6,"nbd":1.5,"ml":2.5833333333,"d":2.0654761905,"mi":-1.3943622269,"fo":3.9166666667,"r":-0.0263157895,"e":9.991968788}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-579_7d72e6ed","label":3,"code":"public abstract void restrictPushDown(SelectorImpl selectorImpl);","code_comment":null,"code_no_comment":"public abstract void restrictPushDown(SelectorImpl selectorImpl);","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.666384778,"fo":-0.5,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-414_116d5928","label":1,"code":"@Override\r\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\r\n    throw new UnsupportedOperationException();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\r\n    throw new UnsupportedOperationException();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.4,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8404510218,"fo":-0.5,"r":1.0526315789,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3634_90ad50da","label":1,"code":"@Override\r\npublic <T extends Document> void update(Collection<T> collection, List<String> keys, UpdateOp updateOp) {\r\n    log(\"update\", keys, updateOp);\r\n    UpdateUtils.assertUnconditional(updateOp);\r\n    DBCollection dbCollection = getDBCollection(collection);\r\n    QueryBuilder query = QueryBuilder.start(Document.ID).in(keys);\r\n    \/\/ make sure we don't modify the original updateOp\r\n    updateOp = updateOp.copy();\r\n    DBObject update = createUpdate(updateOp);\r\n    final long start = PERFLOG.start();\r\n    try {\r\n        Map<String, NodeDocument> cachedDocs = Collections.emptyMap();\r\n        if (collection == Collection.NODES) {\r\n            cachedDocs = Maps.newHashMap();\r\n            for (String key : keys) {\r\n                cachedDocs.put(key, nodesCache.getIfPresent(key));\r\n            }\r\n        }\r\n        try {\r\n            dbCollection.update(query.get(), update, false, true);\r\n            if (collection == Collection.NODES) {\r\n                \/\/ update cache\r\n                for (Entry<String, NodeDocument> entry : cachedDocs.entrySet()) {\r\n                    \/\/ the cachedDocs is not empty, so the collection = NODES\r\n                    Lock lock = nodeLocks.acquire(entry.getKey());\r\n                    try {\r\n                        if (entry.getValue() == null || entry.getValue() == NodeDocument.NULL) {\r\n                            \/\/ make sure concurrently loaded document is\r\n                            \/\/ invalidated\r\n                            nodesCache.invalidate(entry.getKey());\r\n                        } else {\r\n                            NodeDocument newDoc = applyChanges(Collection.NODES, entry.getValue(), updateOp.shallowCopy(entry.getKey()));\r\n                            nodesCache.replaceCachedDocument(entry.getValue(), newDoc);\r\n                        }\r\n                    } finally {\r\n                        lock.unlock();\r\n                    }\r\n                }\r\n            }\r\n        } catch (MongoException e) {\r\n            throw DocumentStoreException.convert(e);\r\n        }\r\n    } finally {\r\n        PERFLOG.end(start, 1, \"update\");\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic <T extends Document> void update(Collection<T> collection, List<String> keys, UpdateOp updateOp) {\r\n    log(\"update\", keys, updateOp);\r\n    UpdateUtils.assertUnconditional(updateOp);\r\n    DBCollection dbCollection = getDBCollection(collection);\r\n    QueryBuilder query = QueryBuilder.start(Document.ID).in(keys);\r\n        updateOp = updateOp.copy();\r\n    DBObject update = createUpdate(updateOp);\r\n    final long start = PERFLOG.start();\r\n    try {\r\n        Map<String, NodeDocument> cachedDocs = Collections.emptyMap();\r\n        if (collection == Collection.NODES) {\r\n            cachedDocs = Maps.newHashMap();\r\n            for (String key : keys) {\r\n                cachedDocs.put(key, nodesCache.getIfPresent(key));\r\n            }\r\n        }\r\n        try {\r\n            dbCollection.update(query.get(), update, false, true);\r\n            if (collection == Collection.NODES) {\r\n                                for (Entry<String, NodeDocument> entry : cachedDocs.entrySet()) {\r\n                                        Lock lock = nodeLocks.acquire(entry.getKey());\r\n                    try {\r\n                        if (entry.getValue() == null || entry.getValue() == NodeDocument.NULL) {\r\n                                                                                    nodesCache.invalidate(entry.getKey());\r\n                        } else {\r\n                            NodeDocument newDoc = applyChanges(Collection.NODES, entry.getValue(), updateOp.shallowCopy(entry.getKey()));\r\n                            nodesCache.replaceCachedDocument(entry.getValue(), newDoc);\r\n                        }\r\n                    } finally {\r\n                        lock.unlock();\r\n                    }\r\n                }\r\n            }\r\n        } catch (MongoException e) {\r\n            throw DocumentStoreException.convert(e);\r\n        }\r\n    } finally {\r\n        PERFLOG.end(start, 1, \"update\");\r\n    }\r\n}","lc":1.2272727273,"pi":2.5454545455,"ma":0.8,"nbd":2.0,"ml":0.0833333333,"d":0.0138888889,"mi":-0.7570119803,"fo":2.0,"r":-0.0263157895,"e":0.5760550475}
{"project_name":"Closure","project_version":"169","label":2,"code":"public boolean hasEqualCallType(FunctionType otherType) {\r\n    return this.call.checkArrowEquivalenceHelper(otherType.call, false);\r\n}","code_comment":null,"code_no_comment":"public boolean hasEqualCallType(FunctionType otherType) {\r\n    return this.call.checkArrowEquivalenceHelper(otherType.call, false);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9960535588,"fo":-0.4166666667,"r":0.1052631579,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4519_e62ded51","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic boolean visitObject(final Object object) {\r\n    return clazz.isAssignableFrom(object.getClass());\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public boolean visitObject(final Object object) {\r\n    return clazz.isAssignableFrom(object.getClass());\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0132487667,"fo":-0.3333333333,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1731_024e5d37","label":1,"code":"private void copyNodeType(QNodeTypeDefinition def, NodeBuilder builder) throws NamespaceException {\r\n    builder.setProperty(JCR_PRIMARYTYPE, NT_NODETYPE, NAME);\r\n    \/\/ - jcr:nodeTypeName (NAME) protected mandatory\r\n    builder.setProperty(JCR_NODETYPENAME, getOakName(def.getName()), NAME);\r\n    \/\/ - jcr:supertypes (NAME) protected multiple\r\n    Name[] supertypes = def.getSupertypes();\r\n    if (supertypes != null && supertypes.length > 0) {\r\n        List<String> names = newArrayListWithCapacity(supertypes.length);\r\n        for (Name supertype : supertypes) {\r\n            names.add(getOakName(supertype));\r\n        }\r\n        builder.setProperty(JCR_SUPERTYPES, names, NAMES);\r\n    }\r\n    \/\/ - jcr:isAbstract (BOOLEAN) protected mandatory\r\n    builder.setProperty(JCR_IS_ABSTRACT, def.isAbstract());\r\n    \/\/ - jcr:isQueryable (BOOLEAN) protected mandatory\r\n    builder.setProperty(JCR_IS_QUERYABLE, def.isQueryable());\r\n    \/\/ - jcr:isMixin (BOOLEAN) protected mandatory\r\n    builder.setProperty(JCR_ISMIXIN, def.isMixin());\r\n    \/\/ - jcr:hasOrderableChildNodes (BOOLEAN) protected mandatory\r\n    builder.setProperty(JCR_HASORDERABLECHILDNODES, def.hasOrderableChildNodes());\r\n    \/\/ - jcr:primaryItemName (NAME) protected\r\n    Name primary = def.getPrimaryItemName();\r\n    if (primary != null) {\r\n        builder.setProperty(JCR_PRIMARYITEMNAME, getOakName(primary), NAME);\r\n    }\r\n    \/\/ + jcr:propertyDefinition (nt:propertyDefinition) = nt:propertyDefinition protected sns\r\n    QPropertyDefinition[] properties = def.getPropertyDefs();\r\n    for (int i = 0; i < properties.length; i++) {\r\n        String name = JCR_PROPERTYDEFINITION + '[' + (i + 1) + ']';\r\n        copyPropertyDefinition(properties[i], builder.child(name));\r\n    }\r\n    \/\/ + jcr:childNodeDefinition (nt:childNodeDefinition) = nt:childNodeDefinition protected sns\r\n    QNodeDefinition[] childNodes = def.getChildNodeDefs();\r\n    for (int i = 0; i < childNodes.length; i++) {\r\n        String name = JCR_CHILDNODEDEFINITION + '[' + (i + 1) + ']';\r\n        copyChildNodeDefinition(childNodes[i], builder.child(name));\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void copyNodeType(QNodeTypeDefinition def, NodeBuilder builder) throws NamespaceException {\r\n    builder.setProperty(JCR_PRIMARYTYPE, NT_NODETYPE, NAME);\r\n        builder.setProperty(JCR_NODETYPENAME, getOakName(def.getName()), NAME);\r\n        Name[] supertypes = def.getSupertypes();\r\n    if (supertypes != null && supertypes.length > 0) {\r\n        List<String> names = newArrayListWithCapacity(supertypes.length);\r\n        for (Name supertype : supertypes) {\r\n            names.add(getOakName(supertype));\r\n        }\r\n        builder.setProperty(JCR_SUPERTYPES, names, NAMES);\r\n    }\r\n        builder.setProperty(JCR_IS_ABSTRACT, def.isAbstract());\r\n        builder.setProperty(JCR_IS_QUERYABLE, def.isQueryable());\r\n        builder.setProperty(JCR_ISMIXIN, def.isMixin());\r\n        builder.setProperty(JCR_HASORDERABLECHILDNODES, def.hasOrderableChildNodes());\r\n        Name primary = def.getPrimaryItemName();\r\n    if (primary != null) {\r\n        builder.setProperty(JCR_PRIMARYITEMNAME, getOakName(primary), NAME);\r\n    }\r\n        QPropertyDefinition[] properties = def.getPropertyDefs();\r\n    for (int i = 0; i < properties.length; i++) {\r\n        String name = JCR_PROPERTYDEFINITION + '[' + (i + 1) + ']';\r\n        copyPropertyDefinition(properties[i], builder.child(name));\r\n    }\r\n        QNodeDefinition[] childNodes = def.getChildNodeDefs();\r\n    for (int i = 0; i < childNodes.length; i++) {\r\n        String name = JCR_CHILDNODEDEFINITION + '[' + (i + 1) + ']';\r\n        copyChildNodeDefinition(childNodes[i], builder.child(name));\r\n    }\r\n}","lc":0.7272727273,"pi":-0.2057416268,"ma":0.4,"nbd":0.0,"ml":0.5,"d":0.9761904762,"mi":-0.6056377731,"fo":1.6666666667,"r":-0.0263157895,"e":2.5293868824}
{"project_name":"Closure","project_version":"43","label":2,"code":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    inputId = t.getInputId();\r\n    attachLiteralTypes(t, n);\r\n    switch(n.getType()) {\r\n        case Token.CALL:\r\n            checkForClassDefiningCalls(t, n, parent);\r\n            checkForCallingConventionDefiningCalls(n, delegateCallingConventions);\r\n            break;\r\n        case Token.FUNCTION:\r\n            if (t.getInput() == null || !t.getInput().isExtern()) {\r\n                nonExternFunctions.add(n);\r\n            }\r\n            \/\/ Hoisted functions are handled during pre-traversal.\r\n            if (!NodeUtil.isHoistedFunctionDeclaration(n)) {\r\n                defineFunctionLiteral(n, parent);\r\n            }\r\n            break;\r\n        case Token.ASSIGN:\r\n            \/\/ Handle initialization of properties.\r\n            Node firstChild = n.getFirstChild();\r\n            if (firstChild.isGetProp() && firstChild.isQualifiedName()) {\r\n                maybeDeclareQualifiedName(t, n.getJSDocInfo(), firstChild, n, firstChild.getNext());\r\n            }\r\n            break;\r\n        case Token.CATCH:\r\n            defineCatch(n, parent);\r\n            break;\r\n        case Token.VAR:\r\n            defineVar(n, parent);\r\n            break;\r\n        case Token.GETPROP:\r\n            \/\/ Handle stubbed properties.\r\n            if (parent.isExprResult() && n.isQualifiedName()) {\r\n                maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\r\n            }\r\n            break;\r\n    }\r\n\/\/ Analyze any @lends object literals in this statement.\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    inputId = t.getInputId();\r\n    attachLiteralTypes(t, n);\r\n    switch(n.getType()) {\r\n        case Token.CALL:\r\n            checkForClassDefiningCalls(t, n, parent);\r\n            checkForCallingConventionDefiningCalls(n, delegateCallingConventions);\r\n            break;\r\n        case Token.FUNCTION:\r\n            if (t.getInput() == null || !t.getInput().isExtern()) {\r\n                nonExternFunctions.add(n);\r\n            }\r\n                        if (!NodeUtil.isHoistedFunctionDeclaration(n)) {\r\n                defineFunctionLiteral(n, parent);\r\n            }\r\n            break;\r\n        case Token.ASSIGN:\r\n                        Node firstChild = n.getFirstChild();\r\n            if (firstChild.isGetProp() && firstChild.isQualifiedName()) {\r\n                maybeDeclareQualifiedName(t, n.getJSDocInfo(), firstChild, n, firstChild.getNext());\r\n            }\r\n            break;\r\n        case Token.CATCH:\r\n            defineCatch(n, parent);\r\n            break;\r\n        case Token.VAR:\r\n            defineVar(n, parent);\r\n            break;\r\n        case Token.GETPROP:\r\n                        if (parent.isExprResult() && n.isQualifiedName()) {\r\n                maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\r\n            }\r\n            break;\r\n    }\r\n}","lc":1.0,"pi":0.6602870813,"ma":2.6,"nbd":0.5,"ml":1.4166666667,"d":0.4682539683,"mi":-0.681465821,"fo":1.4166666667,"r":-0.0263157895,"e":0.8155437608}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5250_6122df49","label":1,"code":"@Override\r\npublic CssPackageResource getResource() {\r\n    return new CssPackageResource(getScope(), getName(), getLocale(), getStyle(), getVariation());\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic CssPackageResource getResource() {\r\n    return new CssPackageResource(getScope(), getName(), getLocale(), getStyle(), getVariation());\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8314305849,"fo":-0.0833333333,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5209_ed651a4d","label":3,"code":"\/\/ TODO: this checking for file == null happens because the resolver has been confused about the root\r\n\/\/ artifact or not. things like the stupid dummy artifact coming from surefire.\r\npublic List<String> getTestClasspathElements() throws DependencyResolutionRequiredException {\r\n    List<String> list = new ArrayList<String>(getArtifacts().size() + 2);\r\n    list.add(getBuild().getTestOutputDirectory());\r\n    list.add(getBuild().getOutputDirectory());\r\n    for (Artifact a : getArtifacts()) {\r\n        if (a.getArtifactHandler().isAddedToClasspath()) {\r\n            addArtifactPath(a, list);\r\n        }\r\n    }\r\n    return list;\r\n}","code_comment":null,"code_no_comment":"public List<String> getTestClasspathElements() throws DependencyResolutionRequiredException {\r\n    List<String> list = new ArrayList<String>(getArtifacts().size() + 2);\r\n    list.add(getBuild().getTestOutputDirectory());\r\n    list.add(getBuild().getOutputDirectory());\r\n    for (Artifact a : getArtifacts()) {\r\n        if (a.getArtifactHandler().isAddedToClasspath()) {\r\n            addArtifactPath(a, list);\r\n        }\r\n    }\r\n    return list;\r\n}","lc":-0.1363636364,"pi":0.1626794258,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.0416666667,"mi":0.1337561663,"fo":0.5,"r":0.0,"e":-0.053763478}
{"project_name":"Closure","project_version":"64","label":2,"code":"\/**\r\n * Writes out js code from a root node. If printing input delimiters, this\r\n * method will attach a comment to the start of the text indicating which\r\n * input the output derived from. If there were any preserve annotations\r\n * within the root's source, they will also be printed in a block comment\r\n * at the beginning of the output.\r\n *\/\r\npublic void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\r\n    runInCompilerThread(new Callable<Void>() {\r\n\r\n        public Void call() throws Exception {\r\n            if (options.printInputDelimiter) {\r\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\r\n                    \/\/ Make sure that the label starts on a new line\r\n                    cb.append(\"\\n\");\r\n                }\r\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\r\n                String delimiter = options.inputDelimiter;\r\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\r\n                Preconditions.checkState(sourceName != null);\r\n                Preconditions.checkState(!sourceName.isEmpty());\r\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\r\n                cb.append(delimiter).append(\"\\n\");\r\n            }\r\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\r\n                cb.append(\"\/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*\/\\n\");\r\n            }\r\n            \/\/ root node's mappings are offset by the given string builder buffer.\r\n            if (options.sourceMapOutputPath != null) {\r\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\r\n            }\r\n            \/\/ if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\r\n            \/\/ for the first input file\r\n            String code = toSource(root, sourceMap);\r\n            if (!code.isEmpty()) {\r\n                cb.append(code);\r\n                \/\/ In order to avoid parse ambiguity when files are concatenated\r\n                \/\/ together, all files should end in a semi-colon. Do a quick\r\n                \/\/ heuristic check if there's an obvious semi-colon already there.\r\n                int length = code.length();\r\n                char lastChar = code.charAt(length - 1);\r\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\r\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\r\n                if (!hasSemiColon) {\r\n                    cb.append(\";\");\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n}","code_comment":"\/**\r\n * Writes out js code from a root node. If printing input delimiters, this\r\n * method will attach a comment to the start of the text indicating which\r\n * input the output derived from. If there were any preserve annotations\r\n * within the root's source, they will also be printed in a block comment\r\n * at the beginning of the output.\r\n *\/\r\n","code_no_comment":"public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\r\n    runInCompilerThread(new Callable<Void>() {\r\n\r\n        public Void call() throws Exception {\r\n            if (options.printInputDelimiter) {\r\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\r\n                                        cb.append(\"\\n\");\r\n                }\r\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\r\n                String delimiter = options.inputDelimiter;\r\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\r\n                Preconditions.checkState(sourceName != null);\r\n                Preconditions.checkState(!sourceName.isEmpty());\r\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\r\n                cb.append(delimiter).append(\"\\n\");\r\n            }\r\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\r\n                cb.append(\"\/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*\/\\n\");\r\n            }\r\n                        if (options.sourceMapOutputPath != null) {\r\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\r\n            }\r\n                                    String code = toSource(root, sourceMap);\r\n            if (!code.isEmpty()) {\r\n                cb.append(code);\r\n                                                                int length = code.length();\r\n                char lastChar = code.charAt(length - 1);\r\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\r\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\r\n                if (!hasSemiColon) {\r\n                    cb.append(\";\");\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n}","lc":1.0,"pi":0.8516746411,"ma":0.8,"nbd":0.5,"ml":1.0833333333,"d":1.4682539683,"mi":-0.7127554616,"fo":2.25,"r":-0.0263157895,"e":3.7974055313}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-47_b62f1c26","label":1,"code":"public String toString() {\r\n    return \"simple:\" + name;\r\n}","code_comment":null,"code_no_comment":"public String toString() {\r\n    return \"simple:\" + name;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.067653277,"fo":-0.5,"r":2.5,"e":-0.1627934049}
{"project_name":"Time","project_version":"27","label":1,"code":"\/\/ -----------------------------------------------------------------------\r\nprivate static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\r\n    if (notPrinter && notParser) {\r\n        throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\r\n    }\r\n    int size = elementPairs.size();\r\n    if (size >= 2 && elementPairs.get(0) instanceof Separator) {\r\n        Separator sep = (Separator) elementPairs.get(0);\r\n        PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\r\n        sep = sep.finish(f.getPrinter(), f.getParser());\r\n        return new PeriodFormatter(sep, sep);\r\n    }\r\n    Object[] comp = createComposite(elementPairs);\r\n    if (notPrinter) {\r\n        return new PeriodFormatter(null, (PeriodParser) comp[1]);\r\n    } else if (notParser) {\r\n        return new PeriodFormatter((PeriodPrinter) comp[0], null);\r\n    } else {\r\n        return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\r\n    if (notPrinter && notParser) {\r\n        throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\r\n    }\r\n    int size = elementPairs.size();\r\n    if (size >= 2 && elementPairs.get(0) instanceof Separator) {\r\n        Separator sep = (Separator) elementPairs.get(0);\r\n        PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\r\n        sep = sep.finish(f.getPrinter(), f.getParser());\r\n        return new PeriodFormatter(sep, sep);\r\n    }\r\n    Object[] comp = createComposite(elementPairs);\r\n    if (notPrinter) {\r\n        return new PeriodFormatter(null, (PeriodParser) comp[1]);\r\n    } else if (notParser) {\r\n        return new PeriodFormatter((PeriodPrinter) comp[0], null);\r\n    } else {\r\n        return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\r\n    }\r\n}","lc":0.2727272727,"pi":-0.2057416268,"ma":0.4,"nbd":0.0,"ml":0.4166666667,"d":0.1428571429,"mi":-0.2992248062,"fo":0.25,"r":-0.0263157895,"e":0.282367179}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3028_89317b28","label":0,"code":"static UpdateOp combine(String id, Iterable<UpdateOp> ops) {\r\n    Map<Key, Operation> changes = Maps.newHashMap();\r\n    for (UpdateOp op : ops) {\r\n        changes.putAll(op.getChanges());\r\n    }\r\n    return new UpdateOp(id, false, false, changes);\r\n}","code_comment":null,"code_no_comment":"static UpdateOp combine(String id, Iterable<UpdateOp> ops) {\r\n    Map<Key, Operation> changes = Maps.newHashMap();\r\n    for (UpdateOp op : ops) {\r\n        changes.putAll(op.getChanges());\r\n    }\r\n    return new UpdateOp(id, false, false, changes);\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.3835095137,"fo":-0.25,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Closure","project_version":"158","label":2,"code":"private void initConfigFromFlags(String[] args, PrintStream err) {\r\n    List<String> processedArgs = processArgs(args);\r\n    CmdLineParser parser = new CmdLineParser(flags);\r\n    isConfigValid = true;\r\n    try {\r\n        parser.parseArgument(processedArgs.toArray(new String[] {}));\r\n        \/\/ For contains --flagfile flag\r\n        if (!flags.flag_file.equals(\"\")) {\r\n            processFlagFile(err);\r\n        }\r\n    } catch (CmdLineException e) {\r\n        err.println(e.getMessage());\r\n        isConfigValid = false;\r\n    } catch (IOException ioErr) {\r\n        err.println(\"ERROR - \" + flags.flag_file + \" read error.\");\r\n        isConfigValid = false;\r\n    }\r\n    if (flags.version) {\r\n        ResourceBundle config = ResourceBundle.getBundle(configResource);\r\n        err.println(\"Closure Compiler (http:\/\/code.google.com\/closure\/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\"));\r\n        err.flush();\r\n    }\r\n    if (!isConfigValid || flags.display_help) {\r\n        isConfigValid = false;\r\n        parser.printUsage(err);\r\n    } else {\r\n        getCommandLineConfig().setPrintTree(flags.print_tree).setComputePhaseOrdering(flags.compute_phase_ordering).setPrintAst(flags.print_ast).setPrintPassGraph(flags.print_pass_graph).setJscompDevMode(flags.jscomp_dev_mode).setLoggingLevel(flags.logging_level).setExterns(flags.externs).setJs(flags.js).setJsOutputFile(flags.js_output_file).setModule(flags.module).setVariableMapInputFile(flags.variable_map_input_file).setPropertyMapInputFile(flags.property_map_input_file).setVariableMapOutputFile(flags.variable_map_output_file).setCreateNameMapFiles(flags.create_name_map_files).setPropertyMapOutputFile(flags.property_map_output_file).setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()).setSummaryDetailLevel(flags.summary_detail_level).setOutputWrapper(flags.output_wrapper).setModuleWrapper(flags.module_wrapper).setModuleOutputPathPrefix(flags.module_output_path_prefix).setCreateSourceMap(flags.create_source_map).setJscompError(flags.jscomp_error).setJscompWarning(flags.jscomp_warning).setJscompOff(flags.jscomp_off).setDefine(flags.define).setCharset(flags.charset).setManageClosureDependencies(flags.manage_closure_dependencies).setClosureEntryPoints(flags.closure_entry_point).setOutputManifest(flags.output_manifest).setAcceptConstKeyword(flags.accept_const_keyword).setLanguageIn(flags.language_in);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void initConfigFromFlags(String[] args, PrintStream err) {\r\n    List<String> processedArgs = processArgs(args);\r\n    CmdLineParser parser = new CmdLineParser(flags);\r\n    isConfigValid = true;\r\n    try {\r\n        parser.parseArgument(processedArgs.toArray(new String[] {}));\r\n                if (!flags.flag_file.equals(\"\")) {\r\n            processFlagFile(err);\r\n        }\r\n    } catch (CmdLineException e) {\r\n        err.println(e.getMessage());\r\n        isConfigValid = false;\r\n    } catch (IOException ioErr) {\r\n        err.println(\"ERROR - \" + flags.flag_file + \" read error.\");\r\n        isConfigValid = false;\r\n    }\r\n    if (flags.version) {\r\n        ResourceBundle config = ResourceBundle.getBundle(configResource);\r\n        err.println(\"Closure Compiler (http:\/\/code.google.com\/closure\/compiler)\\n\" + \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" + \"Built on: \" + config.getString(\"compiler.date\"));\r\n        err.flush();\r\n    }\r\n    if (!isConfigValid || flags.display_help) {\r\n        isConfigValid = false;\r\n        parser.printUsage(err);\r\n    } else {\r\n        getCommandLineConfig().setPrintTree(flags.print_tree).setComputePhaseOrdering(flags.compute_phase_ordering).setPrintAst(flags.print_ast).setPrintPassGraph(flags.print_pass_graph).setJscompDevMode(flags.jscomp_dev_mode).setLoggingLevel(flags.logging_level).setExterns(flags.externs).setJs(flags.js).setJsOutputFile(flags.js_output_file).setModule(flags.module).setVariableMapInputFile(flags.variable_map_input_file).setPropertyMapInputFile(flags.property_map_input_file).setVariableMapOutputFile(flags.variable_map_output_file).setCreateNameMapFiles(flags.create_name_map_files).setPropertyMapOutputFile(flags.property_map_output_file).setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()).setSummaryDetailLevel(flags.summary_detail_level).setOutputWrapper(flags.output_wrapper).setModuleWrapper(flags.module_wrapper).setModuleOutputPathPrefix(flags.module_output_path_prefix).setCreateSourceMap(flags.create_source_map).setJscompError(flags.jscomp_error).setJscompWarning(flags.jscomp_warning).setJscompOff(flags.jscomp_off).setDefine(flags.define).setCharset(flags.charset).setManageClosureDependencies(flags.manage_closure_dependencies).setClosureEntryPoints(flags.closure_entry_point).setOutputManifest(flags.output_manifest).setAcceptConstKeyword(flags.accept_const_keyword).setLanguageIn(flags.language_in);\r\n    }\r\n}","lc":0.6363636364,"pi":-0.1291866029,"ma":0.6,"nbd":0.0,"ml":0.4166666667,"d":0.2579365079,"mi":-0.6352360817,"fo":3.3333333333,"r":-0.0263157895,"e":1.6524956346}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-16_3431e60d","label":1,"code":"\/**\r\n *  Encode a page class target.\r\n *\r\n *  If you override this method to behave different then also\r\n *  {@link #addBookmarkablePageParameters(Request, RequestParameters)} should\r\n *  be overridden to by in sync with that behaviour.\r\n *\r\n *  @param requestCycle\r\n *             the current request cycle\r\n *  @param requestTarget\r\n *             the target to encode\r\n *  @return the encoded url\r\n *\/\r\nprotected CharSequence encode(RequestCycle requestCycle, IBookmarkablePageRequestTarget requestTarget) {\r\n    \/\/ Begin encoding URL\r\n    final AppendingStringBuffer url = new AppendingStringBuffer(64);\r\n    url.append(urlPrefix(requestCycle));\r\n    \/\/ Get page Class\r\n    final Class pageClass = requestTarget.getPageClass();\r\n    final Application application = Application.get();\r\n    \/\/ Find pagemap name\r\n    String pageMapName = requestTarget.getPageMapName();\r\n    if (pageMapName == null) {\r\n        IRequestTarget currentTarget = requestCycle.getRequestTarget();\r\n        if (currentTarget instanceof IPageRequestTarget) {\r\n            Page currentPage = ((IPageRequestTarget) currentTarget).getPage();\r\n            final PageMap pageMap = currentPage.getPageMap();\r\n            if (pageMap.isDefault()) {\r\n                pageMapName = \"\";\r\n            } else {\r\n                pageMapName = pageMap.getName();\r\n            }\r\n        } else {\r\n            pageMapName = \"\";\r\n        }\r\n    }\r\n    boolean firstParameter = true;\r\n    if (!application.getHomePage().equals(pageClass) || !\"\".equals(pageMapName) || requestTarget instanceof BookmarkableListenerInterfaceRequestTarget) {\r\n        firstParameter = false;\r\n        url.append('?');\r\n        url.append(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME);\r\n        url.append('=');\r\n        \/\/ Add <page-map-name>:<bookmarkable-page-class>\r\n        url.append(pageMapName + Component.PATH_SEPARATOR + pageClass.getName());\r\n    }\r\n    \/\/ Is it a bookmarkable interface listener?\r\n    if (requestTarget instanceof BookmarkableListenerInterfaceRequestTarget) {\r\n        BookmarkableListenerInterfaceRequestTarget listenerTarget = (BookmarkableListenerInterfaceRequestTarget) requestTarget;\r\n        if (firstParameter == true) {\r\n            url.append(\"?\");\r\n        } else {\r\n            url.append(\"&\");\r\n        }\r\n        firstParameter = false;\r\n        url.append(INTERFACE_PARAMETER_NAME);\r\n        url.append(\"=\");\r\n        url.append(Component.PATH_SEPARATOR);\r\n        url.append(listenerTarget.getComponentPath());\r\n        url.append(Component.PATH_SEPARATOR);\r\n        url.append(Component.PATH_SEPARATOR);\r\n        url.append(listenerTarget.getInterfaceName());\r\n    }\r\n    \/\/ Get page parameters\r\n    final PageParameters parameters = requestTarget.getPageParameters();\r\n    if (parameters != null) {\r\n        for (Object element : parameters.keySet()) {\r\n            final String key = (String) element;\r\n            final String value = parameters.getString(key);\r\n            if (value != null) {\r\n                String escapedValue = value;\r\n                try {\r\n                    escapedValue = URLEncoder.encode(escapedValue, application.getRequestCycleSettings().getResponseRequestEncoding());\r\n                } catch (UnsupportedEncodingException ex) {\r\n                    log.error(ex.getMessage(), ex);\r\n                }\r\n                if (!firstParameter) {\r\n                    url.append('&');\r\n                } else {\r\n                    firstParameter = false;\r\n                    url.append('?');\r\n                }\r\n                url.append(key);\r\n                url.append('=');\r\n                url.append(escapedValue);\r\n            }\r\n        }\r\n    }\r\n    return requestCycle.getOriginalResponse().encodeURL(url);\r\n}","code_comment":"\/**\r\n *  Encode a page class target.\r\n *\r\n *  If you override this method to behave different then also\r\n *  {@link #addBookmarkablePageParameters(Request, RequestParameters)} should\r\n *  be overridden to by in sync with that behaviour.\r\n *\r\n *  @param requestCycle\r\n *             the current request cycle\r\n *  @param requestTarget\r\n *             the target to encode\r\n *  @return the encoded url\r\n *\/\r\n","code_no_comment":"protected CharSequence encode(RequestCycle requestCycle, IBookmarkablePageRequestTarget requestTarget) {\r\n        final AppendingStringBuffer url = new AppendingStringBuffer(64);\r\n    url.append(urlPrefix(requestCycle));\r\n        final Class pageClass = requestTarget.getPageClass();\r\n    final Application application = Application.get();\r\n        String pageMapName = requestTarget.getPageMapName();\r\n    if (pageMapName == null) {\r\n        IRequestTarget currentTarget = requestCycle.getRequestTarget();\r\n        if (currentTarget instanceof IPageRequestTarget) {\r\n            Page currentPage = ((IPageRequestTarget) currentTarget).getPage();\r\n            final PageMap pageMap = currentPage.getPageMap();\r\n            if (pageMap.isDefault()) {\r\n                pageMapName = \"\";\r\n            } else {\r\n                pageMapName = pageMap.getName();\r\n            }\r\n        } else {\r\n            pageMapName = \"\";\r\n        }\r\n    }\r\n    boolean firstParameter = true;\r\n    if (!application.getHomePage().equals(pageClass) || !\"\".equals(pageMapName) || requestTarget instanceof BookmarkableListenerInterfaceRequestTarget) {\r\n        firstParameter = false;\r\n        url.append('?');\r\n        url.append(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME);\r\n        url.append('=');\r\n                url.append(pageMapName + Component.PATH_SEPARATOR + pageClass.getName());\r\n    }\r\n        if (requestTarget instanceof BookmarkableListenerInterfaceRequestTarget) {\r\n        BookmarkableListenerInterfaceRequestTarget listenerTarget = (BookmarkableListenerInterfaceRequestTarget) requestTarget;\r\n        if (firstParameter == true) {\r\n            url.append(\"?\");\r\n        } else {\r\n            url.append(\"&\");\r\n        }\r\n        firstParameter = false;\r\n        url.append(INTERFACE_PARAMETER_NAME);\r\n        url.append(\"=\");\r\n        url.append(Component.PATH_SEPARATOR);\r\n        url.append(listenerTarget.getComponentPath());\r\n        url.append(Component.PATH_SEPARATOR);\r\n        url.append(Component.PATH_SEPARATOR);\r\n        url.append(listenerTarget.getInterfaceName());\r\n    }\r\n        final PageParameters parameters = requestTarget.getPageParameters();\r\n    if (parameters != null) {\r\n        for (Object element : parameters.keySet()) {\r\n            final String key = (String) element;\r\n            final String value = parameters.getString(key);\r\n            if (value != null) {\r\n                String escapedValue = value;\r\n                try {\r\n                    escapedValue = URLEncoder.encode(escapedValue, application.getRequestCycleSettings().getResponseRequestEncoding());\r\n                } catch (UnsupportedEncodingException ex) {\r\n                    log.error(ex.getMessage(), ex);\r\n                }\r\n                if (!firstParameter) {\r\n                    url.append('&');\r\n                } else {\r\n                    firstParameter = false;\r\n                    url.append('?');\r\n                }\r\n                url.append(key);\r\n                url.append('=');\r\n                url.append(escapedValue);\r\n            }\r\n        }\r\n    }\r\n    return requestCycle.getOriginalResponse().encodeURL(url);\r\n}","lc":2.5454545455,"pi":1.023923445,"ma":1.6,"nbd":1.0,"ml":1.3333333333,"d":1.1646825397,"mi":-1.0964059197,"fo":3.1666666667,"r":-0.0263157895,"e":4.6173406407}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6604_4209fabb","label":1,"code":"public void begin() {\r\n    \/\/ we have already acquired and prepare the producer\r\n    LOG.trace(\"RecipientProcessorExchangePair #{} begin: {}\", index, exchange);\r\n    exchange.setProperty(Exchange.RECIPIENT_LIST_ENDPOINT, endpoint.getEndpointUri());\r\n}","code_comment":null,"code_no_comment":"public void begin() {\r\n        LOG.trace(\"RecipientProcessorExchangePair #{} begin: {}\", index, exchange);\r\n    exchange.setProperty(Exchange.RECIPIENT_LIST_ENDPOINT, endpoint.getEndpointUri());\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7750528541,"fo":-0.25,"r":0.4210526316,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4578_c66cf607","label":3,"code":"\/**\r\n *  Returns if the component is stateless or not. It checks the stateless hint if that is false\r\n *  it returns directly false. If that is still true it checks all its behaviors if they can be\r\n *  stateless.\r\n *\r\n *  @return whether the component is stateless.\r\n *\/\r\npublic final boolean isStateless() {\r\n    if (!getStatelessHint()) {\r\n        return false;\r\n    }\r\n    if (\/\/ the component is either invisible or disabled\r\n    (isVisibleInHierarchy() && isEnabledInHierarchy()) == false && \/\/ and it can't call listener interfaces\r\n    canCallListenerInterface(null) == false) {\r\n        \/\/ then pretend the component is stateless\r\n        return true;\r\n    }\r\n    for (Behavior behavior : getBehaviors()) {\r\n        if (!behavior.getStatelessHint(this)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n *  Returns if the component is stateless or not. It checks the stateless hint if that is false\r\n *  it returns directly false. If that is still true it checks all its behaviors if they can be\r\n *  stateless.\r\n *\r\n *  @return whether the component is stateless.\r\n *\/\r\n","code_no_comment":"public final boolean isStateless() {\r\n    if (!getStatelessHint()) {\r\n        return false;\r\n    }\r\n    if (    (isVisibleInHierarchy() && isEnabledInHierarchy()) == false &&     canCallListenerInterface(null) == false) {\r\n                return true;\r\n    }\r\n    for (Behavior behavior : getBehaviors()) {\r\n        if (!behavior.getStatelessHint(this)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}","lc":0.0909090909,"pi":0.004784689,"ma":0.2,"nbd":0.0,"ml":0.4166666667,"d":-0.0674603175,"mi":0.0133897111,"fo":0.0,"r":0.5526315789,"e":-0.0979489751}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3847_de9399f3","label":3,"code":"@SuppressWarnings(\"unchecked\")\r\nprotected Object doConvertTo(final Class type, final Exchange exchange, final Object value) {\r\n    if (log.isTraceEnabled()) {\r\n        log.trace(\"Converting {} -> {} with value: {}\", new Object[] { value == null ? \"null\" : value.getClass().getCanonicalName(), type.getCanonicalName(), value });\r\n    }\r\n    if (value == null) {\r\n        \/\/ lets avoid NullPointerException when converting to boolean for null values\r\n        if (boolean.class.isAssignableFrom(type)) {\r\n            return Boolean.FALSE;\r\n        }\r\n        return null;\r\n    }\r\n    \/\/ same instance type\r\n    if (type.isInstance(value)) {\r\n        return type.cast(value);\r\n    }\r\n    \/\/ check if we have tried it before and if its a miss\r\n    TypeMapping key = new TypeMapping(type, value.getClass());\r\n    if (misses.containsKey(key)) {\r\n        \/\/ we have tried before but we cannot convert this one\r\n        return Void.TYPE;\r\n    }\r\n    \/\/ try to find a suitable type converter\r\n    TypeConverter converter = getOrFindTypeConverter(type, value);\r\n    if (converter != null) {\r\n        log.trace(\"Using converter: {} to convert {}\", converter, key);\r\n        Object rc = converter.convertTo(type, exchange, value);\r\n        if (rc != null) {\r\n            return rc;\r\n        }\r\n    }\r\n    \/\/ fallback converters\r\n    for (FallbackTypeConverter fallback : fallbackConverters) {\r\n        Object rc = fallback.getFallbackTypeConverter().convertTo(type, exchange, value);\r\n        if (Void.TYPE.equals(rc)) {\r\n            \/\/ it cannot be converted so give up\r\n            return Void.TYPE;\r\n        }\r\n        if (rc != null) {\r\n            \/\/ if fallback can promote then let it be promoted to a first class type converter\r\n            if (fallback.isCanPromote()) {\r\n                \/\/ add it as a known type converter since we found a fallback that could do it\r\n                if (log.isDebugEnabled()) {\r\n                    log.debug(\"Promoting fallback type converter as a known type converter to convert from: {} to: {} for the fallback converter: {}\", new Object[] { type.getCanonicalName(), value.getClass().getCanonicalName(), fallback.getFallbackTypeConverter() });\r\n                }\r\n                addTypeConverter(type, value.getClass(), fallback.getFallbackTypeConverter());\r\n            }\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"Fallback type converter {} converted type from: {} to: {}\", new Object[] { fallback.getFallbackTypeConverter(), type.getCanonicalName(), value.getClass().getCanonicalName() });\r\n            }\r\n            \/\/ return converted value\r\n            return rc;\r\n        }\r\n    }\r\n    \/\/ not found with that type then if it was a primitive type then try again with the wrapper type\r\n    if (type.isPrimitive()) {\r\n        Class primitiveType = ObjectHelper.convertPrimitiveTypeToWrapperType(type);\r\n        if (primitiveType != type) {\r\n            return convertTo(primitiveType, exchange, value);\r\n        }\r\n    }\r\n    \/\/ Could not find suitable conversion, so remember it\r\n    synchronized (misses) {\r\n        misses.put(key, key);\r\n    }\r\n    \/\/ Could not find suitable conversion, so return Void to indicate not found\r\n    return Void.TYPE;\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings(\"unchecked\")\r\nprotected Object doConvertTo(final Class type, final Exchange exchange, final Object value) {\r\n    if (log.isTraceEnabled()) {\r\n        log.trace(\"Converting {} -> {} with value: {}\", new Object[] { value == null ? \"null\" : value.getClass().getCanonicalName(), type.getCanonicalName(), value });\r\n    }\r\n    if (value == null) {\r\n                if (boolean.class.isAssignableFrom(type)) {\r\n            return Boolean.FALSE;\r\n        }\r\n        return null;\r\n    }\r\n        if (type.isInstance(value)) {\r\n        return type.cast(value);\r\n    }\r\n        TypeMapping key = new TypeMapping(type, value.getClass());\r\n    if (misses.containsKey(key)) {\r\n                return Void.TYPE;\r\n    }\r\n        TypeConverter converter = getOrFindTypeConverter(type, value);\r\n    if (converter != null) {\r\n        log.trace(\"Using converter: {} to convert {}\", converter, key);\r\n        Object rc = converter.convertTo(type, exchange, value);\r\n        if (rc != null) {\r\n            return rc;\r\n        }\r\n    }\r\n        for (FallbackTypeConverter fallback : fallbackConverters) {\r\n        Object rc = fallback.getFallbackTypeConverter().convertTo(type, exchange, value);\r\n        if (Void.TYPE.equals(rc)) {\r\n                        return Void.TYPE;\r\n        }\r\n        if (rc != null) {\r\n                        if (fallback.isCanPromote()) {\r\n                                if (log.isDebugEnabled()) {\r\n                    log.debug(\"Promoting fallback type converter as a known type converter to convert from: {} to: {} for the fallback converter: {}\", new Object[] { type.getCanonicalName(), value.getClass().getCanonicalName(), fallback.getFallbackTypeConverter() });\r\n                }\r\n                addTypeConverter(type, value.getClass(), fallback.getFallbackTypeConverter());\r\n            }\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"Fallback type converter {} converted type from: {} to: {}\", new Object[] { fallback.getFallbackTypeConverter(), type.getCanonicalName(), value.getClass().getCanonicalName() });\r\n            }\r\n                        return rc;\r\n        }\r\n    }\r\n        if (type.isPrimitive()) {\r\n        Class primitiveType = ObjectHelper.convertPrimitiveTypeToWrapperType(type);\r\n        if (primitiveType != type) {\r\n            return convertTo(primitiveType, exchange, value);\r\n        }\r\n    }\r\n        synchronized (misses) {\r\n        misses.put(key, key);\r\n    }\r\n        return Void.TYPE;\r\n}","lc":1.8636363636,"pi":0.6411483254,"ma":2.6,"nbd":1.0,"ml":2.0,"d":0.2142857143,"mi":-0.9596899225,"fo":2.5,"r":-0.0263157895,"e":1.0478403439}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-843_65390f8c","label":3,"code":"@Override\r\npublic Set<Range> splitRangeByTablets(String tableName, Range range, int maxSplits) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n    return Collections.singleton(range);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Set<Range> splitRangeByTablets(String tableName, Range range, int maxSplits) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n    return Collections.singleton(range);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7355884426,"fo":-0.4166666667,"r":0.0,"e":-0.1627934049}
{"project_name":"Lang","project_version":"35","label":1,"code":"\/**\r\n * <p>Copies the given array and adds the given element at the end of the new array.<\/p>\r\n *\r\n * <p>The new array contains the same elements of the input\r\n * array plus the given element in the last position. The component type of\r\n * the new array is the same as that of the input array.<\/p>\r\n *\r\n * <p>If the input array is <code>null<\/code>, a new one element array is returned\r\n *  whose component type is the same as the element, unless the element itself is null,\r\n *  in which case the return type is Object[]<\/p>\r\n *\r\n * <pre>\r\n * ArrayUtils.add(null, null)      = [null]\r\n * ArrayUtils.add(null, \"a\")       = [\"a\"]\r\n * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\r\n * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\r\n * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\r\n * <\/pre>\r\n *\r\n * @param array  the array to \"add\" the element to, may be <code>null<\/code>\r\n * @param element  the object to add, may be <code>null<\/code>\r\n * @return A new array containing the existing elements plus the new element\r\n * The returned array type will be that of the input array (unless null),\r\n * in which case it will have the same type as the element.\r\n * If both are null, an IllegalArgumentException is thrown\r\n * @since 2.1\r\n * @throws IllegalArgumentException if both arguments are null\r\n *\/\r\npublic static <T> T[] add(T[] array, T element) {\r\n    Class<?> type;\r\n    if (array != null) {\r\n        type = array.getClass();\r\n    } else if (element != null) {\r\n        type = element.getClass();\r\n    } else {\r\n        type = Object.class;\r\n    }\r\n    \/\/ type must be T\r\n    @SuppressWarnings(\"unchecked\")\r\n    T[] newArray = (T[]) copyArrayGrow1(array, type);\r\n    newArray[newArray.length - 1] = element;\r\n    return newArray;\r\n}","code_comment":"\/**\r\n * <p>Copies the given array and adds the given element at the end of the new array.<\/p>\r\n *\r\n * <p>The new array contains the same elements of the input\r\n * array plus the given element in the last position. The component type of\r\n * the new array is the same as that of the input array.<\/p>\r\n *\r\n * <p>If the input array is <code>null<\/code>, a new one element array is returned\r\n *  whose component type is the same as the element, unless the element itself is null,\r\n *  in which case the return type is Object[]<\/p>\r\n *\r\n * <pre>\r\n * ArrayUtils.add(null, null)      = [null]\r\n * ArrayUtils.add(null, \"a\")       = [\"a\"]\r\n * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\r\n * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\r\n * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\r\n * <\/pre>\r\n *\r\n * @param array  the array to \"add\" the element to, may be <code>null<\/code>\r\n * @param element  the object to add, may be <code>null<\/code>\r\n * @return A new array containing the existing elements plus the new element\r\n * The returned array type will be that of the input array (unless null),\r\n * in which case it will have the same type as the element.\r\n * If both are null, an IllegalArgumentException is thrown\r\n * @since 2.1\r\n * @throws IllegalArgumentException if both arguments are null\r\n *\/\r\n","code_no_comment":"public static <T> T[] add(T[] array, T element) {\r\n    Class<?> type;\r\n    if (array != null) {\r\n        type = array.getClass();\r\n    } else if (element != null) {\r\n        type = element.getClass();\r\n    } else {\r\n        type = Object.class;\r\n    }\r\n        @SuppressWarnings(\"unchecked\")\r\n    T[] newArray = (T[]) copyArrayGrow1(array, type);\r\n    newArray[newArray.length - 1] = element;\r\n    return newArray;\r\n}","lc":0.0,"pi":-0.2966507177,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":0.0813492063,"mi":-0.0136715997,"fo":-0.25,"r":-0.0263157895,"e":0.0310898267}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1058_4ebd967c","label":3,"code":"\/**\r\n * Returns the regularized beta function I(x, a, b).\r\n *\r\n * The implementation of this method is based on:\r\n * <ul>\r\n * <li>\r\n * <a href=\"http:\/\/mathworld.wolfram.com\/RegularizedBetaFunction.html\">\r\n * Regularized Beta Function<\/a>.<\/li>\r\n * <li>\r\n * <a href=\"http:\/\/functions.wolfram.com\/06.21.10.0001.01\">\r\n * Regularized Beta Function<\/a>.<\/li>\r\n * <\/ul>\r\n *\r\n * @param x the value.\r\n * @param a Parameter {@code a}.\r\n * @param b Parameter {@code b}.\r\n * @param epsilon When the absolute value of the nth item in the\r\n * series is less than epsilon the approximation ceases to calculate\r\n * further elements in the series.\r\n * @param maxIterations Maximum number of \"iterations\" to complete.\r\n * @return the regularized beta function I(x, a, b)\r\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\r\n * if the algorithm fails to converge.\r\n *\/\r\npublic static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {\r\n    double ret;\r\n    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0.0 || b <= 0.0) {\r\n        ret = Double.NaN;\r\n    } else if (x > (a + 1.0) \/ (a + b + 2.0)) {\r\n        ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\r\n    } else {\r\n        ContinuedFraction fraction = new ContinuedFraction() {\r\n\r\n            @Override\r\n            protected double getB(int n, double x) {\r\n                double ret;\r\n                double m;\r\n                if (n % 2 == 0) {\r\n                    \/\/ even\r\n                    m = n \/ 2.0;\r\n                    ret = (m * (b - m) * x) \/ ((a + (2 * m) - 1) * (a + (2 * m)));\r\n                } else {\r\n                    m = (n - 1.0) \/ 2.0;\r\n                    ret = -((a + m) * (a + b + m) * x) \/ ((a + (2 * m)) * (a + (2 * m) + 1.0));\r\n                }\r\n                return ret;\r\n            }\r\n\r\n            @Override\r\n            protected double getA(int n, double x) {\r\n                return 1.0;\r\n            }\r\n        };\r\n        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 \/ fraction.evaluate(x, epsilon, maxIterations);\r\n    }\r\n    return ret;\r\n}","code_comment":"\/**\r\n * Returns the regularized beta function I(x, a, b).\r\n *\r\n * The implementation of this method is based on:\r\n * <ul>\r\n * <li>\r\n * <a href=\"http:\/\/mathworld.wolfram.com\/RegularizedBetaFunction.html\">\r\n * Regularized Beta Function<\/a>.<\/li>\r\n * <li>\r\n * <a href=\"http:\/\/functions.wolfram.com\/06.21.10.0001.01\">\r\n * Regularized Beta Function<\/a>.<\/li>\r\n * <\/ul>\r\n *\r\n * @param x the value.\r\n * @param a Parameter {@code a}.\r\n * @param b Parameter {@code b}.\r\n * @param epsilon When the absolute value of the nth item in the\r\n * series is less than epsilon the approximation ceases to calculate\r\n * further elements in the series.\r\n * @param maxIterations Maximum number of \"iterations\" to complete.\r\n * @return the regularized beta function I(x, a, b)\r\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\r\n * if the algorithm fails to converge.\r\n *\/\r\n","code_no_comment":"public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {\r\n    double ret;\r\n    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0.0 || b <= 0.0) {\r\n        ret = Double.NaN;\r\n    } else if (x > (a + 1.0) \/ (a + b + 2.0)) {\r\n        ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\r\n    } else {\r\n        ContinuedFraction fraction = new ContinuedFraction() {\r\n\r\n            @Override\r\n            protected double getB(int n, double x) {\r\n                double ret;\r\n                double m;\r\n                if (n % 2 == 0) {\r\n                                        m = n \/ 2.0;\r\n                    ret = (m * (b - m) * x) \/ ((a + (2 * m) - 1) * (a + (2 * m)));\r\n                } else {\r\n                    m = (n - 1.0) \/ 2.0;\r\n                    ret = -((a + m) * (a + b + m) * x) \/ ((a + (2 * m)) * (a + (2 * m) + 1.0));\r\n                }\r\n                return ret;\r\n            }\r\n\r\n            @Override\r\n            protected double getA(int n, double x) {\r\n                return 1.0;\r\n            }\r\n        };\r\n        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 \/ fraction.evaluate(x, epsilon, maxIterations);\r\n    }\r\n    return ret;\r\n}","lc":0.7272727273,"pi":1.4497607656,"ma":0.0,"nbd":1.0,"ml":0.9166666667,"d":3.7063492063,"mi":-0.6019732206,"fo":0.3333333333,"r":-0.0263157895,"e":8.5461800453}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"\/**\r\n *  Static utility to parse a field of type short from a byte sequence that represents text characters\r\n *  (such as when read from a file stream).\r\n *\r\n *  @param bytes The bytes containing the text data that should be parsed.\r\n *  @param startPos The offset to start the parsing.\r\n *  @param length The length of the byte sequence (counting from the offset).\r\n *  @param delimiter The delimiter that terminates the field.\r\n *\r\n *  @return The parsed value.\r\n *\r\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\r\n *\/\r\npublic static final short parseField(byte[] bytes, int startPos, int length, char delimiter) {\r\n    if (length <= 0) {\r\n        throw new NumberFormatException(\"Invalid input: Empty string\");\r\n    }\r\n    long val = 0;\r\n    boolean neg = false;\r\n    if (bytes[startPos] == '-') {\r\n        neg = true;\r\n        startPos++;\r\n        length--;\r\n        if (length == 0 || bytes[startPos] == delimiter) {\r\n            throw new NumberFormatException(\"Orphaned minus sign.\");\r\n        }\r\n    }\r\n    for (; length > 0; startPos++, length--) {\r\n        if (bytes[startPos] == delimiter) {\r\n            return (short) (neg ? -val : val);\r\n        }\r\n        if (bytes[startPos] < 48 || bytes[startPos] > 57) {\r\n            throw new NumberFormatException(\"Invalid character.\");\r\n        }\r\n        val *= 10;\r\n        val += bytes[startPos] - 48;\r\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\r\n            throw new NumberFormatException(\"Value overflow\/underflow\");\r\n        }\r\n    }\r\n    return (short) (neg ? -val : val);\r\n}","code_comment":"\/**\r\n *  Static utility to parse a field of type short from a byte sequence that represents text characters\r\n *  (such as when read from a file stream).\r\n *\r\n *  @param bytes The bytes containing the text data that should be parsed.\r\n *  @param startPos The offset to start the parsing.\r\n *  @param length The length of the byte sequence (counting from the offset).\r\n *  @param delimiter The delimiter that terminates the field.\r\n *\r\n *  @return The parsed value.\r\n *\r\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\r\n *\/\r\n","code_no_comment":"public static final short parseField(byte[] bytes, int startPos, int length, char delimiter) {\r\n    if (length <= 0) {\r\n        throw new NumberFormatException(\"Invalid input: Empty string\");\r\n    }\r\n    long val = 0;\r\n    boolean neg = false;\r\n    if (bytes[startPos] == '-') {\r\n        neg = true;\r\n        startPos++;\r\n        length--;\r\n        if (length == 0 || bytes[startPos] == delimiter) {\r\n            throw new NumberFormatException(\"Orphaned minus sign.\");\r\n        }\r\n    }\r\n    for (; length > 0; startPos++, length--) {\r\n        if (bytes[startPos] == delimiter) {\r\n            return (short) (neg ? -val : val);\r\n        }\r\n        if (bytes[startPos] < 48 || bytes[startPos] > 57) {\r\n            throw new NumberFormatException(\"Invalid character.\");\r\n        }\r\n        val *= 10;\r\n        val += bytes[startPos] - 48;\r\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\r\n            throw new NumberFormatException(\"Value overflow\/underflow\");\r\n        }\r\n    }\r\n    return (short) (neg ? -val : val);\r\n}","lc":0.6818181818,"pi":0.0861244019,"ma":2.0,"nbd":0.0,"ml":1.0,"d":2.9900793651,"mi":-0.5484143763,"fo":-0.5,"r":-0.0263157895,"e":3.3959740207}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-531_90c45a02","label":1,"code":"@Nonnull\r\nprivate MutableNodeState write(long newRevision, boolean skipRemovedCheck) {\r\n    \/\/ make sure that all revision numbers up to the root gets updated\r\n    if (!isRoot()) {\r\n        checkState(skipRemovedCheck || !parent.removed(name));\r\n        parent.write(newRevision, skipRemovedCheck);\r\n    }\r\n    if (writeState == null || revision != root.revision) {\r\n        \/\/ root never gets here since revision == root.revision\r\n        assert (!isRoot());\r\n        \/\/ The builder could have been reset, need to re-get base state\r\n        baseState = parent.getBaseState(name);\r\n        writeState = parent.getWriteState(name);\r\n        if (writeState == null) {\r\n            if (parent.removed(name)) {\r\n                writeState = new MutableNodeState(null);\r\n            } else {\r\n                writeState = new MutableNodeState(baseState);\r\n            }\r\n            \/\/ guaranteed by called parent.write()\r\n            assert parent.writeState != null;\r\n            parent.writeState.nodes.put(name, writeState);\r\n        }\r\n    }\r\n    revision = newRevision;\r\n    assert classInvariants();\r\n    assert writeState != null;\r\n    return writeState;\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\nprivate MutableNodeState write(long newRevision, boolean skipRemovedCheck) {\r\n        if (!isRoot()) {\r\n        checkState(skipRemovedCheck || !parent.removed(name));\r\n        parent.write(newRevision, skipRemovedCheck);\r\n    }\r\n    if (writeState == null || revision != root.revision) {\r\n                assert (!isRoot());\r\n                baseState = parent.getBaseState(name);\r\n        writeState = parent.getWriteState(name);\r\n        if (writeState == null) {\r\n            if (parent.removed(name)) {\r\n                writeState = new MutableNodeState(null);\r\n            } else {\r\n                writeState = new MutableNodeState(baseState);\r\n            }\r\n                        assert parent.writeState != null;\r\n            parent.writeState.nodes.put(name, writeState);\r\n        }\r\n    }\r\n    revision = newRevision;\r\n    assert classInvariants();\r\n    assert writeState != null;\r\n    return writeState;\r\n}","lc":0.5,"pi":0.7368421053,"ma":0.2,"nbd":0.5,"ml":0.5,"d":-0.3650793651,"mi":0.0734319944,"fo":0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7448_35bde2b2","label":3,"code":"\/\/ Implementation methods\r\n\/\/ -----------------------------------------------------------------------\r\nprotected long calculateDelay(Exchange exchange) {\r\n    \/\/ evaluate as Object first to see if we get any result at all\r\n    Object result = maxRequestsPerPeriodExpression.evaluate(exchange, Object.class);\r\n    if (result == null) {\r\n        throw new RuntimeExchangeException(\"The max requests per period expression was evaluated as null: \" + maxRequestsPerPeriodExpression, exchange);\r\n    }\r\n    \/\/ then must convert value to long\r\n    Long longValue = exchange.getContext().getTypeConverter().convertTo(Long.class, result);\r\n    if (longValue != null) {\r\n        \/\/ log if we changed max period after initial setting\r\n        if (maximumRequestsPerPeriod > 0 && longValue.longValue() != maximumRequestsPerPeriod) {\r\n            log.debug(\"Throttler changed maximum requests per period from {} to {}\", maximumRequestsPerPeriod, longValue);\r\n        }\r\n        if (maximumRequestsPerPeriod > longValue) {\r\n            slot.capacity = 0;\r\n        }\r\n        maximumRequestsPerPeriod = longValue;\r\n    }\r\n    if (maximumRequestsPerPeriod <= 0) {\r\n        throw new IllegalStateException(\"The maximumRequestsPerPeriod must be a positive number, was: \" + maximumRequestsPerPeriod);\r\n    }\r\n    TimeSlot slot = nextSlot();\r\n    if (!slot.isActive()) {\r\n        long delay = slot.startTime - currentSystemTime();\r\n        return delay;\r\n    } else {\r\n        return 0;\r\n    }\r\n}","code_comment":null,"code_no_comment":"protected long calculateDelay(Exchange exchange) {\r\n        Object result = maxRequestsPerPeriodExpression.evaluate(exchange, Object.class);\r\n    if (result == null) {\r\n        throw new RuntimeExchangeException(\"The max requests per period expression was evaluated as null: \" + maxRequestsPerPeriodExpression, exchange);\r\n    }\r\n        Long longValue = exchange.getContext().getTypeConverter().convertTo(Long.class, result);\r\n    if (longValue != null) {\r\n                if (maximumRequestsPerPeriod > 0 && longValue.longValue() != maximumRequestsPerPeriod) {\r\n            log.debug(\"Throttler changed maximum requests per period from {} to {}\", maximumRequestsPerPeriod, longValue);\r\n        }\r\n        if (maximumRequestsPerPeriod > longValue) {\r\n            slot.capacity = 0;\r\n        }\r\n        maximumRequestsPerPeriod = longValue;\r\n    }\r\n    if (maximumRequestsPerPeriod <= 0) {\r\n        throw new IllegalStateException(\"The maximumRequestsPerPeriod must be a positive number, was: \" + maximumRequestsPerPeriod);\r\n    }\r\n    TimeSlot slot = nextSlot();\r\n    if (!slot.isActive()) {\r\n        long delay = slot.startTime - currentSystemTime();\r\n        return delay;\r\n    } else {\r\n        return 0;\r\n    }\r\n}","lc":0.5454545455,"pi":-0.004784689,"ma":1.0,"nbd":0.0,"ml":0.5833333333,"d":1.1448412698,"mi":-0.4483439042,"fo":0.25,"r":-0.0263157895,"e":1.2568039972}
{"project_name":"Closure","project_version":"151","label":2,"code":"private void initConfigFromFlags(String[] args, PrintStream err) {\r\n    \/\/ Args4j has a different format that the old command-line parser.\r\n    \/\/ So we use some voodoo to get the args into the format that args4j\r\n    \/\/ expects.\r\n    Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\r\n    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\r\n    List<String> processedArgs = Lists.newArrayList();\r\n    for (String arg : args) {\r\n        Matcher matcher = argPattern.matcher(arg);\r\n        if (matcher.matches()) {\r\n            processedArgs.add(matcher.group(1));\r\n            String value = matcher.group(2);\r\n            Matcher quotesMatcher = quotesPattern.matcher(value);\r\n            if (quotesMatcher.matches()) {\r\n                processedArgs.add(quotesMatcher.group(1));\r\n            } else {\r\n                processedArgs.add(value);\r\n            }\r\n        } else {\r\n            processedArgs.add(arg);\r\n        }\r\n    }\r\n    CmdLineParser parser = new CmdLineParser(flags);\r\n    isConfigValid = true;\r\n    try {\r\n        parser.parseArgument(processedArgs.toArray(new String[] {}));\r\n    } catch (CmdLineException e) {\r\n        err.println(e.getMessage());\r\n        isConfigValid = false;\r\n    }\r\n    if (!isConfigValid || flags.display_help) {\r\n        isConfigValid = false;\r\n        parser.printUsage(err);\r\n    } else {\r\n        getCommandLineConfig().setPrintTree(flags.print_tree).setComputePhaseOrdering(flags.compute_phase_ordering).setPrintAst(flags.print_ast).setPrintPassGraph(flags.print_pass_graph).setJscompDevMode(flags.jscomp_dev_mode).setLoggingLevel(flags.logging_level).setExterns(flags.externs).setJs(flags.js).setJsOutputFile(flags.js_output_file).setModule(flags.module).setVariableMapInputFile(flags.variable_map_input_file).setPropertyMapInputFile(flags.property_map_input_file).setVariableMapOutputFile(flags.variable_map_output_file).setCreateNameMapFiles(flags.create_name_map_files).setPropertyMapOutputFile(flags.property_map_output_file).setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()).setSummaryDetailLevel(flags.summary_detail_level).setOutputWrapper(flags.output_wrapper).setOutputWrapperMarker(flags.output_wrapper_marker).setModuleWrapper(flags.module_wrapper).setModuleOutputPathPrefix(flags.module_output_path_prefix).setCreateSourceMap(flags.create_source_map).setJscompError(flags.jscomp_error).setJscompWarning(flags.jscomp_warning).setJscompOff(flags.jscomp_off).setDefine(flags.define).setCharset(flags.charset).setManageClosureDependencies(flags.manage_closure_dependencies).setOutputManifest(flags.output_manifest);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void initConfigFromFlags(String[] args, PrintStream err) {\r\n                Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\r\n    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\r\n    List<String> processedArgs = Lists.newArrayList();\r\n    for (String arg : args) {\r\n        Matcher matcher = argPattern.matcher(arg);\r\n        if (matcher.matches()) {\r\n            processedArgs.add(matcher.group(1));\r\n            String value = matcher.group(2);\r\n            Matcher quotesMatcher = quotesPattern.matcher(value);\r\n            if (quotesMatcher.matches()) {\r\n                processedArgs.add(quotesMatcher.group(1));\r\n            } else {\r\n                processedArgs.add(value);\r\n            }\r\n        } else {\r\n            processedArgs.add(arg);\r\n        }\r\n    }\r\n    CmdLineParser parser = new CmdLineParser(flags);\r\n    isConfigValid = true;\r\n    try {\r\n        parser.parseArgument(processedArgs.toArray(new String[] {}));\r\n    } catch (CmdLineException e) {\r\n        err.println(e.getMessage());\r\n        isConfigValid = false;\r\n    }\r\n    if (!isConfigValid || flags.display_help) {\r\n        isConfigValid = false;\r\n        parser.printUsage(err);\r\n    } else {\r\n        getCommandLineConfig().setPrintTree(flags.print_tree).setComputePhaseOrdering(flags.compute_phase_ordering).setPrintAst(flags.print_ast).setPrintPassGraph(flags.print_pass_graph).setJscompDevMode(flags.jscomp_dev_mode).setLoggingLevel(flags.logging_level).setExterns(flags.externs).setJs(flags.js).setJsOutputFile(flags.js_output_file).setModule(flags.module).setVariableMapInputFile(flags.variable_map_input_file).setPropertyMapInputFile(flags.property_map_input_file).setVariableMapOutputFile(flags.variable_map_output_file).setCreateNameMapFiles(flags.create_name_map_files).setPropertyMapOutputFile(flags.property_map_output_file).setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()).setSummaryDetailLevel(flags.summary_detail_level).setOutputWrapper(flags.output_wrapper).setOutputWrapperMarker(flags.output_wrapper_marker).setModuleWrapper(flags.module_wrapper).setModuleOutputPathPrefix(flags.module_output_path_prefix).setCreateSourceMap(flags.create_source_map).setJscompError(flags.jscomp_error).setJscompWarning(flags.jscomp_warning).setJscompOff(flags.jscomp_off).setDefine(flags.define).setCharset(flags.charset).setManageClosureDependencies(flags.manage_closure_dependencies).setOutputManifest(flags.output_manifest);\r\n    }\r\n}","lc":0.9090909091,"pi":0.5071770335,"ma":0.6,"nbd":0.5,"ml":0.4166666667,"d":-0.0198412698,"mi":-0.7245947851,"fo":3.5833333333,"r":-0.0263157895,"e":0.849217683}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-393_d4b02f6a","label":3,"code":"\/**\r\n * Get the maximal number of functions evaluations.\r\n * @return maximal number of functions evaluations\r\n *\/\r\nint getMaxEvaluations();","code_comment":"\/**\r\n * Get the maximal number of functions evaluations.\r\n * @return maximal number of functions evaluations\r\n *\/\r\n","code_no_comment":"int getMaxEvaluations();","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.8696264975,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4138_50db442b","label":1,"code":"@Override\r\npublic Options getOptions() {\r\n    final Options o = new Options();\r\n    verboseOpt = new Option(\"v\", \"verbose\", false, \"verbose output during merge\");\r\n    sizeOpt = new Option(\"s\", \"size\", true, \"merge tablets to the given size over the entire table\");\r\n    forceOpt = new Option(\"f\", \"force\", false, \"merge small tablets to large tablets, even if it goes over the given size\");\r\n    allOpt = new Option(\"\", \"all\", false, \"allow an entire table to be merged into one tablet without prompting the user for confirmation\");\r\n    Option startRowOpt = OptUtil.startRowOpt();\r\n    startRowOpt.setDescription(\"begin row (NOT inclusive)\");\r\n    o.addOption(startRowOpt);\r\n    o.addOption(OptUtil.endRowOpt());\r\n    o.addOption(OptUtil.tableOpt(\"table to be merged\"));\r\n    o.addOption(verboseOpt);\r\n    o.addOption(sizeOpt);\r\n    o.addOption(forceOpt);\r\n    o.addOption(allOpt);\r\n    return o;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Options getOptions() {\r\n    final Options o = new Options();\r\n    verboseOpt = new Option(\"v\", \"verbose\", false, \"verbose output during merge\");\r\n    sizeOpt = new Option(\"s\", \"size\", true, \"merge tablets to the given size over the entire table\");\r\n    forceOpt = new Option(\"f\", \"force\", false, \"merge small tablets to large tablets, even if it goes over the given size\");\r\n    allOpt = new Option(\"\", \"all\", false, \"allow an entire table to be merged into one tablet without prompting the user for confirmation\");\r\n    Option startRowOpt = OptUtil.startRowOpt();\r\n    startRowOpt.setDescription(\"begin row (NOT inclusive)\");\r\n    o.addOption(startRowOpt);\r\n    o.addOption(OptUtil.endRowOpt());\r\n    o.addOption(OptUtil.tableOpt(\"table to be merged\"));\r\n    o.addOption(verboseOpt);\r\n    o.addOption(sizeOpt);\r\n    o.addOption(forceOpt);\r\n    o.addOption(allOpt);\r\n    return o;\r\n}","lc":0.1818181818,"pi":-0.7177033493,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.2067653277,"fo":0.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Closure","project_version":"71","label":2,"code":"\/**\r\n * Determines whether the given property is visible in the current context.\r\n * @param t The current traversal.\r\n * @param getprop The getprop node.\r\n *\/\r\nprivate void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\r\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\r\n    String propertyName = getprop.getLastChild().getString();\r\n    if (objectType != null) {\r\n        \/\/ Is this a normal property access, or are we trying to override\r\n        \/\/ an existing property?\r\n        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\r\n        \/\/ information.\r\n        if (isOverride) {\r\n            objectType = objectType.getImplicitPrototype();\r\n        }\r\n        JSDocInfo docInfo = null;\r\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\r\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\r\n            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\r\n                break;\r\n            }\r\n        }\r\n        if (objectType == null) {\r\n            \/\/ We couldn't find a visibility modifier; assume it's public.\r\n            return;\r\n        }\r\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\r\n        Visibility visibility = docInfo.getVisibility();\r\n        JSType ownerType = normalizeClassType(objectType);\r\n        if (isOverride) {\r\n            \/\/ Check an ASSIGN statement that's trying to override a property\r\n            \/\/ on a superclass.\r\n            JSDocInfo overridingInfo = parent.getJSDocInfo();\r\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\r\n            \/\/ visibility of the original property.\r\n            if (visibility == Visibility.PRIVATE && !sameInput) {\r\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\r\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\r\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\r\n            }\r\n        } else {\r\n            if (sameInput) {\r\n                \/\/ private access is always allowed in the same file.\r\n                return;\r\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\r\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\r\n                    return;\r\n                }\r\n                \/\/ private access is not allowed outside the file from a different\r\n                \/\/ enclosing class.\r\n                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\r\n            } else if (visibility == Visibility.PROTECTED) {\r\n                \/\/ The first two have already been checked for.\r\n                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\r\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Determines whether the given property is visible in the current context.\r\n * @param t The current traversal.\r\n * @param getprop The getprop node.\r\n *\/\r\n","code_no_comment":"private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\r\n    ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\r\n    String propertyName = getprop.getLastChild().getString();\r\n    if (objectType != null) {\r\n                        boolean isOverride = t.inGlobalScope() && parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\r\n                if (isOverride) {\r\n            objectType = objectType.getImplicitPrototype();\r\n        }\r\n        JSDocInfo docInfo = null;\r\n        for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\r\n            docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\r\n            if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\r\n                break;\r\n            }\r\n        }\r\n        if (objectType == null) {\r\n                        return;\r\n        }\r\n        boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\r\n        Visibility visibility = docInfo.getVisibility();\r\n        JSType ownerType = normalizeClassType(objectType);\r\n        if (isOverride) {\r\n                                    JSDocInfo overridingInfo = parent.getJSDocInfo();\r\n            Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility();\r\n                        if (visibility == Visibility.PRIVATE && !sameInput) {\r\n                compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\r\n            } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\r\n                compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name()));\r\n            }\r\n        } else {\r\n            if (sameInput) {\r\n                                return;\r\n            } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) {\r\n                if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\r\n                    return;\r\n                }\r\n                                                compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\r\n            } else if (visibility == Visibility.PROTECTED) {\r\n                                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\r\n                    compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","lc":1.4090909091,"pi":0.7799043062,"ma":2.4,"nbd":2.0,"ml":2.5833333333,"d":1.1865079365,"mi":-0.903030303,"fo":2.9166666667,"r":-0.0263157895,"e":4.1454124237}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4029_5ca779a0","label":1,"code":"@Override\r\npublic int hashCode() {\r\n    return toThrift(false).hashCode();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int hashCode() {\r\n    return toThrift(false).hashCode();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9517970402,"fo":-0.3333333333,"r":1.6315789474,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3897_699b8bf0","label":3,"code":"@Override\r\npublic long isReady(long tid, Master master) throws Exception {\r\n    \/\/ suppress assignment of tablets to the server\r\n    if (force) {\r\n        return 0;\r\n    }\r\n    \/\/ only send this request once\r\n    if (!requestedShutdown) {\r\n        master.shutdownTServer(server);\r\n    }\r\n    if (master.onlineTabletServers().contains(server)) {\r\n        TServerConnection connection = master.getConnection(server);\r\n        if (connection != null) {\r\n            try {\r\n                TabletServerStatus status = connection.getTableMap(false);\r\n                if (status.tableMap != null && status.tableMap.isEmpty()) {\r\n                    log.info(\"tablet server hosts no tablets \" + server);\r\n                    connection.halt(master.getMasterLock());\r\n                    log.info(\"tablet server asked to halt \" + server);\r\n                    return 0;\r\n                }\r\n            } catch (TTransportException ex) {\r\n            \/\/ expected\r\n            } catch (Exception ex) {\r\n                log.error(\"Error talking to tablet server \" + server + \": \" + ex);\r\n            }\r\n            \/\/ tserver to ack the request and stop itself.\r\n            return 1000;\r\n        }\r\n    }\r\n    return 0;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic long isReady(long tid, Master master) throws Exception {\r\n        if (force) {\r\n        return 0;\r\n    }\r\n        if (!requestedShutdown) {\r\n        master.shutdownTServer(server);\r\n    }\r\n    if (master.onlineTabletServers().contains(server)) {\r\n        TServerConnection connection = master.getConnection(server);\r\n        if (connection != null) {\r\n            try {\r\n                TabletServerStatus status = connection.getTableMap(false);\r\n                if (status.tableMap != null && status.tableMap.isEmpty()) {\r\n                    log.info(\"tablet server hosts no tablets \" + server);\r\n                    connection.halt(master.getMasterLock());\r\n                    log.info(\"tablet server asked to halt \" + server);\r\n                    return 0;\r\n                }\r\n            } catch (TTransportException ex) {\r\n                        } catch (Exception ex) {\r\n                log.error(\"Error talking to tablet server \" + server + \": \" + ex);\r\n            }\r\n                        return 1000;\r\n        }\r\n    }\r\n    return 0;\r\n}","lc":0.6363636364,"pi":1.6124401914,"ma":0.8,"nbd":1.0,"ml":0.6666666667,"d":0.2956349206,"mi":-0.4627202255,"fo":0.4166666667,"r":-0.0263157895,"e":0.4053111115}
{"project_name":"Closure","project_version":"103","label":2,"code":"\/**\r\n * Determines if the subtree might throw an exception.\r\n *\/\r\nprivate static boolean mayThrowException(Node n) {\r\n    switch(n.getType()) {\r\n        case Token.CALL:\r\n        case Token.GETPROP:\r\n        case Token.GETELEM:\r\n        case Token.THROW:\r\n        case Token.NEW:\r\n        case Token.ASSIGN:\r\n        case Token.INC:\r\n        case Token.DEC:\r\n            return true;\r\n        case Token.FUNCTION:\r\n            return false;\r\n    }\r\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\r\n        if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":"\/**\r\n * Determines if the subtree might throw an exception.\r\n *\/\r\n","code_no_comment":"private static boolean mayThrowException(Node n) {\r\n    switch(n.getType()) {\r\n        case Token.CALL:\r\n        case Token.GETPROP:\r\n        case Token.GETELEM:\r\n        case Token.THROW:\r\n        case Token.NEW:\r\n        case Token.ASSIGN:\r\n        case Token.INC:\r\n        case Token.DEC:\r\n            return true;\r\n        case Token.FUNCTION:\r\n            return false;\r\n    }\r\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\r\n        if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","lc":0.3181818182,"pi":0.1483253589,"ma":1.6,"nbd":0.0,"ml":0.9166666667,"d":0.3591269841,"mi":-0.2834390416,"fo":-0.0833333333,"r":0.0,"e":0.2134979225}
{"project_name":"Closure","project_version":"10","label":1,"code":"static boolean mayBeString(Node n, boolean recurse) {\r\n    if (recurse) {\r\n        return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\r\n    } else {\r\n        return mayBeStringHelper(n);\r\n    }\r\n}","code_comment":null,"code_no_comment":"static boolean mayBeString(Node n, boolean recurse) {\r\n    if (recurse) {\r\n        return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\r\n    } else {\r\n        return mayBeStringHelper(n);\r\n    }\r\n}","lc":-0.3181818182,"pi":0.014354067,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.563354475,"fo":-0.3333333333,"r":1.3684210526,"e":-0.1627934049}
{"project_name":"Closure","project_version":"108","label":2,"code":"private void findAliases(NodeTraversal t) {\r\n    Scope scope = t.getScope();\r\n    for (Var v : scope.getVarIterable()) {\r\n        Node n = v.getNode();\r\n        Node parent = n.getParent();\r\n        boolean isVar = parent.isVar();\r\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\r\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\r\n            recordAlias(v);\r\n        } else if (v.isBleedingFunction()) {\r\n        \/\/ Bleeding functions already get a BAD_PARAMETERS error, so just\r\n        \/\/ do nothing.\r\n        } else if (parent.getType() == Token.LP) {\r\n        \/\/ Parameters of the scope function also get a BAD_PARAMETERS\r\n        \/\/ error.\r\n        } else if (isVar || isFunctionDecl) {\r\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\r\n            Node grandparent = parent.getParent();\r\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\r\n            Node varNode = null;\r\n            String name = n.getString();\r\n            int nameCount = scopedAliasNames.count(name);\r\n            scopedAliasNames.add(name);\r\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\r\n            compiler.ensureLibraryInjected(\"base\");\r\n            \/\/ to be used in another expression.\r\n            if (isFunctionDecl) {\r\n                \/\/ Replace \"function NAME() { ... }\" with \"var NAME;\".\r\n                Node existingName = v.getNameNode();\r\n                \/\/ We can't keep the local name on the function expression,\r\n                \/\/ because IE is buggy and will leak the name into the global\r\n                \/\/ scope. This is covered in more detail here:\r\n                \/\/ http:\/\/wiki.ecmascript.org\/lib\/exe\/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\r\n                \/\/ \r\n                \/\/ This will only cause problems if this is a hoisted, recursive\r\n                \/\/ function, and the programmer is using the hoisting.\r\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\r\n                value.replaceChild(existingName, newName);\r\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\r\n                grandparent.replaceChild(parent, varNode);\r\n            } else {\r\n                if (value != null) {\r\n                    \/\/ If this is a VAR, we can just detach the expression and\r\n                    \/\/ the tree will still be valid.\r\n                    value.detachFromParent();\r\n                }\r\n                varNode = parent;\r\n            }\r\n            \/\/ Make sure we copy over all the jsdoc and debug info.\r\n            if (value != null || v.getJSDocInfo() != null) {\r\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\r\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\r\n                if (isHoisted) {\r\n                    grandparent.addChildToFront(newDecl);\r\n                } else {\r\n                    grandparent.addChildBefore(newDecl, varNode);\r\n                }\r\n            }\r\n            \/\/ Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\r\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\r\n            recordAlias(v);\r\n        } else {\r\n            \/\/ Do not other kinds of local symbols, like catch params.\r\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void findAliases(NodeTraversal t) {\r\n    Scope scope = t.getScope();\r\n    for (Var v : scope.getVarIterable()) {\r\n        Node n = v.getNode();\r\n        Node parent = n.getParent();\r\n        boolean isVar = parent.isVar();\r\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\r\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\r\n            recordAlias(v);\r\n        } else if (v.isBleedingFunction()) {\r\n                        } else if (parent.getType() == Token.LP) {\r\n                        } else if (isVar || isFunctionDecl) {\r\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\r\n            Node grandparent = parent.getParent();\r\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\r\n            Node varNode = null;\r\n            String name = n.getString();\r\n            int nameCount = scopedAliasNames.count(name);\r\n            scopedAliasNames.add(name);\r\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\r\n            compiler.ensureLibraryInjected(\"base\");\r\n                        if (isFunctionDecl) {\r\n                                Node existingName = v.getNameNode();\r\n                                                                                                                                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\r\n                value.replaceChild(existingName, newName);\r\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\r\n                grandparent.replaceChild(parent, varNode);\r\n            } else {\r\n                if (value != null) {\r\n                                                            value.detachFromParent();\r\n                }\r\n                varNode = parent;\r\n            }\r\n                        if (value != null || v.getJSDocInfo() != null) {\r\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\r\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\r\n                if (isHoisted) {\r\n                    grandparent.addChildToFront(newDecl);\r\n                } else {\r\n                    grandparent.addChildBefore(newDecl, varNode);\r\n                }\r\n            }\r\n                        v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\r\n            recordAlias(v);\r\n        } else {\r\n                        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\r\n        }\r\n    }\r\n}","lc":1.5909090909,"pi":0.7703349282,"ma":1.6,"nbd":2.5,"ml":1.6666666667,"d":1.126984127,"mi":-0.9199436223,"fo":3.25,"r":-0.0263157895,"e":4.0876310345}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2082_0cfa43d7","label":3,"code":"@Override\r\npublic void registerInputOutput() {\r\n    this.userClassLoader = getUserCodeClassLoader();\r\n    this.configuration = new StreamConfig(getTaskConfiguration());\r\n    this.context = createRuntimeContext(getEnvironment().getTaskName());\r\n    this.stateHandleProvider = getStateHandleProvider();\r\n    outputHandler = new OutputHandler<OUT>(this);\r\n    streamOperator = configuration.getStreamOperator(userClassLoader);\r\n    if (streamOperator != null) {\r\n        \/\/ IterationHead and IterationTail don't have an Operator...\r\n        streamOperator.setup(outputHandler.getOutput(), this.context);\r\n    }\r\n    hasChainedOperators = !outputHandler.getChainedOperators().isEmpty();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void registerInputOutput() {\r\n    this.userClassLoader = getUserCodeClassLoader();\r\n    this.configuration = new StreamConfig(getTaskConfiguration());\r\n    this.context = createRuntimeContext(getEnvironment().getTaskName());\r\n    this.stateHandleProvider = getStateHandleProvider();\r\n    outputHandler = new OutputHandler<OUT>(this);\r\n    streamOperator = configuration.getStreamOperator(userClassLoader);\r\n    if (streamOperator != null) {\r\n                streamOperator.setup(outputHandler.getOutput(), this.context);\r\n    }\r\n    hasChainedOperators = !outputHandler.getChainedOperators().isEmpty();\r\n}","lc":-0.0454545455,"pi":-0.4114832536,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1111111111,"mi":0.0187455955,"fo":0.4166666667,"r":0.0,"e":-0.0464791411}
{"project_name":"Math","project_version":"6","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected PointValuePair doOptimize() {\r\n    checkParameters();\r\n    final GoalType goal = getGoalType();\r\n    final double[] guess = getStartPoint();\r\n    final int n = guess.length;\r\n    final double[][] direc = new double[n][n];\r\n    for (int i = 0; i < n; i++) {\r\n        direc[i][i] = 1;\r\n    }\r\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\r\n    double[] x = guess;\r\n    double fVal = computeObjectiveValue(x);\r\n    double[] x1 = x.clone();\r\n    int iter = 0;\r\n    while (true) {\r\n        ++iter;\r\n        double fX = fVal;\r\n        double fX2 = 0;\r\n        double delta = 0;\r\n        int bigInd = 0;\r\n        double alphaMin = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            final double[] d = MathArrays.copyOf(direc[i]);\r\n            fX2 = fVal;\r\n            final UnivariatePointValuePair optimum = line.search(x, d);\r\n            fVal = optimum.getValue();\r\n            alphaMin = optimum.getPoint();\r\n            final double[][] result = newPointAndDirection(x, d, alphaMin);\r\n            x = result[0];\r\n            if ((fX2 - fVal) > delta) {\r\n                delta = fX2 - fVal;\r\n                bigInd = i;\r\n            }\r\n        }\r\n        \/\/ Default convergence check.\r\n        boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold);\r\n        final PointValuePair previous = new PointValuePair(x1, fX);\r\n        final PointValuePair current = new PointValuePair(x, fVal);\r\n        if (!stop) {\r\n            \/\/ User-defined stopping criteria.\r\n            if (checker != null) {\r\n                stop = checker.converged(iter, previous, current);\r\n            }\r\n        }\r\n        if (stop) {\r\n            if (goal == GoalType.MINIMIZE) {\r\n                return (fVal < fX) ? current : previous;\r\n            } else {\r\n                return (fVal > fX) ? current : previous;\r\n            }\r\n        }\r\n        final double[] d = new double[n];\r\n        final double[] x2 = new double[n];\r\n        for (int i = 0; i < n; i++) {\r\n            d[i] = x[i] - x1[i];\r\n            x2[i] = 2 * x[i] - x1[i];\r\n        }\r\n        x1 = x.clone();\r\n        fX2 = computeObjectiveValue(x2);\r\n        if (fX > fX2) {\r\n            double t = 2 * (fX + fX2 - 2 * fVal);\r\n            double temp = fX - fVal - delta;\r\n            t *= temp * temp;\r\n            temp = fX - fX2;\r\n            t -= delta * temp * temp;\r\n            if (t < 0.0) {\r\n                final UnivariatePointValuePair optimum = line.search(x, d);\r\n                fVal = optimum.getValue();\r\n                alphaMin = optimum.getPoint();\r\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\r\n                x = result[0];\r\n                final int lastInd = n - 1;\r\n                direc[bigInd] = direc[lastInd];\r\n                direc[lastInd] = result[1];\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected PointValuePair doOptimize() {\r\n    checkParameters();\r\n    final GoalType goal = getGoalType();\r\n    final double[] guess = getStartPoint();\r\n    final int n = guess.length;\r\n    final double[][] direc = new double[n][n];\r\n    for (int i = 0; i < n; i++) {\r\n        direc[i][i] = 1;\r\n    }\r\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\r\n    double[] x = guess;\r\n    double fVal = computeObjectiveValue(x);\r\n    double[] x1 = x.clone();\r\n    int iter = 0;\r\n    while (true) {\r\n        ++iter;\r\n        double fX = fVal;\r\n        double fX2 = 0;\r\n        double delta = 0;\r\n        int bigInd = 0;\r\n        double alphaMin = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            final double[] d = MathArrays.copyOf(direc[i]);\r\n            fX2 = fVal;\r\n            final UnivariatePointValuePair optimum = line.search(x, d);\r\n            fVal = optimum.getValue();\r\n            alphaMin = optimum.getPoint();\r\n            final double[][] result = newPointAndDirection(x, d, alphaMin);\r\n            x = result[0];\r\n            if ((fX2 - fVal) > delta) {\r\n                delta = fX2 - fVal;\r\n                bigInd = i;\r\n            }\r\n        }\r\n                boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold);\r\n        final PointValuePair previous = new PointValuePair(x1, fX);\r\n        final PointValuePair current = new PointValuePair(x, fVal);\r\n        if (!stop) {\r\n                        if (checker != null) {\r\n                stop = checker.converged(iter, previous, current);\r\n            }\r\n        }\r\n        if (stop) {\r\n            if (goal == GoalType.MINIMIZE) {\r\n                return (fVal < fX) ? current : previous;\r\n            } else {\r\n                return (fVal > fX) ? current : previous;\r\n            }\r\n        }\r\n        final double[] d = new double[n];\r\n        final double[] x2 = new double[n];\r\n        for (int i = 0; i < n; i++) {\r\n            d[i] = x[i] - x1[i];\r\n            x2[i] = 2 * x[i] - x1[i];\r\n        }\r\n        x1 = x.clone();\r\n        fX2 = computeObjectiveValue(x2);\r\n        if (fX > fX2) {\r\n            double t = 2 * (fX + fX2 - 2 * fVal);\r\n            double temp = fX - fVal - delta;\r\n            t *= temp * temp;\r\n            temp = fX - fX2;\r\n            t -= delta * temp * temp;\r\n            if (t < 0.0) {\r\n                final UnivariatePointValuePair optimum = line.search(x, d);\r\n                fVal = optimum.getValue();\r\n                alphaMin = optimum.getPoint();\r\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\r\n                x = result[0];\r\n                final int lastInd = n - 1;\r\n                direc[bigInd] = direc[lastInd];\r\n                direc[lastInd] = result[1];\r\n            }\r\n        }\r\n    }\r\n}","lc":2.8636363636,"pi":0.6411483254,"ma":2.0,"nbd":0.5,"ml":1.5,"d":4.0892857143,"mi":-1.2001409443,"fo":1.1666666667,"r":-0.0263157895,"e":19.0583911067}
{"project_name":"Csv","project_version":"8","label":1,"code":"\/**\r\n * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\r\n *\r\n * @throws IllegalStateException\r\n *\/\r\nvoid validate() throws IllegalStateException {\r\n    if (quoteChar != null && delimiter == quoteChar.charValue()) {\r\n        throw new IllegalStateException(\"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\r\n    }\r\n    if (escape != null && delimiter == escape.charValue()) {\r\n        throw new IllegalStateException(\"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\r\n    }\r\n    if (commentStart != null && delimiter == commentStart.charValue()) {\r\n        throw new IllegalStateException(\"The comment start character and the delimiter cannot be the same ('\" + commentStart + \"')\");\r\n    }\r\n    if (quoteChar != null && quoteChar.equals(commentStart)) {\r\n        throw new IllegalStateException(\"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \"')\");\r\n    }\r\n    if (escape != null && escape.equals(commentStart)) {\r\n        throw new IllegalStateException(\"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\r\n    }\r\n    if (escape == null && quotePolicy == Quote.NONE) {\r\n        throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\r\n    }\r\n    if (header != null) {\r\n        final Set<String> set = new HashSet<String>(header.length);\r\n        set.addAll(Arrays.asList(header));\r\n        if (set.size() != header.length) {\r\n            throw new IllegalStateException(\"The header contains duplicate names: \" + Arrays.toString(header));\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\r\n *\r\n * @throws IllegalStateException\r\n *\/\r\n","code_no_comment":"void validate() throws IllegalStateException {\r\n    if (quoteChar != null && delimiter == quoteChar.charValue()) {\r\n        throw new IllegalStateException(\"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\r\n    }\r\n    if (escape != null && delimiter == escape.charValue()) {\r\n        throw new IllegalStateException(\"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\r\n    }\r\n    if (commentStart != null && delimiter == commentStart.charValue()) {\r\n        throw new IllegalStateException(\"The comment start character and the delimiter cannot be the same ('\" + commentStart + \"')\");\r\n    }\r\n    if (quoteChar != null && quoteChar.equals(commentStart)) {\r\n        throw new IllegalStateException(\"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \"')\");\r\n    }\r\n    if (escape != null && escape.equals(commentStart)) {\r\n        throw new IllegalStateException(\"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\r\n    }\r\n    if (escape == null && quotePolicy == Quote.NONE) {\r\n        throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\r\n    }\r\n    if (header != null) {\r\n        final Set<String> set = new HashSet<String>(header.length);\r\n        set.addAll(Arrays.asList(header));\r\n        if (set.size() != header.length) {\r\n            throw new IllegalStateException(\"The header contains duplicate names: \" + Arrays.toString(header));\r\n        }\r\n    }\r\n}","lc":0.5909090909,"pi":-0.1387559809,"ma":2.4,"nbd":0.0,"ml":1.8333333333,"d":0.6031746032,"mi":-0.5526427061,"fo":0.25,"r":-0.0263157895,"e":1.0431792904}
{"project_name":"Closure","project_version":"102","label":2,"code":"@Override\r\npublic void process(Node externs, Node root) {\r\n    NodeTraversal.traverse(compiler, root, this);\r\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\r\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\r\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\r\n        t.traverseRoots(externs, root);\r\n    }\r\n    removeDuplicateDeclarations(root);\r\n    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void process(Node externs, Node root) {\r\n    NodeTraversal.traverse(compiler, root, this);\r\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\r\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\r\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\r\n        t.traverseRoots(externs, root);\r\n    }\r\n    removeDuplicateDeclarations(root);\r\n    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\r\n}","lc":-0.1363636364,"pi":-0.019138756,"ma":-0.4,"nbd":-0.5,"ml":-0.3333333333,"d":-0.3650793651,"mi":0.1433403805,"fo":-0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2363_90ea7aa5","label":1,"code":"@CheckForNull\r\n@Override\r\npublic NodeState retrieve(@Nonnull String checkpoint) {\r\n    Revision r = Revision.fromString(checkpoint);\r\n    if (checkpoints.getCheckpoints().containsKey(r)) {\r\n        return getRoot(r);\r\n    } else {\r\n        return null;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@CheckForNull\r\n@Override\r\npublic NodeState retrieve(@Nonnull String checkpoint) {\r\n    Revision r = Revision.fromString(checkpoint);\r\n    if (checkpoints.getCheckpoints().containsKey(r)) {\r\n        return getRoot(r);\r\n    } else {\r\n        return null;\r\n    }\r\n}","lc":-0.1818181818,"pi":0.0,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.2606060606,"fo":-0.1666666667,"r":1.3947368421,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5711_5837817c","label":1,"code":"@Override\r\nprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {\r\n    super.updateAjaxAttributes(attributes);\r\n    Component component = getComponent();\r\n    \/\/ while all the other components will use 'change'\r\n    if (component instanceof TextField || component instanceof TextArea) {\r\n        attributes.setEventNames(EVENT_INPUTCHANGE);\r\n    } else {\r\n        attributes.setEventNames(EVENT_CHANGE);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {\r\n    super.updateAjaxAttributes(attributes);\r\n    Component component = getComponent();\r\n        if (component instanceof TextField || component instanceof TextArea) {\r\n        attributes.setEventNames(EVENT_INPUTCHANGE);\r\n    } else {\r\n        attributes.setEventNames(EVENT_CHANGE);\r\n    }\r\n}","lc":-0.1818181818,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0595238095,"mi":0.260324172,"fo":-0.1666666667,"r":0.6842105263,"e":-0.1018308812}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-276_1bf5c550","label":1,"code":"@Override\r\npublic boolean markCNEMap(Id id) throws Exception {\r\n    return touch(id, gcStart);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean markCNEMap(Id id) throws Exception {\r\n    return touch(id, gcStart);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8548273432,"fo":-0.4166666667,"r":1.8157894737,"e":-0.1627934049}
{"project_name":"Math","project_version":"85","label":1,"code":"\/**\r\n * This method attempts to find two values a and b satisfying <ul>\r\n * <li> <code> lowerBound <= a < initial < b <= upperBound<\/code> <\/li>\r\n * <li> <code> f(a) * f(b) <= 0 <\/code> <\/li>\r\n * <\/ul>\r\n * If f is continuous on <code>[a,b],<\/code> this means that <code>a<\/code>\r\n * and <code>b<\/code> bracket a root of f.\r\n * <p>\r\n * The algorithm starts by setting\r\n * <code>a := initial -1; b := initial +1,<\/code> examines the value of the\r\n * function at <code>a<\/code> and <code>b<\/code> and keeps moving\r\n * the endpoints out by one unit each time through a loop that terminates\r\n * when one of the following happens: <ul>\r\n * <li> <code> f(a) * f(b) <= 0 <\/code> --  success!<\/li>\r\n * <li> <code> a = lower <\/code> and <code> b = upper<\/code>\r\n * -- ConvergenceException <\/li>\r\n * <li> <code> maximumIterations<\/code> iterations elapse\r\n * -- ConvergenceException <\/li><\/ul><\/p>\r\n *\r\n * @param function the function\r\n * @param initial initial midpoint of interval being expanded to\r\n * bracket a root\r\n * @param lowerBound lower bound (a is never lower than this value)\r\n * @param upperBound upper bound (b never is greater than this\r\n * value)\r\n * @param maximumIterations maximum number of iterations to perform\r\n * @return a two element array holding {a, b}.\r\n * @throws ConvergenceException if the algorithm fails to find a and b\r\n * satisfying the desired conditions\r\n * @throws FunctionEvaluationException if an error occurs evaluating the\r\n * function\r\n * @throws IllegalArgumentException if function is null, maximumIterations\r\n * is not positive, or initial is not between lowerBound and upperBound\r\n *\/\r\npublic static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException {\r\n    if (function == null) {\r\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\r\n    }\r\n    if (maximumIterations <= 0) {\r\n        throw MathRuntimeException.createIllegalArgumentException(\"bad value for maximum iterations number: {0}\", maximumIterations);\r\n    }\r\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\r\n        throw MathRuntimeException.createIllegalArgumentException(\"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\", lowerBound, initial, upperBound);\r\n    }\r\n    double a = initial;\r\n    double b = initial;\r\n    double fa;\r\n    double fb;\r\n    int numIterations = 0;\r\n    do {\r\n        a = Math.max(a - 1.0, lowerBound);\r\n        b = Math.min(b + 1.0, upperBound);\r\n        fa = function.value(a);\r\n        fb = function.value(b);\r\n        numIterations++;\r\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));\r\n    if (fa * fb >= 0.0) {\r\n        throw new ConvergenceException(\"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb);\r\n    }\r\n    return new double[] { a, b };\r\n}","code_comment":"\/**\r\n * This method attempts to find two values a and b satisfying <ul>\r\n * <li> <code> lowerBound <= a < initial < b <= upperBound<\/code> <\/li>\r\n * <li> <code> f(a) * f(b) <= 0 <\/code> <\/li>\r\n * <\/ul>\r\n * If f is continuous on <code>[a,b],<\/code> this means that <code>a<\/code>\r\n * and <code>b<\/code> bracket a root of f.\r\n * <p>\r\n * The algorithm starts by setting\r\n * <code>a := initial -1; b := initial +1,<\/code> examines the value of the\r\n * function at <code>a<\/code> and <code>b<\/code> and keeps moving\r\n * the endpoints out by one unit each time through a loop that terminates\r\n * when one of the following happens: <ul>\r\n * <li> <code> f(a) * f(b) <= 0 <\/code> --  success!<\/li>\r\n * <li> <code> a = lower <\/code> and <code> b = upper<\/code>\r\n * -- ConvergenceException <\/li>\r\n * <li> <code> maximumIterations<\/code> iterations elapse\r\n * -- ConvergenceException <\/li><\/ul><\/p>\r\n *\r\n * @param function the function\r\n * @param initial initial midpoint of interval being expanded to\r\n * bracket a root\r\n * @param lowerBound lower bound (a is never lower than this value)\r\n * @param upperBound upper bound (b never is greater than this\r\n * value)\r\n * @param maximumIterations maximum number of iterations to perform\r\n * @return a two element array holding {a, b}.\r\n * @throws ConvergenceException if the algorithm fails to find a and b\r\n * satisfying the desired conditions\r\n * @throws FunctionEvaluationException if an error occurs evaluating the\r\n * function\r\n * @throws IllegalArgumentException if function is null, maximumIterations\r\n * is not positive, or initial is not between lowerBound and upperBound\r\n *\/\r\n","code_no_comment":"public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException {\r\n    if (function == null) {\r\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\r\n    }\r\n    if (maximumIterations <= 0) {\r\n        throw MathRuntimeException.createIllegalArgumentException(\"bad value for maximum iterations number: {0}\", maximumIterations);\r\n    }\r\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\r\n        throw MathRuntimeException.createIllegalArgumentException(\"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\", lowerBound, initial, upperBound);\r\n    }\r\n    double a = initial;\r\n    double b = initial;\r\n    double fa;\r\n    double fb;\r\n    int numIterations = 0;\r\n    do {\r\n        a = Math.max(a - 1.0, lowerBound);\r\n        b = Math.min(b + 1.0, upperBound);\r\n        fa = function.value(a);\r\n        fb = function.value(b);\r\n        numIterations++;\r\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));\r\n    if (fa * fb >= 0.0) {\r\n        throw new ConvergenceException(\"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb);\r\n    }\r\n    return new double[] { a, b };\r\n}","lc":0.5909090909,"pi":-0.3157894737,"ma":1.2,"nbd":-0.5,"ml":1.25,"d":3.0535714286,"mi":-0.5371388302,"fo":0.0833333333,"r":-0.0263157895,"e":4.8360736041}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1518_dc95cb69","label":1,"code":"private FileOperations findFileFactory(String file) {\r\n    Path p = new Path(file);\r\n    String name = p.getName();\r\n    if (name.startsWith(Constants.MAPFILE_EXTENSION + \"_\")) {\r\n        return new MapFileOperations();\r\n    }\r\n    String[] sp = name.split(\"\\\\.\");\r\n    if (sp.length != 2) {\r\n        throw new IllegalArgumentException(\"File name \" + name + \" has no extension\");\r\n    }\r\n    String extension = sp[1];\r\n    if (extension.equals(Constants.MAPFILE_EXTENSION) || extension.equals(Constants.MAPFILE_EXTENSION + \"_tmp\")) {\r\n        return new MapFileOperations();\r\n    } else if (extension.equals(RFile.EXTENSION) || extension.equals(RFile.EXTENSION + \"_tmp\")) {\r\n        return new RFileOperations();\r\n    } else {\r\n        throw new IllegalArgumentException(\"File type \" + extension + \" not supported\");\r\n    }\r\n}","code_comment":null,"code_no_comment":"private FileOperations findFileFactory(String file) {\r\n    Path p = new Path(file);\r\n    String name = p.getName();\r\n    if (name.startsWith(Constants.MAPFILE_EXTENSION + \"_\")) {\r\n        return new MapFileOperations();\r\n    }\r\n    String[] sp = name.split(\"\\\\.\");\r\n    if (sp.length != 2) {\r\n        throw new IllegalArgumentException(\"File name \" + name + \" has no extension\");\r\n    }\r\n    String extension = sp[1];\r\n    if (extension.equals(Constants.MAPFILE_EXTENSION) || extension.equals(Constants.MAPFILE_EXTENSION + \"_tmp\")) {\r\n        return new MapFileOperations();\r\n    } else if (extension.equals(RFile.EXTENSION) || extension.equals(RFile.EXTENSION + \"_tmp\")) {\r\n        return new RFileOperations();\r\n    } else {\r\n        throw new IllegalArgumentException(\"File type \" + extension + \" not supported\");\r\n    }\r\n}","lc":0.2272727273,"pi":-0.3110047847,"ma":0.6,"nbd":0.0,"ml":0.5833333333,"d":0.3908730159,"mi":-0.2769556025,"fo":0.0833333333,"r":0.0,"e":0.4763057347}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"@Override\r\npublic long getChildrenCount() {\r\n    \/\/ TODO: make sure cnt respects access control\r\n    root.checkLive();\r\n    return getNodeBuilder().getChildNodeCount();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic long getChildrenCount() {\r\n        root.checkLive();\r\n    return getNodeBuilder().getChildNodeCount();\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.799577167,"fo":-0.25,"r":2.4210526316,"e":-0.1627934049}
{"project_name":"Closure","project_version":"176","label":2,"code":"\/**\r\n * Updates the scope according to the result of a type change, like\r\n * an assignment or a type cast.\r\n *\/\r\nprivate void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\r\n    Preconditions.checkNotNull(resultType);\r\n    switch(left.getType()) {\r\n        case Token.NAME:\r\n            String varName = left.getString();\r\n            Var var = syntacticScope.getVar(varName);\r\n            boolean isVarDeclaration = left.hasChildren();\r\n            \/\/ When looking at VAR initializers for declared VARs, we tend\r\n            \/\/ to use the declared type over the type it's being\r\n            \/\/ initialized to in the global scope.\r\n            \/\/ \r\n            \/\/ For example,\r\n            \/\/ \/** @param {number} *\/ var f = goog.abstractMethod;\r\n            \/\/ it's obvious that the programmer wants you to use\r\n            \/\/ the declared function signature, not the inferred signature.\r\n            \/\/ \r\n            \/\/ Or,\r\n            \/\/ \/** @type {Object.<string>} *\/ var x = {};\r\n            \/\/ the one-time anonymous object on the right side\r\n            \/\/ is as narrow as it can possibly be, but we need to make\r\n            \/\/ sure we back-infer the <string> element constraint on\r\n            \/\/ the left hand side, so we use the left hand side.\r\n            boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\r\n            if (isVarTypeBetter) {\r\n                redeclareSimpleVar(scope, left, resultType);\r\n            }\r\n            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\r\n            if (var != null && var.isTypeInferred()) {\r\n                JSType oldType = var.getType();\r\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\r\n            }\r\n            break;\r\n        case Token.GETPROP:\r\n            String qualifiedName = left.getQualifiedName();\r\n            if (qualifiedName != null) {\r\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\r\n            }\r\n            left.setJSType(resultType);\r\n            ensurePropertyDefined(left, resultType);\r\n            break;\r\n    }\r\n}","code_comment":"\/**\r\n * Updates the scope according to the result of a type change, like\r\n * an assignment or a type cast.\r\n *\/\r\n","code_no_comment":"private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) {\r\n    Preconditions.checkNotNull(resultType);\r\n    switch(left.getType()) {\r\n        case Token.NAME:\r\n            String varName = left.getString();\r\n            Var var = syntacticScope.getVar(varName);\r\n            boolean isVarDeclaration = left.hasChildren();\r\n                                                                                                                                                                                                boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\r\n            if (isVarTypeBetter) {\r\n                redeclareSimpleVar(scope, left, resultType);\r\n            }\r\n            left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\r\n            if (var != null && var.isTypeInferred()) {\r\n                JSType oldType = var.getType();\r\n                var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));\r\n            }\r\n            break;\r\n        case Token.GETPROP:\r\n            String qualifiedName = left.getQualifiedName();\r\n            if (qualifiedName != null) {\r\n                scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType);\r\n            }\r\n            left.setJSType(resultType);\r\n            ensurePropertyDefined(left, resultType);\r\n            break;\r\n    }\r\n}","lc":0.5909090909,"pi":0.6602870813,"ma":1.4,"nbd":0.5,"ml":1.0833333333,"d":1.0178571429,"mi":-0.5261451727,"fo":0.8333333333,"r":-0.0263157895,"e":1.6339620684}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3304_7e7ab76c","label":3,"code":"\/**\r\n *\/\r\nprivate void resolveType() {\r\n    if (!getFlag(TYPE_RESOLVED) && getType() == null) {\r\n        \/\/ Set the type, but only if it's not a String (see WICKET-606).\r\n        \/\/ Otherwise, getConvertEmptyInputStringToNull() won't work.\r\n        Class<?> type = getModelType(getDefaultModel());\r\n        if (!String.class.equals(type)) {\r\n            setType(type);\r\n        }\r\n        setFlag(TYPE_RESOLVED, true);\r\n    }\r\n}","code_comment":"\/**\r\n *\/\r\n","code_no_comment":"private void resolveType() {\r\n    if (!getFlag(TYPE_RESOLVED) && getType() == null) {\r\n                        Class<?> type = getModelType(getDefaultModel());\r\n        if (!String.class.equals(type)) {\r\n            setType(type);\r\n        }\r\n        setFlag(TYPE_RESOLVED, true);\r\n    }\r\n}","lc":-0.2272727273,"pi":0.3971291866,"ma":-0.2,"nbd":0.0,"ml":0.1666666667,"d":0.1111111111,"mi":0.2831571529,"fo":0.0833333333,"r":1.8157894737,"e":-0.054685546}
{"project_name":"Cli","project_version":"35","label":1,"code":"\/**\r\n * Returns the options with a long name starting with the name specified.\r\n *\r\n * @param opt the partial name of the option\r\n * @return the options matching the partial name specified, or an empty list if none matches\r\n * @since 1.3\r\n *\/\r\npublic List<String> getMatchingOptions(String opt) {\r\n    opt = Util.stripLeadingHyphens(opt);\r\n    List<String> matchingOpts = new ArrayList<String>();\r\n    for (String longOpt : longOpts.keySet()) {\r\n        if (longOpt.startsWith(opt)) {\r\n            matchingOpts.add(longOpt);\r\n        }\r\n    }\r\n    return matchingOpts;\r\n}","code_comment":"\/**\r\n * Returns the options with a long name starting with the name specified.\r\n *\r\n * @param opt the partial name of the option\r\n * @return the options matching the partial name specified, or an empty list if none matches\r\n * @since 1.3\r\n *\/\r\n","code_no_comment":"public List<String> getMatchingOptions(String opt) {\r\n    opt = Util.stripLeadingHyphens(opt);\r\n    List<String> matchingOpts = new ArrayList<String>();\r\n    for (String longOpt : longOpts.keySet()) {\r\n        if (longOpt.startsWith(opt)) {\r\n            matchingOpts.add(longOpt);\r\n        }\r\n    }\r\n    return matchingOpts;\r\n}","lc":-0.1818181818,"pi":0.2392344498,"ma":-0.2,"nbd":0.0,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.2183227625,"fo":-0.1666666667,"r":0.5263157895,"e":-0.1627934049}
{"project_name":"Math","project_version":"98","label":1,"code":"\/**\r\n * @param v vector to operate on\r\n * @throws IllegalArgumentException if columnDimension != v.length\r\n * @return resulting vector\r\n *\/\r\npublic double[] operate(double[] v) throws IllegalArgumentException {\r\n    final int nRows = this.getRowDimension();\r\n    final int nCols = this.getColumnDimension();\r\n    if (v.length != nCols) {\r\n        throw new IllegalArgumentException(\"vector has wrong length\");\r\n    }\r\n    final double[] out = new double[v.length];\r\n    for (int row = 0; row < nRows; row++) {\r\n        final double[] dataRow = data[row];\r\n        double sum = 0;\r\n        for (int i = 0; i < nCols; i++) {\r\n            sum += dataRow[i] * v[i];\r\n        }\r\n        out[row] = sum;\r\n    }\r\n    return out;\r\n}","code_comment":"\/**\r\n * @param v vector to operate on\r\n * @throws IllegalArgumentException if columnDimension != v.length\r\n * @return resulting vector\r\n *\/\r\n","code_no_comment":"public double[] operate(double[] v) throws IllegalArgumentException {\r\n    final int nRows = this.getRowDimension();\r\n    final int nCols = this.getColumnDimension();\r\n    if (v.length != nCols) {\r\n        throw new IllegalArgumentException(\"vector has wrong length\");\r\n    }\r\n    final double[] out = new double[v.length];\r\n    for (int row = 0; row < nRows; row++) {\r\n        final double[] dataRow = data[row];\r\n        double sum = 0;\r\n        for (int i = 0; i < nCols; i++) {\r\n            sum += dataRow[i] * v[i];\r\n        }\r\n        out[row] = sum;\r\n    }\r\n    return out;\r\n}","lc":0.1363636364,"pi":0.028708134,"ma":0.2,"nbd":0.0,"ml":0.25,"d":1.0357142857,"mi":-0.1571529246,"fo":-0.3333333333,"r":1.2368421053,"e":0.6468790881}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3789_9319e139","label":1,"code":"private void writeFileByFile(File source, File target) throws IOException {\r\n    FileChannel in = new FileInputStream(source).getChannel();\r\n    FileChannel out = null;\r\n    try {\r\n        out = prepareOutputFileChannel(target, out);\r\n        LOG.trace(\"Using FileChannel to transfer from: {} to: {}\", in, out);\r\n        long size = in.size();\r\n        long position = 0;\r\n        while (position < size) {\r\n            position += in.transferTo(position, endpoint.getBufferSize(), out);\r\n        }\r\n    } finally {\r\n        IOHelper.close(in, source.getName(), LOG);\r\n        IOHelper.close(out, source.getName(), LOG);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void writeFileByFile(File source, File target) throws IOException {\r\n    FileChannel in = new FileInputStream(source).getChannel();\r\n    FileChannel out = null;\r\n    try {\r\n        out = prepareOutputFileChannel(target, out);\r\n        LOG.trace(\"Using FileChannel to transfer from: {} to: {}\", in, out);\r\n        long size = in.size();\r\n        long position = 0;\r\n        while (position < size) {\r\n            position += in.transferTo(position, endpoint.getBufferSize(), out);\r\n        }\r\n    } finally {\r\n        IOHelper.close(in, source.getName(), LOG);\r\n        IOHelper.close(out, source.getName(), LOG);\r\n    }\r\n}","lc":0.0909090909,"pi":0.0813397129,"ma":-0.4,"nbd":0.0,"ml":-0.1666666667,"d":0.0317460317,"mi":-0.1241719521,"fo":0.3333333333,"r":-0.0263157895,"e":0.0898716597}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7359_e6fbbf04","label":1,"code":"private Expression createSimpleExpressionBodyOrHeader(String function, boolean strict) {\r\n    \/\/ bodyAs\r\n    String remainder = ifStartsWithReturnRemainder(\"bodyAs\", function);\r\n    if (remainder != null) {\r\n        String type = ObjectHelper.between(remainder, \"(\", \")\");\r\n        if (type == null) {\r\n            throw new SimpleParserException(\"Valid syntax: ${bodyAs(type)} was: \" + function, token.getIndex());\r\n        }\r\n        type = StringHelper.removeQuotes(type);\r\n        return ExpressionBuilder.bodyExpression(type);\r\n    }\r\n    \/\/ mandatoryBodyAs\r\n    remainder = ifStartsWithReturnRemainder(\"mandatoryBodyAs\", function);\r\n    if (remainder != null) {\r\n        String type = ObjectHelper.between(remainder, \"(\", \")\");\r\n        if (type == null) {\r\n            throw new SimpleParserException(\"Valid syntax: ${mandatoryBodyAs(type)} was: \" + function, token.getIndex());\r\n        }\r\n        type = StringHelper.removeQuotes(type);\r\n        return ExpressionBuilder.mandatoryBodyExpression(type);\r\n    }\r\n    \/\/ body OGNL\r\n    remainder = ifStartsWithReturnRemainder(\"body\", function);\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"in.body\", function);\r\n    }\r\n    if (remainder != null) {\r\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\r\n        if (invalid) {\r\n            throw new SimpleParserException(\"Valid syntax: ${body.OGNL} was: \" + function, token.getIndex());\r\n        }\r\n        return ExpressionBuilder.bodyOgnlExpression(remainder);\r\n    }\r\n    \/\/ headerAs\r\n    remainder = ifStartsWithReturnRemainder(\"headerAs\", function);\r\n    if (remainder != null) {\r\n        String keyAndType = ObjectHelper.between(remainder, \"(\", \")\");\r\n        if (keyAndType == null) {\r\n            throw new SimpleParserException(\"Valid syntax: ${headerAs(key, type)} was: \" + function, token.getIndex());\r\n        }\r\n        String key = ObjectHelper.before(keyAndType, \",\");\r\n        String type = ObjectHelper.after(keyAndType, \",\");\r\n        if (ObjectHelper.isEmpty(key) || ObjectHelper.isEmpty(type)) {\r\n            throw new SimpleParserException(\"Valid syntax: ${headerAs(key, type)} was: \" + function, token.getIndex());\r\n        }\r\n        key = StringHelper.removeQuotes(key);\r\n        type = StringHelper.removeQuotes(type);\r\n        return ExpressionBuilder.headerExpression(key, type);\r\n    }\r\n    \/\/ headers function\r\n    if (\"in.headers\".equals(function) || \"headers\".equals(function)) {\r\n        return ExpressionBuilder.headersExpression();\r\n    }\r\n    \/\/ in header function\r\n    remainder = ifStartsWithReturnRemainder(\"in.headers\", function);\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"in.header\", function);\r\n    }\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"headers\", function);\r\n    }\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"header\", function);\r\n    }\r\n    if (remainder != null) {\r\n        \/\/ remove leading character (dot or ?)\r\n        if (remainder.startsWith(\".\") || remainder.startsWith(\"?\")) {\r\n            remainder = remainder.substring(1);\r\n        }\r\n        \/\/ remove starting and ending brackets\r\n        if (remainder.startsWith(\"[\") && remainder.endsWith(\"]\")) {\r\n            remainder = remainder.substring(1, remainder.length() - 1);\r\n        }\r\n        \/\/ remove quotes from key\r\n        String key = StringHelper.removeLeadingAndEndingQuotes(remainder);\r\n        \/\/ validate syntax\r\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(key);\r\n        if (invalid) {\r\n            throw new SimpleParserException(\"Valid syntax: ${header.name[key]} was: \" + function, token.getIndex());\r\n        }\r\n        if (OgnlHelper.isValidOgnlExpression(key)) {\r\n            \/\/ ognl based header\r\n            return ExpressionBuilder.headersOgnlExpression(key);\r\n        } else {\r\n            \/\/ regular header\r\n            return ExpressionBuilder.headerExpression(key);\r\n        }\r\n    }\r\n    \/\/ out header function\r\n    remainder = ifStartsWithReturnRemainder(\"out.header.\", function);\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"out.headers.\", function);\r\n    }\r\n    if (remainder != null) {\r\n        return ExpressionBuilder.outHeaderExpression(remainder);\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"private Expression createSimpleExpressionBodyOrHeader(String function, boolean strict) {\r\n        String remainder = ifStartsWithReturnRemainder(\"bodyAs\", function);\r\n    if (remainder != null) {\r\n        String type = ObjectHelper.between(remainder, \"(\", \")\");\r\n        if (type == null) {\r\n            throw new SimpleParserException(\"Valid syntax: ${bodyAs(type)} was: \" + function, token.getIndex());\r\n        }\r\n        type = StringHelper.removeQuotes(type);\r\n        return ExpressionBuilder.bodyExpression(type);\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"mandatoryBodyAs\", function);\r\n    if (remainder != null) {\r\n        String type = ObjectHelper.between(remainder, \"(\", \")\");\r\n        if (type == null) {\r\n            throw new SimpleParserException(\"Valid syntax: ${mandatoryBodyAs(type)} was: \" + function, token.getIndex());\r\n        }\r\n        type = StringHelper.removeQuotes(type);\r\n        return ExpressionBuilder.mandatoryBodyExpression(type);\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"body\", function);\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"in.body\", function);\r\n    }\r\n    if (remainder != null) {\r\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\r\n        if (invalid) {\r\n            throw new SimpleParserException(\"Valid syntax: ${body.OGNL} was: \" + function, token.getIndex());\r\n        }\r\n        return ExpressionBuilder.bodyOgnlExpression(remainder);\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"headerAs\", function);\r\n    if (remainder != null) {\r\n        String keyAndType = ObjectHelper.between(remainder, \"(\", \")\");\r\n        if (keyAndType == null) {\r\n            throw new SimpleParserException(\"Valid syntax: ${headerAs(key, type)} was: \" + function, token.getIndex());\r\n        }\r\n        String key = ObjectHelper.before(keyAndType, \",\");\r\n        String type = ObjectHelper.after(keyAndType, \",\");\r\n        if (ObjectHelper.isEmpty(key) || ObjectHelper.isEmpty(type)) {\r\n            throw new SimpleParserException(\"Valid syntax: ${headerAs(key, type)} was: \" + function, token.getIndex());\r\n        }\r\n        key = StringHelper.removeQuotes(key);\r\n        type = StringHelper.removeQuotes(type);\r\n        return ExpressionBuilder.headerExpression(key, type);\r\n    }\r\n        if (\"in.headers\".equals(function) || \"headers\".equals(function)) {\r\n        return ExpressionBuilder.headersExpression();\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"in.headers\", function);\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"in.header\", function);\r\n    }\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"headers\", function);\r\n    }\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"header\", function);\r\n    }\r\n    if (remainder != null) {\r\n                if (remainder.startsWith(\".\") || remainder.startsWith(\"?\")) {\r\n            remainder = remainder.substring(1);\r\n        }\r\n                if (remainder.startsWith(\"[\") && remainder.endsWith(\"]\")) {\r\n            remainder = remainder.substring(1, remainder.length() - 1);\r\n        }\r\n                String key = StringHelper.removeLeadingAndEndingQuotes(remainder);\r\n                boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(key);\r\n        if (invalid) {\r\n            throw new SimpleParserException(\"Valid syntax: ${header.name[key]} was: \" + function, token.getIndex());\r\n        }\r\n        if (OgnlHelper.isValidOgnlExpression(key)) {\r\n                        return ExpressionBuilder.headersOgnlExpression(key);\r\n        } else {\r\n                        return ExpressionBuilder.headerExpression(key);\r\n        }\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"out.header.\", function);\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"out.headers.\", function);\r\n    }\r\n    if (remainder != null) {\r\n        return ExpressionBuilder.outHeaderExpression(remainder);\r\n    }\r\n    return null;\r\n}","lc":3.2272727273,"pi":-0.0909090909,"ma":4.8,"nbd":0.0,"ml":2.9166666667,"d":1.8293650794,"mi":-1.3281183932,"fo":3.5833333333,"r":-0.0263157895,"e":8.8075586522}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-276_1bf5c550","label":1,"code":"public ChildNodeEntriesMap readCNEMap(Id id) throws NotFoundException, Exception {\r\n    Connection con = cp.getConnection();\r\n    try {\r\n        PreparedStatement stmt = con.prepareStatement(\"select DATA from REVS where ID = ?\");\r\n        try {\r\n            stmt.setBytes(1, id.getBytes());\r\n            ResultSet rs = stmt.executeQuery();\r\n            if (rs.next()) {\r\n                ByteArrayInputStream in = new ByteArrayInputStream(rs.getBytes(1));\r\n                return ChildNodeEntriesMap.deserialize(new BinaryBinding(in));\r\n            } else {\r\n                throw new NotFoundException(id.toString());\r\n            }\r\n        } finally {\r\n            stmt.close();\r\n        }\r\n    } finally {\r\n        con.close();\r\n    }\r\n}","code_comment":null,"code_no_comment":"public ChildNodeEntriesMap readCNEMap(Id id) throws NotFoundException, Exception {\r\n    Connection con = cp.getConnection();\r\n    try {\r\n        PreparedStatement stmt = con.prepareStatement(\"select DATA from REVS where ID = ?\");\r\n        try {\r\n            stmt.setBytes(1, id.getBytes());\r\n            ResultSet rs = stmt.executeQuery();\r\n            if (rs.next()) {\r\n                ByteArrayInputStream in = new ByteArrayInputStream(rs.getBytes(1));\r\n                return ChildNodeEntriesMap.deserialize(new BinaryBinding(in));\r\n            } else {\r\n                throw new NotFoundException(id.toString());\r\n            }\r\n        } finally {\r\n            stmt.close();\r\n        }\r\n    } finally {\r\n        con.close();\r\n    }\r\n}","lc":0.2727272727,"pi":0.8803827751,"ma":-0.2,"nbd":0.5,"ml":-0.25,"d":-0.3650793651,"mi":-0.2090204369,"fo":0.4166666667,"r":0.0526315789,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1496_0a4c7694","label":1,"code":"public void updateInputChannel(PartitionInfo partitionInfo) throws IOException {\r\n    synchronized (requestLock) {\r\n        if (isReleased) {\r\n            \/\/ There was a race with a task failure\/cancel\r\n            return;\r\n        }\r\n        final IntermediateResultPartitionID partitionId = partitionInfo.getPartitionId();\r\n        InputChannel current = inputChannels.get(partitionId);\r\n        if (current.getClass() == UnknownInputChannel.class) {\r\n            UnknownInputChannel unknownChannel = (UnknownInputChannel) current;\r\n            InputChannel newChannel;\r\n            if (partitionInfo.getProducerLocation() == PartitionLocation.REMOTE) {\r\n                newChannel = unknownChannel.toRemoteInputChannel(partitionInfo.getProducerAddress());\r\n            } else if (partitionInfo.getProducerLocation() == PartitionLocation.LOCAL) {\r\n                newChannel = unknownChannel.toLocalInputChannel();\r\n            } else {\r\n                throw new IllegalStateException(\"Tried to update unknown channel with unknown channel.\");\r\n            }\r\n            inputChannels.put(partitionId, newChannel);\r\n            newChannel.requestIntermediateResultPartition(queueToRequest);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void updateInputChannel(PartitionInfo partitionInfo) throws IOException {\r\n    synchronized (requestLock) {\r\n        if (isReleased) {\r\n                        return;\r\n        }\r\n        final IntermediateResultPartitionID partitionId = partitionInfo.getPartitionId();\r\n        InputChannel current = inputChannels.get(partitionId);\r\n        if (current.getClass() == UnknownInputChannel.class) {\r\n            UnknownInputChannel unknownChannel = (UnknownInputChannel) current;\r\n            InputChannel newChannel;\r\n            if (partitionInfo.getProducerLocation() == PartitionLocation.REMOTE) {\r\n                newChannel = unknownChannel.toRemoteInputChannel(partitionInfo.getProducerAddress());\r\n            } else if (partitionInfo.getProducerLocation() == PartitionLocation.LOCAL) {\r\n                newChannel = unknownChannel.toLocalInputChannel();\r\n            } else {\r\n                throw new IllegalStateException(\"Tried to update unknown channel with unknown channel.\");\r\n            }\r\n            inputChannels.put(partitionId, newChannel);\r\n            newChannel.requestIntermediateResultPartition(queueToRequest);\r\n        }\r\n    }\r\n}","lc":0.3636363636,"pi":0.7033492823,"ma":0.4,"nbd":1.0,"ml":0.1666666667,"d":-0.0337301587,"mi":-0.3040169133,"fo":0.3333333333,"r":-0.0263157895,"e":0.0600381506}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1429_279bb3ce","label":1,"code":"\/**\r\n * Returns the commit root path for the given <code>revision<\/code> or\r\n * <code>null<\/code> if this document does not have a commit root entry for\r\n * the given <code>revision<\/code>.\r\n *\r\n * @param revision a revision.\r\n * @return the commit root path or <code>null<\/code>.\r\n *\/\r\n@CheckForNull\r\npublic String getCommitRootPath(Revision revision) {\r\n    \/\/ check local map first\r\n    Map<Revision, String> local = getLocalCommitRoot();\r\n    String depth = local.get(revision);\r\n    if (depth != null) {\r\n        if (depth.equals(\"0\")) {\r\n            return \"\/\";\r\n        }\r\n        String p = Utils.getPathFromId(getId());\r\n        return PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - Integer.parseInt(depth));\r\n    }\r\n    \/\/ check previous\r\n    for (NodeDocument prev : getPreviousDocs(COMMIT_ROOT, revision)) {\r\n        String path = prev.getCommitRootPath(revision);\r\n        if (path != null) {\r\n            return path;\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":"\/**\r\n * Returns the commit root path for the given <code>revision<\/code> or\r\n * <code>null<\/code> if this document does not have a commit root entry for\r\n * the given <code>revision<\/code>.\r\n *\r\n * @param revision a revision.\r\n * @return the commit root path or <code>null<\/code>.\r\n *\/\r\n","code_no_comment":"@CheckForNull\r\npublic String getCommitRootPath(Revision revision) {\r\n        Map<Revision, String> local = getLocalCommitRoot();\r\n    String depth = local.get(revision);\r\n    if (depth != null) {\r\n        if (depth.equals(\"0\")) {\r\n            return \"\/\";\r\n        }\r\n        String p = Utils.getPathFromId(getId());\r\n        return PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - Integer.parseInt(depth));\r\n    }\r\n        for (NodeDocument prev : getPreviousDocs(COMMIT_ROOT, revision)) {\r\n        String path = prev.getCommitRootPath(revision);\r\n        if (path != null) {\r\n            return path;\r\n        }\r\n    }\r\n    return null;\r\n}","lc":0.2272727273,"pi":0.2488038278,"ma":0.2,"nbd":0.0,"ml":0.0833333333,"d":-0.0238095238,"mi":-0.2279069767,"fo":0.3333333333,"r":0.0263157895,"e":0.0637494741}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1186_52372042","label":1,"code":"@Nonnull\r\nRevision reset(@Nonnull Revision branchHead, @Nonnull Revision ancestor) {\r\n    checkNotNull(branchHead);\r\n    checkNotNull(ancestor);\r\n    Branch b = getBranches().getBranch(branchHead);\r\n    if (b == null) {\r\n        throw new MicroKernelException(\"Empty branch cannot be reset\");\r\n    }\r\n    if (!b.containsCommit(ancestor)) {\r\n        throw new MicroKernelException(ancestor + \" is not \" + \"an ancestor revision of \" + branchHead);\r\n    }\r\n    Revision rev;\r\n    boolean success = false;\r\n    Commit commit = newCommit(branchHead);\r\n    try {\r\n        \/\/ apply reverse diff\r\n        getRoot(ancestor).compareAgainstBaseState(getRoot(branchHead), new CommitDiff(commit, getBlobSerializer()));\r\n        UpdateOp rootOp = commit.getUpdateOperationForNode(\"\/\");\r\n        \/\/ clear collisions\r\n        Iterator<Revision> it = b.getCommits().tailSet(ancestor).iterator();\r\n        \/\/ first revision is the ancestor (tailSet is inclusive)\r\n        \/\/ do not clear collision for this revision\r\n        it.next();\r\n        while (it.hasNext()) {\r\n            NodeDocument.removeCollision(rootOp, it.next());\r\n        }\r\n        rev = apply(commit);\r\n        success = true;\r\n    } finally {\r\n        if (!success) {\r\n            canceled(commit);\r\n        } else {\r\n            done(commit, true, null);\r\n        }\r\n    }\r\n    return rev;\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\nRevision reset(@Nonnull Revision branchHead, @Nonnull Revision ancestor) {\r\n    checkNotNull(branchHead);\r\n    checkNotNull(ancestor);\r\n    Branch b = getBranches().getBranch(branchHead);\r\n    if (b == null) {\r\n        throw new MicroKernelException(\"Empty branch cannot be reset\");\r\n    }\r\n    if (!b.containsCommit(ancestor)) {\r\n        throw new MicroKernelException(ancestor + \" is not \" + \"an ancestor revision of \" + branchHead);\r\n    }\r\n    Revision rev;\r\n    boolean success = false;\r\n    Commit commit = newCommit(branchHead);\r\n    try {\r\n                getRoot(ancestor).compareAgainstBaseState(getRoot(branchHead), new CommitDiff(commit, getBlobSerializer()));\r\n        UpdateOp rootOp = commit.getUpdateOperationForNode(\"\/\");\r\n                Iterator<Revision> it = b.getCommits().tailSet(ancestor).iterator();\r\n                        it.next();\r\n        while (it.hasNext()) {\r\n            NodeDocument.removeCollision(rootOp, it.next());\r\n        }\r\n        rev = apply(commit);\r\n        success = true;\r\n    } finally {\r\n        if (!success) {\r\n            canceled(commit);\r\n        } else {\r\n            done(commit, true, null);\r\n        }\r\n    }\r\n    return rev;\r\n}","lc":0.8636363636,"pi":0.0669856459,"ma":0.6,"nbd":0.0,"ml":0.3333333333,"d":0.375,"mi":-0.5811134602,"fo":1.25,"r":-0.0263157895,"e":0.7297453364}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4338_9decad35","label":3,"code":"\/**\r\n *  @see org.apache.wicket.request.IRequestParameters#getParameterNames()\r\n *\/\r\npublic Set<String> getParameterNames() {\r\n    Set<String> result = new HashSet<String>();\r\n    for (IRequestParameters p : parameters) {\r\n        result.addAll(p.getParameterNames());\r\n    }\r\n    return Collections.unmodifiableSet(result);\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.request.IRequestParameters#getParameterNames()\r\n *\/\r\n","code_no_comment":"public Set<String> getParameterNames() {\r\n    Set<String> result = new HashSet<String>();\r\n    for (IRequestParameters p : parameters) {\r\n        result.addAll(p.getParameterNames());\r\n    }\r\n    return Collections.unmodifiableSet(result);\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4449612403,"fo":-0.25,"r":0.6842105263,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-209_397f86f6","label":1,"code":"@Override\r\npublic IteratorOptions describeOptions() {\r\n    IteratorOptions io = super.describeOptions();\r\n    io.setName(\"regex\");\r\n    io.setDescription(\"The RegExFilter\/Iterator allows you to filter for key\/value pairs based on regular expressions\");\r\n    io.addNamedOption(RegExFilter.ROW_REGEX, \"regular expression on row\");\r\n    io.addNamedOption(RegExFilter.COLF_REGEX, \"regular expression on column family\");\r\n    io.addNamedOption(RegExFilter.COLQ_REGEX, \"regular expression on column qualifier\");\r\n    io.addNamedOption(RegExFilter.VALUE_REGEX, \"regular expression on value\");\r\n    io.addNamedOption(RegExFilter.OR_FIELDS, \"use OR instread of AND when multiple regexes given\");\r\n    return io;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic IteratorOptions describeOptions() {\r\n    IteratorOptions io = super.describeOptions();\r\n    io.setName(\"regex\");\r\n    io.setDescription(\"The RegExFilter\/Iterator allows you to filter for key\/value pairs based on regular expressions\");\r\n    io.addNamedOption(RegExFilter.ROW_REGEX, \"regular expression on row\");\r\n    io.addNamedOption(RegExFilter.COLF_REGEX, \"regular expression on column family\");\r\n    io.addNamedOption(RegExFilter.COLQ_REGEX, \"regular expression on column qualifier\");\r\n    io.addNamedOption(RegExFilter.VALUE_REGEX, \"regular expression on value\");\r\n    io.addNamedOption(RegExFilter.OR_FIELDS, \"use OR instread of AND when multiple regexes given\");\r\n    return io;\r\n}","lc":-0.0909090909,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.0765327696,"fo":0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4520_b91154ea","label":1,"code":"@Override\r\nprotected final MarkupElement onComponentTag(ComponentTag tag) throws ParseException {\r\n    if (tag.isClose()) {\r\n        return tag;\r\n    }\r\n    final String wicketMessageAttribute = tag.getAttributes().getString(getWicketMessageAttrName());\r\n    if ((wicketMessageAttribute != null) && (wicketMessageAttribute.trim().length() > 0)) {\r\n        \/\/ check if this tag is raw markup\r\n        if (tag.getId() == null) {\r\n            \/\/ if this is a raw tag we need to set the id to something so\r\n            \/\/ that wicket will not merge this as raw markup and instead\r\n            \/\/ pass it on to a resolver\r\n            tag.setId(WICKET_MESSAGE_CONTAINER_ID);\r\n            tag.setAutoComponentTag(true);\r\n            tag.setModified(true);\r\n        }\r\n        tag.addBehavior(new AttributeLocalizer(getWicketMessageAttrName()));\r\n    }\r\n    return tag;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected final MarkupElement onComponentTag(ComponentTag tag) throws ParseException {\r\n    if (tag.isClose()) {\r\n        return tag;\r\n    }\r\n    final String wicketMessageAttribute = tag.getAttributes().getString(getWicketMessageAttrName());\r\n    if ((wicketMessageAttribute != null) && (wicketMessageAttribute.trim().length() > 0)) {\r\n                if (tag.getId() == null) {\r\n                                                tag.setId(WICKET_MESSAGE_CONTAINER_ID);\r\n            tag.setAutoComponentTag(true);\r\n            tag.setModified(true);\r\n        }\r\n        tag.addBehavior(new AttributeLocalizer(getWicketMessageAttrName()));\r\n    }\r\n    return tag;\r\n}","lc":0.0909090909,"pi":0.4784688995,"ma":0.0,"nbd":0.0,"ml":0.25,"d":0.253968254,"mi":-0.1024665257,"fo":0.5,"r":-0.0263157895,"e":0.1477683074}
{"project_name":"Closure","project_version":"163","label":1,"code":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    if (n.isGetProp()) {\r\n        String propName = n.getFirstChild().getNext().getString();\r\n        if (propName.equals(\"prototype\")) {\r\n            processPrototypeParent(t, parent);\r\n        } else if (compiler.getCodingConvention().isExported(propName)) {\r\n            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\r\n        } else {\r\n            \/\/ Do not mark prototype prop assigns as a 'use' in the global scope.\r\n            addSymbolUse(propName, t.getModule(), PROPERTY);\r\n        }\r\n    } else if (n.isObjectLit() && \/\/ Foo.prototype = {bar: 3, baz: 5};\r\n    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\r\n        \/\/ should count as a use of property a and b.\r\n        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\r\n            \/\/ May be STRING, GET, or SET, but NUMBER isn't interesting.\r\n            if (!propNameNode.isQuotedString()) {\r\n                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\r\n            }\r\n        }\r\n    } else if (n.isName()) {\r\n        String name = n.getString();\r\n        Var var = t.getScope().getVar(name);\r\n        if (var != null) {\r\n            \/\/ Only process global functions.\r\n            if (var.isGlobal()) {\r\n                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\r\n                    if (t.inGlobalScope()) {\r\n                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\r\n                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\r\n                        }\r\n                    } else {\r\n                        addSymbolUse(name, t.getModule(), VAR);\r\n                    }\r\n                }\r\n            \/\/ If it is not a global, it might be accessing a local of the outer\r\n            \/\/ scope. If that's the case the functions between the variable's\r\n            \/\/ declaring scope and the variable reference scope cannot be moved.\r\n            } else if (var.getScope() != t.getScope()) {\r\n                for (int i = symbolStack.size() - 1; i >= 0; i--) {\r\n                    NameContext context = symbolStack.get(i);\r\n                    if (context.scope == var.getScope()) {\r\n                        break;\r\n                    }\r\n                    context.name.readClosureVariables = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \/\/ Process prototype assignments to non-functions.\r\n    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\r\n        symbolStack.pop();\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    if (n.isGetProp()) {\r\n        String propName = n.getFirstChild().getNext().getString();\r\n        if (propName.equals(\"prototype\")) {\r\n            processPrototypeParent(t, parent);\r\n        } else if (compiler.getCodingConvention().isExported(propName)) {\r\n            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\r\n        } else {\r\n                        addSymbolUse(propName, t.getModule(), PROPERTY);\r\n        }\r\n    } else if (n.isObjectLit() &&     !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\r\n                for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\r\n                        if (!propNameNode.isQuotedString()) {\r\n                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\r\n            }\r\n        }\r\n    } else if (n.isName()) {\r\n        String name = n.getString();\r\n        Var var = t.getScope().getVar(name);\r\n        if (var != null) {\r\n                        if (var.isGlobal()) {\r\n                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\r\n                    if (t.inGlobalScope()) {\r\n                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\r\n                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\r\n                        }\r\n                    } else {\r\n                        addSymbolUse(name, t.getModule(), VAR);\r\n                    }\r\n                }\r\n                                                } else if (var.getScope() != t.getScope()) {\r\n                for (int i = symbolStack.size() - 1; i >= 0; i--) {\r\n                    NameContext context = symbolStack.get(i);\r\n                    if (context.scope == var.getScope()) {\r\n                        break;\r\n                    }\r\n                    context.name.readClosureVariables = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n        if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\r\n        symbolStack.pop();\r\n    }\r\n}","lc":1.5,"pi":2.009569378,"ma":2.8,"nbd":3.0,"ml":3.75,"d":1.5833333333,"mi":-0.9078224101,"fo":3.6666666667,"r":-0.0263157895,"e":4.2997896532}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1093_531aca78","label":1,"code":"@Override\r\npublic Value[] getValues() throws RepositoryException {\r\n    PropertyValue[] values = row.getValues();\r\n    int len = values.length;\r\n    Value[] v2 = new Value[values.length];\r\n    for (int i = 0; i < len; i++) {\r\n        if (values[i].isArray()) {\r\n            v2[i] = result.createValue(mvpToString(values[i]));\r\n        } else {\r\n            v2[i] = result.createValue(values[i]);\r\n        }\r\n    }\r\n    return v2;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Value[] getValues() throws RepositoryException {\r\n    PropertyValue[] values = row.getValues();\r\n    int len = values.length;\r\n    Value[] v2 = new Value[values.length];\r\n    for (int i = 0; i < len; i++) {\r\n        if (values[i].isArray()) {\r\n            v2[i] = result.createValue(mvpToString(values[i]));\r\n        } else {\r\n            v2[i] = result.createValue(values[i]);\r\n        }\r\n    }\r\n    return v2;\r\n}","lc":0.0,"pi":0.4019138756,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":0.0892857143,"mi":-0.0257928118,"fo":-0.0833333333,"r":0.1578947368,"e":0.052053042}
{"project_name":"Closure","project_version":"163","label":1,"code":"@Override\r\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\r\n    \/\/ Process prototype assignments to non-functions.\r\n    if (isPrototypePropertyAssign(n)) {\r\n        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\r\n    } else if (isGlobalFunctionDeclaration(t, n)) {\r\n        String name = parent.isName() ? parent.getString() : \/* VAR *\/\r\n        n.getFirstChild().getString();\r\n        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\r\n    } else if (n.isFunction()) {\r\n        symbolStack.push(new NameContext(anonymousNode));\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\r\n        if (isPrototypePropertyAssign(n)) {\r\n        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\r\n    } else if (isGlobalFunctionDeclaration(t, n)) {\r\n        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\r\n        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\r\n    } else if (n.isFunction()) {\r\n        symbolStack.push(new NameContext(anonymousNode));\r\n    }\r\n    return true;\r\n}","lc":-0.0454545455,"pi":0.043062201,"ma":0.2,"nbd":0.5,"ml":0.4166666667,"d":-0.3650793651,"mi":-0.014235377,"fo":0.75,"r":0.0789473684,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4066_4d3d1f85","label":1,"code":"public int getCompatibilityScore(Request request) {\r\n    return 0;\r\n}","code_comment":null,"code_no_comment":"public int getCompatibilityScore(Request request) {\r\n    return 0;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.5,"r":1.6578947368,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3249_64712735","label":1,"code":"\/**\r\n * Copies the full content from the source to the target repository.\r\n * <p>\r\n * The source repository <strong>must not be modified<\/strong> while\r\n * the copy operation is running to avoid an inconsistent copy.\r\n * <p>\r\n * Note that both the source and the target repository must be closed\r\n * during the copy operation as this method requires exclusive access\r\n * to the repositories.\r\n *\r\n * @param initializer optional extra repository initializer to use\r\n * @throws RepositoryException if the copy operation fails\r\n *\/\r\npublic void copy(RepositoryInitializer initializer) throws RepositoryException {\r\n    RepositoryConfig config = source.getRepositoryConfig();\r\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\r\n    try {\r\n        NodeState base = target.getRoot();\r\n        NodeBuilder builder = base.builder();\r\n        final Root upgradeRoot = new UpgradeRoot(builder);\r\n        String workspaceName = source.getRepositoryConfig().getDefaultWorkspaceName();\r\n        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\r\n        \/\/ init target repository first\r\n        logger.info(\"Initializing initial repository content from {}\", config.getHomeDir());\r\n        new InitialContent().initialize(builder);\r\n        if (initializer != null) {\r\n            initializer.initialize(builder);\r\n        }\r\n        logger.debug(\"InitialContent completed from {}\", config.getHomeDir());\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            RepositoryInitializer ri = sc.getRepositoryInitializer();\r\n            ri.initialize(builder);\r\n            logger.debug(\"Repository initializer '\" + ri.getClass().getName() + \"' completed\", config.getHomeDir());\r\n        }\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            WorkspaceInitializer wi = sc.getWorkspaceInitializer();\r\n            wi.initialize(builder, workspaceName);\r\n            logger.debug(\"Workspace initializer '\" + wi.getClass().getName() + \"' completed\", config.getHomeDir());\r\n        }\r\n        HashBiMap<String, String> uriToPrefix = HashBiMap.create();\r\n        logger.info(\"Copying registered namespaces\");\r\n        copyNamespaces(builder, uriToPrefix);\r\n        logger.debug(\"Namespace registration completed.\");\r\n        logger.info(\"Copying registered node types\");\r\n        NodeTypeManager ntMgr = new ReadWriteNodeTypeManager() {\r\n\r\n            @Override\r\n            protected Tree getTypes() {\r\n                return upgradeRoot.getTree(NODE_TYPES_PATH);\r\n            }\r\n\r\n            @Nonnull\r\n            @Override\r\n            protected Root getWriteRoot() {\r\n                return upgradeRoot;\r\n            }\r\n        };\r\n        copyNodeTypes(ntMgr, new ValueFactoryImpl(upgradeRoot, NamePathMapper.DEFAULT));\r\n        logger.debug(\"Node type registration completed.\");\r\n        \/\/ migrate privileges\r\n        logger.info(\"Copying registered privileges\");\r\n        PrivilegeConfiguration privilegeConfiguration = security.getConfiguration(PrivilegeConfiguration.class);\r\n        copyCustomPrivileges(privilegeConfiguration.getPrivilegeManager(upgradeRoot, NamePathMapper.DEFAULT));\r\n        logger.debug(\"Privilege registration completed.\");\r\n        \/\/ Triggers compilation of type information, which we need for\r\n        \/\/ the type predicates used by the bulk  copy operations below.\r\n        new TypeEditorProvider(false).getRootEditor(base, builder.getNodeState(), builder, null);\r\n        NodeState root = builder.getNodeState();\r\n        final NodeState sourceState = JackrabbitNodeState.createRootNodeState(source, workspaceName, root, uriToPrefix, copyBinariesByReference, skipOnError);\r\n        final Stopwatch watch = Stopwatch.createStarted();\r\n        logger.info(\"Copying workspace content\");\r\n        copyWorkspace(sourceState, builder, workspaceName);\r\n        \/\/ on TarMK this does call triggers the actual copy\r\n        builder.getNodeState();\r\n        logger.info(\"Upgrading workspace content completed in {}s ({})\", watch.elapsed(TimeUnit.SECONDS), watch);\r\n        if (!versionCopyConfiguration.skipOrphanedVersionsCopy()) {\r\n            logger.info(\"Copying version storage\");\r\n            watch.reset().start();\r\n            copyVersionStorage(sourceState, builder, versionCopyConfiguration);\r\n            \/\/ on TarMK this does call triggers the actual copy\r\n            builder.getNodeState();\r\n            logger.info(\"Version storage copied in {}s ({})\", watch.elapsed(TimeUnit.SECONDS), watch);\r\n        } else {\r\n            logger.info(\"Skipping the version storage as the copyOrphanedVersions is set to false\");\r\n        }\r\n        watch.reset().start();\r\n        logger.info(\"Applying default commit hooks\");\r\n        \/\/ TODO: default hooks?\r\n        List<CommitHook> hooks = newArrayList();\r\n        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);\r\n        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\r\n        \/\/ hooks specific to the upgrade, need to run first\r\n        hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath), \/\/ copy referenced version histories\r\n        new VersionableEditor.Provider(sourceState, workspaceName, versionCopyConfiguration))));\r\n        \/\/ security-related hooks\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            hooks.addAll(sc.getCommitHooks(workspaceName));\r\n        }\r\n        if (customCommitHooks != null) {\r\n            hooks.addAll(customCommitHooks);\r\n        }\r\n        \/\/ type validation, reference and indexing hooks\r\n        hooks.add(new EditorHook(new CompositeEditorProvider(createTypeEditorProvider(), createIndexEditorProvider())));\r\n        target.merge(builder, new LoggingCompositeHook(hooks, source, earlyShutdown), CommitInfo.EMPTY);\r\n        logger.info(\"Processing commit hooks completed in {}s ({})\", watch.elapsed(TimeUnit.SECONDS), watch);\r\n        logger.debug(\"Repository upgrade completed.\");\r\n    } catch (Exception e) {\r\n        throw new RepositoryException(\"Failed to copy content\", e);\r\n    }\r\n}","code_comment":"\/**\r\n * Copies the full content from the source to the target repository.\r\n * <p>\r\n * The source repository <strong>must not be modified<\/strong> while\r\n * the copy operation is running to avoid an inconsistent copy.\r\n * <p>\r\n * Note that both the source and the target repository must be closed\r\n * during the copy operation as this method requires exclusive access\r\n * to the repositories.\r\n *\r\n * @param initializer optional extra repository initializer to use\r\n * @throws RepositoryException if the copy operation fails\r\n *\/\r\n","code_no_comment":"public void copy(RepositoryInitializer initializer) throws RepositoryException {\r\n    RepositoryConfig config = source.getRepositoryConfig();\r\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\r\n    try {\r\n        NodeState base = target.getRoot();\r\n        NodeBuilder builder = base.builder();\r\n        final Root upgradeRoot = new UpgradeRoot(builder);\r\n        String workspaceName = source.getRepositoryConfig().getDefaultWorkspaceName();\r\n        SecurityProviderImpl security = new SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\r\n                logger.info(\"Initializing initial repository content from {}\", config.getHomeDir());\r\n        new InitialContent().initialize(builder);\r\n        if (initializer != null) {\r\n            initializer.initialize(builder);\r\n        }\r\n        logger.debug(\"InitialContent completed from {}\", config.getHomeDir());\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            RepositoryInitializer ri = sc.getRepositoryInitializer();\r\n            ri.initialize(builder);\r\n            logger.debug(\"Repository initializer '\" + ri.getClass().getName() + \"' completed\", config.getHomeDir());\r\n        }\r\n        for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            WorkspaceInitializer wi = sc.getWorkspaceInitializer();\r\n            wi.initialize(builder, workspaceName);\r\n            logger.debug(\"Workspace initializer '\" + wi.getClass().getName() + \"' completed\", config.getHomeDir());\r\n        }\r\n        HashBiMap<String, String> uriToPrefix = HashBiMap.create();\r\n        logger.info(\"Copying registered namespaces\");\r\n        copyNamespaces(builder, uriToPrefix);\r\n        logger.debug(\"Namespace registration completed.\");\r\n        logger.info(\"Copying registered node types\");\r\n        NodeTypeManager ntMgr = new ReadWriteNodeTypeManager() {\r\n\r\n            @Override\r\n            protected Tree getTypes() {\r\n                return upgradeRoot.getTree(NODE_TYPES_PATH);\r\n            }\r\n\r\n            @Nonnull\r\n            @Override\r\n            protected Root getWriteRoot() {\r\n                return upgradeRoot;\r\n            }\r\n        };\r\n        copyNodeTypes(ntMgr, new ValueFactoryImpl(upgradeRoot, NamePathMapper.DEFAULT));\r\n        logger.debug(\"Node type registration completed.\");\r\n                logger.info(\"Copying registered privileges\");\r\n        PrivilegeConfiguration privilegeConfiguration = security.getConfiguration(PrivilegeConfiguration.class);\r\n        copyCustomPrivileges(privilegeConfiguration.getPrivilegeManager(upgradeRoot, NamePathMapper.DEFAULT));\r\n        logger.debug(\"Privilege registration completed.\");\r\n                        new TypeEditorProvider(false).getRootEditor(base, builder.getNodeState(), builder, null);\r\n        NodeState root = builder.getNodeState();\r\n        final NodeState sourceState = JackrabbitNodeState.createRootNodeState(source, workspaceName, root, uriToPrefix, copyBinariesByReference, skipOnError);\r\n        final Stopwatch watch = Stopwatch.createStarted();\r\n        logger.info(\"Copying workspace content\");\r\n        copyWorkspace(sourceState, builder, workspaceName);\r\n                builder.getNodeState();\r\n        logger.info(\"Upgrading workspace content completed in {}s ({})\", watch.elapsed(TimeUnit.SECONDS), watch);\r\n        if (!versionCopyConfiguration.skipOrphanedVersionsCopy()) {\r\n            logger.info(\"Copying version storage\");\r\n            watch.reset().start();\r\n            copyVersionStorage(sourceState, builder, versionCopyConfiguration);\r\n                        builder.getNodeState();\r\n            logger.info(\"Version storage copied in {}s ({})\", watch.elapsed(TimeUnit.SECONDS), watch);\r\n        } else {\r\n            logger.info(\"Skipping the version storage as the copyOrphanedVersions is set to false\");\r\n        }\r\n        watch.reset().start();\r\n        logger.info(\"Applying default commit hooks\");\r\n                List<CommitHook> hooks = newArrayList();\r\n        UserConfiguration userConf = security.getConfiguration(UserConfiguration.class);\r\n        String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\r\n                hooks.add(new EditorHook(new CompositeEditorProvider(new RestrictionEditorProvider(), new GroupEditorProvider(groupsPath),         new VersionableEditor.Provider(sourceState, workspaceName, versionCopyConfiguration))));\r\n                for (SecurityConfiguration sc : security.getConfigurations()) {\r\n            hooks.addAll(sc.getCommitHooks(workspaceName));\r\n        }\r\n        if (customCommitHooks != null) {\r\n            hooks.addAll(customCommitHooks);\r\n        }\r\n                hooks.add(new EditorHook(new CompositeEditorProvider(createTypeEditorProvider(), createIndexEditorProvider())));\r\n        target.merge(builder, new LoggingCompositeHook(hooks, source, earlyShutdown), CommitInfo.EMPTY);\r\n        logger.info(\"Processing commit hooks completed in {}s ({})\", watch.elapsed(TimeUnit.SECONDS), watch);\r\n        logger.debug(\"Repository upgrade completed.\");\r\n    } catch (Exception e) {\r\n        throw new RepositoryException(\"Failed to copy content\", e);\r\n    }\r\n}","lc":3.2272727273,"pi":-0.1244019139,"ma":1.0,"nbd":0.0,"ml":0.0833333333,"d":0.5,"mi":-1.2458069063,"fo":6.1666666667,"r":-0.0263157895,"e":4.514336428}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1178_f2bb1a17","label":1,"code":"\/\/ ------------------------------------------------------------< internal >---\r\n\/**\r\n * Rebase this builder on top of the head of the underlying store\r\n *\/\r\nNodeState rebase() {\r\n    purge();\r\n    branch.rebase();\r\n    NodeState head = branch.getHead();\r\n    reset(head);\r\n    return head;\r\n}","code_comment":"\/**\r\n * Rebase this builder on top of the head of the underlying store\r\n *\/\r\n","code_no_comment":"NodeState rebase() {\r\n    purge();\r\n    branch.rebase();\r\n    NodeState head = branch.getHead();\r\n    reset(head);\r\n    return head;\r\n}","lc":-0.3181818182,"pi":-0.5645933014,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5264270613,"fo":-0.1666666667,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7016_4ed448c7","label":3,"code":"public void updateRouteFromXml(String xml) throws Exception {\r\n    \/\/ convert to model from xml\r\n    RouteDefinition def = ModelHelper.createModelFromXml(xml, RouteDefinition.class);\r\n    if (def == null) {\r\n        return;\r\n    }\r\n    \/\/ add will remove existing route first\r\n    context.addRouteDefinition(def);\r\n}","code_comment":null,"code_no_comment":"public void updateRouteFromXml(String xml) throws Exception {\r\n        RouteDefinition def = ModelHelper.createModelFromXml(xml, RouteDefinition.class);\r\n    if (def == null) {\r\n        return;\r\n    }\r\n        context.addRouteDefinition(def);\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1011904762,"mi":0.4562367865,"fo":-0.3333333333,"r":2.1315789474,"e":-0.1206641195}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-4509_8e3450f4","label":1,"code":"public void process(Exchange exchange) throws Exception {\r\n    ObjectHelper.notNull(dataFormat, \"dataFormat\");\r\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\r\n    Message in = exchange.getIn();\r\n    Object body = in.getBody();\r\n    \/\/ lets setup the out message before we invoke the dataFormat\r\n    \/\/ so that it can mutate it if necessary\r\n    Message out = exchange.getOut();\r\n    out.copyFrom(in);\r\n    dataFormat.marshal(exchange, body, buffer);\r\n    byte[] data = buffer.toByteArray();\r\n    out.setBody(data);\r\n}","code_comment":null,"code_no_comment":"public void process(Exchange exchange) throws Exception {\r\n    ObjectHelper.notNull(dataFormat, \"dataFormat\");\r\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\r\n    Message in = exchange.getIn();\r\n    Object body = in.getBody();\r\n            Message out = exchange.getOut();\r\n    out.copyFrom(in);\r\n    dataFormat.marshal(exchange, body, buffer);\r\n    byte[] data = buffer.toByteArray();\r\n    out.setBody(data);\r\n}","lc":-0.1363636364,"pi":-0.6937799043,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.1016208598,"fo":0.1666666667,"r":0.1842105263,"e":-0.1627934049}
{"project_name":"Closure","project_version":"50","label":3,"code":"\/**\r\n * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\r\n *\/\r\nprivate Node tryFoldArrayJoin(Node n) {\r\n    Node callTarget = n.getFirstChild();\r\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\r\n        return n;\r\n    }\r\n    Node right = callTarget.getNext();\r\n    if (right != null) {\r\n        if (!NodeUtil.isImmutableValue(right)) {\r\n            return n;\r\n        }\r\n    }\r\n    Node arrayNode = callTarget.getFirstChild();\r\n    Node functionName = arrayNode.getNext();\r\n    if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\r\n        return n;\r\n    }\r\n    \/\/ \",\" is the default, it doesn't need to be explicit\r\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\r\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\r\n    StringBuilder sb = null;\r\n    int foldedSize = 0;\r\n    Node prev = null;\r\n    Node elem = arrayNode.getFirstChild();\r\n    \/\/ Merges adjacent String nodes.\r\n    while (elem != null) {\r\n        if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\r\n            if (sb == null) {\r\n                sb = new StringBuilder();\r\n            } else {\r\n                sb.append(joinString);\r\n            }\r\n            sb.append(NodeUtil.getArrayElementStringValue(elem));\r\n        } else {\r\n            if (sb != null) {\r\n                Preconditions.checkNotNull(prev);\r\n                \/\/ + 2 for the quotes.\r\n                foldedSize += sb.length() + 2;\r\n                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\r\n                sb = null;\r\n            }\r\n            foldedSize += InlineCostEstimator.getCost(elem);\r\n            arrayFoldedChildren.add(elem);\r\n        }\r\n        prev = elem;\r\n        elem = elem.getNext();\r\n    }\r\n    if (sb != null) {\r\n        Preconditions.checkNotNull(prev);\r\n        \/\/ + 2 for the quotes.\r\n        foldedSize += sb.length() + 2;\r\n        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\r\n    }\r\n    \/\/ one for each comma.\r\n    foldedSize += arrayFoldedChildren.size() - 1;\r\n    int originalSize = InlineCostEstimator.getCost(n);\r\n    switch(arrayFoldedChildren.size()) {\r\n        case 0:\r\n            Node emptyStringNode = Node.newString(\"\");\r\n            n.getParent().replaceChild(n, emptyStringNode);\r\n            reportCodeChange();\r\n            return emptyStringNode;\r\n        case 1:\r\n            Node foldedStringNode = arrayFoldedChildren.remove(0);\r\n            if (foldedSize > originalSize) {\r\n                return n;\r\n            }\r\n            arrayNode.detachChildren();\r\n            if (foldedStringNode.getType() != Token.STRING) {\r\n                \/\/ If the Node is not a string literal, ensure that\r\n                \/\/ it is coerced to a string.\r\n                Node replacement = new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(n), foldedStringNode);\r\n                foldedStringNode = replacement;\r\n            }\r\n            n.getParent().replaceChild(n, foldedStringNode);\r\n            reportCodeChange();\r\n            return foldedStringNode;\r\n        default:\r\n            \/\/ No folding could actually be performed.\r\n            if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\r\n                return n;\r\n            }\r\n            int kJoinOverhead = \"[].join()\".length();\r\n            foldedSize += kJoinOverhead;\r\n            foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\r\n            if (foldedSize > originalSize) {\r\n                return n;\r\n            }\r\n            arrayNode.detachChildren();\r\n            for (Node node : arrayFoldedChildren) {\r\n                arrayNode.addChildToBack(node);\r\n            }\r\n            reportCodeChange();\r\n            break;\r\n    }\r\n    return n;\r\n}","code_comment":"\/**\r\n * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\r\n *\/\r\n","code_no_comment":"private Node tryFoldArrayJoin(Node n) {\r\n    Node callTarget = n.getFirstChild();\r\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\r\n        return n;\r\n    }\r\n    Node right = callTarget.getNext();\r\n    if (right != null) {\r\n        if (!NodeUtil.isImmutableValue(right)) {\r\n            return n;\r\n        }\r\n    }\r\n    Node arrayNode = callTarget.getFirstChild();\r\n    Node functionName = arrayNode.getNext();\r\n    if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\r\n        return n;\r\n    }\r\n        String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\r\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\r\n    StringBuilder sb = null;\r\n    int foldedSize = 0;\r\n    Node prev = null;\r\n    Node elem = arrayNode.getFirstChild();\r\n        while (elem != null) {\r\n        if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\r\n            if (sb == null) {\r\n                sb = new StringBuilder();\r\n            } else {\r\n                sb.append(joinString);\r\n            }\r\n            sb.append(NodeUtil.getArrayElementStringValue(elem));\r\n        } else {\r\n            if (sb != null) {\r\n                Preconditions.checkNotNull(prev);\r\n                                foldedSize += sb.length() + 2;\r\n                arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\r\n                sb = null;\r\n            }\r\n            foldedSize += InlineCostEstimator.getCost(elem);\r\n            arrayFoldedChildren.add(elem);\r\n        }\r\n        prev = elem;\r\n        elem = elem.getNext();\r\n    }\r\n    if (sb != null) {\r\n        Preconditions.checkNotNull(prev);\r\n                foldedSize += sb.length() + 2;\r\n        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));\r\n    }\r\n        foldedSize += arrayFoldedChildren.size() - 1;\r\n    int originalSize = InlineCostEstimator.getCost(n);\r\n    switch(arrayFoldedChildren.size()) {\r\n        case 0:\r\n            Node emptyStringNode = Node.newString(\"\");\r\n            n.getParent().replaceChild(n, emptyStringNode);\r\n            reportCodeChange();\r\n            return emptyStringNode;\r\n        case 1:\r\n            Node foldedStringNode = arrayFoldedChildren.remove(0);\r\n            if (foldedSize > originalSize) {\r\n                return n;\r\n            }\r\n            arrayNode.detachChildren();\r\n            if (foldedStringNode.getType() != Token.STRING) {\r\n                                                Node replacement = new Node(Token.ADD, Node.newString(\"\").copyInformationFrom(n), foldedStringNode);\r\n                foldedStringNode = replacement;\r\n            }\r\n            n.getParent().replaceChild(n, foldedStringNode);\r\n            reportCodeChange();\r\n            return foldedStringNode;\r\n        default:\r\n                        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\r\n                return n;\r\n            }\r\n            int kJoinOverhead = \"[].join()\".length();\r\n            foldedSize += kJoinOverhead;\r\n            foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\r\n            if (foldedSize > originalSize) {\r\n                return n;\r\n            }\r\n            arrayNode.detachChildren();\r\n            for (Node node : arrayFoldedChildren) {\r\n                arrayNode.addChildToBack(node);\r\n            }\r\n            reportCodeChange();\r\n            break;\r\n    }\r\n    return n;\r\n}","lc":3.3636363636,"pi":0.6650717703,"ma":3.4,"nbd":0.5,"ml":2.5,"d":2.3293650794,"mi":-1.2934460888,"fo":4.0,"r":-0.0263157895,"e":10.4802360494}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3242_15e83709","label":1,"code":"private synchronized void retry(ZooRunnable op) {\r\n    int sleepTime = 100;\r\n    while (true) {\r\n        ZooKeeper zooKeeper = getZooKeeper();\r\n        try {\r\n            op.run(zooKeeper);\r\n            return;\r\n        } catch (KeeperException e) {\r\n            final Code code = e.code();\r\n            if (code == Code.NONODE) {\r\n                log.error(\"Looked up non-existent node in cache \" + e.getPath(), e);\r\n            } else if (code == Code.CONNECTIONLOSS || code == Code.OPERATIONTIMEOUT || code == Code.SESSIONEXPIRED) {\r\n                log.warn(\"Saw (possibly) transient exception communicating with ZooKeeper, wil retry\", e);\r\n                continue;\r\n            }\r\n            log.warn(\"Zookeeper error, will retry\", e);\r\n        } catch (InterruptedException e) {\r\n            log.info(\"Zookeeper error, will retry\", e);\r\n        } catch (ConcurrentModificationException e) {\r\n            log.debug(\"Zookeeper was modified, will retry\");\r\n        }\r\n        try {\r\n            \/\/ do not hold lock while sleeping\r\n            wait(sleepTime);\r\n        } catch (InterruptedException e) {\r\n            log.info(\"Interrupted waiting before retrying ZooKeeper operation\", e);\r\n        }\r\n        if (sleepTime < 10000)\r\n            sleepTime = (int) (sleepTime + sleepTime * Math.random());\r\n    }\r\n}","code_comment":null,"code_no_comment":"private synchronized void retry(ZooRunnable op) {\r\n    int sleepTime = 100;\r\n    while (true) {\r\n        ZooKeeper zooKeeper = getZooKeeper();\r\n        try {\r\n            op.run(zooKeeper);\r\n            return;\r\n        } catch (KeeperException e) {\r\n            final Code code = e.code();\r\n            if (code == Code.NONODE) {\r\n                log.error(\"Looked up non-existent node in cache \" + e.getPath(), e);\r\n            } else if (code == Code.CONNECTIONLOSS || code == Code.OPERATIONTIMEOUT || code == Code.SESSIONEXPIRED) {\r\n                log.warn(\"Saw (possibly) transient exception communicating with ZooKeeper, wil retry\", e);\r\n                continue;\r\n            }\r\n            log.warn(\"Zookeeper error, will retry\", e);\r\n        } catch (InterruptedException e) {\r\n            log.info(\"Zookeeper error, will retry\", e);\r\n        } catch (ConcurrentModificationException e) {\r\n            log.debug(\"Zookeeper was modified, will retry\");\r\n        }\r\n        try {\r\n                        wait(sleepTime);\r\n        } catch (InterruptedException e) {\r\n            log.info(\"Interrupted waiting before retrying ZooKeeper operation\", e);\r\n        }\r\n        if (sleepTime < 10000)\r\n            sleepTime = (int) (sleepTime + sleepTime * Math.random());\r\n    }\r\n}","lc":0.7272727273,"pi":0.5119617225,"ma":1.2,"nbd":1.0,"ml":0.25,"d":0.8095238095,"mi":-0.5385482734,"fo":0.5,"r":-0.0263157895,"e":1.0874800459}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1183_742960f1","label":3,"code":"@Override\r\npublic String createBatchScanner(ByteBuffer login, String tableName, BatchScanOptions opts) throws TException {\r\n    try {\r\n        Connector connector = getConnector(login);\r\n        int threads = 10;\r\n        Authorizations auth;\r\n        if (opts != null && opts.isSetAuthorizations()) {\r\n            auth = getAuthorizations(opts.authorizations);\r\n        } else {\r\n            auth = connector.securityOperations().getUserAuthorizations(connector.whoami());\r\n        }\r\n        if (opts != null && opts.threads > 0)\r\n            threads = opts.threads;\r\n        BatchScanner scanner = connector.createBatchScanner(tableName, auth, threads);\r\n        if (opts != null) {\r\n            if (opts.iterators != null) {\r\n                for (org.apache.accumulo.proxy.thrift.IteratorSetting iter : opts.iterators) {\r\n                    IteratorSetting is = new IteratorSetting(iter.getPriority(), iter.getName(), iter.getIteratorClass(), iter.getProperties());\r\n                    scanner.addScanIterator(is);\r\n                }\r\n            }\r\n            ArrayList<Range> ranges = new ArrayList<Range>();\r\n            if (opts.ranges == null) {\r\n                ranges.add(new Range());\r\n            } else {\r\n                for (org.apache.accumulo.proxy.thrift.Range range : opts.ranges) {\r\n                    Range aRange = new Range(range.getStart() == null ? null : Util.fromThrift(range.getStart()), true, range.getStop() == null ? null : Util.fromThrift(range.getStop()), false);\r\n                    ranges.add(aRange);\r\n                }\r\n            }\r\n            scanner.setRanges(ranges);\r\n        }\r\n        UUID uuid = UUID.randomUUID();\r\n        ScannerPlusIterator spi = new ScannerPlusIterator();\r\n        spi.scanner = scanner;\r\n        spi.iterator = scanner.iterator();\r\n        scannerCache.put(uuid, spi);\r\n        return uuid.toString();\r\n    } catch (Exception e) {\r\n        throw translateException(e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String createBatchScanner(ByteBuffer login, String tableName, BatchScanOptions opts) throws TException {\r\n    try {\r\n        Connector connector = getConnector(login);\r\n        int threads = 10;\r\n        Authorizations auth;\r\n        if (opts != null && opts.isSetAuthorizations()) {\r\n            auth = getAuthorizations(opts.authorizations);\r\n        } else {\r\n            auth = connector.securityOperations().getUserAuthorizations(connector.whoami());\r\n        }\r\n        if (opts != null && opts.threads > 0)\r\n            threads = opts.threads;\r\n        BatchScanner scanner = connector.createBatchScanner(tableName, auth, threads);\r\n        if (opts != null) {\r\n            if (opts.iterators != null) {\r\n                for (org.apache.accumulo.proxy.thrift.IteratorSetting iter : opts.iterators) {\r\n                    IteratorSetting is = new IteratorSetting(iter.getPriority(), iter.getName(), iter.getIteratorClass(), iter.getProperties());\r\n                    scanner.addScanIterator(is);\r\n                }\r\n            }\r\n            ArrayList<Range> ranges = new ArrayList<Range>();\r\n            if (opts.ranges == null) {\r\n                ranges.add(new Range());\r\n            } else {\r\n                for (org.apache.accumulo.proxy.thrift.Range range : opts.ranges) {\r\n                    Range aRange = new Range(range.getStart() == null ? null : Util.fromThrift(range.getStart()), true, range.getStop() == null ? null : Util.fromThrift(range.getStop()), false);\r\n                    ranges.add(aRange);\r\n                }\r\n            }\r\n            scanner.setRanges(ranges);\r\n        }\r\n        UUID uuid = UUID.randomUUID();\r\n        ScannerPlusIterator spi = new ScannerPlusIterator();\r\n        spi.scanner = scanner;\r\n        spi.iterator = scanner.iterator();\r\n        scannerCache.put(uuid, spi);\r\n        return uuid.toString();\r\n    } catch (Exception e) {\r\n        throw translateException(e);\r\n    }\r\n}","lc":1.2727272727,"pi":1.009569378,"ma":1.6,"nbd":1.0,"ml":0.9166666667,"d":0.5178571429,"mi":-0.8260747005,"fo":1.6666666667,"r":-0.0263157895,"e":1.9842602998}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3598_7c364566","label":1,"code":"\/**\r\n *  @return formatter The formatter for the current conversion\r\n *\/\r\n@Override\r\nprotected DateTimeFormatter getFormat(Locale locale) {\r\n    return DateTimeFormat.forPattern(getDatePattern(locale)).withPivotYear(2000);\r\n}","code_comment":"\/**\r\n *  @return formatter The formatter for the current conversion\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected DateTimeFormatter getFormat(Locale locale) {\r\n    return DateTimeFormat.forPattern(getDatePattern(locale)).withPivotYear(2000);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7919661734,"fo":-0.25,"r":1.6578947368,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1320_64045631","label":1,"code":"\/**\r\n * Merge all changes tracked in this builder into the underlying store.\r\n *\/\r\nNodeState merge(CommitHook hook, CommitInfo info) throws CommitFailedException {\r\n    purge();\r\n    branch.merge(hook, info);\r\n    return reset();\r\n}","code_comment":"\/**\r\n * Merge all changes tracked in this builder into the underlying store.\r\n *\/\r\n","code_no_comment":"NodeState merge(CommitHook hook, CommitInfo info) throws CommitFailedException {\r\n    purge();\r\n    branch.merge(hook, info);\r\n    return reset();\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6673713883,"fo":-0.25,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"Closure","project_version":"163","label":1,"code":"\/**\r\n * If this is a non-function prototype assign, return the prop name.\r\n * Otherwise, return null.\r\n *\/\r\n\/**\r\n * Determines whether {@code n} is the FUNCTION node in a global function\r\n * declaration.\r\n *\/\r\nprivate boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {\r\n    return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName());\r\n}","code_comment":"\/**\r\n * If this is a non-function prototype assign, return the prop name.\r\n * Otherwise, return null.\r\n *\/\r\n\/**\r\n * Determines whether {@code n} is the FUNCTION node in a global function\r\n * declaration.\r\n *\/\r\n","code_no_comment":"private boolean isGlobalFunctionDeclaration(NodeTraversal t, Node n) {\r\n    return t.inGlobalScope() && (NodeUtil.isFunctionDeclaration(n) || n.isFunction() && n.getParent().isName());\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.1011904762,"mi":0.8418604651,"fo":-0.0833333333,"r":2.5526315789,"e":-0.1183266772}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4431_7441a3d5","label":1,"code":"\/**\r\n * Provide the corresponding shared state to enable COW inform COR\r\n * about new files it is creating while indexing. This would allow COR to ignore\r\n * such files while determining the deletion candidates.\r\n *\r\n * @param defn index definition for which the directory is being created\r\n * @return a set to maintain the state of new files being created by the COW Directory\r\n *\/\r\nprivate Set<String> getSharedWorkingSet(IndexDefinition defn) {\r\n    String indexPath = defn.getIndexPathFromConfig();\r\n    Set<String> sharedSet;\r\n    synchronized (sharedWorkingSetMap) {\r\n        sharedSet = sharedWorkingSetMap.get(indexPath);\r\n        if (sharedSet == null) {\r\n            sharedSet = Sets.newConcurrentHashSet();\r\n            sharedWorkingSetMap.put(indexPath, sharedSet);\r\n        }\r\n    }\r\n    return sharedSet;\r\n}","code_comment":"\/**\r\n * Provide the corresponding shared state to enable COW inform COR\r\n * about new files it is creating while indexing. This would allow COR to ignore\r\n * such files while determining the deletion candidates.\r\n *\r\n * @param defn index definition for which the directory is being created\r\n * @return a set to maintain the state of new files being created by the COW Directory\r\n *\/\r\n","code_no_comment":"private Set<String> getSharedWorkingSet(IndexDefinition defn) {\r\n    String indexPath = defn.getIndexPathFromConfig();\r\n    Set<String> sharedSet;\r\n    synchronized (sharedWorkingSetMap) {\r\n        sharedSet = sharedWorkingSetMap.get(indexPath);\r\n        if (sharedSet == null) {\r\n            sharedSet = Sets.newConcurrentHashSet();\r\n            sharedWorkingSetMap.put(indexPath, sharedSet);\r\n        }\r\n    }\r\n    return sharedSet;\r\n}","lc":-0.0909090909,"pi":0.3971291866,"ma":-0.4,"nbd":0.0,"ml":-0.25,"d":0.005952381,"mi":0.1154334038,"fo":-0.1666666667,"r":0.1842105263,"e":-0.0502273474}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1531_21f47d9c","label":3,"code":"@Override\r\npublic void readBytes(byte[] bytes, int offset, int count) throws KryoException {\r\n    if (bytes == null) {\r\n        throw new IllegalArgumentException(\"bytes cannot be null.\");\r\n    }\r\n    try {\r\n        int bytesRead = 0;\r\n        int c;\r\n        while (true) {\r\n            c = inputStream.read(bytes, offset + bytesRead, count - bytesRead);\r\n            if (c == -1) {\r\n                throw new KryoException(\"Buffer underflow\");\r\n            }\r\n            bytesRead += c;\r\n            if (bytesRead == count) {\r\n                break;\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        throw new KryoException(ex);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void readBytes(byte[] bytes, int offset, int count) throws KryoException {\r\n    if (bytes == null) {\r\n        throw new IllegalArgumentException(\"bytes cannot be null.\");\r\n    }\r\n    try {\r\n        int bytesRead = 0;\r\n        int c;\r\n        while (true) {\r\n            c = inputStream.read(bytes, offset + bytesRead, count - bytesRead);\r\n            if (c == -1) {\r\n                throw new KryoException(\"Buffer underflow\");\r\n            }\r\n            bytesRead += c;\r\n            if (bytesRead == count) {\r\n                break;\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        throw new KryoException(ex);\r\n    }\r\n}","lc":0.3636363636,"pi":0.8373205742,"ma":1.2,"nbd":0.5,"ml":0.25,"d":0.3293650794,"mi":-0.2786469345,"fo":-0.4166666667,"r":0.1578947368,"e":0.1669150487}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-276_1bf5c550","label":1,"code":"@Override\r\npublic int sweep() throws Exception {\r\n    Timestamp ts = new Timestamp(gcStart);\r\n    Connection con = cp.getConnection();\r\n    try {\r\n        PreparedStatement stmt = con.prepareStatement(\"delete REVS where TIME < ?\");\r\n        try {\r\n            stmt.setTimestamp(1, ts);\r\n            return stmt.executeUpdate();\r\n        } finally {\r\n            stmt.close();\r\n        }\r\n    } finally {\r\n        con.close();\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int sweep() throws Exception {\r\n    Timestamp ts = new Timestamp(gcStart);\r\n    Connection con = cp.getConnection();\r\n    try {\r\n        PreparedStatement stmt = con.prepareStatement(\"delete REVS where TIME < ?\");\r\n        try {\r\n            stmt.setTimestamp(1, ts);\r\n            return stmt.executeUpdate();\r\n        } finally {\r\n            stmt.close();\r\n        }\r\n    } finally {\r\n        con.close();\r\n    }\r\n}","lc":0.0909090909,"pi":0.4832535885,"ma":-0.6,"nbd":0.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.0080338266,"fo":0.0,"r":0.2894736842,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4658_ef3adb12","label":3,"code":"@Override\r\nprotected void onDetach() {\r\n    tabsVisibilityCache = null;\r\n    super.onDetach();\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void onDetach() {\r\n    tabsVisibilityCache = null;\r\n    super.onDetach();\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8116983791,"fo":-0.4166666667,"r":1.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1985_f620b79b","label":1,"code":"\/**\r\n * Create a separate token node underneath a dedicated token store within\r\n * the user home node. That token node contains the hashed token, the\r\n * expiration time and additional mandatory attributes that will be verified\r\n * during login.\r\n *\r\n * @param userId     The identifier of the user for which a new token should\r\n *                   be created.\r\n * @param attributes The attributes associated with the new token.\r\n * @return A new {@code TokenInfo} or {@code null} if the token could not\r\n *         be created.\r\n *\/\r\n@Override\r\npublic TokenInfo createToken(String userId, Map<String, ?> attributes) {\r\n    String error = \"Failed to create login token. \";\r\n    NodeUtil tokenParent = getTokenParent(userId);\r\n    if (tokenParent != null) {\r\n        try {\r\n            long creationTime = new Date().getTime();\r\n            NodeUtil tokenNode = createTokenNode(tokenParent, creationTime);\r\n            tokenNode.setString(JcrConstants.JCR_UUID, IdentifierManager.generateUUID());\r\n            String key = generateKey(options.getConfigValue(PARAM_TOKEN_LENGTH, DEFAULT_KEY_SIZE));\r\n            String nodeId = getIdentifier(tokenNode.getTree());\r\n            String token = new StringBuilder(nodeId).append(DELIM).append(key).toString();\r\n            String keyHash = PasswordUtil.buildPasswordHash(getKeyValue(key, userId), options);\r\n            tokenNode.setString(TOKEN_ATTRIBUTE_KEY, keyHash);\r\n            long exp;\r\n            if (attributes.containsKey(PARAM_TOKEN_EXPIRATION)) {\r\n                exp = Long.parseLong(attributes.get(PARAM_TOKEN_EXPIRATION).toString());\r\n            } else {\r\n                exp = tokenExpiration;\r\n            }\r\n            long expTime = createExpirationTime(creationTime, exp);\r\n            tokenNode.setDate(TOKEN_ATTRIBUTE_EXPIRY, expTime);\r\n            for (String name : attributes.keySet()) {\r\n                if (!RESERVED_ATTRIBUTES.contains(name)) {\r\n                    String attr = attributes.get(name).toString();\r\n                    tokenNode.setString(name, attr);\r\n                }\r\n            }\r\n            root.commit();\r\n            return new TokenInfoImpl(tokenNode, token, userId);\r\n        } catch (NoSuchAlgorithmException e) {\r\n            \/\/ error while generating login token\r\n            log.error(error, e.getMessage());\r\n        } catch (UnsupportedEncodingException e) {\r\n            \/\/ error while generating login token\r\n            log.error(error, e.getMessage());\r\n        } catch (CommitFailedException e) {\r\n            \/\/ conflict while committing changes\r\n            log.warn(error, e.getMessage());\r\n        } catch (AccessDeniedException e) {\r\n            log.warn(error, e.getMessage());\r\n        }\r\n    } else {\r\n        log.warn(\"Unable to get\/create token store for user \" + userId);\r\n    }\r\n    return null;\r\n}","code_comment":"\/**\r\n * Create a separate token node underneath a dedicated token store within\r\n * the user home node. That token node contains the hashed token, the\r\n * expiration time and additional mandatory attributes that will be verified\r\n * during login.\r\n *\r\n * @param userId     The identifier of the user for which a new token should\r\n *                   be created.\r\n * @param attributes The attributes associated with the new token.\r\n * @return A new {@code TokenInfo} or {@code null} if the token could not\r\n *         be created.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic TokenInfo createToken(String userId, Map<String, ?> attributes) {\r\n    String error = \"Failed to create login token. \";\r\n    NodeUtil tokenParent = getTokenParent(userId);\r\n    if (tokenParent != null) {\r\n        try {\r\n            long creationTime = new Date().getTime();\r\n            NodeUtil tokenNode = createTokenNode(tokenParent, creationTime);\r\n            tokenNode.setString(JcrConstants.JCR_UUID, IdentifierManager.generateUUID());\r\n            String key = generateKey(options.getConfigValue(PARAM_TOKEN_LENGTH, DEFAULT_KEY_SIZE));\r\n            String nodeId = getIdentifier(tokenNode.getTree());\r\n            String token = new StringBuilder(nodeId).append(DELIM).append(key).toString();\r\n            String keyHash = PasswordUtil.buildPasswordHash(getKeyValue(key, userId), options);\r\n            tokenNode.setString(TOKEN_ATTRIBUTE_KEY, keyHash);\r\n            long exp;\r\n            if (attributes.containsKey(PARAM_TOKEN_EXPIRATION)) {\r\n                exp = Long.parseLong(attributes.get(PARAM_TOKEN_EXPIRATION).toString());\r\n            } else {\r\n                exp = tokenExpiration;\r\n            }\r\n            long expTime = createExpirationTime(creationTime, exp);\r\n            tokenNode.setDate(TOKEN_ATTRIBUTE_EXPIRY, expTime);\r\n            for (String name : attributes.keySet()) {\r\n                if (!RESERVED_ATTRIBUTES.contains(name)) {\r\n                    String attr = attributes.get(name).toString();\r\n                    tokenNode.setString(name, attr);\r\n                }\r\n            }\r\n            root.commit();\r\n            return new TokenInfoImpl(tokenNode, token, userId);\r\n        } catch (NoSuchAlgorithmException e) {\r\n                        log.error(error, e.getMessage());\r\n        } catch (UnsupportedEncodingException e) {\r\n                        log.error(error, e.getMessage());\r\n        } catch (CommitFailedException e) {\r\n                        log.warn(error, e.getMessage());\r\n        } catch (AccessDeniedException e) {\r\n            log.warn(error, e.getMessage());\r\n        }\r\n    } else {\r\n        log.warn(\"Unable to get\/create token store for user \" + userId);\r\n    }\r\n    return null;\r\n}","lc":1.3636363636,"pi":0.8229665072,"ma":1.0,"nbd":1.0,"ml":0.1666666667,"d":0.4285714286,"mi":-0.8181818182,"fo":2.5,"r":-0.0263157895,"e":1.6406332302}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1215_a9efe3c4","label":0,"code":"\/**\r\n * <b>!Test purpose only! <b>\r\n *\r\n * this creates a filter for the given query\r\n *\/\r\npublic abstract Filter createFilter(boolean preparing);","code_comment":"\/**\r\n * <b>!Test purpose only! <b>\r\n *\r\n * this creates a filter for the given query\r\n *\/\r\n","code_no_comment":"public abstract Filter createFilter(boolean preparing);","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.666384778,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2021_004db804","label":1,"code":"\/**\r\n * Get the left-hand-side expression if it is the same for\r\n * both sides. For example, for x=1 or x=2, it is x,\r\n * but for x=1 or y=2, it is null\r\n *\r\n * @return the left-hand-side expression, or null\r\n *\/\r\n@Override\r\npublic String getCommonLeftPart() {\r\n    if (left instanceof Condition && right instanceof Condition) {\r\n        String l = ((Condition) left).getCommonLeftPart();\r\n        String r = ((Condition) right).getCommonLeftPart();\r\n        if (l != null && r != null && l.equals(r)) {\r\n            return l;\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":"\/**\r\n * Get the left-hand-side expression if it is the same for\r\n * both sides. For example, for x=1 or x=2, it is x,\r\n * but for x=1 or y=2, it is null\r\n *\r\n * @return the left-hand-side expression, or null\r\n *\/\r\n","code_no_comment":"@Override\r\npublic String getCommonLeftPart() {\r\n    if (left instanceof Condition && right instanceof Condition) {\r\n        String l = ((Condition) left).getCommonLeftPart();\r\n        String r = ((Condition) right).getCommonLeftPart();\r\n        if (l != null && r != null && l.equals(r)) {\r\n            return l;\r\n        }\r\n    }\r\n    return null;\r\n}","lc":-0.1363636364,"pi":0.4114832536,"ma":-0.2,"nbd":0.0,"ml":0.4166666667,"d":0.121031746,"mi":0.1501057082,"fo":-0.25,"r":1.1578947368,"e":-0.0163044668}
{"project_name":"Chart","project_version":"1","label":2,"code":"\/**\r\n * Returns a (possibly empty) collection of legend items for the series\r\n * that this renderer is responsible for drawing.\r\n *\r\n * @return The legend item collection (never <code>null<\/code>).\r\n *\r\n * @see #getLegendItem(int, int)\r\n *\/\r\npublic LegendItemCollection getLegendItems() {\r\n    LegendItemCollection result = new LegendItemCollection();\r\n    if (this.plot == null) {\r\n        return result;\r\n    }\r\n    int index = this.plot.getIndexOf(this);\r\n    CategoryDataset dataset = this.plot.getDataset(index);\r\n    if (dataset != null) {\r\n        return result;\r\n    }\r\n    int seriesCount = dataset.getRowCount();\r\n    if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n        for (int i = 0; i < seriesCount; i++) {\r\n            if (isSeriesVisibleInLegend(i)) {\r\n                LegendItem item = getLegendItem(index, i);\r\n                if (item != null) {\r\n                    result.add(item);\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = seriesCount - 1; i >= 0; i--) {\r\n            if (isSeriesVisibleInLegend(i)) {\r\n                LegendItem item = getLegendItem(index, i);\r\n                if (item != null) {\r\n                    result.add(item);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n * Returns a (possibly empty) collection of legend items for the series\r\n * that this renderer is responsible for drawing.\r\n *\r\n * @return The legend item collection (never <code>null<\/code>).\r\n *\r\n * @see #getLegendItem(int, int)\r\n *\/\r\n","code_no_comment":"public LegendItemCollection getLegendItems() {\r\n    LegendItemCollection result = new LegendItemCollection();\r\n    if (this.plot == null) {\r\n        return result;\r\n    }\r\n    int index = this.plot.getIndexOf(this);\r\n    CategoryDataset dataset = this.plot.getDataset(index);\r\n    if (dataset != null) {\r\n        return result;\r\n    }\r\n    int seriesCount = dataset.getRowCount();\r\n    if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n        for (int i = 0; i < seriesCount; i++) {\r\n            if (isSeriesVisibleInLegend(i)) {\r\n                LegendItem item = getLegendItem(index, i);\r\n                if (item != null) {\r\n                    result.add(item);\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = seriesCount - 1; i >= 0; i--) {\r\n            if (isSeriesVisibleInLegend(i)) {\r\n                LegendItem item = getLegendItem(index, i);\r\n                if (item != null) {\r\n                    result.add(item);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}","lc":0.8181818182,"pi":1.2966507177,"ma":1.2,"nbd":1.0,"ml":0.9166666667,"d":1.6666666667,"mi":-0.5512332629,"fo":0.4166666667,"r":-0.0263157895,"e":1.7661820047}
{"project_name":"Closure","project_version":"123","label":2,"code":"void add(Node n, Context context) {\r\n    if (!cc.continueProcessing()) {\r\n        return;\r\n    }\r\n    int type = n.getType();\r\n    String opstr = NodeUtil.opToStr(type);\r\n    int childCount = n.getChildCount();\r\n    Node first = n.getFirstChild();\r\n    Node last = n.getLastChild();\r\n    \/\/ Handle all binary operators\r\n    if (opstr != null && first != last) {\r\n        Preconditions.checkState(childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\r\n        int p = NodeUtil.precedence(type);\r\n        \/\/ For right-hand-side of operations, only pass context if it's\r\n        \/\/ the IN_FOR_INIT_CLAUSE one.\r\n        Context rhsContext = getContextForNoInOperator(context);\r\n        \/\/ we can simply generate a * b * c.\r\n        if (last.getType() == type && NodeUtil.isAssociative(type)) {\r\n            addExpr(first, p, context);\r\n            cc.addOp(opstr, true);\r\n            addExpr(last, p, rhsContext);\r\n        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\r\n            \/\/ Assignments are the only right-associative binary operators\r\n            addExpr(first, p, context);\r\n            cc.addOp(opstr, true);\r\n            addExpr(last, p, rhsContext);\r\n        } else {\r\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\r\n        }\r\n        return;\r\n    }\r\n    cc.startSourceMapping(n);\r\n    switch(type) {\r\n        case Token.TRY:\r\n            {\r\n                Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());\r\n                Preconditions.checkState(childCount >= 2 && childCount <= 3);\r\n                add(\"try\");\r\n                add(first, Context.PRESERVE_BLOCK);\r\n                \/\/ second child contains the catch block, or nothing if there\r\n                \/\/ isn't a catch block\r\n                Node catchblock = first.getNext().getFirstChild();\r\n                if (catchblock != null) {\r\n                    add(catchblock);\r\n                }\r\n                if (childCount == 3) {\r\n                    add(\"finally\");\r\n                    add(last, Context.PRESERVE_BLOCK);\r\n                }\r\n                break;\r\n            }\r\n        case Token.CATCH:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"catch(\");\r\n            add(first);\r\n            add(\")\");\r\n            add(last, Context.PRESERVE_BLOCK);\r\n            break;\r\n        case Token.THROW:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"throw\");\r\n            add(first);\r\n            \/\/ Must have a ';' after a throw statement, otherwise safari can't\r\n            \/\/ parse this.\r\n            cc.endStatement(true);\r\n            break;\r\n        case Token.RETURN:\r\n            add(\"return\");\r\n            if (childCount == 1) {\r\n                add(first);\r\n            } else {\r\n                Preconditions.checkState(childCount == 0);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.VAR:\r\n            if (first != null) {\r\n                add(\"var \");\r\n                addList(first, false, getContextForNoInOperator(context));\r\n            }\r\n            break;\r\n        case Token.LABEL_NAME:\r\n            Preconditions.checkState(!n.getString().isEmpty());\r\n            addIdentifier(n.getString());\r\n            break;\r\n        case Token.NAME:\r\n            if (first == null || first.isEmpty()) {\r\n                addIdentifier(n.getString());\r\n            } else {\r\n                Preconditions.checkState(childCount == 1);\r\n                addIdentifier(n.getString());\r\n                cc.addOp(\"=\", true);\r\n                if (first.isComma()) {\r\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\r\n                } else {\r\n                    \/\/ Add expression, consider nearby code at lowest level of\r\n                    \/\/ precedence.\r\n                    addExpr(first, 0, getContextForNoInOperator(context));\r\n                }\r\n            }\r\n            break;\r\n        case Token.ARRAYLIT:\r\n            add(\"[\");\r\n            addArrayList(first);\r\n            add(\"]\");\r\n            break;\r\n        case Token.PARAM_LIST:\r\n            add(\"(\");\r\n            addList(first);\r\n            add(\")\");\r\n            break;\r\n        case Token.COMMA:\r\n            Preconditions.checkState(childCount == 2);\r\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, getContextForNoInOperator(context), 0, 0);\r\n            break;\r\n        case Token.NUMBER:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addNumber(n.getDouble());\r\n            break;\r\n        case Token.TYPEOF:\r\n        case Token.VOID:\r\n        case Token.NOT:\r\n        case Token.BITNOT:\r\n        case Token.POS:\r\n            {\r\n                \/\/ All of these unary operators are right-associative\r\n                Preconditions.checkState(childCount == 1);\r\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\r\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\r\n                break;\r\n            }\r\n        case Token.NEG:\r\n            {\r\n                Preconditions.checkState(childCount == 1);\r\n                \/\/ NEG is a weird case because Rhino parses \"- -2\" as \"2\".\r\n                if (n.getFirstChild().isNumber()) {\r\n                    cc.addNumber(-n.getFirstChild().getDouble());\r\n                } else {\r\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\r\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\r\n                }\r\n                break;\r\n            }\r\n        case Token.HOOK:\r\n            {\r\n                Preconditions.checkState(childCount == 3);\r\n                int p = NodeUtil.precedence(type);\r\n                Context rhsContext = Context.OTHER;\r\n                addExpr(first, p + 1, context);\r\n                cc.addOp(\"?\", true);\r\n                addExpr(first.getNext(), 1, rhsContext);\r\n                cc.addOp(\":\", true);\r\n                addExpr(last, 1, rhsContext);\r\n                break;\r\n            }\r\n        case Token.REGEXP:\r\n            if (!first.isString() || !last.isString()) {\r\n                throw new Error(\"Expected children to be strings\");\r\n            }\r\n            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\r\n            \/\/ I only use one .add because whitespace matters\r\n            if (childCount == 2) {\r\n                add(regexp + last.getString());\r\n            } else {\r\n                Preconditions.checkState(childCount == 1);\r\n                add(regexp);\r\n            }\r\n            break;\r\n        case Token.FUNCTION:\r\n            if (n.getClass() != Node.class) {\r\n                throw new Error(\"Unexpected Node subclass.\");\r\n            }\r\n            Preconditions.checkState(childCount == 3);\r\n            boolean funcNeedsParens = (context == Context.START_OF_EXPR);\r\n            if (funcNeedsParens) {\r\n                add(\"(\");\r\n            }\r\n            add(\"function\");\r\n            add(first);\r\n            add(first.getNext());\r\n            add(last, Context.PRESERVE_BLOCK);\r\n            cc.endFunction(context == Context.STATEMENT);\r\n            if (funcNeedsParens) {\r\n                add(\")\");\r\n            }\r\n            break;\r\n        case Token.GETTER_DEF:\r\n        case Token.SETTER_DEF:\r\n            Preconditions.checkState(n.getParent().isObjectLit());\r\n            Preconditions.checkState(childCount == 1);\r\n            Preconditions.checkState(first.isFunction());\r\n            \/\/ Get methods are unnamed\r\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\r\n            if (type == Token.GETTER_DEF) {\r\n                \/\/ Get methods have no parameters.\r\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\r\n                add(\"get \");\r\n            } else {\r\n                \/\/ Set methods have one parameter.\r\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\r\n                add(\"set \");\r\n            }\r\n            \/\/ The name is on the GET or SET node.\r\n            String name = n.getString();\r\n            Node fn = first;\r\n            Node parameters = fn.getChildAtIndex(1);\r\n            Node body = fn.getLastChild();\r\n            \/\/ Add the property name.\r\n            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && \/\/ Unicode escaped.\r\n            NodeUtil.isLatin(name)) {\r\n                add(name);\r\n            } else {\r\n                \/\/ Determine if the string is a simple number.\r\n                double d = getSimpleNumber(name);\r\n                if (!Double.isNaN(d)) {\r\n                    cc.addNumber(d);\r\n                } else {\r\n                    addJsString(n);\r\n                }\r\n            }\r\n            add(parameters);\r\n            add(body, Context.PRESERVE_BLOCK);\r\n            break;\r\n        case Token.SCRIPT:\r\n        case Token.BLOCK:\r\n            {\r\n                if (n.getClass() != Node.class) {\r\n                    throw new Error(\"Unexpected Node subclass.\");\r\n                }\r\n                boolean preserveBlock = context == Context.PRESERVE_BLOCK;\r\n                if (preserveBlock) {\r\n                    cc.beginBlock();\r\n                }\r\n                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());\r\n                for (Node c = first; c != null; c = c.getNext()) {\r\n                    add(c, Context.STATEMENT);\r\n                    \/\/ VAR doesn't include ';' since it gets used in expressions\r\n                    if (c.isVar()) {\r\n                        cc.endStatement();\r\n                    }\r\n                    if (c.isFunction()) {\r\n                        cc.maybeLineBreak();\r\n                    }\r\n                    \/\/ because top-level statements are more homogeneous.\r\n                    if (preferLineBreaks) {\r\n                        cc.notePreferredLineBreak();\r\n                    }\r\n                }\r\n                if (preserveBlock) {\r\n                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\r\n                }\r\n                break;\r\n            }\r\n        case Token.FOR:\r\n            if (childCount == 4) {\r\n                add(\"for(\");\r\n                if (first.isVar()) {\r\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\r\n                } else {\r\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\r\n                }\r\n                add(\";\");\r\n                add(first.getNext());\r\n                add(\";\");\r\n                add(first.getNext().getNext());\r\n                add(\")\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            } else {\r\n                Preconditions.checkState(childCount == 3);\r\n                add(\"for(\");\r\n                add(first);\r\n                add(\"in\");\r\n                add(first.getNext());\r\n                add(\")\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            }\r\n            break;\r\n        case Token.DO:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"do\");\r\n            addNonEmptyStatement(first, Context.OTHER, false);\r\n            add(\"while(\");\r\n            add(last);\r\n            add(\")\");\r\n            cc.endStatement();\r\n            break;\r\n        case Token.WHILE:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"while(\");\r\n            add(first);\r\n            add(\")\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            break;\r\n        case Token.EMPTY:\r\n            Preconditions.checkState(childCount == 0);\r\n            break;\r\n        case Token.GETPROP:\r\n            {\r\n                Preconditions.checkState(childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\r\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\r\n                boolean needsParens = (first.isNumber());\r\n                if (needsParens) {\r\n                    add(\"(\");\r\n                }\r\n                addExpr(first, NodeUtil.precedence(type), context);\r\n                if (needsParens) {\r\n                    add(\")\");\r\n                }\r\n                if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {\r\n                    \/\/ Check for ECMASCRIPT3 keywords.\r\n                    add(\"[\");\r\n                    add(last);\r\n                    add(\"]\");\r\n                } else {\r\n                    add(\".\");\r\n                    addIdentifier(last.getString());\r\n                }\r\n                break;\r\n            }\r\n        case Token.GETELEM:\r\n            Preconditions.checkState(childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\r\n            addExpr(first, NodeUtil.precedence(type), context);\r\n            add(\"[\");\r\n            add(first.getNext());\r\n            add(\"]\");\r\n            break;\r\n        case Token.WITH:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"with(\");\r\n            add(first);\r\n            add(\")\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            break;\r\n        case Token.INC:\r\n        case Token.DEC:\r\n            {\r\n                Preconditions.checkState(childCount == 1);\r\n                String o = type == Token.INC ? \"++\" : \"--\";\r\n                int postProp = n.getIntProp(Node.INCRDECR_PROP);\r\n                \/\/ is a pre-inc\/dec.\r\n                if (postProp != 0) {\r\n                    addExpr(first, NodeUtil.precedence(type), context);\r\n                    cc.addOp(o, false);\r\n                } else {\r\n                    cc.addOp(o, false);\r\n                    add(first);\r\n                }\r\n                break;\r\n            }\r\n        case Token.CALL:\r\n            \/\/ that must be preserved.\r\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\r\n                add(\"(0,\");\r\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\r\n                add(\")\");\r\n            } else {\r\n                addExpr(first, NodeUtil.precedence(type), context);\r\n            }\r\n            add(\"(\");\r\n            addList(first.getNext());\r\n            add(\")\");\r\n            break;\r\n        case Token.IF:\r\n            boolean hasElse = childCount == 3;\r\n            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;\r\n            if (ambiguousElseClause) {\r\n                cc.beginBlock();\r\n            }\r\n            add(\"if(\");\r\n            add(first);\r\n            add(\")\");\r\n            if (hasElse) {\r\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\r\n                add(\"else\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            } else {\r\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\r\n                Preconditions.checkState(childCount == 2);\r\n            }\r\n            if (ambiguousElseClause) {\r\n                cc.endBlock();\r\n            }\r\n            break;\r\n        case Token.NULL:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addConstant(\"null\");\r\n            break;\r\n        case Token.THIS:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"this\");\r\n            break;\r\n        case Token.FALSE:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addConstant(\"false\");\r\n            break;\r\n        case Token.TRUE:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addConstant(\"true\");\r\n            break;\r\n        case Token.CONTINUE:\r\n            Preconditions.checkState(childCount <= 1);\r\n            add(\"continue\");\r\n            if (childCount == 1) {\r\n                if (!first.isLabelName()) {\r\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n                }\r\n                add(\" \");\r\n                add(first);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.DEBUGGER:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"debugger\");\r\n            cc.endStatement();\r\n            break;\r\n        case Token.BREAK:\r\n            Preconditions.checkState(childCount <= 1);\r\n            add(\"break\");\r\n            if (childCount == 1) {\r\n                if (!first.isLabelName()) {\r\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n                }\r\n                add(\" \");\r\n                add(first);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.EXPR_RESULT:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(first, Context.START_OF_EXPR);\r\n            cc.endStatement();\r\n            break;\r\n        case Token.NEW:\r\n            add(\"new \");\r\n            int precedence = NodeUtil.precedence(type);\r\n            \/\/ first viable parentheses (don't traverse into functions).\r\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\r\n                precedence = NodeUtil.precedence(first.getType()) + 1;\r\n            }\r\n            addExpr(first, precedence, Context.OTHER);\r\n            \/\/ '()' is optional when no arguments are present\r\n            Node next = first.getNext();\r\n            if (next != null) {\r\n                add(\"(\");\r\n                addList(next);\r\n                add(\")\");\r\n            }\r\n            break;\r\n        case Token.STRING_KEY:\r\n            Preconditions.checkState(childCount == 1, \"Object lit key must have 1 child\");\r\n            addJsString(n);\r\n            break;\r\n        case Token.STRING:\r\n            Preconditions.checkState(childCount == 0, \"A string may not have children\");\r\n            addJsString(n);\r\n            break;\r\n        case Token.DELPROP:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"delete \");\r\n            add(first);\r\n            break;\r\n        case Token.OBJECTLIT:\r\n            {\r\n                boolean needsParens = (context == Context.START_OF_EXPR);\r\n                if (needsParens) {\r\n                    add(\"(\");\r\n                }\r\n                add(\"{\");\r\n                for (Node c = first; c != null; c = c.getNext()) {\r\n                    if (c != first) {\r\n                        cc.listSeparator();\r\n                    }\r\n                    if (c.isGetterDef() || c.isSetterDef()) {\r\n                        add(c);\r\n                    } else {\r\n                        Preconditions.checkState(c.isStringKey());\r\n                        String key = c.getString();\r\n                        \/\/ are not JavaScript keywords\r\n                        if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) && \/\/ were Unicode escaped.\r\n                        NodeUtil.isLatin(key)) {\r\n                            add(key);\r\n                        } else {\r\n                            \/\/ Determine if the string is a simple number.\r\n                            double d = getSimpleNumber(key);\r\n                            if (!Double.isNaN(d)) {\r\n                                cc.addNumber(d);\r\n                            } else {\r\n                                addExpr(c, 1, Context.OTHER);\r\n                            }\r\n                        }\r\n                        add(\":\");\r\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\r\n                    }\r\n                }\r\n                add(\"}\");\r\n                if (needsParens) {\r\n                    add(\")\");\r\n                }\r\n                break;\r\n            }\r\n        case Token.SWITCH:\r\n            add(\"switch(\");\r\n            add(first);\r\n            add(\")\");\r\n            cc.beginBlock();\r\n            addAllSiblings(first.getNext());\r\n            cc.endBlock(context == Context.STATEMENT);\r\n            break;\r\n        case Token.CASE:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"case \");\r\n            add(first);\r\n            addCaseBody(last);\r\n            break;\r\n        case Token.DEFAULT_CASE:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"default\");\r\n            addCaseBody(first);\r\n            break;\r\n        case Token.LABEL:\r\n            Preconditions.checkState(childCount == 2);\r\n            if (!first.isLabelName()) {\r\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n            }\r\n            add(first);\r\n            add(\":\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\r\n            break;\r\n        case Token.CAST:\r\n            add(\"(\");\r\n            add(first);\r\n            add(\")\");\r\n            break;\r\n        default:\r\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\r\n    }\r\n    cc.endSourceMapping(n);\r\n}","code_comment":null,"code_no_comment":"void add(Node n, Context context) {\r\n    if (!cc.continueProcessing()) {\r\n        return;\r\n    }\r\n    int type = n.getType();\r\n    String opstr = NodeUtil.opToStr(type);\r\n    int childCount = n.getChildCount();\r\n    Node first = n.getFirstChild();\r\n    Node last = n.getLastChild();\r\n        if (opstr != null && first != last) {\r\n        Preconditions.checkState(childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\r\n        int p = NodeUtil.precedence(type);\r\n                        Context rhsContext = getContextForNoInOperator(context);\r\n                if (last.getType() == type && NodeUtil.isAssociative(type)) {\r\n            addExpr(first, p, context);\r\n            cc.addOp(opstr, true);\r\n            addExpr(last, p, rhsContext);\r\n        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\r\n                        addExpr(first, p, context);\r\n            cc.addOp(opstr, true);\r\n            addExpr(last, p, rhsContext);\r\n        } else {\r\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\r\n        }\r\n        return;\r\n    }\r\n    cc.startSourceMapping(n);\r\n    switch(type) {\r\n        case Token.TRY:\r\n            {\r\n                Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());\r\n                Preconditions.checkState(childCount >= 2 && childCount <= 3);\r\n                add(\"try\");\r\n                add(first, Context.PRESERVE_BLOCK);\r\n                                                Node catchblock = first.getNext().getFirstChild();\r\n                if (catchblock != null) {\r\n                    add(catchblock);\r\n                }\r\n                if (childCount == 3) {\r\n                    add(\"finally\");\r\n                    add(last, Context.PRESERVE_BLOCK);\r\n                }\r\n                break;\r\n            }\r\n        case Token.CATCH:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"catch(\");\r\n            add(first);\r\n            add(\")\");\r\n            add(last, Context.PRESERVE_BLOCK);\r\n            break;\r\n        case Token.THROW:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"throw\");\r\n            add(first);\r\n                                    cc.endStatement(true);\r\n            break;\r\n        case Token.RETURN:\r\n            add(\"return\");\r\n            if (childCount == 1) {\r\n                add(first);\r\n            } else {\r\n                Preconditions.checkState(childCount == 0);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.VAR:\r\n            if (first != null) {\r\n                add(\"var \");\r\n                addList(first, false, getContextForNoInOperator(context));\r\n            }\r\n            break;\r\n        case Token.LABEL_NAME:\r\n            Preconditions.checkState(!n.getString().isEmpty());\r\n            addIdentifier(n.getString());\r\n            break;\r\n        case Token.NAME:\r\n            if (first == null || first.isEmpty()) {\r\n                addIdentifier(n.getString());\r\n            } else {\r\n                Preconditions.checkState(childCount == 1);\r\n                addIdentifier(n.getString());\r\n                cc.addOp(\"=\", true);\r\n                if (first.isComma()) {\r\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\r\n                } else {\r\n                                                            addExpr(first, 0, getContextForNoInOperator(context));\r\n                }\r\n            }\r\n            break;\r\n        case Token.ARRAYLIT:\r\n            add(\"[\");\r\n            addArrayList(first);\r\n            add(\"]\");\r\n            break;\r\n        case Token.PARAM_LIST:\r\n            add(\"(\");\r\n            addList(first);\r\n            add(\")\");\r\n            break;\r\n        case Token.COMMA:\r\n            Preconditions.checkState(childCount == 2);\r\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, getContextForNoInOperator(context), 0, 0);\r\n            break;\r\n        case Token.NUMBER:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addNumber(n.getDouble());\r\n            break;\r\n        case Token.TYPEOF:\r\n        case Token.VOID:\r\n        case Token.NOT:\r\n        case Token.BITNOT:\r\n        case Token.POS:\r\n            {\r\n                                Preconditions.checkState(childCount == 1);\r\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\r\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\r\n                break;\r\n            }\r\n        case Token.NEG:\r\n            {\r\n                Preconditions.checkState(childCount == 1);\r\n                                if (n.getFirstChild().isNumber()) {\r\n                    cc.addNumber(-n.getFirstChild().getDouble());\r\n                } else {\r\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\r\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\r\n                }\r\n                break;\r\n            }\r\n        case Token.HOOK:\r\n            {\r\n                Preconditions.checkState(childCount == 3);\r\n                int p = NodeUtil.precedence(type);\r\n                Context rhsContext = Context.OTHER;\r\n                addExpr(first, p + 1, context);\r\n                cc.addOp(\"?\", true);\r\n                addExpr(first.getNext(), 1, rhsContext);\r\n                cc.addOp(\":\", true);\r\n                addExpr(last, 1, rhsContext);\r\n                break;\r\n            }\r\n        case Token.REGEXP:\r\n            if (!first.isString() || !last.isString()) {\r\n                throw new Error(\"Expected children to be strings\");\r\n            }\r\n            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\r\n                        if (childCount == 2) {\r\n                add(regexp + last.getString());\r\n            } else {\r\n                Preconditions.checkState(childCount == 1);\r\n                add(regexp);\r\n            }\r\n            break;\r\n        case Token.FUNCTION:\r\n            if (n.getClass() != Node.class) {\r\n                throw new Error(\"Unexpected Node subclass.\");\r\n            }\r\n            Preconditions.checkState(childCount == 3);\r\n            boolean funcNeedsParens = (context == Context.START_OF_EXPR);\r\n            if (funcNeedsParens) {\r\n                add(\"(\");\r\n            }\r\n            add(\"function\");\r\n            add(first);\r\n            add(first.getNext());\r\n            add(last, Context.PRESERVE_BLOCK);\r\n            cc.endFunction(context == Context.STATEMENT);\r\n            if (funcNeedsParens) {\r\n                add(\")\");\r\n            }\r\n            break;\r\n        case Token.GETTER_DEF:\r\n        case Token.SETTER_DEF:\r\n            Preconditions.checkState(n.getParent().isObjectLit());\r\n            Preconditions.checkState(childCount == 1);\r\n            Preconditions.checkState(first.isFunction());\r\n                        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\r\n            if (type == Token.GETTER_DEF) {\r\n                                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\r\n                add(\"get \");\r\n            } else {\r\n                                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\r\n                add(\"set \");\r\n            }\r\n                        String name = n.getString();\r\n            Node fn = first;\r\n            Node parameters = fn.getChildAtIndex(1);\r\n            Node body = fn.getLastChild();\r\n                        if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) &&             NodeUtil.isLatin(name)) {\r\n                add(name);\r\n            } else {\r\n                                double d = getSimpleNumber(name);\r\n                if (!Double.isNaN(d)) {\r\n                    cc.addNumber(d);\r\n                } else {\r\n                    addJsString(n);\r\n                }\r\n            }\r\n            add(parameters);\r\n            add(body, Context.PRESERVE_BLOCK);\r\n            break;\r\n        case Token.SCRIPT:\r\n        case Token.BLOCK:\r\n            {\r\n                if (n.getClass() != Node.class) {\r\n                    throw new Error(\"Unexpected Node subclass.\");\r\n                }\r\n                boolean preserveBlock = context == Context.PRESERVE_BLOCK;\r\n                if (preserveBlock) {\r\n                    cc.beginBlock();\r\n                }\r\n                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());\r\n                for (Node c = first; c != null; c = c.getNext()) {\r\n                    add(c, Context.STATEMENT);\r\n                                        if (c.isVar()) {\r\n                        cc.endStatement();\r\n                    }\r\n                    if (c.isFunction()) {\r\n                        cc.maybeLineBreak();\r\n                    }\r\n                                        if (preferLineBreaks) {\r\n                        cc.notePreferredLineBreak();\r\n                    }\r\n                }\r\n                if (preserveBlock) {\r\n                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\r\n                }\r\n                break;\r\n            }\r\n        case Token.FOR:\r\n            if (childCount == 4) {\r\n                add(\"for(\");\r\n                if (first.isVar()) {\r\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\r\n                } else {\r\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\r\n                }\r\n                add(\";\");\r\n                add(first.getNext());\r\n                add(\";\");\r\n                add(first.getNext().getNext());\r\n                add(\")\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            } else {\r\n                Preconditions.checkState(childCount == 3);\r\n                add(\"for(\");\r\n                add(first);\r\n                add(\"in\");\r\n                add(first.getNext());\r\n                add(\")\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            }\r\n            break;\r\n        case Token.DO:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"do\");\r\n            addNonEmptyStatement(first, Context.OTHER, false);\r\n            add(\"while(\");\r\n            add(last);\r\n            add(\")\");\r\n            cc.endStatement();\r\n            break;\r\n        case Token.WHILE:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"while(\");\r\n            add(first);\r\n            add(\")\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            break;\r\n        case Token.EMPTY:\r\n            Preconditions.checkState(childCount == 0);\r\n            break;\r\n        case Token.GETPROP:\r\n            {\r\n                Preconditions.checkState(childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\r\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\r\n                boolean needsParens = (first.isNumber());\r\n                if (needsParens) {\r\n                    add(\"(\");\r\n                }\r\n                addExpr(first, NodeUtil.precedence(type), context);\r\n                if (needsParens) {\r\n                    add(\")\");\r\n                }\r\n                if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {\r\n                                        add(\"[\");\r\n                    add(last);\r\n                    add(\"]\");\r\n                } else {\r\n                    add(\".\");\r\n                    addIdentifier(last.getString());\r\n                }\r\n                break;\r\n            }\r\n        case Token.GETELEM:\r\n            Preconditions.checkState(childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\r\n            addExpr(first, NodeUtil.precedence(type), context);\r\n            add(\"[\");\r\n            add(first.getNext());\r\n            add(\"]\");\r\n            break;\r\n        case Token.WITH:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"with(\");\r\n            add(first);\r\n            add(\")\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            break;\r\n        case Token.INC:\r\n        case Token.DEC:\r\n            {\r\n                Preconditions.checkState(childCount == 1);\r\n                String o = type == Token.INC ? \"++\" : \"--\";\r\n                int postProp = n.getIntProp(Node.INCRDECR_PROP);\r\n                                if (postProp != 0) {\r\n                    addExpr(first, NodeUtil.precedence(type), context);\r\n                    cc.addOp(o, false);\r\n                } else {\r\n                    cc.addOp(o, false);\r\n                    add(first);\r\n                }\r\n                break;\r\n            }\r\n        case Token.CALL:\r\n                        if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\r\n                add(\"(0,\");\r\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\r\n                add(\")\");\r\n            } else {\r\n                addExpr(first, NodeUtil.precedence(type), context);\r\n            }\r\n            add(\"(\");\r\n            addList(first.getNext());\r\n            add(\")\");\r\n            break;\r\n        case Token.IF:\r\n            boolean hasElse = childCount == 3;\r\n            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;\r\n            if (ambiguousElseClause) {\r\n                cc.beginBlock();\r\n            }\r\n            add(\"if(\");\r\n            add(first);\r\n            add(\")\");\r\n            if (hasElse) {\r\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\r\n                add(\"else\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            } else {\r\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\r\n                Preconditions.checkState(childCount == 2);\r\n            }\r\n            if (ambiguousElseClause) {\r\n                cc.endBlock();\r\n            }\r\n            break;\r\n        case Token.NULL:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addConstant(\"null\");\r\n            break;\r\n        case Token.THIS:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"this\");\r\n            break;\r\n        case Token.FALSE:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addConstant(\"false\");\r\n            break;\r\n        case Token.TRUE:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addConstant(\"true\");\r\n            break;\r\n        case Token.CONTINUE:\r\n            Preconditions.checkState(childCount <= 1);\r\n            add(\"continue\");\r\n            if (childCount == 1) {\r\n                if (!first.isLabelName()) {\r\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n                }\r\n                add(\" \");\r\n                add(first);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.DEBUGGER:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"debugger\");\r\n            cc.endStatement();\r\n            break;\r\n        case Token.BREAK:\r\n            Preconditions.checkState(childCount <= 1);\r\n            add(\"break\");\r\n            if (childCount == 1) {\r\n                if (!first.isLabelName()) {\r\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n                }\r\n                add(\" \");\r\n                add(first);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.EXPR_RESULT:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(first, Context.START_OF_EXPR);\r\n            cc.endStatement();\r\n            break;\r\n        case Token.NEW:\r\n            add(\"new \");\r\n            int precedence = NodeUtil.precedence(type);\r\n                        if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\r\n                precedence = NodeUtil.precedence(first.getType()) + 1;\r\n            }\r\n            addExpr(first, precedence, Context.OTHER);\r\n                        Node next = first.getNext();\r\n            if (next != null) {\r\n                add(\"(\");\r\n                addList(next);\r\n                add(\")\");\r\n            }\r\n            break;\r\n        case Token.STRING_KEY:\r\n            Preconditions.checkState(childCount == 1, \"Object lit key must have 1 child\");\r\n            addJsString(n);\r\n            break;\r\n        case Token.STRING:\r\n            Preconditions.checkState(childCount == 0, \"A string may not have children\");\r\n            addJsString(n);\r\n            break;\r\n        case Token.DELPROP:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"delete \");\r\n            add(first);\r\n            break;\r\n        case Token.OBJECTLIT:\r\n            {\r\n                boolean needsParens = (context == Context.START_OF_EXPR);\r\n                if (needsParens) {\r\n                    add(\"(\");\r\n                }\r\n                add(\"{\");\r\n                for (Node c = first; c != null; c = c.getNext()) {\r\n                    if (c != first) {\r\n                        cc.listSeparator();\r\n                    }\r\n                    if (c.isGetterDef() || c.isSetterDef()) {\r\n                        add(c);\r\n                    } else {\r\n                        Preconditions.checkState(c.isStringKey());\r\n                        String key = c.getString();\r\n                                                if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) &&                         NodeUtil.isLatin(key)) {\r\n                            add(key);\r\n                        } else {\r\n                                                        double d = getSimpleNumber(key);\r\n                            if (!Double.isNaN(d)) {\r\n                                cc.addNumber(d);\r\n                            } else {\r\n                                addExpr(c, 1, Context.OTHER);\r\n                            }\r\n                        }\r\n                        add(\":\");\r\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\r\n                    }\r\n                }\r\n                add(\"}\");\r\n                if (needsParens) {\r\n                    add(\")\");\r\n                }\r\n                break;\r\n            }\r\n        case Token.SWITCH:\r\n            add(\"switch(\");\r\n            add(first);\r\n            add(\")\");\r\n            cc.beginBlock();\r\n            addAllSiblings(first.getNext());\r\n            cc.endBlock(context == Context.STATEMENT);\r\n            break;\r\n        case Token.CASE:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"case \");\r\n            add(first);\r\n            addCaseBody(last);\r\n            break;\r\n        case Token.DEFAULT_CASE:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"default\");\r\n            addCaseBody(first);\r\n            break;\r\n        case Token.LABEL:\r\n            Preconditions.checkState(childCount == 2);\r\n            if (!first.isLabelName()) {\r\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n            }\r\n            add(first);\r\n            add(\":\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\r\n            break;\r\n        case Token.CAST:\r\n            add(\"(\");\r\n            add(first);\r\n            add(\")\");\r\n            break;\r\n        default:\r\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\r\n    }\r\n    cc.endSourceMapping(n);\r\n}","lc":22.5454545455,"pi":0.6650717703,"ma":31.0,"nbd":2.0,"ml":13.8333333333,"d":4.6666666667,"mi":-3.259901339,"fo":29.1666666667,"r":-0.0263157895,"e":124.6451917037}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"@Override\r\npublic boolean hasNext() {\r\n    return c.hasNext();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean hasNext() {\r\n    return c.hasNext();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0005637773,"fo":-0.4166666667,"r":2.0263157895,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-581_bb02fa15","label":1,"code":"private boolean rollover(final RolloverStrategy strategy) {\r\n    try {\r\n        \/\/ Block until the asynchronous operation is completed.\r\n        semaphore.acquire();\r\n    } catch (final InterruptedException ie) {\r\n        LOGGER.error(\"Thread interrupted while attempting to check rollover\", ie);\r\n        return false;\r\n    }\r\n    boolean success = false;\r\n    Thread thread = null;\r\n    try {\r\n        final RolloverDescription descriptor = strategy.rollover(this);\r\n        if (descriptor != null) {\r\n            close();\r\n            if (descriptor.getSynchronous() != null) {\r\n                LOGGER.debug(\"RollingFileManager executing synchronous {}\", descriptor.getSynchronous());\r\n                try {\r\n                    success = descriptor.getSynchronous().execute();\r\n                } catch (final Exception ex) {\r\n                    LOGGER.error(\"Error in synchronous task\", ex);\r\n                }\r\n            }\r\n            if (success && descriptor.getAsynchronous() != null) {\r\n                LOGGER.debug(\"RollingFileManager executing async {}\", descriptor.getAsynchronous());\r\n                thread = new Thread(new AsyncAction(descriptor.getAsynchronous(), this));\r\n                thread.start();\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    } finally {\r\n        if (thread == null) {\r\n            semaphore.release();\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private boolean rollover(final RolloverStrategy strategy) {\r\n    try {\r\n                semaphore.acquire();\r\n    } catch (final InterruptedException ie) {\r\n        LOGGER.error(\"Thread interrupted while attempting to check rollover\", ie);\r\n        return false;\r\n    }\r\n    boolean success = false;\r\n    Thread thread = null;\r\n    try {\r\n        final RolloverDescription descriptor = strategy.rollover(this);\r\n        if (descriptor != null) {\r\n            close();\r\n            if (descriptor.getSynchronous() != null) {\r\n                LOGGER.debug(\"RollingFileManager executing synchronous {}\", descriptor.getSynchronous());\r\n                try {\r\n                    success = descriptor.getSynchronous().execute();\r\n                } catch (final Exception ex) {\r\n                    LOGGER.error(\"Error in synchronous task\", ex);\r\n                }\r\n            }\r\n            if (success && descriptor.getAsynchronous() != null) {\r\n                LOGGER.debug(\"RollingFileManager executing async {}\", descriptor.getAsynchronous());\r\n                thread = new Thread(new AsyncAction(descriptor.getAsynchronous(), this));\r\n                thread.start();\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    } finally {\r\n        if (thread == null) {\r\n            semaphore.release();\r\n        }\r\n    }\r\n}","lc":0.9545454545,"pi":1.1291866029,"ma":0.6,"nbd":1.0,"ml":0.4166666667,"d":0.4404761905,"mi":-0.5650458069,"fo":0.8333333333,"r":-0.0263157895,"e":0.563431937}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-633_8dad5e0f","label":3,"code":"@Override\r\npublic void seek(Range range, Collection<ByteSequence> columnFamilies, boolean inclusive) throws IOException {\r\n    \/\/ save parameters for future internal seeks\r\n    latestRange = range;\r\n    latestColumnFamilies = columnFamilies;\r\n    latestInclusive = inclusive;\r\n    \/\/ seek to first possible pattern in range\r\n    super.seek(range, columnFamilies, inclusive);\r\n    lastRowFound = getSource().hasTop() ? getSource().getTopKey().getRow() : null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void seek(Range range, Collection<ByteSequence> columnFamilies, boolean inclusive) throws IOException {\r\n        latestRange = range;\r\n    latestColumnFamilies = columnFamilies;\r\n    latestInclusive = inclusive;\r\n        super.seek(range, columnFamilies, inclusive);\r\n    lastRowFound = getSource().hasTop() ? getSource().getTopKey().getRow() : null;\r\n}","lc":-0.2727272727,"pi":-0.5023923445,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.3650793651,"mi":0.2972515856,"fo":0.0,"r":0.2368421053,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3549_9772f5b2","label":1,"code":"void backgroundRead() {\r\n    nodeStore.backgroundRead(true);\r\n}","code_comment":null,"code_no_comment":"void backgroundRead() {\r\n    nodeStore.backgroundRead(true);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1319238901,"fo":-0.4166666667,"r":0.8157894737,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-366_db4a291f","label":1,"code":"@Override\r\npublic void compact(TInfo tinfo, AuthInfo credentials, String lock, String tableId, ByteBuffer startRow, ByteBuffer endRow) throws TException {\r\n    try {\r\n        if (!authenticator.hasSystemPermission(credentials, credentials.user, SystemPermission.SYSTEM))\r\n            throw new ThriftSecurityException(credentials.user, SecurityErrorCode.PERMISSION_DENIED);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    KeyExtent ke = new KeyExtent(new Text(tableId), ByteBufferUtil.toText(endRow), ByteBufferUtil.toText(startRow));\r\n    ArrayList<Tablet> tabletsToCompact = new ArrayList<Tablet>();\r\n    synchronized (onlineTablets) {\r\n        for (Tablet tablet : onlineTablets.values()) if (ke.overlaps(tablet.getExtent()))\r\n            tabletsToCompact.add(tablet);\r\n    }\r\n    Long compactionId = null;\r\n    for (Tablet tablet : tabletsToCompact) {\r\n        \/\/ compaction id once\r\n        if (compactionId == null)\r\n            compactionId = tablet.getCompactionID();\r\n        tablet.compactAll(compactionId);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void compact(TInfo tinfo, AuthInfo credentials, String lock, String tableId, ByteBuffer startRow, ByteBuffer endRow) throws TException {\r\n    try {\r\n        if (!authenticator.hasSystemPermission(credentials, credentials.user, SystemPermission.SYSTEM))\r\n            throw new ThriftSecurityException(credentials.user, SecurityErrorCode.PERMISSION_DENIED);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    KeyExtent ke = new KeyExtent(new Text(tableId), ByteBufferUtil.toText(endRow), ByteBufferUtil.toText(startRow));\r\n    ArrayList<Tablet> tabletsToCompact = new ArrayList<Tablet>();\r\n    synchronized (onlineTablets) {\r\n        for (Tablet tablet : onlineTablets.values()) if (ke.overlaps(tablet.getExtent()))\r\n            tabletsToCompact.add(tablet);\r\n    }\r\n    Long compactionId = null;\r\n    for (Tablet tablet : tabletsToCompact) {\r\n                if (compactionId == null)\r\n            compactionId = tablet.getCompactionID();\r\n        tablet.compactAll(compactionId);\r\n    }\r\n}","lc":0.3181818182,"pi":0.2870813397,"ma":1.0,"nbd":-0.5,"ml":0.3333333333,"d":-0.0317460317,"mi":-0.3646229739,"fo":0.25,"r":-0.0263157895,"e":0.1817557327}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-225_e33328e0","label":3,"code":"private void read() throws ParseException {\r\n    currentTokenQuoted = false;\r\n    if (expected != null) {\r\n        expected.clear();\r\n    }\r\n    int[] types = characterTypes;\r\n    int i = parseIndex;\r\n    int type = types[i];\r\n    while (type == 0) {\r\n        type = types[++i];\r\n    }\r\n    int start = i;\r\n    char[] chars = statementChars;\r\n    char c = chars[i++];\r\n    currentToken = \"\";\r\n    switch(type) {\r\n        case CHAR_NAME:\r\n            while (true) {\r\n                type = types[i];\r\n                if (type != CHAR_NAME && type != CHAR_VALUE) {\r\n                    c = chars[i];\r\n                    break;\r\n                }\r\n                i++;\r\n            }\r\n            currentToken = statement.substring(start, i);\r\n            if (currentToken.isEmpty()) {\r\n                throw getSyntaxError();\r\n            }\r\n            currentTokenType = IDENTIFIER;\r\n            parseIndex = i;\r\n            return;\r\n        case CHAR_SPECIAL_2:\r\n            if (types[i] == CHAR_SPECIAL_2) {\r\n                i++;\r\n            }\r\n        \/\/ fall through\r\n        case CHAR_SPECIAL_1:\r\n            currentToken = statement.substring(start, i);\r\n            switch(c) {\r\n                case '+':\r\n                    currentTokenType = PLUS;\r\n                    break;\r\n                case '-':\r\n                    currentTokenType = MINUS;\r\n                    break;\r\n                case '(':\r\n                    currentTokenType = OPEN;\r\n                    break;\r\n                case ')':\r\n                    currentTokenType = CLOSE;\r\n                    break;\r\n                default:\r\n                    currentTokenType = KEYWORD;\r\n            }\r\n            parseIndex = i;\r\n            return;\r\n        case CHAR_VALUE:\r\n            long number = c - '0';\r\n            while (true) {\r\n                c = chars[i];\r\n                if (c < '0' || c > '9') {\r\n                    if (c == '.') {\r\n                        readDecimal(start, i);\r\n                        break;\r\n                    }\r\n                    if (c == 'E' || c == 'e') {\r\n                        readDecimal(start, i);\r\n                        break;\r\n                    }\r\n                    currentTokenType = VALUE_NUMBER;\r\n                    currentToken = String.valueOf(number);\r\n                    parseIndex = i;\r\n                    break;\r\n                }\r\n                number = number * 10 + (c - '0');\r\n                if (number > Integer.MAX_VALUE) {\r\n                    readDecimal(start, i);\r\n                    break;\r\n                }\r\n                i++;\r\n            }\r\n            return;\r\n        case CHAR_DECIMAL:\r\n            if (types[i] != CHAR_VALUE) {\r\n                currentTokenType = KEYWORD;\r\n                currentToken = \".\";\r\n                parseIndex = i;\r\n                return;\r\n            }\r\n            readDecimal(i - 1, i);\r\n            return;\r\n        case CHAR_STRING:\r\n            readString(i, '\\'');\r\n            return;\r\n        case CHAR_END:\r\n            currentToken = \"\";\r\n            currentTokenType = END;\r\n            parseIndex = i;\r\n            return;\r\n        default:\r\n            throw getSyntaxError();\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void read() throws ParseException {\r\n    currentTokenQuoted = false;\r\n    if (expected != null) {\r\n        expected.clear();\r\n    }\r\n    int[] types = characterTypes;\r\n    int i = parseIndex;\r\n    int type = types[i];\r\n    while (type == 0) {\r\n        type = types[++i];\r\n    }\r\n    int start = i;\r\n    char[] chars = statementChars;\r\n    char c = chars[i++];\r\n    currentToken = \"\";\r\n    switch(type) {\r\n        case CHAR_NAME:\r\n            while (true) {\r\n                type = types[i];\r\n                if (type != CHAR_NAME && type != CHAR_VALUE) {\r\n                    c = chars[i];\r\n                    break;\r\n                }\r\n                i++;\r\n            }\r\n            currentToken = statement.substring(start, i);\r\n            if (currentToken.isEmpty()) {\r\n                throw getSyntaxError();\r\n            }\r\n            currentTokenType = IDENTIFIER;\r\n            parseIndex = i;\r\n            return;\r\n        case CHAR_SPECIAL_2:\r\n            if (types[i] == CHAR_SPECIAL_2) {\r\n                i++;\r\n            }\r\n                case CHAR_SPECIAL_1:\r\n            currentToken = statement.substring(start, i);\r\n            switch(c) {\r\n                case '+':\r\n                    currentTokenType = PLUS;\r\n                    break;\r\n                case '-':\r\n                    currentTokenType = MINUS;\r\n                    break;\r\n                case '(':\r\n                    currentTokenType = OPEN;\r\n                    break;\r\n                case ')':\r\n                    currentTokenType = CLOSE;\r\n                    break;\r\n                default:\r\n                    currentTokenType = KEYWORD;\r\n            }\r\n            parseIndex = i;\r\n            return;\r\n        case CHAR_VALUE:\r\n            long number = c - '0';\r\n            while (true) {\r\n                c = chars[i];\r\n                if (c < '0' || c > '9') {\r\n                    if (c == '.') {\r\n                        readDecimal(start, i);\r\n                        break;\r\n                    }\r\n                    if (c == 'E' || c == 'e') {\r\n                        readDecimal(start, i);\r\n                        break;\r\n                    }\r\n                    currentTokenType = VALUE_NUMBER;\r\n                    currentToken = String.valueOf(number);\r\n                    parseIndex = i;\r\n                    break;\r\n                }\r\n                number = number * 10 + (c - '0');\r\n                if (number > Integer.MAX_VALUE) {\r\n                    readDecimal(start, i);\r\n                    break;\r\n                }\r\n                i++;\r\n            }\r\n            return;\r\n        case CHAR_DECIMAL:\r\n            if (types[i] != CHAR_VALUE) {\r\n                currentTokenType = KEYWORD;\r\n                currentToken = \".\";\r\n                parseIndex = i;\r\n                return;\r\n            }\r\n            readDecimal(i - 1, i);\r\n            return;\r\n        case CHAR_STRING:\r\n            readString(i, '\\'');\r\n            return;\r\n        case CHAR_END:\r\n            currentToken = \"\";\r\n            currentTokenType = END;\r\n            parseIndex = i;\r\n            return;\r\n        default:\r\n            throw getSyntaxError();\r\n    }\r\n}","lc":4.0454545455,"pi":1.3397129187,"ma":6.6,"nbd":1.5,"ml":2.1666666667,"d":2.2242063492,"mi":-1.4295983087,"fo":0.5,"r":-0.0263157895,"e":7.6555960881}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4259_1f128536","label":3,"code":"\/**\r\n *  Gets the editor component.\r\n *\r\n *  @return The editor component\r\n *\/\r\nprotected final FormComponent<T> getEditor() {\r\n    if (editor == null) {\r\n        initLabelAndEditor(getDelegatingParentModel());\r\n    }\r\n    return editor;\r\n}","code_comment":"\/**\r\n *  Gets the editor component.\r\n *\r\n *  @return The editor component\r\n *\/\r\n","code_no_comment":"protected final FormComponent<T> getEditor() {\r\n    if (editor == null) {\r\n        initLabelAndEditor(getDelegatingParentModel());\r\n    }\r\n    return editor;\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.6397463002,"fo":-0.3333333333,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1270_70564c7c","label":1,"code":"\/**\r\n * Get the Lucene query for the given filter.\r\n *\r\n * @param filter the filter, including full-text constraint\r\n * @param reader the Lucene reader\r\n * @param nonFullTextConstraints whether non-full-text constraints (such a\r\n *            path, node type, and so on) should be added to the Lucene\r\n *            query\r\n * @param analyzer the Lucene analyzer used for building the fulltext query\r\n * @return the Lucene query\r\n *\/\r\nprivate static Query getQuery(Filter filter, IndexReader reader, boolean nonFullTextConstraints, Analyzer analyzer) {\r\n    List<Query> qs = new ArrayList<Query>();\r\n    FullTextExpression ft = filter.getFullTextConstraint();\r\n    if (ft == null) {\r\n    \/\/ there might be no full-text constraint\r\n    \/\/ when using the LowCostLuceneIndexProvider\r\n    \/\/ which is used for testing\r\n    } else {\r\n        qs.add(getFullTextQuery(ft, analyzer));\r\n    }\r\n    if (nonFullTextConstraints) {\r\n        addNonFullTextConstraints(qs, filter, reader);\r\n    }\r\n    if (qs.size() == 0) {\r\n        return new MatchAllDocsQuery();\r\n    }\r\n    if (qs.size() == 1) {\r\n        return qs.get(0);\r\n    }\r\n    BooleanQuery bq = new BooleanQuery();\r\n    for (Query q : qs) {\r\n        bq.add(q, MUST);\r\n    }\r\n    return bq;\r\n}","code_comment":"\/**\r\n * Get the Lucene query for the given filter.\r\n *\r\n * @param filter the filter, including full-text constraint\r\n * @param reader the Lucene reader\r\n * @param nonFullTextConstraints whether non-full-text constraints (such a\r\n *            path, node type, and so on) should be added to the Lucene\r\n *            query\r\n * @param analyzer the Lucene analyzer used for building the fulltext query\r\n * @return the Lucene query\r\n *\/\r\n","code_no_comment":"private static Query getQuery(Filter filter, IndexReader reader, boolean nonFullTextConstraints, Analyzer analyzer) {\r\n    List<Query> qs = new ArrayList<Query>();\r\n    FullTextExpression ft = filter.getFullTextConstraint();\r\n    if (ft == null) {\r\n                } else {\r\n        qs.add(getFullTextQuery(ft, analyzer));\r\n    }\r\n    if (nonFullTextConstraints) {\r\n        addNonFullTextConstraints(qs, filter, reader);\r\n    }\r\n    if (qs.size() == 0) {\r\n        return new MatchAllDocsQuery();\r\n    }\r\n    if (qs.size() == 1) {\r\n        return qs.get(0);\r\n    }\r\n    BooleanQuery bq = new BooleanQuery();\r\n    for (Query q : qs) {\r\n        bq.add(q, MUST);\r\n    }\r\n    return bq;\r\n}","lc":0.3636363636,"pi":-0.3827751196,"ma":0.4,"nbd":-0.5,"ml":0.1666666667,"d":-0.0099206349,"mi":-0.30260747,"fo":0.1666666667,"r":-0.0263157895,"e":0.074749745}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-395_4ed7bc8e","label":1,"code":"\/**\r\n * @see Node#setProperty(String, javax.jcr.Value, int)\r\n *\/\r\n@Override\r\n@CheckForNull\r\npublic Property setProperty(final String jcrName, final Value value, final int type) throws RepositoryException {\r\n    checkStatus();\r\n    return sessionDelegate.perform(new SessionOperation<PropertyImpl>() {\r\n\r\n        @Override\r\n        public PropertyImpl perform() throws RepositoryException {\r\n            String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\r\n            if (value == null) {\r\n                dlg.removeProperty(oakName);\r\n                return null;\r\n            } else {\r\n                int targetType = getTargetType(value, type);\r\n                Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\r\n                return new PropertyImpl(dlg.setProperty(oakName, targetValue));\r\n            }\r\n        }\r\n    });\r\n}","code_comment":"\/**\r\n * @see Node#setProperty(String, javax.jcr.Value, int)\r\n *\/\r\n","code_no_comment":"@Override\r\n@CheckForNull\r\npublic Property setProperty(final String jcrName, final Value value, final int type) throws RepositoryException {\r\n    checkStatus();\r\n    return sessionDelegate.perform(new SessionOperation<PropertyImpl>() {\r\n\r\n        @Override\r\n        public PropertyImpl perform() throws RepositoryException {\r\n            String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\r\n            if (value == null) {\r\n                dlg.removeProperty(oakName);\r\n                return null;\r\n            } else {\r\n                int targetType = getTargetType(value, type);\r\n                Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\r\n                return new PropertyImpl(dlg.setProperty(oakName, targetValue));\r\n            }\r\n        }\r\n    });\r\n}","lc":0.2272727273,"pi":1.4306220096,"ma":-0.4,"nbd":0.0,"ml":-0.25,"d":-0.0198412698,"mi":-0.1878787879,"fo":0.1666666667,"r":0.0,"e":0.0360413317}
{"project_name":"Lang","project_version":"44","label":1,"code":"\/\/ --------------------------------------------------------------------\r\n\/\/ must handle Long, Float, Integer, Float, Short,\r\n\/\/ BigDecimal, BigInteger and Byte\r\n\/\/ useful methods:\r\n\/\/ Byte.decode(String)\r\n\/\/ Byte.valueOf(String,int radix)\r\n\/\/ Byte.valueOf(String)\r\n\/\/ Double.valueOf(String)\r\n\/\/ Float.valueOf(String)\r\n\/\/ new Float(String)\r\n\/\/ Integer.valueOf(String,int radix)\r\n\/\/ Integer.valueOf(String)\r\n\/\/ Integer.decode(String)\r\n\/\/ Integer.getInteger(String)\r\n\/\/ Integer.getInteger(String,int val)\r\n\/\/ Integer.getInteger(String,Integer val)\r\n\/\/ new Integer(String)\r\n\/\/ new Double(String)\r\n\/\/ new Byte(String)\r\n\/\/ new Long(String)\r\n\/\/ Long.getLong(String)\r\n\/\/ Long.getLong(String,int)\r\n\/\/ Long.getLong(String,Integer)\r\n\/\/ Long.valueOf(String,int)\r\n\/\/ Long.valueOf(String)\r\n\/\/ new Short(String)\r\n\/\/ Short.decode(String)\r\n\/\/ Short.valueOf(String,int)\r\n\/\/ Short.valueOf(String)\r\n\/\/ new BigDecimal(String)\r\n\/\/ new BigInteger(String)\r\n\/\/ new BigInteger(String,int radix)\r\n\/\/ Possible inputs:\r\n\/\/ 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\r\n\/\/ plus minus everything. Prolly more. A lot are not separable.\r\n\/**\r\n * <p>Turns a string value into a java.lang.Number.<\/p>\r\n *\r\n * <p>First, the value is examined for a type qualifier on the end\r\n * (<code>'f','F','d','D','l','L'<\/code>).  If it is found, it starts\r\n * trying to create successively larger types from the type specified\r\n * until one is found that can hold the value.<\/p>\r\n *\r\n * <p>If a type specifier is not found, it will check for a decimal point\r\n * and then try successively larger types from <code>Integer<\/code> to\r\n * <code>BigInteger<\/code> and from <code>Float<\/code> to\r\n * <code>BigDecimal<\/code>.<\/p>\r\n *\r\n * <p>If the string starts with <code>0x<\/code> or <code>-0x<\/code>, it\r\n * will be interpreted as a hexadecimal integer.  Values with leading\r\n * <code>0<\/code>'s will not be interpreted as octal.<\/p>\r\n *\r\n * @param val String containing a number\r\n * @return Number created from the string\r\n * @throws NumberFormatException if the value cannot be converted\r\n *\/\r\npublic static Number createNumber(String val) throws NumberFormatException {\r\n    if (val == null) {\r\n        return null;\r\n    }\r\n    if (val.length() == 0) {\r\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\r\n    }\r\n    if (val.startsWith(\"--\")) {\r\n        \/\/ a wrong value.\r\n        return null;\r\n    }\r\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\r\n        return createInteger(val);\r\n    }\r\n    char lastChar = val.charAt(val.length() - 1);\r\n    String mant;\r\n    String dec;\r\n    String exp;\r\n    int decPos = val.indexOf('.');\r\n    int expPos = val.indexOf('e') + val.indexOf('E') + 1;\r\n    if (decPos > -1) {\r\n        if (expPos > -1) {\r\n            if (expPos < decPos) {\r\n                throw new NumberFormatException(val + \" is not a valid number.\");\r\n            }\r\n            dec = val.substring(decPos + 1, expPos);\r\n        } else {\r\n            dec = val.substring(decPos + 1);\r\n        }\r\n        mant = val.substring(0, decPos);\r\n    } else {\r\n        if (expPos > -1) {\r\n            mant = val.substring(0, expPos);\r\n        } else {\r\n            mant = val;\r\n        }\r\n        dec = null;\r\n    }\r\n    if (!Character.isDigit(lastChar)) {\r\n        if (expPos > -1 && expPos < val.length() - 1) {\r\n            exp = val.substring(expPos + 1, val.length() - 1);\r\n        } else {\r\n            exp = null;\r\n        }\r\n        \/\/ Requesting a specific type..\r\n        String numeric = val.substring(0, val.length() - 1);\r\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n        switch(lastChar) {\r\n            case 'l':\r\n            case 'L':\r\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\r\n                    try {\r\n                        return createLong(numeric);\r\n                    } catch (NumberFormatException nfe) {\r\n                    \/\/ Too big for a long\r\n                    }\r\n                    return createBigInteger(numeric);\r\n                }\r\n                throw new NumberFormatException(val + \" is not a valid number.\");\r\n            case 'f':\r\n            case 'F':\r\n                try {\r\n                    Float f = NumberUtils.createFloat(numeric);\r\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                        \/\/ has non-zeros in it, then float does not have the precision we want\r\n                        return f;\r\n                    }\r\n                } catch (NumberFormatException e) {\r\n                \/\/ ignore the bad number\r\n                }\r\n            \/\/ Fall through\r\n            case 'd':\r\n            case 'D':\r\n                try {\r\n                    Double d = NumberUtils.createDouble(numeric);\r\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\r\n                        return d;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                \/\/ empty catch\r\n                }\r\n                try {\r\n                    return createBigDecimal(numeric);\r\n                } catch (NumberFormatException e) {\r\n                \/\/ empty catch\r\n                }\r\n            \/\/ Fall through\r\n            default:\r\n                throw new NumberFormatException(val + \" is not a valid number.\");\r\n        }\r\n    } else {\r\n        \/\/ small and go from there...\r\n        if (expPos > -1 && expPos < val.length() - 1) {\r\n            exp = val.substring(expPos + 1, val.length());\r\n        } else {\r\n            exp = null;\r\n        }\r\n        if (dec == null && exp == null) {\r\n            \/\/ Must be an int,long,bigint\r\n            try {\r\n                return createInteger(val);\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ empty catch\r\n            }\r\n            try {\r\n                return createLong(val);\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ empty catch\r\n            }\r\n            return createBigInteger(val);\r\n        } else {\r\n            \/\/ Must be a float,double,BigDec\r\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n            try {\r\n                Float f = createFloat(val);\r\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                    return f;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ empty catch\r\n            }\r\n            try {\r\n                Double d = createDouble(val);\r\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\r\n                    return d;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ empty catch\r\n            }\r\n            return createBigDecimal(val);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * <p>Turns a string value into a java.lang.Number.<\/p>\r\n *\r\n * <p>First, the value is examined for a type qualifier on the end\r\n * (<code>'f','F','d','D','l','L'<\/code>).  If it is found, it starts\r\n * trying to create successively larger types from the type specified\r\n * until one is found that can hold the value.<\/p>\r\n *\r\n * <p>If a type specifier is not found, it will check for a decimal point\r\n * and then try successively larger types from <code>Integer<\/code> to\r\n * <code>BigInteger<\/code> and from <code>Float<\/code> to\r\n * <code>BigDecimal<\/code>.<\/p>\r\n *\r\n * <p>If the string starts with <code>0x<\/code> or <code>-0x<\/code>, it\r\n * will be interpreted as a hexadecimal integer.  Values with leading\r\n * <code>0<\/code>'s will not be interpreted as octal.<\/p>\r\n *\r\n * @param val String containing a number\r\n * @return Number created from the string\r\n * @throws NumberFormatException if the value cannot be converted\r\n *\/\r\n","code_no_comment":"public static Number createNumber(String val) throws NumberFormatException {\r\n    if (val == null) {\r\n        return null;\r\n    }\r\n    if (val.length() == 0) {\r\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\r\n    }\r\n    if (val.startsWith(\"--\")) {\r\n                return null;\r\n    }\r\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\r\n        return createInteger(val);\r\n    }\r\n    char lastChar = val.charAt(val.length() - 1);\r\n    String mant;\r\n    String dec;\r\n    String exp;\r\n    int decPos = val.indexOf('.');\r\n    int expPos = val.indexOf('e') + val.indexOf('E') + 1;\r\n    if (decPos > -1) {\r\n        if (expPos > -1) {\r\n            if (expPos < decPos) {\r\n                throw new NumberFormatException(val + \" is not a valid number.\");\r\n            }\r\n            dec = val.substring(decPos + 1, expPos);\r\n        } else {\r\n            dec = val.substring(decPos + 1);\r\n        }\r\n        mant = val.substring(0, decPos);\r\n    } else {\r\n        if (expPos > -1) {\r\n            mant = val.substring(0, expPos);\r\n        } else {\r\n            mant = val;\r\n        }\r\n        dec = null;\r\n    }\r\n    if (!Character.isDigit(lastChar)) {\r\n        if (expPos > -1 && expPos < val.length() - 1) {\r\n            exp = val.substring(expPos + 1, val.length() - 1);\r\n        } else {\r\n            exp = null;\r\n        }\r\n                String numeric = val.substring(0, val.length() - 1);\r\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n        switch(lastChar) {\r\n            case 'l':\r\n            case 'L':\r\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\r\n                    try {\r\n                        return createLong(numeric);\r\n                    } catch (NumberFormatException nfe) {\r\n                                        }\r\n                    return createBigInteger(numeric);\r\n                }\r\n                throw new NumberFormatException(val + \" is not a valid number.\");\r\n            case 'f':\r\n            case 'F':\r\n                try {\r\n                    Float f = NumberUtils.createFloat(numeric);\r\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                                                return f;\r\n                    }\r\n                } catch (NumberFormatException e) {\r\n                                }\r\n                        case 'd':\r\n            case 'D':\r\n                try {\r\n                    Double d = NumberUtils.createDouble(numeric);\r\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\r\n                        return d;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                                }\r\n                try {\r\n                    return createBigDecimal(numeric);\r\n                } catch (NumberFormatException e) {\r\n                                }\r\n                        default:\r\n                throw new NumberFormatException(val + \" is not a valid number.\");\r\n        }\r\n    } else {\r\n                if (expPos > -1 && expPos < val.length() - 1) {\r\n            exp = val.substring(expPos + 1, val.length());\r\n        } else {\r\n            exp = null;\r\n        }\r\n        if (dec == null && exp == null) {\r\n                        try {\r\n                return createInteger(val);\r\n            } catch (NumberFormatException nfe) {\r\n                        }\r\n            try {\r\n                return createLong(val);\r\n            } catch (NumberFormatException nfe) {\r\n                        }\r\n            return createBigInteger(val);\r\n        } else {\r\n                        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n            try {\r\n                Float f = createFloat(val);\r\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                    return f;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n                        }\r\n            try {\r\n                Double d = createDouble(val);\r\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\r\n                    return d;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n                        }\r\n            return createBigDecimal(val);\r\n        }\r\n    }\r\n}","lc":4.6818181818,"pi":1.2057416268,"ma":6.6,"nbd":1.5,"ml":4.6666666667,"d":3.1071428571,"mi":-1.5496828753,"fo":3.6666666667,"r":-0.0263157895,"e":15.8229975277}
{"project_name":"Math","project_version":"4","label":1,"code":"\/**\r\n * Get the intersection of the instance and another sub-line.\r\n * <p>\r\n * This method is related to the {@link Line#intersection(Line)\r\n * intersection} method in the {@link Line Line} class, but in addition\r\n * to compute the point along infinite lines, it also checks the point\r\n * lies on both sub-line ranges.\r\n * <\/p>\r\n * @param subLine other sub-line which may intersect instance\r\n * @param includeEndPoints if true, endpoints are considered to belong to\r\n * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\r\n * are considered to not belong to instance (i.e. they are open sets) and intersection\r\n * occurring on endpoints lead to null being returned\r\n * @return the intersection point if there is one, null if the sub-lines don't intersect\r\n *\/\r\npublic Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\r\n    \/\/ retrieve the underlying lines\r\n    Line line1 = (Line) getHyperplane();\r\n    Line line2 = (Line) subLine.getHyperplane();\r\n    \/\/ compute the intersection on infinite line\r\n    Vector2D v2D = line1.intersection(line2);\r\n    \/\/ check location of point with respect to first sub-line\r\n    Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\r\n    \/\/ check location of point with respect to second sub-line\r\n    Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\r\n    if (includeEndPoints) {\r\n        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\r\n    } else {\r\n        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\r\n    }\r\n}","code_comment":"\/**\r\n * Get the intersection of the instance and another sub-line.\r\n * <p>\r\n * This method is related to the {@link Line#intersection(Line)\r\n * intersection} method in the {@link Line Line} class, but in addition\r\n * to compute the point along infinite lines, it also checks the point\r\n * lies on both sub-line ranges.\r\n * <\/p>\r\n * @param subLine other sub-line which may intersect instance\r\n * @param includeEndPoints if true, endpoints are considered to belong to\r\n * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\r\n * are considered to not belong to instance (i.e. they are open sets) and intersection\r\n * occurring on endpoints lead to null being returned\r\n * @return the intersection point if there is one, null if the sub-lines don't intersect\r\n *\/\r\n","code_no_comment":"public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\r\n        Line line1 = (Line) getHyperplane();\r\n    Line line2 = (Line) subLine.getHyperplane();\r\n        Vector2D v2D = line1.intersection(line2);\r\n        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\r\n        Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\r\n    if (includeEndPoints) {\r\n        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\r\n    } else {\r\n        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\r\n    }\r\n}","lc":-0.0909090909,"pi":-0.3253588517,"ma":0.0,"nbd":-0.5,"ml":0.25,"d":0.6666666667,"mi":-0.0136715997,"fo":0.25,"r":-0.0263157895,"e":0.52969347}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_46f62443","label":1,"code":"@Override\r\npublic void checkIteratorConflicts(String tableName, IteratorSetting setting) throws AccumuloException, TableNotFoundException {\r\n    for (IteratorScope scope : setting.getScopes()) {\r\n        String scopeStr = String.format(\"%s%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase());\r\n        String nameStr = String.format(\"%s.%s\", scopeStr, setting.getName());\r\n        String optStr = String.format(\"%s.opt.\", nameStr);\r\n        Map<String, String> optionConflicts = new TreeMap<String, String>();\r\n        for (Entry<String, String> property : this.getProperties(tableName)) {\r\n            if (property.getKey().startsWith(scopeStr)) {\r\n                if (property.getKey().equals(nameStr))\r\n                    throw new IllegalArgumentException(\"iterator name conflict for \" + setting.getName() + \": \" + property.getKey() + \"=\" + property.getValue());\r\n                if (property.getKey().startsWith(optStr))\r\n                    optionConflicts.put(property.getKey(), property.getValue());\r\n                if (property.getKey().contains(\".opt.\"))\r\n                    continue;\r\n                String[] parts = property.getValue().split(\",\");\r\n                if (parts.length != 2)\r\n                    throw new AccumuloException(\"Bad value for existing iterator setting: \" + property.getKey() + \"=\" + property.getValue());\r\n                try {\r\n                    if (Integer.parseInt(parts[0]) == setting.getPriority())\r\n                        throw new IllegalArgumentException(\"iterator priority conflict: \" + property.getKey() + \"=\" + property.getValue());\r\n                } catch (NumberFormatException e) {\r\n                    throw new AccumuloException(\"Bad value for existing iterator setting: \" + property.getKey() + \"=\" + property.getValue());\r\n                }\r\n            }\r\n        }\r\n        if (optionConflicts.size() > 0)\r\n            throw new IllegalArgumentException(\"iterator options conflict for \" + setting.getName() + \": \" + optionConflicts);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void checkIteratorConflicts(String tableName, IteratorSetting setting) throws AccumuloException, TableNotFoundException {\r\n    for (IteratorScope scope : setting.getScopes()) {\r\n        String scopeStr = String.format(\"%s%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase());\r\n        String nameStr = String.format(\"%s.%s\", scopeStr, setting.getName());\r\n        String optStr = String.format(\"%s.opt.\", nameStr);\r\n        Map<String, String> optionConflicts = new TreeMap<String, String>();\r\n        for (Entry<String, String> property : this.getProperties(tableName)) {\r\n            if (property.getKey().startsWith(scopeStr)) {\r\n                if (property.getKey().equals(nameStr))\r\n                    throw new IllegalArgumentException(\"iterator name conflict for \" + setting.getName() + \": \" + property.getKey() + \"=\" + property.getValue());\r\n                if (property.getKey().startsWith(optStr))\r\n                    optionConflicts.put(property.getKey(), property.getValue());\r\n                if (property.getKey().contains(\".opt.\"))\r\n                    continue;\r\n                String[] parts = property.getValue().split(\",\");\r\n                if (parts.length != 2)\r\n                    throw new AccumuloException(\"Bad value for existing iterator setting: \" + property.getKey() + \"=\" + property.getValue());\r\n                try {\r\n                    if (Integer.parseInt(parts[0]) == setting.getPriority())\r\n                        throw new IllegalArgumentException(\"iterator priority conflict: \" + property.getKey() + \"=\" + property.getValue());\r\n                } catch (NumberFormatException e) {\r\n                    throw new AccumuloException(\"Bad value for existing iterator setting: \" + property.getKey() + \"=\" + property.getValue());\r\n                }\r\n            }\r\n        }\r\n        if (optionConflicts.size() > 0)\r\n            throw new IllegalArgumentException(\"iterator options conflict for \" + setting.getName() + \": \" + optionConflicts);\r\n    }\r\n}","lc":0.7272727273,"pi":1.7464114833,"ma":2.6,"nbd":1.0,"ml":1.0833333333,"d":0.5496031746,"mi":-0.67329105,"fo":2.3333333333,"r":-0.0263157895,"e":1.6260046219}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5359_61122bab","label":3,"code":"\/**\r\n *  Convert to long integer, returning default value if text is inconvertible.\r\n *\r\n *  @param defaultValue\r\n *             the default value\r\n *  @return the converted text as a long integer or the default value if text is empty or inconvertible\r\n *\/\r\npublic final long toLong(final long defaultValue) {\r\n    if (text != null) {\r\n        try {\r\n            return toLong();\r\n        } catch (StringValueConversionException x) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a long: %s\", text, x.getMessage()), x);\r\n            }\r\n        }\r\n    }\r\n    return defaultValue;\r\n}","code_comment":"\/**\r\n *  Convert to long integer, returning default value if text is inconvertible.\r\n *\r\n *  @param defaultValue\r\n *             the default value\r\n *  @return the converted text as a long integer or the default value if text is empty or inconvertible\r\n *\/\r\n","code_no_comment":"public final long toLong(final long defaultValue) {\r\n    if (text != null) {\r\n        try {\r\n            return toLong();\r\n        } catch (StringValueConversionException x) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a long: %s\", text, x.getMessage()), x);\r\n            }\r\n        }\r\n    }\r\n    return defaultValue;\r\n}","lc":-0.0909090909,"pi":0.8899521531,"ma":0.0,"nbd":0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.1709654686,"fo":-0.0833333333,"r":1.0263157895,"e":-0.1627934049}
{"project_name":"Compress","project_version":"41","label":3,"code":"public ZipArchiveEntry getNextZipEntry() throws IOException {\r\n    boolean firstEntry = true;\r\n    if (closed || hitCentralDirectory) {\r\n        return null;\r\n    }\r\n    if (current != null) {\r\n        closeEntry();\r\n        firstEntry = false;\r\n    }\r\n    try {\r\n        if (firstEntry) {\r\n            \/\/ split archives have a special signature before the\r\n            \/\/ first local file header - look for it and fail with\r\n            \/\/ the appropriate error message if this is a split\r\n            \/\/ archive.\r\n            readFirstLocalFileHeader(LFH_BUF);\r\n        } else {\r\n            readFully(LFH_BUF);\r\n        }\r\n    } catch (final EOFException e) {\r\n        return null;\r\n    }\r\n    final ZipLong sig = new ZipLong(LFH_BUF);\r\n    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\r\n        hitCentralDirectory = true;\r\n        skipRemainderOfArchive();\r\n    }\r\n    if (!sig.equals(ZipLong.LFH_SIG)) {\r\n        return null;\r\n    }\r\n    int off = WORD;\r\n    current = new CurrentEntry();\r\n    final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\r\n    off += SHORT;\r\n    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\r\n    final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\r\n    final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\r\n    final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\r\n    current.hasDataDescriptor = gpFlag.usesDataDescriptor();\r\n    current.entry.setGeneralPurposeBit(gpFlag);\r\n    off += SHORT;\r\n    current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\r\n    off += SHORT;\r\n    final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\r\n    current.entry.setTime(time);\r\n    off += WORD;\r\n    ZipLong size = null, cSize = null;\r\n    if (!current.hasDataDescriptor) {\r\n        current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\r\n        off += WORD;\r\n        cSize = new ZipLong(LFH_BUF, off);\r\n        off += WORD;\r\n        size = new ZipLong(LFH_BUF, off);\r\n        off += WORD;\r\n    } else {\r\n        off += 3 * WORD;\r\n    }\r\n    final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\r\n    off += SHORT;\r\n    final int extraLen = ZipShort.getValue(LFH_BUF, off);\r\n    off += SHORT;\r\n    final byte[] fileName = new byte[fileNameLen];\r\n    readFully(fileName);\r\n    current.entry.setName(entryEncoding.decode(fileName), fileName);\r\n    final byte[] extraData = new byte[extraLen];\r\n    readFully(extraData);\r\n    current.entry.setExtra(extraData);\r\n    if (!hasUTF8Flag && useUnicodeExtraFields) {\r\n        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\r\n    }\r\n    processZip64Extra(size, cSize);\r\n    if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\r\n        if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\r\n            current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\r\n        } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\r\n            current.in = new ExplodingInputStream(current.entry.getGeneralPurposeBit().getSlidingDictionarySize(), current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), new BoundedInputStream(in, current.entry.getCompressedSize()));\r\n        } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\r\n            current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\r\n        }\r\n    }\r\n    entriesRead++;\r\n    return current.entry;\r\n}","code_comment":null,"code_no_comment":"public ZipArchiveEntry getNextZipEntry() throws IOException {\r\n    boolean firstEntry = true;\r\n    if (closed || hitCentralDirectory) {\r\n        return null;\r\n    }\r\n    if (current != null) {\r\n        closeEntry();\r\n        firstEntry = false;\r\n    }\r\n    try {\r\n        if (firstEntry) {\r\n                                                            readFirstLocalFileHeader(LFH_BUF);\r\n        } else {\r\n            readFully(LFH_BUF);\r\n        }\r\n    } catch (final EOFException e) {\r\n        return null;\r\n    }\r\n    final ZipLong sig = new ZipLong(LFH_BUF);\r\n    if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\r\n        hitCentralDirectory = true;\r\n        skipRemainderOfArchive();\r\n    }\r\n    if (!sig.equals(ZipLong.LFH_SIG)) {\r\n        return null;\r\n    }\r\n    int off = WORD;\r\n    current = new CurrentEntry();\r\n    final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\r\n    off += SHORT;\r\n    current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\r\n    final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\r\n    final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\r\n    final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\r\n    current.hasDataDescriptor = gpFlag.usesDataDescriptor();\r\n    current.entry.setGeneralPurposeBit(gpFlag);\r\n    off += SHORT;\r\n    current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\r\n    off += SHORT;\r\n    final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\r\n    current.entry.setTime(time);\r\n    off += WORD;\r\n    ZipLong size = null, cSize = null;\r\n    if (!current.hasDataDescriptor) {\r\n        current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\r\n        off += WORD;\r\n        cSize = new ZipLong(LFH_BUF, off);\r\n        off += WORD;\r\n        size = new ZipLong(LFH_BUF, off);\r\n        off += WORD;\r\n    } else {\r\n        off += 3 * WORD;\r\n    }\r\n    final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\r\n    off += SHORT;\r\n    final int extraLen = ZipShort.getValue(LFH_BUF, off);\r\n    off += SHORT;\r\n    final byte[] fileName = new byte[fileNameLen];\r\n    readFully(fileName);\r\n    current.entry.setName(entryEncoding.decode(fileName), fileName);\r\n    final byte[] extraData = new byte[extraLen];\r\n    readFully(extraData);\r\n    current.entry.setExtra(extraData);\r\n    if (!hasUTF8Flag && useUnicodeExtraFields) {\r\n        ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\r\n    }\r\n    processZip64Extra(size, cSize);\r\n    if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\r\n        if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\r\n            current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\r\n        } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\r\n            current.in = new ExplodingInputStream(current.entry.getGeneralPurposeBit().getSlidingDictionarySize(), current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), new BoundedInputStream(in, current.entry.getCompressedSize()));\r\n        } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\r\n            current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\r\n        }\r\n    }\r\n    entriesRead++;\r\n    return current.entry;\r\n}","lc":2.9545454545,"pi":-0.2009569378,"ma":2.0,"nbd":1.0,"ml":2.0833333333,"d":2.4146825397,"mi":-1.2156448203,"fo":3.0833333333,"r":-0.0263157895,"e":12.1585380612}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-369_4e245a76","label":3,"code":"\/**\r\n * Get a property\r\n * @param relPath  oak path\r\n * @return  property at the path given by {@code relPath} or {@code null} if\r\n * no such property exists\r\n *\/\r\n@CheckForNull\r\npublic PropertyDelegate getProperty(String relPath) throws InvalidItemStateException {\r\n    TreeLocation propertyLocation = getChildLocation(relPath);\r\n    PropertyState propertyState = propertyLocation.getProperty();\r\n    return propertyState == null ? null : new PropertyDelegate(sessionDelegate, propertyLocation);\r\n}","code_comment":"\/**\r\n * Get a property\r\n * @param relPath  oak path\r\n * @return  property at the path given by {@code relPath} or {@code null} if\r\n * no such property exists\r\n *\/\r\n","code_no_comment":"@CheckForNull\r\npublic PropertyDelegate getProperty(String relPath) throws InvalidItemStateException {\r\n    TreeLocation propertyLocation = getChildLocation(relPath);\r\n    PropertyState propertyState = propertyLocation.getProperty();\r\n    return propertyState == null ? null : new PropertyDelegate(sessionDelegate, propertyLocation);\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.0674603175,"mi":0.4773784355,"fo":-0.3333333333,"r":2.5526315789,"e":-0.0964045112}
{"project_name":"Closure","project_version":"64","label":2,"code":"\/**\r\n * Generates JavaScript source code for an AST.\r\n *\/\r\nprivate String toSource(Node n, SourceMap sourceMap) {\r\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\r\n    builder.setPrettyPrint(options.prettyPrint);\r\n    builder.setLineBreak(options.lineBreak);\r\n    builder.setSourceMap(sourceMap);\r\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\r\n    builder.setTagAsStrict(options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\r\n    builder.setLineLengthThreshold(options.lineLengthThreshold);\r\n    Charset charset = options.outputCharset != null ? Charset.forName(options.outputCharset) : null;\r\n    builder.setOutputCharset(charset);\r\n    return builder.build();\r\n}","code_comment":"\/**\r\n * Generates JavaScript source code for an AST.\r\n *\/\r\n","code_no_comment":"private String toSource(Node n, SourceMap sourceMap) {\r\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\r\n    builder.setPrettyPrint(options.prettyPrint);\r\n    builder.setLineBreak(options.lineBreak);\r\n    builder.setSourceMap(sourceMap);\r\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\r\n    builder.setTagAsStrict(options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\r\n    builder.setLineLengthThreshold(options.lineLengthThreshold);\r\n    Charset charset = options.outputCharset != null ? Charset.forName(options.outputCharset) : null;\r\n    builder.setOutputCharset(charset);\r\n    return builder.build();\r\n}","lc":-0.0909090909,"pi":-0.7177033493,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.0257936508,"mi":-0.0012684989,"fo":0.3333333333,"r":-0.0263157895,"e":0.0657780237}
{"project_name":"Closure","project_version":"108","label":2,"code":"@Override\r\npublic void exitScope(NodeTraversal t) {\r\n    if (t.getScopeDepth() > 2) {\r\n        findNamespaceShadows(t);\r\n    }\r\n    if (t.getScopeDepth() == 2) {\r\n        renameNamespaceShadows(t);\r\n        aliases.clear();\r\n        forbiddenLocals.clear();\r\n        transformation = null;\r\n        hasNamespaceShadows = false;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void exitScope(NodeTraversal t) {\r\n    if (t.getScopeDepth() > 2) {\r\n        findNamespaceShadows(t);\r\n    }\r\n    if (t.getScopeDepth() == 2) {\r\n        renameNamespaceShadows(t);\r\n        aliases.clear();\r\n        forbiddenLocals.clear();\r\n        transformation = null;\r\n        hasNamespaceShadows = false;\r\n    }\r\n}","lc":-0.0454545455,"pi":0.1004784689,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0793650794,"mi":0.0917547569,"fo":0.0,"r":0.4473684211,"e":-0.086782732}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public void removeTableProperty(ByteBuffer login, String tableName, String property) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException;","code_comment":null,"code_no_comment":"public void removeTableProperty(ByteBuffer login, String tableName, String property) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException;","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.3923890063,"fo":-0.5,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Closure","project_version":"97","label":1,"code":"\/**\r\n * Try to fold shift operations\r\n *\/\r\nprivate Node tryFoldShift(Node n, Node left, Node right) {\r\n    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {\r\n        double result;\r\n        double lval = left.getDouble();\r\n        double rval = right.getDouble();\r\n        \/\/ a 32-bit range, since the user likely does not intend that.\r\n        if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\r\n            error(BITWISE_OPERAND_OUT_OF_RANGE, left);\r\n            return n;\r\n        }\r\n        \/\/ if the shift amount is outside [0,32)\r\n        if (!(rval >= 0 && rval < 32)) {\r\n            error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\r\n            return n;\r\n        }\r\n        \/\/ Convert the numbers to ints\r\n        int lvalInt = (int) lval;\r\n        if (lvalInt != lval) {\r\n            error(FRACTIONAL_BITWISE_OPERAND, left);\r\n            return n;\r\n        }\r\n        int rvalInt = (int) rval;\r\n        if (rvalInt != rval) {\r\n            error(FRACTIONAL_BITWISE_OPERAND, right);\r\n            return n;\r\n        }\r\n        switch(n.getType()) {\r\n            case Token.LSH:\r\n                result = lvalInt << rvalInt;\r\n                break;\r\n            case Token.RSH:\r\n                result = lvalInt >> rvalInt;\r\n                break;\r\n            case Token.URSH:\r\n                \/\/ JavaScript handles zero shifts on signed numbers differently than\r\n                \/\/ Java as an Java int can not represent the unsigned 32-bit number\r\n                \/\/ where JavaScript can so use a long here.\r\n                result = lvalInt >>> rvalInt;\r\n                break;\r\n            default:\r\n                throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType()));\r\n        }\r\n        Node newNumber = Node.newNumber(result);\r\n        n.getParent().replaceChild(n, newNumber);\r\n        reportCodeChange();\r\n        return newNumber;\r\n    }\r\n    return n;\r\n}","code_comment":"\/**\r\n * Try to fold shift operations\r\n *\/\r\n","code_no_comment":"private Node tryFoldShift(Node n, Node left, Node right) {\r\n    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {\r\n        double result;\r\n        double lval = left.getDouble();\r\n        double rval = right.getDouble();\r\n                if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\r\n            error(BITWISE_OPERAND_OUT_OF_RANGE, left);\r\n            return n;\r\n        }\r\n                if (!(rval >= 0 && rval < 32)) {\r\n            error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\r\n            return n;\r\n        }\r\n                int lvalInt = (int) lval;\r\n        if (lvalInt != lval) {\r\n            error(FRACTIONAL_BITWISE_OPERAND, left);\r\n            return n;\r\n        }\r\n        int rvalInt = (int) rval;\r\n        if (rvalInt != rval) {\r\n            error(FRACTIONAL_BITWISE_OPERAND, right);\r\n            return n;\r\n        }\r\n        switch(n.getType()) {\r\n            case Token.LSH:\r\n                result = lvalInt << rvalInt;\r\n                break;\r\n            case Token.RSH:\r\n                result = lvalInt >> rvalInt;\r\n                break;\r\n            case Token.URSH:\r\n                                                                result = lvalInt >>> rvalInt;\r\n                break;\r\n            default:\r\n                throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType()));\r\n        }\r\n        Node newNumber = Node.newNumber(result);\r\n        n.getParent().replaceChild(n, newNumber);\r\n        reportCodeChange();\r\n        return newNumber;\r\n    }\r\n    return n;\r\n}","lc":1.3181818182,"pi":0.4736842105,"ma":2.0,"nbd":0.5,"ml":1.0833333333,"d":2.9265873016,"mi":-0.7818181818,"fo":0.75,"r":-0.0263157895,"e":4.8640952496}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3646_12124902","label":3,"code":"\/**\r\n *  {@inheritDoc}\r\n *\/\r\npublic void scheduleRequestHandlerAfterCurrent(IRequestHandler handler) {\r\n    \/\/ just delegating the call to {@link IRequestHandlerExecutor} and invoking listeners\r\n    requestHandlerExecutor.schedule(handler);\r\n    listeners.onRequestHandlerScheduled(handler);\r\n}","code_comment":"\/**\r\n *  {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public void scheduleRequestHandlerAfterCurrent(IRequestHandler handler) {\r\n        requestHandlerExecutor.schedule(handler);\r\n    listeners.onRequestHandlerScheduled(handler);\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8396053559,"fo":-0.3333333333,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1287_14849e22","label":1,"code":"public RecordId getEntry(int index) {\r\n    checkElementIndex(index, size);\r\n    if (size == 1) {\r\n        return getRecordId();\r\n    } else {\r\n        int bucketIndex = index \/ bucketSize;\r\n        int bucketOffset = index % bucketSize;\r\n        Segment segment = getSegment();\r\n        RecordId bucketId = segment.readRecordId(getOffset(0, bucketIndex));\r\n        ListRecord bucket = new ListRecord(segment, bucketId, bucketSize);\r\n        return bucket.getEntry(bucketOffset);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public RecordId getEntry(int index) {\r\n    checkElementIndex(index, size);\r\n    if (size == 1) {\r\n        return getRecordId();\r\n    } else {\r\n        int bucketIndex = index \/ bucketSize;\r\n        int bucketOffset = index % bucketSize;\r\n        Segment segment = getSegment();\r\n        RecordId bucketId = segment.readRecordId(getOffset(0, bucketIndex));\r\n        ListRecord bucket = new ListRecord(segment, bucketId, bucketSize);\r\n        return bucket.getEntry(bucketOffset);\r\n    }\r\n}","lc":-0.0454545455,"pi":-0.019138756,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.3293650794,"mi":0.0187455955,"fo":0.0,"r":0.0789473684,"e":0.1553384854}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-880_2a9cbbab","label":1,"code":"\/**\r\n * Check outgoing edge processed indicator.\r\n * @return true if outgoing edge needs processing\r\n *\/\r\npublic boolean outgoingNeedsProcessing() {\r\n    return outgoingNeedsProcessing;\r\n}","code_comment":"\/**\r\n * Check outgoing edge processed indicator.\r\n * @return true if outgoing edge needs processing\r\n *\/\r\n","code_no_comment":"public boolean outgoingNeedsProcessing() {\r\n    return outgoingNeedsProcessing;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.3083861875,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"@Override\r\npublic void flush(String writer) throws TException {\r\n    try {\r\n        BatchWriter batchwriter = writerCache.getIfPresent(UUID.fromString(writer));\r\n        if (batchwriter == null) {\r\n            throw new UnknownWriter(\"Writer never existed or no longer exists\");\r\n        }\r\n        batchwriter.flush();\r\n    } catch (Exception e) {\r\n        throw translateException(e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void flush(String writer) throws TException {\r\n    try {\r\n        BatchWriter batchwriter = writerCache.getIfPresent(UUID.fromString(writer));\r\n        if (batchwriter == null) {\r\n            throw new UnknownWriter(\"Writer never existed or no longer exists\");\r\n        }\r\n        batchwriter.flush();\r\n    } catch (Exception e) {\r\n        throw translateException(e);\r\n    }\r\n}","lc":-0.0909090909,"pi":0.3732057416,"ma":0.2,"nbd":0.0,"ml":-0.25,"d":-0.1111111111,"mi":0.1241719521,"fo":-0.1666666667,"r":1.0789473684,"e":-0.0991430531}
{"project_name":"Compress","project_version":"21","label":0,"code":"private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\r\n    int cache = 0;\r\n    int shift = 7;\r\n    for (int i = 0; i < length; i++) {\r\n        cache |= ((bits.get(i) ? 1 : 0) << shift);\r\n        --shift;\r\n        if (shift == 0) {\r\n            header.write(cache);\r\n            shift = 7;\r\n            cache = 0;\r\n        }\r\n    }\r\n    if (length > 0 && shift > 0) {\r\n        header.write(cache);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\r\n    int cache = 0;\r\n    int shift = 7;\r\n    for (int i = 0; i < length; i++) {\r\n        cache |= ((bits.get(i) ? 1 : 0) << shift);\r\n        --shift;\r\n        if (shift == 0) {\r\n            header.write(cache);\r\n            shift = 7;\r\n            cache = 0;\r\n        }\r\n    }\r\n    if (length > 0 && shift > 0) {\r\n        header.write(cache);\r\n    }\r\n}","lc":0.0909090909,"pi":0.3540669856,"ma":0.2,"nbd":0.0,"ml":0.3333333333,"d":1.6686507937,"mi":-0.1334742777,"fo":-0.25,"r":0.0263157895,"e":1.0441797341}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-434_133cbc2d","label":1,"code":"\/**\r\n * Returns whether the problem is at an optimal state.\r\n * @return whether the model has been solved\r\n *\/\r\nboolean isOptimal() {\r\n    for (int i = getNumObjectiveFunctions(); i < getWidth() - 1; i++) {\r\n        if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n * Returns whether the problem is at an optimal state.\r\n * @return whether the model has been solved\r\n *\/\r\n","code_no_comment":"boolean isOptimal() {\r\n    for (int i = getNumObjectiveFunctions(); i < getWidth() - 1; i++) {\r\n        if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}","lc":-0.2727272727,"pi":0.4210526316,"ma":-0.2,"nbd":0.0,"ml":0.1666666667,"d":0.1726190476,"mi":0.3333333333,"fo":-0.1666666667,"r":1.6578947368,"e":-0.0375581335}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-278_db19e70f","label":1,"code":"private void buildPath(StringBuilder sb) {\r\n    if (isRemoved()) {\r\n        throw new IllegalStateException(\"Cannot build the path of a removed tree\");\r\n    }\r\n    if (!isRoot()) {\r\n        parent.buildPath(sb);\r\n        sb.append('\/').append(name);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void buildPath(StringBuilder sb) {\r\n    if (isRemoved()) {\r\n        throw new IllegalStateException(\"Cannot build the path of a removed tree\");\r\n    }\r\n    if (!isRoot()) {\r\n        parent.buildPath(sb);\r\n        sb.append('\/').append(name);\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.3412262156,"fo":-0.0833333333,"r":1.3157894737,"e":-0.1627934049}
{"project_name":"Closure","project_version":"109","label":2,"code":"\/**\r\n * ContextTypeExpression := BasicTypeExpression | '?'\r\n * For expressions on the right hand side of a this: or new:\r\n *\/\r\nprivate Node parseContextTypeExpression(JsDocToken token) {\r\n    return parseTypeName(token);\r\n}","code_comment":"\/**\r\n * ContextTypeExpression := BasicTypeExpression | '?'\r\n * For expressions on the right hand side of a this: or new:\r\n *\/\r\n","code_no_comment":"private Node parseContextTypeExpression(JsDocToken token) {\r\n    return parseTypeName(token);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0451021846,"fo":-0.4166666667,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"Cli","project_version":"4","label":1,"code":"\/**\r\n * <p>Throws a {@link MissingOptionException} if all of the\r\n * required options are no present.<\/p>\r\n *\r\n * @throws MissingOptionException if any of the required Options\r\n * are not present.\r\n *\/\r\nprivate void checkRequiredOptions() throws MissingOptionException {\r\n    \/\/ processsed\r\n    if (requiredOptions.size() > 0) {\r\n        Iterator iter = requiredOptions.iterator();\r\n        StringBuffer buff = new StringBuffer();\r\n        \/\/ loop through the required options\r\n        while (iter.hasNext()) {\r\n            buff.append(iter.next());\r\n        }\r\n        throw new MissingOptionException(buff.toString());\r\n    }\r\n}","code_comment":"\/**\r\n * <p>Throws a {@link MissingOptionException} if all of the\r\n * required options are no present.<\/p>\r\n *\r\n * @throws MissingOptionException if any of the required Options\r\n * are not present.\r\n *\/\r\n","code_no_comment":"private void checkRequiredOptions() throws MissingOptionException {\r\n        if (requiredOptions.size() > 0) {\r\n        Iterator iter = requiredOptions.iterator();\r\n        StringBuffer buff = new StringBuffer();\r\n                while (iter.hasNext()) {\r\n            buff.append(iter.next());\r\n        }\r\n        throw new MissingOptionException(buff.toString());\r\n    }\r\n}","lc":-0.1818181818,"pi":0.3349282297,"ma":0.0,"nbd":0.0,"ml":-0.0833333333,"d":-0.0734126984,"mi":0.221987315,"fo":0.0,"r":2.1578947368,"e":-0.0936982417}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1932_913c2f53","label":1,"code":"public SegmentNodeState writeNode(NodeState state) {\r\n    if (state instanceof SegmentNodeState && store.containsSegment(((SegmentNodeState) state).getRecordId().getSegmentId())) {\r\n        return (SegmentNodeState) state;\r\n    }\r\n    SegmentNodeState before = null;\r\n    Template beforeTemplate = null;\r\n    ModifiedNodeState after = null;\r\n    if (state instanceof ModifiedNodeState) {\r\n        after = (ModifiedNodeState) state;\r\n        NodeState base = after.getBaseState();\r\n        if (base instanceof SegmentNodeState && store.containsSegment(((SegmentNodeState) base).getRecordId().getSegmentId())) {\r\n            before = (SegmentNodeState) base;\r\n            beforeTemplate = before.getTemplate();\r\n        }\r\n    }\r\n    Template template = new Template(state);\r\n    RecordId templateId;\r\n    if (before != null && template.equals(beforeTemplate)) {\r\n        templateId = before.getTemplateId();\r\n    } else {\r\n        templateId = writeTemplate(template);\r\n    }\r\n    List<RecordId> ids = Lists.newArrayList();\r\n    ids.add(templateId);\r\n    String childName = template.getChildName();\r\n    if (childName == Template.MANY_CHILD_NODES) {\r\n        MapRecord base;\r\n        final Map<String, RecordId> childNodes = Maps.newHashMap();\r\n        if (before != null && before.getChildNodeCount(2) > 1 && after.getChildNodeCount(2) > 1) {\r\n            base = before.getChildNodeMap();\r\n            after.compareAgainstBaseState(before, new DefaultNodeStateDiff() {\r\n\r\n                @Override\r\n                public boolean childNodeAdded(String name, NodeState after) {\r\n                    childNodes.put(name, writeNode(after).getRecordId());\r\n                    return true;\r\n                }\r\n\r\n                @Override\r\n                public boolean childNodeChanged(String name, NodeState before, NodeState after) {\r\n                    childNodes.put(name, writeNode(after).getRecordId());\r\n                    return true;\r\n                }\r\n\r\n                @Override\r\n                public boolean childNodeDeleted(String name, NodeState before) {\r\n                    childNodes.put(name, null);\r\n                    return true;\r\n                }\r\n            });\r\n        } else {\r\n            base = null;\r\n            for (ChildNodeEntry entry : state.getChildNodeEntries()) {\r\n                childNodes.put(entry.getName(), writeNode(entry.getNodeState()).getRecordId());\r\n            }\r\n        }\r\n        ids.add(writeMap(base, childNodes).getRecordId());\r\n    } else if (childName != Template.ZERO_CHILD_NODES) {\r\n        ids.add(writeNode(state.getChildNode(template.getChildName())).getRecordId());\r\n    }\r\n    for (PropertyTemplate pt : template.getPropertyTemplates()) {\r\n        String name = pt.getName();\r\n        PropertyState property = state.getProperty(name);\r\n        if (property instanceof SegmentPropertyState && store.containsSegment(((SegmentPropertyState) property).getRecordId().getSegmentId())) {\r\n            ids.add(((SegmentPropertyState) property).getRecordId());\r\n        } else if (!(before instanceof SegmentNodeState) || store.containsSegment(((SegmentNodeState) before).getRecordId().getSegmentId())) {\r\n            ids.add(writeProperty(property));\r\n        } else {\r\n            \/\/ reuse previously stored property, if possible\r\n            PropertyTemplate bt = beforeTemplate.getPropertyTemplate(name);\r\n            if (bt == null) {\r\n                \/\/ new property\r\n                ids.add(writeProperty(property));\r\n            } else {\r\n                SegmentPropertyState bp = beforeTemplate.getProperty(before.getRecordId(), bt.getIndex());\r\n                if (property.equals(bp)) {\r\n                    \/\/ no changes\r\n                    ids.add(bp.getRecordId());\r\n                } else if (bp.isArray() && bp.getType() != BINARIES) {\r\n                    \/\/ reuse entries from the previous list\r\n                    ids.add(writeProperty(property, bp.getValueRecords()));\r\n                } else {\r\n                    ids.add(writeProperty(property));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    synchronized (this) {\r\n        RecordId recordId = prepare(RecordType.NODE, 0, ids);\r\n        for (RecordId id : ids) {\r\n            writeRecordId(id);\r\n        }\r\n        return new SegmentNodeState(recordId);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public SegmentNodeState writeNode(NodeState state) {\r\n    if (state instanceof SegmentNodeState && store.containsSegment(((SegmentNodeState) state).getRecordId().getSegmentId())) {\r\n        return (SegmentNodeState) state;\r\n    }\r\n    SegmentNodeState before = null;\r\n    Template beforeTemplate = null;\r\n    ModifiedNodeState after = null;\r\n    if (state instanceof ModifiedNodeState) {\r\n        after = (ModifiedNodeState) state;\r\n        NodeState base = after.getBaseState();\r\n        if (base instanceof SegmentNodeState && store.containsSegment(((SegmentNodeState) base).getRecordId().getSegmentId())) {\r\n            before = (SegmentNodeState) base;\r\n            beforeTemplate = before.getTemplate();\r\n        }\r\n    }\r\n    Template template = new Template(state);\r\n    RecordId templateId;\r\n    if (before != null && template.equals(beforeTemplate)) {\r\n        templateId = before.getTemplateId();\r\n    } else {\r\n        templateId = writeTemplate(template);\r\n    }\r\n    List<RecordId> ids = Lists.newArrayList();\r\n    ids.add(templateId);\r\n    String childName = template.getChildName();\r\n    if (childName == Template.MANY_CHILD_NODES) {\r\n        MapRecord base;\r\n        final Map<String, RecordId> childNodes = Maps.newHashMap();\r\n        if (before != null && before.getChildNodeCount(2) > 1 && after.getChildNodeCount(2) > 1) {\r\n            base = before.getChildNodeMap();\r\n            after.compareAgainstBaseState(before, new DefaultNodeStateDiff() {\r\n\r\n                @Override\r\n                public boolean childNodeAdded(String name, NodeState after) {\r\n                    childNodes.put(name, writeNode(after).getRecordId());\r\n                    return true;\r\n                }\r\n\r\n                @Override\r\n                public boolean childNodeChanged(String name, NodeState before, NodeState after) {\r\n                    childNodes.put(name, writeNode(after).getRecordId());\r\n                    return true;\r\n                }\r\n\r\n                @Override\r\n                public boolean childNodeDeleted(String name, NodeState before) {\r\n                    childNodes.put(name, null);\r\n                    return true;\r\n                }\r\n            });\r\n        } else {\r\n            base = null;\r\n            for (ChildNodeEntry entry : state.getChildNodeEntries()) {\r\n                childNodes.put(entry.getName(), writeNode(entry.getNodeState()).getRecordId());\r\n            }\r\n        }\r\n        ids.add(writeMap(base, childNodes).getRecordId());\r\n    } else if (childName != Template.ZERO_CHILD_NODES) {\r\n        ids.add(writeNode(state.getChildNode(template.getChildName())).getRecordId());\r\n    }\r\n    for (PropertyTemplate pt : template.getPropertyTemplates()) {\r\n        String name = pt.getName();\r\n        PropertyState property = state.getProperty(name);\r\n        if (property instanceof SegmentPropertyState && store.containsSegment(((SegmentPropertyState) property).getRecordId().getSegmentId())) {\r\n            ids.add(((SegmentPropertyState) property).getRecordId());\r\n        } else if (!(before instanceof SegmentNodeState) || store.containsSegment(((SegmentNodeState) before).getRecordId().getSegmentId())) {\r\n            ids.add(writeProperty(property));\r\n        } else {\r\n                        PropertyTemplate bt = beforeTemplate.getPropertyTemplate(name);\r\n            if (bt == null) {\r\n                                ids.add(writeProperty(property));\r\n            } else {\r\n                SegmentPropertyState bp = beforeTemplate.getProperty(before.getRecordId(), bt.getIndex());\r\n                if (property.equals(bp)) {\r\n                                        ids.add(bp.getRecordId());\r\n                } else if (bp.isArray() && bp.getType() != BINARIES) {\r\n                                        ids.add(writeProperty(property, bp.getValueRecords()));\r\n                } else {\r\n                    ids.add(writeProperty(property));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    synchronized (this) {\r\n        RecordId recordId = prepare(RecordType.NODE, 0, ids);\r\n        for (RecordId id : ids) {\r\n            writeRecordId(id);\r\n        }\r\n        return new SegmentNodeState(recordId);\r\n    }\r\n}","lc":3.3636363636,"pi":1.1818181818,"ma":2.4,"nbd":2.0,"ml":3.0833333333,"d":1.5734126984,"mi":-1.2827343199,"fo":5.4166666667,"r":-0.0263157895,"e":8.7029315998}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1926_9225a3e2","label":1,"code":"\/**\r\n * Initialize with un-merged branches from <code>store<\/code> for this\r\n * <code>clusterId<\/code>.\r\n *\r\n * @param store the document store.\r\n * @param context the revision context.\r\n *\/\r\nvoid init(DocumentStore store, RevisionContext context) {\r\n    if (!initialized.compareAndSet(false, true)) {\r\n        throw new IllegalStateException(\"already initialized\");\r\n    }\r\n    NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath(\"\/\"));\r\n    if (doc == null) {\r\n        return;\r\n    }\r\n    SortedMap<Revision, Revision> revisions = doc.getUncommittedRevisions(context);\r\n    while (!revisions.isEmpty()) {\r\n        SortedSet<Revision> commits = new TreeSet<Revision>(comparator);\r\n        Revision head = revisions.lastKey();\r\n        commits.add(head);\r\n        Revision base = revisions.remove(head).asTrunkRevision();\r\n        while (revisions.containsKey(base)) {\r\n            commits.add(base);\r\n            base = revisions.remove(base).asTrunkRevision();\r\n        }\r\n        branches.add(new Branch(commits, base));\r\n    }\r\n}","code_comment":"\/**\r\n * Initialize with un-merged branches from <code>store<\/code> for this\r\n * <code>clusterId<\/code>.\r\n *\r\n * @param store the document store.\r\n * @param context the revision context.\r\n *\/\r\n","code_no_comment":"void init(DocumentStore store, RevisionContext context) {\r\n    if (!initialized.compareAndSet(false, true)) {\r\n        throw new IllegalStateException(\"already initialized\");\r\n    }\r\n    NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath(\"\/\"));\r\n    if (doc == null) {\r\n        return;\r\n    }\r\n    SortedMap<Revision, Revision> revisions = doc.getUncommittedRevisions(context);\r\n    while (!revisions.isEmpty()) {\r\n        SortedSet<Revision> commits = new TreeSet<Revision>(comparator);\r\n        Revision head = revisions.lastKey();\r\n        commits.add(head);\r\n        Revision base = revisions.remove(head).asTrunkRevision();\r\n        while (revisions.containsKey(base)) {\r\n            commits.add(base);\r\n            base = revisions.remove(base).asTrunkRevision();\r\n        }\r\n        branches.add(new Branch(commits, base));\r\n    }\r\n}","lc":0.3181818182,"pi":0.0909090909,"ma":0.4,"nbd":0.0,"ml":0.3333333333,"d":-0.0238095238,"mi":-0.3333333333,"fo":0.6666666667,"r":-0.0263157895,"e":0.1617929612}
{"project_name":"Closure","project_version":"34","label":2,"code":"@Override\r\nvoid appendOp(String op, boolean binOp) {\r\n    if (binOp) {\r\n        if (getLastChar() != ' ') {\r\n            append(\" \");\r\n        }\r\n        append(op);\r\n        append(\" \");\r\n    } else {\r\n        append(op);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\nvoid appendOp(String op, boolean binOp) {\r\n    if (binOp) {\r\n        if (getLastChar() != ' ') {\r\n            append(\" \");\r\n        }\r\n        append(op);\r\n        append(\" \");\r\n    } else {\r\n        append(op);\r\n    }\r\n}","lc":-0.0909090909,"pi":0.3732057416,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.2236786469,"fo":-0.0833333333,"r":1.3947368421,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"@Override\r\npublic NodeState getNodeState() {\r\n    return context.getNodeState(path);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic NodeState getNodeState() {\r\n    return context.getNodeState(path);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9134601832,"fo":-0.4166666667,"r":1.5526315789,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-555_328513f3","label":3,"code":"\/**\r\n * Round the given value to the specified number of decimal places. The\r\n * value is rounded using the given method which is any method defined in\r\n * {@link BigDecimal}.\r\n *\r\n * @param x the value to round.\r\n * @param scale the number of digits to the right of the decimal point.\r\n * @param roundingMethod the rounding method as defined in\r\n *        {@link BigDecimal}.\r\n * @return the rounded value.\r\n * @since 1.1\r\n *\/\r\npublic static double round(double x, int scale, int roundingMethod) {\r\n    try {\r\n        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();\r\n    } catch (NumberFormatException ex) {\r\n        if (Double.isInfinite(x)) {\r\n            return x;\r\n        } else {\r\n            return Double.NaN;\r\n        }\r\n    } catch (RuntimeException ex) {\r\n        throw new MathRuntimeException(ex);\r\n    }\r\n}","code_comment":"\/**\r\n * Round the given value to the specified number of decimal places. The\r\n * value is rounded using the given method which is any method defined in\r\n * {@link BigDecimal}.\r\n *\r\n * @param x the value to round.\r\n * @param scale the number of digits to the right of the decimal point.\r\n * @param roundingMethod the rounding method as defined in\r\n *        {@link BigDecimal}.\r\n * @return the rounded value.\r\n * @since 1.1\r\n *\/\r\n","code_no_comment":"public static double round(double x, int scale, int roundingMethod) {\r\n    try {\r\n        return (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();\r\n    } catch (NumberFormatException ex) {\r\n        if (Double.isInfinite(x)) {\r\n            return x;\r\n        } else {\r\n            return Double.NaN;\r\n        }\r\n    } catch (RuntimeException ex) {\r\n        throw new MathRuntimeException(ex);\r\n    }\r\n}","lc":-0.0454545455,"pi":0.3492822967,"ma":0.2,"nbd":0.0,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.0988019732,"fo":-0.1666666667,"r":0.1052631579,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3718_73ce9cfb","label":0,"code":"@Override\r\npublic int hashCode() {\r\n    return toThrift().hashCode();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int hashCode() {\r\n    return toThrift().hashCode();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0005637773,"fo":-0.3333333333,"r":1.6578947368,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public void read(org.apache.thrift.protocol.TProtocol iprot, removeTableProperty_result struct) throws org.apache.thrift.TException {\r\n    org.apache.thrift.protocol.TField schemeField;\r\n    iprot.readStructBegin();\r\n    while (true) {\r\n        schemeField = iprot.readFieldBegin();\r\n        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {\r\n            break;\r\n        }\r\n        switch(schemeField.id) {\r\n            case \/\/ OUCH1\r\n            1:\r\n                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\r\n                    struct.ouch1 = new AccumuloException();\r\n                    struct.ouch1.read(iprot);\r\n                    struct.setOuch1IsSet(true);\r\n                } else {\r\n                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n                }\r\n                break;\r\n            case \/\/ OUCH2\r\n            2:\r\n                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\r\n                    struct.ouch2 = new AccumuloSecurityException();\r\n                    struct.ouch2.read(iprot);\r\n                    struct.setOuch2IsSet(true);\r\n                } else {\r\n                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n                }\r\n                break;\r\n            default:\r\n                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n        }\r\n        iprot.readFieldEnd();\r\n    }\r\n    iprot.readStructEnd();\r\n    \/\/ check for required fields of primitive type, which can't be checked in the validate method\r\n    struct.validate();\r\n}","code_comment":null,"code_no_comment":"public void read(org.apache.thrift.protocol.TProtocol iprot, removeTableProperty_result struct) throws org.apache.thrift.TException {\r\n    org.apache.thrift.protocol.TField schemeField;\r\n    iprot.readStructBegin();\r\n    while (true) {\r\n        schemeField = iprot.readFieldBegin();\r\n        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {\r\n            break;\r\n        }\r\n        switch(schemeField.id) {\r\n            case             1:\r\n                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\r\n                    struct.ouch1 = new AccumuloException();\r\n                    struct.ouch1.read(iprot);\r\n                    struct.setOuch1IsSet(true);\r\n                } else {\r\n                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n                }\r\n                break;\r\n            case             2:\r\n                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\r\n                    struct.ouch2 = new AccumuloSecurityException();\r\n                    struct.ouch2.read(iprot);\r\n                    struct.setOuch2IsSet(true);\r\n                } else {\r\n                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n                }\r\n                break;\r\n            default:\r\n                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n        }\r\n        iprot.readFieldEnd();\r\n    }\r\n    iprot.readStructEnd();\r\n        struct.validate();\r\n}","lc":1.0454545455,"pi":1.5358851675,"ma":1.4,"nbd":1.0,"ml":0.25,"d":0.2599206349,"mi":-0.6763918252,"fo":0.5,"r":-0.0263157895,"e":0.6848267953}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7456_02da984a","label":3,"code":"public void setPropertyPrefix(String propertyPrefix) {\r\n    this.propertyPrefix = propertyPrefix;\r\n}","code_comment":null,"code_no_comment":"public void setPropertyPrefix(String propertyPrefix) {\r\n    this.propertyPrefix = propertyPrefix;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0606060606,"fo":-0.5,"r":1.1842105263,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  Registers a warning feedback message for this component.\r\n *\r\n *  @param message\r\n *             The feedback message\r\n *\/\r\npublic final void warn(final String message) {\r\n    getPage().getFeedbackMessages().warn(this, message);\r\n}","code_comment":"\/**\r\n *  Registers a warning feedback message for this component.\r\n *\r\n *  @param message\r\n *             The feedback message\r\n *\/\r\n","code_no_comment":"public final void warn(final String message) {\r\n    getPage().getFeedbackMessages().warn(this, message);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0253699789,"fo":-0.25,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1514_fb25913c","label":1,"code":"static FileObject[] resolve(FileSystemManager vfs, String uris, ArrayList<FileObject> pathsToMonitor) throws FileSystemException {\r\n    if (uris == null)\r\n        return new FileObject[0];\r\n    ArrayList<FileObject> classpath = new ArrayList<FileObject>();\r\n    pathsToMonitor.clear();\r\n    for (String path : uris.split(\",\")) {\r\n        path = path.trim();\r\n        if (path.equals(\"\"))\r\n            continue;\r\n        path = AccumuloClassLoader.replaceEnvVars(path, System.getenv());\r\n        FileObject fo = vfs.resolveFile(path);\r\n        switch(fo.getType()) {\r\n            case FILE:\r\n            case FOLDER:\r\n                classpath.add(fo);\r\n                pathsToMonitor.add(fo);\r\n                break;\r\n            case IMAGINARY:\r\n                \/\/ assume its a pattern\r\n                String pattern = fo.getName().getBaseName();\r\n                if (fo.getParent() != null && fo.getParent().getType() == FileType.FOLDER) {\r\n                    pathsToMonitor.add(fo.getParent());\r\n                    FileObject[] children = fo.getParent().getChildren();\r\n                    for (FileObject child : children) {\r\n                        if (child.getType() == FileType.FILE && child.getName().getBaseName().matches(pattern)) {\r\n                            classpath.add(child);\r\n                        }\r\n                    }\r\n                } else {\r\n                    log.warn(\"ignoring classpath entry \" + fo);\r\n                }\r\n                break;\r\n            default:\r\n                log.warn(\"ignoring classpath entry \" + fo);\r\n                break;\r\n        }\r\n    }\r\n    return classpath.toArray(new FileObject[classpath.size()]);\r\n}","code_comment":null,"code_no_comment":"static FileObject[] resolve(FileSystemManager vfs, String uris, ArrayList<FileObject> pathsToMonitor) throws FileSystemException {\r\n    if (uris == null)\r\n        return new FileObject[0];\r\n    ArrayList<FileObject> classpath = new ArrayList<FileObject>();\r\n    pathsToMonitor.clear();\r\n    for (String path : uris.split(\",\")) {\r\n        path = path.trim();\r\n        if (path.equals(\"\"))\r\n            continue;\r\n        path = AccumuloClassLoader.replaceEnvVars(path, System.getenv());\r\n        FileObject fo = vfs.resolveFile(path);\r\n        switch(fo.getType()) {\r\n            case FILE:\r\n            case FOLDER:\r\n                classpath.add(fo);\r\n                pathsToMonitor.add(fo);\r\n                break;\r\n            case IMAGINARY:\r\n                                String pattern = fo.getName().getBaseName();\r\n                if (fo.getParent() != null && fo.getParent().getType() == FileType.FOLDER) {\r\n                    pathsToMonitor.add(fo.getParent());\r\n                    FileObject[] children = fo.getParent().getChildren();\r\n                    for (FileObject child : children) {\r\n                        if (child.getType() == FileType.FILE && child.getName().getBaseName().matches(pattern)) {\r\n                            classpath.add(child);\r\n                        }\r\n                    }\r\n                } else {\r\n                    log.warn(\"ignoring classpath entry \" + fo);\r\n                }\r\n                break;\r\n            default:\r\n                log.warn(\"ignoring classpath entry \" + fo);\r\n                break;\r\n        }\r\n    }\r\n    return classpath.toArray(new FileObject[classpath.size()]);\r\n}","lc":1.0909090909,"pi":1.8612440191,"ma":2.2,"nbd":2.0,"ml":1.0,"d":0.5615079365,"mi":-0.7350246653,"fo":1.8333333333,"r":-0.0263157895,"e":1.2821885283}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8964_ea8ee025","label":1,"code":"public synchronized void resumeRoute(String routeId) throws Exception {\r\n    if (!routeSupportsSuspension(routeId)) {\r\n        \/\/ start route if suspension is not supported\r\n        startRoute(routeId);\r\n        return;\r\n    }\r\n    RouteService routeService = routeServices.get(routeId);\r\n    if (routeService != null) {\r\n        resumeRouteService(routeService);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public synchronized void resumeRoute(String routeId) throws Exception {\r\n    if (!routeSupportsSuspension(routeId)) {\r\n                startRoute(routeId);\r\n        return;\r\n    }\r\n    RouteService routeService = routeServices.get(routeId);\r\n    if (routeService != null) {\r\n        resumeRouteService(routeService);\r\n    }\r\n}","lc":-0.1818181818,"pi":-0.0909090909,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":-0.0912698413,"mi":0.2572233968,"fo":-0.1666666667,"r":1.3947368421,"e":-0.1091705422}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7883_d57f402b","label":1,"code":"@Override\r\npublic Reader getCharacterStream() {\r\n    InputStream is = getByteStream();\r\n    return camelContext.getTypeConverter().convertTo(Reader.class, is);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Reader getCharacterStream() {\r\n    InputStream is = getByteStream();\r\n    return camelContext.getTypeConverter().convertTo(Reader.class, is);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6783650458,"fo":-0.25,"r":0.5,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5497_724066f4","label":1,"code":"\/**\r\n *  Converts a Map to JSONArray suitable for jQuery#param().\r\n *\r\n *  @param map\r\n *       the map with key\/value(s)\r\n *  @return a JSONArray that contains JSONObject's with name\/value pairs\r\n *  @throws JSONException\r\n *\/\r\npublic static JSONArray asArray(Map<String, Object> map) throws JSONException {\r\n    JSONArray jsonArray = new JSONArray();\r\n    if (map != null) {\r\n        for (Map.Entry<String, Object> entry : map.entrySet()) {\r\n            String name = entry.getKey();\r\n            Object value = entry.getValue();\r\n            if (value instanceof List) {\r\n                List<?> values = (List<?>) value;\r\n                for (Object v : values) {\r\n                    if (v != null) {\r\n                        JSONObject object = new JSONObject();\r\n                        object.put(\"name\", name);\r\n                        object.put(\"value\", v);\r\n                        jsonArray.put(object);\r\n                    }\r\n                }\r\n            } else if (value.getClass().isArray()) {\r\n                Object[] array = (Object[]) value;\r\n                for (Object v : array) {\r\n                    if (v != null) {\r\n                        JSONObject object = new JSONObject();\r\n                        object.put(\"name\", name);\r\n                        object.put(\"value\", v);\r\n                        jsonArray.put(object);\r\n                    }\r\n                }\r\n            } else {\r\n                if (value != null) {\r\n                    JSONObject object = new JSONObject();\r\n                    object.put(\"name\", name);\r\n                    object.put(\"value\", value);\r\n                    jsonArray.put(object);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return jsonArray;\r\n}","code_comment":"\/**\r\n *  Converts a Map to JSONArray suitable for jQuery#param().\r\n *\r\n *  @param map\r\n *       the map with key\/value(s)\r\n *  @return a JSONArray that contains JSONObject's with name\/value pairs\r\n *  @throws JSONException\r\n *\/\r\n","code_no_comment":"public static JSONArray asArray(Map<String, Object> map) throws JSONException {\r\n    JSONArray jsonArray = new JSONArray();\r\n    if (map != null) {\r\n        for (Map.Entry<String, Object> entry : map.entrySet()) {\r\n            String name = entry.getKey();\r\n            Object value = entry.getValue();\r\n            if (value instanceof List) {\r\n                List<?> values = (List<?>) value;\r\n                for (Object v : values) {\r\n                    if (v != null) {\r\n                        JSONObject object = new JSONObject();\r\n                        object.put(\"name\", name);\r\n                        object.put(\"value\", v);\r\n                        jsonArray.put(object);\r\n                    }\r\n                }\r\n            } else if (value.getClass().isArray()) {\r\n                Object[] array = (Object[]) value;\r\n                for (Object v : array) {\r\n                    if (v != null) {\r\n                        JSONObject object = new JSONObject();\r\n                        object.put(\"name\", name);\r\n                        object.put(\"value\", v);\r\n                        jsonArray.put(object);\r\n                    }\r\n                }\r\n            } else {\r\n                if (value != null) {\r\n                    JSONObject object = new JSONObject();\r\n                    object.put(\"name\", name);\r\n                    object.put(\"value\", value);\r\n                    jsonArray.put(object);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return jsonArray;\r\n}","lc":1.0909090909,"pi":1.985645933,"ma":1.2,"nbd":2.0,"ml":0.4166666667,"d":0.3670634921,"mi":-0.6648343904,"fo":0.6666666667,"r":-0.0263157895,"e":0.7210225734}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1008_0c20bfd8","label":1,"code":"\/**\r\n * Returns the matching resources.\r\n * @return A Set of URIs that match the criteria.\r\n *\/\r\npublic Set<URI> getResources() {\r\n    return resourceMatches;\r\n}","code_comment":"\/**\r\n * Returns the matching resources.\r\n * @return A Set of URIs that match the criteria.\r\n *\/\r\n","code_no_comment":"public Set<URI> getResources() {\r\n    return resourceMatches;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2330_408a566e","label":3,"code":"private boolean indexAggregates(final String path, final List<Field> fields, final NodeState state) throws CommitFailedException {\r\n    final AtomicBoolean dirtyFlag = new AtomicBoolean();\r\n    indexingRule.getAggregate().collectAggregates(state, new Aggregate.ResultCollector() {\r\n\r\n        @Override\r\n        public void onResult(Aggregate.NodeIncludeResult result) throws CommitFailedException {\r\n            boolean dirty = indexAggregatedNode(path, fields, result);\r\n            if (dirty) {\r\n                dirtyFlag.set(true);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void onResult(Aggregate.PropertyIncludeResult result) throws CommitFailedException {\r\n            boolean dirty = false;\r\n            if (result.pd.ordered) {\r\n                dirty |= addTypedOrderedFields(fields, result.propertyState, result.propertyPath, result.pd);\r\n            }\r\n            dirty |= indexProperty(path, fields, state, result.propertyState, result.propertyPath, true, result.pd);\r\n            if (dirty) {\r\n                dirtyFlag.set(true);\r\n            }\r\n        }\r\n    });\r\n    return dirtyFlag.get();\r\n}","code_comment":null,"code_no_comment":"private boolean indexAggregates(final String path, final List<Field> fields, final NodeState state) throws CommitFailedException {\r\n    final AtomicBoolean dirtyFlag = new AtomicBoolean();\r\n    indexingRule.getAggregate().collectAggregates(state, new Aggregate.ResultCollector() {\r\n\r\n        @Override\r\n        public void onResult(Aggregate.NodeIncludeResult result) throws CommitFailedException {\r\n            boolean dirty = indexAggregatedNode(path, fields, result);\r\n            if (dirty) {\r\n                dirtyFlag.set(true);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void onResult(Aggregate.PropertyIncludeResult result) throws CommitFailedException {\r\n            boolean dirty = false;\r\n            if (result.pd.ordered) {\r\n                dirty |= addTypedOrderedFields(fields, result.propertyState, result.propertyPath, result.pd);\r\n            }\r\n            dirty |= indexProperty(path, fields, state, result.propertyState, result.propertyPath, true, result.pd);\r\n            if (dirty) {\r\n                dirtyFlag.set(true);\r\n            }\r\n        }\r\n    });\r\n    return dirtyFlag.get();\r\n}","lc":0.4545454545,"pi":0.7416267943,"ma":0.0,"nbd":0.0,"ml":0.0,"d":0.0555555556,"mi":-0.3773079634,"fo":0.1666666667,"r":-0.0263157895,"e":0.2258582436}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-193_8ad5a888","label":3,"code":"public String toString() {\r\n    String labelString = new ColumnVisibility(colVisibility).toString();\r\n    String s = toPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT) + \" \" + toPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT) + \":\" + toPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT) + \" \" + labelString + \" \" + Long.toString(timestamp) + \" \" + deleted;\r\n    return s;\r\n}","code_comment":null,"code_no_comment":"public String toString() {\r\n    String labelString = new ColumnVisibility(colVisibility).toString();\r\n    String s = toPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT) + \" \" + toPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT) + \":\" + toPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT) + \" \" + labelString + \" \" + Long.toString(timestamp) + \" \" + deleted;\r\n    return s;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":0.0515873016,"mi":0.459055673,"fo":-0.0833333333,"r":-0.0263157895,"e":0.0314955366}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-293_59a0da9c","label":1,"code":"\/**\r\n * Removes the phase 1 objective function, positive cost non-artificial variables,\r\n * and the non-basic artificial variables from this tableau.\r\n *\/\r\nprotected void dropPhase1Objective() {\r\n    if (getNumObjectiveFunctions() == 1) {\r\n        return;\r\n    }\r\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\r\n    columnsToDrop.add(0);\r\n    \/\/ positive cost non-artificial variables\r\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\r\n        if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) > 0) {\r\n            columnsToDrop.add(i);\r\n        }\r\n    }\r\n    \/\/ non-basic artificial variables\r\n    for (int i = 0; i < getNumArtificialVariables(); i++) {\r\n        int col = i + getArtificialVariableOffset();\r\n        if (getBasicRow(col) == null) {\r\n            columnsToDrop.add(col);\r\n        }\r\n    }\r\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\r\n    for (int i = 1; i < getHeight(); i++) {\r\n        int col = 0;\r\n        for (int j = 0; j < getWidth(); j++) {\r\n            if (!columnsToDrop.contains(j)) {\r\n                matrix[i - 1][col++] = tableau.getEntry(i, j);\r\n            }\r\n        }\r\n    }\r\n    this.tableau = new Array2DRowRealMatrix(matrix);\r\n    this.numArtificialVariables = 0;\r\n}","code_comment":"\/**\r\n * Removes the phase 1 objective function, positive cost non-artificial variables,\r\n * and the non-basic artificial variables from this tableau.\r\n *\/\r\n","code_no_comment":"protected void dropPhase1Objective() {\r\n    if (getNumObjectiveFunctions() == 1) {\r\n        return;\r\n    }\r\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\r\n    columnsToDrop.add(0);\r\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\r\n        if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) > 0) {\r\n            columnsToDrop.add(i);\r\n        }\r\n    }\r\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\r\n        int col = i + getArtificialVariableOffset();\r\n        if (getBasicRow(col) == null) {\r\n            columnsToDrop.add(col);\r\n        }\r\n    }\r\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\r\n    for (int i = 1; i < getHeight(); i++) {\r\n        int col = 0;\r\n        for (int j = 0; j < getWidth(); j++) {\r\n            if (!columnsToDrop.contains(j)) {\r\n                matrix[i - 1][col++] = tableau.getEntry(i, j);\r\n            }\r\n        }\r\n    }\r\n    this.tableau = new Array2DRowRealMatrix(matrix);\r\n    this.numArtificialVariables = 0;\r\n}","lc":0.6818181818,"pi":0.3397129187,"ma":1.0,"nbd":0.5,"ml":1.3333333333,"d":1.7420634921,"mi":-0.5424947146,"fo":1.0,"r":-0.0263157895,"e":2.5155558629}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2359_b3071839","label":0,"code":"@Override\r\npublic String get(Object key) {\r\n    \/\/ first check values map of this document\r\n    String value = map.get(key);\r\n    if (value != null) {\r\n        return value;\r\n    }\r\n    Revision r = (Revision) key;\r\n    for (NodeDocument prev : doc.getPreviousDocs(property, r)) {\r\n        value = prev.getValueMap(property).get(key);\r\n        if (value != null) {\r\n            return value;\r\n        }\r\n    }\r\n    \/\/ not found\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String get(Object key) {\r\n        String value = map.get(key);\r\n    if (value != null) {\r\n        return value;\r\n    }\r\n    Revision r = (Revision) key;\r\n    for (NodeDocument prev : doc.getPreviousDocs(property, r)) {\r\n        value = prev.getValueMap(property).get(key);\r\n        if (value != null) {\r\n            return value;\r\n        }\r\n    }\r\n        return null;\r\n}","lc":0.0454545455,"pi":0.1626794258,"ma":0.0,"nbd":0.0,"ml":-0.1666666667,"d":0.0317460317,"mi":-0.0339675828,"fo":-0.1666666667,"r":0.5,"e":-0.0100344047}
{"project_name":"Lang","project_version":"62","label":3,"code":"\/**\r\n * <p>Unescapes the escaped entities in the <code>String<\/code> passed and\r\n * writes the result to the <code>Writer<\/code> passed.<\/p>\r\n *\r\n * @param writer The <code>Writer<\/code> to write the results to; assumed to be non-null.\r\n * @param string The <code>String<\/code> to write the results to; assumed to be non-null.\r\n * @throws IOException when <code>Writer<\/code> passed throws the exception from\r\n *                                       calls to the {@link Writer#write(int)} methods.\r\n *\r\n * @see #escape(String)\r\n * @see Writer\r\n *\/\r\npublic void unescape(Writer writer, String string) throws IOException {\r\n    int firstAmp = string.indexOf('&');\r\n    if (firstAmp < 0) {\r\n        writer.write(string);\r\n        return;\r\n    }\r\n    writer.write(string, 0, firstAmp);\r\n    int len = string.length();\r\n    for (int i = firstAmp; i < len; i++) {\r\n        char c = string.charAt(i);\r\n        if (c == '&') {\r\n            int nextIdx = i + 1;\r\n            int semiColonIdx = string.indexOf(';', nextIdx);\r\n            if (semiColonIdx == -1) {\r\n                writer.write(c);\r\n                continue;\r\n            }\r\n            int amphersandIdx = string.indexOf('&', i + 1);\r\n            if (amphersandIdx != -1 && amphersandIdx < semiColonIdx) {\r\n                \/\/ Then the text looks like &...&...;\r\n                writer.write(c);\r\n                continue;\r\n            }\r\n            String entityContent = string.substring(nextIdx, semiColonIdx);\r\n            int entityValue = -1;\r\n            int entityContentLen = entityContent.length();\r\n            if (entityContentLen > 0) {\r\n                if (entityContent.charAt(0) == '#') {\r\n                    \/\/ escaped value content is an integer (decimal or hexidecimal)\r\n                    if (entityContentLen > 1) {\r\n                        char isHexChar = entityContent.charAt(1);\r\n                        try {\r\n                            switch(isHexChar) {\r\n                                case 'X':\r\n                                case 'x':\r\n                                    {\r\n                                        entityValue = Integer.parseInt(entityContent.substring(2), 16);\r\n                                    }\r\n                                default:\r\n                                    {\r\n                                        entityValue = Integer.parseInt(entityContent.substring(1), 10);\r\n                                    }\r\n                            }\r\n                        } catch (NumberFormatException e) {\r\n                        }\r\n                    }\r\n                } else {\r\n                    \/\/ escaped value content is an entity name\r\n                    entityValue = this.entityValue(entityContent);\r\n                }\r\n            }\r\n            if (entityValue == -1) {\r\n                writer.write('&');\r\n                writer.write(entityContent);\r\n                writer.write(';');\r\n            } else {\r\n                writer.write(entityValue);\r\n            }\r\n            \/\/ move index up to the semi-colon\r\n            i = semiColonIdx;\r\n        } else {\r\n            writer.write(c);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * <p>Unescapes the escaped entities in the <code>String<\/code> passed and\r\n * writes the result to the <code>Writer<\/code> passed.<\/p>\r\n *\r\n * @param writer The <code>Writer<\/code> to write the results to; assumed to be non-null.\r\n * @param string The <code>String<\/code> to write the results to; assumed to be non-null.\r\n * @throws IOException when <code>Writer<\/code> passed throws the exception from\r\n *                                       calls to the {@link Writer#write(int)} methods.\r\n *\r\n * @see #escape(String)\r\n * @see Writer\r\n *\/\r\n","code_no_comment":"public void unescape(Writer writer, String string) throws IOException {\r\n    int firstAmp = string.indexOf('&');\r\n    if (firstAmp < 0) {\r\n        writer.write(string);\r\n        return;\r\n    }\r\n    writer.write(string, 0, firstAmp);\r\n    int len = string.length();\r\n    for (int i = firstAmp; i < len; i++) {\r\n        char c = string.charAt(i);\r\n        if (c == '&') {\r\n            int nextIdx = i + 1;\r\n            int semiColonIdx = string.indexOf(';', nextIdx);\r\n            if (semiColonIdx == -1) {\r\n                writer.write(c);\r\n                continue;\r\n            }\r\n            int amphersandIdx = string.indexOf('&', i + 1);\r\n            if (amphersandIdx != -1 && amphersandIdx < semiColonIdx) {\r\n                                writer.write(c);\r\n                continue;\r\n            }\r\n            String entityContent = string.substring(nextIdx, semiColonIdx);\r\n            int entityValue = -1;\r\n            int entityContentLen = entityContent.length();\r\n            if (entityContentLen > 0) {\r\n                if (entityContent.charAt(0) == '#') {\r\n                                        if (entityContentLen > 1) {\r\n                        char isHexChar = entityContent.charAt(1);\r\n                        try {\r\n                            switch(isHexChar) {\r\n                                case 'X':\r\n                                case 'x':\r\n                                    {\r\n                                        entityValue = Integer.parseInt(entityContent.substring(2), 16);\r\n                                    }\r\n                                default:\r\n                                    {\r\n                                        entityValue = Integer.parseInt(entityContent.substring(1), 10);\r\n                                    }\r\n                            }\r\n                        } catch (NumberFormatException e) {\r\n                        }\r\n                    }\r\n                } else {\r\n                                        entityValue = this.entityValue(entityContent);\r\n                }\r\n            }\r\n            if (entityValue == -1) {\r\n                writer.write('&');\r\n                writer.write(entityContent);\r\n                writer.write(';');\r\n            } else {\r\n                writer.write(entityValue);\r\n            }\r\n                        i = semiColonIdx;\r\n        } else {\r\n            writer.write(c);\r\n        }\r\n    }\r\n}","lc":2.1363636364,"pi":3.4258373206,"ma":2.4,"nbd":3.0,"ml":1.4166666667,"d":2.3154761905,"mi":-0.9960535588,"fo":1.4166666667,"r":-0.0263157895,"e":5.2744339367}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4016_f1c9cef2","label":1,"code":"\/**\r\n *  @param detailed\r\n *             True if a detailed string is desired\r\n *  @return The string\r\n *\/\r\npublic String toString(final boolean detailed) {\r\n    try {\r\n        if (detailed) {\r\n            final Page page = findPage();\r\n            if (page == null) {\r\n                return new StringBuilder(\"[Component id = \").append(getId()).append(\", page = <No Page>, path = \").append(getPath()).append('.').append(Classes.simpleName(getClass())).append(']').toString();\r\n            } else {\r\n                return new StringBuilder(\"[Component id = \").append(getId()).append(\", page = \").append(getPage().getClass().getName()).append(\", path = \").append(getPath()).append('.').append(Classes.simpleName(getClass())).append(\", isVisible = \").append((determineVisibility())).append(\", isVersioned = \").append(isVersioned()).append(']').toString();\r\n            }\r\n        } else {\r\n            return \"[Component id = \" + getId() + ']';\r\n        }\r\n    } catch (Exception e) {\r\n        log.warn(\"Error while building toString()\", e);\r\n        return String.format(\"[Component id = %s <attributes are not available because exception %s was thrown during toString()>]\", getId(), e.getClass().getName());\r\n    }\r\n}","code_comment":"\/**\r\n *  @param detailed\r\n *             True if a detailed string is desired\r\n *  @return The string\r\n *\/\r\n","code_no_comment":"public String toString(final boolean detailed) {\r\n    try {\r\n        if (detailed) {\r\n            final Page page = findPage();\r\n            if (page == null) {\r\n                return new StringBuilder(\"[Component id = \").append(getId()).append(\", page = <No Page>, path = \").append(getPath()).append('.').append(Classes.simpleName(getClass())).append(']').toString();\r\n            } else {\r\n                return new StringBuilder(\"[Component id = \").append(getId()).append(\", page = \").append(getPage().getClass().getName()).append(\", path = \").append(getPath()).append('.').append(Classes.simpleName(getClass())).append(\", isVisible = \").append((determineVisibility())).append(\", isVersioned = \").append(isVersioned()).append(']').toString();\r\n            }\r\n        } else {\r\n            return \"[Component id = \" + getId() + ']';\r\n        }\r\n    } catch (Exception e) {\r\n        log.warn(\"Error while building toString()\", e);\r\n        return String.format(\"[Component id = %s <attributes are not available because exception %s was thrown during toString()>]\", getId(), e.getClass().getName());\r\n    }\r\n}","lc":0.1363636364,"pi":0.8325358852,"ma":0.0,"nbd":0.5,"ml":-0.0833333333,"d":0.0674603175,"mi":-0.2208597604,"fo":2.8333333333,"r":-0.0263157895,"e":0.2397077045}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-412_be2fdba7","label":1,"code":"@Override\r\npublic Repo<Master> call(final long tid, Master master) throws Exception {\r\n    FileSystem fs = TraceFileSystem.wrap(org.apache.accumulo.core.file.FileUtil.getFileSystem(CachedConfiguration.getInstance(), ServerConfiguration.getSiteConfiguration()));\r\n    List<FileStatus> files = new ArrayList<FileStatus>();\r\n    for (FileStatus entry : fs.listStatus(new Path(bulk))) {\r\n        files.add(entry);\r\n    }\r\n    log.debug(\"tid \" + tid + \" importing \" + files.size() + \" files\");\r\n    Path writable = new Path(this.errorDir, \".iswritable\");\r\n    if (!fs.createNewFile(writable)) {\r\n        \/\/ Maybe this is a re-try... clear the flag and try again\r\n        fs.delete(writable, false);\r\n        if (!fs.createNewFile(writable))\r\n            throw new ThriftTableOperationException(tableId, null, TableOperation.BULK_IMPORT, TableOperationExceptionType.BULK_BAD_ERROR_DIRECTORY, \"Unable to write to \" + this.errorDir);\r\n    }\r\n    fs.delete(writable, false);\r\n    \/\/ group files into N-sized chunks, send the chunks to random servers\r\n    final int SERVERS_TO_USE = Math.min(ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_SERVERS), master.onlineTabletServers().size());\r\n    log.debug(\"tid \" + tid + \" using \" + SERVERS_TO_USE + \" servers\");\r\n    \/\/ wait for success, repeat failures R times\r\n    final List<String> filesToLoad = Collections.synchronizedList(new ArrayList<String>());\r\n    for (FileStatus f : files) filesToLoad.add(f.getPath().toString());\r\n    final int RETRIES = Math.max(1, ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_RETRIES));\r\n    for (int i = 0; i < RETRIES && filesToLoad.size() > 0; i++) {\r\n        List<Future<?>> results = new ArrayList<Future<?>>();\r\n        for (List<String> chunk : groupFiles(filesToLoad, SERVERS_TO_USE)) {\r\n            final List<String> attempt = chunk;\r\n            results.add(threadPool.submit(new LoggingRunnable(log, new Runnable() {\r\n\r\n                @Override\r\n                public void run() {\r\n                    ClientService.Iface client = null;\r\n                    try {\r\n                        client = ServerClient.getConnection(HdfsZooInstance.getInstance());\r\n                        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\r\n                        attempt.removeAll(fail);\r\n                        filesToLoad.removeAll(attempt);\r\n                    } catch (Exception ex) {\r\n                        log.error(ex, ex);\r\n                    } finally {\r\n                        ServerClient.close(client);\r\n                    }\r\n                }\r\n            })));\r\n        }\r\n        for (Future<?> f : results) f.get();\r\n        if (filesToLoad.size() > 0) {\r\n            log.debug(\"tid \" + tid + \" attempt \" + (i + 1) + \" \" + filesToLoad + \" failed\");\r\n            UtilWaitThread.sleep(100);\r\n        }\r\n    }\r\n    \/\/ Copy\/Create failed file markers\r\n    for (String f : filesToLoad) {\r\n        Path orig = new Path(f);\r\n        Path dest = new Path(errorDir, orig.getName());\r\n        try {\r\n            FileUtil.copy(fs, orig, fs, dest, false, true, CachedConfiguration.getInstance());\r\n            log.debug(\"tid \" + tid + \" copied \" + orig + \" to \" + dest + \": failed\");\r\n        } catch (IOException ex) {\r\n            try {\r\n                fs.create(dest).close();\r\n                log.debug(\"tid \" + tid + \" marked \" + dest + \" failed\");\r\n            } catch (IOException e) {\r\n                log.error(\"Unable to create failure flag file \" + dest, e);\r\n            }\r\n        }\r\n    }\r\n    \/\/ return the next step, which will perform cleanup\r\n    return new CompleteBulkImport(tableId, source, bulk, errorDir);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Repo<Master> call(final long tid, Master master) throws Exception {\r\n    FileSystem fs = TraceFileSystem.wrap(org.apache.accumulo.core.file.FileUtil.getFileSystem(CachedConfiguration.getInstance(), ServerConfiguration.getSiteConfiguration()));\r\n    List<FileStatus> files = new ArrayList<FileStatus>();\r\n    for (FileStatus entry : fs.listStatus(new Path(bulk))) {\r\n        files.add(entry);\r\n    }\r\n    log.debug(\"tid \" + tid + \" importing \" + files.size() + \" files\");\r\n    Path writable = new Path(this.errorDir, \".iswritable\");\r\n    if (!fs.createNewFile(writable)) {\r\n                fs.delete(writable, false);\r\n        if (!fs.createNewFile(writable))\r\n            throw new ThriftTableOperationException(tableId, null, TableOperation.BULK_IMPORT, TableOperationExceptionType.BULK_BAD_ERROR_DIRECTORY, \"Unable to write to \" + this.errorDir);\r\n    }\r\n    fs.delete(writable, false);\r\n        final int SERVERS_TO_USE = Math.min(ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_SERVERS), master.onlineTabletServers().size());\r\n    log.debug(\"tid \" + tid + \" using \" + SERVERS_TO_USE + \" servers\");\r\n        final List<String> filesToLoad = Collections.synchronizedList(new ArrayList<String>());\r\n    for (FileStatus f : files) filesToLoad.add(f.getPath().toString());\r\n    final int RETRIES = Math.max(1, ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_RETRIES));\r\n    for (int i = 0; i < RETRIES && filesToLoad.size() > 0; i++) {\r\n        List<Future<?>> results = new ArrayList<Future<?>>();\r\n        for (List<String> chunk : groupFiles(filesToLoad, SERVERS_TO_USE)) {\r\n            final List<String> attempt = chunk;\r\n            results.add(threadPool.submit(new LoggingRunnable(log, new Runnable() {\r\n\r\n                @Override\r\n                public void run() {\r\n                    ClientService.Iface client = null;\r\n                    try {\r\n                        client = ServerClient.getConnection(HdfsZooInstance.getInstance());\r\n                        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\r\n                        attempt.removeAll(fail);\r\n                        filesToLoad.removeAll(attempt);\r\n                    } catch (Exception ex) {\r\n                        log.error(ex, ex);\r\n                    } finally {\r\n                        ServerClient.close(client);\r\n                    }\r\n                }\r\n            })));\r\n        }\r\n        for (Future<?> f : results) f.get();\r\n        if (filesToLoad.size() > 0) {\r\n            log.debug(\"tid \" + tid + \" attempt \" + (i + 1) + \" \" + filesToLoad + \" failed\");\r\n            UtilWaitThread.sleep(100);\r\n        }\r\n    }\r\n        for (String f : filesToLoad) {\r\n        Path orig = new Path(f);\r\n        Path dest = new Path(errorDir, orig.getName());\r\n        try {\r\n            FileUtil.copy(fs, orig, fs, dest, false, true, CachedConfiguration.getInstance());\r\n            log.debug(\"tid \" + tid + \" copied \" + orig + \" to \" + dest + \": failed\");\r\n        } catch (IOException ex) {\r\n            try {\r\n                fs.create(dest).close();\r\n                log.debug(\"tid \" + tid + \" marked \" + dest + \" failed\");\r\n            } catch (IOException e) {\r\n                log.error(\"Unable to create failure flag file \" + dest, e);\r\n            }\r\n        }\r\n    }\r\n        return new CompleteBulkImport(tableId, source, bulk, errorDir);\r\n}","lc":2.2727272727,"pi":1.8277511962,"ma":2.0,"nbd":1.0,"ml":0.3333333333,"d":0.9186507937,"mi":-1.1299506695,"fo":3.5833333333,"r":-0.0263157895,"e":5.9413841393}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1749_591e4d4a","label":0,"code":"@Override\r\npublic synchronized void run() {\r\n    log.debug(\"Running background index task {}\", name);\r\n    if (isAlreadyRunning(store, name)) {\r\n        log.debug(\"Async job '{}' found to be already running. Skipping\", name);\r\n        return;\r\n    }\r\n    String checkpoint = store.checkpoint(lifetime);\r\n    NodeState after = store.retrieve(checkpoint);\r\n    if (after == null) {\r\n        log.debug(\"Unable to retrieve checkpoint {}\", checkpoint);\r\n        return;\r\n    }\r\n    NodeBuilder builder = store.getRoot().builder();\r\n    NodeBuilder async = builder.child(ASYNC);\r\n    NodeState before = null;\r\n    final PropertyState state = async.getProperty(name);\r\n    if (state != null && state.getType() == STRING) {\r\n        before = store.retrieve(state.getValue(STRING));\r\n    }\r\n    if (before == null) {\r\n        before = MISSING_NODE;\r\n    }\r\n    AsyncUpdateCallback callback = new AsyncUpdateCallback();\r\n    preAsyncRunStatsStats(indexStats);\r\n    IndexUpdate indexUpdate = new IndexUpdate(provider, name, after, builder, callback);\r\n    CommitFailedException exception = EditorDiff.process(indexUpdate, before, after);\r\n    if (exception == null) {\r\n        if (callback.dirty) {\r\n            async.setProperty(name, checkpoint);\r\n            try {\r\n                store.merge(builder, newCommitHook(name, state), CommitInfo.EMPTY);\r\n            } catch (CommitFailedException e) {\r\n                if (e != CONCURRENT_UPDATE) {\r\n                    exception = e;\r\n                }\r\n            }\r\n            if (switchOnSync) {\r\n                reindexedDefinitions.addAll(indexUpdate.getReindexedDefinitions());\r\n            } else {\r\n                postAsyncRunStatsStatus(indexStats);\r\n            }\r\n        } else if (switchOnSync) {\r\n            log.debug(\"No changes detected after diff, will try to switch to synchronous updates on \" + reindexedDefinitions);\r\n            async.setProperty(name, checkpoint);\r\n            \/\/ no changes after diff, switch to sync on the async defs\r\n            for (String path : reindexedDefinitions) {\r\n                NodeBuilder c = builder;\r\n                for (String p : elements(path)) {\r\n                    c = c.getChildNode(p);\r\n                }\r\n                if (c.exists() && !c.getBoolean(REINDEX_PROPERTY_NAME)) {\r\n                    c.removeProperty(ASYNC_PROPERTY_NAME);\r\n                }\r\n            }\r\n            try {\r\n                store.merge(builder, newCommitHook(name, state), CommitInfo.EMPTY);\r\n                reindexedDefinitions.clear();\r\n                postAsyncRunStatsStatus(indexStats);\r\n            } catch (CommitFailedException e) {\r\n                if (e != CONCURRENT_UPDATE) {\r\n                    exception = e;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (exception != null) {\r\n        if (!failing) {\r\n            log.warn(\"Index update {} failed\", name, exception);\r\n        }\r\n        failing = true;\r\n    } else {\r\n        if (failing) {\r\n            log.info(\"Index update {} no longer fails\", name);\r\n        }\r\n        failing = false;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic synchronized void run() {\r\n    log.debug(\"Running background index task {}\", name);\r\n    if (isAlreadyRunning(store, name)) {\r\n        log.debug(\"Async job '{}' found to be already running. Skipping\", name);\r\n        return;\r\n    }\r\n    String checkpoint = store.checkpoint(lifetime);\r\n    NodeState after = store.retrieve(checkpoint);\r\n    if (after == null) {\r\n        log.debug(\"Unable to retrieve checkpoint {}\", checkpoint);\r\n        return;\r\n    }\r\n    NodeBuilder builder = store.getRoot().builder();\r\n    NodeBuilder async = builder.child(ASYNC);\r\n    NodeState before = null;\r\n    final PropertyState state = async.getProperty(name);\r\n    if (state != null && state.getType() == STRING) {\r\n        before = store.retrieve(state.getValue(STRING));\r\n    }\r\n    if (before == null) {\r\n        before = MISSING_NODE;\r\n    }\r\n    AsyncUpdateCallback callback = new AsyncUpdateCallback();\r\n    preAsyncRunStatsStats(indexStats);\r\n    IndexUpdate indexUpdate = new IndexUpdate(provider, name, after, builder, callback);\r\n    CommitFailedException exception = EditorDiff.process(indexUpdate, before, after);\r\n    if (exception == null) {\r\n        if (callback.dirty) {\r\n            async.setProperty(name, checkpoint);\r\n            try {\r\n                store.merge(builder, newCommitHook(name, state), CommitInfo.EMPTY);\r\n            } catch (CommitFailedException e) {\r\n                if (e != CONCURRENT_UPDATE) {\r\n                    exception = e;\r\n                }\r\n            }\r\n            if (switchOnSync) {\r\n                reindexedDefinitions.addAll(indexUpdate.getReindexedDefinitions());\r\n            } else {\r\n                postAsyncRunStatsStatus(indexStats);\r\n            }\r\n        } else if (switchOnSync) {\r\n            log.debug(\"No changes detected after diff, will try to switch to synchronous updates on \" + reindexedDefinitions);\r\n            async.setProperty(name, checkpoint);\r\n                        for (String path : reindexedDefinitions) {\r\n                NodeBuilder c = builder;\r\n                for (String p : elements(path)) {\r\n                    c = c.getChildNode(p);\r\n                }\r\n                if (c.exists() && !c.getBoolean(REINDEX_PROPERTY_NAME)) {\r\n                    c.removeProperty(ASYNC_PROPERTY_NAME);\r\n                }\r\n            }\r\n            try {\r\n                store.merge(builder, newCommitHook(name, state), CommitInfo.EMPTY);\r\n                reindexedDefinitions.clear();\r\n                postAsyncRunStatsStatus(indexStats);\r\n            } catch (CommitFailedException e) {\r\n                if (e != CONCURRENT_UPDATE) {\r\n                    exception = e;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (exception != null) {\r\n        if (!failing) {\r\n            log.warn(\"Index update {} failed\", name, exception);\r\n        }\r\n        failing = true;\r\n    } else {\r\n        if (failing) {\r\n            log.info(\"Index update {} no longer fails\", name);\r\n        }\r\n        failing = false;\r\n    }\r\n}","lc":2.8636363636,"pi":1.1291866029,"ma":3.0,"nbd":1.5,"ml":2.0833333333,"d":1.0476190476,"mi":-1.1823819591,"fo":2.3333333333,"r":-0.0263157895,"e":4.1658823326}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5964_86066852","label":1,"code":"protected final Component getChild() {\r\n    if (childComponent == null) {\r\n        \/\/ try to find child when queued\r\n        childComponent = get(childId);\r\n    }\r\n    if (childComponent == null) {\r\n        \/\/ try to find child when resolved\r\n        childComponent = getChildComponent(new MarkupStream(getMarkup()), getEnclosureParent());\r\n    }\r\n    return childComponent;\r\n}","code_comment":null,"code_no_comment":"protected final Component getChild() {\r\n    if (childComponent == null) {\r\n                childComponent = get(childId);\r\n    }\r\n    if (childComponent == null) {\r\n                childComponent = getChildComponent(new MarkupStream(getMarkup()), getEnclosureParent());\r\n    }\r\n    return childComponent;\r\n}","lc":-0.2272727273,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0773809524,"mi":0.3237491191,"fo":-0.1666666667,"r":2.0789473684,"e":-0.1131630965}
{"project_name":"Closure","project_version":"95","label":2,"code":"\/**\r\n * Defines a typed variable. The defining node will be annotated with the\r\n * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\r\n * inferred.\r\n *\r\n * Slots may be any variable or any qualified name in the global scope.\r\n *\r\n * @param n the defining NAME or GETPROP node.\r\n * @param parent the {@code n}'s parent.\r\n * @param type the variable's type. It may be {@code null} if\r\n *     {@code inferred} is {@code true}.\r\n *\/\r\nvoid defineSlot(Node n, Node parent, JSType type, boolean inferred) {\r\n    Preconditions.checkArgument(inferred || type != null);\r\n    \/\/ Only allow declarations of NAMEs and qualfied names.\r\n    boolean shouldDeclareOnGlobalThis = false;\r\n    if (n.getType() == Token.NAME) {\r\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\r\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\r\n    } else {\r\n        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\r\n    }\r\n    String variableName = n.getQualifiedName();\r\n    Preconditions.checkArgument(!variableName.isEmpty());\r\n    \/\/ If n is a property, then we should really declare it in the\r\n    \/\/ scope where the root object appears. This helps out people\r\n    \/\/ who declare \"global\" names in an anonymous namespace.\r\n    Scope scopeToDeclareIn = scope;\r\n    \/\/ declared in closest scope?\r\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\r\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\r\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\r\n    } else {\r\n        if (!inferred) {\r\n            setDeferredType(n, type);\r\n        }\r\n        CompilerInput input = compiler.getInput(sourceName);\r\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\r\n        if (shouldDeclareOnGlobalThis) {\r\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\r\n            boolean isExtern = input.isExtern();\r\n            if (inferred) {\r\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\r\n            } else {\r\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\r\n            }\r\n        }\r\n        \/\/ in the scope chain.\r\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\r\n            FunctionType fnType = (FunctionType) type;\r\n            if (fnType.isConstructor() || fnType.isInterface()) {\r\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\r\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName), \/* declared iff there's an explicit supertype *\/\r\n                superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Defines a typed variable. The defining node will be annotated with the\r\n * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\r\n * inferred.\r\n *\r\n * Slots may be any variable or any qualified name in the global scope.\r\n *\r\n * @param n the defining NAME or GETPROP node.\r\n * @param parent the {@code n}'s parent.\r\n * @param type the variable's type. It may be {@code null} if\r\n *     {@code inferred} is {@code true}.\r\n *\/\r\n","code_no_comment":"void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\r\n    Preconditions.checkArgument(inferred || type != null);\r\n        boolean shouldDeclareOnGlobalThis = false;\r\n    if (n.getType() == Token.NAME) {\r\n        Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);\r\n        shouldDeclareOnGlobalThis = scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);\r\n    } else {\r\n        Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));\r\n    }\r\n    String variableName = n.getQualifiedName();\r\n    Preconditions.checkArgument(!variableName.isEmpty());\r\n                Scope scopeToDeclareIn = scope;\r\n        if (scopeToDeclareIn.isDeclared(variableName, false)) {\r\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\r\n        validator.expectUndeclaredVariable(sourceName, n, parent, oldVar, variableName, type);\r\n    } else {\r\n        if (!inferred) {\r\n            setDeferredType(n, type);\r\n        }\r\n        CompilerInput input = compiler.getInput(sourceName);\r\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\r\n        if (shouldDeclareOnGlobalThis) {\r\n            ObjectType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\r\n            boolean isExtern = input.isExtern();\r\n            if (inferred) {\r\n                globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, isExtern);\r\n            } else {\r\n                globalThis.defineDeclaredProperty(variableName, type, isExtern);\r\n            }\r\n        }\r\n                if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\r\n            FunctionType fnType = (FunctionType) type;\r\n            if (fnType.isConstructor() || fnType.isInterface()) {\r\n                FunctionType superClassCtor = fnType.getSuperClassConstructor();\r\n                scopeToDeclareIn.declare(variableName + \".prototype\", n, fnType.getPrototype(), compiler.getInput(sourceName),                 superClassCtor == null || superClassCtor.getInstanceType().equals(getNativeType(OBJECT_TYPE)));\r\n            }\r\n        }\r\n    }\r\n}","lc":1.1818181818,"pi":0.6555023923,"ma":1.0,"nbd":0.5,"ml":1.1666666667,"d":1.1329365079,"mi":-0.8114164905,"fo":2.6666666667,"r":-0.0263157895,"e":4.2083251212}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1211_a06a1584","label":1,"code":"\/**\r\n * Get the first sub-hyperplane crossed by a semi-infinite line.\r\n * @param node current node\r\n * @param point start point of the part of the line considered\r\n * @param line line to consider (contains point)\r\n * @return the first sub-hyperplaned crossed by the line after the\r\n * given point, or null if the line does not intersect any\r\n * sub-hyperplaned\r\n *\/\r\nprivate SubHyperplane<Euclidean3D> recurseFirstIntersection(final BSPTree<Euclidean3D> node, final Vector3D point, final Line line) {\r\n    final SubHyperplane<Euclidean3D> cut = node.getCut();\r\n    if (cut == null) {\r\n        return null;\r\n    }\r\n    final BSPTree<Euclidean3D> minus = node.getMinus();\r\n    final BSPTree<Euclidean3D> plus = node.getPlus();\r\n    final Plane plane = (Plane) cut.getHyperplane();\r\n    \/\/ establish search order\r\n    final double offset = plane.getOffset((Point<Euclidean3D>) point);\r\n    final boolean in = FastMath.abs(offset) < 1.0e-10;\r\n    final BSPTree<Euclidean3D> near;\r\n    final BSPTree<Euclidean3D> far;\r\n    if (offset < 0) {\r\n        near = minus;\r\n        far = plus;\r\n    } else {\r\n        near = plus;\r\n        far = minus;\r\n    }\r\n    if (in) {\r\n        \/\/ search in the cut hyperplane\r\n        final SubHyperplane<Euclidean3D> facet = boundaryFacet(point, node);\r\n        if (facet != null) {\r\n            return facet;\r\n        }\r\n    }\r\n    \/\/ search in the near branch\r\n    final SubHyperplane<Euclidean3D> crossed = recurseFirstIntersection(near, point, line);\r\n    if (crossed != null) {\r\n        return crossed;\r\n    }\r\n    if (!in) {\r\n        \/\/ search in the cut hyperplane\r\n        final Vector3D hit3D = plane.intersection(line);\r\n        if (hit3D != null) {\r\n            final SubHyperplane<Euclidean3D> facet = boundaryFacet(hit3D, node);\r\n            if (facet != null) {\r\n                return facet;\r\n            }\r\n        }\r\n    }\r\n    \/\/ search in the far branch\r\n    return recurseFirstIntersection(far, point, line);\r\n}","code_comment":"\/**\r\n * Get the first sub-hyperplane crossed by a semi-infinite line.\r\n * @param node current node\r\n * @param point start point of the part of the line considered\r\n * @param line line to consider (contains point)\r\n * @return the first sub-hyperplaned crossed by the line after the\r\n * given point, or null if the line does not intersect any\r\n * sub-hyperplaned\r\n *\/\r\n","code_no_comment":"private SubHyperplane<Euclidean3D> recurseFirstIntersection(final BSPTree<Euclidean3D> node, final Vector3D point, final Line line) {\r\n    final SubHyperplane<Euclidean3D> cut = node.getCut();\r\n    if (cut == null) {\r\n        return null;\r\n    }\r\n    final BSPTree<Euclidean3D> minus = node.getMinus();\r\n    final BSPTree<Euclidean3D> plus = node.getPlus();\r\n    final Plane plane = (Plane) cut.getHyperplane();\r\n        final double offset = plane.getOffset((Point<Euclidean3D>) point);\r\n    final boolean in = FastMath.abs(offset) < 1.0e-10;\r\n    final BSPTree<Euclidean3D> near;\r\n    final BSPTree<Euclidean3D> far;\r\n    if (offset < 0) {\r\n        near = minus;\r\n        far = plus;\r\n    } else {\r\n        near = plus;\r\n        far = minus;\r\n    }\r\n    if (in) {\r\n                final SubHyperplane<Euclidean3D> facet = boundaryFacet(point, node);\r\n        if (facet != null) {\r\n            return facet;\r\n        }\r\n    }\r\n        final SubHyperplane<Euclidean3D> crossed = recurseFirstIntersection(near, point, line);\r\n    if (crossed != null) {\r\n        return crossed;\r\n    }\r\n    if (!in) {\r\n                final Vector3D hit3D = plane.intersection(line);\r\n        if (hit3D != null) {\r\n            final SubHyperplane<Euclidean3D> facet = boundaryFacet(hit3D, node);\r\n            if (facet != null) {\r\n                return facet;\r\n            }\r\n        }\r\n    }\r\n        return recurseFirstIntersection(far, point, line);\r\n}","lc":1.1818181818,"pi":0.1722488038,"ma":1.0,"nbd":0.5,"ml":0.75,"d":0.7916666667,"mi":-0.7169837914,"fo":0.4166666667,"r":-0.0263157895,"e":1.6105231007}
{"project_name":"Closure","project_version":"167","label":2,"code":"\/**\r\n * If the restrictedType differs from the originalType, then we should\r\n * branch the current flow scope and create a new flow scope with the name\r\n * declared with the new type.\r\n *\r\n * We try not to create spurious child flow scopes as this makes type\r\n * inference slower.\r\n *\r\n * We also do not want spurious slots around in type inference, because\r\n * we use these as a signal for \"checked unknown\" types. A \"checked unknown\"\r\n * type is a symbol that the programmer has already checked and verified that\r\n * it's defined, even if we don't know what it is.\r\n *\r\n * It is OK to pass non-name nodes into this method, as long as you pass\r\n * in {@code null} for a restricted type.\r\n *\/\r\nprivate FlowScope maybeRestrictName(FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) {\r\n    if (restrictedType != null && !restrictedType.equals(originalType)) {\r\n        FlowScope informed = blindScope.createChildFlowScope();\r\n        declareNameInScope(informed, node, restrictedType);\r\n        return informed;\r\n    }\r\n    return blindScope;\r\n}","code_comment":"\/**\r\n * If the restrictedType differs from the originalType, then we should\r\n * branch the current flow scope and create a new flow scope with the name\r\n * declared with the new type.\r\n *\r\n * We try not to create spurious child flow scopes as this makes type\r\n * inference slower.\r\n *\r\n * We also do not want spurious slots around in type inference, because\r\n * we use these as a signal for \"checked unknown\" types. A \"checked unknown\"\r\n * type is a symbol that the programmer has already checked and verified that\r\n * it's defined, even if we don't know what it is.\r\n *\r\n * It is OK to pass non-name nodes into this method, as long as you pass\r\n * in {@code null} for a restricted type.\r\n *\/\r\n","code_no_comment":"private FlowScope maybeRestrictName(FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) {\r\n    if (restrictedType != null && !restrictedType.equals(originalType)) {\r\n        FlowScope informed = blindScope.createChildFlowScope();\r\n        declareNameInScope(informed, node, restrictedType);\r\n        return informed;\r\n    }\r\n    return blindScope;\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":0.0,"d":0.371031746,"mi":0.3071176885,"fo":-0.25,"r":0.0263157895,"e":0.0514260357}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-846_7acb091a","label":3,"code":"boolean mark(DocumentStore store) {\r\n    if (markCommitRoot(document, theirRev, store)) {\r\n        return true;\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<String, String> revisions = (Map<String, String>) document.get(UpdateOp.REVISIONS);\r\n    if (revisions.containsKey(theirRev)) {\r\n        String value = revisions.get(theirRev);\r\n        if (\"true\".equals(value)) {\r\n            \/\/ their commit wins, we have to mark ourRev\r\n            Map<String, Object> newDoc = Utils.newMap();\r\n            Utils.deepCopyMap(document, newDoc);\r\n            MemoryDocumentStore.applyChanges(newDoc, ourOp);\r\n            if (markCommitRoot(newDoc, ourRev, store)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"boolean mark(DocumentStore store) {\r\n    if (markCommitRoot(document, theirRev, store)) {\r\n        return true;\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<String, String> revisions = (Map<String, String>) document.get(UpdateOp.REVISIONS);\r\n    if (revisions.containsKey(theirRev)) {\r\n        String value = revisions.get(theirRev);\r\n        if (\"true\".equals(value)) {\r\n                        Map<String, Object> newDoc = Utils.newMap();\r\n            Utils.deepCopyMap(document, newDoc);\r\n            MemoryDocumentStore.applyChanges(newDoc, ourOp);\r\n            if (markCommitRoot(newDoc, ourRev, store)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}","lc":0.2272727273,"pi":0.6842105263,"ma":0.2,"nbd":0.5,"ml":0.75,"d":-0.3650793651,"mi":-0.221141649,"fo":0.25,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Closure","project_version":"158","label":2,"code":"\/**\r\n * Adds warning levels by name.\r\n *\/\r\nvoid setWarningLevels(CompilerOptions options, List<String> diagnosticGroups, CheckLevel level) {\r\n    for (String name : diagnosticGroups) {\r\n        DiagnosticGroup group = forName(name);\r\n        Preconditions.checkNotNull(group, \"No warning class for name: \" + name);\r\n        options.setWarningLevel(group, level);\r\n    }\r\n}","code_comment":"\/**\r\n * Adds warning levels by name.\r\n *\/\r\n","code_no_comment":"void setWarningLevels(CompilerOptions options, List<String> diagnosticGroups, CheckLevel level) {\r\n    for (String name : diagnosticGroups) {\r\n        DiagnosticGroup group = forName(name);\r\n        Preconditions.checkNotNull(group, \"No warning class for name: \" + name);\r\n        options.setWarningLevel(group, level);\r\n    }\r\n}","lc":-0.3181818182,"pi":0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.0734126984,"mi":0.3809725159,"fo":-0.25,"r":0.1842105263,"e":-0.0850308028}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"\/**\r\n *  Static utility to parse a field of type int from a byte sequence that represents text characters\r\n *  (such as when read from a file stream).\r\n *\r\n *  @param bytes The bytes containing the text data that should be parsed.\r\n *  @param startPos The offset to start the parsing.\r\n *  @param length The length of the byte sequence (counting from the offset).\r\n *\r\n *  @return The parsed value.\r\n *\r\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\r\n *\/\r\npublic static final int parseField(byte[] bytes, int startPos, int length) {\r\n    return parseField(bytes, startPos, length, (char) 0xffff);\r\n}","code_comment":"\/**\r\n *  Static utility to parse a field of type int from a byte sequence that represents text characters\r\n *  (such as when read from a file stream).\r\n *\r\n *  @param bytes The bytes containing the text data that should be parsed.\r\n *  @param startPos The offset to start the parsing.\r\n *  @param length The length of the byte sequence (counting from the offset).\r\n *\r\n *  @return The parsed value.\r\n *\r\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\r\n *\/\r\n","code_no_comment":"public static final int parseField(byte[] bytes, int startPos, int length) {\r\n    return parseField(bytes, startPos, length, (char) 0xffff);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.992670895,"fo":-0.4166666667,"r":1.8947368421,"e":-0.1627934049}
{"project_name":"Closure","project_version":"143","label":2,"code":"\/**\r\n * Create a map of constant names to constant values from a textual\r\n * description of the map.\r\n *\r\n * @param definitions A list of overriding definitions for defines in\r\n *     the form <name>[=<val>], where <val> is a number, boolean, or\r\n *     single-quoted string without single quotes.\r\n *\/\r\n@VisibleForTesting\r\nstatic void createDefineReplacements(List<String> definitions, CompilerOptions options) {\r\n    \/\/ Parse the definitions\r\n    for (String override : definitions) {\r\n        String[] assignment = override.split(\"=\", 2);\r\n        String defName = assignment[0];\r\n        if (defName.length() > 0) {\r\n            if (assignment.length == 1) {\r\n                options.setDefineToBooleanLiteral(defName, true);\r\n                continue;\r\n            } else {\r\n                String defValue = assignment[1];\r\n                if (defValue.equals(\"true\")) {\r\n                    options.setDefineToBooleanLiteral(defName, true);\r\n                    continue;\r\n                } else if (defValue.equals(\"false\")) {\r\n                    options.setDefineToBooleanLiteral(defName, false);\r\n                    continue;\r\n                } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\\'' && defValue.charAt(defValue.length() - 1) == '\\''))) {\r\n                    \/\/ If the value starts and ends with a single quote,\r\n                    \/\/ we assume that it's a string.\r\n                    String maybeStringVal = defValue.substring(1, defValue.length() - 1);\r\n                    if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {\r\n                        options.setDefineToStringLiteral(defName, maybeStringVal);\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    try {\r\n                        options.setDefineToDoubleLiteral(defName, Double.parseDouble(defValue));\r\n                        continue;\r\n                    } catch (NumberFormatException e) {\r\n                    \/\/ do nothing, it will be caught at the end\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        throw new RuntimeException(\"--define flag syntax invalid: \" + override);\r\n    }\r\n}","code_comment":"\/**\r\n * Create a map of constant names to constant values from a textual\r\n * description of the map.\r\n *\r\n * @param definitions A list of overriding definitions for defines in\r\n *     the form <name>[=<val>], where <val> is a number, boolean, or\r\n *     single-quoted string without single quotes.\r\n *\/\r\n","code_no_comment":"@VisibleForTesting\r\nstatic void createDefineReplacements(List<String> definitions, CompilerOptions options) {\r\n        for (String override : definitions) {\r\n        String[] assignment = override.split(\"=\", 2);\r\n        String defName = assignment[0];\r\n        if (defName.length() > 0) {\r\n            if (assignment.length == 1) {\r\n                options.setDefineToBooleanLiteral(defName, true);\r\n                continue;\r\n            } else {\r\n                String defValue = assignment[1];\r\n                if (defValue.equals(\"true\")) {\r\n                    options.setDefineToBooleanLiteral(defName, true);\r\n                    continue;\r\n                } else if (defValue.equals(\"false\")) {\r\n                    options.setDefineToBooleanLiteral(defName, false);\r\n                    continue;\r\n                } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\\'' && defValue.charAt(defValue.length() - 1) == '\\''))) {\r\n                                                            String maybeStringVal = defValue.substring(1, defValue.length() - 1);\r\n                    if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {\r\n                        options.setDefineToStringLiteral(defName, maybeStringVal);\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    try {\r\n                        options.setDefineToDoubleLiteral(defName, Double.parseDouble(defValue));\r\n                        continue;\r\n                    } catch (NumberFormatException e) {\r\n                                        }\r\n                }\r\n            }\r\n        }\r\n        throw new RuntimeException(\"--define flag syntax invalid: \" + override);\r\n    }\r\n}","lc":0.9545454545,"pi":1.966507177,"ma":2.2,"nbd":2.5,"ml":0.9166666667,"d":1.1825396825,"mi":-0.674136716,"fo":1.0,"r":-0.0263157895,"e":1.8986785613}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-208_b224bad8","label":3,"code":"\/**\r\n *  @see wicket.behavior.AbstractAjaxBehavior#renderHead(wicket.markup.html.IHeaderResponse)\r\n *\/\r\npublic void renderHead(IHeaderResponse response) {\r\n    super.renderHead(response);\r\n    if (this.attachedBodyOnLoadModifier == false) {\r\n        this.attachedBodyOnLoadModifier = true;\r\n        ((WebPage) getComponent().getPage()).getBodyContainer().addOnLoadModifier(getJsTimeoutCall(updateInterval), getComponent());\r\n    }\r\n}","code_comment":"\/**\r\n *  @see wicket.behavior.AbstractAjaxBehavior#renderHead(wicket.markup.html.IHeaderResponse)\r\n *\/\r\n","code_no_comment":"public void renderHead(IHeaderResponse response) {\r\n    super.renderHead(response);\r\n    if (this.attachedBodyOnLoadModifier == false) {\r\n        this.attachedBodyOnLoadModifier = true;\r\n        ((WebPage) getComponent().getPage()).getBodyContainer().addOnLoadModifier(getJsTimeoutCall(updateInterval), getComponent());\r\n    }\r\n}","lc":-0.3181818182,"pi":0.014354067,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1091269841,"mi":0.4336856942,"fo":0.0833333333,"r":0.4210526316,"e":-0.1153714493}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1178_f2bb1a17","label":1,"code":"\/\/ ---------------------------------------------------------< internal >---\r\nprivate NodeState getBase() {\r\n    if (parent == null) {\r\n        return root.getBaseState();\r\n    } else {\r\n        return parent.getBase().getChildNode(name);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private NodeState getBase() {\r\n    if (parent == null) {\r\n        return root.getBaseState();\r\n    } else {\r\n        return parent.getBase().getChildNode(name);\r\n    }\r\n}","lc":-0.3181818182,"pi":0.014354067,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.5357293869,"fo":-0.25,"r":2.4473684211,"e":-0.1627934049}
{"project_name":"Math","project_version":"83","label":1,"code":"\/**\r\n * Checks whether the given column is basic.\r\n * @param col index of the column to check\r\n * @return the row that the variable is basic in.  null if the column is not basic\r\n *\/\r\nprivate Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\r\n    Integer row = null;\r\n    int start = getNumObjectiveFunctions();\r\n    for (int i = start; i < getHeight(); i++) {\r\n        if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\r\n            row = i;\r\n        } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\r\n            return null;\r\n        }\r\n    }\r\n    return row;\r\n}","code_comment":"\/**\r\n * Checks whether the given column is basic.\r\n * @param col index of the column to check\r\n * @return the row that the variable is basic in.  null if the column is not basic\r\n *\/\r\n","code_no_comment":"private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\r\n    Integer row = null;\r\n    int start = getNumObjectiveFunctions();\r\n    for (int i = start; i < getHeight(); i++) {\r\n        if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\r\n            row = i;\r\n        } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\r\n            return null;\r\n        }\r\n    }\r\n    return row;\r\n}","lc":-0.0909090909,"pi":0.3971291866,"ma":0.0,"nbd":0.5,"ml":0.5833333333,"d":0.8611111111,"mi":0.0410147992,"fo":0.0,"r":0.2894736842,"e":0.4039741129}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2350_cd281092","label":1,"code":"\/**\r\n *  @see org.apache.wicket.validation.IErrorMessageSource#getMessage(java.lang.String)\r\n *\/\r\npublic String getMessage(String key) {\r\n    final FormComponent<T> formComponent = FormComponent.this;\r\n    \/\/ Use the following log4j config for detailed logging on the property resolution\r\n    \/\/ process\r\n    \/\/ log4j.logger.org.apache.wicket.resource.loader=DEBUG\r\n    \/\/ log4j.logger.org.apache.wicket.Localizer=DEBUG\r\n    final Localizer localizer = formComponent.getLocalizer();\r\n    \/\/ retrieve prefix that will be used to construct message keys\r\n    String prefix = formComponent.getValidatorKeyPrefix();\r\n    String message = null;\r\n    \/\/ first try the full form of key [prefix].[form-component-id].[key]\r\n    String resource = prefix(prefix, getId() + \".\" + key);\r\n    message = getString(localizer, resource, formComponent);\r\n    \/\/ if not found, try a more general form (without prefix) [form-component-id].[key]\r\n    if (Strings.isEmpty(message) && Strings.isEmpty(prefix)) {\r\n        resource = getId() + \".\" + key;\r\n        message = getString(localizer, resource, formComponent);\r\n    }\r\n    \/\/ If not found try a more general form [prefix].[key]\r\n    if (Strings.isEmpty(message)) {\r\n        resource = prefix(prefix, key);\r\n        message = getString(localizer, key, formComponent);\r\n    }\r\n    \/\/ If not found try the most general form [key]\r\n    if (Strings.isEmpty(message) && Strings.isEmpty(prefix)) {\r\n        \/\/ Try a variation of the resource key\r\n        message = getString(localizer, key, formComponent);\r\n    }\r\n    \/\/ returned from localizer\r\n    if (Strings.isEmpty(message)) {\r\n        message = null;\r\n    }\r\n    return message;\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.validation.IErrorMessageSource#getMessage(java.lang.String)\r\n *\/\r\n","code_no_comment":"public String getMessage(String key) {\r\n    final FormComponent<T> formComponent = FormComponent.this;\r\n                    final Localizer localizer = formComponent.getLocalizer();\r\n        String prefix = formComponent.getValidatorKeyPrefix();\r\n    String message = null;\r\n        String resource = prefix(prefix, getId() + \".\" + key);\r\n    message = getString(localizer, resource, formComponent);\r\n        if (Strings.isEmpty(message) && Strings.isEmpty(prefix)) {\r\n        resource = getId() + \".\" + key;\r\n        message = getString(localizer, resource, formComponent);\r\n    }\r\n        if (Strings.isEmpty(message)) {\r\n        resource = prefix(prefix, key);\r\n        message = getString(localizer, key, formComponent);\r\n    }\r\n        if (Strings.isEmpty(message) && Strings.isEmpty(prefix)) {\r\n                message = getString(localizer, key, formComponent);\r\n    }\r\n        if (Strings.isEmpty(message)) {\r\n        message = null;\r\n    }\r\n    return message;\r\n}","lc":0.4090909091,"pi":-0.3540669856,"ma":0.2,"nbd":-0.5,"ml":0.4166666667,"d":0.3888888889,"mi":-0.3708245243,"fo":0.8333333333,"r":-0.0263157895,"e":0.5663041787}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8964_ea8ee025","label":1,"code":"\/**\r\n * Resumes the given {@code service}.\r\n * <p\/>\r\n * If {@code service} is a {@link org.apache.camel.SuspendableService} then\r\n * it's {@link org.apache.camel.SuspendableService#resume()} is called but\r\n * <b>only<\/b> if {@code service} is already {@link #isSuspended(Object)\r\n * suspended}.\r\n * <p\/>\r\n * If {@code service} is <b>not<\/b> a\r\n * {@link org.apache.camel.SuspendableService} then it's\r\n * {@link org.apache.camel.Service#start()} is called.\r\n * <p\/>\r\n * Calling this method has no effect if {@code service} is {@code null}.\r\n *\r\n * @param service the service\r\n * @return <tt>true<\/tt> if either <tt>resume<\/tt> method or\r\n *         {@link #startService(Service)} was called, <tt>false<\/tt>\r\n *         otherwise.\r\n * @throws Exception is thrown if error occurred\r\n * @see #startService(Service)\r\n *\/\r\npublic static boolean resumeService(Service service) throws Exception {\r\n    if (service instanceof SuspendableService) {\r\n        SuspendableService ss = (SuspendableService) service;\r\n        if (ss.isSuspended()) {\r\n            LOG.debug(\"Resuming service {}\", service);\r\n            ss.resume();\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } else {\r\n        startService(service);\r\n        return true;\r\n    }\r\n}","code_comment":"\/**\r\n * Resumes the given {@code service}.\r\n * <p\/>\r\n * If {@code service} is a {@link org.apache.camel.SuspendableService} then\r\n * it's {@link org.apache.camel.SuspendableService#resume()} is called but\r\n * <b>only<\/b> if {@code service} is already {@link #isSuspended(Object)\r\n * suspended}.\r\n * <p\/>\r\n * If {@code service} is <b>not<\/b> a\r\n * {@link org.apache.camel.SuspendableService} then it's\r\n * {@link org.apache.camel.Service#start()} is called.\r\n * <p\/>\r\n * Calling this method has no effect if {@code service} is {@code null}.\r\n *\r\n * @param service the service\r\n * @return <tt>true<\/tt> if either <tt>resume<\/tt> method or\r\n *         {@link #startService(Service)} was called, <tt>false<\/tt>\r\n *         otherwise.\r\n * @throws Exception is thrown if error occurred\r\n * @see #startService(Service)\r\n *\/\r\n","code_no_comment":"public static boolean resumeService(Service service) throws Exception {\r\n    if (service instanceof SuspendableService) {\r\n        SuspendableService ss = (SuspendableService) service;\r\n        if (ss.isSuspended()) {\r\n            LOG.debug(\"Resuming service {}\", service);\r\n            ss.resume();\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } else {\r\n        startService(service);\r\n        return true;\r\n    }\r\n}","lc":0.0454545455,"pi":0.4449760766,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.0463706836,"fo":-0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1058_4ebd967c","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\r\n * For scale {@code m} and shape {@code s}, the variance is\r\n * {@code (exp(s^2) - 1) * exp(2 * m + s^2)}.\r\n *\/\r\npublic double getNumericalVariance() {\r\n    final double s = shape;\r\n    final double ss = s * s;\r\n    return (FastMath.exp(ss) - 1) * FastMath.exp(2 * scale + ss);\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\r\n * For scale {@code m} and shape {@code s}, the variance is\r\n * {@code (exp(s^2) - 1) * exp(2 * m + s^2)}.\r\n *\/\r\n","code_no_comment":"public double getNumericalVariance() {\r\n    final double s = shape;\r\n    final double ss = s * s;\r\n    return (FastMath.exp(ss) - 1) * FastMath.exp(2 * scale + ss);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":0.2698412698,"mi":0.5805496829,"fo":-0.3333333333,"r":2.5526315789,"e":-0.0336024619}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2334_96330447","label":1,"code":"\/**\r\n *  Register your own custom contributor that will be part of the debug bar.\r\n *  You must have the context of an application for this thread at the time\r\n *  of calling this method.\r\n *\r\n *  @param contrib\r\n *             custom contributor - can not be null\r\n *\/\r\npublic static void registerContributor(IDebugBarContributor contrib) {\r\n    if (contrib == null) {\r\n        throw new IllegalArgumentException(\"contrib can not be null\");\r\n    }\r\n    List<IDebugBarContributor> contributors = getContributors();\r\n    contributors.add(contrib);\r\n    Application.get().setMetaData(CONTRIBS_META_KEY, contributors);\r\n}","code_comment":"\/**\r\n *  Register your own custom contributor that will be part of the debug bar.\r\n *  You must have the context of an application for this thread at the time\r\n *  of calling this method.\r\n *\r\n *  @param contrib\r\n *             custom contributor - can not be null\r\n *\/\r\n","code_no_comment":"public static void registerContributor(IDebugBarContributor contrib) {\r\n    if (contrib == null) {\r\n        throw new IllegalArgumentException(\"contrib can not be null\");\r\n    }\r\n    List<IDebugBarContributor> contributors = getContributors();\r\n    contributors.add(contrib);\r\n    Application.get().setMetaData(CONTRIBS_META_KEY, contributors);\r\n}","lc":-0.2727272727,"pi":-0.2822966507,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.1011904762,"mi":0.349119098,"fo":-0.1666666667,"r":1.9736842105,"e":-0.1075154302}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2172_ea4a3f8a","label":3,"code":"\/**\r\n *  @see IValueMap#getAsEnum\r\n *\/\r\npublic <T extends Enum<T>> T getAsEnum(String key, T defaultValue) {\r\n    if (defaultValue == null)\r\n        throw new IllegalArgumentException(\"Default value cannot be null\");\r\n    return getEnumImpl(key, defaultValue.getClass(), defaultValue);\r\n}","code_comment":"\/**\r\n *  @see IValueMap#getAsEnum\r\n *\/\r\n","code_no_comment":"public <T extends Enum<T>> T getAsEnum(String key, T defaultValue) {\r\n    if (defaultValue == null)\r\n        throw new IllegalArgumentException(\"Default value cannot be null\");\r\n    return getEnumImpl(key, defaultValue.getClass(), defaultValue);\r\n}","lc":-0.4090909091,"pi":0.0,"ma":-0.2,"nbd":-1.0,"ml":-0.25,"d":-0.3650793651,"mi":0.5923890063,"fo":-0.3333333333,"r":1.8421052632,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5891_2d9ebf9a","label":1,"code":"\/**\r\n *  Check if the credit card is a China UnionPay. A China UnionPay number has to start with 622\r\n *  (622126-622925) and has to have a length between 16 and 19. No further validation takes\r\n *  place.<br\/>\r\n *  <br\/>\r\n *\r\n *  @param creditCardNumber\r\n *             the credit card number as a string\r\n *  @return The credit card id of the issuer\r\n *\/\r\nprivate CreditCard isChinaUnionPay(String creditCardNumber) {\r\n    if ((creditCardNumber.length() >= 16 && creditCardNumber.length() <= 19) && (creditCardNumber.startsWith(\"622\"))) {\r\n        int firstDigits = Integer.parseInt(creditCardNumber.substring(0, 5));\r\n        if (firstDigits >= 622126 && firstDigits <= 622925) {\r\n            return CreditCard.CHINA_UNIONPAY;\r\n        }\r\n    }\r\n    return CreditCard.INVALID;\r\n}","code_comment":"\/**\r\n *  Check if the credit card is a China UnionPay. A China UnionPay number has to start with 622\r\n *  (622126-622925) and has to have a length between 16 and 19. No further validation takes\r\n *  place.<br\/>\r\n *  <br\/>\r\n *\r\n *  @param creditCardNumber\r\n *             the credit card number as a string\r\n *  @return The credit card id of the issuer\r\n *\/\r\n","code_no_comment":"private CreditCard isChinaUnionPay(String creditCardNumber) {\r\n    if ((creditCardNumber.length() >= 16 && creditCardNumber.length() <= 19) && (creditCardNumber.startsWith(\"622\"))) {\r\n        int firstDigits = Integer.parseInt(creditCardNumber.substring(0, 5));\r\n        if (firstDigits >= 622126 && firstDigits <= 622925) {\r\n            return CreditCard.CHINA_UNIONPAY;\r\n        }\r\n    }\r\n    return CreditCard.INVALID;\r\n}","lc":-0.2272727273,"pi":0.3732057416,"ma":-0.2,"nbd":0.0,"ml":0.25,"d":0.2103174603,"mi":0.2022551092,"fo":-0.0833333333,"r":0.8947368421,"e":0.0640214842}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public void setTableProperty(ByteBuffer login, String tableName, String property, String value) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\r\n    send_setTableProperty(login, tableName, property, value);\r\n    recv_setTableProperty();\r\n}","code_comment":null,"code_no_comment":"public void setTableProperty(ByteBuffer login, String tableName, String property, String value) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\r\n    send_setTableProperty(login, tableName, property, value);\r\n    recv_setTableProperty();\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6817477097,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Long reusable) {\r\n    long val = 0;\r\n    boolean neg = false;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    if (bytes[startPos] == '-') {\r\n        neg = true;\r\n        startPos++;\r\n        \/\/ check for empty field with only the sign\r\n        if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\r\n            return -1;\r\n        }\r\n    }\r\n    for (int i = startPos; i < limit; i++) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            this.result = neg ? -val : val;\r\n            return i + delimiter.length;\r\n        }\r\n        if (bytes[i] < 48 || bytes[i] > 57) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\r\n            return -1;\r\n        }\r\n        val *= 10;\r\n        val += bytes[i] - 48;\r\n        \/\/ check for overflow \/ underflow\r\n        if (val < 0) {\r\n            \/\/ this is an overflow\/underflow, unless we hit exactly the Long.MIN_VALUE\r\n            if (neg && val == Long.MIN_VALUE) {\r\n                this.result = Long.MIN_VALUE;\r\n                if (i + 1 >= limit) {\r\n                    return limit;\r\n                } else if (i + 1 < delimLimit && delimiterNext(bytes, i + 1, delimiter)) {\r\n                    return i + 1 + delimiter.length;\r\n                } else {\r\n                    setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\r\n                    return -1;\r\n                }\r\n            } else {\r\n                setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\r\n                return -1;\r\n            }\r\n        }\r\n    }\r\n    this.result = neg ? -val : val;\r\n    return limit;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Long reusable) {\r\n    long val = 0;\r\n    boolean neg = false;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    if (bytes[startPos] == '-') {\r\n        neg = true;\r\n        startPos++;\r\n                if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\r\n            return -1;\r\n        }\r\n    }\r\n    for (int i = startPos; i < limit; i++) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            this.result = neg ? -val : val;\r\n            return i + delimiter.length;\r\n        }\r\n        if (bytes[i] < 48 || bytes[i] > 57) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\r\n            return -1;\r\n        }\r\n        val *= 10;\r\n        val += bytes[i] - 48;\r\n                if (val < 0) {\r\n                        if (neg && val == Long.MIN_VALUE) {\r\n                this.result = Long.MIN_VALUE;\r\n                if (i + 1 >= limit) {\r\n                    return limit;\r\n                } else if (i + 1 < delimLimit && delimiterNext(bytes, i + 1, delimiter)) {\r\n                    return i + 1 + delimiter.length;\r\n                } else {\r\n                    setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\r\n                    return -1;\r\n                }\r\n            } else {\r\n                setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\r\n                return -1;\r\n            }\r\n        }\r\n    }\r\n    this.result = neg ? -val : val;\r\n    return limit;\r\n}","lc":1.3636363636,"pi":1.2296650718,"ma":1.6,"nbd":1.5,"ml":1.9166666667,"d":3.9206349206,"mi":-0.8108527132,"fo":0.0833333333,"r":-0.0263157895,"e":7.9456786708}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7586_1f92fa42","label":3,"code":"public Boolean getMessageHistory() {\r\n    return context.isMessageHistory();\r\n}","code_comment":null,"code_no_comment":"public Boolean getMessageHistory() {\r\n    return context.isMessageHistory();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.4166666667,"r":1.6315789474,"e":-0.1627934049}
{"project_name":"Closure","project_version":"34","label":2,"code":"void add(Node n, Context context) {\r\n    if (!cc.continueProcessing()) {\r\n        return;\r\n    }\r\n    int type = n.getType();\r\n    String opstr = NodeUtil.opToStr(type);\r\n    int childCount = n.getChildCount();\r\n    Node first = n.getFirstChild();\r\n    Node last = n.getLastChild();\r\n    \/\/ Handle all binary operators\r\n    if (opstr != null && first != last) {\r\n        Preconditions.checkState(childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\r\n        int p = NodeUtil.precedence(type);\r\n        \/\/ For right-hand-side of operations, only pass context if it's\r\n        \/\/ the IN_FOR_INIT_CLAUSE one.\r\n        Context rhsContext = getContextForNoInOperator(context);\r\n        \/\/ we can simply generate a * b * c.\r\n        if (last.getType() == type && NodeUtil.isAssociative(type)) {\r\n            addExpr(first, p, context);\r\n            cc.addOp(opstr, true);\r\n            addExpr(last, p, rhsContext);\r\n        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\r\n            \/\/ Assignments are the only right-associative binary operators\r\n            addExpr(first, p, context);\r\n            cc.addOp(opstr, true);\r\n            addExpr(last, p, rhsContext);\r\n        } else {\r\n            addExpr(first, p, context);\r\n            cc.addOp(opstr, true);\r\n            addExpr(last, p + 1, rhsContext);\r\n        }\r\n        return;\r\n    }\r\n    cc.startSourceMapping(n);\r\n    switch(type) {\r\n        case Token.TRY:\r\n            {\r\n                Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());\r\n                Preconditions.checkState(childCount >= 2 && childCount <= 3);\r\n                add(\"try\");\r\n                add(first, Context.PRESERVE_BLOCK);\r\n                \/\/ second child contains the catch block, or nothing if there\r\n                \/\/ isn't a catch block\r\n                Node catchblock = first.getNext().getFirstChild();\r\n                if (catchblock != null) {\r\n                    add(catchblock);\r\n                }\r\n                if (childCount == 3) {\r\n                    add(\"finally\");\r\n                    add(last, Context.PRESERVE_BLOCK);\r\n                }\r\n                break;\r\n            }\r\n        case Token.CATCH:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"catch(\");\r\n            add(first);\r\n            add(\")\");\r\n            add(last, Context.PRESERVE_BLOCK);\r\n            break;\r\n        case Token.THROW:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"throw\");\r\n            add(first);\r\n            \/\/ Must have a ';' after a throw statement, otherwise safari can't\r\n            \/\/ parse this.\r\n            cc.endStatement(true);\r\n            break;\r\n        case Token.RETURN:\r\n            add(\"return\");\r\n            if (childCount == 1) {\r\n                add(first);\r\n            } else {\r\n                Preconditions.checkState(childCount == 0);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.VAR:\r\n            if (first != null) {\r\n                add(\"var \");\r\n                addList(first, false, getContextForNoInOperator(context));\r\n            }\r\n            break;\r\n        case Token.LABEL_NAME:\r\n            Preconditions.checkState(!n.getString().isEmpty());\r\n            addIdentifier(n.getString());\r\n            break;\r\n        case Token.NAME:\r\n            if (first == null || first.isEmpty()) {\r\n                addIdentifier(n.getString());\r\n            } else {\r\n                Preconditions.checkState(childCount == 1);\r\n                addIdentifier(n.getString());\r\n                cc.addOp(\"=\", true);\r\n                if (first.isComma()) {\r\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\r\n                } else {\r\n                    \/\/ Add expression, consider nearby code at lowest level of\r\n                    \/\/ precedence.\r\n                    addExpr(first, 0, getContextForNoInOperator(context));\r\n                }\r\n            }\r\n            break;\r\n        case Token.ARRAYLIT:\r\n            add(\"[\");\r\n            addArrayList(first);\r\n            add(\"]\");\r\n            break;\r\n        case Token.PARAM_LIST:\r\n            add(\"(\");\r\n            addList(first);\r\n            add(\")\");\r\n            break;\r\n        case Token.COMMA:\r\n            Preconditions.checkState(childCount == 2);\r\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\r\n            break;\r\n        case Token.NUMBER:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addNumber(n.getDouble());\r\n            break;\r\n        case Token.TYPEOF:\r\n        case Token.VOID:\r\n        case Token.NOT:\r\n        case Token.BITNOT:\r\n        case Token.POS:\r\n            {\r\n                \/\/ All of these unary operators are right-associative\r\n                Preconditions.checkState(childCount == 1);\r\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\r\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\r\n                break;\r\n            }\r\n        case Token.NEG:\r\n            {\r\n                Preconditions.checkState(childCount == 1);\r\n                \/\/ NEG is a weird case because Rhino parses \"- -2\" as \"2\".\r\n                if (n.getFirstChild().isNumber()) {\r\n                    cc.addNumber(-n.getFirstChild().getDouble());\r\n                } else {\r\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\r\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\r\n                }\r\n                break;\r\n            }\r\n        case Token.HOOK:\r\n            {\r\n                Preconditions.checkState(childCount == 3);\r\n                int p = NodeUtil.precedence(type);\r\n                addExpr(first, p + 1, context);\r\n                cc.addOp(\"?\", true);\r\n                addExpr(first.getNext(), 1, Context.OTHER);\r\n                cc.addOp(\":\", true);\r\n                addExpr(last, 1, Context.OTHER);\r\n                break;\r\n            }\r\n        case Token.REGEXP:\r\n            if (!first.isString() || !last.isString()) {\r\n                throw new Error(\"Expected children to be strings\");\r\n            }\r\n            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\r\n            \/\/ I only use one .add because whitespace matters\r\n            if (childCount == 2) {\r\n                add(regexp + last.getString());\r\n            } else {\r\n                Preconditions.checkState(childCount == 1);\r\n                add(regexp);\r\n            }\r\n            break;\r\n        case Token.FUNCTION:\r\n            if (n.getClass() != Node.class) {\r\n                throw new Error(\"Unexpected Node subclass.\");\r\n            }\r\n            Preconditions.checkState(childCount == 3);\r\n            boolean funcNeedsParens = (context == Context.START_OF_EXPR);\r\n            if (funcNeedsParens) {\r\n                add(\"(\");\r\n            }\r\n            add(\"function\");\r\n            add(first);\r\n            add(first.getNext());\r\n            add(last, Context.PRESERVE_BLOCK);\r\n            cc.endFunction(context == Context.STATEMENT);\r\n            if (funcNeedsParens) {\r\n                add(\")\");\r\n            }\r\n            break;\r\n        case Token.GETTER_DEF:\r\n        case Token.SETTER_DEF:\r\n            Preconditions.checkState(n.getParent().isObjectLit());\r\n            Preconditions.checkState(childCount == 1);\r\n            Preconditions.checkState(first.isFunction());\r\n            \/\/ Get methods are unnamed\r\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\r\n            if (type == Token.GETTER_DEF) {\r\n                \/\/ Get methods have no parameters.\r\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\r\n                add(\"get \");\r\n            } else {\r\n                \/\/ Set methods have one parameter.\r\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\r\n                add(\"set \");\r\n            }\r\n            \/\/ The name is on the GET or SET node.\r\n            String name = n.getString();\r\n            Node fn = first;\r\n            Node parameters = fn.getChildAtIndex(1);\r\n            Node body = fn.getLastChild();\r\n            \/\/ Add the property name.\r\n            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && \/\/ unicode escaped.\r\n            NodeUtil.isLatin(name)) {\r\n                add(name);\r\n            } else {\r\n                \/\/ Determine if the string is a simple number.\r\n                double d = getSimpleNumber(name);\r\n                if (!Double.isNaN(d)) {\r\n                    cc.addNumber(d);\r\n                } else {\r\n                    addJsString(n);\r\n                }\r\n            }\r\n            add(parameters);\r\n            add(body, Context.PRESERVE_BLOCK);\r\n            break;\r\n        case Token.SCRIPT:\r\n        case Token.BLOCK:\r\n            {\r\n                if (n.getClass() != Node.class) {\r\n                    throw new Error(\"Unexpected Node subclass.\");\r\n                }\r\n                boolean preserveBlock = context == Context.PRESERVE_BLOCK;\r\n                if (preserveBlock) {\r\n                    cc.beginBlock();\r\n                }\r\n                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());\r\n                for (Node c = first; c != null; c = c.getNext()) {\r\n                    add(c, Context.STATEMENT);\r\n                    \/\/ VAR doesn't include ';' since it gets used in expressions\r\n                    if (c.isVar()) {\r\n                        cc.endStatement();\r\n                    }\r\n                    if (c.isFunction()) {\r\n                        cc.maybeLineBreak();\r\n                    }\r\n                    \/\/ because top level statements are more homogeneous.\r\n                    if (preferLineBreaks) {\r\n                        cc.notePreferredLineBreak();\r\n                    }\r\n                }\r\n                if (preserveBlock) {\r\n                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\r\n                }\r\n                break;\r\n            }\r\n        case Token.FOR:\r\n            if (childCount == 4) {\r\n                add(\"for(\");\r\n                if (first.isVar()) {\r\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\r\n                } else {\r\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\r\n                }\r\n                add(\";\");\r\n                add(first.getNext());\r\n                add(\";\");\r\n                add(first.getNext().getNext());\r\n                add(\")\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            } else {\r\n                Preconditions.checkState(childCount == 3);\r\n                add(\"for(\");\r\n                add(first);\r\n                add(\"in\");\r\n                add(first.getNext());\r\n                add(\")\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            }\r\n            break;\r\n        case Token.DO:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"do\");\r\n            addNonEmptyStatement(first, Context.OTHER, false);\r\n            add(\"while(\");\r\n            add(last);\r\n            add(\")\");\r\n            cc.endStatement();\r\n            break;\r\n        case Token.WHILE:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"while(\");\r\n            add(first);\r\n            add(\")\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            break;\r\n        case Token.EMPTY:\r\n            Preconditions.checkState(childCount == 0);\r\n            break;\r\n        case Token.GETPROP:\r\n            {\r\n                Preconditions.checkState(childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\r\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\r\n                boolean needsParens = (first.isNumber());\r\n                if (needsParens) {\r\n                    add(\"(\");\r\n                }\r\n                addExpr(first, NodeUtil.precedence(type), context);\r\n                if (needsParens) {\r\n                    add(\")\");\r\n                }\r\n                add(\".\");\r\n                addIdentifier(last.getString());\r\n                break;\r\n            }\r\n        case Token.GETELEM:\r\n            Preconditions.checkState(childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\r\n            addExpr(first, NodeUtil.precedence(type), context);\r\n            add(\"[\");\r\n            add(first.getNext());\r\n            add(\"]\");\r\n            break;\r\n        case Token.WITH:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"with(\");\r\n            add(first);\r\n            add(\")\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            break;\r\n        case Token.INC:\r\n        case Token.DEC:\r\n            {\r\n                Preconditions.checkState(childCount == 1);\r\n                String o = type == Token.INC ? \"++\" : \"--\";\r\n                int postProp = n.getIntProp(Node.INCRDECR_PROP);\r\n                \/\/ is a pre-inc\/dec.\r\n                if (postProp != 0) {\r\n                    addExpr(first, NodeUtil.precedence(type), context);\r\n                    cc.addOp(o, false);\r\n                } else {\r\n                    cc.addOp(o, false);\r\n                    add(first);\r\n                }\r\n                break;\r\n            }\r\n        case Token.CALL:\r\n            \/\/ that must be preserved.\r\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\r\n                add(\"(0,\");\r\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\r\n                add(\")\");\r\n            } else {\r\n                addExpr(first, NodeUtil.precedence(type), context);\r\n            }\r\n            add(\"(\");\r\n            addList(first.getNext());\r\n            add(\")\");\r\n            break;\r\n        case Token.IF:\r\n            boolean hasElse = childCount == 3;\r\n            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;\r\n            if (ambiguousElseClause) {\r\n                cc.beginBlock();\r\n            }\r\n            add(\"if(\");\r\n            add(first);\r\n            add(\")\");\r\n            if (hasElse) {\r\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\r\n                add(\"else\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            } else {\r\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\r\n                Preconditions.checkState(childCount == 2);\r\n            }\r\n            if (ambiguousElseClause) {\r\n                cc.endBlock();\r\n            }\r\n            break;\r\n        case Token.NULL:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"null\");\r\n            break;\r\n        case Token.THIS:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"this\");\r\n            break;\r\n        case Token.FALSE:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"false\");\r\n            break;\r\n        case Token.TRUE:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"true\");\r\n            break;\r\n        case Token.CONTINUE:\r\n            Preconditions.checkState(childCount <= 1);\r\n            add(\"continue\");\r\n            if (childCount == 1) {\r\n                if (!first.isLabelName()) {\r\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n                }\r\n                add(\" \");\r\n                add(first);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.DEBUGGER:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"debugger\");\r\n            cc.endStatement();\r\n            break;\r\n        case Token.BREAK:\r\n            Preconditions.checkState(childCount <= 1);\r\n            add(\"break\");\r\n            if (childCount == 1) {\r\n                if (!first.isLabelName()) {\r\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n                }\r\n                add(\" \");\r\n                add(first);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.EXPR_RESULT:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(first, Context.START_OF_EXPR);\r\n            cc.endStatement();\r\n            break;\r\n        case Token.NEW:\r\n            add(\"new \");\r\n            int precedence = NodeUtil.precedence(type);\r\n            \/\/ first viable parentheses (don't traverse into functions).\r\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\r\n                precedence = NodeUtil.precedence(first.getType()) + 1;\r\n            }\r\n            addExpr(first, precedence, Context.OTHER);\r\n            \/\/ '()' is optional when no arguments are present\r\n            Node next = first.getNext();\r\n            if (next != null) {\r\n                add(\"(\");\r\n                addList(next);\r\n                add(\")\");\r\n            }\r\n            break;\r\n        case Token.STRING:\r\n            if (childCount != ((n.getParent() != null && n.getParent().isObjectLit()) ? 1 : 0)) {\r\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\r\n            }\r\n            addJsString(n);\r\n            break;\r\n        case Token.DELPROP:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"delete \");\r\n            add(first);\r\n            break;\r\n        case Token.OBJECTLIT:\r\n            {\r\n                boolean needsParens = (context == Context.START_OF_EXPR);\r\n                if (needsParens) {\r\n                    add(\"(\");\r\n                }\r\n                add(\"{\");\r\n                for (Node c = first; c != null; c = c.getNext()) {\r\n                    if (c != first) {\r\n                        cc.listSeparator();\r\n                    }\r\n                    if (c.isGetterDef() || c.isSetterDef()) {\r\n                        add(c);\r\n                    } else {\r\n                        Preconditions.checkState(c.isString());\r\n                        String key = c.getString();\r\n                        \/\/ are not JavaScript keywords\r\n                        if (!c.isQuotedString() && !TokenStream.isKeyword(key) && TokenStream.isJSIdentifier(key) && \/\/ were unicode escaped.\r\n                        NodeUtil.isLatin(key)) {\r\n                            add(key);\r\n                        } else {\r\n                            \/\/ Determine if the string is a simple number.\r\n                            double d = getSimpleNumber(key);\r\n                            if (!Double.isNaN(d)) {\r\n                                cc.addNumber(d);\r\n                            } else {\r\n                                addExpr(c, 1, Context.OTHER);\r\n                            }\r\n                        }\r\n                        add(\":\");\r\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\r\n                    }\r\n                }\r\n                add(\"}\");\r\n                if (needsParens) {\r\n                    add(\")\");\r\n                }\r\n                break;\r\n            }\r\n        case Token.SWITCH:\r\n            add(\"switch(\");\r\n            add(first);\r\n            add(\")\");\r\n            cc.beginBlock();\r\n            addAllSiblings(first.getNext());\r\n            cc.endBlock(context == Context.STATEMENT);\r\n            break;\r\n        case Token.CASE:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"case \");\r\n            add(first);\r\n            addCaseBody(last);\r\n            break;\r\n        case Token.DEFAULT_CASE:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"default\");\r\n            addCaseBody(first);\r\n            break;\r\n        case Token.LABEL:\r\n            Preconditions.checkState(childCount == 2);\r\n            if (!first.isLabelName()) {\r\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n            }\r\n            add(first);\r\n            add(\":\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\r\n            break;\r\n        default:\r\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\r\n    }\r\n    cc.endSourceMapping(n);\r\n}","code_comment":null,"code_no_comment":"void add(Node n, Context context) {\r\n    if (!cc.continueProcessing()) {\r\n        return;\r\n    }\r\n    int type = n.getType();\r\n    String opstr = NodeUtil.opToStr(type);\r\n    int childCount = n.getChildCount();\r\n    Node first = n.getFirstChild();\r\n    Node last = n.getLastChild();\r\n        if (opstr != null && first != last) {\r\n        Preconditions.checkState(childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\r\n        int p = NodeUtil.precedence(type);\r\n                        Context rhsContext = getContextForNoInOperator(context);\r\n                if (last.getType() == type && NodeUtil.isAssociative(type)) {\r\n            addExpr(first, p, context);\r\n            cc.addOp(opstr, true);\r\n            addExpr(last, p, rhsContext);\r\n        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\r\n                        addExpr(first, p, context);\r\n            cc.addOp(opstr, true);\r\n            addExpr(last, p, rhsContext);\r\n        } else {\r\n            addExpr(first, p, context);\r\n            cc.addOp(opstr, true);\r\n            addExpr(last, p + 1, rhsContext);\r\n        }\r\n        return;\r\n    }\r\n    cc.startSourceMapping(n);\r\n    switch(type) {\r\n        case Token.TRY:\r\n            {\r\n                Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());\r\n                Preconditions.checkState(childCount >= 2 && childCount <= 3);\r\n                add(\"try\");\r\n                add(first, Context.PRESERVE_BLOCK);\r\n                                                Node catchblock = first.getNext().getFirstChild();\r\n                if (catchblock != null) {\r\n                    add(catchblock);\r\n                }\r\n                if (childCount == 3) {\r\n                    add(\"finally\");\r\n                    add(last, Context.PRESERVE_BLOCK);\r\n                }\r\n                break;\r\n            }\r\n        case Token.CATCH:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"catch(\");\r\n            add(first);\r\n            add(\")\");\r\n            add(last, Context.PRESERVE_BLOCK);\r\n            break;\r\n        case Token.THROW:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"throw\");\r\n            add(first);\r\n                                    cc.endStatement(true);\r\n            break;\r\n        case Token.RETURN:\r\n            add(\"return\");\r\n            if (childCount == 1) {\r\n                add(first);\r\n            } else {\r\n                Preconditions.checkState(childCount == 0);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.VAR:\r\n            if (first != null) {\r\n                add(\"var \");\r\n                addList(first, false, getContextForNoInOperator(context));\r\n            }\r\n            break;\r\n        case Token.LABEL_NAME:\r\n            Preconditions.checkState(!n.getString().isEmpty());\r\n            addIdentifier(n.getString());\r\n            break;\r\n        case Token.NAME:\r\n            if (first == null || first.isEmpty()) {\r\n                addIdentifier(n.getString());\r\n            } else {\r\n                Preconditions.checkState(childCount == 1);\r\n                addIdentifier(n.getString());\r\n                cc.addOp(\"=\", true);\r\n                if (first.isComma()) {\r\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\r\n                } else {\r\n                                                            addExpr(first, 0, getContextForNoInOperator(context));\r\n                }\r\n            }\r\n            break;\r\n        case Token.ARRAYLIT:\r\n            add(\"[\");\r\n            addArrayList(first);\r\n            add(\"]\");\r\n            break;\r\n        case Token.PARAM_LIST:\r\n            add(\"(\");\r\n            addList(first);\r\n            add(\")\");\r\n            break;\r\n        case Token.COMMA:\r\n            Preconditions.checkState(childCount == 2);\r\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\r\n            break;\r\n        case Token.NUMBER:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addNumber(n.getDouble());\r\n            break;\r\n        case Token.TYPEOF:\r\n        case Token.VOID:\r\n        case Token.NOT:\r\n        case Token.BITNOT:\r\n        case Token.POS:\r\n            {\r\n                                Preconditions.checkState(childCount == 1);\r\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\r\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\r\n                break;\r\n            }\r\n        case Token.NEG:\r\n            {\r\n                Preconditions.checkState(childCount == 1);\r\n                                if (n.getFirstChild().isNumber()) {\r\n                    cc.addNumber(-n.getFirstChild().getDouble());\r\n                } else {\r\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\r\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\r\n                }\r\n                break;\r\n            }\r\n        case Token.HOOK:\r\n            {\r\n                Preconditions.checkState(childCount == 3);\r\n                int p = NodeUtil.precedence(type);\r\n                addExpr(first, p + 1, context);\r\n                cc.addOp(\"?\", true);\r\n                addExpr(first.getNext(), 1, Context.OTHER);\r\n                cc.addOp(\":\", true);\r\n                addExpr(last, 1, Context.OTHER);\r\n                break;\r\n            }\r\n        case Token.REGEXP:\r\n            if (!first.isString() || !last.isString()) {\r\n                throw new Error(\"Expected children to be strings\");\r\n            }\r\n            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\r\n                        if (childCount == 2) {\r\n                add(regexp + last.getString());\r\n            } else {\r\n                Preconditions.checkState(childCount == 1);\r\n                add(regexp);\r\n            }\r\n            break;\r\n        case Token.FUNCTION:\r\n            if (n.getClass() != Node.class) {\r\n                throw new Error(\"Unexpected Node subclass.\");\r\n            }\r\n            Preconditions.checkState(childCount == 3);\r\n            boolean funcNeedsParens = (context == Context.START_OF_EXPR);\r\n            if (funcNeedsParens) {\r\n                add(\"(\");\r\n            }\r\n            add(\"function\");\r\n            add(first);\r\n            add(first.getNext());\r\n            add(last, Context.PRESERVE_BLOCK);\r\n            cc.endFunction(context == Context.STATEMENT);\r\n            if (funcNeedsParens) {\r\n                add(\")\");\r\n            }\r\n            break;\r\n        case Token.GETTER_DEF:\r\n        case Token.SETTER_DEF:\r\n            Preconditions.checkState(n.getParent().isObjectLit());\r\n            Preconditions.checkState(childCount == 1);\r\n            Preconditions.checkState(first.isFunction());\r\n                        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\r\n            if (type == Token.GETTER_DEF) {\r\n                                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\r\n                add(\"get \");\r\n            } else {\r\n                                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\r\n                add(\"set \");\r\n            }\r\n                        String name = n.getString();\r\n            Node fn = first;\r\n            Node parameters = fn.getChildAtIndex(1);\r\n            Node body = fn.getLastChild();\r\n                        if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) &&             NodeUtil.isLatin(name)) {\r\n                add(name);\r\n            } else {\r\n                                double d = getSimpleNumber(name);\r\n                if (!Double.isNaN(d)) {\r\n                    cc.addNumber(d);\r\n                } else {\r\n                    addJsString(n);\r\n                }\r\n            }\r\n            add(parameters);\r\n            add(body, Context.PRESERVE_BLOCK);\r\n            break;\r\n        case Token.SCRIPT:\r\n        case Token.BLOCK:\r\n            {\r\n                if (n.getClass() != Node.class) {\r\n                    throw new Error(\"Unexpected Node subclass.\");\r\n                }\r\n                boolean preserveBlock = context == Context.PRESERVE_BLOCK;\r\n                if (preserveBlock) {\r\n                    cc.beginBlock();\r\n                }\r\n                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());\r\n                for (Node c = first; c != null; c = c.getNext()) {\r\n                    add(c, Context.STATEMENT);\r\n                                        if (c.isVar()) {\r\n                        cc.endStatement();\r\n                    }\r\n                    if (c.isFunction()) {\r\n                        cc.maybeLineBreak();\r\n                    }\r\n                                        if (preferLineBreaks) {\r\n                        cc.notePreferredLineBreak();\r\n                    }\r\n                }\r\n                if (preserveBlock) {\r\n                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\r\n                }\r\n                break;\r\n            }\r\n        case Token.FOR:\r\n            if (childCount == 4) {\r\n                add(\"for(\");\r\n                if (first.isVar()) {\r\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\r\n                } else {\r\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\r\n                }\r\n                add(\";\");\r\n                add(first.getNext());\r\n                add(\";\");\r\n                add(first.getNext().getNext());\r\n                add(\")\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            } else {\r\n                Preconditions.checkState(childCount == 3);\r\n                add(\"for(\");\r\n                add(first);\r\n                add(\"in\");\r\n                add(first.getNext());\r\n                add(\")\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            }\r\n            break;\r\n        case Token.DO:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"do\");\r\n            addNonEmptyStatement(first, Context.OTHER, false);\r\n            add(\"while(\");\r\n            add(last);\r\n            add(\")\");\r\n            cc.endStatement();\r\n            break;\r\n        case Token.WHILE:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"while(\");\r\n            add(first);\r\n            add(\")\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            break;\r\n        case Token.EMPTY:\r\n            Preconditions.checkState(childCount == 0);\r\n            break;\r\n        case Token.GETPROP:\r\n            {\r\n                Preconditions.checkState(childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\r\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\r\n                boolean needsParens = (first.isNumber());\r\n                if (needsParens) {\r\n                    add(\"(\");\r\n                }\r\n                addExpr(first, NodeUtil.precedence(type), context);\r\n                if (needsParens) {\r\n                    add(\")\");\r\n                }\r\n                add(\".\");\r\n                addIdentifier(last.getString());\r\n                break;\r\n            }\r\n        case Token.GETELEM:\r\n            Preconditions.checkState(childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\r\n            addExpr(first, NodeUtil.precedence(type), context);\r\n            add(\"[\");\r\n            add(first.getNext());\r\n            add(\"]\");\r\n            break;\r\n        case Token.WITH:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"with(\");\r\n            add(first);\r\n            add(\")\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            break;\r\n        case Token.INC:\r\n        case Token.DEC:\r\n            {\r\n                Preconditions.checkState(childCount == 1);\r\n                String o = type == Token.INC ? \"++\" : \"--\";\r\n                int postProp = n.getIntProp(Node.INCRDECR_PROP);\r\n                                if (postProp != 0) {\r\n                    addExpr(first, NodeUtil.precedence(type), context);\r\n                    cc.addOp(o, false);\r\n                } else {\r\n                    cc.addOp(o, false);\r\n                    add(first);\r\n                }\r\n                break;\r\n            }\r\n        case Token.CALL:\r\n                        if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\r\n                add(\"(0,\");\r\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\r\n                add(\")\");\r\n            } else {\r\n                addExpr(first, NodeUtil.precedence(type), context);\r\n            }\r\n            add(\"(\");\r\n            addList(first.getNext());\r\n            add(\")\");\r\n            break;\r\n        case Token.IF:\r\n            boolean hasElse = childCount == 3;\r\n            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;\r\n            if (ambiguousElseClause) {\r\n                cc.beginBlock();\r\n            }\r\n            add(\"if(\");\r\n            add(first);\r\n            add(\")\");\r\n            if (hasElse) {\r\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\r\n                add(\"else\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            } else {\r\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\r\n                Preconditions.checkState(childCount == 2);\r\n            }\r\n            if (ambiguousElseClause) {\r\n                cc.endBlock();\r\n            }\r\n            break;\r\n        case Token.NULL:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"null\");\r\n            break;\r\n        case Token.THIS:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"this\");\r\n            break;\r\n        case Token.FALSE:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"false\");\r\n            break;\r\n        case Token.TRUE:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"true\");\r\n            break;\r\n        case Token.CONTINUE:\r\n            Preconditions.checkState(childCount <= 1);\r\n            add(\"continue\");\r\n            if (childCount == 1) {\r\n                if (!first.isLabelName()) {\r\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n                }\r\n                add(\" \");\r\n                add(first);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.DEBUGGER:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"debugger\");\r\n            cc.endStatement();\r\n            break;\r\n        case Token.BREAK:\r\n            Preconditions.checkState(childCount <= 1);\r\n            add(\"break\");\r\n            if (childCount == 1) {\r\n                if (!first.isLabelName()) {\r\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n                }\r\n                add(\" \");\r\n                add(first);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.EXPR_RESULT:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(first, Context.START_OF_EXPR);\r\n            cc.endStatement();\r\n            break;\r\n        case Token.NEW:\r\n            add(\"new \");\r\n            int precedence = NodeUtil.precedence(type);\r\n                        if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\r\n                precedence = NodeUtil.precedence(first.getType()) + 1;\r\n            }\r\n            addExpr(first, precedence, Context.OTHER);\r\n                        Node next = first.getNext();\r\n            if (next != null) {\r\n                add(\"(\");\r\n                addList(next);\r\n                add(\")\");\r\n            }\r\n            break;\r\n        case Token.STRING:\r\n            if (childCount != ((n.getParent() != null && n.getParent().isObjectLit()) ? 1 : 0)) {\r\n                throw new IllegalStateException(\"Unexpected String children: \" + n.getParent().toStringTree());\r\n            }\r\n            addJsString(n);\r\n            break;\r\n        case Token.DELPROP:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"delete \");\r\n            add(first);\r\n            break;\r\n        case Token.OBJECTLIT:\r\n            {\r\n                boolean needsParens = (context == Context.START_OF_EXPR);\r\n                if (needsParens) {\r\n                    add(\"(\");\r\n                }\r\n                add(\"{\");\r\n                for (Node c = first; c != null; c = c.getNext()) {\r\n                    if (c != first) {\r\n                        cc.listSeparator();\r\n                    }\r\n                    if (c.isGetterDef() || c.isSetterDef()) {\r\n                        add(c);\r\n                    } else {\r\n                        Preconditions.checkState(c.isString());\r\n                        String key = c.getString();\r\n                                                if (!c.isQuotedString() && !TokenStream.isKeyword(key) && TokenStream.isJSIdentifier(key) &&                         NodeUtil.isLatin(key)) {\r\n                            add(key);\r\n                        } else {\r\n                                                        double d = getSimpleNumber(key);\r\n                            if (!Double.isNaN(d)) {\r\n                                cc.addNumber(d);\r\n                            } else {\r\n                                addExpr(c, 1, Context.OTHER);\r\n                            }\r\n                        }\r\n                        add(\":\");\r\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\r\n                    }\r\n                }\r\n                add(\"}\");\r\n                if (needsParens) {\r\n                    add(\")\");\r\n                }\r\n                break;\r\n            }\r\n        case Token.SWITCH:\r\n            add(\"switch(\");\r\n            add(first);\r\n            add(\")\");\r\n            cc.beginBlock();\r\n            addAllSiblings(first.getNext());\r\n            cc.endBlock(context == Context.STATEMENT);\r\n            break;\r\n        case Token.CASE:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"case \");\r\n            add(first);\r\n            addCaseBody(last);\r\n            break;\r\n        case Token.DEFAULT_CASE:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"default\");\r\n            addCaseBody(first);\r\n            break;\r\n        case Token.LABEL:\r\n            Preconditions.checkState(childCount == 2);\r\n            if (!first.isLabelName()) {\r\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n            }\r\n            add(first);\r\n            add(\":\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\r\n            break;\r\n        default:\r\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\r\n    }\r\n    cc.endSourceMapping(n);\r\n}","lc":22.0,"pi":0.6555023923,"ma":30.6,"nbd":2.0,"ml":13.5833333333,"d":4.7123015873,"mi":-3.2322762509,"fo":28.75,"r":-0.0263157895,"e":122.5036289137}
{"project_name":"Math","project_version":"16","label":1,"code":"\/**\r\n * Compute the hyperbolic cosine of a number.\r\n * @param x number on which evaluation is done\r\n * @return hyperbolic cosine of x\r\n *\/\r\npublic static double cosh(double x) {\r\n    if (x != x) {\r\n        return x;\r\n    }\r\n    if (x > 20) {\r\n        \/\/ Avoid overflow (MATH-905).\r\n        return 0.5 * exp(x);\r\n    }\r\n    if (x < -20) {\r\n        \/\/ Avoid overflow (MATH-905).\r\n        return 0.5 * exp(-x);\r\n    }\r\n    final double[] hiPrec = new double[2];\r\n    if (x < 0.0) {\r\n        x = -x;\r\n    }\r\n    exp(x, 0.0, hiPrec);\r\n    double ya = hiPrec[0] + hiPrec[1];\r\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\r\n    double temp = ya * HEX_40000000;\r\n    double yaa = ya + temp - temp;\r\n    double yab = ya - yaa;\r\n    \/\/ recip = 1\/y\r\n    double recip = 1.0 \/ ya;\r\n    temp = recip * HEX_40000000;\r\n    double recipa = recip + temp - temp;\r\n    double recipb = recip - recipa;\r\n    \/\/ Correct for rounding in division\r\n    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\r\n    \/\/ Account for yb\r\n    recipb += -yb * recip * recip;\r\n    \/\/ y = y + 1\/y\r\n    temp = ya + recipa;\r\n    yb += -(temp - ya - recipa);\r\n    ya = temp;\r\n    temp = ya + recipb;\r\n    yb += -(temp - ya - recipb);\r\n    ya = temp;\r\n    double result = ya + yb;\r\n    result *= 0.5;\r\n    return result;\r\n}","code_comment":"\/**\r\n * Compute the hyperbolic cosine of a number.\r\n * @param x number on which evaluation is done\r\n * @return hyperbolic cosine of x\r\n *\/\r\n","code_no_comment":"public static double cosh(double x) {\r\n    if (x != x) {\r\n        return x;\r\n    }\r\n    if (x > 20) {\r\n                return 0.5 * exp(x);\r\n    }\r\n    if (x < -20) {\r\n                return 0.5 * exp(-x);\r\n    }\r\n    final double[] hiPrec = new double[2];\r\n    if (x < 0.0) {\r\n        x = -x;\r\n    }\r\n    exp(x, 0.0, hiPrec);\r\n    double ya = hiPrec[0] + hiPrec[1];\r\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\r\n    double temp = ya * HEX_40000000;\r\n    double yaa = ya + temp - temp;\r\n    double yab = ya - yaa;\r\n        double recip = 1.0 \/ ya;\r\n    temp = recip * HEX_40000000;\r\n    double recipa = recip + temp - temp;\r\n    double recipb = recip - recipa;\r\n        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\r\n        recipb += -yb * recip * recip;\r\n        temp = ya + recipa;\r\n    yb += -(temp - ya - recipa);\r\n    ya = temp;\r\n    temp = ya + recipb;\r\n    yb += -(temp - ya - recipb);\r\n    ya = temp;\r\n    double result = ya + yb;\r\n    result *= 0.5;\r\n    return result;\r\n}","lc":1.0,"pi":-0.6555023923,"ma":0.2,"nbd":-0.5,"ml":0.0,"d":4.0992063492,"mi":-0.6701902748,"fo":-0.25,"r":-0.0263157895,"e":8.0839519833}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"\/**\r\n *  @return Iterator that iterates through children in the order they were\r\n *          added\r\n *\/\r\npublic final Iterator<Component> iterator() {\r\n    return new Iterator<Component>() {\r\n\r\n        int index = 0;\r\n\r\n        public boolean hasNext() {\r\n            return index < children_size();\r\n        }\r\n\r\n        public Component next() {\r\n            return children_get(index++);\r\n        }\r\n\r\n        public void remove() {\r\n            removedComponent(children_remove(--index));\r\n        }\r\n    };\r\n}","code_comment":"\/**\r\n *  @return Iterator that iterates through children in the order they were\r\n *          added\r\n *\/\r\n","code_no_comment":"public final Iterator<Component> iterator() {\r\n    return new Iterator<Component>() {\r\n\r\n        int index = 0;\r\n\r\n        public boolean hasNext() {\r\n            return index < children_size();\r\n        }\r\n\r\n        public Component next() {\r\n            return children_get(index++);\r\n        }\r\n\r\n        public void remove() {\r\n            removedComponent(children_remove(--index));\r\n        }\r\n    };\r\n}","lc":0.0,"pi":0.3684210526,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":0.2142857143,"mi":0.0999295278,"fo":-0.1666666667,"r":2.4210526316,"e":-0.0361012661}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Discards the <code>i<\/code> first or last elements of the array,\r\n * depending on the value of <code>front<\/code>.\r\n * For example, if the array contains the elements 1,2,3,4, invoking\r\n * <code>discardExtremeElements(2,false)<\/code> will cause the last two elements\r\n * to be discarded, leaving 1,2 in the array.\r\n * For example, if the array contains the elements 1,2,3,4, invoking\r\n * <code>discardExtremeElements(2,true)<\/code> will cause the first two elements\r\n * to be discarded, leaving 3,4 in the array.\r\n * Throws illegalArgumentException\r\n * if i exceeds numElements.\r\n *\r\n * @param i  the number of elements to discard from the front\/end of the array\r\n * @param front true if elements are to be discarded from the front\r\n * of the array, false if elements are to be discarded from the end\r\n * of the array\r\n * @throws MathIllegalArgumentException if i is greater than numElements.\r\n * @since 2.0\r\n *\/\r\nprivate synchronized void discardExtremeElements(int i, boolean front) throws MathIllegalArgumentException {\r\n    if (i > numElements) {\r\n        throw new MathIllegalArgumentException(LocalizedFormats.TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY, i, numElements);\r\n    } else if (i < 0) {\r\n        throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_DISCARD_NEGATIVE_NUMBER_OF_ELEMENTS, i);\r\n    } else {\r\n        \/\/ \"Subtract\" this number of discarded from numElements\r\n        numElements -= i;\r\n        if (front) {\r\n            startIndex += i;\r\n        }\r\n    }\r\n    if (shouldContract()) {\r\n        contract();\r\n    }\r\n}","code_comment":"\/**\r\n * Discards the <code>i<\/code> first or last elements of the array,\r\n * depending on the value of <code>front<\/code>.\r\n * For example, if the array contains the elements 1,2,3,4, invoking\r\n * <code>discardExtremeElements(2,false)<\/code> will cause the last two elements\r\n * to be discarded, leaving 1,2 in the array.\r\n * For example, if the array contains the elements 1,2,3,4, invoking\r\n * <code>discardExtremeElements(2,true)<\/code> will cause the first two elements\r\n * to be discarded, leaving 3,4 in the array.\r\n * Throws illegalArgumentException\r\n * if i exceeds numElements.\r\n *\r\n * @param i  the number of elements to discard from the front\/end of the array\r\n * @param front true if elements are to be discarded from the front\r\n * of the array, false if elements are to be discarded from the end\r\n * of the array\r\n * @throws MathIllegalArgumentException if i is greater than numElements.\r\n * @since 2.0\r\n *\/\r\n","code_no_comment":"private synchronized void discardExtremeElements(int i, boolean front) throws MathIllegalArgumentException {\r\n    if (i > numElements) {\r\n        throw new MathIllegalArgumentException(LocalizedFormats.TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY, i, numElements);\r\n    } else if (i < 0) {\r\n        throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_DISCARD_NEGATIVE_NUMBER_OF_ELEMENTS, i);\r\n    } else {\r\n                numElements -= i;\r\n        if (front) {\r\n            startIndex += i;\r\n        }\r\n    }\r\n    if (shouldContract()) {\r\n        contract();\r\n    }\r\n}","lc":0.0454545455,"pi":0.1004784689,"ma":0.6,"nbd":0.5,"ml":0.25,"d":0.3988095238,"mi":-0.0043692741,"fo":-0.3333333333,"r":-0.0263157895,"e":0.0473965987}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5043_2b1ce91d","label":1,"code":"\/**\r\n *  @see org.apache.wicket.core.request.mapper.AbstractBookmarkableMapper#pageMustHaveBeenCreatedBookmarkable()\r\n *\/\r\n@Override\r\nprotected boolean pageMustHaveBeenCreatedBookmarkable() {\r\n    return true;\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.core.request.mapper.AbstractBookmarkableMapper#pageMustHaveBeenCreatedBookmarkable()\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected boolean pageMustHaveBeenCreatedBookmarkable() {\r\n    return true;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0332628612,"fo":-0.5,"r":2.1315789474,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4927_8c827e33","label":1,"code":"@Override\r\npublic void write(byte[] array) {\r\n    writeBuffered();\r\n    originalResponse.write(array);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void write(byte[] array) {\r\n    writeBuffered();\r\n    originalResponse.write(array);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.792248062,"fo":-0.3333333333,"r":1.7368421053,"e":-0.1627934049}
{"project_name":"Closure","project_version":"157","label":2,"code":"\/**\r\n * Transforms the given node and then sets its type to Token.STRING if it\r\n * was Token.NAME. If its type was already Token.STRING, then quotes it.\r\n * Used for properties, as the old AST uses String tokens, while the new one\r\n * uses Name tokens for unquoted strings. For example, in\r\n * var o = {'a' : 1, b: 2};\r\n * the string 'a' is quoted, while the name b is turned into a string, but\r\n * unquoted.\r\n *\/\r\nprivate Node transformAsString(AstNode n) {\r\n    Node ret;\r\n    if (n instanceof Name) {\r\n        ret = transformNameAsString((Name) n);\r\n    } else {\r\n        ret = transform(n);\r\n        Preconditions.checkState(ret.getType() == Token.NUMBER || ret.getType() == Token.STRING);\r\n        if (ret.getType() == Token.STRING) {\r\n            ret.putBooleanProp(Node.QUOTED_PROP, true);\r\n        }\r\n    }\r\n    return ret;\r\n}","code_comment":"\/**\r\n * Transforms the given node and then sets its type to Token.STRING if it\r\n * was Token.NAME. If its type was already Token.STRING, then quotes it.\r\n * Used for properties, as the old AST uses String tokens, while the new one\r\n * uses Name tokens for unquoted strings. For example, in\r\n * var o = {'a' : 1, b: 2};\r\n * the string 'a' is quoted, while the name b is turned into a string, but\r\n * unquoted.\r\n *\/\r\n","code_no_comment":"private Node transformAsString(AstNode n) {\r\n    Node ret;\r\n    if (n instanceof Name) {\r\n        ret = transformNameAsString((Name) n);\r\n    } else {\r\n        ret = transform(n);\r\n        Preconditions.checkState(ret.getType() == Token.NUMBER || ret.getType() == Token.STRING);\r\n        if (ret.getType() == Token.STRING) {\r\n            ret.putBooleanProp(Node.QUOTED_PROP, true);\r\n        }\r\n    }\r\n    return ret;\r\n}","lc":-0.0454545455,"pi":0.1674641148,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":0.0317460317,"mi":0.0221282593,"fo":0.0833333333,"r":-0.0263157895,"e":0.0073050835}
{"project_name":"Math","project_version":"95","label":3,"code":"\/**\r\n * Access the initial domain value, based on <code>p<\/code>, used to\r\n * bracket a CDF root.  This method is used by\r\n * {@link #inverseCumulativeProbability(double)} to find critical values.\r\n *\r\n * @param p the desired probability for the critical value\r\n * @return initial domain value\r\n *\/\r\nprotected double getInitialDomain(double p) {\r\n    double ret;\r\n    double d = getDenominatorDegreesOfFreedom();\r\n    \/\/ use mean\r\n    ret = d \/ (d - 2.0);\r\n    return ret;\r\n}","code_comment":"\/**\r\n * Access the initial domain value, based on <code>p<\/code>, used to\r\n * bracket a CDF root.  This method is used by\r\n * {@link #inverseCumulativeProbability(double)} to find critical values.\r\n *\r\n * @param p the desired probability for the critical value\r\n * @return initial domain value\r\n *\/\r\n","code_no_comment":"protected double getInitialDomain(double p) {\r\n    double ret;\r\n    double d = getDenominatorDegreesOfFreedom();\r\n        ret = d \/ (d - 2.0);\r\n    return ret;\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.0535714286,"mi":0.5799859056,"fo":-0.4166666667,"r":2.3947368421,"e":-0.126694444}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-835_63a48705","label":3,"code":"\/**\r\n * <p>\r\n * Gets the fraction percentage as a <tt>double<\/tt>. This calculates the\r\n * fraction as the numerator divided by denominator multiplied by 100.\r\n * <\/p>\r\n *\r\n * @return the fraction percentage as a <tt>double<\/tt>.\r\n *\/\r\npublic double percentageValue() {\r\n    return multiply(100).doubleValue();\r\n}","code_comment":"\/**\r\n * <p>\r\n * Gets the fraction percentage as a <tt>double<\/tt>. This calculates the\r\n * fraction as the numerator divided by denominator multiplied by 100.\r\n * <\/p>\r\n *\r\n * @return the fraction percentage as a <tt>double<\/tt>.\r\n *\/\r\n","code_no_comment":"public double percentageValue() {\r\n    return multiply(100).doubleValue();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.3333333333,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3885_beb9086d","label":1,"code":"@Override\r\npublic void sendRedirect(String url) {\r\n    try {\r\n        redirect = true;\r\n        url = getAbsoluteURL(url);\r\n        url = encodeRedirectURL(url);\r\n        \/\/ wicket redirects should never be cached\r\n        disableCaching();\r\n        if (webRequest.isAjax()) {\r\n            httpServletResponse.addHeader(\"Ajax-Location\", url);\r\n            \/*\r\n\t\t\t\t * usually the Ajax-Location header is enough and we do not need to the redirect url\r\n\t\t\t\t * into the response, but sometimes the response is processed via an iframe (eg\r\n\t\t\t\t * using multipart ajax handling) and the headers are not available because XHR is\r\n\t\t\t\t * not used and that is the only way javascript has access to response headers.\r\n\t\t\t\t *\/\r\n            httpServletResponse.getWriter().write(\"<ajax-response><redirect><![CDATA[\" + url + \"]]><\/redirect><\/ajax-response>\");\r\n            setContentType(\"text\/xml;charset=\" + webRequest.getContainerRequest().getCharacterEncoding());\r\n        } else {\r\n            httpServletResponse.sendRedirect(url);\r\n        }\r\n    } catch (IOException e) {\r\n        throw new WicketRuntimeException(e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void sendRedirect(String url) {\r\n    try {\r\n        redirect = true;\r\n        url = getAbsoluteURL(url);\r\n        url = encodeRedirectURL(url);\r\n                disableCaching();\r\n        if (webRequest.isAjax()) {\r\n            httpServletResponse.addHeader(\"Ajax-Location\", url);\r\n                        httpServletResponse.getWriter().write(\"<ajax-response><redirect><![CDATA[\" + url + \"]]><\/redirect><\/ajax-response>\");\r\n            setContentType(\"text\/xml;charset=\" + webRequest.getContainerRequest().getCharacterEncoding());\r\n        } else {\r\n            httpServletResponse.sendRedirect(url);\r\n        }\r\n    } catch (IOException e) {\r\n        throw new WicketRuntimeException(e);\r\n    }\r\n}","lc":0.1818181818,"pi":0.4641148325,"ma":0.0,"nbd":0.0,"ml":-0.25,"d":-0.0753968254,"mi":-0.1498238196,"fo":0.4166666667,"r":-0.0263157895,"e":-0.0235058177}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5687_3d2d8619","label":1,"code":"private List<MavenProject> getProjects(Collection<String> projectIds) {\r\n    List<MavenProject> projects = new ArrayList<MavenProject>(projectIds.size());\r\n    for (String projectId : projectIds) {\r\n        MavenProject project = sorter.getProjectMap().get(projectId);\r\n        if (project != null) {\r\n            projects.add(project);\r\n        }\r\n    }\r\n    return projects;\r\n}","code_comment":null,"code_no_comment":"private List<MavenProject> getProjects(Collection<String> projectIds) {\r\n    List<MavenProject> projects = new ArrayList<MavenProject>(projectIds.size());\r\n    for (String projectId : projectIds) {\r\n        MavenProject project = sorter.getProjectMap().get(projectId);\r\n        if (project != null) {\r\n            projects.add(project);\r\n        }\r\n    }\r\n    return projects;\r\n}","lc":-0.1818181818,"pi":0.2918660287,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.0257936508,"mi":0.1864693446,"fo":-0.1666666667,"r":0.1052631579,"e":-0.0558842344}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4597_9dab1bb5","label":1,"code":"\/**\r\n *  Retrieves the <code>String<\/code> representation of this <code>Duration<\/code> in days,\r\n *  hours, minutes, seconds or milliseconds, as appropriate.\r\n *\r\n *  @param locale\r\n *             a <code>Locale<\/code>\r\n *  @return a <code>String<\/code> representation\r\n *\/\r\npublic String toString(final Locale locale) {\r\n    if (getMilliseconds() >= 0) {\r\n        if (days() >= 1.0) {\r\n            return unitString(days(), \"day\", locale);\r\n        }\r\n        if (hours() >= 1.0) {\r\n            return unitString(hours(), \"hour\", locale);\r\n        }\r\n        if (minutes() >= 1.0) {\r\n            return unitString(minutes(), \"minute\", locale);\r\n        }\r\n        if (seconds() >= 1.0) {\r\n            return unitString(seconds(), \"second\", locale);\r\n        }\r\n        return unitString(seconds(), \"millisecond\", locale);\r\n    } else {\r\n        return \"N\/A\";\r\n    }\r\n}","code_comment":"\/**\r\n *  Retrieves the <code>String<\/code> representation of this <code>Duration<\/code> in days,\r\n *  hours, minutes, seconds or milliseconds, as appropriate.\r\n *\r\n *  @param locale\r\n *             a <code>Locale<\/code>\r\n *  @return a <code>String<\/code> representation\r\n *\/\r\n","code_no_comment":"public String toString(final Locale locale) {\r\n    if (getMilliseconds() >= 0) {\r\n        if (days() >= 1.0) {\r\n            return unitString(days(), \"day\", locale);\r\n        }\r\n        if (hours() >= 1.0) {\r\n            return unitString(hours(), \"hour\", locale);\r\n        }\r\n        if (minutes() >= 1.0) {\r\n            return unitString(minutes(), \"minute\", locale);\r\n        }\r\n        if (seconds() >= 1.0) {\r\n            return unitString(seconds(), \"second\", locale);\r\n        }\r\n        return unitString(seconds(), \"millisecond\", locale);\r\n    } else {\r\n        return \"N\/A\";\r\n    }\r\n}","lc":0.2272727273,"pi":0.2440191388,"ma":0.4,"nbd":0.0,"ml":0.4166666667,"d":-0.3650793651,"mi":-0.1647639183,"fo":0.75,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3156_786b3d76","label":0,"code":"@Override\r\npublic IndexRow next() {\r\n    final IndexRow pathRow = pathCursor.next();\r\n    return new IndexRow() {\r\n\r\n        @Override\r\n        public boolean isVirtualRow() {\r\n            return getPath() == null;\r\n        }\r\n\r\n        @Override\r\n        public String getPath() {\r\n            String sub = pathRow.getPath();\r\n            if (PathUtils.isAbsolute(sub)) {\r\n                return pathPrefix + sub;\r\n            } else {\r\n                return PathUtils.concat(pathPrefix, sub);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public PropertyValue getValue(String columnName) {\r\n            \/\/ overlay the score\r\n            if (QueryImpl.JCR_SCORE.equals(columnName)) {\r\n                return PropertyValues.newDouble(currentRow.score);\r\n            }\r\n            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {\r\n                return PropertyValues.newString(Iterables.toString(currentRow.suggestWords));\r\n            }\r\n            return pathRow.getValue(columnName);\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic IndexRow next() {\r\n    final IndexRow pathRow = pathCursor.next();\r\n    return new IndexRow() {\r\n\r\n        @Override\r\n        public boolean isVirtualRow() {\r\n            return getPath() == null;\r\n        }\r\n\r\n        @Override\r\n        public String getPath() {\r\n            String sub = pathRow.getPath();\r\n            if (PathUtils.isAbsolute(sub)) {\r\n                return pathPrefix + sub;\r\n            } else {\r\n                return PathUtils.concat(pathPrefix, sub);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public PropertyValue getValue(String columnName) {\r\n                        if (QueryImpl.JCR_SCORE.equals(columnName)) {\r\n                return PropertyValues.newDouble(currentRow.score);\r\n            }\r\n            if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {\r\n                return PropertyValues.newString(Iterables.toString(currentRow.suggestWords));\r\n            }\r\n            return pathRow.getValue(columnName);\r\n        }\r\n    };\r\n}","lc":0.6818181818,"pi":0.7655502392,"ma":0.0,"nbd":0.0,"ml":0.4166666667,"d":0.3908730159,"mi":-0.4353770261,"fo":0.5,"r":0.0,"e":0.4132962201}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7568_b3377b16","label":3,"code":"\/**\r\n * Processes the exchange by the processors\r\n *\r\n * @param processor the processor\r\n * @param exchange the exchange\r\n *\/\r\nprotected static void doProcess(Processor processor, Exchange exchange) {\r\n    \/\/ must remember some properties which we cannot use during onCompletion processing\r\n    \/\/ as otherwise we may cause issues\r\n    Object stop = exchange.removeProperty(Exchange.ROUTE_STOP);\r\n    Object failureHandled = exchange.removeProperty(Exchange.FAILURE_HANDLED);\r\n    Object caught = exchange.removeProperty(Exchange.EXCEPTION_CAUGHT);\r\n    Object errorhandlerHandled = exchange.removeProperty(Exchange.ERRORHANDLER_HANDLED);\r\n    Exception cause = exchange.getException();\r\n    exchange.setException(null);\r\n    try {\r\n        processor.process(exchange);\r\n    } catch (Exception e) {\r\n        exchange.setException(e);\r\n    } finally {\r\n        \/\/ restore the options\r\n        if (stop != null) {\r\n            exchange.setProperty(Exchange.ROUTE_STOP, stop);\r\n        }\r\n        if (failureHandled != null) {\r\n            exchange.setProperty(Exchange.FAILURE_HANDLED, failureHandled);\r\n        }\r\n        if (caught != null) {\r\n            exchange.setProperty(Exchange.EXCEPTION_CAUGHT, caught);\r\n        }\r\n        if (errorhandlerHandled != null) {\r\n            exchange.setProperty(Exchange.ERRORHANDLER_HANDLED, errorhandlerHandled);\r\n        }\r\n        if (cause != null) {\r\n            exchange.setException(cause);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Processes the exchange by the processors\r\n *\r\n * @param processor the processor\r\n * @param exchange the exchange\r\n *\/\r\n","code_no_comment":"protected static void doProcess(Processor processor, Exchange exchange) {\r\n            Object stop = exchange.removeProperty(Exchange.ROUTE_STOP);\r\n    Object failureHandled = exchange.removeProperty(Exchange.FAILURE_HANDLED);\r\n    Object caught = exchange.removeProperty(Exchange.EXCEPTION_CAUGHT);\r\n    Object errorhandlerHandled = exchange.removeProperty(Exchange.ERRORHANDLER_HANDLED);\r\n    Exception cause = exchange.getException();\r\n    exchange.setException(null);\r\n    try {\r\n        processor.process(exchange);\r\n    } catch (Exception e) {\r\n        exchange.setException(e);\r\n    } finally {\r\n                if (stop != null) {\r\n            exchange.setProperty(Exchange.ROUTE_STOP, stop);\r\n        }\r\n        if (failureHandled != null) {\r\n            exchange.setProperty(Exchange.FAILURE_HANDLED, failureHandled);\r\n        }\r\n        if (caught != null) {\r\n            exchange.setProperty(Exchange.EXCEPTION_CAUGHT, caught);\r\n        }\r\n        if (errorhandlerHandled != null) {\r\n            exchange.setProperty(Exchange.ERRORHANDLER_HANDLED, errorhandlerHandled);\r\n        }\r\n        if (cause != null) {\r\n            exchange.setException(cause);\r\n        }\r\n    }\r\n}","lc":0.6818181818,"pi":0.1674641148,"ma":0.6,"nbd":0.0,"ml":0.4166666667,"d":0.2797619048,"mi":-0.4886539817,"fo":0.5833333333,"r":-0.0263157895,"e":0.4569884108}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4109_8f7805f8","label":1,"code":"\/**\r\n *  Looks up a page by id from the {@link IPageStore}. <br\/>\r\n *  If {@linkplain #pageClass} is specified then compares it against the stored instance class\r\n *  and returns the found instance only if they match.\r\n *\r\n *  @param pageId\r\n *             the id of the page to look for.\r\n *  @return the found page instance by id.\r\n *\/\r\nprivate IRequestablePage getStoredPage(final int pageId) {\r\n    IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);\r\n    if (storedPageInstance != null && (pageClass == null || pageClass.equals(storedPageInstance.getClass()))) {\r\n        pageInstance = storedPageInstance;\r\n        if (pageParameters != null) {\r\n            storedPageInstance.getPageParameters().overwriteWith(pageParameters);\r\n        }\r\n    }\r\n    return storedPageInstance;\r\n}","code_comment":"\/**\r\n *  Looks up a page by id from the {@link IPageStore}. <br\/>\r\n *  If {@linkplain #pageClass} is specified then compares it against the stored instance class\r\n *  and returns the found instance only if they match.\r\n *\r\n *  @param pageId\r\n *             the id of the page to look for.\r\n *  @return the found page instance by id.\r\n *\/\r\n","code_no_comment":"private IRequestablePage getStoredPage(final int pageId) {\r\n    IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);\r\n    if (storedPageInstance != null && (pageClass == null || pageClass.equals(storedPageInstance.getClass()))) {\r\n        pageInstance = storedPageInstance;\r\n        if (pageParameters != null) {\r\n            storedPageInstance.getPageParameters().overwriteWith(pageParameters);\r\n        }\r\n    }\r\n    return storedPageInstance;\r\n}","lc":-0.1818181818,"pi":0.2918660287,"ma":-0.2,"nbd":0.0,"ml":0.3333333333,"d":0.3234126984,"mi":0.1797040169,"fo":0.0,"r":0.8157894737,"e":0.0651556278}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Sets the element at the specified index.  If the specified index is greater than\r\n * <code>getNumElements() - 1<\/code>, the <code>numElements<\/code> property\r\n * is increased to <code>index +1<\/code> and additional storage is allocated\r\n * (if necessary) for the new element and all  (uninitialized) elements\r\n * between the new element and the previous end of the array).\r\n *\r\n * @param index index to store a value in\r\n * @param value value to store at the specified index\r\n * @throws ArrayIndexOutOfBoundsException if {@code index < 0}.\r\n *\/\r\n@Override\r\npublic synchronized void setElement(int index, double value) {\r\n    if (index < 0) {\r\n        throw new ArrayIndexOutOfBoundsException(index);\r\n    }\r\n    if (index + 1 > numElements) {\r\n        numElements = index + 1;\r\n    }\r\n    if ((startIndex + index) >= internalArray.length) {\r\n        expandTo(startIndex + (index + 1));\r\n    }\r\n    internalArray[startIndex + index] = value;\r\n}","code_comment":"\/**\r\n * Sets the element at the specified index.  If the specified index is greater than\r\n * <code>getNumElements() - 1<\/code>, the <code>numElements<\/code> property\r\n * is increased to <code>index +1<\/code> and additional storage is allocated\r\n * (if necessary) for the new element and all  (uninitialized) elements\r\n * between the new element and the previous end of the array).\r\n *\r\n * @param index index to store a value in\r\n * @param value value to store at the specified index\r\n * @throws ArrayIndexOutOfBoundsException if {@code index < 0}.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic synchronized void setElement(int index, double value) {\r\n    if (index < 0) {\r\n        throw new ArrayIndexOutOfBoundsException(index);\r\n    }\r\n    if (index + 1 > numElements) {\r\n        numElements = index + 1;\r\n    }\r\n    if ((startIndex + index) >= internalArray.length) {\r\n        expandTo(startIndex + (index + 1));\r\n    }\r\n    internalArray[startIndex + index] = value;\r\n}","lc":-0.0454545455,"pi":-0.1291866029,"ma":0.2,"nbd":-0.5,"ml":0.1666666667,"d":0.4583333333,"mi":0.0314305849,"fo":-0.4166666667,"r":-0.0263157895,"e":0.1406637737}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-178_2f0643a9","label":3,"code":"protected Key buildDocKey() {\r\n    if (log.isTraceEnabled())\r\n        log.trace(\"building doc key for \" + currentPartition + \" \" + currentDocID);\r\n    int zeroIndex = currentDocID.find(\"\\0\");\r\n    if (zeroIndex < 0)\r\n        throw new IllegalArgumentException(\"bad current docID\");\r\n    Text colf = new Text(docColf);\r\n    colf.append(nullByte, 0, 1);\r\n    colf.append(currentDocID.getBytes(), 0, zeroIndex);\r\n    docColfSet = Collections.singleton((ByteSequence) new ArrayByteSequence(colf.getBytes(), 0, colf.getLength()));\r\n    if (log.isTraceEnabled())\r\n        log.trace(zeroIndex + \" \" + currentDocID.getLength());\r\n    Text colq = new Text();\r\n    colq.set(currentDocID.getBytes(), zeroIndex + 1, currentDocID.getLength() - zeroIndex - 2);\r\n    Key k = new Key(currentPartition, colf, colq);\r\n    if (log.isTraceEnabled())\r\n        log.trace(\"built doc key for seek: \" + k.toString());\r\n    return k;\r\n}","code_comment":null,"code_no_comment":"protected Key buildDocKey() {\r\n    if (log.isTraceEnabled())\r\n        log.trace(\"building doc key for \" + currentPartition + \" \" + currentDocID);\r\n    int zeroIndex = currentDocID.find(\"\\0\");\r\n    if (zeroIndex < 0)\r\n        throw new IllegalArgumentException(\"bad current docID\");\r\n    Text colf = new Text(docColf);\r\n    colf.append(nullByte, 0, 1);\r\n    colf.append(currentDocID.getBytes(), 0, zeroIndex);\r\n    docColfSet = Collections.singleton((ByteSequence) new ArrayByteSequence(colf.getBytes(), 0, colf.getLength()));\r\n    if (log.isTraceEnabled())\r\n        log.trace(zeroIndex + \" \" + currentDocID.getLength());\r\n    Text colq = new Text();\r\n    colq.set(currentDocID.getBytes(), zeroIndex + 1, currentDocID.getLength() - zeroIndex - 2);\r\n    Key k = new Key(currentPartition, colf, colq);\r\n    if (log.isTraceEnabled())\r\n        log.trace(\"built doc key for seek: \" + k.toString());\r\n    return k;\r\n}","lc":0.2272727273,"pi":-0.3732057416,"ma":0.4,"nbd":-1.0,"ml":0.0833333333,"d":0.5297619048,"mi":-0.3096546864,"fo":1.0,"r":-0.0263157895,"e":0.8272217516}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Short reusable) {\r\n    int val = 0;\r\n    boolean neg = false;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    if (bytes[startPos] == '-') {\r\n        neg = true;\r\n        startPos++;\r\n        \/\/ check for empty field with only the sign\r\n        if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\r\n            return -1;\r\n        }\r\n    }\r\n    for (int i = startPos; i < limit; i++) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            this.result = (short) (neg ? -val : val);\r\n            return i + delimiter.length;\r\n        }\r\n        if (bytes[i] < 48 || bytes[i] > 57) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\r\n            return -1;\r\n        }\r\n        val *= 10;\r\n        val += bytes[i] - 48;\r\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\r\n            return -1;\r\n        }\r\n    }\r\n    this.result = (short) (neg ? -val : val);\r\n    return limit;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Short reusable) {\r\n    int val = 0;\r\n    boolean neg = false;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    if (bytes[startPos] == '-') {\r\n        neg = true;\r\n        startPos++;\r\n                if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\r\n            return -1;\r\n        }\r\n    }\r\n    for (int i = startPos; i < limit; i++) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            this.result = (short) (neg ? -val : val);\r\n            return i + delimiter.length;\r\n        }\r\n        if (bytes[i] < 48 || bytes[i] > 57) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\r\n            return -1;\r\n        }\r\n        val *= 10;\r\n        val += bytes[i] - 48;\r\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\r\n            return -1;\r\n        }\r\n    }\r\n    this.result = (short) (neg ? -val : val);\r\n    return limit;\r\n}","lc":0.8181818182,"pi":0.3444976077,"ma":1.0,"nbd":0.0,"ml":1.5833333333,"d":2.8611111111,"mi":-0.6129668781,"fo":-0.0833333333,"r":-0.0263157895,"e":4.7179290353}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2434_8159fc21","label":1,"code":"static Query getFullTextQuery(final IndexPlan plan, FullTextExpression ft, final Analyzer analyzer) {\r\n    final PlanResult pr = pr(plan);\r\n    \/\/ a reference to the query, so it can be set in the visitor\r\n    \/\/ (a \"non-local return\")\r\n    final AtomicReference<Query> result = new AtomicReference<Query>();\r\n    ft.accept(new FullTextVisitor() {\r\n\r\n        @Override\r\n        public boolean visit(FullTextContains contains) {\r\n            visitTerm(contains.getPropertyName(), contains.getRawText(), null, false);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean visit(FullTextOr or) {\r\n            BooleanQuery q = new BooleanQuery();\r\n            for (FullTextExpression e : or.list) {\r\n                Query x = getFullTextQuery(plan, e, analyzer);\r\n                q.add(x, SHOULD);\r\n            }\r\n            result.set(q);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean visit(FullTextAnd and) {\r\n            BooleanQuery q = new BooleanQuery();\r\n            for (FullTextExpression e : and.list) {\r\n                Query x = getFullTextQuery(plan, e, analyzer);\r\n                \/\/ Lucene can't deal with \"must(must_not(x))\"\r\n                if (x instanceof BooleanQuery) {\r\n                    BooleanQuery bq = (BooleanQuery) x;\r\n                    for (BooleanClause c : bq.clauses()) {\r\n                        q.add(c);\r\n                    }\r\n                } else {\r\n                    q.add(x, MUST);\r\n                }\r\n            }\r\n            result.set(q);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean visit(FullTextTerm term) {\r\n            return visitTerm(term.getPropertyName(), term.getText(), term.getBoost(), term.isNot());\r\n        }\r\n\r\n        private boolean visitTerm(String propertyName, String text, String boost, boolean not) {\r\n            String p = getLuceneFieldName(propertyName, pr);\r\n            Query q = tokenToQuery(text, p, analyzer);\r\n            if (q == null) {\r\n                return false;\r\n            }\r\n            if (boost != null) {\r\n                q.setBoost(Float.parseFloat(boost));\r\n            }\r\n            if (not) {\r\n                BooleanQuery bq = new BooleanQuery();\r\n                bq.add(q, MUST_NOT);\r\n                result.set(bq);\r\n            } else {\r\n                result.set(q);\r\n            }\r\n            return true;\r\n        }\r\n    });\r\n    return result.get();\r\n}","code_comment":null,"code_no_comment":"static Query getFullTextQuery(final IndexPlan plan, FullTextExpression ft, final Analyzer analyzer) {\r\n    final PlanResult pr = pr(plan);\r\n            final AtomicReference<Query> result = new AtomicReference<Query>();\r\n    ft.accept(new FullTextVisitor() {\r\n\r\n        @Override\r\n        public boolean visit(FullTextContains contains) {\r\n            visitTerm(contains.getPropertyName(), contains.getRawText(), null, false);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean visit(FullTextOr or) {\r\n            BooleanQuery q = new BooleanQuery();\r\n            for (FullTextExpression e : or.list) {\r\n                Query x = getFullTextQuery(plan, e, analyzer);\r\n                q.add(x, SHOULD);\r\n            }\r\n            result.set(q);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean visit(FullTextAnd and) {\r\n            BooleanQuery q = new BooleanQuery();\r\n            for (FullTextExpression e : and.list) {\r\n                Query x = getFullTextQuery(plan, e, analyzer);\r\n                                if (x instanceof BooleanQuery) {\r\n                    BooleanQuery bq = (BooleanQuery) x;\r\n                    for (BooleanClause c : bq.clauses()) {\r\n                        q.add(c);\r\n                    }\r\n                } else {\r\n                    q.add(x, MUST);\r\n                }\r\n            }\r\n            result.set(q);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean visit(FullTextTerm term) {\r\n            return visitTerm(term.getPropertyName(), term.getText(), term.getBoost(), term.isNot());\r\n        }\r\n\r\n        private boolean visitTerm(String propertyName, String text, String boost, boolean not) {\r\n            String p = getLuceneFieldName(propertyName, pr);\r\n            Query q = tokenToQuery(text, p, analyzer);\r\n            if (q == null) {\r\n                return false;\r\n            }\r\n            if (boost != null) {\r\n                q.setBoost(Float.parseFloat(boost));\r\n            }\r\n            if (not) {\r\n                BooleanQuery bq = new BooleanQuery();\r\n                bq.add(q, MUST_NOT);\r\n                result.set(bq);\r\n            } else {\r\n                result.set(q);\r\n            }\r\n            return true;\r\n        }\r\n    });\r\n    return result.get();\r\n}","lc":2.1363636364,"pi":0.8708133971,"ma":0.8,"nbd":1.0,"ml":0.25,"d":0.1468253968,"mi":-0.9639182523,"fo":1.6666666667,"r":-0.0263157895,"e":1.0260749295}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1111_459bd065","label":0,"code":"private org.apache.jackrabbit.oak.api.PropertyState getProperty(String name, InternalValue value, int type) throws RepositoryException, IOException {\r\n    switch(type) {\r\n        case PropertyType.BINARY:\r\n            return PropertyStates.createProperty(name, store.createBlob(value.getStream()), Type.BINARY);\r\n        case PropertyType.BOOLEAN:\r\n            return PropertyStates.createProperty(name, value.getBoolean(), Type.BOOLEAN);\r\n        case PropertyType.DATE:\r\n            return PropertyStates.createProperty(name, value.getCalendar().getTimeInMillis(), Type.DATE);\r\n        case PropertyType.DECIMAL:\r\n            return PropertyStates.createProperty(name, value.getDecimal(), Type.DECIMAL);\r\n        case PropertyType.DOUBLE:\r\n            return PropertyStates.createProperty(name, value.getDouble(), Type.DOUBLE);\r\n        case PropertyType.LONG:\r\n            return PropertyStates.createProperty(name, value.getLong(), Type.LONG);\r\n        case PropertyType.NAME:\r\n            return PropertyStates.createProperty(name, getOakName(value.getName()), Type.NAME);\r\n        case PropertyType.PATH:\r\n            return PropertyStates.createProperty(name, getOakPath(value.getPath()), Type.PATH);\r\n        case PropertyType.REFERENCE:\r\n            return PropertyStates.createProperty(name, value.getNodeId().toString(), Type.REFERENCE);\r\n        case PropertyType.STRING:\r\n            return PropertyStates.createProperty(name, value.getString(), Type.STRING);\r\n        case PropertyType.URI:\r\n            return PropertyStates.createProperty(name, value.getURI().toString(), Type.URI);\r\n        case PropertyType.WEAKREFERENCE:\r\n            return PropertyStates.createProperty(name, value.getNodeId().toString(), Type.WEAKREFERENCE);\r\n        default:\r\n            throw new RepositoryException(\"Unknown value type: \" + type);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private org.apache.jackrabbit.oak.api.PropertyState getProperty(String name, InternalValue value, int type) throws RepositoryException, IOException {\r\n    switch(type) {\r\n        case PropertyType.BINARY:\r\n            return PropertyStates.createProperty(name, store.createBlob(value.getStream()), Type.BINARY);\r\n        case PropertyType.BOOLEAN:\r\n            return PropertyStates.createProperty(name, value.getBoolean(), Type.BOOLEAN);\r\n        case PropertyType.DATE:\r\n            return PropertyStates.createProperty(name, value.getCalendar().getTimeInMillis(), Type.DATE);\r\n        case PropertyType.DECIMAL:\r\n            return PropertyStates.createProperty(name, value.getDecimal(), Type.DECIMAL);\r\n        case PropertyType.DOUBLE:\r\n            return PropertyStates.createProperty(name, value.getDouble(), Type.DOUBLE);\r\n        case PropertyType.LONG:\r\n            return PropertyStates.createProperty(name, value.getLong(), Type.LONG);\r\n        case PropertyType.NAME:\r\n            return PropertyStates.createProperty(name, getOakName(value.getName()), Type.NAME);\r\n        case PropertyType.PATH:\r\n            return PropertyStates.createProperty(name, getOakPath(value.getPath()), Type.PATH);\r\n        case PropertyType.REFERENCE:\r\n            return PropertyStates.createProperty(name, value.getNodeId().toString(), Type.REFERENCE);\r\n        case PropertyType.STRING:\r\n            return PropertyStates.createProperty(name, value.getString(), Type.STRING);\r\n        case PropertyType.URI:\r\n            return PropertyStates.createProperty(name, value.getURI().toString(), Type.URI);\r\n        case PropertyType.WEAKREFERENCE:\r\n            return PropertyStates.createProperty(name, value.getNodeId().toString(), Type.WEAKREFERENCE);\r\n        default:\r\n            throw new RepositoryException(\"Unknown value type: \" + type);\r\n    }\r\n}","lc":0.7272727273,"pi":0.1866028708,"ma":2.2,"nbd":0.0,"ml":0.6666666667,"d":-0.3650793651,"mi":-0.6465116279,"fo":2.0833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-579_7d72e6ed","label":3,"code":"@Override\r\npublic void restrict(FilterImpl f) {\r\n    if (f.getSelector() == selector1) {\r\n        String p2 = selector2.currentPath();\r\n        if (p2 != null) {\r\n            if (selector2Path.equals(\".\")) {\r\n                f.restrictPath(p2, Filter.PathRestriction.EXACT);\r\n            } else {\r\n                \/\/ TODO normalize paths; support more complex relative path (\"..\" and so on)\r\n                String p = PathUtils.concat(p2, selector2Path);\r\n                f.restrictPath(p, Filter.PathRestriction.EXACT);\r\n            }\r\n        }\r\n    }\r\n    if (f.getSelector() == selector2) {\r\n        String p1 = selector1.currentPath();\r\n        if (p1 != null) {\r\n            if (selector2Path.equals(\".\")) {\r\n                f.restrictPath(p1, Filter.PathRestriction.EXACT);\r\n            } else {\r\n            \/\/ TODO normalize paths; support relative path (\"..\" and so on)\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void restrict(FilterImpl f) {\r\n    if (f.getSelector() == selector1) {\r\n        String p2 = selector2.currentPath();\r\n        if (p2 != null) {\r\n            if (selector2Path.equals(\".\")) {\r\n                f.restrictPath(p2, Filter.PathRestriction.EXACT);\r\n            } else {\r\n                                String p = PathUtils.concat(p2, selector2Path);\r\n                f.restrictPath(p, Filter.PathRestriction.EXACT);\r\n            }\r\n        }\r\n    }\r\n    if (f.getSelector() == selector2) {\r\n        String p1 = selector1.currentPath();\r\n        if (p1 != null) {\r\n            if (selector2Path.equals(\".\")) {\r\n                f.restrictPath(p1, Filter.PathRestriction.EXACT);\r\n            } else {\r\n                        }\r\n        }\r\n    }\r\n}","lc":0.4090909091,"pi":1.004784689,"ma":0.6,"nbd":0.5,"ml":0.5833333333,"d":0.0912698413,"mi":-0.3265680056,"fo":0.3333333333,"r":0.0,"e":0.1368279709}
{"project_name":"Closure","project_version":"52","label":2,"code":"static boolean isSimpleNumber(String s) {\r\n    int len = s.length();\r\n    for (int index = 0; index < len; index++) {\r\n        char c = s.charAt(index);\r\n        if (c < '0' || c > '9') {\r\n            return false;\r\n        }\r\n    }\r\n    return len > 0;\r\n}","code_comment":null,"code_no_comment":"static boolean isSimpleNumber(String s) {\r\n    int len = s.length();\r\n    for (int index = 0; index < len; index++) {\r\n        char c = s.charAt(index);\r\n        if (c < '0' || c > '9') {\r\n            return false;\r\n        }\r\n    }\r\n    return len > 0;\r\n}","lc":-0.1818181818,"pi":0.2918660287,"ma":-0.2,"nbd":0.0,"ml":0.0833333333,"d":0.3948412698,"mi":0.1923890063,"fo":-0.3333333333,"r":0.7105263158,"e":0.0683690347}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1822_016df669","label":1,"code":"@Override\r\npublic <T extends Document> boolean create(Collection<T> collection, List<UpdateOp> updateOps) {\r\n    log(\"create\", updateOps);\r\n    List<T> docs = new ArrayList<T>();\r\n    DBObject[] inserts = new DBObject[updateOps.size()];\r\n    for (int i = 0; i < updateOps.size(); i++) {\r\n        inserts[i] = new BasicDBObject();\r\n        UpdateOp update = updateOps.get(i);\r\n        T target = collection.newDocument(this);\r\n        UpdateUtils.applyChanges(target, update, comparator);\r\n        docs.add(target);\r\n        for (Entry<Key, Operation> entry : update.getChanges().entrySet()) {\r\n            Key k = entry.getKey();\r\n            Operation op = entry.getValue();\r\n            switch(op.type) {\r\n                case SET:\r\n                case INCREMENT:\r\n                    {\r\n                        inserts[i].put(k.toString(), op.value);\r\n                        break;\r\n                    }\r\n                case SET_MAP_ENTRY:\r\n                    {\r\n                        Revision r = k.getRevision();\r\n                        if (r == null) {\r\n                            throw new IllegalStateException(\"SET_MAP_ENTRY must not have null revision\");\r\n                        }\r\n                        DBObject value = new RevisionEntry(r, op.value);\r\n                        inserts[i].put(k.getName(), value);\r\n                        break;\r\n                    }\r\n                case REMOVE_MAP_ENTRY:\r\n                    \/\/ nothing to do for new entries\r\n                    break;\r\n                case CONTAINS_MAP_ENTRY:\r\n                    \/\/ no effect\r\n                    break;\r\n            }\r\n        }\r\n        if (!inserts[i].containsField(Document.MOD_COUNT)) {\r\n            inserts[i].put(Document.MOD_COUNT, 1L);\r\n            target.put(Document.MOD_COUNT, 1L);\r\n        }\r\n    }\r\n    DBCollection dbCollection = getDBCollection(collection);\r\n    long start = start();\r\n    try {\r\n        try {\r\n            WriteResult writeResult = dbCollection.insert(inserts, WriteConcern.SAFE);\r\n            if (writeResult.getError() != null) {\r\n                return false;\r\n            }\r\n            if (collection == Collection.NODES) {\r\n                for (T doc : docs) {\r\n                    Lock lock = getAndLock(doc.getId());\r\n                    try {\r\n                        addToCache((NodeDocument) doc);\r\n                    } finally {\r\n                        lock.unlock();\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        } catch (MongoException e) {\r\n            return false;\r\n        }\r\n    } finally {\r\n        end(\"create\", start);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic <T extends Document> boolean create(Collection<T> collection, List<UpdateOp> updateOps) {\r\n    log(\"create\", updateOps);\r\n    List<T> docs = new ArrayList<T>();\r\n    DBObject[] inserts = new DBObject[updateOps.size()];\r\n    for (int i = 0; i < updateOps.size(); i++) {\r\n        inserts[i] = new BasicDBObject();\r\n        UpdateOp update = updateOps.get(i);\r\n        T target = collection.newDocument(this);\r\n        UpdateUtils.applyChanges(target, update, comparator);\r\n        docs.add(target);\r\n        for (Entry<Key, Operation> entry : update.getChanges().entrySet()) {\r\n            Key k = entry.getKey();\r\n            Operation op = entry.getValue();\r\n            switch(op.type) {\r\n                case SET:\r\n                case INCREMENT:\r\n                    {\r\n                        inserts[i].put(k.toString(), op.value);\r\n                        break;\r\n                    }\r\n                case SET_MAP_ENTRY:\r\n                    {\r\n                        Revision r = k.getRevision();\r\n                        if (r == null) {\r\n                            throw new IllegalStateException(\"SET_MAP_ENTRY must not have null revision\");\r\n                        }\r\n                        DBObject value = new RevisionEntry(r, op.value);\r\n                        inserts[i].put(k.getName(), value);\r\n                        break;\r\n                    }\r\n                case REMOVE_MAP_ENTRY:\r\n                                        break;\r\n                case CONTAINS_MAP_ENTRY:\r\n                                        break;\r\n            }\r\n        }\r\n        if (!inserts[i].containsField(Document.MOD_COUNT)) {\r\n            inserts[i].put(Document.MOD_COUNT, 1L);\r\n            target.put(Document.MOD_COUNT, 1L);\r\n        }\r\n    }\r\n    DBCollection dbCollection = getDBCollection(collection);\r\n    long start = start();\r\n    try {\r\n        try {\r\n            WriteResult writeResult = dbCollection.insert(inserts, WriteConcern.SAFE);\r\n            if (writeResult.getError() != null) {\r\n                return false;\r\n            }\r\n            if (collection == Collection.NODES) {\r\n                for (T doc : docs) {\r\n                    Lock lock = getAndLock(doc.getId());\r\n                    try {\r\n                        addToCache((NodeDocument) doc);\r\n                    } finally {\r\n                        lock.unlock();\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        } catch (MongoException e) {\r\n            return false;\r\n        }\r\n    } finally {\r\n        end(\"create\", start);\r\n    }\r\n}","lc":2.4545454545,"pi":2.0765550239,"ma":3.0,"nbd":1.5,"ml":1.0,"d":0.7738095238,"mi":-1.10260747,"fo":1.8333333333,"r":-0.0263157895,"e":2.8213735355}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3324_5f863af6","label":1,"code":"@Override\r\npublic boolean isGranted(long permissions, @Nonnull PropertyState property) {\r\n    return hasPermissions(getIterator(property, permissions), permissions, tree.getPath());\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean isGranted(long permissions, @Nonnull PropertyState property) {\r\n    return hasPermissions(getIterator(property, permissions), permissions, tree.getPath());\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.769415081,"fo":-0.25,"r":0.0,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3123_f3c9c818","label":1,"code":"\/**\r\n * Associates {@code key} with {@code value} if not already present\r\n * @param key\r\n * @param value\r\n * @return  {@code true} if added, {@code false} if already present\r\n *\/\r\npublic boolean put(short key, @Nonnull RecordId value) {\r\n    if (keys == null) {\r\n        keys = new short[1];\r\n        values = new RecordId[1];\r\n        keys[0] = key;\r\n        values[0] = value;\r\n        return true;\r\n    } else {\r\n        int k = binarySearch(keys, key);\r\n        if (k < 0) {\r\n            int l = -k - 1;\r\n            short[] newKeys = new short[keys.length + 1];\r\n            RecordId[] newValues = new RecordId[(values.length + 1)];\r\n            arraycopy(keys, 0, newKeys, 0, l);\r\n            arraycopy(values, 0, newValues, 0, l);\r\n            newKeys[l] = key;\r\n            newValues[l] = value;\r\n            int c = keys.length - l;\r\n            if (c > 0) {\r\n                arraycopy(keys, l, newKeys, l + 1, c);\r\n                arraycopy(values, l, newValues, l + 1, c);\r\n            }\r\n            keys = newKeys;\r\n            values = newValues;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Associates {@code key} with {@code value} if not already present\r\n * @param key\r\n * @param value\r\n * @return  {@code true} if added, {@code false} if already present\r\n *\/\r\n","code_no_comment":"public boolean put(short key, @Nonnull RecordId value) {\r\n    if (keys == null) {\r\n        keys = new short[1];\r\n        values = new RecordId[1];\r\n        keys[0] = key;\r\n        values[0] = value;\r\n        return true;\r\n    } else {\r\n        int k = binarySearch(keys, key);\r\n        if (k < 0) {\r\n            int l = -k - 1;\r\n            short[] newKeys = new short[keys.length + 1];\r\n            RecordId[] newValues = new RecordId[(values.length + 1)];\r\n            arraycopy(keys, 0, newKeys, 0, l);\r\n            arraycopy(values, 0, newValues, 0, l);\r\n            newKeys[l] = key;\r\n            newValues[l] = value;\r\n            int c = keys.length - l;\r\n            if (c > 0) {\r\n                arraycopy(keys, l, newKeys, l + 1, c);\r\n                arraycopy(values, l, newValues, l + 1, c);\r\n            }\r\n            keys = newKeys;\r\n            values = newValues;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}","lc":0.7272727273,"pi":0.4497607656,"ma":0.0,"nbd":0.5,"ml":0.0833333333,"d":1.9880952381,"mi":-0.5137420719,"fo":-0.0833333333,"r":-0.0263157895,"e":2.5924425004}
{"project_name":"Math","project_version":"105","label":1,"code":"\/**\r\n * Returns the <a href=\"http:\/\/www.xycoon.com\/SumOfSquares.htm\">\r\n * sum of squared errors<\/a> (SSE) associated with the regression\r\n * model.\r\n * <p>\r\n * The sum is computed using the computational formula\r\n * <p>\r\n * <code>SSE = SYY - (SXY * SXY \/ SXX)<\/code>\r\n * <p>\r\n * where <code>SYY<\/code> is the sum of the squared deviations of the y\r\n * values about their mean, <code>SXX<\/code> is similarly defined and\r\n * <code>SXY<\/code> is the sum of the products of x and y mean deviations.\r\n * <p>\r\n * The sums are accumulated using the updating algorithm referenced in\r\n * {@link #addData}.\r\n * <p>\r\n * The return value is constrained to be non-negative - i.e., if due to\r\n * rounding errors the computational formula returns a negative result,\r\n * 0 is returned.\r\n * <p>\r\n * <strong>Preconditions<\/strong>: <ul>\r\n * <li>At least two observations (with at least two different x values)\r\n * must have been added before invoking this method. If this method is\r\n * invoked before a model can be estimated, <code>Double,NaN<\/code> is\r\n * returned.\r\n * <\/li><\/ul>\r\n *\r\n * @return sum of squared errors associated with the regression model\r\n *\/\r\npublic double getSumSquaredErrors() {\r\n    return sumYY - sumXY * sumXY \/ sumXX;\r\n}","code_comment":"\/**\r\n * Returns the <a href=\"http:\/\/www.xycoon.com\/SumOfSquares.htm\">\r\n * sum of squared errors<\/a> (SSE) associated with the regression\r\n * model.\r\n * <p>\r\n * The sum is computed using the computational formula\r\n * <p>\r\n * <code>SSE = SYY - (SXY * SXY \/ SXX)<\/code>\r\n * <p>\r\n * where <code>SYY<\/code> is the sum of the squared deviations of the y\r\n * values about their mean, <code>SXX<\/code> is similarly defined and\r\n * <code>SXY<\/code> is the sum of the products of x and y mean deviations.\r\n * <p>\r\n * The sums are accumulated using the updating algorithm referenced in\r\n * {@link #addData}.\r\n * <p>\r\n * The return value is constrained to be non-negative - i.e., if due to\r\n * rounding errors the computational formula returns a negative result,\r\n * 0 is returned.\r\n * <p>\r\n * <strong>Preconditions<\/strong>: <ul>\r\n * <li>At least two observations (with at least two different x values)\r\n * must have been added before invoking this method. If this method is\r\n * invoked before a model can be estimated, <code>Double,NaN<\/code> is\r\n * returned.\r\n * <\/li><\/ul>\r\n *\r\n * @return sum of squared errors associated with the regression model\r\n *\/\r\n","code_no_comment":"public double getSumSquaredErrors() {\r\n    return sumYY - sumXY * sumXY \/ sumXX;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.126984127,"mi":0.986187456,"fo":-0.5,"r":0.0,"e":-0.1478559038}
{"project_name":"Cli","project_version":"22","label":1,"code":"\/**\r\n * Breaks <code>token<\/code> into its constituent parts\r\n * using the following algorithm.\r\n *\r\n * <ul>\r\n *  <li>ignore the first character (\"<b>-<\/b>\")<\/li>\r\n *  <li>foreach remaining character check if an {@link Option}\r\n *  exists with that id.<\/li>\r\n *  <li>if an {@link Option} does exist then add that character\r\n *  prepended with \"<b>-<\/b>\" to the list of processed tokens.<\/li>\r\n *  <li>if the {@link Option} can have an argument value and there\r\n *  are remaining characters in the token then add the remaining\r\n *  characters as a token to the list of processed tokens.<\/li>\r\n *  <li>if an {@link Option} does <b>NOT<\/b> exist <b>AND<\/b>\r\n *  <code>stopAtNonOption<\/code> <b>IS<\/b> set then add the special token\r\n *  \"<b>--<\/b>\" followed by the remaining characters and also\r\n *  the remaining tokens directly to the processed tokens list.<\/li>\r\n *  <li>if an {@link Option} does <b>NOT<\/b> exist <b>AND<\/b>\r\n *  <code>stopAtNonOption<\/code> <b>IS NOT<\/b> set then add that\r\n *  character prepended with \"<b>-<\/b>\".<\/li>\r\n * <\/ul>\r\n *\r\n * @param token The current token to be <b>burst<\/b>\r\n * @param stopAtNonOption Specifies whether to stop processing\r\n * at the first non-Option encountered.\r\n *\/\r\nprotected void burstToken(String token, boolean stopAtNonOption) {\r\n    Option currentOption;\r\n    for (int i = 1; i < token.length(); i++) {\r\n        String ch = String.valueOf(token.charAt(i));\r\n        if (options.hasOption(ch)) {\r\n            tokens.add(\"-\" + ch);\r\n            currentOption = options.getOption(ch);\r\n            if (currentOption.hasArg() && (token.length() != (i + 1))) {\r\n                tokens.add(token.substring(i + 1));\r\n                break;\r\n            }\r\n        } else if (stopAtNonOption) {\r\n            processNonOptionToken(token.substring(i));\r\n            break;\r\n        } else {\r\n            tokens.add(token);\r\n            break;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Breaks <code>token<\/code> into its constituent parts\r\n * using the following algorithm.\r\n *\r\n * <ul>\r\n *  <li>ignore the first character (\"<b>-<\/b>\")<\/li>\r\n *  <li>foreach remaining character check if an {@link Option}\r\n *  exists with that id.<\/li>\r\n *  <li>if an {@link Option} does exist then add that character\r\n *  prepended with \"<b>-<\/b>\" to the list of processed tokens.<\/li>\r\n *  <li>if the {@link Option} can have an argument value and there\r\n *  are remaining characters in the token then add the remaining\r\n *  characters as a token to the list of processed tokens.<\/li>\r\n *  <li>if an {@link Option} does <b>NOT<\/b> exist <b>AND<\/b>\r\n *  <code>stopAtNonOption<\/code> <b>IS<\/b> set then add the special token\r\n *  \"<b>--<\/b>\" followed by the remaining characters and also\r\n *  the remaining tokens directly to the processed tokens list.<\/li>\r\n *  <li>if an {@link Option} does <b>NOT<\/b> exist <b>AND<\/b>\r\n *  <code>stopAtNonOption<\/code> <b>IS NOT<\/b> set then add that\r\n *  character prepended with \"<b>-<\/b>\".<\/li>\r\n * <\/ul>\r\n *\r\n * @param token The current token to be <b>burst<\/b>\r\n * @param stopAtNonOption Specifies whether to stop processing\r\n * at the first non-Option encountered.\r\n *\/\r\n","code_no_comment":"protected void burstToken(String token, boolean stopAtNonOption) {\r\n    Option currentOption;\r\n    for (int i = 1; i < token.length(); i++) {\r\n        String ch = String.valueOf(token.charAt(i));\r\n        if (options.hasOption(ch)) {\r\n            tokens.add(\"-\" + ch);\r\n            currentOption = options.getOption(ch);\r\n            if (currentOption.hasArg() && (token.length() != (i + 1))) {\r\n                tokens.add(token.substring(i + 1));\r\n                break;\r\n            }\r\n        } else if (stopAtNonOption) {\r\n            processNonOptionToken(token.substring(i));\r\n            break;\r\n        } else {\r\n            tokens.add(token);\r\n            break;\r\n        }\r\n    }\r\n}","lc":0.2727272727,"pi":0.7416267943,"ma":0.8,"nbd":0.5,"ml":0.5,"d":1.0138888889,"mi":-0.274982382,"fo":0.5833333333,"r":-0.0263157895,"e":0.7774439123}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-531_90c45a02","label":1,"code":"\/**\r\n * Determine whether the named child has been removed. This is the\r\n * case when the write state has a corresponding {@code null} entry.\r\n * Assumes {@code read()}, {@code write()} needs not be called.\r\n * @param name  name of the child\r\n * @return  {@code true} iff a child with the given name has been removed\r\n *\/\r\nprivate boolean removed(String name) {\r\n    return writeState != null && writeState.isRemoved(name);\r\n}","code_comment":"\/**\r\n * Determine whether the named child has been removed. This is the\r\n * case when the write state has a corresponding {@code null} entry.\r\n * Assumes {@code read()}, {@code write()} needs not be called.\r\n * @param name  name of the child\r\n * @return  {@code true} iff a child with the given name has been removed\r\n *\/\r\n","code_no_comment":"private boolean removed(String name) {\r\n    return writeState != null && writeState.isRemoved(name);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.1091269841,"mi":0.948696265,"fo":-0.4166666667,"r":2.4210526316,"e":-0.1421252514}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"\/**\r\n * retrieve the cost for the query.\r\n *\r\n * !!! for now we want to skip the use-case of NON range-queries !!!\r\n *\/\r\npublic double getCost(Filter filter, NodeState root) {\r\n    throw new UnsupportedOperationException(\"Not supported as implementing AdvancedQueryIndex\");\r\n}","code_comment":"\/**\r\n * retrieve the cost for the query.\r\n *\r\n * !!! for now we want to skip the use-case of NON range-queries !!!\r\n *\/\r\n","code_no_comment":"public double getCost(Filter filter, NodeState root) {\r\n    throw new UnsupportedOperationException(\"Not supported as implementing AdvancedQueryIndex\");\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9971811135,"fo":-0.5,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5209_ed651a4d","label":3,"code":"public List<String> getRuntimeClasspathElements() throws DependencyResolutionRequiredException {\r\n    List<String> list = new ArrayList<String>(getArtifacts().size() + 1);\r\n    list.add(getBuild().getOutputDirectory());\r\n    for (Artifact a : getArtifacts()) {\r\n        if (a.getArtifactHandler().isAddedToClasspath()) {\r\n            \/\/ TODO: let the scope handler deal with this\r\n            if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_RUNTIME.equals(a.getScope())) {\r\n                addArtifactPath(a, list);\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}","code_comment":null,"code_no_comment":"public List<String> getRuntimeClasspathElements() throws DependencyResolutionRequiredException {\r\n    List<String> list = new ArrayList<String>(getArtifacts().size() + 1);\r\n    list.add(getBuild().getOutputDirectory());\r\n    for (Artifact a : getArtifacts()) {\r\n        if (a.getArtifactHandler().isAddedToClasspath()) {\r\n                        if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_RUNTIME.equals(a.getScope())) {\r\n                addArtifactPath(a, list);\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}","lc":-0.0909090909,"pi":0.8421052632,"ma":0.0,"nbd":0.5,"ml":0.1666666667,"d":-0.0317460317,"mi":0.0511627907,"fo":0.5833333333,"r":0.0,"e":-0.0187663883}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_add180fb","label":1,"code":"@Override\r\npublic Map<String, Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Map<String, Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {\r\n    return null;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7919661734,"fo":-0.5,"r":0.2105263158,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-177_f91ce934","label":1,"code":"protected void setOutputStream(final OutputStream os) {\r\n    this.os = os;\r\n}","code_comment":null,"code_no_comment":"protected void setOutputStream(final OutputStream os) {\r\n    this.os = os;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0606060606,"fo":-0.5,"r":1.9210526316,"e":-0.1627934049}
{"project_name":"Math","project_version":"7","label":0,"code":"\/**\r\n * Accept a step, triggering events and step handlers.\r\n * @param interpolator step interpolator\r\n * @param y state vector at step end time, must be reset if an event\r\n * asks for resetting or if an events stops integration during the step\r\n * @param yDot placeholder array where to put the time derivative of the state vector\r\n * @param tEnd final integration time\r\n * @return time at end of step\r\n * @exception MaxCountExceededException if the interpolator throws one because\r\n * the number of functions evaluations is exceeded\r\n * @exception NoBracketingException if the location of an event cannot be bracketed\r\n * @exception DimensionMismatchException if arrays dimensions do not match equations settings\r\n * @since 2.2\r\n *\/\r\nprotected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\r\n    double previousT = interpolator.getGlobalPreviousTime();\r\n    final double currentT = interpolator.getGlobalCurrentTime();\r\n    \/\/ initialize the events states if needed\r\n    if (!statesInitialized) {\r\n        for (EventState state : eventsStates) {\r\n            state.reinitializeBegin(interpolator);\r\n        }\r\n        statesInitialized = true;\r\n    }\r\n    \/\/ search for next events that may occur during the step\r\n    final int orderingSign = interpolator.isForward() ? +1 : -1;\r\n    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\r\n\r\n        \/**\r\n         * {@inheritDoc}\r\n         *\/\r\n        public int compare(EventState es0, EventState es1) {\r\n            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\r\n        }\r\n    });\r\n    for (final EventState state : eventsStates) {\r\n        if (state.evaluateStep(interpolator)) {\r\n            \/\/ the event occurs during the current step\r\n            occuringEvents.add(state);\r\n        }\r\n    }\r\n    while (!occuringEvents.isEmpty()) {\r\n        \/\/ handle the chronologically first event\r\n        final Iterator<EventState> iterator = occuringEvents.iterator();\r\n        final EventState currentEvent = iterator.next();\r\n        iterator.remove();\r\n        \/\/ restrict the interpolator to the first part of the step, up to the event\r\n        final double eventT = currentEvent.getEventTime();\r\n        interpolator.setSoftPreviousTime(previousT);\r\n        interpolator.setSoftCurrentTime(eventT);\r\n        \/\/ get state at event time\r\n        interpolator.setInterpolatedTime(eventT);\r\n        final double[] eventY = interpolator.getInterpolatedState().clone();\r\n        \/\/ advance all event states to current time\r\n        currentEvent.stepAccepted(eventT, eventY);\r\n        isLastStep = currentEvent.stop();\r\n        \/\/ handle the first part of the step, up to the event\r\n        for (final StepHandler handler : stepHandlers) {\r\n            handler.handleStep(interpolator, isLastStep);\r\n        }\r\n        if (isLastStep) {\r\n            \/\/ the event asked to stop integration\r\n            System.arraycopy(eventY, 0, y, 0, y.length);\r\n            for (final EventState remaining : occuringEvents) {\r\n                remaining.stepAccepted(eventT, eventY);\r\n            }\r\n            return eventT;\r\n        }\r\n        boolean needReset = currentEvent.reset(eventT, eventY);\r\n        if (needReset) {\r\n            \/\/ some event handler has triggered changes that\r\n            \/\/ invalidate the derivatives, we need to recompute them\r\n            System.arraycopy(eventY, 0, y, 0, y.length);\r\n            computeDerivatives(eventT, y, yDot);\r\n            resetOccurred = true;\r\n            for (final EventState remaining : occuringEvents) {\r\n                remaining.stepAccepted(eventT, eventY);\r\n            }\r\n            return eventT;\r\n        }\r\n        \/\/ prepare handling of the remaining part of the step\r\n        previousT = eventT;\r\n        interpolator.setSoftPreviousTime(eventT);\r\n        interpolator.setSoftCurrentTime(currentT);\r\n        \/\/ check if the same event occurs again in the remaining part of the step\r\n        if (currentEvent.evaluateStep(interpolator)) {\r\n            \/\/ the event occurs during the current step\r\n            occuringEvents.add(currentEvent);\r\n        }\r\n    }\r\n    \/\/ last part of the step, after the last event\r\n    interpolator.setInterpolatedTime(currentT);\r\n    final double[] currentY = interpolator.getInterpolatedState();\r\n    for (final EventState state : eventsStates) {\r\n        state.stepAccepted(currentT, currentY);\r\n        isLastStep = isLastStep || state.stop();\r\n    }\r\n    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\r\n    \/\/ handle the remaining part of the step, after all events if any\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.handleStep(interpolator, isLastStep);\r\n    }\r\n    return currentT;\r\n}","code_comment":"\/**\r\n * Accept a step, triggering events and step handlers.\r\n * @param interpolator step interpolator\r\n * @param y state vector at step end time, must be reset if an event\r\n * asks for resetting or if an events stops integration during the step\r\n * @param yDot placeholder array where to put the time derivative of the state vector\r\n * @param tEnd final integration time\r\n * @return time at end of step\r\n * @exception MaxCountExceededException if the interpolator throws one because\r\n * the number of functions evaluations is exceeded\r\n * @exception NoBracketingException if the location of an event cannot be bracketed\r\n * @exception DimensionMismatchException if arrays dimensions do not match equations settings\r\n * @since 2.2\r\n *\/\r\n\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\r\n    double previousT = interpolator.getGlobalPreviousTime();\r\n    final double currentT = interpolator.getGlobalCurrentTime();\r\n        if (!statesInitialized) {\r\n        for (EventState state : eventsStates) {\r\n            state.reinitializeBegin(interpolator);\r\n        }\r\n        statesInitialized = true;\r\n    }\r\n        final int orderingSign = interpolator.isForward() ? +1 : -1;\r\n    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\r\n\r\n        \/**\r\n         * {@inheritDoc}\r\n         *\/\r\n        public int compare(EventState es0, EventState es1) {\r\n            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\r\n        }\r\n    });\r\n    for (final EventState state : eventsStates) {\r\n        if (state.evaluateStep(interpolator)) {\r\n                        occuringEvents.add(state);\r\n        }\r\n    }\r\n    while (!occuringEvents.isEmpty()) {\r\n                final Iterator<EventState> iterator = occuringEvents.iterator();\r\n        final EventState currentEvent = iterator.next();\r\n        iterator.remove();\r\n                final double eventT = currentEvent.getEventTime();\r\n        interpolator.setSoftPreviousTime(previousT);\r\n        interpolator.setSoftCurrentTime(eventT);\r\n                interpolator.setInterpolatedTime(eventT);\r\n        final double[] eventY = interpolator.getInterpolatedState().clone();\r\n                currentEvent.stepAccepted(eventT, eventY);\r\n        isLastStep = currentEvent.stop();\r\n                for (final StepHandler handler : stepHandlers) {\r\n            handler.handleStep(interpolator, isLastStep);\r\n        }\r\n        if (isLastStep) {\r\n                        System.arraycopy(eventY, 0, y, 0, y.length);\r\n            for (final EventState remaining : occuringEvents) {\r\n                remaining.stepAccepted(eventT, eventY);\r\n            }\r\n            return eventT;\r\n        }\r\n        boolean needReset = currentEvent.reset(eventT, eventY);\r\n        if (needReset) {\r\n                                    System.arraycopy(eventY, 0, y, 0, y.length);\r\n            computeDerivatives(eventT, y, yDot);\r\n            resetOccurred = true;\r\n            for (final EventState remaining : occuringEvents) {\r\n                remaining.stepAccepted(eventT, eventY);\r\n            }\r\n            return eventT;\r\n        }\r\n                previousT = eventT;\r\n        interpolator.setSoftPreviousTime(eventT);\r\n        interpolator.setSoftCurrentTime(currentT);\r\n                if (currentEvent.evaluateStep(interpolator)) {\r\n                        occuringEvents.add(currentEvent);\r\n        }\r\n    }\r\n        interpolator.setInterpolatedTime(currentT);\r\n    final double[] currentY = interpolator.getInterpolatedState();\r\n    for (final EventState state : eventsStates) {\r\n        state.stepAccepted(currentT, currentY);\r\n        isLastStep = isLastStep || state.stop();\r\n    }\r\n    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\r\n        for (StepHandler handler : stepHandlers) {\r\n        handler.handleStep(interpolator, isLastStep);\r\n    }\r\n    return currentT;\r\n}","lc":2.6818181818,"pi":0.1531100478,"ma":2.2,"nbd":0.5,"ml":0.8333333333,"d":1.3670634921,"mi":-1.1330514447,"fo":2.6666666667,"r":-0.0263157895,"e":5.1746062482}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3318_e12e2052","label":3,"code":"\/**\r\n * Returns <code>true<\/code> if this rule applies to the given node\r\n * <code>state<\/code>.\r\n *\r\n * @param state the state to check.\r\n * @return <code>true<\/code> the rule applies to the given node;\r\n *         <code>false<\/code> otherwise.\r\n *\/\r\npublic boolean appliesTo(Tree state) {\r\n    if (!nodeTypeName.equals(getPrimaryTypeName(state))) {\r\n        return false;\r\n    }\r\n    \/\/ return condition == null || condition.evaluate(state);\r\n    return true;\r\n}","code_comment":"\/**\r\n * Returns <code>true<\/code> if this rule applies to the given node\r\n * <code>state<\/code>.\r\n *\r\n * @param state the state to check.\r\n * @return <code>true<\/code> the rule applies to the given node;\r\n *         <code>false<\/code> otherwise.\r\n *\/\r\n","code_no_comment":"public boolean appliesTo(Tree state) {\r\n    if (!nodeTypeName.equals(getPrimaryTypeName(state))) {\r\n        return false;\r\n    }\r\n        return true;\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.6188865398,"fo":-0.3333333333,"r":1.0,"e":-0.1627934049}
{"project_name":"Closure","project_version":"60","label":2,"code":"\/**\r\n * Gets the boolean value of a node that represents a expression. This method\r\n * effectively emulates the <code>Boolean()<\/code> JavaScript cast function.\r\n * Note: unlike getBooleanValue this function does not return UNKNOWN\r\n * for expressions with side-effects.\r\n *\/\r\nstatic TernaryValue getImpureBooleanValue(Node n) {\r\n    switch(n.getType()) {\r\n        case Token.ASSIGN:\r\n        case Token.COMMA:\r\n            \/\/ For ASSIGN and COMMA the value is the value of the RHS.\r\n            return getImpureBooleanValue(n.getLastChild());\r\n        case Token.NOT:\r\n            TernaryValue value = getImpureBooleanValue(n.getLastChild());\r\n            return value.not();\r\n        case Token.AND:\r\n            {\r\n                TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\r\n                TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\r\n                return lhs.and(rhs);\r\n            }\r\n        case Token.OR:\r\n            {\r\n                TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\r\n                TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\r\n                return lhs.or(rhs);\r\n            }\r\n        case Token.HOOK:\r\n            {\r\n                TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext());\r\n                TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\r\n                if (trueValue.equals(falseValue)) {\r\n                    return trueValue;\r\n                } else {\r\n                    return TernaryValue.UNKNOWN;\r\n                }\r\n            }\r\n        case Token.ARRAYLIT:\r\n        case Token.OBJECTLIT:\r\n            \/\/ ignoring side-effects\r\n            return TernaryValue.TRUE;\r\n        default:\r\n            return getPureBooleanValue(n);\r\n    }\r\n}","code_comment":"\/**\r\n * Gets the boolean value of a node that represents a expression. This method\r\n * effectively emulates the <code>Boolean()<\/code> JavaScript cast function.\r\n * Note: unlike getBooleanValue this function does not return UNKNOWN\r\n * for expressions with side-effects.\r\n *\/\r\n","code_no_comment":"static TernaryValue getImpureBooleanValue(Node n) {\r\n    switch(n.getType()) {\r\n        case Token.ASSIGN:\r\n        case Token.COMMA:\r\n                        return getImpureBooleanValue(n.getLastChild());\r\n        case Token.NOT:\r\n            TernaryValue value = getImpureBooleanValue(n.getLastChild());\r\n            return value.not();\r\n        case Token.AND:\r\n            {\r\n                TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\r\n                TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\r\n                return lhs.and(rhs);\r\n            }\r\n        case Token.OR:\r\n            {\r\n                TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\r\n                TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\r\n                return lhs.or(rhs);\r\n            }\r\n        case Token.HOOK:\r\n            {\r\n                TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext());\r\n                TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\r\n                if (trueValue.equals(falseValue)) {\r\n                    return trueValue;\r\n                } else {\r\n                    return TernaryValue.UNKNOWN;\r\n                }\r\n            }\r\n        case Token.ARRAYLIT:\r\n        case Token.OBJECTLIT:\r\n                        return TernaryValue.TRUE;\r\n        default:\r\n            return getPureBooleanValue(n);\r\n    }\r\n}","lc":1.0454545455,"pi":0.8708133971,"ma":1.4,"nbd":0.5,"ml":0.5833333333,"d":-0.3650793651,"mi":-0.6318534179,"fo":1.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5261_55c2e2d8","label":1,"code":"public synchronized BlockingQueue<Exchange> getQueue() {\r\n    if (queue == null) {\r\n        if (size > 0) {\r\n            queue = new LinkedBlockingQueue<Exchange>(size);\r\n        } else {\r\n            queue = new LinkedBlockingQueue<Exchange>();\r\n        }\r\n    }\r\n    return queue;\r\n}","code_comment":null,"code_no_comment":"public synchronized BlockingQueue<Exchange> getQueue() {\r\n    if (queue == null) {\r\n        if (size > 0) {\r\n            queue = new LinkedBlockingQueue<Exchange>(size);\r\n        } else {\r\n            queue = new LinkedBlockingQueue<Exchange>();\r\n        }\r\n    }\r\n    return queue;\r\n}","lc":-0.1818181818,"pi":0.5311004785,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0119047619,"mi":0.2803382664,"fo":-0.5,"r":0.4736842105,"e":-0.104025403}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"\/**\r\n *  @param comparator\r\n *             The comparator\r\n *  @return Iterator that iterates over children in the order specified by\r\n *          comparator\r\n *\/\r\npublic final Iterator<Component> iterator(Comparator<Component> comparator) {\r\n    final List<Component> sorted;\r\n    if (children == null) {\r\n        sorted = Collections.emptyList();\r\n    } else {\r\n        if (children instanceof Component) {\r\n            sorted = new ArrayList<Component>(1);\r\n            sorted.add((Component) children);\r\n        } else {\r\n            sorted = Arrays.asList((Component[]) children);\r\n        }\r\n    }\r\n    Collections.sort(sorted, comparator);\r\n    return sorted.iterator();\r\n}","code_comment":"\/**\r\n *  @param comparator\r\n *             The comparator\r\n *  @return Iterator that iterates over children in the order specified by\r\n *          comparator\r\n *\/\r\n","code_no_comment":"public final Iterator<Component> iterator(Comparator<Component> comparator) {\r\n    final List<Component> sorted;\r\n    if (children == null) {\r\n        sorted = Collections.emptyList();\r\n    } else {\r\n        if (children instanceof Component) {\r\n            sorted = new ArrayList<Component>(1);\r\n            sorted.add((Component) children);\r\n        } else {\r\n            sorted = Arrays.asList((Component[]) children);\r\n        }\r\n    }\r\n    Collections.sort(sorted, comparator);\r\n    return sorted.iterator();\r\n}","lc":0.0454545455,"pi":0.4019138756,"ma":-0.2,"nbd":0.0,"ml":-0.1666666667,"d":0.0317460317,"mi":-0.0336856942,"fo":-0.0833333333,"r":0.4736842105,"e":-0.003390905}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1076_9238264d","label":3,"code":"private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {\r\n    boolean asterisk = oakPropertyName.indexOf('*') >= 0;\r\n    if (asterisk) {\r\n        Tree t = currentTree();\r\n        ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();\r\n        readOakProperties(list, t, oakPropertyName, propertyType);\r\n        if (list.size() == 0) {\r\n            return null;\r\n        }\r\n        ArrayList<String> strings = new ArrayList<String>();\r\n        for (PropertyValue p : list) {\r\n            Iterables.addAll(strings, p.getValue(Type.STRINGS));\r\n        }\r\n        return PropertyValues.newString(strings);\r\n    }\r\n    boolean relative = oakPropertyName.indexOf('\/') >= 0;\r\n    Tree t = currentTree();\r\n    if (relative) {\r\n        for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {\r\n            if (t == null) {\r\n                return null;\r\n            }\r\n            if (p.equals(\"..\")) {\r\n                t = t.isRoot() ? null : t.getParent();\r\n            } else if (p.equals(\".\")) {\r\n            \/\/ same node\r\n            } else {\r\n                t = t.getChild(p);\r\n            }\r\n        }\r\n        oakPropertyName = PathUtils.getName(oakPropertyName);\r\n    }\r\n    return currentOakProperty(t, oakPropertyName, propertyType);\r\n}","code_comment":null,"code_no_comment":"private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {\r\n    boolean asterisk = oakPropertyName.indexOf('*') >= 0;\r\n    if (asterisk) {\r\n        Tree t = currentTree();\r\n        ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();\r\n        readOakProperties(list, t, oakPropertyName, propertyType);\r\n        if (list.size() == 0) {\r\n            return null;\r\n        }\r\n        ArrayList<String> strings = new ArrayList<String>();\r\n        for (PropertyValue p : list) {\r\n            Iterables.addAll(strings, p.getValue(Type.STRINGS));\r\n        }\r\n        return PropertyValues.newString(strings);\r\n    }\r\n    boolean relative = oakPropertyName.indexOf('\/') >= 0;\r\n    Tree t = currentTree();\r\n    if (relative) {\r\n        for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {\r\n            if (t == null) {\r\n                return null;\r\n            }\r\n            if (p.equals(\"..\")) {\r\n                t = t.isRoot() ? null : t.getParent();\r\n            } else if (p.equals(\".\")) {\r\n                        } else {\r\n                t = t.getChild(p);\r\n            }\r\n        }\r\n        oakPropertyName = PathUtils.getName(oakPropertyName);\r\n    }\r\n    return currentOakProperty(t, oakPropertyName, propertyType);\r\n}","lc":0.8636363636,"pi":0.5645933014,"ma":1.2,"nbd":1.0,"ml":0.75,"d":0.0853174603,"mi":-0.6126849894,"fo":1.0,"r":-0.0263157895,"e":0.4291050754}
{"project_name":"JxPath","project_version":"4","label":1,"code":"private String stringValue(Node node) {\r\n    int nodeType = node.getNodeType();\r\n    if (nodeType == Node.COMMENT_NODE) {\r\n        String text = ((Comment) node).getData();\r\n        return text == null ? \"\" : text.trim();\r\n    }\r\n    if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\r\n        String text = node.getNodeValue();\r\n        return text == null ? \"\" : text.trim();\r\n    }\r\n    if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\r\n        String text = ((ProcessingInstruction) node).getData();\r\n        return text == null ? \"\" : text.trim();\r\n    }\r\n    NodeList list = node.getChildNodes();\r\n    StringBuffer buf = new StringBuffer(16);\r\n    for (int i = 0; i < list.getLength(); i++) {\r\n        Node child = list.item(i);\r\n        if (child.getNodeType() == Node.TEXT_NODE) {\r\n            buf.append(child.getNodeValue());\r\n        } else {\r\n            buf.append(stringValue(child));\r\n        }\r\n    }\r\n    return buf.toString().trim();\r\n}","code_comment":null,"code_no_comment":"private String stringValue(Node node) {\r\n    int nodeType = node.getNodeType();\r\n    if (nodeType == Node.COMMENT_NODE) {\r\n        String text = ((Comment) node).getData();\r\n        return text == null ? \"\" : text.trim();\r\n    }\r\n    if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) {\r\n        String text = node.getNodeValue();\r\n        return text == null ? \"\" : text.trim();\r\n    }\r\n    if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) {\r\n        String text = ((ProcessingInstruction) node).getData();\r\n        return text == null ? \"\" : text.trim();\r\n    }\r\n    NodeList list = node.getChildNodes();\r\n    StringBuffer buf = new StringBuffer(16);\r\n    for (int i = 0; i < list.getLength(); i++) {\r\n        Node child = list.item(i);\r\n        if (child.getNodeType() == Node.TEXT_NODE) {\r\n            buf.append(child.getNodeValue());\r\n        } else {\r\n            buf.append(stringValue(child));\r\n        }\r\n    }\r\n    return buf.toString().trim();\r\n}","lc":0.5454545455,"pi":-0.004784689,"ma":1.0,"nbd":0.0,"ml":0.75,"d":0.6646825397,"mi":-0.488372093,"fo":0.9166666667,"r":-0.0263157895,"e":1.1080237202}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"\/**\r\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\r\n *  OVERRIDE.\r\n *\r\n *  Called when a request begins.\r\n *\/\r\n@Override\r\npublic void internalAttach() {\r\n    \/\/ Handle begin request for the container itself\r\n    try {\r\n        super.internalAttach();\r\n        \/\/ Loop through child components\r\n        final int size = children_size();\r\n        for (int i = 0; i < size; i++) {\r\n            \/\/ Get next child\r\n            final Component child = children_get(i);\r\n            \/\/ Ignore feedback as that was done in Page\r\n            if (!(child instanceof IFeedback)) {\r\n                \/\/ Call begin request on the child\r\n                child.internalAttach();\r\n            }\r\n        }\r\n    } catch (RuntimeException ex) {\r\n        if (ex instanceof WicketRuntimeException) {\r\n            throw ex;\r\n        } else {\r\n            throw new WicketRuntimeException(\"Error attaching this container for rendering: \" + this, ex);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\r\n *  OVERRIDE.\r\n *\r\n *  Called when a request begins.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void internalAttach() {\r\n        try {\r\n        super.internalAttach();\r\n                final int size = children_size();\r\n        for (int i = 0; i < size; i++) {\r\n                        final Component child = children_get(i);\r\n                        if (!(child instanceof IFeedback)) {\r\n                                child.internalAttach();\r\n            }\r\n        }\r\n    } catch (RuntimeException ex) {\r\n        if (ex instanceof WicketRuntimeException) {\r\n            throw ex;\r\n        } else {\r\n            throw new WicketRuntimeException(\"Error attaching this container for rendering: \" + this, ex);\r\n        }\r\n    }\r\n}","lc":0.2272727273,"pi":0.7129186603,"ma":0.6,"nbd":0.5,"ml":0.1666666667,"d":0.3492063492,"mi":-0.1439041579,"fo":-0.1666666667,"r":0.9736842105,"e":0.0810935726}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2337_36a41358","label":1,"code":"private static ObjectAndGetSetter getObjectAndGetSetter(final String expression, final Object object, int tryToCreateNull) {\r\n    final String expressionBracketsSeperated = Strings.replaceAll(expression, \"[\", \".[\").toString();\r\n    int index = getNextDotIndex(expressionBracketsSeperated, 0);\r\n    int lastIndex = 0;\r\n    Object value = object;\r\n    Class<?> clz = value.getClass();\r\n    String exp = expressionBracketsSeperated;\r\n    while (index != -1) {\r\n        exp = expressionBracketsSeperated.substring(lastIndex, index);\r\n        IGetAndSet getAndSetter = null;\r\n        try {\r\n            getAndSetter = getGetAndSetter(exp, clz);\r\n        } catch (WicketRuntimeException ex) {\r\n            \/\/ expression by it self can't be found. try to find a\r\n            \/\/ setPropertyByIndex(int,value) method\r\n            index = getNextDotIndex(expressionBracketsSeperated, index + 1);\r\n            if (index != -1) {\r\n                String indexExpression = expressionBracketsSeperated.substring(lastIndex, index);\r\n                getAndSetter = getGetAndSetter(indexExpression, clz);\r\n            } else {\r\n                exp = expressionBracketsSeperated.substring(lastIndex);\r\n                break;\r\n            }\r\n        }\r\n        Object newValue = null;\r\n        if (value != null) {\r\n            newValue = getAndSetter.getValue(value);\r\n        }\r\n        if (newValue == null) {\r\n            if (tryToCreateNull == CREATE_NEW_VALUE) {\r\n                newValue = getAndSetter.newValue(value);\r\n                if (newValue == null) {\r\n                    return null;\r\n                }\r\n            } else if (tryToCreateNull == RESOLVE_CLASS) {\r\n                clz = getAndSetter.getTargetClass();\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        value = newValue;\r\n        if (value != null) {\r\n            \/\/ value can be null if we are in the RESOLVE_CLASS\r\n            clz = value.getClass();\r\n        }\r\n        lastIndex = index + 1;\r\n        index = getNextDotIndex(expressionBracketsSeperated, lastIndex);\r\n        if (index == -1) {\r\n            exp = expressionBracketsSeperated.substring(lastIndex);\r\n            break;\r\n        }\r\n    }\r\n    IGetAndSet getAndSetter = getGetAndSetter(exp, clz);\r\n    return new ObjectAndGetSetter(getAndSetter, value);\r\n}","code_comment":null,"code_no_comment":"private static ObjectAndGetSetter getObjectAndGetSetter(final String expression, final Object object, int tryToCreateNull) {\r\n    final String expressionBracketsSeperated = Strings.replaceAll(expression, \"[\", \".[\").toString();\r\n    int index = getNextDotIndex(expressionBracketsSeperated, 0);\r\n    int lastIndex = 0;\r\n    Object value = object;\r\n    Class<?> clz = value.getClass();\r\n    String exp = expressionBracketsSeperated;\r\n    while (index != -1) {\r\n        exp = expressionBracketsSeperated.substring(lastIndex, index);\r\n        IGetAndSet getAndSetter = null;\r\n        try {\r\n            getAndSetter = getGetAndSetter(exp, clz);\r\n        } catch (WicketRuntimeException ex) {\r\n                                    index = getNextDotIndex(expressionBracketsSeperated, index + 1);\r\n            if (index != -1) {\r\n                String indexExpression = expressionBracketsSeperated.substring(lastIndex, index);\r\n                getAndSetter = getGetAndSetter(indexExpression, clz);\r\n            } else {\r\n                exp = expressionBracketsSeperated.substring(lastIndex);\r\n                break;\r\n            }\r\n        }\r\n        Object newValue = null;\r\n        if (value != null) {\r\n            newValue = getAndSetter.getValue(value);\r\n        }\r\n        if (newValue == null) {\r\n            if (tryToCreateNull == CREATE_NEW_VALUE) {\r\n                newValue = getAndSetter.newValue(value);\r\n                if (newValue == null) {\r\n                    return null;\r\n                }\r\n            } else if (tryToCreateNull == RESOLVE_CLASS) {\r\n                clz = getAndSetter.getTargetClass();\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        value = newValue;\r\n        if (value != null) {\r\n                        clz = value.getClass();\r\n        }\r\n        lastIndex = index + 1;\r\n        index = getNextDotIndex(expressionBracketsSeperated, lastIndex);\r\n        if (index == -1) {\r\n            exp = expressionBracketsSeperated.substring(lastIndex);\r\n            break;\r\n        }\r\n    }\r\n    IGetAndSet getAndSetter = getGetAndSetter(exp, clz);\r\n    return new ObjectAndGetSetter(getAndSetter, value);\r\n}","lc":1.7272727273,"pi":0.7607655502,"ma":1.8,"nbd":1.0,"ml":0.6666666667,"d":0.9543650794,"mi":-0.9019027484,"fo":0.9166666667,"r":-0.0263157895,"e":2.481817396}
{"project_name":"Lang","project_version":"58","label":1,"code":"\/\/ -----------------------------------------------------------------------\r\n\/\/ must handle Long, Float, Integer, Float, Short,\r\n\/\/ BigDecimal, BigInteger and Byte\r\n\/\/ useful methods:\r\n\/\/ Byte.decode(String)\r\n\/\/ Byte.valueOf(String,int radix)\r\n\/\/ Byte.valueOf(String)\r\n\/\/ Double.valueOf(String)\r\n\/\/ Float.valueOf(String)\r\n\/\/ new Float(String)\r\n\/\/ Integer.valueOf(String,int radix)\r\n\/\/ Integer.valueOf(String)\r\n\/\/ Integer.decode(String)\r\n\/\/ Integer.getInteger(String)\r\n\/\/ Integer.getInteger(String,int val)\r\n\/\/ Integer.getInteger(String,Integer val)\r\n\/\/ new Integer(String)\r\n\/\/ new Double(String)\r\n\/\/ new Byte(String)\r\n\/\/ new Long(String)\r\n\/\/ Long.getLong(String)\r\n\/\/ Long.getLong(String,int)\r\n\/\/ Long.getLong(String,Integer)\r\n\/\/ Long.valueOf(String,int)\r\n\/\/ Long.valueOf(String)\r\n\/\/ new Short(String)\r\n\/\/ Short.decode(String)\r\n\/\/ Short.valueOf(String,int)\r\n\/\/ Short.valueOf(String)\r\n\/\/ new BigDecimal(String)\r\n\/\/ new BigInteger(String)\r\n\/\/ new BigInteger(String,int radix)\r\n\/\/ Possible inputs:\r\n\/\/ 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\r\n\/\/ plus minus everything. Prolly more. A lot are not separable.\r\n\/**\r\n * <p>Turns a string value into a java.lang.Number.<\/p>\r\n *\r\n * <p>First, the value is examined for a type qualifier on the end\r\n * (<code>'f','F','d','D','l','L'<\/code>).  If it is found, it starts\r\n * trying to create successively larger types from the type specified\r\n * until one is found that can represent the value.<\/p>\r\n *\r\n * <p>If a type specifier is not found, it will check for a decimal point\r\n * and then try successively larger types from <code>Integer<\/code> to\r\n * <code>BigInteger<\/code> and from <code>Float<\/code> to\r\n * <code>BigDecimal<\/code>.<\/p>\r\n *\r\n * <p>If the string starts with <code>0x<\/code> or <code>-0x<\/code>, it\r\n * will be interpreted as a hexadecimal integer.  Values with leading\r\n * <code>0<\/code>'s will not be interpreted as octal.<\/p>\r\n *\r\n * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\r\n *\r\n * <p>This method does not trim the input string, i.e., strings with leading\r\n * or trailing spaces will generate NumberFormatExceptions.<\/p>\r\n *\r\n * @param str  String containing a number, may be null\r\n * @return Number created from the string\r\n * @throws NumberFormatException if the value cannot be converted\r\n *\/\r\npublic static Number createNumber(String str) throws NumberFormatException {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    if (StringUtils.isBlank(str)) {\r\n        throw new NumberFormatException(\"A blank string is not a valid number\");\r\n    }\r\n    if (str.startsWith(\"--\")) {\r\n        \/\/ a wrong value.\r\n        return null;\r\n    }\r\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\r\n        return createInteger(str);\r\n    }\r\n    char lastChar = str.charAt(str.length() - 1);\r\n    String mant;\r\n    String dec;\r\n    String exp;\r\n    int decPos = str.indexOf('.');\r\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\r\n    if (decPos > -1) {\r\n        if (expPos > -1) {\r\n            if (expPos < decPos) {\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            }\r\n            dec = str.substring(decPos + 1, expPos);\r\n        } else {\r\n            dec = str.substring(decPos + 1);\r\n        }\r\n        mant = str.substring(0, decPos);\r\n    } else {\r\n        if (expPos > -1) {\r\n            mant = str.substring(0, expPos);\r\n        } else {\r\n            mant = str;\r\n        }\r\n        dec = null;\r\n    }\r\n    if (!Character.isDigit(lastChar)) {\r\n        if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length() - 1);\r\n        } else {\r\n            exp = null;\r\n        }\r\n        \/\/ Requesting a specific type..\r\n        String numeric = str.substring(0, str.length() - 1);\r\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n        switch(lastChar) {\r\n            case 'l':\r\n            case 'L':\r\n                if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\r\n                    try {\r\n                        return createLong(numeric);\r\n                    } catch (NumberFormatException nfe) {\r\n                    \/\/ Too big for a long\r\n                    }\r\n                    return createBigInteger(numeric);\r\n                }\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            case 'f':\r\n            case 'F':\r\n                try {\r\n                    Float f = NumberUtils.createFloat(numeric);\r\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                        \/\/ has non-zeros in it, then float does not have the precision we want\r\n                        return f;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                \/\/ ignore the bad number\r\n                }\r\n            \/\/ Fall through\r\n            case 'd':\r\n            case 'D':\r\n                try {\r\n                    Double d = NumberUtils.createDouble(numeric);\r\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\r\n                        return d;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                \/\/ ignore the bad number\r\n                }\r\n                try {\r\n                    return createBigDecimal(numeric);\r\n                } catch (NumberFormatException e) {\r\n                \/\/ ignore the bad number\r\n                }\r\n            \/\/ Fall through\r\n            default:\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n        }\r\n    } else {\r\n        \/\/ small and go from there...\r\n        if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length());\r\n        } else {\r\n            exp = null;\r\n        }\r\n        if (dec == null && exp == null) {\r\n            \/\/ Must be an int,long,bigint\r\n            try {\r\n                return createInteger(str);\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ ignore the bad number\r\n            }\r\n            try {\r\n                return createLong(str);\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ ignore the bad number\r\n            }\r\n            return createBigInteger(str);\r\n        } else {\r\n            \/\/ Must be a float,double,BigDec\r\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n            try {\r\n                Float f = createFloat(str);\r\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                    return f;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ ignore the bad number\r\n            }\r\n            try {\r\n                Double d = createDouble(str);\r\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\r\n                    return d;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ ignore the bad number\r\n            }\r\n            return createBigDecimal(str);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * <p>Turns a string value into a java.lang.Number.<\/p>\r\n *\r\n * <p>First, the value is examined for a type qualifier on the end\r\n * (<code>'f','F','d','D','l','L'<\/code>).  If it is found, it starts\r\n * trying to create successively larger types from the type specified\r\n * until one is found that can represent the value.<\/p>\r\n *\r\n * <p>If a type specifier is not found, it will check for a decimal point\r\n * and then try successively larger types from <code>Integer<\/code> to\r\n * <code>BigInteger<\/code> and from <code>Float<\/code> to\r\n * <code>BigDecimal<\/code>.<\/p>\r\n *\r\n * <p>If the string starts with <code>0x<\/code> or <code>-0x<\/code>, it\r\n * will be interpreted as a hexadecimal integer.  Values with leading\r\n * <code>0<\/code>'s will not be interpreted as octal.<\/p>\r\n *\r\n * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\r\n *\r\n * <p>This method does not trim the input string, i.e., strings with leading\r\n * or trailing spaces will generate NumberFormatExceptions.<\/p>\r\n *\r\n * @param str  String containing a number, may be null\r\n * @return Number created from the string\r\n * @throws NumberFormatException if the value cannot be converted\r\n *\/\r\n","code_no_comment":"public static Number createNumber(String str) throws NumberFormatException {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    if (StringUtils.isBlank(str)) {\r\n        throw new NumberFormatException(\"A blank string is not a valid number\");\r\n    }\r\n    if (str.startsWith(\"--\")) {\r\n                return null;\r\n    }\r\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\r\n        return createInteger(str);\r\n    }\r\n    char lastChar = str.charAt(str.length() - 1);\r\n    String mant;\r\n    String dec;\r\n    String exp;\r\n    int decPos = str.indexOf('.');\r\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\r\n    if (decPos > -1) {\r\n        if (expPos > -1) {\r\n            if (expPos < decPos) {\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            }\r\n            dec = str.substring(decPos + 1, expPos);\r\n        } else {\r\n            dec = str.substring(decPos + 1);\r\n        }\r\n        mant = str.substring(0, decPos);\r\n    } else {\r\n        if (expPos > -1) {\r\n            mant = str.substring(0, expPos);\r\n        } else {\r\n            mant = str;\r\n        }\r\n        dec = null;\r\n    }\r\n    if (!Character.isDigit(lastChar)) {\r\n        if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length() - 1);\r\n        } else {\r\n            exp = null;\r\n        }\r\n                String numeric = str.substring(0, str.length() - 1);\r\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n        switch(lastChar) {\r\n            case 'l':\r\n            case 'L':\r\n                if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\r\n                    try {\r\n                        return createLong(numeric);\r\n                    } catch (NumberFormatException nfe) {\r\n                                        }\r\n                    return createBigInteger(numeric);\r\n                }\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            case 'f':\r\n            case 'F':\r\n                try {\r\n                    Float f = NumberUtils.createFloat(numeric);\r\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                                                return f;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                                }\r\n                        case 'd':\r\n            case 'D':\r\n                try {\r\n                    Double d = NumberUtils.createDouble(numeric);\r\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\r\n                        return d;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                                }\r\n                try {\r\n                    return createBigDecimal(numeric);\r\n                } catch (NumberFormatException e) {\r\n                                }\r\n                        default:\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n        }\r\n    } else {\r\n                if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length());\r\n        } else {\r\n            exp = null;\r\n        }\r\n        if (dec == null && exp == null) {\r\n                        try {\r\n                return createInteger(str);\r\n            } catch (NumberFormatException nfe) {\r\n                        }\r\n            try {\r\n                return createLong(str);\r\n            } catch (NumberFormatException nfe) {\r\n                        }\r\n            return createBigInteger(str);\r\n        } else {\r\n                        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n            try {\r\n                Float f = createFloat(str);\r\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                    return f;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n                        }\r\n            try {\r\n                Double d = createDouble(str);\r\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\r\n                    return d;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n                        }\r\n            return createBigDecimal(str);\r\n        }\r\n    }\r\n}","lc":4.6818181818,"pi":1.2057416268,"ma":6.6,"nbd":1.5,"ml":4.6666666667,"d":3.0277777778,"mi":-1.5516560958,"fo":3.75,"r":-0.0263157895,"e":15.6698512589}
{"project_name":"Closure","project_version":"30","label":2,"code":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    if (n.isName() && jsScope.isDeclared(n.getString(), true)) {\r\n        Var dep = jsScope.getVar(n.getString());\r\n        def.depends.add(dep);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    if (n.isName() && jsScope.isDeclared(n.getString(), true)) {\r\n        Var dep = jsScope.getVar(n.getString());\r\n        def.depends.add(dep);\r\n    }\r\n}","lc":-0.3181818182,"pi":0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":0.0,"d":-0.0932539683,"mi":0.3705426357,"fo":0.0,"r":0.0,"e":-0.0852013854}
{"project_name":"Codec","project_version":"1","label":1,"code":"\/**\r\n * Find the metaphone value of a String. This is similar to the\r\n * soundex algorithm, but better at finding similar sounding words.\r\n * All input is converted to upper case.\r\n * Limitations: Input format is expected to be a single ASCII word\r\n * with only characters in the A - Z range, no punctuation or numbers.\r\n *\r\n * @param txt String to find the metaphone code for\r\n * @return A metaphone code corresponding to the String supplied\r\n *\/\r\npublic String metaphone(String txt) {\r\n    boolean hard = false;\r\n    if ((txt == null) || (txt.length() == 0)) {\r\n        return \"\";\r\n    }\r\n    \/\/ single character is itself\r\n    if (txt.length() == 1) {\r\n        return txt.toUpperCase();\r\n    }\r\n    char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();\r\n    \/\/ manipulate\r\n    StringBuffer local = new StringBuffer(40);\r\n    \/\/ output\r\n    StringBuffer code = new StringBuffer(10);\r\n    \/\/ handle initial 2 characters exceptions\r\n    switch(inwd[0]) {\r\n        case 'K':\r\n        case 'G':\r\n        case 'P':\r\n            \/* looking for KN, etc*\/\r\n            if (inwd[1] == 'N') {\r\n                local.append(inwd, 1, inwd.length - 1);\r\n            } else {\r\n                local.append(inwd);\r\n            }\r\n            break;\r\n        case 'A':\r\n            \/* looking for AE *\/\r\n            if (inwd[1] == 'E') {\r\n                local.append(inwd, 1, inwd.length - 1);\r\n            } else {\r\n                local.append(inwd);\r\n            }\r\n            break;\r\n        case 'W':\r\n            \/* looking for WR or WH *\/\r\n            if (inwd[1] == 'R') {\r\n                \/\/ WR -> R\r\n                local.append(inwd, 1, inwd.length - 1);\r\n                break;\r\n            }\r\n            if (inwd[1] == 'H') {\r\n                local.append(inwd, 1, inwd.length - 1);\r\n                \/\/ WH -> W\r\n                local.setCharAt(0, 'W');\r\n            } else {\r\n                local.append(inwd);\r\n            }\r\n            break;\r\n        case 'X':\r\n            \/* initial X becomes S *\/\r\n            inwd[0] = 'S';\r\n            local.append(inwd);\r\n            break;\r\n        default:\r\n            local.append(inwd);\r\n    }\r\n    \/\/ now local has working string with initials fixed\r\n    int wdsz = local.length();\r\n    int n = 0;\r\n    while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {\r\n        \/\/ max code size of 4 works well\r\n        char symb = local.charAt(n);\r\n        \/\/ remove duplicate letters except C\r\n        if ((symb != 'C') && (isPreviousChar(local, n, symb))) {\r\n            n++;\r\n        } else {\r\n            \/\/ not dup\r\n            switch(symb) {\r\n                case 'A':\r\n                case 'E':\r\n                case 'I':\r\n                case 'O':\r\n                case 'U':\r\n                    if (n == 0) {\r\n                        code.append(symb);\r\n                    }\r\n                    \/\/ only use vowel if leading char\r\n                    break;\r\n                case 'B':\r\n                    if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {\r\n                        \/\/ B is silent if word ends in MB\r\n                        break;\r\n                    }\r\n                    code.append(symb);\r\n                    break;\r\n                case \/\/ lots of C special cases\r\n                'C':\r\n                    \/* discard if SCI, SCE or SCY *\/\r\n                    if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\r\n                        break;\r\n                    }\r\n                    if (regionMatch(local, n, \"CIA\")) {\r\n                        \/\/ \"CIA\" -> X\r\n                        code.append('X');\r\n                        break;\r\n                    }\r\n                    if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\r\n                        code.append('S');\r\n                        \/\/ CI,CE,CY -> S\r\n                        break;\r\n                    }\r\n                    if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {\r\n                        \/\/ SCH->sk\r\n                        code.append('K');\r\n                        break;\r\n                    }\r\n                    if (isNextChar(local, n, 'H')) {\r\n                        \/\/ detect CH\r\n                        if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {\r\n                            \/\/ CH consonant -> K consonant\r\n                            code.append('K');\r\n                        } else {\r\n                            \/\/ CHvowel -> X\r\n                            code.append('X');\r\n                        }\r\n                    } else {\r\n                        code.append('K');\r\n                    }\r\n                    break;\r\n                case 'D':\r\n                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {\r\n                        \/\/ DGE DGI DGY -> J\r\n                        code.append('J');\r\n                        n += 2;\r\n                    } else {\r\n                        code.append('T');\r\n                    }\r\n                    break;\r\n                case \/\/ GH silent at end or before consonant\r\n                'G':\r\n                    if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {\r\n                        break;\r\n                    }\r\n                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {\r\n                        break;\r\n                    }\r\n                    if ((n > 0) && (regionMatch(local, n, \"GN\") || regionMatch(local, n, \"GNED\"))) {\r\n                        \/\/ silent G\r\n                        break;\r\n                    }\r\n                    if (isPreviousChar(local, n, 'G')) {\r\n                        hard = true;\r\n                    } else {\r\n                        hard = false;\r\n                    }\r\n                    if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {\r\n                        code.append('J');\r\n                    } else {\r\n                        code.append('K');\r\n                    }\r\n                    break;\r\n                case 'H':\r\n                    if (isLastChar(wdsz, n)) {\r\n                        \/\/ terminal H\r\n                        break;\r\n                    }\r\n                    if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {\r\n                        break;\r\n                    }\r\n                    if (isVowel(local, n + 1)) {\r\n                        \/\/ Hvowel\r\n                        code.append('H');\r\n                    }\r\n                    break;\r\n                case 'F':\r\n                case 'J':\r\n                case 'L':\r\n                case 'M':\r\n                case 'N':\r\n                case 'R':\r\n                    code.append(symb);\r\n                    break;\r\n                case 'K':\r\n                    if (n > 0) {\r\n                        \/\/ not initial\r\n                        if (!isPreviousChar(local, n, 'C')) {\r\n                            code.append(symb);\r\n                        }\r\n                    } else {\r\n                        \/\/ initial K\r\n                        code.append(symb);\r\n                    }\r\n                    break;\r\n                case 'P':\r\n                    if (isNextChar(local, n, 'H')) {\r\n                        \/\/ PH -> F\r\n                        code.append('F');\r\n                    } else {\r\n                        code.append(symb);\r\n                    }\r\n                    break;\r\n                case 'Q':\r\n                    code.append('K');\r\n                    break;\r\n                case 'S':\r\n                    if (regionMatch(local, n, \"SH\") || regionMatch(local, n, \"SIO\") || regionMatch(local, n, \"SIA\")) {\r\n                        code.append('X');\r\n                    } else {\r\n                        code.append('S');\r\n                    }\r\n                    break;\r\n                case 'T':\r\n                    if (regionMatch(local, n, \"TIA\") || regionMatch(local, n, \"TIO\")) {\r\n                        code.append('X');\r\n                        break;\r\n                    }\r\n                    if (regionMatch(local, n, \"TCH\")) {\r\n                        \/\/ Silent if in \"TCH\"\r\n                        break;\r\n                    }\r\n                    \/\/ substitute numeral 0 for TH (resembles theta after all)\r\n                    if (regionMatch(local, n, \"TH\")) {\r\n                        code.append('0');\r\n                    } else {\r\n                        code.append('T');\r\n                    }\r\n                    break;\r\n                case 'V':\r\n                    code.append('F');\r\n                    break;\r\n                case 'W':\r\n                case \/\/ silent if not followed by vowel\r\n                'Y':\r\n                    if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {\r\n                        code.append(symb);\r\n                    }\r\n                    break;\r\n                case 'X':\r\n                    code.append('K');\r\n                    code.append('S');\r\n                    break;\r\n                case 'Z':\r\n                    code.append('S');\r\n                    break;\r\n            }\r\n            \/\/ end switch\r\n            n++;\r\n        }\r\n        \/\/ end else from symb != 'C'\r\n        if (code.length() > this.getMaxCodeLen()) {\r\n            code.setLength(this.getMaxCodeLen());\r\n        }\r\n    }\r\n    return code.toString();\r\n}","code_comment":"\/**\r\n * Find the metaphone value of a String. This is similar to the\r\n * soundex algorithm, but better at finding similar sounding words.\r\n * All input is converted to upper case.\r\n * Limitations: Input format is expected to be a single ASCII word\r\n * with only characters in the A - Z range, no punctuation or numbers.\r\n *\r\n * @param txt String to find the metaphone code for\r\n * @return A metaphone code corresponding to the String supplied\r\n *\/\r\n","code_no_comment":"public String metaphone(String txt) {\r\n    boolean hard = false;\r\n    if ((txt == null) || (txt.length() == 0)) {\r\n        return \"\";\r\n    }\r\n        if (txt.length() == 1) {\r\n        return txt.toUpperCase();\r\n    }\r\n    char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();\r\n        StringBuffer local = new StringBuffer(40);\r\n        StringBuffer code = new StringBuffer(10);\r\n        switch(inwd[0]) {\r\n        case 'K':\r\n        case 'G':\r\n        case 'P':\r\n                        if (inwd[1] == 'N') {\r\n                local.append(inwd, 1, inwd.length - 1);\r\n            } else {\r\n                local.append(inwd);\r\n            }\r\n            break;\r\n        case 'A':\r\n                        if (inwd[1] == 'E') {\r\n                local.append(inwd, 1, inwd.length - 1);\r\n            } else {\r\n                local.append(inwd);\r\n            }\r\n            break;\r\n        case 'W':\r\n                        if (inwd[1] == 'R') {\r\n                                local.append(inwd, 1, inwd.length - 1);\r\n                break;\r\n            }\r\n            if (inwd[1] == 'H') {\r\n                local.append(inwd, 1, inwd.length - 1);\r\n                                local.setCharAt(0, 'W');\r\n            } else {\r\n                local.append(inwd);\r\n            }\r\n            break;\r\n        case 'X':\r\n                        inwd[0] = 'S';\r\n            local.append(inwd);\r\n            break;\r\n        default:\r\n            local.append(inwd);\r\n    }\r\n        int wdsz = local.length();\r\n    int n = 0;\r\n    while ((code.length() < this.getMaxCodeLen()) && (n < wdsz)) {\r\n                char symb = local.charAt(n);\r\n                if ((symb != 'C') && (isPreviousChar(local, n, symb))) {\r\n            n++;\r\n        } else {\r\n                        switch(symb) {\r\n                case 'A':\r\n                case 'E':\r\n                case 'I':\r\n                case 'O':\r\n                case 'U':\r\n                    if (n == 0) {\r\n                        code.append(symb);\r\n                    }\r\n                                        break;\r\n                case 'B':\r\n                    if (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {\r\n                                                break;\r\n                    }\r\n                    code.append(symb);\r\n                    break;\r\n                case                 'C':\r\n                                        if (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\r\n                        break;\r\n                    }\r\n                    if (regionMatch(local, n, \"CIA\")) {\r\n                                                code.append('X');\r\n                        break;\r\n                    }\r\n                    if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {\r\n                        code.append('S');\r\n                                                break;\r\n                    }\r\n                    if (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {\r\n                                                code.append('K');\r\n                        break;\r\n                    }\r\n                    if (isNextChar(local, n, 'H')) {\r\n                                                if ((n == 0) && (wdsz >= 3) && isVowel(local, 2)) {\r\n                                                        code.append('K');\r\n                        } else {\r\n                                                        code.append('X');\r\n                        }\r\n                    } else {\r\n                        code.append('K');\r\n                    }\r\n                    break;\r\n                case 'D':\r\n                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) {\r\n                                                code.append('J');\r\n                        n += 2;\r\n                    } else {\r\n                        code.append('T');\r\n                    }\r\n                    break;\r\n                case                 'G':\r\n                    if (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {\r\n                        break;\r\n                    }\r\n                    if (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {\r\n                        break;\r\n                    }\r\n                    if ((n > 0) && (regionMatch(local, n, \"GN\") || regionMatch(local, n, \"GNED\"))) {\r\n                                                break;\r\n                    }\r\n                    if (isPreviousChar(local, n, 'G')) {\r\n                        hard = true;\r\n                    } else {\r\n                        hard = false;\r\n                    }\r\n                    if (!isLastChar(wdsz, n) && (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {\r\n                        code.append('J');\r\n                    } else {\r\n                        code.append('K');\r\n                    }\r\n                    break;\r\n                case 'H':\r\n                    if (isLastChar(wdsz, n)) {\r\n                                                break;\r\n                    }\r\n                    if ((n > 0) && (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {\r\n                        break;\r\n                    }\r\n                    if (isVowel(local, n + 1)) {\r\n                                                code.append('H');\r\n                    }\r\n                    break;\r\n                case 'F':\r\n                case 'J':\r\n                case 'L':\r\n                case 'M':\r\n                case 'N':\r\n                case 'R':\r\n                    code.append(symb);\r\n                    break;\r\n                case 'K':\r\n                    if (n > 0) {\r\n                                                if (!isPreviousChar(local, n, 'C')) {\r\n                            code.append(symb);\r\n                        }\r\n                    } else {\r\n                                                code.append(symb);\r\n                    }\r\n                    break;\r\n                case 'P':\r\n                    if (isNextChar(local, n, 'H')) {\r\n                                                code.append('F');\r\n                    } else {\r\n                        code.append(symb);\r\n                    }\r\n                    break;\r\n                case 'Q':\r\n                    code.append('K');\r\n                    break;\r\n                case 'S':\r\n                    if (regionMatch(local, n, \"SH\") || regionMatch(local, n, \"SIO\") || regionMatch(local, n, \"SIA\")) {\r\n                        code.append('X');\r\n                    } else {\r\n                        code.append('S');\r\n                    }\r\n                    break;\r\n                case 'T':\r\n                    if (regionMatch(local, n, \"TIA\") || regionMatch(local, n, \"TIO\")) {\r\n                        code.append('X');\r\n                        break;\r\n                    }\r\n                    if (regionMatch(local, n, \"TCH\")) {\r\n                                                break;\r\n                    }\r\n                                        if (regionMatch(local, n, \"TH\")) {\r\n                        code.append('0');\r\n                    } else {\r\n                        code.append('T');\r\n                    }\r\n                    break;\r\n                case 'V':\r\n                    code.append('F');\r\n                    break;\r\n                case 'W':\r\n                case                 'Y':\r\n                    if (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {\r\n                        code.append(symb);\r\n                    }\r\n                    break;\r\n                case 'X':\r\n                    code.append('K');\r\n                    code.append('S');\r\n                    break;\r\n                case 'Z':\r\n                    code.append('S');\r\n                    break;\r\n            }\r\n                        n++;\r\n        }\r\n                if (code.length() > this.getMaxCodeLen()) {\r\n            code.setLength(this.getMaxCodeLen());\r\n        }\r\n    }\r\n    return code.toString();\r\n}","lc":9.0,"pi":1.4928229665,"ma":19.4,"nbd":2.0,"ml":10.1666666667,"d":6.128968254,"mi":-2.311627907,"fo":7.6666666667,"r":-0.0263157895,"e":49.8502008379}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-326_ce185345","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic double getNorm() {\r\n    double res = 0;\r\n    Iterator iter = entries.iterator();\r\n    while (iter.hasNext()) {\r\n        iter.advance();\r\n        res += iter.value() * iter.value();\r\n    }\r\n    return Math.sqrt(res);\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public double getNorm() {\r\n    double res = 0;\r\n    Iterator iter = entries.iterator();\r\n    while (iter.hasNext()) {\r\n        iter.advance();\r\n        res += iter.value() * iter.value();\r\n    }\r\n    return Math.sqrt(res);\r\n}","lc":-0.2272727273,"pi":-0.1531100478,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0595238095,"mi":0.2921775899,"fo":0.0,"r":1.5263157895,"e":-0.0947032958}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"\/**\r\n * Creates a cursor which wraps another cursor and adds a path prefix to\r\n * each of row of the wrapped cursor. This method will return the passed\r\n * cursor as is if {@code path} is the empty string or the root path (\"\/\").\r\n *\r\n * @param c    the cursor to wrap.\r\n * @param path the path prefix.\r\n * @return the cursor.\r\n *\/\r\npublic static Cursor newPrefixCursor(Cursor c, String path) {\r\n    if (path.isEmpty() || PathUtils.denotesRoot(path)) {\r\n        \/\/ no need to wrap\r\n        return c;\r\n    }\r\n    return new PrefixCursor(c, path);\r\n}","code_comment":"\/**\r\n * Creates a cursor which wraps another cursor and adds a path prefix to\r\n * each of row of the wrapped cursor. This method will return the passed\r\n * cursor as is if {@code path} is the empty string or the root path (\"\/\").\r\n *\r\n * @param c    the cursor to wrap.\r\n * @param path the path prefix.\r\n * @return the cursor.\r\n *\/\r\n","code_no_comment":"public static Cursor newPrefixCursor(Cursor c, String path) {\r\n    if (path.isEmpty() || PathUtils.denotesRoot(path)) {\r\n                return c;\r\n    }\r\n    return new PrefixCursor(c, path);\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":0.0,"d":-0.3650793651,"mi":0.5492600423,"fo":-0.3333333333,"r":1.0526315789,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4918_691a03a7","label":1,"code":"public void setActiveProfiles(List<Profile> activeProfiles) {\r\n    this.activeProfiles.addAll(activeProfiles);\r\n}","code_comment":null,"code_no_comment":"public void setActiveProfiles(List<Profile> activeProfiles) {\r\n    this.activeProfiles.addAll(activeProfiles);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0253699789,"fo":-0.4166666667,"r":0.2368421053,"e":-0.1627934049}
{"project_name":"Cli","project_version":"17","label":1,"code":"\/**\r\n * <p>Breaks <code>token<\/code> into its constituent parts\r\n * using the following algorithm.\r\n * <ul>\r\n *  <li>ignore the first character (\"<b>-<\/b>\")<\/li>\r\n *  <li>foreach remaining character check if an {@link Option}\r\n *  exists with that id.<\/li>\r\n *  <li>if an {@link Option} does exist then add that character\r\n *  prepended with \"<b>-<\/b>\" to the list of processed tokens.<\/li>\r\n *  <li>if the {@link Option} can have an argument value and there\r\n *  are remaining characters in the token then add the remaining\r\n *  characters as a token to the list of processed tokens.<\/li>\r\n *  <li>if an {@link Option} does <b>NOT<\/b> exist <b>AND<\/b>\r\n *  <code>stopAtNonOption<\/code> <b>IS<\/b> set then add the special token\r\n *  \"<b>--<\/b>\" followed by the remaining characters and also\r\n *  the remaining tokens directly to the processed tokens list.<\/li>\r\n *  <li>if an {@link Option} does <b>NOT<\/b> exist <b>AND<\/b>\r\n *  <code>stopAtNonOption<\/code> <b>IS NOT<\/b> set then add that\r\n *  character prepended with \"<b>-<\/b>\".<\/li>\r\n * <\/ul>\r\n * <\/p>\r\n *\r\n * @param token The current token to be <b>burst<\/b>\r\n * @param stopAtNonOption Specifies whether to stop processing\r\n * at the first non-Option encountered.\r\n *\/\r\nprotected void burstToken(String token, boolean stopAtNonOption) {\r\n    for (int i = 1; i < token.length(); i++) {\r\n        String ch = String.valueOf(token.charAt(i));\r\n        if (options.hasOption(ch)) {\r\n            tokens.add(\"-\" + ch);\r\n            currentOption = options.getOption(ch);\r\n            if (currentOption.hasArg() && (token.length() != (i + 1))) {\r\n                tokens.add(token.substring(i + 1));\r\n                break;\r\n            }\r\n        } else if (stopAtNonOption) {\r\n            process(token.substring(i));\r\n        } else {\r\n            tokens.add(token);\r\n            break;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * <p>Breaks <code>token<\/code> into its constituent parts\r\n * using the following algorithm.\r\n * <ul>\r\n *  <li>ignore the first character (\"<b>-<\/b>\")<\/li>\r\n *  <li>foreach remaining character check if an {@link Option}\r\n *  exists with that id.<\/li>\r\n *  <li>if an {@link Option} does exist then add that character\r\n *  prepended with \"<b>-<\/b>\" to the list of processed tokens.<\/li>\r\n *  <li>if the {@link Option} can have an argument value and there\r\n *  are remaining characters in the token then add the remaining\r\n *  characters as a token to the list of processed tokens.<\/li>\r\n *  <li>if an {@link Option} does <b>NOT<\/b> exist <b>AND<\/b>\r\n *  <code>stopAtNonOption<\/code> <b>IS<\/b> set then add the special token\r\n *  \"<b>--<\/b>\" followed by the remaining characters and also\r\n *  the remaining tokens directly to the processed tokens list.<\/li>\r\n *  <li>if an {@link Option} does <b>NOT<\/b> exist <b>AND<\/b>\r\n *  <code>stopAtNonOption<\/code> <b>IS NOT<\/b> set then add that\r\n *  character prepended with \"<b>-<\/b>\".<\/li>\r\n * <\/ul>\r\n * <\/p>\r\n *\r\n * @param token The current token to be <b>burst<\/b>\r\n * @param stopAtNonOption Specifies whether to stop processing\r\n * at the first non-Option encountered.\r\n *\/\r\n","code_no_comment":"protected void burstToken(String token, boolean stopAtNonOption) {\r\n    for (int i = 1; i < token.length(); i++) {\r\n        String ch = String.valueOf(token.charAt(i));\r\n        if (options.hasOption(ch)) {\r\n            tokens.add(\"-\" + ch);\r\n            currentOption = options.getOption(ch);\r\n            if (currentOption.hasArg() && (token.length() != (i + 1))) {\r\n                tokens.add(token.substring(i + 1));\r\n                break;\r\n            }\r\n        } else if (stopAtNonOption) {\r\n            process(token.substring(i));\r\n        } else {\r\n            tokens.add(token);\r\n            break;\r\n        }\r\n    }\r\n}","lc":0.1818181818,"pi":0.7607655502,"ma":0.6,"nbd":0.5,"ml":0.5,"d":1.0238095238,"mi":-0.213812544,"fo":0.5833333333,"r":-0.0263157895,"e":0.7425713018}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-209_397f86f6","label":1,"code":"@Override\r\npublic void init(SortedKeyValueIterator<Key, Value> source, Map<String, String> options, IteratorEnvironment env) throws IOException {\r\n    super.init(source, options, env);\r\n    if (options.containsKey(ROW_REGEX)) {\r\n        rowMatcher = Pattern.compile(options.get(ROW_REGEX)).matcher(\"\");\r\n    } else {\r\n        rowMatcher = null;\r\n    }\r\n    if (options.containsKey(COLF_REGEX)) {\r\n        colfMatcher = Pattern.compile(options.get(COLF_REGEX)).matcher(\"\");\r\n    } else {\r\n        colfMatcher = null;\r\n    }\r\n    if (options.containsKey(COLQ_REGEX)) {\r\n        colqMatcher = Pattern.compile(options.get(COLQ_REGEX)).matcher(\"\");\r\n    } else {\r\n        colqMatcher = null;\r\n    }\r\n    if (options.containsKey(VALUE_REGEX)) {\r\n        valueMatcher = Pattern.compile(options.get(VALUE_REGEX)).matcher(\"\");\r\n    } else {\r\n        valueMatcher = null;\r\n    }\r\n    if (options.containsKey(OR_FIELDS)) {\r\n        orFields = Boolean.parseBoolean(options.get(OR_FIELDS));\r\n    } else {\r\n        orFields = false;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void init(SortedKeyValueIterator<Key, Value> source, Map<String, String> options, IteratorEnvironment env) throws IOException {\r\n    super.init(source, options, env);\r\n    if (options.containsKey(ROW_REGEX)) {\r\n        rowMatcher = Pattern.compile(options.get(ROW_REGEX)).matcher(\"\");\r\n    } else {\r\n        rowMatcher = null;\r\n    }\r\n    if (options.containsKey(COLF_REGEX)) {\r\n        colfMatcher = Pattern.compile(options.get(COLF_REGEX)).matcher(\"\");\r\n    } else {\r\n        colfMatcher = null;\r\n    }\r\n    if (options.containsKey(COLQ_REGEX)) {\r\n        colqMatcher = Pattern.compile(options.get(COLQ_REGEX)).matcher(\"\");\r\n    } else {\r\n        colqMatcher = null;\r\n    }\r\n    if (options.containsKey(VALUE_REGEX)) {\r\n        valueMatcher = Pattern.compile(options.get(VALUE_REGEX)).matcher(\"\");\r\n    } else {\r\n        valueMatcher = null;\r\n    }\r\n    if (options.containsKey(OR_FIELDS)) {\r\n        orFields = Boolean.parseBoolean(options.get(OR_FIELDS));\r\n    } else {\r\n        orFields = false;\r\n    }\r\n}","lc":0.6818181818,"pi":-0.2344497608,"ma":0.4,"nbd":-0.5,"ml":0.4166666667,"d":-0.3650793651,"mi":-0.4988019732,"fo":1.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-1619_b154d12f","label":1,"code":"\/**\r\n *  Factory method for creating page number links.\r\n *\r\n *  @param id\r\n *             the component id.\r\n *  @param pageable\r\n *             the pageable for the link\r\n *  @param pageIndex\r\n *             the page index the link points to\r\n *  @return the page navigation link.\r\n *\/\r\nprotected Link<?> newPagingNavigationLink(String id, IPageable pageable, int pageIndex) {\r\n    return new PagingNavigationLink<Void>(id, pageable, pageIndex) {\r\n\r\n        private static final long serialVersionUID = 1L;\r\n\r\n        @Override\r\n        public boolean isEnabled() {\r\n            return PagingNavigation.this.isEnabled() && PagingNavigation.this.isEnableAllowed();\r\n        }\r\n    };\r\n}","code_comment":"\/**\r\n *  Factory method for creating page number links.\r\n *\r\n *  @param id\r\n *             the component id.\r\n *  @param pageable\r\n *             the pageable for the link\r\n *  @param pageIndex\r\n *             the page index the link points to\r\n *  @return the page navigation link.\r\n *\/\r\n","code_no_comment":"protected Link<?> newPagingNavigationLink(String id, IPageable pageable, int pageIndex) {\r\n    return new PagingNavigationLink<Void>(id, pageable, pageIndex) {\r\n\r\n        private static final long serialVersionUID = 1L;\r\n\r\n        @Override\r\n        public boolean isEnabled() {\r\n            return PagingNavigation.this.isEnabled() && PagingNavigation.this.isEnableAllowed();\r\n        }\r\n    };\r\n}","lc":-0.2272727273,"pi":0.3971291866,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.1051587302,"mi":0.2989429175,"fo":-0.3333333333,"r":1.8947368421,"e":-0.104758447}
{"project_name":"Csv","project_version":"9","label":1,"code":"\/**\r\n * Puts all values of this record into the given Map.\r\n *\r\n * @param map The Map to populate.\r\n * @return the given map.\r\n *\/\r\n<M extends Map<String, String>> M putIn(final M map) {\r\n    for (final Entry<String, Integer> entry : mapping.entrySet()) {\r\n        final int col = entry.getValue().intValue();\r\n        if (col < values.length) {\r\n            map.put(entry.getKey(), values[col]);\r\n        }\r\n    }\r\n    return map;\r\n}","code_comment":"\/**\r\n * Puts all values of this record into the given Map.\r\n *\r\n * @param map The Map to populate.\r\n * @return the given map.\r\n *\/\r\n","code_no_comment":"<M extends Map<String, String>> M putIn(final M map) {\r\n    for (final Entry<String, Integer> entry : mapping.entrySet()) {\r\n        final int col = entry.getValue().intValue();\r\n        if (col < values.length) {\r\n            map.put(entry.getKey(), values[col]);\r\n        }\r\n    }\r\n    return map;\r\n}","lc":-0.2272727273,"pi":0.3732057416,"ma":-0.2,"nbd":0.0,"ml":-0.1666666667,"d":-0.0456349206,"mi":0.2369274137,"fo":-0.0833333333,"r":0.5789473684,"e":-0.0632746091}
{"project_name":"Lang","project_version":"34","label":1,"code":"\/**\r\n * <p>\r\n * Returns the registry of objects being traversed by the <code>reflectionToString<\/code>\r\n * methods in the current thread.\r\n * <\/p>\r\n *\r\n * @return Set the registry of objects being traversed\r\n *\/\r\nstatic Map<Object, Object> getRegistry() {\r\n    return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\r\n}","code_comment":"\/**\r\n * <p>\r\n * Returns the registry of objects being traversed by the <code>reflectionToString<\/code>\r\n * methods in the current thread.\r\n * <\/p>\r\n *\r\n * @return Set the registry of objects being traversed\r\n *\/\r\n","code_no_comment":"static Map<Object, Object> getRegistry() {\r\n    return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.3650793651,"mi":0.8900634249,"fo":-0.25,"r":2.4473684211,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"\/**\r\n *  Static utility to parse a field of type long from a byte sequence that represents text characters\r\n *  (such as when read from a file stream).\r\n *\r\n *  @param bytes The bytes containing the text data that should be parsed.\r\n *  @param startPos The offset to start the parsing.\r\n *  @param length The length of the byte sequence (counting from the offset).\r\n *\r\n *  @return The parsed value.\r\n *\r\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\r\n *\/\r\npublic static final long parseField(byte[] bytes, int startPos, int length) {\r\n    return parseField(bytes, startPos, length, (char) 0xffff);\r\n}","code_comment":"\/**\r\n *  Static utility to parse a field of type long from a byte sequence that represents text characters\r\n *  (such as when read from a file stream).\r\n *\r\n *  @param bytes The bytes containing the text data that should be parsed.\r\n *  @param startPos The offset to start the parsing.\r\n *  @param length The length of the byte sequence (counting from the offset).\r\n *\r\n *  @return The parsed value.\r\n *\r\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\r\n *\/\r\n","code_no_comment":"public static final long parseField(byte[] bytes, int startPos, int length) {\r\n    return parseField(bytes, startPos, length, (char) 0xffff);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.992670895,"fo":-0.4166666667,"r":1.9210526316,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1933_2e16a983","label":1,"code":"@Override\r\npublic Map<DynamicOperandImpl, Set<StaticOperandImpl>> getInMap() {\r\n    Map<DynamicOperandImpl, Set<StaticOperandImpl>> m1 = constraint1.getInMap();\r\n    Map<DynamicOperandImpl, Set<StaticOperandImpl>> m2 = constraint2.getInMap();\r\n    if (m1.isEmpty()) {\r\n        return m2;\r\n    } else if (m2.isEmpty()) {\r\n        return m1;\r\n    }\r\n    Map<DynamicOperandImpl, Set<StaticOperandImpl>> result = Maps.newHashMap();\r\n    result.putAll(m1);\r\n    for (Entry<DynamicOperandImpl, Set<StaticOperandImpl>> e2 : m2.entrySet()) {\r\n        Set<StaticOperandImpl> s = result.get(e2.getKey());\r\n        if (s != null) {\r\n            s.retainAll(e2.getValue());\r\n        } else {\r\n            result.put(e2.getKey(), e2.getValue());\r\n        }\r\n    }\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Map<DynamicOperandImpl, Set<StaticOperandImpl>> getInMap() {\r\n    Map<DynamicOperandImpl, Set<StaticOperandImpl>> m1 = constraint1.getInMap();\r\n    Map<DynamicOperandImpl, Set<StaticOperandImpl>> m2 = constraint2.getInMap();\r\n    if (m1.isEmpty()) {\r\n        return m2;\r\n    } else if (m2.isEmpty()) {\r\n        return m1;\r\n    }\r\n    Map<DynamicOperandImpl, Set<StaticOperandImpl>> result = Maps.newHashMap();\r\n    result.putAll(m1);\r\n    for (Entry<DynamicOperandImpl, Set<StaticOperandImpl>> e2 : m2.entrySet()) {\r\n        Set<StaticOperandImpl> s = result.get(e2.getKey());\r\n        if (s != null) {\r\n            s.retainAll(e2.getValue());\r\n        } else {\r\n            result.put(e2.getKey(), e2.getValue());\r\n        }\r\n    }\r\n    return result;\r\n}","lc":0.3181818182,"pi":0.1674641148,"ma":0.2,"nbd":0.0,"ml":0.0833333333,"d":0.123015873,"mi":-0.2958421424,"fo":0.6666666667,"r":-0.0263157895,"e":0.2136454533}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5230_9c8f658a","label":1,"code":"\/**\r\n *  @see org.apache.wicket.ajax.AjaxEventBehavior#onEvent(org.apache.wicket.ajax.AjaxRequestTarget)\r\n *\/\r\n@Override\r\nprotected final void onEvent(final AjaxRequestTarget target) {\r\n    final FormComponent<?> formComponent = getFormComponent();\r\n    if (\"blur\".equals(getEvent().toLowerCase()) && disableFocusOnBlur()) {\r\n        target.focusComponent(null);\r\n    }\r\n    try {\r\n        formComponent.inputChanged();\r\n        formComponent.validate();\r\n        if (formComponent.hasErrorMessage()) {\r\n            formComponent.invalid();\r\n            onError(target, null);\r\n        } else {\r\n            formComponent.valid();\r\n            if (getUpdateModel()) {\r\n                formComponent.updateModel();\r\n            }\r\n            onUpdate(target);\r\n        }\r\n    } catch (RuntimeException e) {\r\n        onError(target, e);\r\n    }\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.ajax.AjaxEventBehavior#onEvent(org.apache.wicket.ajax.AjaxRequestTarget)\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected final void onEvent(final AjaxRequestTarget target) {\r\n    final FormComponent<?> formComponent = getFormComponent();\r\n    if (\"blur\".equals(getEvent().toLowerCase()) && disableFocusOnBlur()) {\r\n        target.focusComponent(null);\r\n    }\r\n    try {\r\n        formComponent.inputChanged();\r\n        formComponent.validate();\r\n        if (formComponent.hasErrorMessage()) {\r\n            formComponent.invalid();\r\n            onError(target, null);\r\n        } else {\r\n            formComponent.valid();\r\n            if (getUpdateModel()) {\r\n                formComponent.updateModel();\r\n            }\r\n            onUpdate(target);\r\n        }\r\n    } catch (RuntimeException e) {\r\n        onError(target, e);\r\n    }\r\n}","lc":0.4090909091,"pi":0.6555023923,"ma":0.2,"nbd":0.5,"ml":0.3333333333,"d":-0.0674603175,"mi":-0.2611698379,"fo":0.8333333333,"r":-0.0263157895,"e":-0.0264887075}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-326_ce185345","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic double getLInfNorm() {\r\n    double max = 0;\r\n    Iterator iter = entries.iterator();\r\n    while (iter.hasNext()) {\r\n        iter.advance();\r\n        max += iter.value();\r\n    }\r\n    return max;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public double getLInfNorm() {\r\n    double max = 0;\r\n    Iterator iter = entries.iterator();\r\n    while (iter.hasNext()) {\r\n        iter.advance();\r\n        max += iter.value();\r\n    }\r\n    return max;\r\n}","lc":-0.2272727273,"pi":-0.1531100478,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0773809524,"mi":0.3378435518,"fo":-0.1666666667,"r":2.1578947368,"e":-0.1156434594}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5071_6e794ad0","label":1,"code":"\/**\r\n *  @see AbstractBookmarkableMapper#getCompatibilityScore(org.apache.wicket.request.Request)\r\n *\/\r\n@Override\r\npublic int getCompatibilityScore(Request request) {\r\n    int score = 0;\r\n    Url url = request.getUrl();\r\n    if (matches(url)) {\r\n        score = Integer.MAX_VALUE;\r\n    }\r\n    return score;\r\n}","code_comment":"\/**\r\n *  @see AbstractBookmarkableMapper#getCompatibilityScore(org.apache.wicket.request.Request)\r\n *\/\r\n","code_no_comment":"@Override\r\npublic int getCompatibilityScore(Request request) {\r\n    int score = 0;\r\n    Url url = request.getUrl();\r\n    if (matches(url)) {\r\n        score = Integer.MAX_VALUE;\r\n    }\r\n    return score;\r\n}","lc":-0.2272727273,"pi":-0.2296650718,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.326286117,"fo":-0.3333333333,"r":2.0263157895,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1311_94c8e3fa","label":1,"code":"@Override\r\npublic void postVisit(Operator<?> c) {\r\n    OptimizerNode n = this.con2node.get(c);\r\n    \/\/ first connect to the predecessors\r\n    n.setInput(this.con2node);\r\n    n.setBroadcastInputs(this.con2node);\r\n    \/\/ if the node represents a bulk iteration, we recursively translate the data flow now\r\n    if (n instanceof BulkIterationNode) {\r\n        final BulkIterationNode iterNode = (BulkIterationNode) n;\r\n        final BulkIterationBase<?> iter = iterNode.getIterationContract();\r\n        \/\/ pass a copy of the no iterative part into the iteration translation,\r\n        \/\/ in case the iteration references its closure\r\n        HashMap<Operator<?>, OptimizerNode> closure = new HashMap<Operator<?>, OptimizerNode>(con2node);\r\n        \/\/ first, recursively build the data flow for the step function\r\n        final GraphCreatingVisitor recursiveCreator = new GraphCreatingVisitor(this, true, iterNode.getDegreeOfParallelism(), closure);\r\n        BulkPartialSolutionNode partialSolution = null;\r\n        iter.getNextPartialSolution().accept(recursiveCreator);\r\n        partialSolution = (BulkPartialSolutionNode) recursiveCreator.con2node.get(iter.getPartialSolution());\r\n        OptimizerNode rootOfStepFunction = recursiveCreator.con2node.get(iter.getNextPartialSolution());\r\n        if (partialSolution == null) {\r\n            throw new CompilerException(\"Error: The step functions result does not depend on the partial solution.\");\r\n        }\r\n        OptimizerNode terminationCriterion = null;\r\n        if (iter.getTerminationCriterion() != null) {\r\n            terminationCriterion = recursiveCreator.con2node.get(iter.getTerminationCriterion());\r\n            \/\/ no intermediate node yet, traverse from the termination criterion to build the missing parts\r\n            if (terminationCriterion == null) {\r\n                iter.getTerminationCriterion().accept(recursiveCreator);\r\n                terminationCriterion = recursiveCreator.con2node.get(iter.getTerminationCriterion());\r\n            }\r\n        }\r\n        iterNode.setPartialSolution(partialSolution);\r\n        iterNode.setNextPartialSolution(rootOfStepFunction, terminationCriterion);\r\n        \/\/ go over the contained data flow and mark the dynamic path nodes\r\n        StaticDynamicPathIdentifier identifier = new StaticDynamicPathIdentifier(iterNode.getCostWeight());\r\n        rootOfStepFunction.accept(identifier);\r\n        if (terminationCriterion != null) {\r\n            terminationCriterion.accept(identifier);\r\n        }\r\n    } else if (n instanceof WorksetIterationNode) {\r\n        final WorksetIterationNode iterNode = (WorksetIterationNode) n;\r\n        final DeltaIterationBase<?, ?> iter = iterNode.getIterationContract();\r\n        \/\/ we need to ensure that both the next-workset and the solution-set-delta depend on the workset. One check is for free\r\n        \/\/ during the translation, we do the other check here as a pre-condition\r\n        {\r\n            StepFunctionValidator wsf = new StepFunctionValidator();\r\n            iter.getNextWorkset().accept(wsf);\r\n            if (!wsf.foundWorkset) {\r\n                throw new CompilerException(\"In the given program, the next workset does not depend on the workset. This is a prerequisite in delta iterations.\");\r\n            }\r\n        }\r\n        \/\/ calculate the closure of the anonymous function\r\n        HashMap<Operator<?>, OptimizerNode> closure = new HashMap<Operator<?>, OptimizerNode>(con2node);\r\n        \/\/ first, recursively build the data flow for the step function\r\n        final GraphCreatingVisitor recursiveCreator = new GraphCreatingVisitor(this, true, iterNode.getDegreeOfParallelism(), closure);\r\n        \/\/ descend from the solution set delta. check that it depends on both the workset\r\n        \/\/ and the solution set. If it does depend on both, this descend should create both nodes\r\n        iter.getSolutionSetDelta().accept(recursiveCreator);\r\n        final WorksetNode worksetNode = (WorksetNode) recursiveCreator.con2node.get(iter.getWorkset());\r\n        if (worksetNode == null) {\r\n            throw new CompilerException(\"In the given program, the solution set delta does not depend on the workset. This is a prerequisite in delta iterations.\");\r\n        }\r\n        iter.getNextWorkset().accept(recursiveCreator);\r\n        SolutionSetNode solutionSetNode = (SolutionSetNode) recursiveCreator.con2node.get(iter.getSolutionSet());\r\n        if (solutionSetNode == null || solutionSetNode.getOutgoingConnections() == null || solutionSetNode.getOutgoingConnections().isEmpty()) {\r\n            solutionSetNode = new SolutionSetNode((SolutionSetPlaceHolder<?>) iter.getSolutionSet(), iterNode);\r\n        } else {\r\n            for (PactConnection conn : solutionSetNode.getOutgoingConnections()) {\r\n                OptimizerNode successor = conn.getTarget();\r\n                if (successor.getClass() == JoinNode.class) {\r\n                    \/\/ find out which input to the match the solution set is\r\n                    JoinNode mn = (JoinNode) successor;\r\n                    if (mn.getFirstPredecessorNode() == solutionSetNode) {\r\n                        mn.makeJoinWithSolutionSet(0);\r\n                    } else if (mn.getSecondPredecessorNode() == solutionSetNode) {\r\n                        mn.makeJoinWithSolutionSet(1);\r\n                    } else {\r\n                        throw new CompilerException();\r\n                    }\r\n                } else if (successor.getClass() == CoGroupNode.class) {\r\n                    CoGroupNode cg = (CoGroupNode) successor;\r\n                    if (cg.getFirstPredecessorNode() == solutionSetNode) {\r\n                        cg.makeCoGroupWithSolutionSet(0);\r\n                    } else if (cg.getSecondPredecessorNode() == solutionSetNode) {\r\n                        cg.makeCoGroupWithSolutionSet(1);\r\n                    } else {\r\n                        throw new CompilerException();\r\n                    }\r\n                } else {\r\n                    throw new InvalidProgramException(\"Error: The only operations allowed on the solution set are Join and CoGroup.\");\r\n                }\r\n            }\r\n        }\r\n        final OptimizerNode nextWorksetNode = recursiveCreator.con2node.get(iter.getNextWorkset());\r\n        final OptimizerNode solutionSetDeltaNode = recursiveCreator.con2node.get(iter.getSolutionSetDelta());\r\n        \/\/ set the step function nodes to the iteration node\r\n        iterNode.setPartialSolution(solutionSetNode, worksetNode);\r\n        iterNode.setNextPartialSolution(solutionSetDeltaNode, nextWorksetNode);\r\n        \/\/ go over the contained data flow and mark the dynamic path nodes\r\n        StaticDynamicPathIdentifier pathIdentifier = new StaticDynamicPathIdentifier(iterNode.getCostWeight());\r\n        nextWorksetNode.accept(pathIdentifier);\r\n        iterNode.getSolutionSetDelta().accept(pathIdentifier);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void postVisit(Operator<?> c) {\r\n    OptimizerNode n = this.con2node.get(c);\r\n        n.setInput(this.con2node);\r\n    n.setBroadcastInputs(this.con2node);\r\n        if (n instanceof BulkIterationNode) {\r\n        final BulkIterationNode iterNode = (BulkIterationNode) n;\r\n        final BulkIterationBase<?> iter = iterNode.getIterationContract();\r\n                        HashMap<Operator<?>, OptimizerNode> closure = new HashMap<Operator<?>, OptimizerNode>(con2node);\r\n                final GraphCreatingVisitor recursiveCreator = new GraphCreatingVisitor(this, true, iterNode.getDegreeOfParallelism(), closure);\r\n        BulkPartialSolutionNode partialSolution = null;\r\n        iter.getNextPartialSolution().accept(recursiveCreator);\r\n        partialSolution = (BulkPartialSolutionNode) recursiveCreator.con2node.get(iter.getPartialSolution());\r\n        OptimizerNode rootOfStepFunction = recursiveCreator.con2node.get(iter.getNextPartialSolution());\r\n        if (partialSolution == null) {\r\n            throw new CompilerException(\"Error: The step functions result does not depend on the partial solution.\");\r\n        }\r\n        OptimizerNode terminationCriterion = null;\r\n        if (iter.getTerminationCriterion() != null) {\r\n            terminationCriterion = recursiveCreator.con2node.get(iter.getTerminationCriterion());\r\n                        if (terminationCriterion == null) {\r\n                iter.getTerminationCriterion().accept(recursiveCreator);\r\n                terminationCriterion = recursiveCreator.con2node.get(iter.getTerminationCriterion());\r\n            }\r\n        }\r\n        iterNode.setPartialSolution(partialSolution);\r\n        iterNode.setNextPartialSolution(rootOfStepFunction, terminationCriterion);\r\n                StaticDynamicPathIdentifier identifier = new StaticDynamicPathIdentifier(iterNode.getCostWeight());\r\n        rootOfStepFunction.accept(identifier);\r\n        if (terminationCriterion != null) {\r\n            terminationCriterion.accept(identifier);\r\n        }\r\n    } else if (n instanceof WorksetIterationNode) {\r\n        final WorksetIterationNode iterNode = (WorksetIterationNode) n;\r\n        final DeltaIterationBase<?, ?> iter = iterNode.getIterationContract();\r\n                        {\r\n            StepFunctionValidator wsf = new StepFunctionValidator();\r\n            iter.getNextWorkset().accept(wsf);\r\n            if (!wsf.foundWorkset) {\r\n                throw new CompilerException(\"In the given program, the next workset does not depend on the workset. This is a prerequisite in delta iterations.\");\r\n            }\r\n        }\r\n                HashMap<Operator<?>, OptimizerNode> closure = new HashMap<Operator<?>, OptimizerNode>(con2node);\r\n                final GraphCreatingVisitor recursiveCreator = new GraphCreatingVisitor(this, true, iterNode.getDegreeOfParallelism(), closure);\r\n                        iter.getSolutionSetDelta().accept(recursiveCreator);\r\n        final WorksetNode worksetNode = (WorksetNode) recursiveCreator.con2node.get(iter.getWorkset());\r\n        if (worksetNode == null) {\r\n            throw new CompilerException(\"In the given program, the solution set delta does not depend on the workset. This is a prerequisite in delta iterations.\");\r\n        }\r\n        iter.getNextWorkset().accept(recursiveCreator);\r\n        SolutionSetNode solutionSetNode = (SolutionSetNode) recursiveCreator.con2node.get(iter.getSolutionSet());\r\n        if (solutionSetNode == null || solutionSetNode.getOutgoingConnections() == null || solutionSetNode.getOutgoingConnections().isEmpty()) {\r\n            solutionSetNode = new SolutionSetNode((SolutionSetPlaceHolder<?>) iter.getSolutionSet(), iterNode);\r\n        } else {\r\n            for (PactConnection conn : solutionSetNode.getOutgoingConnections()) {\r\n                OptimizerNode successor = conn.getTarget();\r\n                if (successor.getClass() == JoinNode.class) {\r\n                                        JoinNode mn = (JoinNode) successor;\r\n                    if (mn.getFirstPredecessorNode() == solutionSetNode) {\r\n                        mn.makeJoinWithSolutionSet(0);\r\n                    } else if (mn.getSecondPredecessorNode() == solutionSetNode) {\r\n                        mn.makeJoinWithSolutionSet(1);\r\n                    } else {\r\n                        throw new CompilerException();\r\n                    }\r\n                } else if (successor.getClass() == CoGroupNode.class) {\r\n                    CoGroupNode cg = (CoGroupNode) successor;\r\n                    if (cg.getFirstPredecessorNode() == solutionSetNode) {\r\n                        cg.makeCoGroupWithSolutionSet(0);\r\n                    } else if (cg.getSecondPredecessorNode() == solutionSetNode) {\r\n                        cg.makeCoGroupWithSolutionSet(1);\r\n                    } else {\r\n                        throw new CompilerException();\r\n                    }\r\n                } else {\r\n                    throw new InvalidProgramException(\"Error: The only operations allowed on the solution set are Join and CoGroup.\");\r\n                }\r\n            }\r\n        }\r\n        final OptimizerNode nextWorksetNode = recursiveCreator.con2node.get(iter.getNextWorkset());\r\n        final OptimizerNode solutionSetDeltaNode = recursiveCreator.con2node.get(iter.getSolutionSetDelta());\r\n                iterNode.setPartialSolution(solutionSetNode, worksetNode);\r\n        iterNode.setNextPartialSolution(solutionSetDeltaNode, nextWorksetNode);\r\n                StaticDynamicPathIdentifier pathIdentifier = new StaticDynamicPathIdentifier(iterNode.getCostWeight());\r\n        nextWorksetNode.accept(pathIdentifier);\r\n        iterNode.getSolutionSetDelta().accept(pathIdentifier);\r\n    }\r\n}","lc":3.3636363636,"pi":1.4258373206,"ma":3.8,"nbd":3.0,"ml":2.1666666667,"d":1.0555555556,"mi":-1.3295278365,"fo":4.5833333333,"r":-0.0263157895,"e":6.4066227532}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1348_bc7b7e8c","label":1,"code":"private boolean internalAddEntry(@Nonnull ACE entry) throws RepositoryException {\r\n    final Principal principal = entry.getPrincipal();\r\n    List<ACE> subList = Lists.newArrayList(Iterables.filter(entries, new Predicate<ACE>() {\r\n\r\n        @Override\r\n        public boolean apply(@Nullable ACE ace) {\r\n            return (ace != null) && ace.getPrincipal().equals(principal);\r\n        }\r\n    }));\r\n    for (ACE existing : subList) {\r\n        PrivilegeBits existingBits = PrivilegeBits.getInstance(existing.getPrivilegeBits());\r\n        PrivilegeBits entryBits = entry.getPrivilegeBits();\r\n        if (entry.getRestrictions().equals(existing.getRestrictions())) {\r\n            if (entry.isAllow() == existing.isAllow()) {\r\n                if (existingBits.includes(entryBits)) {\r\n                    \/\/ no changes\r\n                    return false;\r\n                } else {\r\n                    \/\/ merge existing and new ace\r\n                    existingBits.add(entryBits);\r\n                    int index = entries.indexOf(existing);\r\n                    entries.remove(existing);\r\n                    entries.add(index, createACE(existing, existingBits));\r\n                    return true;\r\n                }\r\n            } else {\r\n                \/\/ existing is complementary entry -> clean up redundant\r\n                \/\/ privileges defined by the existing entry\r\n                PrivilegeBits updated = PrivilegeBits.getInstance(existingBits).diff(entryBits);\r\n                if (updated.isEmpty()) {\r\n                    \/\/ remove the existing entry as the new entry covers all privileges\r\n                    entries.remove(existing);\r\n                } else if (!updated.includes(existingBits)) {\r\n                    \/\/ replace the existing entry having it's privileges adjusted\r\n                    int index = entries.indexOf(existing);\r\n                    entries.remove(existing);\r\n                    entries.add(index, createACE(existing, updated));\r\n                }\r\n            \/* else: no collision that requires adjusting the existing entry.*\/\r\n            }\r\n        }\r\n    }\r\n    \/\/ finally add the new entry at the end of the list\r\n    entries.add(entry);\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"private boolean internalAddEntry(@Nonnull ACE entry) throws RepositoryException {\r\n    final Principal principal = entry.getPrincipal();\r\n    List<ACE> subList = Lists.newArrayList(Iterables.filter(entries, new Predicate<ACE>() {\r\n\r\n        @Override\r\n        public boolean apply(@Nullable ACE ace) {\r\n            return (ace != null) && ace.getPrincipal().equals(principal);\r\n        }\r\n    }));\r\n    for (ACE existing : subList) {\r\n        PrivilegeBits existingBits = PrivilegeBits.getInstance(existing.getPrivilegeBits());\r\n        PrivilegeBits entryBits = entry.getPrivilegeBits();\r\n        if (entry.getRestrictions().equals(existing.getRestrictions())) {\r\n            if (entry.isAllow() == existing.isAllow()) {\r\n                if (existingBits.includes(entryBits)) {\r\n                                        return false;\r\n                } else {\r\n                                        existingBits.add(entryBits);\r\n                    int index = entries.indexOf(existing);\r\n                    entries.remove(existing);\r\n                    entries.add(index, createACE(existing, existingBits));\r\n                    return true;\r\n                }\r\n            } else {\r\n                                                PrivilegeBits updated = PrivilegeBits.getInstance(existingBits).diff(entryBits);\r\n                if (updated.isEmpty()) {\r\n                                        entries.remove(existing);\r\n                } else if (!updated.includes(existingBits)) {\r\n                                        int index = entries.indexOf(existing);\r\n                    entries.remove(existing);\r\n                    entries.add(index, createACE(existing, updated));\r\n                }\r\n                        }\r\n        }\r\n    }\r\n        entries.add(entry);\r\n    return true;\r\n}","lc":1.0454545455,"pi":1.7177033493,"ma":0.6,"nbd":1.5,"ml":0.75,"d":0.6369047619,"mi":-0.6662438337,"fo":1.9166666667,"r":-0.0263157895,"e":1.3495732554}
{"project_name":"Math","project_version":"73","label":0,"code":"\/**\r\n * Find a zero in the given interval with an initial guess.\r\n * <p>Throws <code>IllegalArgumentException<\/code> if the values of the\r\n * function at the three points have the same sign (note that it is\r\n * allowed to have endpoints with the same sign if the initial point has\r\n * opposite sign function-wise).<\/p>\r\n *\r\n * @param f function to solve.\r\n * @param min the lower bound for the interval.\r\n * @param max the upper bound for the interval.\r\n * @param initial the start value to use (must be set to min if no\r\n * initial point is known).\r\n * @return the value where the function is zero\r\n * @throws MaxIterationsExceededException the maximum iteration count\r\n * is exceeded\r\n * @throws FunctionEvaluationException if an error occurs evaluating\r\n *  the function\r\n * @throws IllegalArgumentException if initial is not between min and max\r\n * (even if it <em>is<\/em> a root)\r\n *\/\r\npublic double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    clearResult();\r\n    verifySequence(min, initial, max);\r\n    \/\/ return the initial guess if it is good enough\r\n    double yInitial = f.value(initial);\r\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\r\n        setResult(initial, 0);\r\n        return result;\r\n    }\r\n    \/\/ return the first endpoint if it is good enough\r\n    double yMin = f.value(min);\r\n    if (Math.abs(yMin) <= functionValueAccuracy) {\r\n        setResult(yMin, 0);\r\n        return result;\r\n    }\r\n    \/\/ reduce interval if min and initial bracket the root\r\n    if (yInitial * yMin < 0) {\r\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\r\n    }\r\n    \/\/ return the second endpoint if it is good enough\r\n    double yMax = f.value(max);\r\n    if (Math.abs(yMax) <= functionValueAccuracy) {\r\n        setResult(yMax, 0);\r\n        return result;\r\n    }\r\n    \/\/ reduce interval if initial and max bracket the root\r\n    if (yInitial * yMax < 0) {\r\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\r\n    }\r\n    \/\/ full Brent algorithm starting with provided initial guess\r\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\r\n}","code_comment":"\/**\r\n * Find a zero in the given interval with an initial guess.\r\n * <p>Throws <code>IllegalArgumentException<\/code> if the values of the\r\n * function at the three points have the same sign (note that it is\r\n * allowed to have endpoints with the same sign if the initial point has\r\n * opposite sign function-wise).<\/p>\r\n *\r\n * @param f function to solve.\r\n * @param min the lower bound for the interval.\r\n * @param max the upper bound for the interval.\r\n * @param initial the start value to use (must be set to min if no\r\n * initial point is known).\r\n * @return the value where the function is zero\r\n * @throws MaxIterationsExceededException the maximum iteration count\r\n * is exceeded\r\n * @throws FunctionEvaluationException if an error occurs evaluating\r\n *  the function\r\n * @throws IllegalArgumentException if initial is not between min and max\r\n * (even if it <em>is<\/em> a root)\r\n *\/\r\n","code_no_comment":"public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    clearResult();\r\n    verifySequence(min, initial, max);\r\n        double yInitial = f.value(initial);\r\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\r\n        setResult(initial, 0);\r\n        return result;\r\n    }\r\n        double yMin = f.value(min);\r\n    if (Math.abs(yMin) <= functionValueAccuracy) {\r\n        setResult(yMin, 0);\r\n        return result;\r\n    }\r\n        if (yInitial * yMin < 0) {\r\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\r\n    }\r\n        double yMax = f.value(max);\r\n    if (Math.abs(yMax) <= functionValueAccuracy) {\r\n        setResult(yMax, 0);\r\n        return result;\r\n    }\r\n        if (yInitial * yMax < 0) {\r\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\r\n    }\r\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\r\n}","lc":0.5454545455,"pi":-0.3301435407,"ma":0.4,"nbd":-0.5,"ml":0.5833333333,"d":1.1468253968,"mi":-0.4339675828,"fo":0.6666666667,"r":-0.0263157895,"e":1.3053047723}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7622_faa20255","label":1,"code":"\/**\r\n * Gets the outputs from the given parent.\r\n * <p\/>\r\n * This implementation deals with that outputs can be abstract and retrieves the correct non-nested output.\r\n *\r\n * @param parent the parent\r\n * @return <tt>null<\/tt> if no parent\r\n *\/\r\n@SuppressWarnings(\"unchecked\")\r\nprivate static List<ProcessorDefinition> getParentOutputs(ProcessorDefinition parent) {\r\n    if (parent == null) {\r\n        return null;\r\n    }\r\n    List<ProcessorDefinition> outputs = parent.getOutputs();\r\n    if (outputs.size() >= 1) {\r\n        \/\/ get the 'actual' outputs from that\r\n        if (outputs.get(0).isAbstract()) {\r\n            outputs = outputs.get(0).getOutputs();\r\n        }\r\n    }\r\n    return outputs;\r\n}","code_comment":"\/**\r\n * Gets the outputs from the given parent.\r\n * <p\/>\r\n * This implementation deals with that outputs can be abstract and retrieves the correct non-nested output.\r\n *\r\n * @param parent the parent\r\n * @return <tt>null<\/tt> if no parent\r\n *\/\r\n","code_no_comment":"@SuppressWarnings(\"unchecked\")\r\nprivate static List<ProcessorDefinition> getParentOutputs(ProcessorDefinition parent) {\r\n    if (parent == null) {\r\n        return null;\r\n    }\r\n    List<ProcessorDefinition> outputs = parent.getOutputs();\r\n    if (outputs.size() >= 1) {\r\n                if (outputs.get(0).isAbstract()) {\r\n            outputs = outputs.get(0).getOutputs();\r\n        }\r\n    }\r\n    return outputs;\r\n}","lc":-0.0454545455,"pi":0.2200956938,"ma":0.0,"nbd":0.0,"ml":0.0833333333,"d":0.0178571429,"mi":0.0584918957,"fo":0.0,"r":0.0526315789,"e":-0.0401399238}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1104_7ae92779","label":1,"code":"\/\/ --------------------------------------------------------< Comparable >--\r\n@Override\r\npublic int compareTo(MapEntry that) {\r\n    return ComparisonChain.start().compare(getHash(), that.getHash()).compare(name, that.name).compare(value, that.value).result();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int compareTo(MapEntry that) {\r\n    return ComparisonChain.start().compare(getHash(), that.getHash()).compare(name, that.name).compare(value, that.value).result();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7119097956,"fo":0.0833333333,"r":0.2105263158,"e":-0.1627934049}
{"project_name":"Compress","project_version":"7","label":1,"code":"\/**\r\n * Parse an entry name from a buffer.\r\n * Parsing stops when a NUL is found\r\n * or the buffer length is reached.\r\n *\r\n * @param buffer The buffer from which to parse.\r\n * @param offset The offset into the buffer from which to parse.\r\n * @param length The maximum number of bytes to parse.\r\n * @return The entry name.\r\n *\/\r\npublic static String parseName(byte[] buffer, final int offset, final int length) {\r\n    StringBuffer result = new StringBuffer(length);\r\n    int end = offset + length;\r\n    for (int i = offset; i < end; ++i) {\r\n        if (buffer[i] == 0) {\r\n            break;\r\n        }\r\n        result.append((char) buffer[i]);\r\n    }\r\n    return result.toString();\r\n}","code_comment":"\/**\r\n * Parse an entry name from a buffer.\r\n * Parsing stops when a NUL is found\r\n * or the buffer length is reached.\r\n *\r\n * @param buffer The buffer from which to parse.\r\n * @param offset The offset into the buffer from which to parse.\r\n * @param length The maximum number of bytes to parse.\r\n * @return The entry name.\r\n *\/\r\n","code_no_comment":"public static String parseName(byte[] buffer, final int offset, final int length) {\r\n    StringBuffer result = new StringBuffer(length);\r\n    int end = offset + length;\r\n    for (int i = offset; i < end; ++i) {\r\n        if (buffer[i] == 0) {\r\n            break;\r\n        }\r\n        result.append((char) buffer[i]);\r\n    }\r\n    return result.toString();\r\n}","lc":-0.1363636364,"pi":0.2200956938,"ma":0.0,"nbd":0.0,"ml":-0.0833333333,"d":0.4583333333,"mi":0.1303735025,"fo":-0.3333333333,"r":0.5789473684,"e":0.1087187289}
{"project_name":"Math","project_version":"53","label":1,"code":"\/**\r\n * Return the sum of this complex number and the given complex number.\r\n * <p>\r\n * Uses the definitional formula\r\n * <pre>\r\n * (a + bi) + (c + di) = (a+c) + (b+d)i\r\n * <\/pre><\/p>\r\n * <p>\r\n * If either this or <code>rhs<\/code> has a NaN value in either part,\r\n * {@link #NaN} is returned; otherwise Infinite and NaN values are\r\n * returned in the parts of the result according to the rules for\r\n * {@link java.lang.Double} arithmetic.<\/p>\r\n *\r\n * @param rhs the other complex number\r\n * @return the complex number sum\r\n * @throws NullArgumentException if <code>rhs<\/code> is null\r\n *\/\r\npublic Complex add(Complex rhs) throws NullArgumentException {\r\n    MathUtils.checkNotNull(rhs);\r\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\r\n}","code_comment":"\/**\r\n * Return the sum of this complex number and the given complex number.\r\n * <p>\r\n * Uses the definitional formula\r\n * <pre>\r\n * (a + bi) + (c + di) = (a+c) + (b+d)i\r\n * <\/pre><\/p>\r\n * <p>\r\n * If either this or <code>rhs<\/code> has a NaN value in either part,\r\n * {@link #NaN} is returned; otherwise Infinite and NaN values are\r\n * returned in the parts of the result according to the rules for\r\n * {@link java.lang.Double} arithmetic.<\/p>\r\n *\r\n * @param rhs the other complex number\r\n * @return the complex number sum\r\n * @throws NullArgumentException if <code>rhs<\/code> is null\r\n *\/\r\n","code_no_comment":"public Complex add(Complex rhs) throws NullArgumentException {\r\n    MathUtils.checkNotNull(rhs);\r\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7226215645,"fo":-0.1666666667,"r":1.1578947368,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3015_f848178e","label":1,"code":"@Override\r\npublic void readFields(DataInput in) throws IOException {\r\n    range.readFields(in);\r\n    int numLocs = in.readInt();\r\n    locations = new String[numLocs];\r\n    for (int i = 0; i < numLocs; ++i) locations[i] = in.readUTF();\r\n    if (in.readBoolean()) {\r\n        isolatedScan = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        offline = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        localIterators = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        mockInstance = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        int numColumns = in.readInt();\r\n        List<String> columns = new ArrayList<String>(numColumns);\r\n        for (int i = 0; i < numColumns; i++) {\r\n            columns.add(in.readUTF());\r\n        }\r\n        fetchedColumns = InputConfigurator.deserializeFetchedColumns(columns);\r\n    }\r\n    if (in.readBoolean()) {\r\n        String strAuths = in.readUTF();\r\n        auths = new Authorizations(strAuths.getBytes(Charset.forName(\"UTF-8\")));\r\n    }\r\n    if (in.readBoolean()) {\r\n        principal = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        String tokenClass = in.readUTF();\r\n        byte[] base64TokenBytes = in.readUTF().getBytes(Charset.forName(\"UTF-8\"));\r\n        byte[] tokenBytes = Base64.decodeBase64(base64TokenBytes);\r\n        try {\r\n            token = CredentialHelper.extractToken(tokenClass, tokenBytes);\r\n        } catch (AccumuloSecurityException e) {\r\n            throw new IOException(e);\r\n        }\r\n    }\r\n    if (in.readBoolean()) {\r\n        instanceName = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        zooKeepers = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        int numIterators = in.readInt();\r\n        iterators = new ArrayList<IteratorSetting>(numIterators);\r\n        for (int i = 0; i < numIterators; i++) {\r\n            iterators.add(new IteratorSetting(in));\r\n        }\r\n    }\r\n    if (in.readBoolean()) {\r\n        level = Level.toLevel(in.readInt());\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void readFields(DataInput in) throws IOException {\r\n    range.readFields(in);\r\n    int numLocs = in.readInt();\r\n    locations = new String[numLocs];\r\n    for (int i = 0; i < numLocs; ++i) locations[i] = in.readUTF();\r\n    if (in.readBoolean()) {\r\n        isolatedScan = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        offline = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        localIterators = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        mockInstance = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        int numColumns = in.readInt();\r\n        List<String> columns = new ArrayList<String>(numColumns);\r\n        for (int i = 0; i < numColumns; i++) {\r\n            columns.add(in.readUTF());\r\n        }\r\n        fetchedColumns = InputConfigurator.deserializeFetchedColumns(columns);\r\n    }\r\n    if (in.readBoolean()) {\r\n        String strAuths = in.readUTF();\r\n        auths = new Authorizations(strAuths.getBytes(Charset.forName(\"UTF-8\")));\r\n    }\r\n    if (in.readBoolean()) {\r\n        principal = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        String tokenClass = in.readUTF();\r\n        byte[] base64TokenBytes = in.readUTF().getBytes(Charset.forName(\"UTF-8\"));\r\n        byte[] tokenBytes = Base64.decodeBase64(base64TokenBytes);\r\n        try {\r\n            token = CredentialHelper.extractToken(tokenClass, tokenBytes);\r\n        } catch (AccumuloSecurityException e) {\r\n            throw new IOException(e);\r\n        }\r\n    }\r\n    if (in.readBoolean()) {\r\n        instanceName = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        zooKeepers = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        int numIterators = in.readInt();\r\n        iterators = new ArrayList<IteratorSetting>(numIterators);\r\n        for (int i = 0; i < numIterators; i++) {\r\n            iterators.add(new IteratorSetting(in));\r\n        }\r\n    }\r\n    if (in.readBoolean()) {\r\n        level = Level.toLevel(in.readInt());\r\n    }\r\n}","lc":2.0909090909,"pi":-0.1004784689,"ma":2.8,"nbd":0.0,"ml":1.25,"d":0.1845238095,"mi":-1.0262156448,"fo":2.75,"r":-0.0263157895,"e":1.1590279098}
{"project_name":"Closure","project_version":"137","label":2,"code":"\/**\r\n * Rename vars for the current scope, and merge any referenced\r\n * names into the parent scope reference set.\r\n *\/\r\n@Override\r\npublic void visit(NodeTraversal t, Node node, Node parent) {\r\n    if (node.getType() == Token.NAME) {\r\n        String oldName = node.getString();\r\n        if (containsSeparator(oldName)) {\r\n            Scope scope = t.getScope();\r\n            Var var = t.getScope().getVar(oldName);\r\n            if (var == null || var.isGlobal()) {\r\n                return;\r\n            }\r\n            if (nameMap.containsKey(var)) {\r\n                node.setString(nameMap.get(var));\r\n            } else {\r\n                int index = indexOfSeparator(oldName);\r\n                String newName = getOrginalNameInternal(oldName, index);\r\n                String suffix = getNameSuffix(oldName, index);\r\n                \/\/ Merge any names that were referenced but not declared in the current\r\n                \/\/ scope.\r\n                \/\/ If there isn't anything left in the stack we will be going into the\r\n                \/\/ global scope: don't try to build a set of referenced names for the\r\n                \/\/ global scope.\r\n                boolean recurseScopes = false;\r\n                if (!suffix.matches(\"\\\\d+\")) {\r\n                    recurseScopes = true;\r\n                }\r\n                \/\/ Check if the new name is valid and if it would cause conflicts.\r\n                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\r\n                    newName = oldName;\r\n                } else {\r\n                    var.scope.declare(newName, var.nameNode, null, null);\r\n                    \/\/ Adding a reference to the new name to prevent either the parent\r\n                    \/\/ scopes or the current scope renaming another var to this new name.\r\n                    Node parentNode = var.getParentNode();\r\n                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\r\n                        var.getNameNode().setString(newName);\r\n                    }\r\n                    node.setString(newName);\r\n                    compiler.reportCodeChange();\r\n                }\r\n                nameMap.put(var, newName);\r\n            }\r\n        \/\/ Add all referenced names to the set so it is possible to check for\r\n        \/\/ conflicts.\r\n        \/\/ Store only references to candidate names in the node map.\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Rename vars for the current scope, and merge any referenced\r\n * names into the parent scope reference set.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void visit(NodeTraversal t, Node node, Node parent) {\r\n    if (node.getType() == Token.NAME) {\r\n        String oldName = node.getString();\r\n        if (containsSeparator(oldName)) {\r\n            Scope scope = t.getScope();\r\n            Var var = t.getScope().getVar(oldName);\r\n            if (var == null || var.isGlobal()) {\r\n                return;\r\n            }\r\n            if (nameMap.containsKey(var)) {\r\n                node.setString(nameMap.get(var));\r\n            } else {\r\n                int index = indexOfSeparator(oldName);\r\n                String newName = getOrginalNameInternal(oldName, index);\r\n                String suffix = getNameSuffix(oldName, index);\r\n                                                                                                boolean recurseScopes = false;\r\n                if (!suffix.matches(\"\\\\d+\")) {\r\n                    recurseScopes = true;\r\n                }\r\n                                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\r\n                    newName = oldName;\r\n                } else {\r\n                    var.scope.declare(newName, var.nameNode, null, null);\r\n                                                            Node parentNode = var.getParentNode();\r\n                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\r\n                        var.getNameNode().setString(newName);\r\n                    }\r\n                    node.setString(newName);\r\n                    compiler.reportCodeChange();\r\n                }\r\n                nameMap.put(var, newName);\r\n            }\r\n                                }\r\n    }\r\n}","lc":1.0,"pi":1.5071770335,"ma":0.8,"nbd":1.5,"ml":1.5833333333,"d":0.4444444444,"mi":-0.6738548273,"fo":1.5833333333,"r":-0.0263157895,"e":1.1803092385}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1192_c489d866","label":3,"code":"public static void printDiskUsage(AccumuloConfiguration acuConf, Collection<String> tables, FileSystem fs, Connector conn, Printer printer) throws TableNotFoundException, IOException {\r\n    TableDiskUsage tdu = new TableDiskUsage();\r\n    HashSet<String> tableIds = new HashSet<String>();\r\n    for (String tableName : tables) {\r\n        String tableId = conn.tableOperations().tableIdMap().get(tableName);\r\n        if (tableId == null)\r\n            throw new TableNotFoundException(null, tableName, \"Table \" + tableName + \" not found\");\r\n        tableIds.add(tableId);\r\n    }\r\n    for (String tableId : tableIds) tdu.addTable(tableId);\r\n    HashSet<String> tablesReferenced = new HashSet<String>(tableIds);\r\n    for (String tableId : tableIds) {\r\n        Scanner mdScanner = conn.createScanner(Constants.METADATA_TABLE_NAME, Constants.NO_AUTHS);\r\n        mdScanner.fetchColumnFamily(Constants.METADATA_DATAFILE_COLUMN_FAMILY);\r\n        mdScanner.setRange(new KeyExtent(new Text(tableId), null, null).toMetadataRange());\r\n        for (Entry<Key, Value> entry : mdScanner) {\r\n            String file = entry.getKey().getColumnQualifier().toString();\r\n            if (file.startsWith(\"..\/\")) {\r\n                file = file.substring(2);\r\n                tablesReferenced.add(file.split(\"\\\\\/\")[1]);\r\n            } else\r\n                file = \"\/\" + tableId + file;\r\n            tdu.linkFileAndTable(tableId, file);\r\n        }\r\n    }\r\n    for (String tableId : tablesReferenced) {\r\n        FileStatus[] files = fs.globStatus(new Path(Constants.getTablesDir(acuConf) + \"\/\" + tableId + \"\/*\/*\"));\r\n        for (FileStatus fileStatus : files) {\r\n            String dir = fileStatus.getPath().getParent().getName();\r\n            String name = fileStatus.getPath().getName();\r\n            tdu.addFileSize(\"\/\" + tableId + \"\/\" + dir + \"\/\" + name, fileStatus.getLen());\r\n        }\r\n    }\r\n    HashMap<String, String> reverseTableIdMap = new HashMap<String, String>();\r\n    for (Entry<String, String> entry : conn.tableOperations().tableIdMap().entrySet()) reverseTableIdMap.put(entry.getValue(), entry.getKey());\r\n    TreeMap<TreeSet<String>, Long> usage = new TreeMap<TreeSet<String>, Long>(new Comparator<TreeSet<String>>() {\r\n\r\n        @Override\r\n        public int compare(TreeSet<String> o1, TreeSet<String> o2) {\r\n            int len1 = o1.size();\r\n            int len2 = o2.size();\r\n            int min = Math.min(len1, len2);\r\n            Iterator<String> iter1 = o1.iterator();\r\n            Iterator<String> iter2 = o2.iterator();\r\n            int count = 0;\r\n            while (count < min) {\r\n                String s1 = iter1.next();\r\n                String s2 = iter2.next();\r\n                int cmp = s1.compareTo(s2);\r\n                if (cmp != 0)\r\n                    return cmp;\r\n                count++;\r\n            }\r\n            return len1 - len2;\r\n        }\r\n    });\r\n    for (Entry<List<String>, Long> entry : tdu.calculateUsage().entrySet()) {\r\n        TreeSet<String> tableNames = new TreeSet<String>();\r\n        for (String tableId : entry.getKey()) tableNames.add(reverseTableIdMap.get(tableId));\r\n        usage.put(tableNames, entry.getValue());\r\n    }\r\n    for (Entry<TreeSet<String>, Long> entry : usage.entrySet()) printer.print(String.format(\"%,24d %s\", entry.getValue(), entry.getKey()));\r\n}","code_comment":null,"code_no_comment":"public static void printDiskUsage(AccumuloConfiguration acuConf, Collection<String> tables, FileSystem fs, Connector conn, Printer printer) throws TableNotFoundException, IOException {\r\n    TableDiskUsage tdu = new TableDiskUsage();\r\n    HashSet<String> tableIds = new HashSet<String>();\r\n    for (String tableName : tables) {\r\n        String tableId = conn.tableOperations().tableIdMap().get(tableName);\r\n        if (tableId == null)\r\n            throw new TableNotFoundException(null, tableName, \"Table \" + tableName + \" not found\");\r\n        tableIds.add(tableId);\r\n    }\r\n    for (String tableId : tableIds) tdu.addTable(tableId);\r\n    HashSet<String> tablesReferenced = new HashSet<String>(tableIds);\r\n    for (String tableId : tableIds) {\r\n        Scanner mdScanner = conn.createScanner(Constants.METADATA_TABLE_NAME, Constants.NO_AUTHS);\r\n        mdScanner.fetchColumnFamily(Constants.METADATA_DATAFILE_COLUMN_FAMILY);\r\n        mdScanner.setRange(new KeyExtent(new Text(tableId), null, null).toMetadataRange());\r\n        for (Entry<Key, Value> entry : mdScanner) {\r\n            String file = entry.getKey().getColumnQualifier().toString();\r\n            if (file.startsWith(\"..\/\")) {\r\n                file = file.substring(2);\r\n                tablesReferenced.add(file.split(\"\\\\\/\")[1]);\r\n            } else\r\n                file = \"\/\" + tableId + file;\r\n            tdu.linkFileAndTable(tableId, file);\r\n        }\r\n    }\r\n    for (String tableId : tablesReferenced) {\r\n        FileStatus[] files = fs.globStatus(new Path(Constants.getTablesDir(acuConf) + \"\/\" + tableId + \"\/*\/*\"));\r\n        for (FileStatus fileStatus : files) {\r\n            String dir = fileStatus.getPath().getParent().getName();\r\n            String name = fileStatus.getPath().getName();\r\n            tdu.addFileSize(\"\/\" + tableId + \"\/\" + dir + \"\/\" + name, fileStatus.getLen());\r\n        }\r\n    }\r\n    HashMap<String, String> reverseTableIdMap = new HashMap<String, String>();\r\n    for (Entry<String, String> entry : conn.tableOperations().tableIdMap().entrySet()) reverseTableIdMap.put(entry.getValue(), entry.getKey());\r\n    TreeMap<TreeSet<String>, Long> usage = new TreeMap<TreeSet<String>, Long>(new Comparator<TreeSet<String>>() {\r\n\r\n        @Override\r\n        public int compare(TreeSet<String> o1, TreeSet<String> o2) {\r\n            int len1 = o1.size();\r\n            int len2 = o2.size();\r\n            int min = Math.min(len1, len2);\r\n            Iterator<String> iter1 = o1.iterator();\r\n            Iterator<String> iter2 = o2.iterator();\r\n            int count = 0;\r\n            while (count < min) {\r\n                String s1 = iter1.next();\r\n                String s2 = iter2.next();\r\n                int cmp = s1.compareTo(s2);\r\n                if (cmp != 0)\r\n                    return cmp;\r\n                count++;\r\n            }\r\n            return len1 - len2;\r\n        }\r\n    });\r\n    for (Entry<List<String>, Long> entry : tdu.calculateUsage().entrySet()) {\r\n        TreeSet<String> tableNames = new TreeSet<String>();\r\n        for (String tableId : entry.getKey()) tableNames.add(reverseTableIdMap.get(tableId));\r\n        usage.put(tableNames, entry.getValue());\r\n    }\r\n    for (Entry<TreeSet<String>, Long> entry : usage.entrySet()) printer.print(String.format(\"%,24d %s\", entry.getValue(), entry.getKey()));\r\n}","lc":2.1818181818,"pi":0.7368421053,"ma":2.4,"nbd":0.5,"ml":0.3333333333,"d":1.1428571429,"mi":-1.1330514447,"fo":3.8333333333,"r":-0.0263157895,"e":7.2346858918}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1348_ef0f6ddc","label":1,"code":"public int start() throws IOException {\r\n    if (configError)\r\n        return 1;\r\n    String input;\r\n    if (isVerbose())\r\n        printInfo();\r\n    if (execFile != null) {\r\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\r\n        while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());\r\n    } else if (execCommand != null) {\r\n        for (String command : execCommand.split(\"\\n\")) {\r\n            execCommand(command, true, isVerbose());\r\n        }\r\n        return exitCode;\r\n    }\r\n    while (true) {\r\n        if (hasExited())\r\n            return exitCode;\r\n        reader.setDefaultPrompt(getDefaultPrompt());\r\n        input = reader.readLine();\r\n        if (input == null) {\r\n            reader.printNewline();\r\n            return exitCode;\r\n        }\r\n        \/\/ user canceled\r\n        execCommand(input, false, false);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public int start() throws IOException {\r\n    if (configError)\r\n        return 1;\r\n    String input;\r\n    if (isVerbose())\r\n        printInfo();\r\n    if (execFile != null) {\r\n        java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\r\n        while (scanner.hasNextLine()) execCommand(scanner.nextLine(), true, isVerbose());\r\n    } else if (execCommand != null) {\r\n        for (String command : execCommand.split(\"\\n\")) {\r\n            execCommand(command, true, isVerbose());\r\n        }\r\n        return exitCode;\r\n    }\r\n    while (true) {\r\n        if (hasExited())\r\n            return exitCode;\r\n        reader.setDefaultPrompt(getDefaultPrompt());\r\n        input = reader.readLine();\r\n        if (input == null) {\r\n            reader.printNewline();\r\n            return exitCode;\r\n        }\r\n                execCommand(input, false, false);\r\n    }\r\n}","lc":0.5909090909,"pi":0.1148325359,"ma":1.2,"nbd":0.5,"ml":0.8333333333,"d":0.0,"mi":-0.4356589147,"fo":0.75,"r":-0.0263157895,"e":0.1045924748}
{"project_name":"Codec","project_version":"7","label":1,"code":"\/**\r\n * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\r\n *\r\n * @param binaryData\r\n *            binary data to encode\r\n * @return String containing Base64 characters.\r\n * @since 1.4\r\n *\/\r\npublic static String encodeBase64String(byte[] binaryData) {\r\n    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\r\n}","code_comment":"\/**\r\n * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\r\n *\r\n * @param binaryData\r\n *            binary data to encode\r\n * @return String containing Base64 characters.\r\n * @since 1.4\r\n *\/\r\n","code_no_comment":"public static String encodeBase64String(byte[] binaryData) {\r\n    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.986187456,"fo":-0.3333333333,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4351_59a83d23","label":3,"code":"@Override\r\npublic String getPath() {\r\n    String sub = pathRow.getPath();\r\n    if (isVirtualRow()) {\r\n        return sub;\r\n    } else if (PathUtils.isAbsolute(sub)) {\r\n        return pathPrefix + sub;\r\n    } else {\r\n        return PathUtils.concat(pathPrefix, sub);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String getPath() {\r\n    String sub = pathRow.getPath();\r\n    if (isVirtualRow()) {\r\n        return sub;\r\n    } else if (PathUtils.isAbsolute(sub)) {\r\n        return pathPrefix + sub;\r\n    } else {\r\n        return PathUtils.concat(pathPrefix, sub);\r\n    }\r\n}","lc":-0.1363636364,"pi":-0.019138756,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":-0.0218253968,"mi":0.2250880902,"fo":-0.1666666667,"r":0.3947368421,"e":-0.1009088132}
{"project_name":"Math","project_version":"82","label":1,"code":"\/**\r\n * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\r\n * @param tableau simple tableau for the problem\r\n * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\r\n * @return row with the minimum ratio\r\n *\/\r\nprivate Integer getPivotRow(final int col, final SimplexTableau tableau) {\r\n    double minRatio = Double.MAX_VALUE;\r\n    Integer minRatioPos = null;\r\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\r\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\r\n        final double entry = tableau.getEntry(i, col);\r\n        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\r\n            final double ratio = rhs \/ entry;\r\n            if (ratio < minRatio) {\r\n                minRatio = ratio;\r\n                minRatioPos = i;\r\n            }\r\n        }\r\n    }\r\n    return minRatioPos;\r\n}","code_comment":"\/**\r\n * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\r\n * @param tableau simple tableau for the problem\r\n * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\r\n * @return row with the minimum ratio\r\n *\/\r\n","code_no_comment":"private Integer getPivotRow(final int col, final SimplexTableau tableau) {\r\n    double minRatio = Double.MAX_VALUE;\r\n    Integer minRatioPos = null;\r\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\r\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\r\n        final double entry = tableau.getEntry(i, col);\r\n        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\r\n            final double ratio = rhs \/ entry;\r\n            if (ratio < minRatio) {\r\n                minRatio = ratio;\r\n                minRatioPos = i;\r\n            }\r\n        }\r\n    }\r\n    return minRatioPos;\r\n}","lc":0.0909090909,"pi":0.8995215311,"ma":0.0,"nbd":0.5,"ml":0.4166666667,"d":0.8015873016,"mi":-0.1501057082,"fo":0.0,"r":0.0263157895,"e":0.6479394662}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-644_55a4f738","label":3,"code":"\/**\r\n * @param privilegeNames\r\n * @return\r\n *\/\r\n@Nonnull\r\npublic PrivilegeBits getBits(@Nonnull String... privilegeNames) {\r\n    if (privilegeNames.length == 0) {\r\n        return PrivilegeBits.EMPTY;\r\n    }\r\n    Tree privilegesTree = getPrivilegesTree();\r\n    if (privilegesTree == null) {\r\n        return PrivilegeBits.EMPTY;\r\n    }\r\n    PrivilegeBits bits = PrivilegeBits.getInstance();\r\n    for (String privilegeName : privilegeNames) {\r\n        Tree defTree = privilegesTree.getChild(privilegeName);\r\n        if (defTree != null) {\r\n            bits.add(PrivilegeBits.getInstance(defTree));\r\n        }\r\n    }\r\n    return bits.unmodifiable();\r\n}","code_comment":"\/**\r\n * @param privilegeNames\r\n * @return\r\n *\/\r\n","code_no_comment":"@Nonnull\r\npublic PrivilegeBits getBits(@Nonnull String... privilegeNames) {\r\n    if (privilegeNames.length == 0) {\r\n        return PrivilegeBits.EMPTY;\r\n    }\r\n    Tree privilegesTree = getPrivilegesTree();\r\n    if (privilegesTree == null) {\r\n        return PrivilegeBits.EMPTY;\r\n    }\r\n    PrivilegeBits bits = PrivilegeBits.getInstance();\r\n    for (String privilegeName : privilegeNames) {\r\n        Tree defTree = privilegesTree.getChild(privilegeName);\r\n        if (defTree != null) {\r\n            bits.add(PrivilegeBits.getInstance(defTree));\r\n        }\r\n    }\r\n    return bits.unmodifiable();\r\n}","lc":0.1818181818,"pi":0.0717703349,"ma":0.2,"nbd":0.0,"ml":0.0833333333,"d":0.0317460317,"mi":-0.1571529246,"fo":0.0,"r":0.0263157895,"e":0.0290751082}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-9641_9a6e6d8a","label":1,"code":"private Expression createSimpleExpression(String function, boolean strict) {\r\n    \/\/ return the function directly if we can create function without analyzing the prefix\r\n    Expression answer = createSimpleExpressionDirectly(function);\r\n    if (answer != null) {\r\n        return answer;\r\n    }\r\n    \/\/ body and headers first\r\n    answer = createSimpleExpressionBodyOrHeader(function, strict);\r\n    if (answer != null) {\r\n        return answer;\r\n    }\r\n    \/\/ camelContext OGNL\r\n    String remainder = ifStartsWithReturnRemainder(\"camelContext\", function);\r\n    if (remainder != null) {\r\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\r\n        if (invalid) {\r\n            throw new SimpleParserException(\"Valid syntax: ${camelContext.OGNL} was: \" + function, token.getIndex());\r\n        }\r\n        return ExpressionBuilder.camelContextOgnlExpression(remainder);\r\n    }\r\n    \/\/ Exception OGNL\r\n    remainder = ifStartsWithReturnRemainder(\"exception\", function);\r\n    if (remainder != null) {\r\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\r\n        if (invalid) {\r\n            throw new SimpleParserException(\"Valid syntax: ${exception.OGNL} was: \" + function, token.getIndex());\r\n        }\r\n        return ExpressionBuilder.exchangeExceptionOgnlExpression(remainder);\r\n    }\r\n    \/\/ property\r\n    remainder = ifStartsWithReturnRemainder(\"property\", function);\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"exchangeProperty\", function);\r\n    }\r\n    if (remainder != null) {\r\n        \/\/ remove leading character (dot or ?)\r\n        if (remainder.startsWith(\".\") || remainder.startsWith(\"?\")) {\r\n            remainder = remainder.substring(1);\r\n        }\r\n        \/\/ remove starting and ending brackets\r\n        if (remainder.startsWith(\"[\") && remainder.endsWith(\"]\")) {\r\n            remainder = remainder.substring(1, remainder.length() - 1);\r\n        }\r\n        \/\/ validate syntax\r\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\r\n        if (invalid) {\r\n            throw new SimpleParserException(\"Valid syntax: ${exchangeProperty.OGNL} was: \" + function, token.getIndex());\r\n        }\r\n        if (OgnlHelper.isValidOgnlExpression(remainder)) {\r\n            \/\/ ognl based property\r\n            return ExpressionBuilder.propertyOgnlExpression(remainder);\r\n        } else {\r\n            \/\/ regular property\r\n            return ExpressionBuilder.exchangePropertyExpression(remainder);\r\n        }\r\n    }\r\n    \/\/ system property\r\n    remainder = ifStartsWithReturnRemainder(\"sys.\", function);\r\n    if (remainder != null) {\r\n        return ExpressionBuilder.systemPropertyExpression(remainder);\r\n    }\r\n    remainder = ifStartsWithReturnRemainder(\"sysenv.\", function);\r\n    if (remainder != null) {\r\n        return ExpressionBuilder.systemEnvironmentExpression(remainder);\r\n    }\r\n    \/\/ exchange OGNL\r\n    remainder = ifStartsWithReturnRemainder(\"exchange\", function);\r\n    if (remainder != null) {\r\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\r\n        if (invalid) {\r\n            throw new SimpleParserException(\"Valid syntax: ${exchange.OGNL} was: \" + function, token.getIndex());\r\n        }\r\n        return ExpressionBuilder.exchangeOgnlExpression(remainder);\r\n    }\r\n    \/\/ file: prefix\r\n    remainder = ifStartsWithReturnRemainder(\"file:\", function);\r\n    if (remainder != null) {\r\n        Expression fileExpression = createSimpleFileExpression(remainder);\r\n        if (function != null) {\r\n            return fileExpression;\r\n        }\r\n    }\r\n    \/\/ date: prefix\r\n    remainder = ifStartsWithReturnRemainder(\"date:\", function);\r\n    if (remainder != null) {\r\n        String[] parts = remainder.split(\":\");\r\n        if (parts.length < 2) {\r\n            throw new SimpleParserException(\"Valid syntax: ${date:command:pattern} was: \" + function, token.getIndex());\r\n        }\r\n        String command = ObjectHelper.before(remainder, \":\");\r\n        String pattern = ObjectHelper.after(remainder, \":\");\r\n        return ExpressionBuilder.dateExpression(command, pattern);\r\n    }\r\n    \/\/ bean: prefix\r\n    remainder = ifStartsWithReturnRemainder(\"bean:\", function);\r\n    if (remainder != null) {\r\n        return ExpressionBuilder.beanExpression(remainder);\r\n    }\r\n    \/\/ properties: prefix\r\n    remainder = ifStartsWithReturnRemainder(\"properties:\", function);\r\n    if (remainder != null) {\r\n        String[] parts = remainder.split(\":\");\r\n        if (parts.length > 2) {\r\n            throw new SimpleParserException(\"Valid syntax: ${properties:key[:default]} was: \" + function, token.getIndex());\r\n        }\r\n        return ExpressionBuilder.propertiesComponentExpression(remainder, null);\r\n    }\r\n    \/\/ properties-location: prefix\r\n    remainder = ifStartsWithReturnRemainder(\"properties-location:\", function);\r\n    if (remainder != null) {\r\n        String[] parts = remainder.split(\":\");\r\n        if (parts.length > 3) {\r\n            throw new SimpleParserException(\"Valid syntax: ${properties-location:location:key[:default]} was: \" + function, token.getIndex());\r\n        }\r\n        String locations = null;\r\n        String key = remainder;\r\n        if (parts.length >= 2) {\r\n            locations = ObjectHelper.before(remainder, \":\");\r\n            key = ObjectHelper.after(remainder, \":\");\r\n        }\r\n        return ExpressionBuilder.propertiesComponentExpression(key, locations);\r\n    }\r\n    \/\/ ref: prefix\r\n    remainder = ifStartsWithReturnRemainder(\"ref:\", function);\r\n    if (remainder != null) {\r\n        return ExpressionBuilder.refExpression(remainder);\r\n    }\r\n    \/\/ const: prefix\r\n    remainder = ifStartsWithReturnRemainder(\"type:\", function);\r\n    if (remainder != null) {\r\n        Expression exp = ExpressionBuilder.typeExpression(remainder);\r\n        \/\/ we want to cache this expression so we wont re-evaluate it as the type\/constant wont change\r\n        return ExpressionBuilder.cacheExpression(exp);\r\n    }\r\n    \/\/ random\r\n    remainder = ifStartsWithReturnRemainder(\"random\", function);\r\n    if (remainder != null) {\r\n        String values = ObjectHelper.between(remainder, \"(\", \")\");\r\n        if (values == null || ObjectHelper.isEmpty(values)) {\r\n            throw new SimpleParserException(\"Valid syntax: ${random(min,max)} or ${random(max)} was: \" + function, token.getIndex());\r\n        }\r\n        if (values.contains(\",\")) {\r\n            String[] tokens = values.split(\",\", -1);\r\n            if (tokens.length > 2) {\r\n                throw new SimpleParserException(\"Valid syntax: ${random(min,max)} or ${random(max)} was: \" + function, token.getIndex());\r\n            }\r\n            int min = Integer.parseInt(tokens[0].trim());\r\n            int max = Integer.parseInt(tokens[1].trim());\r\n            return ExpressionBuilder.randomExpression(min, max);\r\n        } else {\r\n            int max = Integer.parseInt(values.trim());\r\n            return ExpressionBuilder.randomExpression(max);\r\n        }\r\n    }\r\n    \/\/ collate function\r\n    remainder = ifStartsWithReturnRemainder(\"collate\", function);\r\n    if (remainder != null) {\r\n        String values = ObjectHelper.between(remainder, \"(\", \")\");\r\n        if (values == null || ObjectHelper.isEmpty(values)) {\r\n            throw new SimpleParserException(\"Valid syntax: ${collate(group)} was: \" + function, token.getIndex());\r\n        }\r\n        String exp = \"${body}\";\r\n        int num = Integer.parseInt(values.trim());\r\n        return ExpressionBuilder.collateExpression(exp, num);\r\n    }\r\n    if (strict) {\r\n        throw new SimpleParserException(\"Unknown function: \" + function, token.getIndex());\r\n    } else {\r\n        return null;\r\n    }\r\n}","code_comment":null,"code_no_comment":"private Expression createSimpleExpression(String function, boolean strict) {\r\n        Expression answer = createSimpleExpressionDirectly(function);\r\n    if (answer != null) {\r\n        return answer;\r\n    }\r\n        answer = createSimpleExpressionBodyOrHeader(function, strict);\r\n    if (answer != null) {\r\n        return answer;\r\n    }\r\n        String remainder = ifStartsWithReturnRemainder(\"camelContext\", function);\r\n    if (remainder != null) {\r\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\r\n        if (invalid) {\r\n            throw new SimpleParserException(\"Valid syntax: ${camelContext.OGNL} was: \" + function, token.getIndex());\r\n        }\r\n        return ExpressionBuilder.camelContextOgnlExpression(remainder);\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"exception\", function);\r\n    if (remainder != null) {\r\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\r\n        if (invalid) {\r\n            throw new SimpleParserException(\"Valid syntax: ${exception.OGNL} was: \" + function, token.getIndex());\r\n        }\r\n        return ExpressionBuilder.exchangeExceptionOgnlExpression(remainder);\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"property\", function);\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"exchangeProperty\", function);\r\n    }\r\n    if (remainder != null) {\r\n                if (remainder.startsWith(\".\") || remainder.startsWith(\"?\")) {\r\n            remainder = remainder.substring(1);\r\n        }\r\n                if (remainder.startsWith(\"[\") && remainder.endsWith(\"]\")) {\r\n            remainder = remainder.substring(1, remainder.length() - 1);\r\n        }\r\n                boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\r\n        if (invalid) {\r\n            throw new SimpleParserException(\"Valid syntax: ${exchangeProperty.OGNL} was: \" + function, token.getIndex());\r\n        }\r\n        if (OgnlHelper.isValidOgnlExpression(remainder)) {\r\n                        return ExpressionBuilder.propertyOgnlExpression(remainder);\r\n        } else {\r\n                        return ExpressionBuilder.exchangePropertyExpression(remainder);\r\n        }\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"sys.\", function);\r\n    if (remainder != null) {\r\n        return ExpressionBuilder.systemPropertyExpression(remainder);\r\n    }\r\n    remainder = ifStartsWithReturnRemainder(\"sysenv.\", function);\r\n    if (remainder != null) {\r\n        return ExpressionBuilder.systemEnvironmentExpression(remainder);\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"exchange\", function);\r\n    if (remainder != null) {\r\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\r\n        if (invalid) {\r\n            throw new SimpleParserException(\"Valid syntax: ${exchange.OGNL} was: \" + function, token.getIndex());\r\n        }\r\n        return ExpressionBuilder.exchangeOgnlExpression(remainder);\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"file:\", function);\r\n    if (remainder != null) {\r\n        Expression fileExpression = createSimpleFileExpression(remainder);\r\n        if (function != null) {\r\n            return fileExpression;\r\n        }\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"date:\", function);\r\n    if (remainder != null) {\r\n        String[] parts = remainder.split(\":\");\r\n        if (parts.length < 2) {\r\n            throw new SimpleParserException(\"Valid syntax: ${date:command:pattern} was: \" + function, token.getIndex());\r\n        }\r\n        String command = ObjectHelper.before(remainder, \":\");\r\n        String pattern = ObjectHelper.after(remainder, \":\");\r\n        return ExpressionBuilder.dateExpression(command, pattern);\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"bean:\", function);\r\n    if (remainder != null) {\r\n        return ExpressionBuilder.beanExpression(remainder);\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"properties:\", function);\r\n    if (remainder != null) {\r\n        String[] parts = remainder.split(\":\");\r\n        if (parts.length > 2) {\r\n            throw new SimpleParserException(\"Valid syntax: ${properties:key[:default]} was: \" + function, token.getIndex());\r\n        }\r\n        return ExpressionBuilder.propertiesComponentExpression(remainder, null);\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"properties-location:\", function);\r\n    if (remainder != null) {\r\n        String[] parts = remainder.split(\":\");\r\n        if (parts.length > 3) {\r\n            throw new SimpleParserException(\"Valid syntax: ${properties-location:location:key[:default]} was: \" + function, token.getIndex());\r\n        }\r\n        String locations = null;\r\n        String key = remainder;\r\n        if (parts.length >= 2) {\r\n            locations = ObjectHelper.before(remainder, \":\");\r\n            key = ObjectHelper.after(remainder, \":\");\r\n        }\r\n        return ExpressionBuilder.propertiesComponentExpression(key, locations);\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"ref:\", function);\r\n    if (remainder != null) {\r\n        return ExpressionBuilder.refExpression(remainder);\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"type:\", function);\r\n    if (remainder != null) {\r\n        Expression exp = ExpressionBuilder.typeExpression(remainder);\r\n                return ExpressionBuilder.cacheExpression(exp);\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"random\", function);\r\n    if (remainder != null) {\r\n        String values = ObjectHelper.between(remainder, \"(\", \")\");\r\n        if (values == null || ObjectHelper.isEmpty(values)) {\r\n            throw new SimpleParserException(\"Valid syntax: ${random(min,max)} or ${random(max)} was: \" + function, token.getIndex());\r\n        }\r\n        if (values.contains(\",\")) {\r\n            String[] tokens = values.split(\",\", -1);\r\n            if (tokens.length > 2) {\r\n                throw new SimpleParserException(\"Valid syntax: ${random(min,max)} or ${random(max)} was: \" + function, token.getIndex());\r\n            }\r\n            int min = Integer.parseInt(tokens[0].trim());\r\n            int max = Integer.parseInt(tokens[1].trim());\r\n            return ExpressionBuilder.randomExpression(min, max);\r\n        } else {\r\n            int max = Integer.parseInt(values.trim());\r\n            return ExpressionBuilder.randomExpression(max);\r\n        }\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"collate\", function);\r\n    if (remainder != null) {\r\n        String values = ObjectHelper.between(remainder, \"(\", \")\");\r\n        if (values == null || ObjectHelper.isEmpty(values)) {\r\n            throw new SimpleParserException(\"Valid syntax: ${collate(group)} was: \" + function, token.getIndex());\r\n        }\r\n        String exp = \"${body}\";\r\n        int num = Integer.parseInt(values.trim());\r\n        return ExpressionBuilder.collateExpression(exp, num);\r\n    }\r\n    if (strict) {\r\n        throw new SimpleParserException(\"Unknown function: \" + function, token.getIndex());\r\n    } else {\r\n        return null;\r\n    }\r\n}","lc":6.1363636364,"pi":0.009569378,"ma":8.6,"nbd":0.5,"ml":4.0833333333,"d":3.5734126984,"mi":-1.8002818887,"fo":6.1666666667,"r":-0.0263157895,"e":30.1207724624}
{"project_name":"JxPath","project_version":"4","label":1,"code":"public Object getValue() {\r\n    return stringValue(node);\r\n}","code_comment":null,"code_no_comment":"public Object getValue() {\r\n    return stringValue(node);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.4166666667,"r":2.3947368421,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7055_15e1077d","label":1,"code":"public void close() throws IOException {\r\n    currentStream.close();\r\n    cleanUpTempFile();\r\n}","code_comment":null,"code_no_comment":"public void close() throws IOException {\r\n    currentStream.close();\r\n    cleanUpTempFile();\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9517970402,"fo":-0.3333333333,"r":1.6052631579,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2734_8b40bb7a","label":0,"code":"\/**\r\n *  Getter of the {@link org.apache.flink.streaming.api.graph.StreamGraph} of the streaming job.\r\n *\r\n *  @return The streamgraph representing the transformations\r\n *\/\r\npublic StreamGraph getStreamGraph() {\r\n    if (transformations.size() <= 0) {\r\n        throw new IllegalStateException(\"No operators defined in streaming topology. Cannot execute.\");\r\n    }\r\n    StreamGraph result = StreamGraphGenerator.generate(this, transformations);\r\n    return result;\r\n}","code_comment":"\/**\r\n *  Getter of the {@link org.apache.flink.streaming.api.graph.StreamGraph} of the streaming job.\r\n *\r\n *  @return The streamgraph representing the transformations\r\n *\/\r\n","code_no_comment":"public StreamGraph getStreamGraph() {\r\n    if (transformations.size() <= 0) {\r\n        throw new IllegalStateException(\"No operators defined in streaming topology. Cannot execute.\");\r\n    }\r\n    StreamGraph result = StreamGraphGenerator.generate(this, transformations);\r\n    return result;\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.1130952381,"mi":0.4711768851,"fo":-0.3333333333,"r":0.7368421053,"e":-0.1280544942}
{"project_name":"Math","project_version":"46","label":3,"code":"\/**\r\n * Returns a {@code Complex} whose value is {@code (this \/ divisor)},\r\n * with {@code divisor} interpreted as a real number.\r\n *\r\n * @param  divisor Value by which this {@code Complex} is to be divided.\r\n * @return {@code this \/ divisor}.\r\n * @see #divide(Complex)\r\n *\/\r\npublic Complex divide(double divisor) {\r\n    if (isNaN || Double.isNaN(divisor)) {\r\n        return NaN;\r\n    }\r\n    if (divisor == 0d) {\r\n        \/\/ return isZero ? NaN : INF; \/\/ See MATH-657\r\n        return isZero ? NaN : INF;\r\n    }\r\n    if (Double.isInfinite(divisor)) {\r\n        return !isInfinite() ? ZERO : NaN;\r\n    }\r\n    return createComplex(real \/ divisor, imaginary \/ divisor);\r\n}","code_comment":"\/**\r\n * Returns a {@code Complex} whose value is {@code (this \/ divisor)},\r\n * with {@code divisor} interpreted as a real number.\r\n *\r\n * @param  divisor Value by which this {@code Complex} is to be divided.\r\n * @return {@code this \/ divisor}.\r\n * @see #divide(Complex)\r\n *\/\r\n","code_no_comment":"public Complex divide(double divisor) {\r\n    if (isNaN || Double.isNaN(divisor)) {\r\n        return NaN;\r\n    }\r\n    if (divisor == 0d) {\r\n                return isZero ? NaN : INF;\r\n    }\r\n    if (Double.isInfinite(divisor)) {\r\n        return !isInfinite() ? ZERO : NaN;\r\n    }\r\n    return createComplex(real \/ divisor, imaginary \/ divisor);\r\n}","lc":-0.0909090909,"pi":-0.2057416268,"ma":0.4,"nbd":-0.5,"ml":0.5833333333,"d":0.2956349206,"mi":0.0934460888,"fo":-0.1666666667,"r":0.4210526316,"e":0.0330492211}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-327_262fe4c0","label":0,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic int getRank() {\r\n    final double threshold = FastMath.max(m, n) * FastMath.ulp(singularValues[0]);\r\n    for (int i = singularValues.length - 1; i >= 0; --i) {\r\n        if (singularValues[i] > threshold) {\r\n            return i + 1;\r\n        }\r\n    }\r\n    return 0;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public int getRank() {\r\n    final double threshold = FastMath.max(m, n) * FastMath.ulp(singularValues[0]);\r\n    for (int i = singularValues.length - 1; i >= 0; --i) {\r\n        if (singularValues[i] > threshold) {\r\n            return i + 1;\r\n        }\r\n    }\r\n    return 0;\r\n}","lc":-0.2272727273,"pi":0.3205741627,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":0.7341269841,"mi":0.2321353066,"fo":-0.3333333333,"r":2.0789473684,"e":0.1903494061}
{"project_name":"Closure","project_version":"3","label":1,"code":"@Override\r\npublic void enterScope(NodeTraversal t) {\r\n    if (t.inGlobalScope()) {\r\n        \/\/ Don't even brother. All global variables are likely escaped.\r\n        return;\r\n    }\r\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\r\n        return;\r\n    }\r\n    \/\/ Compute the forward reaching definition.\r\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\r\n    \/\/ Process the body of the function.\r\n    Preconditions.checkState(t.getScopeRoot().isFunction());\r\n    cfa.process(null, t.getScopeRoot().getLastChild());\r\n    cfg = cfa.getCfg();\r\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\r\n    reachingDef.analyze();\r\n    candidates = Lists.newLinkedList();\r\n    \/\/ Using the forward reaching definition search to find all the inline\r\n    \/\/ candidates\r\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\r\n    \/\/ Compute the backward reaching use. The CFG can be reused.\r\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\r\n    reachingUses.analyze();\r\n    for (Candidate c : candidates) {\r\n        if (c.canInline()) {\r\n            c.inlineVariable();\r\n            \/\/ so that we can back off appropriately.\r\n            if (!c.defMetadata.depends.isEmpty()) {\r\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void enterScope(NodeTraversal t) {\r\n    if (t.inGlobalScope()) {\r\n                return;\r\n    }\r\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\r\n        return;\r\n    }\r\n        ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\r\n        Preconditions.checkState(t.getScopeRoot().isFunction());\r\n    cfa.process(null, t.getScopeRoot().getLastChild());\r\n    cfg = cfa.getCfg();\r\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\r\n    reachingDef.analyze();\r\n    candidates = Lists.newLinkedList();\r\n            new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\r\n        reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\r\n    reachingUses.analyze();\r\n    for (Candidate c : candidates) {\r\n        if (c.canInline()) {\r\n            c.inlineVariable();\r\n                        if (!c.defMetadata.depends.isEmpty()) {\r\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\r\n            }\r\n        }\r\n    }\r\n}","lc":0.5909090909,"pi":0.3827751196,"ma":0.4,"nbd":0.5,"ml":0.25,"d":-0.0297619048,"mi":-0.4661028894,"fo":1.5,"r":-0.0263157895,"e":0.1981454908}
{"project_name":"Lang","project_version":"55","label":1,"code":"\/**\r\n * <p>Stop the stopwatch.<\/p>\r\n *\r\n * <p>This method ends a new timing session, allowing the time to be retrieved.<\/p>\r\n *\r\n * @throws IllegalStateException if the StopWatch is not running.\r\n *\/\r\npublic void stop() {\r\n    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\r\n        throw new IllegalStateException(\"Stopwatch is not running. \");\r\n    }\r\n    stopTime = System.currentTimeMillis();\r\n    this.runningState = STATE_STOPPED;\r\n}","code_comment":"\/**\r\n * <p>Stop the stopwatch.<\/p>\r\n *\r\n * <p>This method ends a new timing session, allowing the time to be retrieved.<\/p>\r\n *\r\n * @throws IllegalStateException if the StopWatch is not running.\r\n *\/\r\n","code_no_comment":"public void stop() {\r\n    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\r\n        throw new IllegalStateException(\"Stopwatch is not running. \");\r\n    }\r\n    stopTime = System.currentTimeMillis();\r\n    this.runningState = STATE_STOPPED;\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":-0.130952381,"mi":0.4497533474,"fo":-0.4166666667,"r":2.3157894737,"e":-0.1254542625}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2345_a0dc4c89","label":1,"code":"\/**\r\n * Perform a background read and make external changes visible.\r\n *\r\n * @param dispatchChange whether to dispatch external changes\r\n *                       to {@link #dispatcher}.\r\n *\/\r\nvoid backgroundRead(boolean dispatchChange) {\r\n    String id = Utils.getIdFromPath(\"\/\");\r\n    NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);\r\n    if (doc == null) {\r\n        return;\r\n    }\r\n    Map<Integer, Revision> lastRevMap = doc.getLastRev();\r\n    Revision.RevisionComparator revisionComparator = getRevisionComparator();\r\n    \/\/ the (old) head occurred first\r\n    Revision headSeen = Revision.newRevision(0);\r\n    \/\/ then we saw this new revision (from another cluster node)\r\n    Revision otherSeen = Revision.newRevision(0);\r\n    Map<Revision, Revision> externalChanges = Maps.newHashMap();\r\n    for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {\r\n        int machineId = e.getKey();\r\n        if (machineId == clusterId) {\r\n            \/\/ ignore own lastRev\r\n            continue;\r\n        }\r\n        Revision r = e.getValue();\r\n        Revision last = lastKnownRevision.get(machineId);\r\n        if (last == null || r.compareRevisionTime(last) > 0) {\r\n            lastKnownRevision.put(machineId, r);\r\n            externalChanges.put(r, otherSeen);\r\n        }\r\n    }\r\n    if (!externalChanges.isEmpty()) {\r\n        \/\/ invalidate caches\r\n        store.invalidateCache();\r\n        \/\/ TODO only invalidate affected items\r\n        docChildrenCache.invalidateAll();\r\n        \/\/ make sure update to revision comparator is atomic\r\n        \/\/ and no local commit is in progress\r\n        backgroundOperationLock.writeLock().lock();\r\n        try {\r\n            \/\/ the latest revisions of the current cluster node\r\n            \/\/ happened before the latest revisions of other cluster nodes\r\n            revisionComparator.add(newRevision(), headSeen);\r\n            \/\/ then we saw other revisions\r\n            for (Map.Entry<Revision, Revision> e : externalChanges.entrySet()) {\r\n                revisionComparator.add(e.getKey(), e.getValue());\r\n            }\r\n            \/\/ the new head revision is after other revisions\r\n            setHeadRevision(newRevision());\r\n            if (dispatchChange) {\r\n                dispatcher.contentChanged(getRoot(), null);\r\n            }\r\n        } finally {\r\n            backgroundOperationLock.writeLock().unlock();\r\n        }\r\n    }\r\n    revisionComparator.purge(Revision.getCurrentTimestamp() - REMEMBER_REVISION_ORDER_MILLIS);\r\n}","code_comment":"\/**\r\n * Perform a background read and make external changes visible.\r\n *\r\n * @param dispatchChange whether to dispatch external changes\r\n *                       to {@link #dispatcher}.\r\n *\/\r\n","code_no_comment":"void backgroundRead(boolean dispatchChange) {\r\n    String id = Utils.getIdFromPath(\"\/\");\r\n    NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);\r\n    if (doc == null) {\r\n        return;\r\n    }\r\n    Map<Integer, Revision> lastRevMap = doc.getLastRev();\r\n    Revision.RevisionComparator revisionComparator = getRevisionComparator();\r\n        Revision headSeen = Revision.newRevision(0);\r\n        Revision otherSeen = Revision.newRevision(0);\r\n    Map<Revision, Revision> externalChanges = Maps.newHashMap();\r\n    for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {\r\n        int machineId = e.getKey();\r\n        if (machineId == clusterId) {\r\n                        continue;\r\n        }\r\n        Revision r = e.getValue();\r\n        Revision last = lastKnownRevision.get(machineId);\r\n        if (last == null || r.compareRevisionTime(last) > 0) {\r\n            lastKnownRevision.put(machineId, r);\r\n            externalChanges.put(r, otherSeen);\r\n        }\r\n    }\r\n    if (!externalChanges.isEmpty()) {\r\n                store.invalidateCache();\r\n                docChildrenCache.invalidateAll();\r\n                        backgroundOperationLock.writeLock().lock();\r\n        try {\r\n                                    revisionComparator.add(newRevision(), headSeen);\r\n                        for (Map.Entry<Revision, Revision> e : externalChanges.entrySet()) {\r\n                revisionComparator.add(e.getKey(), e.getValue());\r\n            }\r\n                        setHeadRevision(newRevision());\r\n            if (dispatchChange) {\r\n                dispatcher.contentChanged(getRoot(), null);\r\n            }\r\n        } finally {\r\n            backgroundOperationLock.writeLock().unlock();\r\n        }\r\n    }\r\n    revisionComparator.purge(Revision.getCurrentTimestamp() - REMEMBER_REVISION_ORDER_MILLIS);\r\n}","lc":1.2727272727,"pi":0.4258373206,"ma":1.0,"nbd":0.5,"ml":0.6666666667,"d":0.8253968254,"mi":-0.7725158562,"fo":2.25,"r":-0.0263157895,"e":2.1278493341}
{"project_name":"Time","project_version":"20","label":2,"code":"public int parseInto(DateTimeParserBucket bucket, String text, int position) {\r\n    String str = text.substring(position);\r\n    for (String id : ALL_IDS) {\r\n        if (str.startsWith(id)) {\r\n            bucket.setZone(DateTimeZone.forID(id));\r\n            return position + id.length();\r\n        }\r\n    }\r\n    return ~position;\r\n}","code_comment":null,"code_no_comment":"public int parseInto(DateTimeParserBucket bucket, String text, int position) {\r\n    String str = text.substring(position);\r\n    for (String id : ALL_IDS) {\r\n        if (str.startsWith(id)) {\r\n            bucket.setZone(DateTimeZone.forID(id));\r\n            return position + id.length();\r\n        }\r\n    }\r\n    return ~position;\r\n}","lc":-0.1818181818,"pi":0.5215311005,"ma":-0.2,"nbd":0.0,"ml":-0.1666666667,"d":-0.0297619048,"mi":0.1960535588,"fo":-0.0833333333,"r":0.0263157895,"e":-0.0636480467}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2065_9da430fb","label":1,"code":"\/**\r\n *  @see java.lang.Object#toString()\r\n *\/\r\npublic String toString() {\r\n    return \"PackageEncoder[package=\" + packageName + \"]\";\r\n}","code_comment":"\/**\r\n *  @see java.lang.Object#toString()\r\n *\/\r\n","code_no_comment":"public String toString() {\r\n    return \"PackageEncoder[package=\" + packageName + \"]\";\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0329809725,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3433_b76b31f7","label":0,"code":"void acquiring();","code_comment":null,"code_no_comment":"void acquiring();","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.8696264975,"fo":-0.5,"r":2.2368421053,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-776_dc9f23d9","label":3,"code":"\/**\r\n * A convenience method for setting the start timestamp accepted by the timestamp filter.\r\n *\r\n * @param is\r\n *          the iterator setting object to configure\r\n * @param start\r\n *          the start timestamp (yyyyMMddHHmmssz)\r\n * @param startInclusive\r\n *          boolean indicating whether the start is inclusive\r\n *\/\r\npublic static void setStart(IteratorSetting is, String start, boolean startInclusive) {\r\n    is.addOption(START, start);\r\n    is.addOption(START_INCL, Boolean.toString(startInclusive));\r\n}","code_comment":"\/**\r\n * A convenience method for setting the start timestamp accepted by the timestamp filter.\r\n *\r\n * @param is\r\n *          the iterator setting object to configure\r\n * @param start\r\n *          the start timestamp (yyyyMMddHHmmssz)\r\n * @param startInclusive\r\n *          boolean indicating whether the start is inclusive\r\n *\/\r\n","code_no_comment":"public static void setStart(IteratorSetting is, String start, boolean startInclusive) {\r\n    is.addOption(START, start);\r\n    is.addOption(START_INCL, Boolean.toString(startInclusive));\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7355884426,"fo":-0.25,"r":2.0789473684,"e":-0.1627934049}
{"project_name":"Closure","project_version":"75","label":2,"code":"static Double getStringNumberValue(String rawJsString) {\r\n    \/\/ vertical tab is not always whitespace\r\n    String s = trimJsWhiteSpace(rawJsString);\r\n    \/\/ return ScriptRuntime.toNumber(s);\r\n    if (s.length() == 0) {\r\n        return 0.0;\r\n    }\r\n    if (s.length() > 2 && s.charAt(0) == '0' && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\r\n        \/\/ Attempt to convert hex numbers.\r\n        try {\r\n            return Double.valueOf(Integer.parseInt(s.substring(2), 16));\r\n        } catch (NumberFormatException e) {\r\n            return Double.NaN;\r\n        }\r\n    }\r\n    if (s.length() > 3 && (s.charAt(0) == '-' || s.charAt(0) == '+') && s.charAt(1) == '0' && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\r\n        \/\/ hex numbers with explicit signs vary between browsers.\r\n        return null;\r\n    }\r\n    \/\/ insensitive, but IE treats \"infinity\" as NaN.  So leave it alone.\r\n    if (s.equals(\"infinity\") || s.equals(\"-infinity\") || s.equals(\"+infinity\")) {\r\n        return null;\r\n    }\r\n    try {\r\n        return Double.parseDouble(s);\r\n    } catch (NumberFormatException e) {\r\n        return Double.NaN;\r\n    }\r\n}","code_comment":null,"code_no_comment":"static Double getStringNumberValue(String rawJsString) {\r\n        String s = trimJsWhiteSpace(rawJsString);\r\n        if (s.length() == 0) {\r\n        return 0.0;\r\n    }\r\n    if (s.length() > 2 && s.charAt(0) == '0' && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\r\n                try {\r\n            return Double.valueOf(Integer.parseInt(s.substring(2), 16));\r\n        } catch (NumberFormatException e) {\r\n            return Double.NaN;\r\n        }\r\n    }\r\n    if (s.length() > 3 && (s.charAt(0) == '-' || s.charAt(0) == '+') && s.charAt(1) == '0' && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\r\n                return null;\r\n    }\r\n        if (s.equals(\"infinity\") || s.equals(\"-infinity\") || s.equals(\"+infinity\")) {\r\n        return null;\r\n    }\r\n    try {\r\n        return Double.parseDouble(s);\r\n    } catch (NumberFormatException e) {\r\n        return Double.NaN;\r\n    }\r\n}","lc":0.4545454545,"pi":0.023923445,"ma":0.6,"nbd":0.0,"ml":1.3333333333,"d":0.6388888889,"mi":-0.4390415786,"fo":1.0833333333,"r":-0.0263157895,"e":1.077401843}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-793_73400bfb","label":3,"code":"private static org.apache.logging.log4j.Marker getMarker(final Marker marker) {\r\n    return marker != null ? ((org.apache.logging.slf4j.Log4jMarker) marker).getLog4jMarker() : null;\r\n}","code_comment":null,"code_no_comment":"private static org.apache.logging.log4j.Marker getMarker(final Marker marker) {\r\n    return marker != null ? ((org.apache.logging.slf4j.Log4jMarker) marker).getLog4jMarker() : null;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.3650793651,"mi":0.8319943622,"fo":-0.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_add180fb","label":1,"code":"@Override\r\npublic void checkIteratorConflicts(String tableName, IteratorSetting setting) throws AccumuloException, TableNotFoundException {\r\n    for (IteratorScope scope : setting.getScopes()) {\r\n        String scopeStr = String.format(\"%s%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase());\r\n        String nameStr = String.format(\"%s.%s\", scopeStr, setting.getName());\r\n        String optStr = String.format(\"%s.opt.\", nameStr);\r\n        Map<String, String> optionConflicts = new TreeMap<String, String>();\r\n        for (Entry<String, String> property : this.getProperties(tableName)) {\r\n            if (property.getKey().startsWith(scopeStr)) {\r\n                if (property.getKey().equals(nameStr))\r\n                    throw new IllegalArgumentException(\"iterator name conflict for \" + setting.getName() + \": \" + property.getKey() + \"=\" + property.getValue());\r\n                if (property.getKey().startsWith(optStr))\r\n                    optionConflicts.put(property.getKey(), property.getValue());\r\n                if (property.getKey().contains(\".opt.\"))\r\n                    continue;\r\n                String[] parts = property.getValue().split(\",\");\r\n                if (parts.length != 2)\r\n                    throw new AccumuloException(\"Bad value for existing iterator setting: \" + property.getKey() + \"=\" + property.getValue());\r\n                try {\r\n                    if (Integer.parseInt(parts[0]) == setting.getPriority())\r\n                        throw new IllegalArgumentException(\"iterator priority conflict: \" + property.getKey() + \"=\" + property.getValue());\r\n                } catch (NumberFormatException e) {\r\n                    throw new AccumuloException(\"Bad value for existing iterator setting: \" + property.getKey() + \"=\" + property.getValue());\r\n                }\r\n            }\r\n        }\r\n        if (optionConflicts.size() > 0)\r\n            throw new IllegalArgumentException(\"iterator options conflict for \" + setting.getName() + \": \" + optionConflicts);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void checkIteratorConflicts(String tableName, IteratorSetting setting) throws AccumuloException, TableNotFoundException {\r\n    for (IteratorScope scope : setting.getScopes()) {\r\n        String scopeStr = String.format(\"%s%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase());\r\n        String nameStr = String.format(\"%s.%s\", scopeStr, setting.getName());\r\n        String optStr = String.format(\"%s.opt.\", nameStr);\r\n        Map<String, String> optionConflicts = new TreeMap<String, String>();\r\n        for (Entry<String, String> property : this.getProperties(tableName)) {\r\n            if (property.getKey().startsWith(scopeStr)) {\r\n                if (property.getKey().equals(nameStr))\r\n                    throw new IllegalArgumentException(\"iterator name conflict for \" + setting.getName() + \": \" + property.getKey() + \"=\" + property.getValue());\r\n                if (property.getKey().startsWith(optStr))\r\n                    optionConflicts.put(property.getKey(), property.getValue());\r\n                if (property.getKey().contains(\".opt.\"))\r\n                    continue;\r\n                String[] parts = property.getValue().split(\",\");\r\n                if (parts.length != 2)\r\n                    throw new AccumuloException(\"Bad value for existing iterator setting: \" + property.getKey() + \"=\" + property.getValue());\r\n                try {\r\n                    if (Integer.parseInt(parts[0]) == setting.getPriority())\r\n                        throw new IllegalArgumentException(\"iterator priority conflict: \" + property.getKey() + \"=\" + property.getValue());\r\n                } catch (NumberFormatException e) {\r\n                    throw new AccumuloException(\"Bad value for existing iterator setting: \" + property.getKey() + \"=\" + property.getValue());\r\n                }\r\n            }\r\n        }\r\n        if (optionConflicts.size() > 0)\r\n            throw new IllegalArgumentException(\"iterator options conflict for \" + setting.getName() + \": \" + optionConflicts);\r\n    }\r\n}","lc":0.7272727273,"pi":1.7464114833,"ma":2.6,"nbd":1.0,"ml":1.0833333333,"d":0.5496031746,"mi":-0.67329105,"fo":2.3333333333,"r":-0.0263157895,"e":1.6260046219}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  This returns a page instance that is rollbacked the number of versions\r\n *  that is specified compared to the current page.\r\n *\r\n *  This is a rollback including ajax versions.\r\n *\r\n *  @param numberOfVersions to rollback\r\n *  @return\r\n *\/\r\npublic final Page rollbackPage(int numberOfVersions) {\r\n    Page page = versionManager == null ? this : versionManager.rollbackPage(numberOfVersions);\r\n    getSession().touch(page);\r\n    return page;\r\n}","code_comment":"\/**\r\n *  This returns a page instance that is rollbacked the number of versions\r\n *  that is specified compared to the current page.\r\n *\r\n *  This is a rollback including ajax versions.\r\n *\r\n *  @param numberOfVersions to rollback\r\n *  @return\r\n *\/\r\n","code_no_comment":"public final Page rollbackPage(int numberOfVersions) {\r\n    Page page = versionManager == null ? this : versionManager.rollbackPage(numberOfVersions);\r\n    getSession().touch(page);\r\n    return page;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.0337301587,"mi":0.6324171952,"fo":-0.25,"r":2.5789473684,"e":-0.1176028538}
{"project_name":"Closure","project_version":"86","label":0,"code":"\/**\r\n * @param locals A predicate to apply to unknown local values.\r\n * @return Whether the node is known to be a value that is not a reference\r\n *     outside the expression scope.\r\n *\/\r\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\r\n    switch(value.getType()) {\r\n        case Token.ASSIGN:\r\n            \/\/ value is immutable.\r\n            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals));\r\n        case Token.COMMA:\r\n            return evaluatesToLocalValue(value.getLastChild(), locals);\r\n        case Token.AND:\r\n        case Token.OR:\r\n            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\r\n        case Token.HOOK:\r\n            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\r\n        case Token.INC:\r\n        case Token.DEC:\r\n            if (value.getBooleanProp(Node.INCRDECR_PROP)) {\r\n                return evaluatesToLocalValue(value.getFirstChild(), locals);\r\n            } else {\r\n                return true;\r\n            }\r\n        case Token.THIS:\r\n            return locals.apply(value);\r\n        case Token.NAME:\r\n            return isImmutableValue(value) || locals.apply(value);\r\n        case Token.GETELEM:\r\n        case Token.GETPROP:\r\n            \/\/ There is no information about the locality of object properties.\r\n            return locals.apply(value);\r\n        case Token.CALL:\r\n            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value);\r\n        case Token.NEW:\r\n            \/\/ the constructor (similar to callHasLocalResult)\r\n            return true;\r\n        case Token.FUNCTION:\r\n        case Token.REGEXP:\r\n        case Token.ARRAYLIT:\r\n        case Token.OBJECTLIT:\r\n            \/\/ Literals objects with non-literal children are allowed.\r\n            return true;\r\n        case Token.IN:\r\n            \/\/ TODO(johnlenz): should IN operator be included in #isSimpleOperator?\r\n            return true;\r\n        default:\r\n            \/\/ x -= g (x is now an local number)\r\n            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {\r\n                return true;\r\n            }\r\n            throw new IllegalStateException(\"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent());\r\n    }\r\n}","code_comment":"\/**\r\n * @param locals A predicate to apply to unknown local values.\r\n * @return Whether the node is known to be a value that is not a reference\r\n *     outside the expression scope.\r\n *\/\r\n","code_no_comment":"static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\r\n    switch(value.getType()) {\r\n        case Token.ASSIGN:\r\n                        return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals));\r\n        case Token.COMMA:\r\n            return evaluatesToLocalValue(value.getLastChild(), locals);\r\n        case Token.AND:\r\n        case Token.OR:\r\n            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\r\n        case Token.HOOK:\r\n            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\r\n        case Token.INC:\r\n        case Token.DEC:\r\n            if (value.getBooleanProp(Node.INCRDECR_PROP)) {\r\n                return evaluatesToLocalValue(value.getFirstChild(), locals);\r\n            } else {\r\n                return true;\r\n            }\r\n        case Token.THIS:\r\n            return locals.apply(value);\r\n        case Token.NAME:\r\n            return isImmutableValue(value) || locals.apply(value);\r\n        case Token.GETELEM:\r\n        case Token.GETPROP:\r\n                        return locals.apply(value);\r\n        case Token.CALL:\r\n            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value);\r\n        case Token.NEW:\r\n                        return true;\r\n        case Token.FUNCTION:\r\n        case Token.REGEXP:\r\n        case Token.ARRAYLIT:\r\n        case Token.OBJECTLIT:\r\n                        return true;\r\n        case Token.IN:\r\n                        return true;\r\n        default:\r\n                        if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {\r\n                return true;\r\n            }\r\n            throw new IllegalStateException(\"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent());\r\n    }\r\n}","lc":1.3181818182,"pi":0.2296650718,"ma":3.8,"nbd":0.5,"ml":1.9166666667,"d":0.1884920635,"mi":-0.850880902,"fo":2.0833333333,"r":-0.0263157895,"e":0.7468589178}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-812_6eb46555","label":1,"code":"\/**\r\n * Compute the dot product of this vector with {@code v}.\r\n *\r\n * @param v Vector with which dot product should be computed\r\n * @return the scalar dot product between this instance and {@code v}.\r\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\r\n * if {@code v} is not the same size as this vector.\r\n *\/\r\npublic double dotProduct(RealVector v) {\r\n    checkVectorDimensions(v);\r\n    double d = 0;\r\n    Iterator<Entry> it = sparseIterator();\r\n    while (it.hasNext()) {\r\n        final Entry e = it.next();\r\n        d += e.getValue() * v.getEntry(e.getIndex());\r\n    }\r\n    return d;\r\n}","code_comment":"\/**\r\n * Compute the dot product of this vector with {@code v}.\r\n *\r\n * @param v Vector with which dot product should be computed\r\n * @return the scalar dot product between this instance and {@code v}.\r\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\r\n * if {@code v} is not the same size as this vector.\r\n *\/\r\n","code_no_comment":"public double dotProduct(RealVector v) {\r\n    checkVectorDimensions(v);\r\n    double d = 0;\r\n    Iterator<Entry> it = sparseIterator();\r\n    while (it.hasNext()) {\r\n        final Entry e = it.next();\r\n        d += e.getValue() * v.getEntry(e.getIndex());\r\n    }\r\n    return d;\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0615079365,"mi":0.1952078929,"fo":0.0833333333,"r":1.9473684211,"e":-0.0683229313}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-519_26a61077","label":1,"code":"\/**\r\n * Factory method creating <code>Comparator<\/code> for comparing\r\n * <code>WeightedObservedPoint<\/code> instances.\r\n *\r\n * @return new <code>Comparator<\/code> instance\r\n *\/\r\nprivate Comparator<WeightedObservedPoint> createWeightedObservedPointComparator() {\r\n    return new Comparator<WeightedObservedPoint>() {\r\n\r\n        public int compare(WeightedObservedPoint p1, WeightedObservedPoint p2) {\r\n            if (p1 == null && p2 == null) {\r\n                return 0;\r\n            }\r\n            if (p1 == null) {\r\n                return -1;\r\n            }\r\n            if (p2 == null) {\r\n                return 1;\r\n            }\r\n            if (p1.getX() < p2.getX()) {\r\n                return -1;\r\n            }\r\n            if (p1.getX() > p2.getX()) {\r\n                return 1;\r\n            }\r\n            if (p1.getY() < p2.getY()) {\r\n                return -1;\r\n            }\r\n            if (p1.getY() > p2.getY()) {\r\n                return 1;\r\n            }\r\n            if (p1.getWeight() < p2.getWeight()) {\r\n                return -1;\r\n            }\r\n            if (p1.getWeight() > p2.getWeight()) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        }\r\n    };\r\n}","code_comment":"\/**\r\n * Factory method creating <code>Comparator<\/code> for comparing\r\n * <code>WeightedObservedPoint<\/code> instances.\r\n *\r\n * @return new <code>Comparator<\/code> instance\r\n *\/\r\n","code_no_comment":"private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator() {\r\n    return new Comparator<WeightedObservedPoint>() {\r\n\r\n        public int compare(WeightedObservedPoint p1, WeightedObservedPoint p2) {\r\n            if (p1 == null && p2 == null) {\r\n                return 0;\r\n            }\r\n            if (p1 == null) {\r\n                return -1;\r\n            }\r\n            if (p2 == null) {\r\n                return 1;\r\n            }\r\n            if (p1.getX() < p2.getX()) {\r\n                return -1;\r\n            }\r\n            if (p1.getX() > p2.getX()) {\r\n                return 1;\r\n            }\r\n            if (p1.getY() < p2.getY()) {\r\n                return -1;\r\n            }\r\n            if (p1.getY() > p2.getY()) {\r\n                return 1;\r\n            }\r\n            if (p1.getWeight() < p2.getWeight()) {\r\n                return -1;\r\n            }\r\n            if (p1.getWeight() > p2.getWeight()) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        }\r\n    };\r\n}","lc":0.9090909091,"pi":0.5598086124,"ma":1.2,"nbd":0.0,"ml":1.0833333333,"d":1.251984127,"mi":-0.5252995067,"fo":0.5,"r":-0.0263157895,"e":0.9031448281}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3442_17032c50","label":3,"code":"@Override\r\npublic List<IndexPlan> getPlans(Filter filter, List<OrderEntry> sortOrder, NodeState rootState) {\r\n    Collection<String> indexPaths = new LuceneIndexLookup(rootState).collectIndexNodePaths(filter);\r\n    List<IndexPlan> plans = Lists.newArrayListWithCapacity(indexPaths.size());\r\n    IndexNode indexNode = null;\r\n    for (String path : indexPaths) {\r\n        try {\r\n            indexNode = tracker.acquireIndexNode(path);\r\n            if (indexNode != null) {\r\n                IndexPlan plan = new IndexPlanner(indexNode, path, filter, sortOrder).getPlan();\r\n                if (plan != null) {\r\n                    plans.add(plan);\r\n                }\r\n            }\r\n        } finally {\r\n            if (indexNode != null) {\r\n                indexNode.release();\r\n            }\r\n        }\r\n    }\r\n    return plans;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic List<IndexPlan> getPlans(Filter filter, List<OrderEntry> sortOrder, NodeState rootState) {\r\n    Collection<String> indexPaths = new LuceneIndexLookup(rootState).collectIndexNodePaths(filter);\r\n    List<IndexPlan> plans = Lists.newArrayListWithCapacity(indexPaths.size());\r\n    IndexNode indexNode = null;\r\n    for (String path : indexPaths) {\r\n        try {\r\n            indexNode = tracker.acquireIndexNode(path);\r\n            if (indexNode != null) {\r\n                IndexPlan plan = new IndexPlanner(indexNode, path, filter, sortOrder).getPlan();\r\n                if (plan != null) {\r\n                    plans.add(plan);\r\n                }\r\n            }\r\n        } finally {\r\n            if (indexNode != null) {\r\n                indexNode.release();\r\n            }\r\n        }\r\n    }\r\n    return plans;\r\n}","lc":0.3636363636,"pi":1.3732057416,"ma":0.2,"nbd":1.0,"ml":0.0,"d":-0.005952381,"mi":-0.3133192389,"fo":0.0833333333,"r":0.0,"e":0.1060816145}
{"project_name":"Math","project_version":"33","label":1,"code":"\/**\r\n * Removes the phase 1 objective function, positive cost non-artificial variables,\r\n * and the non-basic artificial variables from this tableau.\r\n *\/\r\nprotected void dropPhase1Objective() {\r\n    if (getNumObjectiveFunctions() == 1) {\r\n        return;\r\n    }\r\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\r\n    columnsToDrop.add(0);\r\n    \/\/ positive cost non-artificial variables\r\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\r\n        final double entry = tableau.getEntry(0, i);\r\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\r\n            columnsToDrop.add(i);\r\n        }\r\n    }\r\n    \/\/ non-basic artificial variables\r\n    for (int i = 0; i < getNumArtificialVariables(); i++) {\r\n        int col = i + getArtificialVariableOffset();\r\n        if (getBasicRow(col) == null) {\r\n            columnsToDrop.add(col);\r\n        }\r\n    }\r\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\r\n    for (int i = 1; i < getHeight(); i++) {\r\n        int col = 0;\r\n        for (int j = 0; j < getWidth(); j++) {\r\n            if (!columnsToDrop.contains(j)) {\r\n                matrix[i - 1][col++] = tableau.getEntry(i, j);\r\n            }\r\n        }\r\n    }\r\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\r\n        columnLabels.remove((int) columnsToDrop.get(i));\r\n    }\r\n    this.tableau = new Array2DRowRealMatrix(matrix);\r\n    this.numArtificialVariables = 0;\r\n}","code_comment":"\/**\r\n * Removes the phase 1 objective function, positive cost non-artificial variables,\r\n * and the non-basic artificial variables from this tableau.\r\n *\/\r\n","code_no_comment":"protected void dropPhase1Objective() {\r\n    if (getNumObjectiveFunctions() == 1) {\r\n        return;\r\n    }\r\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\r\n    columnsToDrop.add(0);\r\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\r\n        final double entry = tableau.getEntry(0, i);\r\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\r\n            columnsToDrop.add(i);\r\n        }\r\n    }\r\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\r\n        int col = i + getArtificialVariableOffset();\r\n        if (getBasicRow(col) == null) {\r\n            columnsToDrop.add(col);\r\n        }\r\n    }\r\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\r\n    for (int i = 1; i < getHeight(); i++) {\r\n        int col = 0;\r\n        for (int j = 0; j < getWidth(); j++) {\r\n            if (!columnsToDrop.contains(j)) {\r\n                matrix[i - 1][col++] = tableau.getEntry(i, j);\r\n            }\r\n        }\r\n    }\r\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\r\n        columnLabels.remove((int) columnsToDrop.get(i));\r\n    }\r\n    this.tableau = new Array2DRowRealMatrix(matrix);\r\n    this.numArtificialVariables = 0;\r\n}","lc":0.8636363636,"pi":0.2631578947,"ma":1.2,"nbd":0.5,"ml":1.4166666667,"d":2.2896825397,"mi":-0.6394644116,"fo":1.25,"r":-0.0263157895,"e":4.0139209211}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3719_5ad32df9","label":1,"code":"\/**\r\n *  @param child\r\n *             Component being added\r\n *\/\r\nprivate final void addedComponent(final Component child) {\r\n    \/\/ Check for degenerate case\r\n    if (child == this) {\r\n        throw new IllegalArgumentException(\"Component can't be added to itself\");\r\n    }\r\n    MarkupContainer parent = child.getParent();\r\n    if (parent != null) {\r\n        parent.remove(child);\r\n    }\r\n    \/\/ Set child's parent\r\n    child.setParent(this);\r\n    final IDebugSettings debugSettings = Application.get().getDebugSettings();\r\n    if (debugSettings.isLinePreciseReportingOnAddComponentEnabled()) {\r\n        child.setMetaData(ADDED_AT_KEY, ComponentStrings.toString(child, new MarkupException(\"added\")));\r\n    }\r\n    final Page page = findPage();\r\n    if (page != null) {\r\n        \/\/ tell the page a component has been added first, to allow it to initialize\r\n        page.componentAdded(child);\r\n        \/\/ initialize the component\r\n        if (page.isInitialized()) {\r\n            child.internalInitialize();\r\n        }\r\n    }\r\n    \/\/ beforeRender on this component's children. So we need to initialize the newly added one\r\n    if (isPreparedForRender()) {\r\n        child.beforeRender();\r\n    }\r\n}","code_comment":"\/**\r\n *  @param child\r\n *             Component being added\r\n *\/\r\n","code_no_comment":"private final void addedComponent(final Component child) {\r\n        if (child == this) {\r\n        throw new IllegalArgumentException(\"Component can't be added to itself\");\r\n    }\r\n    MarkupContainer parent = child.getParent();\r\n    if (parent != null) {\r\n        parent.remove(child);\r\n    }\r\n        child.setParent(this);\r\n    final IDebugSettings debugSettings = Application.get().getDebugSettings();\r\n    if (debugSettings.isLinePreciseReportingOnAddComponentEnabled()) {\r\n        child.setMetaData(ADDED_AT_KEY, ComponentStrings.toString(child, new MarkupException(\"added\")));\r\n    }\r\n    final Page page = findPage();\r\n    if (page != null) {\r\n                page.componentAdded(child);\r\n                if (page.isInitialized()) {\r\n            child.internalInitialize();\r\n        }\r\n    }\r\n        if (isPreparedForRender()) {\r\n        child.beforeRender();\r\n    }\r\n}","lc":0.4545454545,"pi":-0.1387559809,"ma":0.8,"nbd":0.0,"ml":0.5833333333,"d":-0.0674603175,"mi":-0.3499647639,"fo":0.6666666667,"r":-0.0263157895,"e":0.0287523844}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  Registers a debug feedback message for this component\r\n *\r\n *  @param message\r\n *             The feedback message\r\n *\/\r\npublic final void debug(final String message) {\r\n    getPage().getFeedbackMessages().debug(this, message);\r\n}","code_comment":"\/**\r\n *  Registers a debug feedback message for this component\r\n *\r\n *  @param message\r\n *             The feedback message\r\n *\/\r\n","code_no_comment":"public final void debug(final String message) {\r\n    getPage().getFeedbackMessages().debug(this, message);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0253699789,"fo":-0.25,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1668_63070cf9","label":1,"code":"private static void addNonFullTextConstraints(List<Query> qs, Filter filter, IndexReader reader, Analyzer analyzer) {\r\n    if (!filter.matchesAllTypes()) {\r\n        addNodeTypeConstraints(qs, filter);\r\n    }\r\n    String path = filter.getPath();\r\n    switch(filter.getPathRestriction()) {\r\n        case ALL_CHILDREN:\r\n            if (\"\/\".equals(path)) {\r\n                break;\r\n            }\r\n            if (!path.endsWith(\"\/\")) {\r\n                path += \"\/\";\r\n            }\r\n            qs.add(new PrefixQuery(newPathTerm(path)));\r\n            break;\r\n        case DIRECT_CHILDREN:\r\n            if (!path.endsWith(\"\/\")) {\r\n                path += \"\/\";\r\n            }\r\n            qs.add(new PrefixQuery(newPathTerm(path)));\r\n            break;\r\n        case EXACT:\r\n            qs.add(new TermQuery(newPathTerm(path)));\r\n            break;\r\n        case PARENT:\r\n            if (denotesRoot(path)) {\r\n                \/\/ there's no parent of the root node\r\n                \/\/ we add a path that can not possibly occur because there\r\n                \/\/ is no way to say \"match no documents\" in Lucene\r\n                qs.add(new TermQuery(new Term(FieldNames.PATH, \"\/\/\/\")));\r\n            } else {\r\n                qs.add(new TermQuery(newPathTerm(getParentPath(path))));\r\n            }\r\n            break;\r\n        case NO_RESTRICTION:\r\n            break;\r\n    }\r\n    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\r\n        if (pr.first == null && pr.last == null) {\r\n            \/\/ is not null' queries (OAK-1208)\r\n            continue;\r\n        }\r\n        String name = pr.propertyName;\r\n        if (name.contains(\"\/\")) {\r\n            \/\/ lucene cannot handle child-level property restrictions\r\n            continue;\r\n        }\r\n        if (\"rep:excerpt\".equals(name)) {\r\n            continue;\r\n        }\r\n        if (JCR_PRIMARYTYPE.equals(name)) {\r\n            continue;\r\n        }\r\n        if (skipTokenization(name)) {\r\n            qs.add(new TermQuery(new Term(name, pr.first.getValue(STRING))));\r\n            continue;\r\n        }\r\n        String first = null;\r\n        String last = null;\r\n        boolean isLike = pr.isLike;\r\n        \/\/ TODO what to do with escaped tokens?\r\n        if (pr.first != null) {\r\n            first = pr.first.getValue(STRING);\r\n            first = first.replace(\"\\\\\", \"\");\r\n        }\r\n        if (pr.last != null) {\r\n            last = pr.last.getValue(STRING);\r\n            last = last.replace(\"\\\\\", \"\");\r\n        }\r\n        if (isLike) {\r\n            first = first.replace('%', WildcardQuery.WILDCARD_STRING);\r\n            first = first.replace('_', WildcardQuery.WILDCARD_CHAR);\r\n            int indexOfWS = first.indexOf(WildcardQuery.WILDCARD_STRING);\r\n            int indexOfWC = first.indexOf(WildcardQuery.WILDCARD_CHAR);\r\n            int len = first.length();\r\n            if (indexOfWS == len || indexOfWC == len) {\r\n                \/\/ remove trailing \"*\" for prefixquery\r\n                first = first.substring(0, first.length() - 1);\r\n                if (JCR_PATH.equals(name)) {\r\n                    qs.add(new PrefixQuery(newPathTerm(first)));\r\n                } else {\r\n                    qs.add(new PrefixQuery(new Term(name, first)));\r\n                }\r\n            } else {\r\n                if (JCR_PATH.equals(name)) {\r\n                    qs.add(new WildcardQuery(newPathTerm(first)));\r\n                } else {\r\n                    qs.add(new WildcardQuery(new Term(name, first)));\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n        if (first != null && first.equals(last) && pr.firstIncluding && pr.lastIncluding) {\r\n            if (JCR_PATH.equals(name)) {\r\n                qs.add(new TermQuery(newPathTerm(first)));\r\n            } else {\r\n                if (\"*\".equals(name)) {\r\n                    addReferenceConstraint(first, qs, reader);\r\n                } else {\r\n                    for (String t : tokenize(first, analyzer)) {\r\n                        qs.add(new TermQuery(new Term(name, t)));\r\n                    }\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n        first = tokenizeAndPoll(first, analyzer);\r\n        last = tokenizeAndPoll(last, analyzer);\r\n        qs.add(TermRangeQuery.newStringRange(name, first, last, pr.firstIncluding, pr.lastIncluding));\r\n    }\r\n}","code_comment":null,"code_no_comment":"private static void addNonFullTextConstraints(List<Query> qs, Filter filter, IndexReader reader, Analyzer analyzer) {\r\n    if (!filter.matchesAllTypes()) {\r\n        addNodeTypeConstraints(qs, filter);\r\n    }\r\n    String path = filter.getPath();\r\n    switch(filter.getPathRestriction()) {\r\n        case ALL_CHILDREN:\r\n            if (\"\/\".equals(path)) {\r\n                break;\r\n            }\r\n            if (!path.endsWith(\"\/\")) {\r\n                path += \"\/\";\r\n            }\r\n            qs.add(new PrefixQuery(newPathTerm(path)));\r\n            break;\r\n        case DIRECT_CHILDREN:\r\n            if (!path.endsWith(\"\/\")) {\r\n                path += \"\/\";\r\n            }\r\n            qs.add(new PrefixQuery(newPathTerm(path)));\r\n            break;\r\n        case EXACT:\r\n            qs.add(new TermQuery(newPathTerm(path)));\r\n            break;\r\n        case PARENT:\r\n            if (denotesRoot(path)) {\r\n                                                                qs.add(new TermQuery(new Term(FieldNames.PATH, \"\/\/\/\")));\r\n            } else {\r\n                qs.add(new TermQuery(newPathTerm(getParentPath(path))));\r\n            }\r\n            break;\r\n        case NO_RESTRICTION:\r\n            break;\r\n    }\r\n    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\r\n        if (pr.first == null && pr.last == null) {\r\n                        continue;\r\n        }\r\n        String name = pr.propertyName;\r\n        if (name.contains(\"\/\")) {\r\n                        continue;\r\n        }\r\n        if (\"rep:excerpt\".equals(name)) {\r\n            continue;\r\n        }\r\n        if (JCR_PRIMARYTYPE.equals(name)) {\r\n            continue;\r\n        }\r\n        if (skipTokenization(name)) {\r\n            qs.add(new TermQuery(new Term(name, pr.first.getValue(STRING))));\r\n            continue;\r\n        }\r\n        String first = null;\r\n        String last = null;\r\n        boolean isLike = pr.isLike;\r\n                if (pr.first != null) {\r\n            first = pr.first.getValue(STRING);\r\n            first = first.replace(\"\\\\\", \"\");\r\n        }\r\n        if (pr.last != null) {\r\n            last = pr.last.getValue(STRING);\r\n            last = last.replace(\"\\\\\", \"\");\r\n        }\r\n        if (isLike) {\r\n            first = first.replace('%', WildcardQuery.WILDCARD_STRING);\r\n            first = first.replace('_', WildcardQuery.WILDCARD_CHAR);\r\n            int indexOfWS = first.indexOf(WildcardQuery.WILDCARD_STRING);\r\n            int indexOfWC = first.indexOf(WildcardQuery.WILDCARD_CHAR);\r\n            int len = first.length();\r\n            if (indexOfWS == len || indexOfWC == len) {\r\n                                first = first.substring(0, first.length() - 1);\r\n                if (JCR_PATH.equals(name)) {\r\n                    qs.add(new PrefixQuery(newPathTerm(first)));\r\n                } else {\r\n                    qs.add(new PrefixQuery(new Term(name, first)));\r\n                }\r\n            } else {\r\n                if (JCR_PATH.equals(name)) {\r\n                    qs.add(new WildcardQuery(newPathTerm(first)));\r\n                } else {\r\n                    qs.add(new WildcardQuery(new Term(name, first)));\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n        if (first != null && first.equals(last) && pr.firstIncluding && pr.lastIncluding) {\r\n            if (JCR_PATH.equals(name)) {\r\n                qs.add(new TermQuery(newPathTerm(first)));\r\n            } else {\r\n                if (\"*\".equals(name)) {\r\n                    addReferenceConstraint(first, qs, reader);\r\n                } else {\r\n                    for (String t : tokenize(first, analyzer)) {\r\n                        qs.add(new TermQuery(new Term(name, t)));\r\n                    }\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n        first = tokenizeAndPoll(first, analyzer);\r\n        last = tokenizeAndPoll(last, analyzer);\r\n        qs.add(TermRangeQuery.newStringRange(name, first, last, pr.firstIncluding, pr.lastIncluding));\r\n    }\r\n}","lc":4.0909090909,"pi":0.6842105263,"ma":7.2,"nbd":1.5,"ml":4.0,"d":2.3293650794,"mi":-1.5071176885,"fo":4.1666666667,"r":-0.0263157895,"e":11.5625363785}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5215_033eb6fe","label":3,"code":"@Converter\r\npublic static BufferedWriter toWriter(File file, Exchange exchange) throws IOException {\r\n    return IOHelper.buffered(new EncodingFileWriter(file, IOHelper.getCharsetName(exchange)));\r\n}","code_comment":null,"code_no_comment":"@Converter\r\npublic static BufferedWriter toWriter(File file, Exchange exchange) throws IOException {\r\n    return IOHelper.buffered(new EncodingFileWriter(file, IOHelper.getCharsetName(exchange)));\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7398167724,"fo":-0.3333333333,"r":0.1842105263,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5071_a2f848f2","label":1,"code":"private boolean matches(final Url url) {\r\n    return urlStartsWith(url, getContext().getNamespace(), getContext().getPageIdentifier());\r\n}","code_comment":null,"code_no_comment":"private boolean matches(final Url url) {\r\n    return urlStartsWith(url, getContext().getNamespace(), getContext().getPageIdentifier());\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9709654686,"fo":-0.0833333333,"r":0.0789473684,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4420_d645112f","label":1,"code":"private void copyState(NodeState sourceRoot, NodeBuilder targetRoot) throws CommitFailedException {\r\n    copyWorkspace(sourceRoot, targetRoot);\r\n    removeCheckpointReferences(targetRoot);\r\n    if (!versionCopyConfiguration.skipOrphanedVersionsCopy()) {\r\n        copyVersionStorage(sourceRoot, targetRoot, versionCopyConfiguration);\r\n    }\r\n    final List<CommitHook> hooks = new ArrayList<CommitHook>();\r\n    hooks.add(new EditorHook(new VersionableEditor.Provider(sourceRoot, Oak.DEFAULT_WORKSPACE_NAME, versionCopyConfiguration)));\r\n    if (customCommitHooks != null) {\r\n        hooks.addAll(customCommitHooks);\r\n    }\r\n    markIndexesToBeRebuilt(targetRoot);\r\n    target.merge(targetRoot, new LoggingCompositeHook(hooks, null, false), CommitInfo.EMPTY);\r\n}","code_comment":null,"code_no_comment":"private void copyState(NodeState sourceRoot, NodeBuilder targetRoot) throws CommitFailedException {\r\n    copyWorkspace(sourceRoot, targetRoot);\r\n    removeCheckpointReferences(targetRoot);\r\n    if (!versionCopyConfiguration.skipOrphanedVersionsCopy()) {\r\n        copyVersionStorage(sourceRoot, targetRoot, versionCopyConfiguration);\r\n    }\r\n    final List<CommitHook> hooks = new ArrayList<CommitHook>();\r\n    hooks.add(new EditorHook(new VersionableEditor.Provider(sourceRoot, Oak.DEFAULT_WORKSPACE_NAME, versionCopyConfiguration)));\r\n    if (customCommitHooks != null) {\r\n        hooks.addAll(customCommitHooks);\r\n    }\r\n    markIndexesToBeRebuilt(targetRoot);\r\n    target.merge(targetRoot, new LoggingCompositeHook(hooks, null, false), CommitInfo.EMPTY);\r\n}","lc":0.0,"pi":-0.4066985646,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0674603175,"mi":-0.0630021142,"fo":0.1666666667,"r":-0.0263157895,"e":0.0181117201}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"@Override\r\npublic PropertyState setProperty(String name, CoreValue value) {\r\n    PropertyState property = new PropertyStateImpl(name, value);\r\n    if (hasProperty(name)) {\r\n        context.setProperty(property, path);\r\n    } else {\r\n        context.addProperty(property, path);\r\n    }\r\n    return property;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic PropertyState setProperty(String name, CoreValue value) {\r\n    PropertyState property = new PropertyStateImpl(name, value);\r\n    if (hasProperty(name)) {\r\n        context.setProperty(property, path);\r\n    } else {\r\n        context.addProperty(property, path);\r\n    }\r\n    return property;\r\n}","lc":-0.1818181818,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.2414376321,"fo":-0.25,"r":0.0789473684,"e":-0.1627934049}
{"project_name":"Lang","project_version":"48","label":3,"code":"\/\/ -------------------------------------------------------------------------\r\n\/**\r\n * <p>Test if two <code>Object<\/code>s are equal using their\r\n * <code>equals<\/code> method.<\/p>\r\n *\r\n * @param lhs  the left hand object\r\n * @param rhs  the right hand object\r\n * @return EqualsBuilder - used to chain calls.\r\n *\/\r\npublic EqualsBuilder append(Object lhs, Object rhs) {\r\n    if (isEquals == false) {\r\n        return this;\r\n    }\r\n    if (lhs == rhs) {\r\n        return this;\r\n    }\r\n    if (lhs == null || rhs == null) {\r\n        this.setEquals(false);\r\n        return this;\r\n    }\r\n    Class lhsClass = lhs.getClass();\r\n    if (!lhsClass.isArray()) {\r\n        \/\/ The simple case, not an array, just test the element\r\n        isEquals = lhs.equals(rhs);\r\n    } else if (lhs.getClass() != rhs.getClass()) {\r\n        \/\/ Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\r\n        this.setEquals(false);\r\n    } else \/\/ This handles multi dimensional arrays of the same depth\r\n    if (lhs instanceof long[]) {\r\n        append((long[]) lhs, (long[]) rhs);\r\n    } else if (lhs instanceof int[]) {\r\n        append((int[]) lhs, (int[]) rhs);\r\n    } else if (lhs instanceof short[]) {\r\n        append((short[]) lhs, (short[]) rhs);\r\n    } else if (lhs instanceof char[]) {\r\n        append((char[]) lhs, (char[]) rhs);\r\n    } else if (lhs instanceof byte[]) {\r\n        append((byte[]) lhs, (byte[]) rhs);\r\n    } else if (lhs instanceof double[]) {\r\n        append((double[]) lhs, (double[]) rhs);\r\n    } else if (lhs instanceof float[]) {\r\n        append((float[]) lhs, (float[]) rhs);\r\n    } else if (lhs instanceof boolean[]) {\r\n        append((boolean[]) lhs, (boolean[]) rhs);\r\n    } else {\r\n        \/\/ Not an array of primitives\r\n        append((Object[]) lhs, (Object[]) rhs);\r\n    }\r\n    return this;\r\n}","code_comment":"\/**\r\n * <p>Test if two <code>Object<\/code>s are equal using their\r\n * <code>equals<\/code> method.<\/p>\r\n *\r\n * @param lhs  the left hand object\r\n * @param rhs  the right hand object\r\n * @return EqualsBuilder - used to chain calls.\r\n *\/\r\n","code_no_comment":"public EqualsBuilder append(Object lhs, Object rhs) {\r\n    if (isEquals == false) {\r\n        return this;\r\n    }\r\n    if (lhs == rhs) {\r\n        return this;\r\n    }\r\n    if (lhs == null || rhs == null) {\r\n        this.setEquals(false);\r\n        return this;\r\n    }\r\n    Class lhsClass = lhs.getClass();\r\n    if (!lhsClass.isArray()) {\r\n                isEquals = lhs.equals(rhs);\r\n    } else if (lhs.getClass() != rhs.getClass()) {\r\n                this.setEquals(false);\r\n    } else     if (lhs instanceof long[]) {\r\n        append((long[]) lhs, (long[]) rhs);\r\n    } else if (lhs instanceof int[]) {\r\n        append((int[]) lhs, (int[]) rhs);\r\n    } else if (lhs instanceof short[]) {\r\n        append((short[]) lhs, (short[]) rhs);\r\n    } else if (lhs instanceof char[]) {\r\n        append((char[]) lhs, (char[]) rhs);\r\n    } else if (lhs instanceof byte[]) {\r\n        append((byte[]) lhs, (byte[]) rhs);\r\n    } else if (lhs instanceof double[]) {\r\n        append((double[]) lhs, (double[]) rhs);\r\n    } else if (lhs instanceof float[]) {\r\n        append((float[]) lhs, (float[]) rhs);\r\n    } else if (lhs instanceof boolean[]) {\r\n        append((boolean[]) lhs, (boolean[]) rhs);\r\n    } else {\r\n                append((Object[]) lhs, (Object[]) rhs);\r\n    }\r\n    return this;\r\n}","lc":1.0909090909,"pi":-0.3301435407,"ma":2.0,"nbd":4.0,"ml":1.25,"d":1.4861111111,"mi":-0.62931642,"fo":0.8333333333,"r":-0.0263157895,"e":1.3063835918}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"@Override\r\npublic NodeStateBuilder getChildBuilder(String name) {\r\n    return hasChild(name) ? new KernelNodeStateBuilder(context, PathUtils.concat(path, name)) : null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic NodeStateBuilder getChildBuilder(String name) {\r\n    return hasChild(name) ? new KernelNodeStateBuilder(context, PathUtils.concat(path, name)) : null;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.4,"nbd":-1.0,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.7429175476,"fo":-0.3333333333,"r":0.3157894737,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-478_11763dee","label":1,"code":"\/**\r\n * Formats a {@link org.apache.logging.log4j.core.LogEvent} in conformance with the log4j.dtd.\r\n *\r\n * @param event\r\n *            The LogEvent.\r\n * @return The XML representation of the LogEvent.\r\n *\/\r\n@Override\r\npublic String toSerializable(final LogEvent event) {\r\n    final StringBuilder buf = new StringBuilder(DEFAULT_SIZE);\r\n    \/\/ DC locking to avoid synchronizing the whole layout.\r\n    boolean check = this.firstLayoutDone;\r\n    if (!this.firstLayoutDone) {\r\n        synchronized (this) {\r\n            check = this.firstLayoutDone;\r\n            if (!check) {\r\n                this.firstLayoutDone = true;\r\n            } else {\r\n                buf.append(',');\r\n                buf.append(this.eol);\r\n            }\r\n        }\r\n    } else {\r\n        buf.append(',');\r\n        buf.append(this.eol);\r\n    }\r\n    buf.append(this.indent1);\r\n    buf.append('{');\r\n    buf.append(this.eol);\r\n    buf.append(this.indent2);\r\n    buf.append(\"\\\"logger\\\":\\\"\");\r\n    String name = event.getLoggerName();\r\n    if (name.isEmpty()) {\r\n        name = \"root\";\r\n    }\r\n    buf.append(Transform.escapeJsonControlCharacters(name));\r\n    buf.append(\"\\\",\");\r\n    buf.append(this.eol);\r\n    buf.append(this.indent2);\r\n    buf.append(\"\\\"timestamp\\\":\\\"\");\r\n    buf.append(event.getMillis());\r\n    buf.append(\"\\\",\");\r\n    buf.append(this.eol);\r\n    buf.append(this.indent2);\r\n    buf.append(\"\\\"level\\\":\\\"\");\r\n    buf.append(Transform.escapeJsonControlCharacters(String.valueOf(event.getLevel())));\r\n    buf.append(\"\\\",\");\r\n    buf.append(this.eol);\r\n    buf.append(this.indent2);\r\n    buf.append(\"\\\"thread\\\":\\\"\");\r\n    buf.append(Transform.escapeJsonControlCharacters(event.getThreadName()));\r\n    buf.append(\"\\\",\");\r\n    buf.append(this.eol);\r\n    final Message msg = event.getMessage();\r\n    if (msg != null) {\r\n        boolean jsonSupported = false;\r\n        if (msg instanceof MultiformatMessage) {\r\n            final String[] formats = ((MultiformatMessage) msg).getFormats();\r\n            for (final String format : formats) {\r\n                if (format.equalsIgnoreCase(\"JSON\")) {\r\n                    jsonSupported = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        buf.append(this.indent2);\r\n        buf.append(\"\\\"message\\\":\\\"\");\r\n        if (jsonSupported) {\r\n            buf.append(((MultiformatMessage) msg).getFormattedMessage(FORMATS));\r\n        } else {\r\n            Transform.appendEscapingCDATA(buf, event.getMessage().getFormattedMessage());\r\n        }\r\n        buf.append('\\\"');\r\n    }\r\n    if (event.getContextStack().getDepth() > 0) {\r\n        buf.append(\",\");\r\n        buf.append(this.eol);\r\n        buf.append(\"\\\"ndc\\\":\");\r\n        Transform.appendEscapingCDATA(buf, event.getContextStack().toString());\r\n        buf.append(\"\\\"\");\r\n    }\r\n    final Throwable throwable = event.getThrown();\r\n    if (throwable != null) {\r\n        buf.append(\",\");\r\n        buf.append(this.eol);\r\n        buf.append(this.indent2);\r\n        buf.append(\"\\\"throwable\\\":\\\"\");\r\n        final List<String> list = Throwables.toStringList(throwable);\r\n        for (final String str : list) {\r\n            buf.append(Transform.escapeJsonControlCharacters(str));\r\n            buf.append(\"\\\\\\\\n\");\r\n        }\r\n        buf.append(\"\\\"\");\r\n    }\r\n    if (this.locationInfo) {\r\n        final StackTraceElement element = event.getSource();\r\n        buf.append(\",\");\r\n        buf.append(this.eol);\r\n        buf.append(this.indent2);\r\n        buf.append(\"\\\"LocationInfo\\\":{\");\r\n        buf.append(this.eol);\r\n        buf.append(this.indent3);\r\n        buf.append(\"\\\"class\\\":\\\"\");\r\n        buf.append(Transform.escapeJsonControlCharacters(element.getClassName()));\r\n        buf.append(\"\\\",\");\r\n        buf.append(this.eol);\r\n        buf.append(this.indent3);\r\n        buf.append(\"\\\"method\\\":\\\"\");\r\n        buf.append(Transform.escapeJsonControlCharacters(element.getMethodName()));\r\n        buf.append(\"\\\",\");\r\n        buf.append(this.eol);\r\n        buf.append(this.indent3);\r\n        buf.append(\"\\\"file\\\":\\\"\");\r\n        buf.append(Transform.escapeJsonControlCharacters(element.getFileName()));\r\n        buf.append(\"\\\",\");\r\n        buf.append(this.eol);\r\n        buf.append(this.indent3);\r\n        buf.append(\"\\\"line\\\":\\\"\");\r\n        buf.append(element.getLineNumber());\r\n        buf.append(\"\\\"\");\r\n        buf.append(this.eol);\r\n        buf.append(this.indent2);\r\n        buf.append(\"}\");\r\n    }\r\n    if (this.properties && event.getContextMap().size() > 0) {\r\n        buf.append(\",\");\r\n        buf.append(this.eol);\r\n        buf.append(this.indent2);\r\n        buf.append(\"\\\"Properties\\\":[\");\r\n        buf.append(this.eol);\r\n        final Set<Entry<String, String>> entrySet = event.getContextMap().entrySet();\r\n        int i = 1;\r\n        for (final Map.Entry<String, String> entry : entrySet) {\r\n            buf.append(this.indent3);\r\n            buf.append('{');\r\n            buf.append(this.eol);\r\n            buf.append(this.indent4);\r\n            buf.append(\"\\\"name\\\":\\\"\");\r\n            buf.append(Transform.escapeJsonControlCharacters(entry.getKey()));\r\n            buf.append(\"\\\",\");\r\n            buf.append(this.eol);\r\n            buf.append(this.indent4);\r\n            buf.append(\"\\\"value\\\":\\\"\");\r\n            buf.append(Transform.escapeJsonControlCharacters(String.valueOf(entry.getValue())));\r\n            buf.append(\"\\\"\");\r\n            buf.append(this.eol);\r\n            buf.append(this.indent3);\r\n            buf.append(\"}\");\r\n            if (i < entrySet.size()) {\r\n                buf.append(\",\");\r\n            }\r\n            buf.append(this.eol);\r\n            i++;\r\n        }\r\n        buf.append(this.indent2);\r\n        buf.append(\"]\");\r\n    }\r\n    buf.append(this.eol);\r\n    buf.append(this.indent1);\r\n    buf.append(\"}\");\r\n    return buf.toString();\r\n}","code_comment":"\/**\r\n * Formats a {@link org.apache.logging.log4j.core.LogEvent} in conformance with the log4j.dtd.\r\n *\r\n * @param event\r\n *            The LogEvent.\r\n * @return The XML representation of the LogEvent.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic String toSerializable(final LogEvent event) {\r\n    final StringBuilder buf = new StringBuilder(DEFAULT_SIZE);\r\n        boolean check = this.firstLayoutDone;\r\n    if (!this.firstLayoutDone) {\r\n        synchronized (this) {\r\n            check = this.firstLayoutDone;\r\n            if (!check) {\r\n                this.firstLayoutDone = true;\r\n            } else {\r\n                buf.append(',');\r\n                buf.append(this.eol);\r\n            }\r\n        }\r\n    } else {\r\n        buf.append(',');\r\n        buf.append(this.eol);\r\n    }\r\n    buf.append(this.indent1);\r\n    buf.append('{');\r\n    buf.append(this.eol);\r\n    buf.append(this.indent2);\r\n    buf.append(\"\\\"logger\\\":\\\"\");\r\n    String name = event.getLoggerName();\r\n    if (name.isEmpty()) {\r\n        name = \"root\";\r\n    }\r\n    buf.append(Transform.escapeJsonControlCharacters(name));\r\n    buf.append(\"\\\",\");\r\n    buf.append(this.eol);\r\n    buf.append(this.indent2);\r\n    buf.append(\"\\\"timestamp\\\":\\\"\");\r\n    buf.append(event.getMillis());\r\n    buf.append(\"\\\",\");\r\n    buf.append(this.eol);\r\n    buf.append(this.indent2);\r\n    buf.append(\"\\\"level\\\":\\\"\");\r\n    buf.append(Transform.escapeJsonControlCharacters(String.valueOf(event.getLevel())));\r\n    buf.append(\"\\\",\");\r\n    buf.append(this.eol);\r\n    buf.append(this.indent2);\r\n    buf.append(\"\\\"thread\\\":\\\"\");\r\n    buf.append(Transform.escapeJsonControlCharacters(event.getThreadName()));\r\n    buf.append(\"\\\",\");\r\n    buf.append(this.eol);\r\n    final Message msg = event.getMessage();\r\n    if (msg != null) {\r\n        boolean jsonSupported = false;\r\n        if (msg instanceof MultiformatMessage) {\r\n            final String[] formats = ((MultiformatMessage) msg).getFormats();\r\n            for (final String format : formats) {\r\n                if (format.equalsIgnoreCase(\"JSON\")) {\r\n                    jsonSupported = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        buf.append(this.indent2);\r\n        buf.append(\"\\\"message\\\":\\\"\");\r\n        if (jsonSupported) {\r\n            buf.append(((MultiformatMessage) msg).getFormattedMessage(FORMATS));\r\n        } else {\r\n            Transform.appendEscapingCDATA(buf, event.getMessage().getFormattedMessage());\r\n        }\r\n        buf.append('\\\"');\r\n    }\r\n    if (event.getContextStack().getDepth() > 0) {\r\n        buf.append(\",\");\r\n        buf.append(this.eol);\r\n        buf.append(\"\\\"ndc\\\":\");\r\n        Transform.appendEscapingCDATA(buf, event.getContextStack().toString());\r\n        buf.append(\"\\\"\");\r\n    }\r\n    final Throwable throwable = event.getThrown();\r\n    if (throwable != null) {\r\n        buf.append(\",\");\r\n        buf.append(this.eol);\r\n        buf.append(this.indent2);\r\n        buf.append(\"\\\"throwable\\\":\\\"\");\r\n        final List<String> list = Throwables.toStringList(throwable);\r\n        for (final String str : list) {\r\n            buf.append(Transform.escapeJsonControlCharacters(str));\r\n            buf.append(\"\\\\\\\\n\");\r\n        }\r\n        buf.append(\"\\\"\");\r\n    }\r\n    if (this.locationInfo) {\r\n        final StackTraceElement element = event.getSource();\r\n        buf.append(\",\");\r\n        buf.append(this.eol);\r\n        buf.append(this.indent2);\r\n        buf.append(\"\\\"LocationInfo\\\":{\");\r\n        buf.append(this.eol);\r\n        buf.append(this.indent3);\r\n        buf.append(\"\\\"class\\\":\\\"\");\r\n        buf.append(Transform.escapeJsonControlCharacters(element.getClassName()));\r\n        buf.append(\"\\\",\");\r\n        buf.append(this.eol);\r\n        buf.append(this.indent3);\r\n        buf.append(\"\\\"method\\\":\\\"\");\r\n        buf.append(Transform.escapeJsonControlCharacters(element.getMethodName()));\r\n        buf.append(\"\\\",\");\r\n        buf.append(this.eol);\r\n        buf.append(this.indent3);\r\n        buf.append(\"\\\"file\\\":\\\"\");\r\n        buf.append(Transform.escapeJsonControlCharacters(element.getFileName()));\r\n        buf.append(\"\\\",\");\r\n        buf.append(this.eol);\r\n        buf.append(this.indent3);\r\n        buf.append(\"\\\"line\\\":\\\"\");\r\n        buf.append(element.getLineNumber());\r\n        buf.append(\"\\\"\");\r\n        buf.append(this.eol);\r\n        buf.append(this.indent2);\r\n        buf.append(\"}\");\r\n    }\r\n    if (this.properties && event.getContextMap().size() > 0) {\r\n        buf.append(\",\");\r\n        buf.append(this.eol);\r\n        buf.append(this.indent2);\r\n        buf.append(\"\\\"Properties\\\":[\");\r\n        buf.append(this.eol);\r\n        final Set<Entry<String, String>> entrySet = event.getContextMap().entrySet();\r\n        int i = 1;\r\n        for (final Map.Entry<String, String> entry : entrySet) {\r\n            buf.append(this.indent3);\r\n            buf.append('{');\r\n            buf.append(this.eol);\r\n            buf.append(this.indent4);\r\n            buf.append(\"\\\"name\\\":\\\"\");\r\n            buf.append(Transform.escapeJsonControlCharacters(entry.getKey()));\r\n            buf.append(\"\\\",\");\r\n            buf.append(this.eol);\r\n            buf.append(this.indent4);\r\n            buf.append(\"\\\"value\\\":\\\"\");\r\n            buf.append(Transform.escapeJsonControlCharacters(String.valueOf(entry.getValue())));\r\n            buf.append(\"\\\"\");\r\n            buf.append(this.eol);\r\n            buf.append(this.indent3);\r\n            buf.append(\"}\");\r\n            if (i < entrySet.size()) {\r\n                buf.append(\",\");\r\n            }\r\n            buf.append(this.eol);\r\n            i++;\r\n        }\r\n        buf.append(this.indent2);\r\n        buf.append(\"]\");\r\n    }\r\n    buf.append(this.eol);\r\n    buf.append(this.indent1);\r\n    buf.append(\"}\");\r\n    return buf.toString();\r\n}","lc":6.3636363636,"pi":0.3349282297,"ma":2.6,"nbd":1.0,"ml":1.75,"d":2.3035714286,"mi":-1.6100070472,"fo":11.0833333333,"r":-0.0263157895,"e":18.9132253361}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2311_ca85ecce","label":3,"code":"@CheckForNull\r\n@Override\r\npublic NodeState retrieve(@Nonnull String checkpoint) {\r\n    return getRoot(Revision.fromString(checkpoint));\r\n}","code_comment":null,"code_no_comment":"@CheckForNull\r\n@Override\r\npublic NodeState retrieve(@Nonnull String checkpoint) {\r\n    return getRoot(Revision.fromString(checkpoint));\r\n}","lc":-0.4090909091,"pi":-0.6650717703,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6899224806,"fo":-0.3333333333,"r":1.8157894737,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-4509_8e3450f4","label":1,"code":"public void process(Exchange exchange) throws Exception {\r\n    ObjectHelper.notNull(dataFormat, \"dataFormat\");\r\n    InputStream stream = ExchangeHelper.getMandatoryInBody(exchange, InputStream.class);\r\n    try {\r\n        \/\/ lets setup the out message before we invoke the dataFormat\r\n        \/\/ so that it can mutate it if necessary\r\n        Message out = exchange.getOut();\r\n        out.copyFrom(exchange.getIn());\r\n        Object result = dataFormat.unmarshal(exchange, stream);\r\n        out.setBody(result);\r\n    } finally {\r\n        if (stream != null) {\r\n            stream.close();\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void process(Exchange exchange) throws Exception {\r\n    ObjectHelper.notNull(dataFormat, \"dataFormat\");\r\n    InputStream stream = ExchangeHelper.getMandatoryInBody(exchange, InputStream.class);\r\n    try {\r\n                        Message out = exchange.getOut();\r\n        out.copyFrom(exchange.getIn());\r\n        Object result = dataFormat.unmarshal(exchange, stream);\r\n        out.setBody(result);\r\n    } finally {\r\n        if (stream != null) {\r\n            stream.close();\r\n        }\r\n    }\r\n}","lc":0.0,"pi":0.1387559809,"ma":-0.4,"nbd":0.0,"ml":-0.25,"d":-0.0535714286,"mi":-0.0063424947,"fo":0.1666666667,"r":0.0789473684,"e":-0.0287477741}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4383_0f3d4d24","label":1,"code":"private boolean validateBoolean(String fieldName, ModelProblemCollector problems, boolean warning, String string, String sourceHint) {\r\n    if (string == null || string.length() <= 0) {\r\n        return true;\r\n    }\r\n    if (\"true\".equalsIgnoreCase(string) || \"false\".equalsIgnoreCase(string)) {\r\n        return true;\r\n    }\r\n    if (sourceHint != null) {\r\n        addViolation(problems, warning, \"'\" + fieldName + \"' must be 'true' or 'false' for \" + sourceHint);\r\n    } else {\r\n        addViolation(problems, warning, \"'\" + fieldName + \"' must be 'true' or 'false'.\");\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"private boolean validateBoolean(String fieldName, ModelProblemCollector problems, boolean warning, String string, String sourceHint) {\r\n    if (string == null || string.length() <= 0) {\r\n        return true;\r\n    }\r\n    if (\"true\".equalsIgnoreCase(string) || \"false\".equalsIgnoreCase(string)) {\r\n        return true;\r\n    }\r\n    if (sourceHint != null) {\r\n        addViolation(problems, warning, \"'\" + fieldName + \"' must be 'true' or 'false' for \" + sourceHint);\r\n    } else {\r\n        addViolation(problems, warning, \"'\" + fieldName + \"' must be 'true' or 'false'.\");\r\n    }\r\n    return false;\r\n}","lc":0.0,"pi":-0.2057416268,"ma":0.0,"nbd":-0.5,"ml":0.4166666667,"d":0.4702380952,"mi":-0.0410147992,"fo":-0.0833333333,"r":0.0,"e":0.2555211701}
{"project_name":"Time","project_version":"18","label":3,"code":"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {\r\n    Chronology base;\r\n    if ((base = getBase()) != null) {\r\n        return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\r\n    }\r\n    \/\/ Assume date is Gregorian.\r\n    long instant;\r\n    instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\r\n    if (instant < iCutoverMillis) {\r\n        \/\/ Maybe it's Julian.\r\n        instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\r\n        if (instant >= iCutoverMillis) {\r\n            \/\/ Okay, it's in the illegal cutover gap.\r\n            throw new IllegalArgumentException(\"Specified date does not exist\");\r\n        }\r\n    }\r\n    return instant;\r\n}","code_comment":null,"code_no_comment":"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException {\r\n    Chronology base;\r\n    if ((base = getBase()) != null) {\r\n        return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\r\n    }\r\n        long instant;\r\n    instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\r\n    if (instant < iCutoverMillis) {\r\n                instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\r\n        if (instant >= iCutoverMillis) {\r\n                        throw new IllegalArgumentException(\"Specified date does not exist\");\r\n        }\r\n    }\r\n    return instant;\r\n}","lc":0.0454545455,"pi":0.04784689,"ma":0.2,"nbd":0.0,"ml":0.0,"d":0.7202380952,"mi":-0.1078224101,"fo":-0.1666666667,"r":-0.0263157895,"e":0.4993021098}
{"project_name":"Closure","project_version":"48","label":2,"code":"\/**\r\n * Declare the symbol for a qualified name in the global scope.\r\n *\r\n * @param info The doc info for this property.\r\n * @param n A top-level GETPROP node (it should not be contained inside\r\n *     another GETPROP).\r\n * @param parent The parent of {@code n}.\r\n * @param rhsValue The node that {@code n} is being initialized to,\r\n *     or {@code null} if this is a stub declaration.\r\n *\/\r\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\r\n    Node ownerNode = n.getFirstChild();\r\n    String ownerName = ownerNode.getQualifiedName();\r\n    String qName = n.getQualifiedName();\r\n    String propName = n.getLastChild().getString();\r\n    Preconditions.checkArgument(qName != null && ownerName != null);\r\n    \/\/ Precedence of type information on GETPROPs:\r\n    \/\/ 1) @type annnotation \/ @enum annotation\r\n    \/\/ 2) ASSIGN to FUNCTION literal\r\n    \/\/ 3) @param\/@return annotation (with no function literal)\r\n    \/\/ 4) ASSIGN to something marked @const\r\n    \/\/ 5) ASSIGN to anything else\r\n    \/\/ \r\n    \/\/ 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\r\n    \/\/ the function has jsdoc or has not been declared before.\r\n    \/\/ \r\n    \/\/ FUNCTION literals are special because TypedScopeCreator is very smart\r\n    \/\/ about getting as much type information as possible for them.\r\n    \/\/ Determining type for #1 + #2 + #3 + #4\r\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\r\n    if (valueType == null && rhsValue != null) {\r\n        \/\/ Determining type for #5\r\n        valueType = rhsValue.getJSType();\r\n    }\r\n    \/\/ allow F.prototype to be redefined arbitrarily.\r\n    if (\"prototype\".equals(propName)) {\r\n        Var qVar = scope.getVar(qName);\r\n        if (qVar != null) {\r\n            \/\/ If the programmer has declared that F inherits from Super,\r\n            \/\/ and they assign F.prototype to an object literal,\r\n            \/\/ then they are responsible for making sure that the object literal's\r\n            \/\/ implicit prototype is set up appropriately. We just obey\r\n            \/\/ the @extends tag.\r\n            ObjectType qVarType = ObjectType.cast(qVar.getType());\r\n            if (qVarType != null && rhsValue != null && rhsValue.isObjectLit()) {\r\n                typeRegistry.resetImplicitPrototype(rhsValue.getJSType(), qVarType.getImplicitPrototype());\r\n            } else if (!qVar.isTypeInferred()) {\r\n                \/\/ what props are going to be on that prototype.\r\n                return;\r\n            }\r\n            if (qVar.getScope() == scope) {\r\n                scope.undeclare(qVar);\r\n            }\r\n        }\r\n    }\r\n    if (valueType == null) {\r\n        if (parent.isExprResult()) {\r\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\r\n        }\r\n        return;\r\n    }\r\n    \/\/ NOTE(nicksantos): Determining whether a property is declared or not\r\n    \/\/ is really really obnoxious.\r\n    \/\/ \r\n    \/\/ The problem is that there are two (equally valid) coding styles:\r\n    \/\/ \r\n    \/\/ (function() {\r\n    \/\/ \/* The authoritative definition of goog.bar. *\/\r\n    \/\/ goog.bar = function() {};\r\n    \/\/ })();\r\n    \/\/ \r\n    \/\/ function f() {\r\n    \/\/ goog.bar();\r\n    \/\/ \/* Reset goog.bar to a no-op. *\/\r\n    \/\/ goog.bar = function() {};\r\n    \/\/ }\r\n    \/\/ \r\n    \/\/ In a dynamic language with first-class functions, it's very difficult\r\n    \/\/ to know which one the user intended without looking at lots of\r\n    \/\/ contextual information (the second example demonstrates a small case\r\n    \/\/ of this, but there are some really pathological cases as well).\r\n    \/\/ \r\n    \/\/ The current algorithm checks if either the declaration has\r\n    \/\/ jsdoc type information, or @const with a known type,\r\n    \/\/ or a function literal with a name we haven't seen before.\r\n    boolean inferred = true;\r\n    if (info != null) {\r\n        \/\/ Determining declaration for #1 + #3 + #4\r\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\r\n    }\r\n    if (inferred) {\r\n        \/\/ Determining declaration for #2\r\n        inferred = !(rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false)));\r\n    }\r\n    if (!inferred) {\r\n        ObjectType ownerType = getObjectSlot(ownerName);\r\n        if (ownerType != null) {\r\n            \/\/ Only declare this as an official property if it has not been\r\n            \/\/ declared yet.\r\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\r\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\r\n                \/\/ If the property is undeclared or inferred, declare it now.\r\n                ownerType.defineDeclaredProperty(propName, valueType, n);\r\n            }\r\n        }\r\n        \/\/ If the property is already declared, the error will be\r\n        \/\/ caught when we try to declare it in the current scope.\r\n        defineSlot(n, parent, valueType, inferred);\r\n    } else if (rhsValue != null && rhsValue.isTrue()) {\r\n        \/\/ We declare these for delegate proxy method properties.\r\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\r\n        if (ownerType != null) {\r\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\r\n            String delegateName = codingConvention.getDelegateSuperclassName();\r\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\r\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\r\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Declare the symbol for a qualified name in the global scope.\r\n *\r\n * @param info The doc info for this property.\r\n * @param n A top-level GETPROP node (it should not be contained inside\r\n *     another GETPROP).\r\n * @param parent The parent of {@code n}.\r\n * @param rhsValue The node that {@code n} is being initialized to,\r\n *     or {@code null} if this is a stub declaration.\r\n *\/\r\n","code_no_comment":"void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\r\n    Node ownerNode = n.getFirstChild();\r\n    String ownerName = ownerNode.getQualifiedName();\r\n    String qName = n.getQualifiedName();\r\n    String propName = n.getLastChild().getString();\r\n    Preconditions.checkArgument(qName != null && ownerName != null);\r\n                                                        JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\r\n    if (valueType == null && rhsValue != null) {\r\n                valueType = rhsValue.getJSType();\r\n    }\r\n        if (\"prototype\".equals(propName)) {\r\n        Var qVar = scope.getVar(qName);\r\n        if (qVar != null) {\r\n                                                                        ObjectType qVarType = ObjectType.cast(qVar.getType());\r\n            if (qVarType != null && rhsValue != null && rhsValue.isObjectLit()) {\r\n                typeRegistry.resetImplicitPrototype(rhsValue.getJSType(), qVarType.getImplicitPrototype());\r\n            } else if (!qVar.isTypeInferred()) {\r\n                                return;\r\n            }\r\n            if (qVar.getScope() == scope) {\r\n                scope.undeclare(qVar);\r\n            }\r\n        }\r\n    }\r\n    if (valueType == null) {\r\n        if (parent.isExprResult()) {\r\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\r\n        }\r\n        return;\r\n    }\r\n                                                                                                    boolean inferred = true;\r\n    if (info != null) {\r\n                inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\r\n    }\r\n    if (inferred) {\r\n                inferred = !(rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false)));\r\n    }\r\n    if (!inferred) {\r\n        ObjectType ownerType = getObjectSlot(ownerName);\r\n        if (ownerType != null) {\r\n                                    boolean isExtern = t.getInput() != null && t.getInput().isExtern();\r\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\r\n                                ownerType.defineDeclaredProperty(propName, valueType, n);\r\n            }\r\n        }\r\n                        defineSlot(n, parent, valueType, inferred);\r\n    } else if (rhsValue != null && rhsValue.isTrue()) {\r\n                FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\r\n        if (ownerType != null) {\r\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\r\n            String delegateName = codingConvention.getDelegateSuperclassName();\r\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\r\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\r\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\r\n            }\r\n        }\r\n    }\r\n}","lc":2.0,"pi":0.5645933014,"ma":2.8,"nbd":1.0,"ml":3.6666666667,"d":1.1408730159,"mi":-1.0865398168,"fo":3.75,"r":-0.0263157895,"e":5.9040081142}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-9480_0ead2cac","label":1,"code":"public boolean process(final Exchange exchange, final AsyncCallback callback) {\r\n    final String messageId = messageIdExpression.evaluate(exchange, String.class);\r\n    if (messageId == null) {\r\n        exchange.setException(new NoMessageIdException(exchange, messageIdExpression));\r\n        callback.done(true);\r\n        return true;\r\n    }\r\n    boolean newKey;\r\n    if (eager) {\r\n        \/\/ add the key to the repository\r\n        if (idempotentRepository instanceof ExchangeIdempotentRepository) {\r\n            newKey = ((ExchangeIdempotentRepository<String>) idempotentRepository).add(exchange, messageId);\r\n        } else {\r\n            newKey = idempotentRepository.add(messageId);\r\n        }\r\n    } else {\r\n        \/\/ check if we already have the key\r\n        if (idempotentRepository instanceof ExchangeIdempotentRepository) {\r\n            newKey = ((ExchangeIdempotentRepository<String>) idempotentRepository).contains(exchange, messageId);\r\n        } else {\r\n            newKey = !idempotentRepository.contains(messageId);\r\n        }\r\n    }\r\n    if (!newKey) {\r\n        \/\/ mark the exchange as duplicate\r\n        exchange.setProperty(Exchange.DUPLICATE_MESSAGE, Boolean.TRUE);\r\n        \/\/ we already have this key so its a duplicate message\r\n        onDuplicate(exchange, messageId);\r\n        if (skipDuplicate) {\r\n            \/\/ if we should skip duplicate then we are done\r\n            LOG.debug(\"Ignoring duplicate message with id: {} for exchange: {}\", messageId, exchange);\r\n            callback.done(true);\r\n            return true;\r\n        }\r\n    }\r\n    final Synchronization onCompletion = new IdempotentOnCompletion(idempotentRepository, messageId, eager, removeOnFailure);\r\n    final AsyncCallback target = new IdempotentConsumerCallback(exchange, onCompletion, callback, completionEager);\r\n    if (!completionEager) {\r\n        \/\/ the scope is to do the idempotent completion work as an unit of work on the exchange when its done being routed\r\n        exchange.addOnCompletion(onCompletion);\r\n    }\r\n    \/\/ process the exchange\r\n    return processor.process(exchange, target);\r\n}","code_comment":null,"code_no_comment":"public boolean process(final Exchange exchange, final AsyncCallback callback) {\r\n    final String messageId = messageIdExpression.evaluate(exchange, String.class);\r\n    if (messageId == null) {\r\n        exchange.setException(new NoMessageIdException(exchange, messageIdExpression));\r\n        callback.done(true);\r\n        return true;\r\n    }\r\n    boolean newKey;\r\n    if (eager) {\r\n                if (idempotentRepository instanceof ExchangeIdempotentRepository) {\r\n            newKey = ((ExchangeIdempotentRepository<String>) idempotentRepository).add(exchange, messageId);\r\n        } else {\r\n            newKey = idempotentRepository.add(messageId);\r\n        }\r\n    } else {\r\n                if (idempotentRepository instanceof ExchangeIdempotentRepository) {\r\n            newKey = ((ExchangeIdempotentRepository<String>) idempotentRepository).contains(exchange, messageId);\r\n        } else {\r\n            newKey = !idempotentRepository.contains(messageId);\r\n        }\r\n    }\r\n    if (!newKey) {\r\n                exchange.setProperty(Exchange.DUPLICATE_MESSAGE, Boolean.TRUE);\r\n                onDuplicate(exchange, messageId);\r\n        if (skipDuplicate) {\r\n                        LOG.debug(\"Ignoring duplicate message with id: {} for exchange: {}\", messageId, exchange);\r\n            callback.done(true);\r\n            return true;\r\n        }\r\n    }\r\n    final Synchronization onCompletion = new IdempotentOnCompletion(idempotentRepository, messageId, eager, removeOnFailure);\r\n    final AsyncCallback target = new IdempotentConsumerCallback(exchange, onCompletion, callback, completionEager);\r\n    if (!completionEager) {\r\n                exchange.addOnCompletion(onCompletion);\r\n    }\r\n        return processor.process(exchange, target);\r\n}","lc":1.0454545455,"pi":0.1674641148,"ma":0.8,"nbd":0.0,"ml":0.6666666667,"d":0.1071428571,"mi":-0.6510218464,"fo":0.5833333333,"r":-0.0263157895,"e":0.4537427315}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4138_eb0f9b41","label":1,"code":"@Override\r\npublic Options getOptions() {\r\n    final Options o = new Options();\r\n    verboseOpt = new Option(\"v\", \"verbose\", false, \"verbose output during merge\");\r\n    sizeOpt = new Option(\"s\", \"size\", true, \"merge tablets to the given size over the entire table\");\r\n    forceOpt = new Option(\"f\", \"force\", false, \"merge small tablets to large tablets, even if it goes over the given size\");\r\n    allOpt = new Option(\"\", \"all\", false, \"allow an entire table to be merged into one tablet without prompting the user for confirmation\");\r\n    Option startRowOpt = OptUtil.startRowOpt();\r\n    startRowOpt.setDescription(\"begin row (NOT inclusive)\");\r\n    o.addOption(startRowOpt);\r\n    o.addOption(OptUtil.endRowOpt());\r\n    o.addOption(OptUtil.tableOpt(\"table to be merged\"));\r\n    o.addOption(verboseOpt);\r\n    o.addOption(sizeOpt);\r\n    o.addOption(forceOpt);\r\n    o.addOption(allOpt);\r\n    return o;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Options getOptions() {\r\n    final Options o = new Options();\r\n    verboseOpt = new Option(\"v\", \"verbose\", false, \"verbose output during merge\");\r\n    sizeOpt = new Option(\"s\", \"size\", true, \"merge tablets to the given size over the entire table\");\r\n    forceOpt = new Option(\"f\", \"force\", false, \"merge small tablets to large tablets, even if it goes over the given size\");\r\n    allOpt = new Option(\"\", \"all\", false, \"allow an entire table to be merged into one tablet without prompting the user for confirmation\");\r\n    Option startRowOpt = OptUtil.startRowOpt();\r\n    startRowOpt.setDescription(\"begin row (NOT inclusive)\");\r\n    o.addOption(startRowOpt);\r\n    o.addOption(OptUtil.endRowOpt());\r\n    o.addOption(OptUtil.tableOpt(\"table to be merged\"));\r\n    o.addOption(verboseOpt);\r\n    o.addOption(sizeOpt);\r\n    o.addOption(forceOpt);\r\n    o.addOption(allOpt);\r\n    return o;\r\n}","lc":0.1818181818,"pi":-0.7177033493,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.2067653277,"fo":0.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-370_495f04bc","label":3,"code":"\/**\r\n * Round the given non-negative, value to the \"nearest\" integer. Nearest is\r\n * determined by the rounding method specified. Rounding methods are defined\r\n * in {@link BigDecimal}.\r\n *\r\n * @param unscaled the value to round.\r\n * @param sign the sign of the original, scaled value.\r\n * @param roundingMethod the rounding method as defined in\r\n *        {@link BigDecimal}.\r\n * @return the rounded value.\r\n * @since 1.1\r\n *\/\r\nprivate static double roundUnscaled(double unscaled, double sign, int roundingMethod) {\r\n    switch(roundingMethod) {\r\n        case BigDecimal.ROUND_CEILING:\r\n            if (sign == -1) {\r\n                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\r\n            } else {\r\n                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\r\n            }\r\n            break;\r\n        case BigDecimal.ROUND_DOWN:\r\n            unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\r\n            break;\r\n        case BigDecimal.ROUND_FLOOR:\r\n            if (sign == -1) {\r\n                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\r\n            } else {\r\n                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\r\n            }\r\n            break;\r\n        case BigDecimal.ROUND_HALF_DOWN:\r\n            {\r\n                unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\r\n                double fraction = unscaled - FastMath.floor(unscaled);\r\n                if (fraction > 0.5) {\r\n                    unscaled = FastMath.ceil(unscaled);\r\n                } else {\r\n                    unscaled = FastMath.floor(unscaled);\r\n                }\r\n                break;\r\n            }\r\n        case BigDecimal.ROUND_HALF_EVEN:\r\n            {\r\n                double fraction = unscaled - FastMath.floor(unscaled);\r\n                if (fraction > 0.5) {\r\n                    unscaled = FastMath.ceil(unscaled);\r\n                } else if (fraction < 0.5) {\r\n                    unscaled = FastMath.floor(unscaled);\r\n                } else {\r\n                    \/\/ The following equality test is intentional and needed for rounding purposes\r\n                    if (FastMath.floor(unscaled) \/ 2.0 == FastMath.floor(Math.floor(unscaled) \/ 2.0)) {\r\n                        \/\/ even\r\n                        unscaled = FastMath.floor(unscaled);\r\n                    } else {\r\n                        \/\/ odd\r\n                        unscaled = FastMath.ceil(unscaled);\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        case BigDecimal.ROUND_HALF_UP:\r\n            {\r\n                unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\r\n                double fraction = unscaled - FastMath.floor(unscaled);\r\n                if (fraction >= 0.5) {\r\n                    unscaled = FastMath.ceil(unscaled);\r\n                } else {\r\n                    unscaled = FastMath.floor(unscaled);\r\n                }\r\n                break;\r\n            }\r\n        case BigDecimal.ROUND_UNNECESSARY:\r\n            if (unscaled != FastMath.floor(unscaled)) {\r\n                throw new ArithmeticException(\"Inexact result from rounding\");\r\n            }\r\n            break;\r\n        case BigDecimal.ROUND_UP:\r\n            unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\r\n            break;\r\n        default:\r\n            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.INVALID_ROUNDING_METHOD, roundingMethod, \"ROUND_CEILING\", BigDecimal.ROUND_CEILING, \"ROUND_DOWN\", BigDecimal.ROUND_DOWN, \"ROUND_FLOOR\", BigDecimal.ROUND_FLOOR, \"ROUND_HALF_DOWN\", BigDecimal.ROUND_HALF_DOWN, \"ROUND_HALF_EVEN\", BigDecimal.ROUND_HALF_EVEN, \"ROUND_HALF_UP\", BigDecimal.ROUND_HALF_UP, \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY, \"ROUND_UP\", BigDecimal.ROUND_UP);\r\n    }\r\n    return unscaled;\r\n}","code_comment":"\/**\r\n * Round the given non-negative, value to the \"nearest\" integer. Nearest is\r\n * determined by the rounding method specified. Rounding methods are defined\r\n * in {@link BigDecimal}.\r\n *\r\n * @param unscaled the value to round.\r\n * @param sign the sign of the original, scaled value.\r\n * @param roundingMethod the rounding method as defined in\r\n *        {@link BigDecimal}.\r\n * @return the rounded value.\r\n * @since 1.1\r\n *\/\r\n","code_no_comment":"private static double roundUnscaled(double unscaled, double sign, int roundingMethod) {\r\n    switch(roundingMethod) {\r\n        case BigDecimal.ROUND_CEILING:\r\n            if (sign == -1) {\r\n                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\r\n            } else {\r\n                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\r\n            }\r\n            break;\r\n        case BigDecimal.ROUND_DOWN:\r\n            unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\r\n            break;\r\n        case BigDecimal.ROUND_FLOOR:\r\n            if (sign == -1) {\r\n                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\r\n            } else {\r\n                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\r\n            }\r\n            break;\r\n        case BigDecimal.ROUND_HALF_DOWN:\r\n            {\r\n                unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\r\n                double fraction = unscaled - FastMath.floor(unscaled);\r\n                if (fraction > 0.5) {\r\n                    unscaled = FastMath.ceil(unscaled);\r\n                } else {\r\n                    unscaled = FastMath.floor(unscaled);\r\n                }\r\n                break;\r\n            }\r\n        case BigDecimal.ROUND_HALF_EVEN:\r\n            {\r\n                double fraction = unscaled - FastMath.floor(unscaled);\r\n                if (fraction > 0.5) {\r\n                    unscaled = FastMath.ceil(unscaled);\r\n                } else if (fraction < 0.5) {\r\n                    unscaled = FastMath.floor(unscaled);\r\n                } else {\r\n                                        if (FastMath.floor(unscaled) \/ 2.0 == FastMath.floor(Math.floor(unscaled) \/ 2.0)) {\r\n                                                unscaled = FastMath.floor(unscaled);\r\n                    } else {\r\n                                                unscaled = FastMath.ceil(unscaled);\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        case BigDecimal.ROUND_HALF_UP:\r\n            {\r\n                unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\r\n                double fraction = unscaled - FastMath.floor(unscaled);\r\n                if (fraction >= 0.5) {\r\n                    unscaled = FastMath.ceil(unscaled);\r\n                } else {\r\n                    unscaled = FastMath.floor(unscaled);\r\n                }\r\n                break;\r\n            }\r\n        case BigDecimal.ROUND_UNNECESSARY:\r\n            if (unscaled != FastMath.floor(unscaled)) {\r\n                throw new ArithmeticException(\"Inexact result from rounding\");\r\n            }\r\n            break;\r\n        case BigDecimal.ROUND_UP:\r\n            unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\r\n            break;\r\n        default:\r\n            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.INVALID_ROUNDING_METHOD, roundingMethod, \"ROUND_CEILING\", BigDecimal.ROUND_CEILING, \"ROUND_DOWN\", BigDecimal.ROUND_DOWN, \"ROUND_FLOOR\", BigDecimal.ROUND_FLOOR, \"ROUND_HALF_DOWN\", BigDecimal.ROUND_HALF_DOWN, \"ROUND_HALF_EVEN\", BigDecimal.ROUND_HALF_EVEN, \"ROUND_HALF_UP\", BigDecimal.ROUND_HALF_UP, \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY, \"ROUND_UP\", BigDecimal.ROUND_UP);\r\n    }\r\n    return unscaled;\r\n}","lc":2.5454545455,"pi":0.9282296651,"ma":4.8,"nbd":1.5,"ml":1.5,"d":4.0753968254,"mi":-1.1750528541,"fo":2.0,"r":-0.0263157895,"e":11.5307065922}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3760_494212b3","label":0,"code":"\/\/ ------------------------------------------------------------------------\r\n\/**\r\n *  Checks whether the serializer has been initialized. Serializer initialization is lazy,\r\n *  to allow parametrization of serializers with an {@link ExecutionConfig} via\r\n *  {@link #initializeSerializerUnlessSet(ExecutionConfig)}.\r\n *\r\n *  @return True if the serializers have been initialized, false otherwise.\r\n *\/\r\npublic boolean isSerializerInitialized() {\r\n    return serializer != null;\r\n}","code_comment":"\/**\r\n *  Checks whether the serializer has been initialized. Serializer initialization is lazy,\r\n *  to allow parametrization of serializers with an {@link ExecutionConfig} via\r\n *  {@link #initializeSerializerUnlessSet(ExecutionConfig)}.\r\n *\r\n *  @return True if the serializers have been initialized, false otherwise.\r\n *\/\r\n","code_no_comment":"public boolean isSerializerInitialized() {\r\n    return serializer != null;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1822_3e83a4c1","label":1,"code":"public static void setModified(@Nonnull UpdateOp op, @Nonnull Revision revision) {\r\n    checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\r\n}","code_comment":null,"code_no_comment":"public static void setModified(@Nonnull UpdateOp op, @Nonnull Revision revision) {\r\n    checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8759689922,"fo":-0.0833333333,"r":0.1315789474,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2484_d738430c","label":0,"code":"\/\/ ------------------------------------------------------------------------\r\n\/\/ Buffer and barrier handling\r\n\/\/ ------------------------------------------------------------------------\r\n@Override\r\npublic BufferOrEvent getNextNonBlocked() throws IOException, InterruptedException {\r\n    while (true) {\r\n        \/\/ process buffered BufferOrEvents before grabbing new ones\r\n        BufferOrEvent next;\r\n        if (currentBuffered != null) {\r\n            next = currentBuffered.getNext();\r\n            if (next == null) {\r\n                currentBuffered = queuedBuffered.pollFirst();\r\n                if (currentBuffered != null) {\r\n                    currentBuffered.open();\r\n                }\r\n                return getNextNonBlocked();\r\n            }\r\n        } else {\r\n            next = inputGate.getNextBufferOrEvent();\r\n        }\r\n        if (next != null) {\r\n            if (isBlocked(next.getChannelIndex())) {\r\n                \/\/ if the channel is blocked we, we just store the BufferOrEvent\r\n                bufferSpiller.add(next);\r\n            } else if (next.isBuffer() || next.getEvent().getClass() != CheckpointBarrier.class) {\r\n                return next;\r\n            } else if (!endOfStream) {\r\n                \/\/ process barriers only if there is a chance of the checkpoint completing\r\n                processBarrier((CheckpointBarrier) next.getEvent(), next.getChannelIndex());\r\n            }\r\n        } else if (!endOfStream) {\r\n            \/\/ end of stream. we feed the data that is still buffered\r\n            endOfStream = true;\r\n            releaseBlocks();\r\n            return getNextNonBlocked();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic BufferOrEvent getNextNonBlocked() throws IOException, InterruptedException {\r\n    while (true) {\r\n                BufferOrEvent next;\r\n        if (currentBuffered != null) {\r\n            next = currentBuffered.getNext();\r\n            if (next == null) {\r\n                currentBuffered = queuedBuffered.pollFirst();\r\n                if (currentBuffered != null) {\r\n                    currentBuffered.open();\r\n                }\r\n                return getNextNonBlocked();\r\n            }\r\n        } else {\r\n            next = inputGate.getNextBufferOrEvent();\r\n        }\r\n        if (next != null) {\r\n            if (isBlocked(next.getChannelIndex())) {\r\n                                bufferSpiller.add(next);\r\n            } else if (next.isBuffer() || next.getEvent().getClass() != CheckpointBarrier.class) {\r\n                return next;\r\n            } else if (!endOfStream) {\r\n                                processBarrier((CheckpointBarrier) next.getEvent(), next.getChannelIndex());\r\n            }\r\n        } else if (!endOfStream) {\r\n                        endOfStream = true;\r\n            releaseBlocks();\r\n            return getNextNonBlocked();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}","lc":0.8636363636,"pi":0.9186602871,"ma":1.2,"nbd":1.5,"ml":1.0,"d":0.4424603175,"mi":-0.5362931642,"fo":0.8333333333,"r":-0.0263157895,"e":0.4664303867}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-722_95d15eff","label":3,"code":"\/**\r\n * Compute the\r\n * <a href=\"http:\/\/mathworld.wolfram.com\/Tangent.html\" TARGET=\"_top\">\r\n * tangent<\/a> of this complex number.\r\n * Implements the formula:\r\n * <pre>\r\n *  <code>\r\n *   tan(a + bi) = sin(2a)\/(cos(2a)+cosh(2b)) + [sinh(2b)\/(cos(2a)+cosh(2b))]i\r\n *  <\/code>\r\n * <\/pre>\r\n * where the (real) functions on the right-hand side are\r\n * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\r\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\r\n * <br\/>\r\n * Returns {@link Complex#NaN} if either real or imaginary part of the\r\n * input argument is {@code NaN}.\r\n * <br\/>\r\n * Infinite (or critical) values in real or imaginary parts of the input may\r\n * result in infinite or NaN values returned in parts of the result.\r\n * <pre>\r\n *  Examples:\r\n *  <code>\r\n *   tan(1 &plusmn; INFINITY i) = 0 + NaN i\r\n *   tan(&plusmn;INFINITY + i) = NaN + NaN i\r\n *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\r\n *   tan(&plusmn;&pi;\/2 + 0 i) = &plusmn;INFINITY + NaN i\r\n *  <\/code>\r\n * <\/pre>\r\n *\r\n * @return the tangent of {@code this}.\r\n * @since 1.2\r\n *\/\r\npublic Complex tan() {\r\n    if (isNaN) {\r\n        return NaN;\r\n    }\r\n    double real2 = 2.0 * real;\r\n    double imaginary2 = 2.0 * imaginary;\r\n    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\r\n    return createComplex(FastMath.sin(real2) \/ d, FastMath.sinh(imaginary2) \/ d);\r\n}","code_comment":"\/**\r\n * Compute the\r\n * <a href=\"http:\/\/mathworld.wolfram.com\/Tangent.html\" TARGET=\"_top\">\r\n * tangent<\/a> of this complex number.\r\n * Implements the formula:\r\n * <pre>\r\n *  <code>\r\n *   tan(a + bi) = sin(2a)\/(cos(2a)+cosh(2b)) + [sinh(2b)\/(cos(2a)+cosh(2b))]i\r\n *  <\/code>\r\n * <\/pre>\r\n * where the (real) functions on the right-hand side are\r\n * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\r\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\r\n * <br\/>\r\n * Returns {@link Complex#NaN} if either real or imaginary part of the\r\n * input argument is {@code NaN}.\r\n * <br\/>\r\n * Infinite (or critical) values in real or imaginary parts of the input may\r\n * result in infinite or NaN values returned in parts of the result.\r\n * <pre>\r\n *  Examples:\r\n *  <code>\r\n *   tan(1 &plusmn; INFINITY i) = 0 + NaN i\r\n *   tan(&plusmn;INFINITY + i) = NaN + NaN i\r\n *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\r\n *   tan(&plusmn;&pi;\/2 + 0 i) = &plusmn;INFINITY + NaN i\r\n *  <\/code>\r\n * <\/pre>\r\n *\r\n * @return the tangent of {@code this}.\r\n * @since 1.2\r\n *\/\r\n","code_no_comment":"public Complex tan() {\r\n    if (isNaN) {\r\n        return NaN;\r\n    }\r\n    double real2 = 2.0 * real;\r\n    double imaginary2 = 2.0 * imaginary;\r\n    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\r\n    return createComplex(FastMath.sin(real2) \/ d, FastMath.sinh(imaginary2) \/ d);\r\n}","lc":-0.2272727273,"pi":-0.3444976077,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.2658730159,"mi":0.2231148696,"fo":-0.0833333333,"r":0.2368421053,"e":0.0623387101}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5442_a382917f","label":1,"code":"\/**\r\n *  Retrieves the hour field of the given <code>Calendar<\/code>.\r\n *\r\n *  @param calendar\r\n *             the <code>Calendar<\/code> to get the field value from\r\n *  @return the hour field value\r\n *\/\r\npublic int getHour(final Calendar calendar) {\r\n    return get(calendar, Calendar.HOUR);\r\n}","code_comment":"\/**\r\n *  Retrieves the hour field of the given <code>Calendar<\/code>.\r\n *\r\n *  @param calendar\r\n *             the <code>Calendar<\/code> to get the field value from\r\n *  @return the hour field value\r\n *\/\r\n","code_no_comment":"public int getHour(final Calendar calendar) {\r\n    return get(calendar, Calendar.HOUR);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0253699789,"fo":-0.4166666667,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"Closure","project_version":"62","label":2,"code":"private String format(JSError error, boolean warning) {\r\n    \/\/ extract source excerpt\r\n    SourceExcerptProvider source = getSource();\r\n    String sourceExcerpt = source == null ? null : excerpt.get(source, error.sourceName, error.lineNumber, excerptFormatter);\r\n    \/\/ formatting the message\r\n    StringBuilder b = new StringBuilder();\r\n    if (error.sourceName != null) {\r\n        b.append(error.sourceName);\r\n        if (error.lineNumber > 0) {\r\n            b.append(':');\r\n            b.append(error.lineNumber);\r\n        }\r\n        b.append(\": \");\r\n    }\r\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\r\n    b.append(\" - \");\r\n    b.append(error.description);\r\n    b.append('\\n');\r\n    if (sourceExcerpt != null) {\r\n        b.append(sourceExcerpt);\r\n        b.append('\\n');\r\n        int charno = error.getCharno();\r\n        \/\/ at the end of the line\r\n        if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) {\r\n            for (int i = 0; i < charno; i++) {\r\n                char c = sourceExcerpt.charAt(i);\r\n                if (Character.isWhitespace(c)) {\r\n                    b.append(c);\r\n                } else {\r\n                    b.append(' ');\r\n                }\r\n            }\r\n            b.append(\"^\\n\");\r\n        }\r\n    }\r\n    return b.toString();\r\n}","code_comment":null,"code_no_comment":"private String format(JSError error, boolean warning) {\r\n        SourceExcerptProvider source = getSource();\r\n    String sourceExcerpt = source == null ? null : excerpt.get(source, error.sourceName, error.lineNumber, excerptFormatter);\r\n        StringBuilder b = new StringBuilder();\r\n    if (error.sourceName != null) {\r\n        b.append(error.sourceName);\r\n        if (error.lineNumber > 0) {\r\n            b.append(':');\r\n            b.append(error.lineNumber);\r\n        }\r\n        b.append(\": \");\r\n    }\r\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\r\n    b.append(\" - \");\r\n    b.append(error.description);\r\n    b.append('\\n');\r\n    if (sourceExcerpt != null) {\r\n        b.append(sourceExcerpt);\r\n        b.append('\\n');\r\n        int charno = error.getCharno();\r\n                if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) {\r\n            for (int i = 0; i < charno; i++) {\r\n                char c = sourceExcerpt.charAt(i);\r\n                if (Character.isWhitespace(c)) {\r\n                    b.append(c);\r\n                } else {\r\n                    b.append(' ');\r\n                }\r\n            }\r\n            b.append(\"^\\n\");\r\n        }\r\n    }\r\n    return b.toString();\r\n}","lc":0.9090909091,"pi":1.0861244019,"ma":1.0,"nbd":1.0,"ml":1.3333333333,"d":1.619047619,"mi":-0.6476391825,"fo":1.3333333333,"r":-0.0263157895,"e":2.985639944}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"\/**\r\n * Move this tree to the parent at {@code destParent} with the new name\r\n * {@code destName}.\r\n *\r\n * @param destParent  new parent for this tree\r\n * @param destName  new name for this tree\r\n * @return  {@code true} if successful, {@code false otherwise}. I.e.\r\n * when {@code destName} already exists at {@code destParent}\r\n *\/\r\npublic boolean move(TreeImpl destParent, String destName) {\r\n    boolean result = builder.moveTo(destParent.builder, destName);\r\n    if (result) {\r\n        TreeImpl oldParent = parent;\r\n        String oldName = name;\r\n        name = destName;\r\n        parent = destParent;\r\n        if (listener != null) {\r\n            listener.move(oldParent, oldName, this);\r\n        }\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n * Move this tree to the parent at {@code destParent} with the new name\r\n * {@code destName}.\r\n *\r\n * @param destParent  new parent for this tree\r\n * @param destName  new name for this tree\r\n * @return  {@code true} if successful, {@code false otherwise}. I.e.\r\n * when {@code destName} already exists at {@code destParent}\r\n *\/\r\n","code_no_comment":"public boolean move(TreeImpl destParent, String destName) {\r\n    boolean result = builder.moveTo(destParent.builder, destName);\r\n    if (result) {\r\n        TreeImpl oldParent = parent;\r\n        String oldName = name;\r\n        name = destName;\r\n        parent = destParent;\r\n        if (listener != null) {\r\n            listener.move(oldParent, oldName, this);\r\n        }\r\n    }\r\n    return result;\r\n}","lc":-0.0454545455,"pi":0.1818181818,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":0.0317460317,"mi":0.0551092319,"fo":-0.3333333333,"r":0.1052631579,"e":-0.0271111034}
{"project_name":"Closure","project_version":"152","label":2,"code":"@Override\r\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\r\n    setResolvedTypeInternal(this);\r\n    call = (ArrowType) safeResolve(call, t, scope);\r\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\r\n    \/\/ Warning about typeOfThis if it doesn't resolve to an ObjectType\r\n    \/\/ is handled further upstream.\r\n    \/\/ TODO(nicksantos): Handle this correctly if we have a UnionType.\r\n    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\r\n    boolean changed = false;\r\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\r\n    for (ObjectType iface : implementedInterfaces) {\r\n        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\r\n        resolvedInterfaces.add(resolvedIface);\r\n        changed |= (resolvedIface != iface);\r\n    }\r\n    if (changed) {\r\n        implementedInterfaces = resolvedInterfaces.build();\r\n    }\r\n    if (subTypes != null) {\r\n        for (int i = 0; i < subTypes.size(); i++) {\r\n            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\r\n        }\r\n    }\r\n    return super.resolveInternal(t, scope);\r\n}","code_comment":null,"code_no_comment":"@Override\r\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\r\n    setResolvedTypeInternal(this);\r\n    call = (ArrowType) safeResolve(call, t, scope);\r\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\r\n                typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\r\n    boolean changed = false;\r\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\r\n    for (ObjectType iface : implementedInterfaces) {\r\n        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\r\n        resolvedInterfaces.add(resolvedIface);\r\n        changed |= (resolvedIface != iface);\r\n    }\r\n    if (changed) {\r\n        implementedInterfaces = resolvedInterfaces.build();\r\n    }\r\n    if (subTypes != null) {\r\n        for (int i = 0; i < subTypes.size(); i++) {\r\n            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\r\n        }\r\n    }\r\n    return super.resolveInternal(t, scope);\r\n}","lc":0.4090909091,"pi":-0.0526315789,"ma":0.2,"nbd":0.0,"ml":0.1666666667,"d":0.4841269841,"mi":-0.392248062,"fo":0.5833333333,"r":-0.0263157895,"e":0.7881629525}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5724_b92591f6","label":1,"code":"@Override\r\npublic Component newComponent(ComponentTag tag) {\r\n    String attributeName = getInlineEnclosureAttributeName(null);\r\n    String childId = tag.getAttribute(attributeName);\r\n    return new InlineEnclosure(tag.getId(), childId);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Component newComponent(ComponentTag tag) {\r\n    String attributeName = getInlineEnclosureAttributeName(null);\r\n    String childId = tag.getAttribute(attributeName);\r\n    return new InlineEnclosure(tag.getId(), childId);\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5069767442,"fo":-0.25,"r":1.1842105263,"e":-0.1627934049}
{"project_name":"Closure","project_version":"163","label":1,"code":"\/**\r\n * Processes the GETPROP of prototype, which can either be under\r\n * another GETPROP (in the case of Foo.prototype.bar), or can be\r\n * under an assignment (in the case of Foo.prototype = ...).\r\n * @return True if a declaration was added.\r\n *\/\r\nprivate void processPrototypeParent(NodeTraversal t, Node n) {\r\n    switch(n.getType()) {\r\n        \/\/ Foo.prototype.getBar = function() { ... }\r\n        case Token.GETPROP:\r\n            Node dest = n.getFirstChild().getNext();\r\n            Node parent = n.getParent();\r\n            Node grandParent = parent.getParent();\r\n            if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\r\n                String name = dest.getString();\r\n                Property prop = new AssignmentProperty(grandParent, t.getModule());\r\n                getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\r\n            }\r\n            break;\r\n        \/\/ Foo.prototype = { \"getBar\" : function() { ... } }\r\n        case Token.ASSIGN:\r\n            Node map = n.getFirstChild().getNext();\r\n            if (map.isObjectLit()) {\r\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\r\n                    \/\/ May be STRING, GET, or SET,\r\n                    String name = key.getString();\r\n                    Property prop = new LiteralProperty(key, key.getFirstChild(), map, n, t.getModule());\r\n                    getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\r\n                }\r\n            }\r\n            break;\r\n    }\r\n}","code_comment":"\/**\r\n * Processes the GETPROP of prototype, which can either be under\r\n * another GETPROP (in the case of Foo.prototype.bar), or can be\r\n * under an assignment (in the case of Foo.prototype = ...).\r\n * @return True if a declaration was added.\r\n *\/\r\n","code_no_comment":"private void processPrototypeParent(NodeTraversal t, Node n) {\r\n    switch(n.getType()) {\r\n                case Token.GETPROP:\r\n            Node dest = n.getFirstChild().getNext();\r\n            Node parent = n.getParent();\r\n            Node grandParent = parent.getParent();\r\n            if (dest.isString() && NodeUtil.isExprAssign(grandParent) && NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\r\n                String name = dest.getString();\r\n                Property prop = new AssignmentProperty(grandParent, t.getModule());\r\n                getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\r\n            }\r\n            break;\r\n                case Token.ASSIGN:\r\n            Node map = n.getFirstChild().getNext();\r\n            if (map.isObjectLit()) {\r\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\r\n                                        String name = key.getString();\r\n                    Property prop = new LiteralProperty(key, key.getFirstChild(), map, n, t.getModule());\r\n                    getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\r\n                }\r\n            }\r\n            break;\r\n    }\r\n}","lc":0.4545454545,"pi":1.1866028708,"ma":0.8,"nbd":1.0,"ml":0.9166666667,"d":0.1091269841,"mi":-0.4415785765,"fo":1.5,"r":-0.0263157895,"e":0.4076762158}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-393_d4b02f6a","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic double getFunctionValue() {\r\n    return optimizer.getFunctionValue();\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public double getFunctionValue() {\r\n    return optimizer.getFunctionValue();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1987315011,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3603_aa1d177a","label":1,"code":"private void addToolbar(final AbstractToolbar toolbar, final RepeatingView container) {\r\n    if (toolbar == null) {\r\n        throw new IllegalArgumentException(\"argument [toolbar] cannot be null\");\r\n    }\r\n    container.add(toolbar);\r\n}","code_comment":null,"code_no_comment":"private void addToolbar(final AbstractToolbar toolbar, final RepeatingView container) {\r\n    if (toolbar == null) {\r\n        throw new IllegalArgumentException(\"argument [toolbar] cannot be null\");\r\n    }\r\n    container.add(toolbar);\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.5712473573,"fo":-0.4166666667,"r":1.0,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2802_88a97768","label":0,"code":"@SuppressWarnings(\"unchecked\")\r\npublic boolean processInput(OneInputStreamOperator<IN, ?> streamOperator, Object lock) throws Exception {\r\n    if (isFinished) {\r\n        return false;\r\n    }\r\n    while (true) {\r\n        if (currentRecordDeserializer != null) {\r\n            DeserializationResult result = currentRecordDeserializer.getNextRecord(deserializationDelegate);\r\n            if (result.isBufferConsumed()) {\r\n                currentRecordDeserializer.getCurrentBuffer().recycle();\r\n                currentRecordDeserializer = null;\r\n            }\r\n            if (result.isFullRecord()) {\r\n                StreamElement recordOrWatermark = deserializationDelegate.getInstance();\r\n                if (recordOrWatermark.isWatermark()) {\r\n                    long watermarkMillis = recordOrWatermark.asWatermark().getTimestamp();\r\n                    if (watermarkMillis > watermarks[currentChannel]) {\r\n                        watermarks[currentChannel] = watermarkMillis;\r\n                        long newMinWatermark = Long.MAX_VALUE;\r\n                        for (long watermark : watermarks) {\r\n                            newMinWatermark = Math.min(watermark, newMinWatermark);\r\n                        }\r\n                        if (newMinWatermark > lastEmittedWatermark) {\r\n                            lastEmittedWatermark = newMinWatermark;\r\n                            synchronized (lock) {\r\n                                streamOperator.processWatermark(new Watermark(lastEmittedWatermark));\r\n                            }\r\n                        }\r\n                    }\r\n                    continue;\r\n                } else {\r\n                    \/\/ now we can do the actual processing\r\n                    StreamRecord<IN> record = recordOrWatermark.asRecord();\r\n                    StreamingRuntimeContext ctx = streamOperator.getRuntimeContext();\r\n                    synchronized (lock) {\r\n                        if (ctx != null) {\r\n                            ctx.setNextInput(record);\r\n                        }\r\n                        streamOperator.processElement(record);\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        final BufferOrEvent bufferOrEvent = barrierHandler.getNextNonBlocked();\r\n        if (bufferOrEvent != null) {\r\n            if (bufferOrEvent.isBuffer()) {\r\n                currentChannel = bufferOrEvent.getChannelIndex();\r\n                currentRecordDeserializer = recordDeserializers[currentChannel];\r\n                currentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer());\r\n            } else {\r\n                \/\/ Event received\r\n                final AbstractEvent event = bufferOrEvent.getEvent();\r\n                if (event.getClass() != EndOfPartitionEvent.class) {\r\n                    throw new IOException(\"Unexpected event: \" + event);\r\n                }\r\n            }\r\n        } else {\r\n            isFinished = true;\r\n            if (!barrierHandler.isEmpty()) {\r\n                throw new IllegalStateException(\"Trailing data in checkpoint barrier handler.\");\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings(\"unchecked\")\r\npublic boolean processInput(OneInputStreamOperator<IN, ?> streamOperator, Object lock) throws Exception {\r\n    if (isFinished) {\r\n        return false;\r\n    }\r\n    while (true) {\r\n        if (currentRecordDeserializer != null) {\r\n            DeserializationResult result = currentRecordDeserializer.getNextRecord(deserializationDelegate);\r\n            if (result.isBufferConsumed()) {\r\n                currentRecordDeserializer.getCurrentBuffer().recycle();\r\n                currentRecordDeserializer = null;\r\n            }\r\n            if (result.isFullRecord()) {\r\n                StreamElement recordOrWatermark = deserializationDelegate.getInstance();\r\n                if (recordOrWatermark.isWatermark()) {\r\n                    long watermarkMillis = recordOrWatermark.asWatermark().getTimestamp();\r\n                    if (watermarkMillis > watermarks[currentChannel]) {\r\n                        watermarks[currentChannel] = watermarkMillis;\r\n                        long newMinWatermark = Long.MAX_VALUE;\r\n                        for (long watermark : watermarks) {\r\n                            newMinWatermark = Math.min(watermark, newMinWatermark);\r\n                        }\r\n                        if (newMinWatermark > lastEmittedWatermark) {\r\n                            lastEmittedWatermark = newMinWatermark;\r\n                            synchronized (lock) {\r\n                                streamOperator.processWatermark(new Watermark(lastEmittedWatermark));\r\n                            }\r\n                        }\r\n                    }\r\n                    continue;\r\n                } else {\r\n                                        StreamRecord<IN> record = recordOrWatermark.asRecord();\r\n                    StreamingRuntimeContext ctx = streamOperator.getRuntimeContext();\r\n                    synchronized (lock) {\r\n                        if (ctx != null) {\r\n                            ctx.setNextInput(record);\r\n                        }\r\n                        streamOperator.processElement(record);\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        final BufferOrEvent bufferOrEvent = barrierHandler.getNextNonBlocked();\r\n        if (bufferOrEvent != null) {\r\n            if (bufferOrEvent.isBuffer()) {\r\n                currentChannel = bufferOrEvent.getChannelIndex();\r\n                currentRecordDeserializer = recordDeserializers[currentChannel];\r\n                currentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer());\r\n            } else {\r\n                                final AbstractEvent event = bufferOrEvent.getEvent();\r\n                if (event.getClass() != EndOfPartitionEvent.class) {\r\n                    throw new IOException(\"Unexpected event: \" + event);\r\n                }\r\n            }\r\n        } else {\r\n            isFinished = true;\r\n            if (!barrierHandler.isEmpty()) {\r\n                throw new IllegalStateException(\"Trailing data in checkpoint barrier handler.\");\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n}","lc":2.2727272727,"pi":2.2057416268,"ma":2.8,"nbd":2.5,"ml":1.75,"d":0.3234126984,"mi":-1.0310077519,"fo":1.4166666667,"r":-0.0263157895,"e":1.2336831429}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-470_50340d0c","label":3,"code":"\/**\r\n * Create the Properties component.\r\n * @param properties An array of Property elements.\r\n * @param config The Configuration.\r\n * @return An Interpolator that includes the configuration properties.\r\n *\/\r\n@PluginFactory\r\npublic static StrLookup configureSubstitutor(@PluginElement(\"Properties\") final Property[] properties, @PluginConfiguration final Configuration config) {\r\n    if (properties == null) {\r\n        return new Interpolator(null);\r\n    }\r\n    final Map<String, String> map = new HashMap<String, String>(config.getProperties());\r\n    for (final Property prop : properties) {\r\n        map.put(prop.getName(), prop.getValue());\r\n    }\r\n    return new Interpolator(new MapLookup(map));\r\n}","code_comment":"\/**\r\n * Create the Properties component.\r\n * @param properties An array of Property elements.\r\n * @param config The Configuration.\r\n * @return An Interpolator that includes the configuration properties.\r\n *\/\r\n","code_no_comment":"@PluginFactory\r\npublic static StrLookup configureSubstitutor(@PluginElement(\"Properties\") final Property[] properties, @PluginConfiguration final Configuration config) {\r\n    if (properties == null) {\r\n        return new Interpolator(null);\r\n    }\r\n    final Map<String, String> map = new HashMap<String, String>(config.getProperties());\r\n    for (final Property prop : properties) {\r\n        map.put(prop.getName(), prop.getValue());\r\n    }\r\n    return new Interpolator(new MapLookup(map));\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0535714286,"mi":0.104721635,"fo":-0.1666666667,"r":0.3684210526,"e":-0.0354512082}
{"project_name":"Closure","project_version":"54","label":2,"code":"\/**\r\n * Sets the prototype, creating the prototype object from the given\r\n * base type.\r\n * @param baseType The base type.\r\n *\/\r\npublic void setPrototypeBasedOn(ObjectType baseType) {\r\n    \/\/ In the second case, we just use the anonymous object as the prototype.\r\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\r\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\r\n    }\r\n    setPrototype((PrototypeObjectType) baseType);\r\n}","code_comment":"\/**\r\n * Sets the prototype, creating the prototype object from the given\r\n * base type.\r\n * @param baseType The base type.\r\n *\/\r\n","code_no_comment":"public void setPrototypeBasedOn(ObjectType baseType) {\r\n        if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\r\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\r\n    }\r\n    setPrototype((PrototypeObjectType) baseType);\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":0.4166666667,"d":0.3055555556,"mi":0.4624383369,"fo":0.0,"r":0.0526315789,"e":0.0030405191}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-763_b2ec5106","label":1,"code":"@Override\r\npublic boolean equals(final Object o) {\r\n    if (this == o) {\r\n        return true;\r\n    }\r\n    if (o == null || getClass() != o.getClass()) {\r\n        return false;\r\n    }\r\n    final ObjectMessage that = (ObjectMessage) o;\r\n    return obj == null ? that.obj == null : obj.equals(that.obj);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean equals(final Object o) {\r\n    if (this == o) {\r\n        return true;\r\n    }\r\n    if (o == null || getClass() != o.getClass()) {\r\n        return false;\r\n    }\r\n    final ObjectMessage that = (ObjectMessage) o;\r\n    return obj == null ? that.obj == null : obj.equals(that.obj);\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":0.0,"nbd":-0.5,"ml":0.25,"d":0.494047619,"mi":0.1408033827,"fo":-0.25,"r":1.6578947368,"e":0.1009180339}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1008_0c20bfd8","label":1,"code":"String extractPath(final URL url) throws UnsupportedEncodingException {\r\n    \/\/ same as getFile but without the Query portion\r\n    String urlPath = url.getPath();\r\n    \/\/ I would be surprised if URL.getPath() ever starts with \"jar:\" but no harm in checking\r\n    if (urlPath.startsWith(\"jar:\")) {\r\n        urlPath = urlPath.substring(4);\r\n    }\r\n    \/\/ For jar: URLs, the path part starts with \"file:\"\r\n    if (urlPath.startsWith(\"file:\")) {\r\n        urlPath = urlPath.substring(5);\r\n    }\r\n    \/\/ If it was in a JAR, grab the path to the jar\r\n    if (urlPath.indexOf('!') > 0) {\r\n        urlPath = urlPath.substring(0, urlPath.indexOf('!'));\r\n    }\r\n    \/\/ LOG4J2-445\r\n    \/\/ Finally, decide whether to URL-decode the file name or not...\r\n    final String protocol = url.getProtocol();\r\n    final List<String> neverDecode = Arrays.asList(VFSZIP, BUNDLE_RESOURCE);\r\n    if (neverDecode.contains(protocol)) {\r\n        return urlPath;\r\n    }\r\n    if (new File(urlPath).exists()) {\r\n        \/\/ if URL-encoded file exists, don't decode it\r\n        return urlPath;\r\n    }\r\n    urlPath = URLDecoder.decode(urlPath, Constants.UTF_8.name());\r\n    return urlPath;\r\n}","code_comment":null,"code_no_comment":"String extractPath(final URL url) throws UnsupportedEncodingException {\r\n        String urlPath = url.getPath();\r\n        if (urlPath.startsWith(\"jar:\")) {\r\n        urlPath = urlPath.substring(4);\r\n    }\r\n        if (urlPath.startsWith(\"file:\")) {\r\n        urlPath = urlPath.substring(5);\r\n    }\r\n        if (urlPath.indexOf('!') > 0) {\r\n        urlPath = urlPath.substring(0, urlPath.indexOf('!'));\r\n    }\r\n            final String protocol = url.getProtocol();\r\n    final List<String> neverDecode = Arrays.asList(VFSZIP, BUNDLE_RESOURCE);\r\n    if (neverDecode.contains(protocol)) {\r\n        return urlPath;\r\n    }\r\n    if (new File(urlPath).exists()) {\r\n                return urlPath;\r\n    }\r\n    urlPath = URLDecoder.decode(urlPath, Constants.UTF_8.name());\r\n    return urlPath;\r\n}","lc":0.3636363636,"pi":-0.3827751196,"ma":0.4,"nbd":-0.5,"ml":0.5,"d":0.0079365079,"mi":-0.3353065539,"fo":0.6666666667,"r":-0.0263157895,"e":0.1482109}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-9269_62b2042b","label":1,"code":"\/**\r\n * Optionally a <tt>from<\/tt> route which means that this expression should only be based\r\n * on {@link Exchange} which is originated from the particular route(s).\r\n *\r\n * @param routeId id of route or pattern (see the EndpointHelper javadoc)\r\n * @return the builder\r\n * @see org.apache.camel.util.EndpointHelper#matchEndpoint(org.apache.camel.CamelContext, String, String)\r\n *\/\r\npublic NotifyBuilder fromRoute(final String routeId) {\r\n    stack.add(new EventPredicateSupport() {\r\n\r\n        @Override\r\n        public boolean isAbstract() {\r\n            \/\/ is abstract as its a filter\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean onExchange(Exchange exchange) {\r\n            String id = EndpointHelper.getRouteIdFromEndpoint(exchange.getFromEndpoint());\r\n            \/\/ filter non matching exchanges\r\n            return EndpointHelper.matchPattern(id, routeId);\r\n        }\r\n\r\n        public boolean matches() {\r\n            \/\/ should be true as we use the onExchange to filter\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"fromRoute(\" + routeId + \")\";\r\n        }\r\n    });\r\n    return this;\r\n}","code_comment":"\/**\r\n * Optionally a <tt>from<\/tt> route which means that this expression should only be based\r\n * on {@link Exchange} which is originated from the particular route(s).\r\n *\r\n * @param routeId id of route or pattern (see the EndpointHelper javadoc)\r\n * @return the builder\r\n * @see org.apache.camel.util.EndpointHelper#matchEndpoint(org.apache.camel.CamelContext, String, String)\r\n *\/\r\n","code_no_comment":"public NotifyBuilder fromRoute(final String routeId) {\r\n    stack.add(new EventPredicateSupport() {\r\n\r\n        @Override\r\n        public boolean isAbstract() {\r\n                        return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean onExchange(Exchange exchange) {\r\n            String id = EndpointHelper.getRouteIdFromEndpoint(exchange.getFromEndpoint());\r\n                        return EndpointHelper.matchPattern(id, routeId);\r\n        }\r\n\r\n        public boolean matches() {\r\n                        return true;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"fromRoute(\" + routeId + \")\";\r\n        }\r\n    });\r\n    return this;\r\n}","lc":0.3181818182,"pi":0.2296650718,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.0813492063,"mi":-0.1653276956,"fo":-0.1666666667,"r":0.3684210526,"e":-0.0552802798}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5326_ded3c583","label":1,"code":"@Override\r\npublic Url mapHandler(final IRequestHandler requestHandler) {\r\n    final Url url = wrappedMapper.mapHandler(requestHandler);\r\n    if (url == null) {\r\n        return null;\r\n    }\r\n    if (url.isFull()) {\r\n        \/\/ do not encrypt full urls\r\n        return url;\r\n    }\r\n    return encryptUrl(url);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Url mapHandler(final IRequestHandler requestHandler) {\r\n    final Url url = wrappedMapper.mapHandler(requestHandler);\r\n    if (url == null) {\r\n        return null;\r\n    }\r\n    if (url.isFull()) {\r\n                return url;\r\n    }\r\n    return encryptUrl(url);\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0218253968,"mi":0.2250880902,"fo":-0.25,"r":1.0263157895,"e":-0.1009088132}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2964_76bebd42","label":0,"code":"\/**\r\n *  Gets the number of memory segments used by this partition, which includes build side\r\n *  memory buffers and overflow memory segments.\r\n *\r\n *  @return The number of occupied memory segments.\r\n *\/\r\npublic int getNumOccupiedMemorySegments() {\r\n    \/\/ either the number of memory segments, or one for spilling\r\n    final int numPartitionBuffers = this.partitionBuffers != null ? this.partitionBuffers.length : 1;\r\n    return numPartitionBuffers + numOverflowSegments;\r\n}","code_comment":"\/**\r\n *  Gets the number of memory segments used by this partition, which includes build side\r\n *  memory buffers and overflow memory segments.\r\n *\r\n *  @return The number of occupied memory segments.\r\n *\/\r\n","code_no_comment":"public int getNumOccupiedMemorySegments() {\r\n        final int numPartitionBuffers = this.partitionBuffers != null ? this.partitionBuffers.length : 1;\r\n    return numPartitionBuffers + numOverflowSegments;\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.1170634921,"mi":0.7736434109,"fo":-0.5,"r":2.3947368421,"e":-0.1368740743}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7562_689147e9","label":1,"code":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nprivate static <T> void doFindType(List<ProcessorDefinition<?>> outputs, Class<T> type, List<T> found) {\r\n    if (outputs == null || outputs.isEmpty()) {\r\n        return;\r\n    }\r\n    for (ProcessorDefinition out : outputs) {\r\n        if (type.isInstance(out)) {\r\n            found.add((T) out);\r\n        }\r\n        \/\/ send is much common\r\n        if (out instanceof SendDefinition) {\r\n            SendDefinition send = (SendDefinition) out;\r\n            List<ProcessorDefinition<?>> children = send.getOutputs();\r\n            doFindType(children, type, found);\r\n        }\r\n        \/\/ special for choice\r\n        if (out instanceof ChoiceDefinition) {\r\n            ChoiceDefinition choice = (ChoiceDefinition) out;\r\n            for (WhenDefinition when : choice.getWhenClauses()) {\r\n                List<ProcessorDefinition<?>> children = when.getOutputs();\r\n                doFindType(children, type, found);\r\n            }\r\n            \/\/ otherwise is optional\r\n            if (choice.getOtherwise() != null) {\r\n                List<ProcessorDefinition<?>> children = choice.getOtherwise().getOutputs();\r\n                doFindType(children, type, found);\r\n            }\r\n        }\r\n        \/\/ special for try ... catch ... finally\r\n        if (out instanceof TryDefinition) {\r\n            TryDefinition doTry = (TryDefinition) out;\r\n            List<ProcessorDefinition<?>> doTryOut = doTry.getOutputsWithoutCatches();\r\n            doFindType(doTryOut, type, found);\r\n            List<CatchDefinition> doTryCatch = doTry.getCatchClauses();\r\n            for (CatchDefinition doCatch : doTryCatch) {\r\n                doFindType(doCatch.getOutputs(), type, found);\r\n            }\r\n            if (doTry.getFinallyClause() != null) {\r\n                doFindType(doTry.getFinallyClause().getOutputs(), type, found);\r\n            }\r\n            \/\/ do not check children as we already did that\r\n            continue;\r\n        }\r\n        \/\/ special for some types which has special outputs\r\n        if (out instanceof OutputDefinition) {\r\n            OutputDefinition outDef = (OutputDefinition) out;\r\n            List<ProcessorDefinition<?>> outDefOut = outDef.getOutputs();\r\n            doFindType(outDefOut, type, found);\r\n            \/\/ do not check children as we already did that\r\n            continue;\r\n        }\r\n        \/\/ try children as well\r\n        List<ProcessorDefinition<?>> children = out.getOutputs();\r\n        doFindType(children, type, found);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nprivate static <T> void doFindType(List<ProcessorDefinition<?>> outputs, Class<T> type, List<T> found) {\r\n    if (outputs == null || outputs.isEmpty()) {\r\n        return;\r\n    }\r\n    for (ProcessorDefinition out : outputs) {\r\n        if (type.isInstance(out)) {\r\n            found.add((T) out);\r\n        }\r\n                if (out instanceof SendDefinition) {\r\n            SendDefinition send = (SendDefinition) out;\r\n            List<ProcessorDefinition<?>> children = send.getOutputs();\r\n            doFindType(children, type, found);\r\n        }\r\n                if (out instanceof ChoiceDefinition) {\r\n            ChoiceDefinition choice = (ChoiceDefinition) out;\r\n            for (WhenDefinition when : choice.getWhenClauses()) {\r\n                List<ProcessorDefinition<?>> children = when.getOutputs();\r\n                doFindType(children, type, found);\r\n            }\r\n                        if (choice.getOtherwise() != null) {\r\n                List<ProcessorDefinition<?>> children = choice.getOtherwise().getOutputs();\r\n                doFindType(children, type, found);\r\n            }\r\n        }\r\n                if (out instanceof TryDefinition) {\r\n            TryDefinition doTry = (TryDefinition) out;\r\n            List<ProcessorDefinition<?>> doTryOut = doTry.getOutputsWithoutCatches();\r\n            doFindType(doTryOut, type, found);\r\n            List<CatchDefinition> doTryCatch = doTry.getCatchClauses();\r\n            for (CatchDefinition doCatch : doTryCatch) {\r\n                doFindType(doCatch.getOutputs(), type, found);\r\n            }\r\n            if (doTry.getFinallyClause() != null) {\r\n                doFindType(doTry.getFinallyClause().getOutputs(), type, found);\r\n            }\r\n                        continue;\r\n        }\r\n                if (out instanceof OutputDefinition) {\r\n            OutputDefinition outDef = (OutputDefinition) out;\r\n            List<ProcessorDefinition<?>> outDefOut = outDef.getOutputs();\r\n            doFindType(outDefOut, type, found);\r\n                        continue;\r\n        }\r\n                List<ProcessorDefinition<?>> children = out.getOutputs();\r\n        doFindType(children, type, found);\r\n    }\r\n}","lc":1.5454545455,"pi":0.5215311005,"ma":2.0,"nbd":0.5,"ml":0.8333333333,"d":1.0297619048,"mi":-0.8652572234,"fo":1.5833333333,"r":-0.0263157895,"e":2.5087556116}
{"project_name":"Time","project_version":"26","label":2,"code":"public long roundCeiling(long instant) {\r\n    if (iTimeField) {\r\n        int offset = getOffsetToAdd(instant);\r\n        instant = iField.roundCeiling(instant + offset);\r\n        return instant - offset;\r\n    } else {\r\n        long localInstant = iZone.convertUTCToLocal(instant);\r\n        localInstant = iField.roundCeiling(localInstant);\r\n        return iZone.convertLocalToUTC(localInstant, false);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public long roundCeiling(long instant) {\r\n    if (iTimeField) {\r\n        int offset = getOffsetToAdd(instant);\r\n        instant = iField.roundCeiling(instant + offset);\r\n        return instant - offset;\r\n    } else {\r\n        long localInstant = iZone.convertUTCToLocal(instant);\r\n        localInstant = iField.roundCeiling(localInstant);\r\n        return iZone.convertLocalToUTC(localInstant, false);\r\n    }\r\n}","lc":-0.1363636364,"pi":0.04784689,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.0654761905,"mi":0.1619450317,"fo":-0.0833333333,"r":0.1315789474,"e":-0.0379085193}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3123_f3c9c818","label":1,"code":"\/**\r\n * Retrieve the key at a given index. Keys are ordered according\r\n * the natural ordering of shorts.\r\n * @param index\r\n * @return the key at {@code index}\r\n *\/\r\npublic short getKey(int index) {\r\n    return keys[index];\r\n}","code_comment":"\/**\r\n * Retrieve the key at a given index. Keys are ordered according\r\n * the natural ordering of shorts.\r\n * @param index\r\n * @return the key at {@code index}\r\n *\/\r\n","code_no_comment":"public short getKey(int index) {\r\n    return keys[index];\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1319238901,"fo":-0.5,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"Math","project_version":"60","label":3,"code":"\/**\r\n * For this distribution, {@code X}, this method returns {@code P(X < x)}.\r\n * If {@code x}is more than 40 standard deviations from the mean, 0 or 1 is returned,\r\n * as in these cases the actual value is within {@code Double.MIN_VALUE} of 0 or 1.\r\n *\r\n * @param x Value at which the CDF is evaluated.\r\n * @return CDF evaluated at {@code x}.\r\n * @throws MathException if the algorithm fails to converge\r\n *\/\r\npublic double cumulativeProbability(double x) throws MathException {\r\n    final double dev = x - mean;\r\n    try {\r\n        return 0.5 * (1.0 + Erf.erf((dev) \/ (standardDeviation * FastMath.sqrt(2.0))));\r\n    } catch (MaxIterationsExceededException ex) {\r\n        if (x < (mean - 20 * standardDeviation)) {\r\n            \/\/ JDK 1.5 blows at 38\r\n            return 0;\r\n        } else if (x > (mean + 20 * standardDeviation)) {\r\n            return 1;\r\n        } else {\r\n            throw ex;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * For this distribution, {@code X}, this method returns {@code P(X < x)}.\r\n * If {@code x}is more than 40 standard deviations from the mean, 0 or 1 is returned,\r\n * as in these cases the actual value is within {@code Double.MIN_VALUE} of 0 or 1.\r\n *\r\n * @param x Value at which the CDF is evaluated.\r\n * @return CDF evaluated at {@code x}.\r\n * @throws MathException if the algorithm fails to converge\r\n *\/\r\n","code_no_comment":"public double cumulativeProbability(double x) throws MathException {\r\n    final double dev = x - mean;\r\n    try {\r\n        return 0.5 * (1.0 + Erf.erf((dev) \/ (standardDeviation * FastMath.sqrt(2.0))));\r\n    } catch (MaxIterationsExceededException ex) {\r\n        if (x < (mean - 20 * standardDeviation)) {\r\n                        return 0;\r\n        } else if (x > (mean + 20 * standardDeviation)) {\r\n            return 1;\r\n        } else {\r\n            throw ex;\r\n        }\r\n    }\r\n}","lc":0.0,"pi":0.4306220096,"ma":0.2,"nbd":0.5,"ml":0.0,"d":0.5436507937,"mi":-0.0311486963,"fo":-0.3333333333,"r":0.3157894737,"e":0.2440460342}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4529_03a383e3","label":1,"code":"private boolean isQualifiedForInterpolation(Field field, Class<?> fieldType) {\r\n    Boolean primitive = fieldIsPrimitiveByClass.get(fieldType);\r\n    if (primitive == null) {\r\n        primitive = Boolean.valueOf(fieldType.isPrimitive());\r\n        fieldIsPrimitiveByClass.put(fieldType, primitive);\r\n    }\r\n    if (primitive.booleanValue()) {\r\n        return false;\r\n    }\r\n    if (\"parent\".equals(field.getName())) {\r\n        return false;\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"private boolean isQualifiedForInterpolation(Field field, Class<?> fieldType) {\r\n    Boolean primitive = fieldIsPrimitiveByClass.get(fieldType);\r\n    if (primitive == null) {\r\n        primitive = Boolean.valueOf(fieldType.isPrimitive());\r\n        fieldIsPrimitiveByClass.put(fieldType, primitive);\r\n    }\r\n    if (primitive.booleanValue()) {\r\n        return false;\r\n    }\r\n    if (\"parent\".equals(field.getName())) {\r\n        return false;\r\n    }\r\n    return true;\r\n}","lc":0.0,"pi":-0.2057416268,"ma":0.0,"nbd":-0.5,"ml":0.1666666667,"d":-0.0575396825,"mi":0.0105708245,"fo":0.0833333333,"r":0.0263157895,"e":-0.0544458083}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4291_cdb34ffc","label":0,"code":"private synchronized void returnWriter(Object key, SegmentBufferWriter writer) {\r\n    if (borrowed.remove(writer)) {\r\n        checkState(writers.put(key, writer) == null);\r\n    } else {\r\n        \/\/ Defer flush this writer as it was borrowed while flush() was called.\r\n        disposed.add(writer);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private synchronized void returnWriter(Object key, SegmentBufferWriter writer) {\r\n    if (borrowed.remove(writer)) {\r\n        checkState(writers.put(key, writer) == null);\r\n    } else {\r\n                disposed.add(writer);\r\n    }\r\n}","lc":-0.3181818182,"pi":0.014354067,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.4446793517,"fo":-0.1666666667,"r":0.1315789474,"e":-0.1627934049}
{"project_name":"Time","project_version":"26","label":2,"code":"public long set(long instant, int value) {\r\n    long localInstant = iZone.convertUTCToLocal(instant);\r\n    localInstant = iField.set(localInstant, value);\r\n    long result = iZone.convertLocalToUTC(localInstant, false);\r\n    if (get(result) != value) {\r\n        throw new IllegalFieldValueException(iField.getType(), new Integer(value), \"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) + \" (\" + iZone.getID() + \")\");\r\n    }\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"public long set(long instant, int value) {\r\n    long localInstant = iZone.convertUTCToLocal(instant);\r\n    localInstant = iField.set(localInstant, value);\r\n    long result = iZone.convertLocalToUTC(localInstant, false);\r\n    if (get(result) != value) {\r\n        throw new IllegalFieldValueException(iField.getType(), new Integer(value), \"Illegal instant due to time zone offset transition: \" + DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) + \" (\" + iZone.getID() + \")\");\r\n    }\r\n    return result;\r\n}","lc":-0.2272727273,"pi":-0.3444976077,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0515873016,"mi":0.1749119098,"fo":0.1666666667,"r":-0.0263157895,"e":-0.0135428733}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7736_7ad36e3d","label":1,"code":"\/**\r\n * Sends an exchange to an endpoint using a supplied callback supporting the asynchronous routing engine.\r\n * <p\/>\r\n * If an exception was thrown during processing, it would be set on the given Exchange\r\n *\r\n * @param endpoint         the endpoint to send the exchange to\r\n * @param exchange         the exchange, can be <tt>null<\/tt> if so then create a new exchange from the producer\r\n * @param pattern          the exchange pattern, can be <tt>null<\/tt>\r\n * @param callback         the asynchronous callback\r\n * @param producerCallback the producer template callback to be executed\r\n * @return (doneSync) <tt>true<\/tt> to continue execute synchronously, <tt>false<\/tt> to continue being executed asynchronously\r\n *\/\r\npublic boolean doInAsyncProducer(final Endpoint endpoint, final Exchange exchange, final ExchangePattern pattern, final AsyncCallback callback, final AsyncProducerCallback producerCallback) {\r\n    boolean sync = true;\r\n    \/\/ get the producer and we do not mind if its pooled as we can handle returning it back to the pool\r\n    final Producer producer = doGetProducer(endpoint, true);\r\n    if (producer == null) {\r\n        if (isStopped()) {\r\n            LOG.warn(\"Ignoring exchange sent after processor is stopped: \" + exchange);\r\n            return false;\r\n        } else {\r\n            throw new IllegalStateException(\"No producer, this processor has not been started: \" + this);\r\n        }\r\n    }\r\n    \/\/ record timing for sending the exchange using the producer\r\n    final StopWatch watch = eventNotifierEnabled && exchange != null ? new StopWatch() : null;\r\n    try {\r\n        if (eventNotifierEnabled && exchange != null) {\r\n            EventHelper.notifyExchangeSending(exchange.getContext(), exchange, endpoint);\r\n        }\r\n        \/\/ invoke the callback\r\n        AsyncProcessor asyncProcessor = AsyncProcessorConverterHelper.convert(producer);\r\n        sync = producerCallback.doInAsyncProducer(producer, asyncProcessor, exchange, pattern, new AsyncCallback() {\r\n\r\n            @Override\r\n            public void done(boolean doneSync) {\r\n                try {\r\n                    if (eventNotifierEnabled && watch != null) {\r\n                        long timeTaken = watch.stop();\r\n                        \/\/ emit event that the exchange was sent to the endpoint\r\n                        EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken);\r\n                    }\r\n                    if (producer instanceof ServicePoolAware) {\r\n                        \/\/ release back to the pool\r\n                        pool.release(endpoint, producer);\r\n                    } else if (!producer.isSingleton()) {\r\n                        \/\/ stop and shutdown non-singleton producers as we should not leak resources\r\n                        try {\r\n                            ServiceHelper.stopAndShutdownService(producer);\r\n                        } catch (Exception e) {\r\n                            \/\/ ignore and continue\r\n                            LOG.warn(\"Error stopping\/shutting down producer: \" + producer, e);\r\n                        }\r\n                    }\r\n                } finally {\r\n                    callback.done(doneSync);\r\n                }\r\n            }\r\n        });\r\n    } catch (Throwable e) {\r\n        \/\/ ensure exceptions is caught and set on the exchange\r\n        if (exchange != null) {\r\n            exchange.setException(e);\r\n        }\r\n    }\r\n    return sync;\r\n}","code_comment":"\/**\r\n * Sends an exchange to an endpoint using a supplied callback supporting the asynchronous routing engine.\r\n * <p\/>\r\n * If an exception was thrown during processing, it would be set on the given Exchange\r\n *\r\n * @param endpoint         the endpoint to send the exchange to\r\n * @param exchange         the exchange, can be <tt>null<\/tt> if so then create a new exchange from the producer\r\n * @param pattern          the exchange pattern, can be <tt>null<\/tt>\r\n * @param callback         the asynchronous callback\r\n * @param producerCallback the producer template callback to be executed\r\n * @return (doneSync) <tt>true<\/tt> to continue execute synchronously, <tt>false<\/tt> to continue being executed asynchronously\r\n *\/\r\n","code_no_comment":"public boolean doInAsyncProducer(final Endpoint endpoint, final Exchange exchange, final ExchangePattern pattern, final AsyncCallback callback, final AsyncProducerCallback producerCallback) {\r\n    boolean sync = true;\r\n        final Producer producer = doGetProducer(endpoint, true);\r\n    if (producer == null) {\r\n        if (isStopped()) {\r\n            LOG.warn(\"Ignoring exchange sent after processor is stopped: \" + exchange);\r\n            return false;\r\n        } else {\r\n            throw new IllegalStateException(\"No producer, this processor has not been started: \" + this);\r\n        }\r\n    }\r\n        final StopWatch watch = eventNotifierEnabled && exchange != null ? new StopWatch() : null;\r\n    try {\r\n        if (eventNotifierEnabled && exchange != null) {\r\n            EventHelper.notifyExchangeSending(exchange.getContext(), exchange, endpoint);\r\n        }\r\n                AsyncProcessor asyncProcessor = AsyncProcessorConverterHelper.convert(producer);\r\n        sync = producerCallback.doInAsyncProducer(producer, asyncProcessor, exchange, pattern, new AsyncCallback() {\r\n\r\n            @Override\r\n            public void done(boolean doneSync) {\r\n                try {\r\n                    if (eventNotifierEnabled && watch != null) {\r\n                        long timeTaken = watch.stop();\r\n                                                EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken);\r\n                    }\r\n                    if (producer instanceof ServicePoolAware) {\r\n                                                pool.release(endpoint, producer);\r\n                    } else if (!producer.isSingleton()) {\r\n                                                try {\r\n                            ServiceHelper.stopAndShutdownService(producer);\r\n                        } catch (Exception e) {\r\n                                                        LOG.warn(\"Error stopping\/shutting down producer: \" + producer, e);\r\n                        }\r\n                    }\r\n                } finally {\r\n                    callback.done(doneSync);\r\n                }\r\n            }\r\n        });\r\n    } catch (Throwable e) {\r\n                if (exchange != null) {\r\n            exchange.setException(e);\r\n        }\r\n    }\r\n    return sync;\r\n}","lc":1.4545454545,"pi":2.3110047847,"ma":1.6,"nbd":2.0,"ml":1.0,"d":0.8134920635,"mi":-0.8105708245,"fo":0.8333333333,"r":-0.0263157895,"e":1.7790817356}
{"project_name":"Closure","project_version":"174","label":2,"code":"private void findAliases(NodeTraversal t) {\r\n    Scope scope = t.getScope();\r\n    for (Var v : scope.getVarIterable()) {\r\n        Node n = v.getNode();\r\n        Node parent = n.getParent();\r\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\r\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\r\n            recordAlias(v);\r\n        } else if (v.isBleedingFunction()) {\r\n        \/\/ Bleeding functions already get a BAD_PARAMETERS error, so just\r\n        \/\/ do nothing.\r\n        } else if (parent.getType() == Token.LP) {\r\n        \/\/ Parameters of the scope function also get a BAD_PARAMETERS\r\n        \/\/ error.\r\n        } else if (isVarAssign) {\r\n            Node value = v.getInitialValue().detachFromParent();\r\n            String name = n.getString();\r\n            int nameCount = scopedAliasNames.count(name);\r\n            scopedAliasNames.add(name);\r\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\r\n            compiler.ensureLibraryInjected(\"base\");\r\n            \/\/ Add $jscomp.scope.name = EXPR;\r\n            \/\/ Make sure we copy over all the jsdoc and debug info.\r\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\r\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\r\n            parent.getParent().addChildBefore(newDecl, parent);\r\n            \/\/ Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\r\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\r\n            recordAlias(v);\r\n        } else {\r\n            \/\/ Do not allow hoisted functions or other kinds of local symbols.\r\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void findAliases(NodeTraversal t) {\r\n    Scope scope = t.getScope();\r\n    for (Var v : scope.getVarIterable()) {\r\n        Node n = v.getNode();\r\n        Node parent = n.getParent();\r\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\r\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\r\n            recordAlias(v);\r\n        } else if (v.isBleedingFunction()) {\r\n                        } else if (parent.getType() == Token.LP) {\r\n                        } else if (isVarAssign) {\r\n            Node value = v.getInitialValue().detachFromParent();\r\n            String name = n.getString();\r\n            int nameCount = scopedAliasNames.count(name);\r\n            scopedAliasNames.add(name);\r\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\r\n            compiler.ensureLibraryInjected(\"base\");\r\n                                    Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\r\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\r\n            parent.getParent().addChildBefore(newDecl, parent);\r\n                        v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\r\n            recordAlias(v);\r\n        } else {\r\n                        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\r\n        }\r\n    }\r\n}","lc":0.5909090909,"pi":0.3205741627,"ma":0.6,"nbd":1.5,"ml":0.5,"d":0.4007936508,"mi":-0.5385482734,"fo":2.25,"r":-0.0263157895,"e":1.1292082318}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8125_36e7b668","label":3,"code":"private void doStartCamel() throws Exception {\r\n    if (applicationContextClassLoader == null) {\r\n        \/\/ Using the TCCL as the default value of ApplicationClassLoader\r\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\r\n        if (cl == null) {\r\n            \/\/ use the classloader that loaded this class\r\n            cl = this.getClass().getClassLoader();\r\n        }\r\n        setApplicationContextClassLoader(cl);\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Using ClassResolver={}, PackageScanClassResolver={}, ApplicationContextClassLoader={}\", new Object[] { getClassResolver(), getPackageScanClassResolver(), getApplicationContextClassLoader() });\r\n    }\r\n    if (isStreamCaching()) {\r\n        log.info(\"StreamCaching is enabled on CamelContext: {}\", getName());\r\n    }\r\n    if (isTracing()) {\r\n        \/\/ tracing is added in the DefaultChannel so we can enable it on the fly\r\n        log.info(\"Tracing is enabled on CamelContext: {}\", getName());\r\n    }\r\n    if (isUseMDCLogging()) {\r\n        \/\/ log if MDC has been enabled\r\n        log.info(\"MDC logging is enabled on CamelContext: {}\", getName());\r\n    }\r\n    if (isHandleFault()) {\r\n        \/\/ only add a new handle fault if not already configured\r\n        if (HandleFault.getHandleFault(this) == null) {\r\n            log.info(\"HandleFault is enabled on CamelContext: {}\", getName());\r\n            addInterceptStrategy(new HandleFault());\r\n        }\r\n    }\r\n    if (getDelayer() != null && getDelayer() > 0) {\r\n        log.info(\"Delayer is enabled with: {} ms. on CamelContext: {}\", getDelayer(), getName());\r\n    }\r\n    \/\/ register debugger\r\n    if (getDebugger() != null) {\r\n        log.info(\"Debugger: {} is enabled on CamelContext: {}\", getDebugger(), getName());\r\n        \/\/ register this camel context on the debugger\r\n        getDebugger().setCamelContext(this);\r\n        startService(getDebugger());\r\n        addInterceptStrategy(new Debug(getDebugger()));\r\n    }\r\n    \/\/ start management strategy before lifecycles are started\r\n    ManagementStrategy managementStrategy = getManagementStrategy();\r\n    \/\/ inject CamelContext if aware\r\n    if (managementStrategy instanceof CamelContextAware) {\r\n        ((CamelContextAware) managementStrategy).setCamelContext(this);\r\n    }\r\n    ServiceHelper.startService(managementStrategy);\r\n    \/\/ start lifecycle strategies\r\n    ServiceHelper.startServices(lifecycleStrategies);\r\n    Iterator<LifecycleStrategy> it = lifecycleStrategies.iterator();\r\n    while (it.hasNext()) {\r\n        LifecycleStrategy strategy = it.next();\r\n        try {\r\n            strategy.onContextStart(this);\r\n        } catch (VetoCamelContextStartException e) {\r\n            \/\/ okay we should not start Camel since it was vetoed\r\n            log.warn(\"Lifecycle strategy vetoed starting CamelContext ({}) due {}\", getName(), e.getMessage());\r\n            throw e;\r\n        } catch (Exception e) {\r\n            log.warn(\"Lifecycle strategy \" + strategy + \" failed starting CamelContext ({}) due {}\", getName(), e.getMessage());\r\n            throw e;\r\n        }\r\n    }\r\n    \/\/ start notifiers as services\r\n    for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {\r\n        if (notifier instanceof Service) {\r\n            Service service = (Service) notifier;\r\n            for (LifecycleStrategy strategy : lifecycleStrategies) {\r\n                strategy.onServiceAdd(this, service, null);\r\n            }\r\n        }\r\n        if (notifier instanceof Service) {\r\n            startService((Service) notifier);\r\n        }\r\n    }\r\n    \/\/ must let some bootstrap service be started before we can notify the starting event\r\n    EventHelper.notifyCamelContextStarting(this);\r\n    forceLazyInitialization();\r\n    \/\/ re-create endpoint registry as the cache size limit may be set after the constructor of this instance was called.\r\n    \/\/ and we needed to create endpoints up-front as it may be accessed before this context is started\r\n    endpoints = new EndpointRegistry(this, endpoints);\r\n    addService(endpoints);\r\n    \/\/ special for executorServiceManager as want to stop it manually\r\n    doAddService(executorServiceManager, false);\r\n    addService(producerServicePool);\r\n    addService(inflightRepository);\r\n    addService(shutdownStrategy);\r\n    addService(packageScanClassResolver);\r\n    addService(restRegistry);\r\n    if (runtimeEndpointRegistry != null) {\r\n        if (runtimeEndpointRegistry instanceof EventNotifier) {\r\n            getManagementStrategy().addEventNotifier((EventNotifier) runtimeEndpointRegistry);\r\n        }\r\n        addService(runtimeEndpointRegistry);\r\n    }\r\n    \/\/ eager lookup any configured properties component to avoid subsequent lookup attempts which may impact performance\r\n    \/\/ due we use properties component for property placeholder resolution at runtime\r\n    Component existing = lookupPropertiesComponent();\r\n    if (existing != null) {\r\n        \/\/ store reference to the existing properties component\r\n        if (existing instanceof PropertiesComponent) {\r\n            propertiesComponent = (PropertiesComponent) existing;\r\n        } else {\r\n            \/\/ properties component must be expected type\r\n            throw new IllegalArgumentException(\"Found properties component of type: \" + existing.getClass() + \" instead of expected: \" + PropertiesComponent.class);\r\n        }\r\n    }\r\n    \/\/ start components\r\n    startServices(components.values());\r\n    \/\/ start the route definitions before the routes is started\r\n    startRouteDefinitions(routeDefinitions);\r\n    \/\/ is there any stream caching enabled then log an info about this and its limit of spooling to disk, so people is aware of this\r\n    boolean streamCachingInUse = isStreamCaching();\r\n    if (!streamCachingInUse) {\r\n        for (RouteDefinition route : routeDefinitions) {\r\n            Boolean routeCache = CamelContextHelper.parseBoolean(this, route.getStreamCache());\r\n            if (routeCache != null && routeCache) {\r\n                streamCachingInUse = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (isAllowUseOriginalMessage()) {\r\n        log.info(\"AllowUseOriginalMessage is enabled. If access to the original message is not needed,\" + \" then its recommended to turn this option off as it may improve performance.\");\r\n    }\r\n    if (streamCachingInUse) {\r\n        \/\/ stream caching is in use so enable the strategy\r\n        getStreamCachingStrategy().setEnabled(true);\r\n        addService(getStreamCachingStrategy());\r\n    } else {\r\n        \/\/ log if stream caching is not in use as this can help people to enable it if they use streams\r\n        log.info(\"StreamCaching is not in use. If using streams then its recommended to enable stream caching.\" + \" See more details at http:\/\/camel.apache.org\/stream-caching.html\");\r\n    }\r\n    \/\/ start routes\r\n    if (doNotStartRoutesOnFirstStart) {\r\n        log.debug(\"Skip starting of routes as CamelContext has been configured with autoStartup=false\");\r\n    }\r\n    \/\/ invoke this logic to warmup the routes and if possible also start the routes\r\n    doStartOrResumeRoutes(routeServices, true, !doNotStartRoutesOnFirstStart, false, true);\r\n\/\/ starting will continue in the start method\r\n}","code_comment":null,"code_no_comment":"private void doStartCamel() throws Exception {\r\n    if (applicationContextClassLoader == null) {\r\n                ClassLoader cl = Thread.currentThread().getContextClassLoader();\r\n        if (cl == null) {\r\n                        cl = this.getClass().getClassLoader();\r\n        }\r\n        setApplicationContextClassLoader(cl);\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Using ClassResolver={}, PackageScanClassResolver={}, ApplicationContextClassLoader={}\", new Object[] { getClassResolver(), getPackageScanClassResolver(), getApplicationContextClassLoader() });\r\n    }\r\n    if (isStreamCaching()) {\r\n        log.info(\"StreamCaching is enabled on CamelContext: {}\", getName());\r\n    }\r\n    if (isTracing()) {\r\n                log.info(\"Tracing is enabled on CamelContext: {}\", getName());\r\n    }\r\n    if (isUseMDCLogging()) {\r\n                log.info(\"MDC logging is enabled on CamelContext: {}\", getName());\r\n    }\r\n    if (isHandleFault()) {\r\n                if (HandleFault.getHandleFault(this) == null) {\r\n            log.info(\"HandleFault is enabled on CamelContext: {}\", getName());\r\n            addInterceptStrategy(new HandleFault());\r\n        }\r\n    }\r\n    if (getDelayer() != null && getDelayer() > 0) {\r\n        log.info(\"Delayer is enabled with: {} ms. on CamelContext: {}\", getDelayer(), getName());\r\n    }\r\n        if (getDebugger() != null) {\r\n        log.info(\"Debugger: {} is enabled on CamelContext: {}\", getDebugger(), getName());\r\n                getDebugger().setCamelContext(this);\r\n        startService(getDebugger());\r\n        addInterceptStrategy(new Debug(getDebugger()));\r\n    }\r\n        ManagementStrategy managementStrategy = getManagementStrategy();\r\n        if (managementStrategy instanceof CamelContextAware) {\r\n        ((CamelContextAware) managementStrategy).setCamelContext(this);\r\n    }\r\n    ServiceHelper.startService(managementStrategy);\r\n        ServiceHelper.startServices(lifecycleStrategies);\r\n    Iterator<LifecycleStrategy> it = lifecycleStrategies.iterator();\r\n    while (it.hasNext()) {\r\n        LifecycleStrategy strategy = it.next();\r\n        try {\r\n            strategy.onContextStart(this);\r\n        } catch (VetoCamelContextStartException e) {\r\n                        log.warn(\"Lifecycle strategy vetoed starting CamelContext ({}) due {}\", getName(), e.getMessage());\r\n            throw e;\r\n        } catch (Exception e) {\r\n            log.warn(\"Lifecycle strategy \" + strategy + \" failed starting CamelContext ({}) due {}\", getName(), e.getMessage());\r\n            throw e;\r\n        }\r\n    }\r\n        for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {\r\n        if (notifier instanceof Service) {\r\n            Service service = (Service) notifier;\r\n            for (LifecycleStrategy strategy : lifecycleStrategies) {\r\n                strategy.onServiceAdd(this, service, null);\r\n            }\r\n        }\r\n        if (notifier instanceof Service) {\r\n            startService((Service) notifier);\r\n        }\r\n    }\r\n        EventHelper.notifyCamelContextStarting(this);\r\n    forceLazyInitialization();\r\n            endpoints = new EndpointRegistry(this, endpoints);\r\n    addService(endpoints);\r\n        doAddService(executorServiceManager, false);\r\n    addService(producerServicePool);\r\n    addService(inflightRepository);\r\n    addService(shutdownStrategy);\r\n    addService(packageScanClassResolver);\r\n    addService(restRegistry);\r\n    if (runtimeEndpointRegistry != null) {\r\n        if (runtimeEndpointRegistry instanceof EventNotifier) {\r\n            getManagementStrategy().addEventNotifier((EventNotifier) runtimeEndpointRegistry);\r\n        }\r\n        addService(runtimeEndpointRegistry);\r\n    }\r\n            Component existing = lookupPropertiesComponent();\r\n    if (existing != null) {\r\n                if (existing instanceof PropertiesComponent) {\r\n            propertiesComponent = (PropertiesComponent) existing;\r\n        } else {\r\n                        throw new IllegalArgumentException(\"Found properties component of type: \" + existing.getClass() + \" instead of expected: \" + PropertiesComponent.class);\r\n        }\r\n    }\r\n        startServices(components.values());\r\n        startRouteDefinitions(routeDefinitions);\r\n        boolean streamCachingInUse = isStreamCaching();\r\n    if (!streamCachingInUse) {\r\n        for (RouteDefinition route : routeDefinitions) {\r\n            Boolean routeCache = CamelContextHelper.parseBoolean(this, route.getStreamCache());\r\n            if (routeCache != null && routeCache) {\r\n                streamCachingInUse = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (isAllowUseOriginalMessage()) {\r\n        log.info(\"AllowUseOriginalMessage is enabled. If access to the original message is not needed,\" + \" then its recommended to turn this option off as it may improve performance.\");\r\n    }\r\n    if (streamCachingInUse) {\r\n                getStreamCachingStrategy().setEnabled(true);\r\n        addService(getStreamCachingStrategy());\r\n    } else {\r\n                log.info(\"StreamCaching is not in use. If using streams then its recommended to enable stream caching.\" + \" See more details at http:\/\/camel.apache.org\/stream-caching.html\");\r\n    }\r\n        if (doNotStartRoutesOnFirstStart) {\r\n        log.debug(\"Skip starting of routes as CamelContext has been configured with autoStartup=false\");\r\n    }\r\n        doStartOrResumeRoutes(routeServices, true, !doNotStartRoutesOnFirstStart, false, true);\r\n}","lc":4.5909090909,"pi":0.1866028708,"ma":5.8,"nbd":0.5,"ml":3.25,"d":0.8313492063,"mi":-1.5062720226,"fo":6.6666666667,"r":-0.0263157895,"e":4.9844205091}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4307_f303c916","label":1,"code":"private RecordId internalWriteStream(InputStream stream) throws IOException {\r\n    if (stream instanceof SegmentStream) {\r\n        SegmentStream segmentStream = (SegmentStream) stream;\r\n        List<RecordId> blockIds = segmentStream.getBlockIds();\r\n        if (blockIds != null) {\r\n            return writeValueRecord(segmentStream.getLength(), writeList(blockIds));\r\n        }\r\n    }\r\n    \/\/ Special case for short binaries (up to about 16kB):\r\n    \/\/ store them directly as small- or medium-sized value records\r\n    byte[] data = new byte[Segment.MEDIUM_LIMIT];\r\n    int n = read(stream, data, 0, data.length);\r\n    if (n < Segment.MEDIUM_LIMIT) {\r\n        return writeValueRecord(n, data);\r\n    }\r\n    BlobStore blobStore = store.getBlobStore();\r\n    if (blobStore != null) {\r\n        String blobId = blobStore.writeBlob(new SequenceInputStream(new ByteArrayInputStream(data, 0, n), stream));\r\n        return writeBlobId(blobId);\r\n    }\r\n    data = Arrays.copyOf(data, Segment.MAX_SEGMENT_SIZE);\r\n    n += read(stream, data, n, Segment.MAX_SEGMENT_SIZE - n);\r\n    long length = n;\r\n    List<RecordId> blockIds = newArrayListWithExpectedSize(2 * n \/ BLOCK_SIZE);\r\n    \/\/ Write the data to bulk segments and collect the list of block ids\r\n    while (n != 0) {\r\n        SegmentId bulkId = getTracker().newBulkSegmentId();\r\n        int len = Segment.align(n, 1 << Segment.RECORD_ALIGN_BITS);\r\n        LOG.debug(\"Writing bulk segment {} ({} bytes)\", bulkId, n);\r\n        store.writeSegment(bulkId, data, 0, len);\r\n        for (int i = 0; i < n; i += BLOCK_SIZE) {\r\n            blockIds.add(new RecordId(bulkId, data.length - len + i));\r\n        }\r\n        n = read(stream, data, 0, data.length);\r\n        length += n;\r\n    }\r\n    return writeValueRecord(length, writeList(blockIds));\r\n}","code_comment":null,"code_no_comment":"private RecordId internalWriteStream(InputStream stream) throws IOException {\r\n    if (stream instanceof SegmentStream) {\r\n        SegmentStream segmentStream = (SegmentStream) stream;\r\n        List<RecordId> blockIds = segmentStream.getBlockIds();\r\n        if (blockIds != null) {\r\n            return writeValueRecord(segmentStream.getLength(), writeList(blockIds));\r\n        }\r\n    }\r\n            byte[] data = new byte[Segment.MEDIUM_LIMIT];\r\n    int n = read(stream, data, 0, data.length);\r\n    if (n < Segment.MEDIUM_LIMIT) {\r\n        return writeValueRecord(n, data);\r\n    }\r\n    BlobStore blobStore = store.getBlobStore();\r\n    if (blobStore != null) {\r\n        String blobId = blobStore.writeBlob(new SequenceInputStream(new ByteArrayInputStream(data, 0, n), stream));\r\n        return writeBlobId(blobId);\r\n    }\r\n    data = Arrays.copyOf(data, Segment.MAX_SEGMENT_SIZE);\r\n    n += read(stream, data, n, Segment.MAX_SEGMENT_SIZE - n);\r\n    long length = n;\r\n    List<RecordId> blockIds = newArrayListWithExpectedSize(2 * n \/ BLOCK_SIZE);\r\n        while (n != 0) {\r\n        SegmentId bulkId = getTracker().newBulkSegmentId();\r\n        int len = Segment.align(n, 1 << Segment.RECORD_ALIGN_BITS);\r\n        LOG.debug(\"Writing bulk segment {} ({} bytes)\", bulkId, n);\r\n        store.writeSegment(bulkId, data, 0, len);\r\n        for (int i = 0; i < n; i += BLOCK_SIZE) {\r\n            blockIds.add(new RecordId(bulkId, data.length - len + i));\r\n        }\r\n        n = read(stream, data, 0, data.length);\r\n        length += n;\r\n    }\r\n    return writeValueRecord(length, writeList(blockIds));\r\n}","lc":0.9545454545,"pi":-0.1052631579,"ma":0.6,"nbd":0.0,"ml":0.5,"d":1.6488095238,"mi":-0.695278365,"fo":1.25,"r":-0.0263157895,"e":4.2515839399}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"public String getIndexName() {\r\n    return TYPE;\r\n}","code_comment":null,"code_no_comment":"public String getIndexName() {\r\n    return TYPE;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1646229739,"fo":-0.5,"r":2.3947368421,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3475_7651b777","label":1,"code":"public boolean config(String... args) {\r\n    configError = super.config(args);\r\n    \/\/ Update the ConsoleReader with the input and output \"redirected\"\r\n    try {\r\n        this.reader = new ConsoleReader(in, writer);\r\n    } catch (Exception e) {\r\n        printException(e);\r\n        configError = true;\r\n    }\r\n    \/\/ Don't need this for testing purposes\r\n    this.reader.setUseHistory(false);\r\n    this.reader.setUsePagination(false);\r\n    \/\/ Make the parsing from the client easier;\r\n    this.verbose = false;\r\n    return configError;\r\n}","code_comment":null,"code_no_comment":"public boolean config(String... args) {\r\n    configError = super.config(args);\r\n        try {\r\n        this.reader = new ConsoleReader(in, writer);\r\n    } catch (Exception e) {\r\n        printException(e);\r\n        configError = true;\r\n    }\r\n        this.reader.setUseHistory(false);\r\n    this.reader.setUsePagination(false);\r\n        this.verbose = false;\r\n    return configError;\r\n}","lc":-0.0454545455,"pi":-0.2535885167,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.0855532065,"fo":-0.1666666667,"r":0.2368421053,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-2712_06090da4","label":1,"code":"protected void updateRepositoryMetadata(ArtifactRepository localRepository, ArtifactRepository remoteRepository) throws IOException, XmlPullParserException {\r\n    MetadataXpp3Reader mappingReader = new MetadataXpp3Reader();\r\n    Metadata metadata = null;\r\n    File metadataFile = new File(localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata(this, remoteRepository));\r\n    if (metadataFile.exists()) {\r\n        Reader reader = null;\r\n        try {\r\n            reader = new FileReader(metadataFile);\r\n            metadata = mappingReader.read(reader, false);\r\n        } finally {\r\n            IOUtil.close(reader);\r\n        }\r\n    }\r\n    boolean changed;\r\n    \/\/ If file could not be found or was not valid, start from scratch\r\n    if (metadata == null) {\r\n        metadata = this.metadata;\r\n        changed = true;\r\n    } else {\r\n        changed = metadata.merge(this.metadata);\r\n    }\r\n    \/\/ beware meta-versions!\r\n    String version = metadata.getVersion();\r\n    if (version != null && (Artifact.LATEST_VERSION.equals(version) || Artifact.RELEASE_VERSION.equals(version))) {\r\n        \/\/ meta-versions are not valid <version\/> values...don't write them.\r\n        changed = false;\r\n    }\r\n    if (changed) {\r\n        Writer writer = null;\r\n        try {\r\n            metadataFile.getParentFile().mkdirs();\r\n            writer = new FileWriter(metadataFile);\r\n            MetadataXpp3Writer mappingWriter = new MetadataXpp3Writer();\r\n            mappingWriter.write(writer, metadata);\r\n        } finally {\r\n            IOUtil.close(writer);\r\n        }\r\n    } else {\r\n        metadataFile.setLastModified(System.currentTimeMillis());\r\n    }\r\n}","code_comment":null,"code_no_comment":"protected void updateRepositoryMetadata(ArtifactRepository localRepository, ArtifactRepository remoteRepository) throws IOException, XmlPullParserException {\r\n    MetadataXpp3Reader mappingReader = new MetadataXpp3Reader();\r\n    Metadata metadata = null;\r\n    File metadataFile = new File(localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata(this, remoteRepository));\r\n    if (metadataFile.exists()) {\r\n        Reader reader = null;\r\n        try {\r\n            reader = new FileReader(metadataFile);\r\n            metadata = mappingReader.read(reader, false);\r\n        } finally {\r\n            IOUtil.close(reader);\r\n        }\r\n    }\r\n    boolean changed;\r\n        if (metadata == null) {\r\n        metadata = this.metadata;\r\n        changed = true;\r\n    } else {\r\n        changed = metadata.merge(this.metadata);\r\n    }\r\n        String version = metadata.getVersion();\r\n    if (version != null && (Artifact.LATEST_VERSION.equals(version) || Artifact.RELEASE_VERSION.equals(version))) {\r\n                changed = false;\r\n    }\r\n    if (changed) {\r\n        Writer writer = null;\r\n        try {\r\n            metadataFile.getParentFile().mkdirs();\r\n            writer = new FileWriter(metadataFile);\r\n            MetadataXpp3Writer mappingWriter = new MetadataXpp3Writer();\r\n            mappingWriter.write(writer, metadata);\r\n        } finally {\r\n            IOUtil.close(writer);\r\n        }\r\n    } else {\r\n        metadataFile.setLastModified(System.currentTimeMillis());\r\n    }\r\n}","lc":1.0909090909,"pi":0.2057416268,"ma":0.2,"nbd":0.0,"ml":0.5833333333,"d":0.4206349206,"mi":-0.6546863989,"fo":0.75,"r":-0.0263157895,"e":0.9384923036}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1959_93c1aa40","label":1,"code":"private void mergeWithConcurrencyCheck(NodeBuilder builder, final String checkpoint, final long lease) throws CommitFailedException {\r\n    CommitHook concurrentUpdateCheck = new CommitHook() {\r\n\r\n        @Override\r\n        @Nonnull\r\n        public NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {\r\n            \/\/ check for concurrent updates by this async task\r\n            NodeState async = before.getChildNode(ASYNC);\r\n            if (Objects.equal(checkpoint, async.getString(name)) && lease == async.getLong(name + \"-lease\")) {\r\n                return after;\r\n            } else {\r\n                throw CONCURRENT_UPDATE;\r\n            }\r\n        }\r\n    };\r\n    CompositeHook hooks = new CompositeHook(new ConflictHook(new AnnotatingConflictHandler()), new EditorHook(new ConflictValidatorProvider()), concurrentUpdateCheck);\r\n    store.merge(builder, hooks, CommitInfo.EMPTY);\r\n}","code_comment":null,"code_no_comment":"private void mergeWithConcurrencyCheck(NodeBuilder builder, final String checkpoint, final long lease) throws CommitFailedException {\r\n    CommitHook concurrentUpdateCheck = new CommitHook() {\r\n\r\n        @Override\r\n        @Nonnull\r\n        public NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {\r\n                        NodeState async = before.getChildNode(ASYNC);\r\n            if (Objects.equal(checkpoint, async.getString(name)) && lease == async.getLong(name + \"-lease\")) {\r\n                return after;\r\n            } else {\r\n                throw CONCURRENT_UPDATE;\r\n            }\r\n        }\r\n    };\r\n    CompositeHook hooks = new CompositeHook(new ConflictHook(new AnnotatingConflictHandler()), new EditorHook(new ConflictValidatorProvider()), concurrentUpdateCheck);\r\n    store.merge(builder, hooks, CommitInfo.EMPTY);\r\n}","lc":0.0909090909,"pi":0.9138755981,"ma":-0.2,"nbd":0.0,"ml":0.25,"d":0.2142857143,"mi":-0.1540521494,"fo":-0.0833333333,"r":-0.0263157895,"e":0.2697947822}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1730_872b6db3","label":3,"code":"Node parse_(byte[] expression) {\r\n    Node result = null;\r\n    Node expr = null;\r\n    int wholeTermStart = index;\r\n    int subtermStart = index;\r\n    boolean subtermComplete = false;\r\n    while (index < expression.length) {\r\n        switch(expression[index++]) {\r\n            case '&':\r\n                {\r\n                    expr = processTerm(subtermStart, index - 1, expr, expression);\r\n                    if (result != null) {\r\n                        if (!result.type.equals(NodeType.AND))\r\n                            throw new BadArgumentException(\"cannot mix & and |\", new String(expression), index - 1);\r\n                    } else {\r\n                        result = new Node(NodeType.AND, wholeTermStart);\r\n                    }\r\n                    result.add(expr);\r\n                    expr = null;\r\n                    subtermStart = index;\r\n                    subtermComplete = false;\r\n                    break;\r\n                }\r\n            case '|':\r\n                {\r\n                    expr = processTerm(subtermStart, index - 1, expr, expression);\r\n                    if (result != null) {\r\n                        if (!result.type.equals(NodeType.OR))\r\n                            throw new BadArgumentException(\"cannot mix | and &\", new String(expression), index - 1);\r\n                    } else {\r\n                        result = new Node(NodeType.OR, wholeTermStart);\r\n                    }\r\n                    result.add(expr);\r\n                    expr = null;\r\n                    subtermStart = index;\r\n                    subtermComplete = false;\r\n                    break;\r\n                }\r\n            case '(':\r\n                {\r\n                    parens++;\r\n                    if (subtermStart != index - 1 || expr != null)\r\n                        throw new BadArgumentException(\"expression needs & or |\", new String(expression), index - 1);\r\n                    expr = parse_(expression);\r\n                    subtermStart = index;\r\n                    subtermComplete = false;\r\n                    break;\r\n                }\r\n            case ')':\r\n                {\r\n                    parens--;\r\n                    Node child = processTerm(subtermStart, index - 1, expr, expression);\r\n                    if (child == null && result == null)\r\n                        throw new BadArgumentException(\"empty expression not allowed\", new String(expression), index);\r\n                    if (result == null)\r\n                        return child;\r\n                    if (result.type == child.type)\r\n                        for (Node c : child.children) result.add(c);\r\n                    else\r\n                        result.add(child);\r\n                    return result;\r\n                }\r\n            case '\"':\r\n                {\r\n                    if (subtermStart != index - 1)\r\n                        throw new BadArgumentException(\"expression needs & or |\", new String(expression), index - 1);\r\n                    while (index < expression.length && expression[index] != '\"') {\r\n                        if (expression[index] == '\\\\') {\r\n                            index++;\r\n                            if (expression[index] != '\\\\' && expression[index] != '\"')\r\n                                throw new BadArgumentException(\"invalid escaping within quotes\", new String(expression), index - 1);\r\n                        }\r\n                        index++;\r\n                    }\r\n                    if (index == expression.length)\r\n                        throw new BadArgumentException(\"unclosed quote\", new String(expression), subtermStart);\r\n                    if (subtermStart + 1 == index)\r\n                        throw new BadArgumentException(\"empty term\", new String(expression), subtermStart);\r\n                    index++;\r\n                    subtermComplete = true;\r\n                    break;\r\n                }\r\n            default:\r\n                {\r\n                    if (subtermComplete)\r\n                        throw new BadArgumentException(\"expression needs & or |\", new String(expression), index - 1);\r\n                    byte c = expression[index - 1];\r\n                    if (!Authorizations.isValidAuthChar(c))\r\n                        throw new BadArgumentException(\"bad character (\" + c + \")\", new String(expression), index - 1);\r\n                }\r\n        }\r\n    }\r\n    Node child = processTerm(subtermStart, index, expr, expression);\r\n    if (result != null) {\r\n        result.add(child);\r\n        result.end = index;\r\n    } else\r\n        result = child;\r\n    if (result.type != NodeType.TERM)\r\n        if (result.children.size() < 2)\r\n            throw new BadArgumentException(\"missing term\", new String(expression), index);\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"Node parse_(byte[] expression) {\r\n    Node result = null;\r\n    Node expr = null;\r\n    int wholeTermStart = index;\r\n    int subtermStart = index;\r\n    boolean subtermComplete = false;\r\n    while (index < expression.length) {\r\n        switch(expression[index++]) {\r\n            case '&':\r\n                {\r\n                    expr = processTerm(subtermStart, index - 1, expr, expression);\r\n                    if (result != null) {\r\n                        if (!result.type.equals(NodeType.AND))\r\n                            throw new BadArgumentException(\"cannot mix & and |\", new String(expression), index - 1);\r\n                    } else {\r\n                        result = new Node(NodeType.AND, wholeTermStart);\r\n                    }\r\n                    result.add(expr);\r\n                    expr = null;\r\n                    subtermStart = index;\r\n                    subtermComplete = false;\r\n                    break;\r\n                }\r\n            case '|':\r\n                {\r\n                    expr = processTerm(subtermStart, index - 1, expr, expression);\r\n                    if (result != null) {\r\n                        if (!result.type.equals(NodeType.OR))\r\n                            throw new BadArgumentException(\"cannot mix | and &\", new String(expression), index - 1);\r\n                    } else {\r\n                        result = new Node(NodeType.OR, wholeTermStart);\r\n                    }\r\n                    result.add(expr);\r\n                    expr = null;\r\n                    subtermStart = index;\r\n                    subtermComplete = false;\r\n                    break;\r\n                }\r\n            case '(':\r\n                {\r\n                    parens++;\r\n                    if (subtermStart != index - 1 || expr != null)\r\n                        throw new BadArgumentException(\"expression needs & or |\", new String(expression), index - 1);\r\n                    expr = parse_(expression);\r\n                    subtermStart = index;\r\n                    subtermComplete = false;\r\n                    break;\r\n                }\r\n            case ')':\r\n                {\r\n                    parens--;\r\n                    Node child = processTerm(subtermStart, index - 1, expr, expression);\r\n                    if (child == null && result == null)\r\n                        throw new BadArgumentException(\"empty expression not allowed\", new String(expression), index);\r\n                    if (result == null)\r\n                        return child;\r\n                    if (result.type == child.type)\r\n                        for (Node c : child.children) result.add(c);\r\n                    else\r\n                        result.add(child);\r\n                    return result;\r\n                }\r\n            case '\"':\r\n                {\r\n                    if (subtermStart != index - 1)\r\n                        throw new BadArgumentException(\"expression needs & or |\", new String(expression), index - 1);\r\n                    while (index < expression.length && expression[index] != '\"') {\r\n                        if (expression[index] == '\\\\') {\r\n                            index++;\r\n                            if (expression[index] != '\\\\' && expression[index] != '\"')\r\n                                throw new BadArgumentException(\"invalid escaping within quotes\", new String(expression), index - 1);\r\n                        }\r\n                        index++;\r\n                    }\r\n                    if (index == expression.length)\r\n                        throw new BadArgumentException(\"unclosed quote\", new String(expression), subtermStart);\r\n                    if (subtermStart + 1 == index)\r\n                        throw new BadArgumentException(\"empty term\", new String(expression), subtermStart);\r\n                    index++;\r\n                    subtermComplete = true;\r\n                    break;\r\n                }\r\n            default:\r\n                {\r\n                    if (subtermComplete)\r\n                        throw new BadArgumentException(\"expression needs & or |\", new String(expression), index - 1);\r\n                    byte c = expression[index - 1];\r\n                    if (!Authorizations.isValidAuthChar(c))\r\n                        throw new BadArgumentException(\"bad character (\" + c + \")\", new String(expression), index - 1);\r\n                }\r\n        }\r\n    }\r\n    Node child = processTerm(subtermStart, index, expr, expression);\r\n    if (result != null) {\r\n        result.add(child);\r\n        result.end = index;\r\n    } else\r\n        result = child;\r\n    if (result.type != NodeType.TERM)\r\n        if (result.children.size() < 2)\r\n            throw new BadArgumentException(\"missing term\", new String(expression), index);\r\n    return result;\r\n}","lc":4.0454545455,"pi":1.966507177,"ma":7.8,"nbd":1.5,"ml":3.1666666667,"d":4.7579365079,"mi":-1.5257223397,"fo":0.6666666667,"r":-0.0263157895,"e":22.6863366816}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5898_b00920f3","label":1,"code":"\/**\r\n *  Get the markup for the child component, which is assumed to be a child of 'container'.\r\n *\/\r\n@Override\r\npublic IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {\r\n    \/\/ If the sourcing strategy did not provide one, than ask the component.\r\n    \/\/ Get the markup for the container\r\n    IMarkupFragment markup = container.getMarkup();\r\n    if (markup == null) {\r\n        return null;\r\n    }\r\n    if (child == null) {\r\n        return markup;\r\n    }\r\n    \/\/ Find the child's markup\r\n    markup = markup.find(child.getId());\r\n    if (markup != null) {\r\n        return markup;\r\n    }\r\n    markup = searchMarkupInTransparentResolvers(container, child);\r\n    return markup;\r\n}","code_comment":"\/**\r\n *  Get the markup for the child component, which is assumed to be a child of 'container'.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {\r\n            IMarkupFragment markup = container.getMarkup();\r\n    if (markup == null) {\r\n        return null;\r\n    }\r\n    if (child == null) {\r\n        return markup;\r\n    }\r\n        markup = markup.find(child.getId());\r\n    if (markup != null) {\r\n        return markup;\r\n    }\r\n    markup = searchMarkupInTransparentResolvers(container, child);\r\n    return markup;\r\n}","lc":0.0909090909,"pi":-0.2583732057,"ma":0.0,"nbd":-0.5,"ml":0.0,"d":0.1071428571,"mi":-0.0469344609,"fo":-0.1666666667,"r":0.0,"e":-0.0000852913}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6723_b92d6237","label":1,"code":"private static Exchange copyExchangeNoAttachments(Exchange exchange, boolean preserveExchangeId) {\r\n    Exchange answer = ExchangeHelper.createCopy(exchange, preserveExchangeId);\r\n    \/\/ we do not want attachments for the splitted sub-messages\r\n    answer.getIn().setAttachments(null);\r\n    return answer;\r\n}","code_comment":null,"code_no_comment":"private static Exchange copyExchangeNoAttachments(Exchange exchange, boolean preserveExchangeId) {\r\n    Exchange answer = ExchangeHelper.createCopy(exchange, preserveExchangeId);\r\n        answer.getIn().setAttachments(null);\r\n    return answer;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6253699789,"fo":-0.25,"r":0.4473684211,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-4011_cbffff59","label":3,"code":"\/**\r\n * Returns the converted value, or null if the value is null\r\n *\/\r\n@Converter\r\npublic static Long toLong(Object value) {\r\n    if (value instanceof Long) {\r\n        return (Long) value;\r\n    } else if (value instanceof Number) {\r\n        Number number = (Number) value;\r\n        return number.longValue();\r\n    } else if (value instanceof String) {\r\n        return Long.valueOf((String) value);\r\n    } else {\r\n        return null;\r\n    }\r\n}","code_comment":"\/**\r\n * Returns the converted value, or null if the value is null\r\n *\/\r\n","code_no_comment":"@Converter\r\npublic static Long toLong(Object value) {\r\n    if (value instanceof Long) {\r\n        return (Long) value;\r\n    } else if (value instanceof Number) {\r\n        Number number = (Number) value;\r\n        return number.longValue();\r\n    } else if (value instanceof String) {\r\n        return Long.valueOf((String) value);\r\n    } else {\r\n        return null;\r\n    }\r\n}","lc":-0.0454545455,"pi":0.043062201,"ma":0.0,"nbd":0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.1109231853,"fo":-0.3333333333,"r":0.2368421053,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3684_e3759a5e","label":1,"code":"@Override\r\npublic void processWatermark(Watermark mark) throws Exception {\r\n    \/\/ iterate over all keys to trigger the execution of the buffered elements\r\n    for (KEY key : keys) {\r\n        setKeyContext(key);\r\n        PriorityQueue<StreamRecord<IN>> priorityQueue = getPriorityQueue();\r\n        NFA<IN> nfa = getNFA();\r\n        while (!priorityQueue.isEmpty() && priorityQueue.peek().getTimestamp() <= mark.getTimestamp()) {\r\n            StreamRecord<IN> streamRecord = priorityQueue.poll();\r\n            processEvent(nfa, streamRecord.getValue(), streamRecord.getTimestamp());\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void processWatermark(Watermark mark) throws Exception {\r\n        for (KEY key : keys) {\r\n        setKeyContext(key);\r\n        PriorityQueue<StreamRecord<IN>> priorityQueue = getPriorityQueue();\r\n        NFA<IN> nfa = getNFA();\r\n        while (!priorityQueue.isEmpty() && priorityQueue.peek().getTimestamp() <= mark.getTimestamp()) {\r\n            StreamRecord<IN> streamRecord = priorityQueue.poll();\r\n            processEvent(nfa, streamRecord.getValue(), streamRecord.getTimestamp());\r\n        }\r\n    }\r\n}","lc":-0.0909090909,"pi":0.5598086124,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":0.2380952381,"mi":0.037068358,"fo":0.4166666667,"r":0.0,"e":0.1367864779}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5094_74e77676","label":1,"code":"\/**\r\n *  @see AbstractBookmarkableMapper#parseRequest(org.apache.wicket.request.Request)\r\n *\/\r\n@Override\r\nprotected UrlInfo parseRequest(Request request) {\r\n    if (Application.exists()) {\r\n        if (Application.get().getSecuritySettings().getEnforceMounts()) {\r\n            return null;\r\n        }\r\n    }\r\n    Url url = request.getUrl();\r\n    if (matches(url)) {\r\n        \/\/ try to extract page and component information from URL\r\n        PageComponentInfo info = getPageComponentInfo(url);\r\n        \/\/ load the page class\r\n        String className = url.getSegments().get(2);\r\n        Class<? extends IRequestablePage> pageClass = getPageClass(className);\r\n        if (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass)) {\r\n            \/\/ extract the PageParameters from URL if there are any\r\n            PageParameters pageParameters = extractPageParameters(request, 3, pageParametersEncoder);\r\n            return new UrlInfo(info, pageClass, pageParameters);\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":"\/**\r\n *  @see AbstractBookmarkableMapper#parseRequest(org.apache.wicket.request.Request)\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected UrlInfo parseRequest(Request request) {\r\n    if (Application.exists()) {\r\n        if (Application.get().getSecuritySettings().getEnforceMounts()) {\r\n            return null;\r\n        }\r\n    }\r\n    Url url = request.getUrl();\r\n    if (matches(url)) {\r\n                PageComponentInfo info = getPageComponentInfo(url);\r\n                String className = url.getSegments().get(2);\r\n        Class<? extends IRequestablePage> pageClass = getPageClass(className);\r\n        if (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass)) {\r\n                        PageParameters pageParameters = extractPageParameters(request, 3, pageParametersEncoder);\r\n            return new UrlInfo(info, pageClass, pageParameters);\r\n        }\r\n    }\r\n    return null;\r\n}","lc":0.2272727273,"pi":0.3636363636,"ma":0.2,"nbd":0.0,"ml":0.5,"d":-0.0634920635,"mi":-0.2329809725,"fo":0.5,"r":0.0,"e":0.0430536586}
{"project_name":"Closure","project_version":"161","label":2,"code":"private Node tryFoldArrayAccess(Node n, Node left, Node right) {\r\n    Node parent = n.getParent();\r\n    if (right.getType() != Token.NUMBER) {\r\n        \/\/ arrays, or strings to index into array methods.\r\n        return n;\r\n    }\r\n    double index = right.getDouble();\r\n    int intIndex = (int) index;\r\n    if (intIndex != index) {\r\n        error(INVALID_GETELEM_INDEX_ERROR, right);\r\n        return n;\r\n    }\r\n    if (intIndex < 0) {\r\n        error(INDEX_OUT_OF_BOUNDS_ERROR, right);\r\n        return n;\r\n    }\r\n    Node elem = left.getFirstChild();\r\n    for (int i = 0; elem != null && i < intIndex; i++) {\r\n        elem = elem.getNext();\r\n    }\r\n    if (elem == null) {\r\n        error(INDEX_OUT_OF_BOUNDS_ERROR, right);\r\n        return n;\r\n    }\r\n    if (elem.getType() == Token.EMPTY) {\r\n        elem = NodeUtil.newUndefinedNode(elem);\r\n    } else {\r\n        left.removeChild(elem);\r\n    }\r\n    \/\/ Replace the entire GETELEM with the value\r\n    n.getParent().replaceChild(n, elem);\r\n    reportCodeChange();\r\n    return elem;\r\n}","code_comment":null,"code_no_comment":"private Node tryFoldArrayAccess(Node n, Node left, Node right) {\r\n    Node parent = n.getParent();\r\n    if (right.getType() != Token.NUMBER) {\r\n                return n;\r\n    }\r\n    double index = right.getDouble();\r\n    int intIndex = (int) index;\r\n    if (intIndex != index) {\r\n        error(INVALID_GETELEM_INDEX_ERROR, right);\r\n        return n;\r\n    }\r\n    if (intIndex < 0) {\r\n        error(INDEX_OUT_OF_BOUNDS_ERROR, right);\r\n        return n;\r\n    }\r\n    Node elem = left.getFirstChild();\r\n    for (int i = 0; elem != null && i < intIndex; i++) {\r\n        elem = elem.getNext();\r\n    }\r\n    if (elem == null) {\r\n        error(INDEX_OUT_OF_BOUNDS_ERROR, right);\r\n        return n;\r\n    }\r\n    if (elem.getType() == Token.EMPTY) {\r\n        elem = NodeUtil.newUndefinedNode(elem);\r\n    } else {\r\n        left.removeChild(elem);\r\n    }\r\n        n.getParent().replaceChild(n, elem);\r\n    reportCodeChange();\r\n    return elem;\r\n}","lc":0.8181818182,"pi":-0.3588516746,"ma":0.6,"nbd":-0.5,"ml":0.6666666667,"d":1.1329365079,"mi":-0.5481324877,"fo":0.6666666667,"r":-0.0263157895,"e":1.4265797618}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4119_bb7a6995","label":1,"code":"\/**\r\n *  creates a new resource response based on the request attributes\r\n *\r\n *  @param attributes\r\n *             current request attributes from client\r\n *  @return resource response for answering request\r\n *\/\r\n@Override\r\nprotected ResourceResponse newResourceResponse(Attributes attributes) {\r\n    final ResourceResponse resourceResponse = new ResourceResponse();\r\n    if (resourceResponse.dataNeedsToBeWritten(attributes)) {\r\n        \/\/ get resource stream\r\n        final IResourceStream resourceStream = getResourceStream();\r\n        \/\/ bail out if resource stream could not be found\r\n        if (resourceStream == null)\r\n            return sendResourceError(resourceResponse, HttpServletResponse.SC_NOT_FOUND, \"Unable to find resource\");\r\n        String contentType = resourceStream.getContentType();\r\n        if (contentType == null && Application.exists()) {\r\n            contentType = Application.get().getMimeType(path);\r\n        }\r\n        \/\/ set Content-Type (may be null)\r\n        resourceResponse.setContentType(contentType);\r\n        \/\/ add Last-Modified header (to support HEAD requests and If-Modified-Since)\r\n        final Time lastModified = resourceStream.lastModifiedTime();\r\n        if (lastModified != null)\r\n            resourceResponse.setLastModified(lastModified);\r\n        try {\r\n            \/\/ read resource data\r\n            final byte[] bytes;\r\n            try {\r\n                bytes = IOUtils.toByteArray(resourceStream.getInputStream());\r\n            } finally {\r\n                resourceStream.close();\r\n            }\r\n            final byte[] processed = processResponse(attributes, bytes);\r\n            \/\/ send Content-Length header\r\n            resourceResponse.setContentLength(processed.length);\r\n            \/\/ send response body with resource data\r\n            resourceResponse.setWriteCallback(new WriteCallback() {\r\n\r\n                @Override\r\n                public void writeData(Attributes attributes) {\r\n                    attributes.getResponse().write(processed);\r\n                }\r\n            });\r\n        } catch (IOException e) {\r\n            log.debug(e.getMessage(), e);\r\n            return sendResourceError(resourceResponse, 500, \"Unable to read resource stream\");\r\n        } catch (ResourceStreamNotFoundException e) {\r\n            log.debug(e.getMessage(), e);\r\n            return sendResourceError(resourceResponse, 500, \"Unable to open resource stream\");\r\n        }\r\n    }\r\n    return resourceResponse;\r\n}","code_comment":"\/**\r\n *  creates a new resource response based on the request attributes\r\n *\r\n *  @param attributes\r\n *             current request attributes from client\r\n *  @return resource response for answering request\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected ResourceResponse newResourceResponse(Attributes attributes) {\r\n    final ResourceResponse resourceResponse = new ResourceResponse();\r\n    if (resourceResponse.dataNeedsToBeWritten(attributes)) {\r\n                final IResourceStream resourceStream = getResourceStream();\r\n                if (resourceStream == null)\r\n            return sendResourceError(resourceResponse, HttpServletResponse.SC_NOT_FOUND, \"Unable to find resource\");\r\n        String contentType = resourceStream.getContentType();\r\n        if (contentType == null && Application.exists()) {\r\n            contentType = Application.get().getMimeType(path);\r\n        }\r\n                resourceResponse.setContentType(contentType);\r\n                final Time lastModified = resourceStream.lastModifiedTime();\r\n        if (lastModified != null)\r\n            resourceResponse.setLastModified(lastModified);\r\n        try {\r\n                        final byte[] bytes;\r\n            try {\r\n                bytes = IOUtils.toByteArray(resourceStream.getInputStream());\r\n            } finally {\r\n                resourceStream.close();\r\n            }\r\n            final byte[] processed = processResponse(attributes, bytes);\r\n                        resourceResponse.setContentLength(processed.length);\r\n                        resourceResponse.setWriteCallback(new WriteCallback() {\r\n\r\n                @Override\r\n                public void writeData(Attributes attributes) {\r\n                    attributes.getResponse().write(processed);\r\n                }\r\n            });\r\n        } catch (IOException e) {\r\n            log.debug(e.getMessage(), e);\r\n            return sendResourceError(resourceResponse, 500, \"Unable to read resource stream\");\r\n        } catch (ResourceStreamNotFoundException e) {\r\n            log.debug(e.getMessage(), e);\r\n            return sendResourceError(resourceResponse, 500, \"Unable to open resource stream\");\r\n        }\r\n    }\r\n    return resourceResponse;\r\n}","lc":1.1818181818,"pi":0.7511961722,"ma":0.6,"nbd":0.5,"ml":0.5,"d":0.375,"mi":-0.6964059197,"fo":1.5,"r":-0.0263157895,"e":0.9159892349}
{"project_name":"Closure","project_version":"167","label":2,"code":"private FlowScope caseEquality(Node left, Node right, FlowScope blindScope, Function<TypePair, TypePair> merging) {\r\n    \/\/ left type\r\n    JSType leftType = getTypeIfRefinable(left, blindScope);\r\n    boolean leftIsRefineable;\r\n    if (leftType != null) {\r\n        leftIsRefineable = true;\r\n    } else {\r\n        leftIsRefineable = false;\r\n        leftType = left.getJSType();\r\n    }\r\n    \/\/ right type\r\n    JSType rightType = getTypeIfRefinable(right, blindScope);\r\n    boolean rightIsRefineable;\r\n    if (rightType != null) {\r\n        rightIsRefineable = true;\r\n    } else {\r\n        rightIsRefineable = false;\r\n        rightType = right.getJSType();\r\n    }\r\n    \/\/ merged types\r\n    TypePair merged = merging.apply(new TypePair(leftType, rightType));\r\n    \/\/ creating new scope\r\n    if (merged != null) {\r\n        return maybeRestrictTwoNames(blindScope, left, leftIsRefineable, merged.typeA, right, rightIsRefineable, merged.typeB);\r\n    }\r\n    return blindScope;\r\n}","code_comment":null,"code_no_comment":"private FlowScope caseEquality(Node left, Node right, FlowScope blindScope, Function<TypePair, TypePair> merging) {\r\n        JSType leftType = getTypeIfRefinable(left, blindScope);\r\n    boolean leftIsRefineable;\r\n    if (leftType != null) {\r\n        leftIsRefineable = true;\r\n    } else {\r\n        leftIsRefineable = false;\r\n        leftType = left.getJSType();\r\n    }\r\n        JSType rightType = getTypeIfRefinable(right, blindScope);\r\n    boolean rightIsRefineable;\r\n    if (rightType != null) {\r\n        rightIsRefineable = true;\r\n    } else {\r\n        rightIsRefineable = false;\r\n        rightType = right.getJSType();\r\n    }\r\n        TypePair merged = merging.apply(new TypePair(leftType, rightType));\r\n        if (merged != null) {\r\n        return maybeRestrictTwoNames(blindScope, left, leftIsRefineable, merged.typeA, right, rightIsRefineable, merged.typeB);\r\n    }\r\n    return blindScope;\r\n}","lc":0.4090909091,"pi":-0.3062200957,"ma":0.0,"nbd":-0.5,"ml":0.0833333333,"d":0.1349206349,"mi":-0.3415081043,"fo":0.0,"r":-0.0263157895,"e":0.2515240055}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-193_c831e44d","label":3,"code":"public String toString() {\r\n    String labelString = new ColumnVisibility(colVisibility).toString();\r\n    String s = toPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT) + \" \" + toPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT) + \":\" + toPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT) + \" \" + labelString + \" \" + Long.toString(timestamp) + \" \" + deleted;\r\n    return s;\r\n}","code_comment":null,"code_no_comment":"public String toString() {\r\n    String labelString = new ColumnVisibility(colVisibility).toString();\r\n    String s = toPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT) + \" \" + toPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT) + \":\" + toPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT) + \" \" + labelString + \" \" + Long.toString(timestamp) + \" \" + deleted;\r\n    return s;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":0.0515873016,"mi":0.459055673,"fo":-0.0833333333,"r":-0.0263157895,"e":0.0314955366}
{"project_name":"Time","project_version":"23","label":2,"code":"\/\/ -----------------------------------------------------------------------\r\n\/**\r\n * Converts an old style id to a new style id.\r\n *\r\n * @param id  the old style id\r\n * @return the new style id, null if not found\r\n *\/\r\nprivate static synchronized String getConvertedId(String id) {\r\n    Map<String, String> map = cZoneIdConversion;\r\n    if (map == null) {\r\n        \/\/ Backwards compatibility with TimeZone.\r\n        map = new HashMap<String, String>();\r\n        map.put(\"GMT\", \"UTC\");\r\n        map.put(\"MIT\", \"Pacific\/Apia\");\r\n        \/\/ JDK 1.1 compatible\r\n        map.put(\"HST\", \"Pacific\/Honolulu\");\r\n        map.put(\"AST\", \"America\/Anchorage\");\r\n        map.put(\"PST\", \"America\/Los_Angeles\");\r\n        \/\/ JDK 1.1 compatible\r\n        map.put(\"MST\", \"America\/Denver\");\r\n        map.put(\"PNT\", \"America\/Phoenix\");\r\n        map.put(\"CST\", \"America\/Chicago\");\r\n        \/\/ JDK 1.1 compatible\r\n        map.put(\"EST\", \"America\/New_York\");\r\n        map.put(\"IET\", \"America\/Indianapolis\");\r\n        map.put(\"PRT\", \"America\/Puerto_Rico\");\r\n        map.put(\"CNT\", \"America\/St_Johns\");\r\n        map.put(\"AGT\", \"America\/Buenos_Aires\");\r\n        map.put(\"BET\", \"America\/Sao_Paulo\");\r\n        map.put(\"WET\", \"Europe\/London\");\r\n        map.put(\"ECT\", \"Europe\/Paris\");\r\n        map.put(\"ART\", \"Africa\/Cairo\");\r\n        map.put(\"CAT\", \"Africa\/Harare\");\r\n        map.put(\"EET\", \"Europe\/Bucharest\");\r\n        map.put(\"EAT\", \"Africa\/Addis_Ababa\");\r\n        map.put(\"MET\", \"Asia\/Tehran\");\r\n        map.put(\"NET\", \"Asia\/Yerevan\");\r\n        map.put(\"PLT\", \"Asia\/Karachi\");\r\n        map.put(\"IST\", \"Asia\/Calcutta\");\r\n        map.put(\"BST\", \"Asia\/Dhaka\");\r\n        map.put(\"VST\", \"Asia\/Saigon\");\r\n        map.put(\"CTT\", \"Asia\/Shanghai\");\r\n        map.put(\"JST\", \"Asia\/Tokyo\");\r\n        map.put(\"ACT\", \"Australia\/Darwin\");\r\n        map.put(\"AET\", \"Australia\/Sydney\");\r\n        map.put(\"SST\", \"Pacific\/Guadalcanal\");\r\n        map.put(\"NST\", \"Pacific\/Auckland\");\r\n        cZoneIdConversion = map;\r\n    }\r\n    return map.get(id);\r\n}","code_comment":"\/**\r\n * Converts an old style id to a new style id.\r\n *\r\n * @param id  the old style id\r\n * @return the new style id, null if not found\r\n *\/\r\n","code_no_comment":"private static synchronized String getConvertedId(String id) {\r\n    Map<String, String> map = cZoneIdConversion;\r\n    if (map == null) {\r\n                map = new HashMap<String, String>();\r\n        map.put(\"GMT\", \"UTC\");\r\n        map.put(\"MIT\", \"Pacific\/Apia\");\r\n                map.put(\"HST\", \"Pacific\/Honolulu\");\r\n        map.put(\"AST\", \"America\/Anchorage\");\r\n        map.put(\"PST\", \"America\/Los_Angeles\");\r\n                map.put(\"MST\", \"America\/Denver\");\r\n        map.put(\"PNT\", \"America\/Phoenix\");\r\n        map.put(\"CST\", \"America\/Chicago\");\r\n                map.put(\"EST\", \"America\/New_York\");\r\n        map.put(\"IET\", \"America\/Indianapolis\");\r\n        map.put(\"PRT\", \"America\/Puerto_Rico\");\r\n        map.put(\"CNT\", \"America\/St_Johns\");\r\n        map.put(\"AGT\", \"America\/Buenos_Aires\");\r\n        map.put(\"BET\", \"America\/Sao_Paulo\");\r\n        map.put(\"WET\", \"Europe\/London\");\r\n        map.put(\"ECT\", \"Europe\/Paris\");\r\n        map.put(\"ART\", \"Africa\/Cairo\");\r\n        map.put(\"CAT\", \"Africa\/Harare\");\r\n        map.put(\"EET\", \"Europe\/Bucharest\");\r\n        map.put(\"EAT\", \"Africa\/Addis_Ababa\");\r\n        map.put(\"MET\", \"Asia\/Tehran\");\r\n        map.put(\"NET\", \"Asia\/Yerevan\");\r\n        map.put(\"PLT\", \"Asia\/Karachi\");\r\n        map.put(\"IST\", \"Asia\/Calcutta\");\r\n        map.put(\"BST\", \"Asia\/Dhaka\");\r\n        map.put(\"VST\", \"Asia\/Saigon\");\r\n        map.put(\"CTT\", \"Asia\/Shanghai\");\r\n        map.put(\"JST\", \"Asia\/Tokyo\");\r\n        map.put(\"ACT\", \"Australia\/Darwin\");\r\n        map.put(\"AET\", \"Australia\/Sydney\");\r\n        map.put(\"SST\", \"Pacific\/Guadalcanal\");\r\n        map.put(\"NST\", \"Pacific\/Auckland\");\r\n        cZoneIdConversion = map;\r\n    }\r\n    return map.get(id);\r\n}","lc":1.1818181818,"pi":-0.4545454545,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.0297619048,"mi":-0.726286117,"fo":2.25,"r":-0.0263157895,"e":0.7154071795}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-519_26a61077","label":1,"code":"\/**\r\n * Guesses the parameters based on the observed points.\r\n *\r\n * @return guessed parameters array <code>{norm, mean, sigma}<\/code>\r\n *\/\r\npublic double[] guess() {\r\n    if (parameters == null) {\r\n        parameters = basicGuess(observations);\r\n    }\r\n    return parameters.clone();\r\n}","code_comment":"\/**\r\n * Guesses the parameters based on the observed points.\r\n *\r\n * @return guessed parameters array <code>{norm, mean, sigma}<\/code>\r\n *\/\r\n","code_no_comment":"public double[] guess() {\r\n    if (parameters == null) {\r\n        parameters = basicGuess(observations);\r\n    }\r\n    return parameters.clone();\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1091269841,"mi":0.6259337562,"fo":-0.3333333333,"r":2.2105263158,"e":-0.1421252514}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-867_bfbb156d","label":1,"code":"\/**\r\n * @param x Original objective variables.\r\n * @return the normalized objective variables.\r\n *\/\r\npublic double[] encode(final double[] x) {\r\n    if (boundaries == null) {\r\n        return x;\r\n    }\r\n    double[] res = new double[x.length];\r\n    for (int i = 0; i < x.length; i++) {\r\n        double diff = boundaries[1][i] - boundaries[0][i];\r\n        res[i] = x[i] \/ diff;\r\n    }\r\n    return res;\r\n}","code_comment":"\/**\r\n * @param x Original objective variables.\r\n * @return the normalized objective variables.\r\n *\/\r\n","code_no_comment":"public double[] encode(final double[] x) {\r\n    if (boundaries == null) {\r\n        return x;\r\n    }\r\n    double[] res = new double[x.length];\r\n    for (int i = 0; i < x.length; i++) {\r\n        double diff = boundaries[1][i] - boundaries[0][i];\r\n        res[i] = x[i] \/ diff;\r\n    }\r\n    return res;\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":1.1507936508,"mi":0.1275546159,"fo":-0.5,"r":1.9473684211,"e":0.3696501328}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"public long count(NodeState indexMeta, final String indexStorageNodeName, Set<String> values, int max) {\r\n    NodeState index = indexMeta.getChildNode(indexStorageNodeName);\r\n    int count = 0;\r\n    if (values == null) {\r\n        PropertyState ec = indexMeta.getProperty(ENTRY_COUNT_PROPERTY_NAME);\r\n        if (ec != null) {\r\n            return ec.getValue(Type.LONG);\r\n        }\r\n        CountingNodeVisitor v = new CountingNodeVisitor(max);\r\n        v.visit(index);\r\n        count = v.getEstimatedCount();\r\n        if (count >= max) {\r\n            \/\/ \"is not null\" queries typically read more data\r\n            count *= 10;\r\n        }\r\n    } else {\r\n        int size = values.size();\r\n        if (size == 0) {\r\n            return 0;\r\n        }\r\n        PropertyState ec = indexMeta.getProperty(ENTRY_COUNT_PROPERTY_NAME);\r\n        if (ec != null) {\r\n            long entryCount = ec.getValue(Type.LONG);\r\n            \/\/ assume 10000 entries per key, so that this index is used\r\n            \/\/ instead of traversal, but not instead of a regular property index\r\n            long keyCount = entryCount \/ 10000;\r\n            ec = indexMeta.getProperty(KEY_COUNT_PROPERTY_NAME);\r\n            if (ec != null) {\r\n                keyCount = ec.getValue(Type.LONG);\r\n            }\r\n            \/\/ otherwise the traversing index might be used\r\n            return (long) ((double) entryCount \/ keyCount) + size;\r\n        }\r\n        max = Math.max(10, max \/ size);\r\n        int i = 0;\r\n        for (String p : values) {\r\n            if (count > max && i > 3) {\r\n                \/\/ the total count is extrapolated from the the number\r\n                \/\/ of values counted so far to the total number of values\r\n                count = count * size \/ i;\r\n                break;\r\n            }\r\n            NodeState s = index.getChildNode(p);\r\n            if (s.exists()) {\r\n                CountingNodeVisitor v = new CountingNodeVisitor(max);\r\n                v.visit(s);\r\n                count += v.getEstimatedCount();\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    return count;\r\n}","code_comment":null,"code_no_comment":"public long count(NodeState indexMeta, final String indexStorageNodeName, Set<String> values, int max) {\r\n    NodeState index = indexMeta.getChildNode(indexStorageNodeName);\r\n    int count = 0;\r\n    if (values == null) {\r\n        PropertyState ec = indexMeta.getProperty(ENTRY_COUNT_PROPERTY_NAME);\r\n        if (ec != null) {\r\n            return ec.getValue(Type.LONG);\r\n        }\r\n        CountingNodeVisitor v = new CountingNodeVisitor(max);\r\n        v.visit(index);\r\n        count = v.getEstimatedCount();\r\n        if (count >= max) {\r\n                        count *= 10;\r\n        }\r\n    } else {\r\n        int size = values.size();\r\n        if (size == 0) {\r\n            return 0;\r\n        }\r\n        PropertyState ec = indexMeta.getProperty(ENTRY_COUNT_PROPERTY_NAME);\r\n        if (ec != null) {\r\n            long entryCount = ec.getValue(Type.LONG);\r\n                                    long keyCount = entryCount \/ 10000;\r\n            ec = indexMeta.getProperty(KEY_COUNT_PROPERTY_NAME);\r\n            if (ec != null) {\r\n                keyCount = ec.getValue(Type.LONG);\r\n            }\r\n                        return (long) ((double) entryCount \/ keyCount) + size;\r\n        }\r\n        max = Math.max(10, max \/ size);\r\n        int i = 0;\r\n        for (String p : values) {\r\n            if (count > max && i > 3) {\r\n                                                count = count * size \/ i;\r\n                break;\r\n            }\r\n            NodeState s = index.getChildNode(p);\r\n            if (s.exists()) {\r\n                CountingNodeVisitor v = new CountingNodeVisitor(max);\r\n                v.visit(s);\r\n                count += v.getEstimatedCount();\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    return count;\r\n}","lc":1.5,"pi":0.4784688995,"ma":1.4,"nbd":0.5,"ml":0.9166666667,"d":3.503968254,"mi":-0.8396053559,"fo":0.75,"r":-0.0263157895,"e":7.4188735787}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_add180fb","label":1,"code":"@Override\r\npublic void offline(String tableName) throws AccumuloSecurityException, AccumuloException {\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void offline(String tableName) throws AccumuloSecurityException, AccumuloException {\r\n}","lc":-0.5,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0329809725,"fo":-0.5,"r":1.6578947368,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4565_c6529932","label":1,"code":"private boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems) {\r\n    for (ProfileActivator activator : activators) {\r\n        try {\r\n            if (activator.isActive(profile, context, problems)) {\r\n                return true;\r\n            }\r\n        } catch (RuntimeException e) {\r\n            problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage(\"Failed to determine activation for profile \" + profile.getId()).setLocation(profile.getLocation(\"\")).setException(e));\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"private boolean isActive(Profile profile, ProfileActivationContext context, ModelProblemCollector problems) {\r\n    for (ProfileActivator activator : activators) {\r\n        try {\r\n            if (activator.isActive(profile, context, problems)) {\r\n                return true;\r\n            }\r\n        } catch (RuntimeException e) {\r\n            problems.add(new ModelProblemCollectorRequest(Severity.ERROR, Version.BASE).setMessage(\"Failed to determine activation for profile \" + profile.getId()).setLocation(profile.getLocation(\"\")).setException(e));\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}","lc":-0.0454545455,"pi":0.8803827751,"ma":0.0,"nbd":0.5,"ml":0.0,"d":-0.3650793651,"mi":0.0116983791,"fo":0.0833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5265_0eb596df","label":1,"code":"@Override\r\nprotected boolean shouldRecurseInto(Component component) {\r\n    return component.getMetaData(FENCE_KEY) == null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected boolean shouldRecurseInto(Component component) {\r\n    return component.getMetaData(FENCE_KEY) == null;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8314305849,"fo":-0.4166666667,"r":2.1578947368,"e":-0.1627934049}
{"project_name":"Closure","project_version":"54","label":2,"code":"\/**\r\n * Sets the prototype.\r\n * @param prototype the prototype. If this value is {@code null} it will\r\n *        silently be discarded.\r\n *\/\r\npublic boolean setPrototype(PrototypeObjectType prototype) {\r\n    if (prototype == null) {\r\n        return false;\r\n    }\r\n    \/\/ getInstanceType fails if the function is not a constructor\r\n    if (isConstructor() && prototype == getInstanceType()) {\r\n        return false;\r\n    }\r\n    boolean replacedPrototype = prototype != null;\r\n    this.prototype = prototype;\r\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\r\n    this.prototype.setOwnerFunction(this);\r\n    if (isConstructor() || isInterface()) {\r\n        FunctionType superClass = getSuperClassConstructor();\r\n        if (superClass != null) {\r\n            superClass.addSubType(this);\r\n        }\r\n        if (isInterface()) {\r\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\r\n                if (interfaceType.getConstructor() != null) {\r\n                    interfaceType.getConstructor().addSubType(this);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (replacedPrototype) {\r\n        clearCachedValues();\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n * Sets the prototype.\r\n * @param prototype the prototype. If this value is {@code null} it will\r\n *        silently be discarded.\r\n *\/\r\n","code_no_comment":"public boolean setPrototype(PrototypeObjectType prototype) {\r\n    if (prototype == null) {\r\n        return false;\r\n    }\r\n        if (isConstructor() && prototype == getInstanceType()) {\r\n        return false;\r\n    }\r\n    boolean replacedPrototype = prototype != null;\r\n    this.prototype = prototype;\r\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\r\n    this.prototype.setOwnerFunction(this);\r\n    if (isConstructor() || isInterface()) {\r\n        FunctionType superClass = getSuperClassConstructor();\r\n        if (superClass != null) {\r\n            superClass.addSubType(this);\r\n        }\r\n        if (isInterface()) {\r\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\r\n                if (interfaceType.getConstructor() != null) {\r\n                    interfaceType.getConstructor().addSubType(this);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (replacedPrototype) {\r\n        clearCachedValues();\r\n    }\r\n    return true;\r\n}","lc":0.6818181818,"pi":0.7990430622,"ma":1.0,"nbd":1.0,"ml":0.9166666667,"d":0.4107142857,"mi":-0.4387596899,"fo":0.5833333333,"r":-0.0263157895,"e":0.3228782352}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3789_9319e139","label":1,"code":"private boolean writeFileByLocalWorkPath(File source, File file) {\r\n    LOG.trace(\"Using local work file being renamed from: {} to: {}\", source, file);\r\n    return FileUtil.renameFile(source, file);\r\n}","code_comment":null,"code_no_comment":"private boolean writeFileByLocalWorkPath(File source, File file) {\r\n    LOG.trace(\"Using local work file being renamed from: {} to: {}\", source, file);\r\n    return FileUtil.renameFile(source, file);\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7651867512,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1369_ce0b0955","label":1,"code":"@Override\r\npublic String toString() {\r\n    StringBuilder buff = new StringBuilder(\"contains\").append('(').append(left).append(\", \").append(right).append(')');\r\n    return buff.toString();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String toString() {\r\n    StringBuilder buff = new StringBuilder(\"contains\").append('(').append(left).append(\", \").append(right).append(')');\r\n    return buff.toString();\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5937984496,"fo":0.0,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4927_8c827e33","label":1,"code":"@Override\r\npublic void sendError(int sc, String msg) {\r\n    checkHeader();\r\n    bufferedResponse.sendError(sc, msg);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void sendError(int sc, String msg) {\r\n    checkHeader();\r\n    bufferedResponse.sendError(sc, msg);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7237491191,"fo":-0.3333333333,"r":0.5789473684,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1096_19c1c3bb","label":0,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic EnclosingBall<Euclidean3D, Vector3D> ballOnSupport(final List<Vector3D> support) {\r\n    if (support.size() < 1) {\r\n        return new EnclosingBall<Euclidean3D, Vector3D>(Vector3D.ZERO, -1.0);\r\n    } else {\r\n        final Vector3D vA = support.get(0);\r\n        if (support.size() < 2) {\r\n            return new EnclosingBall<Euclidean3D, Vector3D>(vA, 0, vA);\r\n        } else {\r\n            final Vector3D vB = support.get(1);\r\n            if (support.size() < 3) {\r\n                return new EnclosingBall<Euclidean3D, Vector3D>(new Vector3D(0.5, vA, 0.5, vB), 0.5 * vA.distance(vB), vA, vB);\r\n            } else {\r\n                final Vector3D vC = support.get(2);\r\n                if (support.size() < 4) {\r\n                    \/\/ delegate to 2D disk generator\r\n                    final Plane p = new Plane(vA, vB, vC, 1.0e-10 * (vA.getNorm1() + vB.getNorm1() + vC.getNorm1()));\r\n                    final EnclosingBall<Euclidean2D, Vector2D> disk = new DiskGenerator().ballOnSupport(Arrays.asList(p.toSubSpace(vA), p.toSubSpace(vB), p.toSubSpace(vC)));\r\n                    \/\/ convert back to 3D\r\n                    return new EnclosingBall<Euclidean3D, Vector3D>(p.toSpace(disk.getCenter()), disk.getRadius(), vA, vB, vC);\r\n                } else {\r\n                    final Vector3D vD = support.get(3);\r\n                    \/\/ a sphere is 3D can be defined as:\r\n                    \/\/ (1)   (x - x_0)^2 + (y - y_0)^2 + (z - z_0)^2 = r^2\r\n                    \/\/ which can be written:\r\n                    \/\/ (2)   (x^2 + y^2 + z^2) - 2 x_0 x - 2 y_0 y - 2 z_0 z + (x_0^2 + y_0^2 + z_0^2 - r^2) = 0\r\n                    \/\/ or simply:\r\n                    \/\/ (3)   (x^2 + y^2 + z^2) + a x + b y + c z + d = 0\r\n                    \/\/ with sphere center coordinates -a\/2, -b\/2, -c\/2\r\n                    \/\/ If the sphere exists, a b, c and d are a non zero solution to\r\n                    \/\/ [ (x^2  + y^2  + z^2)    x    y   z    1 ]   [ 1 ]   [ 0 ]\r\n                    \/\/ [ (xA^2 + yA^2 + zA^2)   xA   yA  zA   1 ]   [ a ]   [ 0 ]\r\n                    \/\/ [ (xB^2 + yB^2 + zB^2)   xB   yB  zB   1 ] * [ b ] = [ 0 ]\r\n                    \/\/ [ (xC^2 + yC^2 + zC^2)   xC   yC  zC   1 ]   [ c ]   [ 0 ]\r\n                    \/\/ [ (xD^2 + yD^2 + zD^2)   xD   yD  zD   1 ]   [ d ]   [ 0 ]\r\n                    \/\/ So the determinant of the matrix is zero. Computing this determinant\r\n                    \/\/ by expanding it using the minors m_ij of first row leads to\r\n                    \/\/ (4)   m_11 (x^2 + y^2 + z^2) - m_12 x + m_13 y - m_14 z + m_15 = 0\r\n                    \/\/ So by identifying equations (2) and (4) we get the coordinates\r\n                    \/\/ of center as:\r\n                    \/\/ x_0 = +m_12 \/ (2 m_11)\r\n                    \/\/ y_0 = -m_13 \/ (2 m_11)\r\n                    \/\/ z_0 = +m_14 \/ (2 m_11)\r\n                    \/\/ Note that the minors m_11, m_12, m_13 and m_14 all have the last column\r\n                    \/\/ filled with 1.0, hence simplifying the computation\r\n                    final double[] c1 = new double[] { vA.getNormSq(), vB.getNormSq(), vC.getNormSq(), vD.getNormSq() };\r\n                    final double[] c2 = new double[] { vA.getX(), vB.getX(), vC.getX(), vD.getX() };\r\n                    final double[] c3 = new double[] { vA.getY(), vB.getY(), vC.getY(), vD.getY() };\r\n                    final double[] c4 = new double[] { vA.getZ(), vB.getZ(), vC.getZ(), vD.getZ() };\r\n                    final double m11 = minor(c2, c3, c4);\r\n                    final double m12 = minor(c1, c3, c4);\r\n                    final double m13 = minor(c1, c2, c4);\r\n                    final double m14 = minor(c1, c2, c3);\r\n                    final Vector3D center = new Vector3D(0.5 * m12 \/ m11, -0.5 * m13 \/ m11, 0.5 * m14 \/ m11);\r\n                    return new EnclosingBall<Euclidean3D, Vector3D>(center, center.distance(vA), vA, vB, vC, vD);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public EnclosingBall<Euclidean3D, Vector3D> ballOnSupport(final List<Vector3D> support) {\r\n    if (support.size() < 1) {\r\n        return new EnclosingBall<Euclidean3D, Vector3D>(Vector3D.ZERO, -1.0);\r\n    } else {\r\n        final Vector3D vA = support.get(0);\r\n        if (support.size() < 2) {\r\n            return new EnclosingBall<Euclidean3D, Vector3D>(vA, 0, vA);\r\n        } else {\r\n            final Vector3D vB = support.get(1);\r\n            if (support.size() < 3) {\r\n                return new EnclosingBall<Euclidean3D, Vector3D>(new Vector3D(0.5, vA, 0.5, vB), 0.5 * vA.distance(vB), vA, vB);\r\n            } else {\r\n                final Vector3D vC = support.get(2);\r\n                if (support.size() < 4) {\r\n                                        final Plane p = new Plane(vA, vB, vC, 1.0e-10 * (vA.getNorm1() + vB.getNorm1() + vC.getNorm1()));\r\n                    final EnclosingBall<Euclidean2D, Vector2D> disk = new DiskGenerator().ballOnSupport(Arrays.asList(p.toSubSpace(vA), p.toSubSpace(vB), p.toSubSpace(vC)));\r\n                                        return new EnclosingBall<Euclidean3D, Vector3D>(p.toSpace(disk.getCenter()), disk.getRadius(), vA, vB, vC);\r\n                } else {\r\n                    final Vector3D vD = support.get(3);\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                final double[] c1 = new double[] { vA.getNormSq(), vB.getNormSq(), vC.getNormSq(), vD.getNormSq() };\r\n                    final double[] c2 = new double[] { vA.getX(), vB.getX(), vC.getX(), vD.getX() };\r\n                    final double[] c3 = new double[] { vA.getY(), vB.getY(), vC.getY(), vD.getY() };\r\n                    final double[] c4 = new double[] { vA.getZ(), vB.getZ(), vC.getZ(), vD.getZ() };\r\n                    final double m11 = minor(c2, c3, c4);\r\n                    final double m12 = minor(c1, c3, c4);\r\n                    final double m13 = minor(c1, c2, c4);\r\n                    final double m14 = minor(c1, c2, c3);\r\n                    final Vector3D center = new Vector3D(0.5 * m12 \/ m11, -0.5 * m13 \/ m11, 0.5 * m14 \/ m11);\r\n                    return new EnclosingBall<Euclidean3D, Vector3D>(center, center.distance(vA), vA, vB, vC, vD);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","lc":0.9090909091,"pi":1.6555023923,"ma":0.2,"nbd":1.0,"ml":0.0,"d":1.8611111111,"mi":-0.711627907,"fo":2.9166666667,"r":-0.0263157895,"e":6.355950508}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2528_239de7b8","label":1,"code":"private void addGarbage(Revision rev, String property) {\r\n    Set<Revision> revisions = garbage.get(property);\r\n    if (revisions == null) {\r\n        revisions = Sets.newHashSet();\r\n        garbage.put(property, revisions);\r\n    }\r\n    revisions.add(rev);\r\n}","code_comment":null,"code_no_comment":"private void addGarbage(Revision rev, String property) {\r\n    Set<Revision> revisions = garbage.get(property);\r\n    if (revisions == null) {\r\n        revisions = Sets.newHashSet();\r\n        garbage.put(property, revisions);\r\n    }\r\n    revisions.add(rev);\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0476190476,"mi":0.325440451,"fo":-0.1666666667,"r":0.0789473684,"e":-0.081384024}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2246_dcadb0e1","label":1,"code":"@Override\r\npublic void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos) throws RepositoryException {\r\n    Tree parent = parents.peek();\r\n    Tree tree = null;\r\n    String id = nodeInfo.getUUID();\r\n    String nodeName = nodeInfo.getName();\r\n    String ntName = nodeInfo.getPrimaryTypeName();\r\n    if (parent == null) {\r\n        log.debug(\"Skipping node: \" + nodeName);\r\n        \/\/ parent node was skipped, skip this child node too\r\n        \/\/ push null onto stack for skipped node\r\n        parents.push(null);\r\n        \/\/ notify the p-i-importer\r\n        if (pnImporter != null) {\r\n            pnImporter.startChildInfo(nodeInfo, propInfos);\r\n        }\r\n        return;\r\n    }\r\n    NodeDefinition parentDef = getDefinition(parent);\r\n    if (parentDef.isProtected()) {\r\n        \/\/ skip protected node\r\n        parents.push(null);\r\n        log.debug(\"Skipping protected node: \" + nodeName);\r\n        if (pnImporter != null) {\r\n            \/\/ pnImporter was already started (current nodeInfo is a sibling)\r\n            \/\/ notify it about this child node.\r\n            pnImporter.startChildInfo(nodeInfo, propInfos);\r\n        } else {\r\n            \/\/ potentially is able to deal with it, notify it about the child node.\r\n            for (ProtectedNodeImporter pni : getNodeImporters()) {\r\n                if (pni.start(parent)) {\r\n                    log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\r\n                    pnImporter = pni;\r\n                    pnImporter.startChildInfo(nodeInfo, propInfos);\r\n                    break;\r\n                }\r\n            \/* else: p-i-Importer isn't able to deal with the protected tree.\r\n                     try next. and if none can handle the passed parent the\r\n                     tree below will be skipped *\/\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    if (parent.hasChild(nodeName)) {\r\n        \/\/ a node with that name already exists...\r\n        Tree existing = parent.getChild(nodeName);\r\n        NodeDefinition def = getDefinition(existing);\r\n        if (!def.allowsSameNameSiblings()) {\r\n            \/\/ check for potential conflicts\r\n            if (def.isProtected() && isNodeType(existing, ntName)) {\r\n                \/*\r\n                     use the existing node as parent for the possible subsequent\r\n                     import of a protected tree, that the protected node importer\r\n                     may or may not be able to deal with.\r\n                     -> upon the next 'startNode' the check for the parent being\r\n                        protected will notify the protected node importer.\r\n                     -> if the importer is able to deal with that node it needs\r\n                        to care of the complete subtree until it is notified\r\n                        during the 'endNode' call.\r\n                     -> if the import can't deal with that node or if that node\r\n                        is the a leaf in the tree to be imported 'end' will\r\n                        not have an effect on the importer, that was never started.\r\n                    *\/\r\n                log.debug(\"Skipping protected node: \" + existing);\r\n                parents.push(existing);\r\n                \/**\r\n                 * let ProtectedPropertyImporters handle the properties\r\n                 * associated with the imported node. this may include overwriting,\r\n                 * merging or just adding missing properties.\r\n                 *\/\r\n                importProperties(existing, propInfos, true);\r\n                return;\r\n            }\r\n            if (def.isAutoCreated() && isNodeType(existing, ntName)) {\r\n                \/\/ this node has already been auto-created, no need to create it\r\n                tree = existing;\r\n            } else {\r\n                \/\/ edge case: colliding node does have same uuid\r\n                \/\/ (see http:\/\/issues.apache.org\/jira\/browse\/JCR-1128)\r\n                String existingIdentifier = IdentifierManager.getIdentifier(existing);\r\n                if (!(existingIdentifier.equals(id) && (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING || uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING))) {\r\n                    throw new ItemExistsException(\"Node with the same UUID exists:\" + existing);\r\n                }\r\n            \/\/ fall through\r\n            }\r\n        }\r\n    }\r\n    if (tree == null) {\r\n        \/\/ create node\r\n        if (id == null) {\r\n            \/\/ no potential uuid conflict, always add new node\r\n            tree = createTree(parent, nodeInfo, null);\r\n        } else if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\r\n            \/\/ always create a new UUID even if no\r\n            \/\/ conflicting node exists. see OAK-1244\r\n            tree = createTree(parent, nodeInfo, UUID.randomUUID().toString());\r\n            \/\/ remember uuid mapping\r\n            if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\r\n                refTracker.put(nodeInfo.getUUID(), TreeUtil.getString(tree, JcrConstants.JCR_UUID));\r\n            }\r\n        } else {\r\n            \/\/ 1. First check from base state that tree corresponding to\r\n            \/\/ this id exist\r\n            Tree conflicting = baseStateIdManager.getTree(id);\r\n            if (conflicting == null) {\r\n                \/\/ 1.a. Check if id is found in newly created nodes\r\n                if (uuids.contains(id)) {\r\n                    conflicting = currentStateIdManager.getTree(id);\r\n                }\r\n            } else {\r\n                \/\/ 1.b Re obtain the conflicting tree from Id Manager\r\n                \/\/ associated with current root. Such that any operation\r\n                \/\/ on it gets reflected in later operations\r\n                \/\/ In case a tree with same id was removed earlier then it\r\n                \/\/ would return null\r\n                conflicting = currentStateIdManager.getTree(id);\r\n            }\r\n            if (conflicting != null && conflicting.exists()) {\r\n                \/\/ resolve uuid conflict\r\n                tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\r\n                if (tree == null) {\r\n                    \/\/ no new node has been created, so skip this node\r\n                    \/\/ push null onto stack for skipped node\r\n                    parents.push(null);\r\n                    log.debug(\"Skipping existing node \" + nodeInfo.getName());\r\n                    return;\r\n                }\r\n            } else {\r\n                \/\/ create new with given uuid\r\n                tree = createTree(parent, nodeInfo, id);\r\n            }\r\n        }\r\n    }\r\n    \/\/ process properties\r\n    importProperties(tree, propInfos, false);\r\n    parents.push(tree);\r\n}","code_comment":"\/**\r\n * let ProtectedPropertyImporters handle the properties\r\n * associated with the imported node. this may include overwriting,\r\n * merging or just adding missing properties.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos) throws RepositoryException {\r\n    Tree parent = parents.peek();\r\n    Tree tree = null;\r\n    String id = nodeInfo.getUUID();\r\n    String nodeName = nodeInfo.getName();\r\n    String ntName = nodeInfo.getPrimaryTypeName();\r\n    if (parent == null) {\r\n        log.debug(\"Skipping node: \" + nodeName);\r\n                        parents.push(null);\r\n                if (pnImporter != null) {\r\n            pnImporter.startChildInfo(nodeInfo, propInfos);\r\n        }\r\n        return;\r\n    }\r\n    NodeDefinition parentDef = getDefinition(parent);\r\n    if (parentDef.isProtected()) {\r\n                parents.push(null);\r\n        log.debug(\"Skipping protected node: \" + nodeName);\r\n        if (pnImporter != null) {\r\n                                    pnImporter.startChildInfo(nodeInfo, propInfos);\r\n        } else {\r\n                        for (ProtectedNodeImporter pni : getNodeImporters()) {\r\n                if (pni.start(parent)) {\r\n                    log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\r\n                    pnImporter = pni;\r\n                    pnImporter.startChildInfo(nodeInfo, propInfos);\r\n                    break;\r\n                }\r\n                        }\r\n        }\r\n        return;\r\n    }\r\n    if (parent.hasChild(nodeName)) {\r\n                Tree existing = parent.getChild(nodeName);\r\n        NodeDefinition def = getDefinition(existing);\r\n        if (!def.allowsSameNameSiblings()) {\r\n                        if (def.isProtected() && isNodeType(existing, ntName)) {\r\n                                log.debug(\"Skipping protected node: \" + existing);\r\n                parents.push(existing);\r\n                \/**\r\n                 * let ProtectedPropertyImporters handle the properties\r\n                 * associated with the imported node. this may include overwriting,\r\n                 * merging or just adding missing properties.\r\n                 *\/\r\n                importProperties(existing, propInfos, true);\r\n                return;\r\n            }\r\n            if (def.isAutoCreated() && isNodeType(existing, ntName)) {\r\n                                tree = existing;\r\n            } else {\r\n                                                String existingIdentifier = IdentifierManager.getIdentifier(existing);\r\n                if (!(existingIdentifier.equals(id) && (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING || uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING))) {\r\n                    throw new ItemExistsException(\"Node with the same UUID exists:\" + existing);\r\n                }\r\n                        }\r\n        }\r\n    }\r\n    if (tree == null) {\r\n                if (id == null) {\r\n                        tree = createTree(parent, nodeInfo, null);\r\n        } else if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\r\n                                    tree = createTree(parent, nodeInfo, UUID.randomUUID().toString());\r\n                        if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\r\n                refTracker.put(nodeInfo.getUUID(), TreeUtil.getString(tree, JcrConstants.JCR_UUID));\r\n            }\r\n        } else {\r\n                                    Tree conflicting = baseStateIdManager.getTree(id);\r\n            if (conflicting == null) {\r\n                                if (uuids.contains(id)) {\r\n                    conflicting = currentStateIdManager.getTree(id);\r\n                }\r\n            } else {\r\n                                                                                                conflicting = currentStateIdManager.getTree(id);\r\n            }\r\n            if (conflicting != null && conflicting.exists()) {\r\n                                tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\r\n                if (tree == null) {\r\n                                                            parents.push(null);\r\n                    log.debug(\"Skipping existing node \" + nodeInfo.getName());\r\n                    return;\r\n                }\r\n            } else {\r\n                                tree = createTree(parent, nodeInfo, id);\r\n            }\r\n        }\r\n    }\r\n        importProperties(tree, propInfos, false);\r\n    parents.push(tree);\r\n}","lc":3.4545454545,"pi":1.1818181818,"ma":3.6,"nbd":1.5,"ml":3.1666666667,"d":1.2400793651,"mi":-1.3044397463,"fo":3.5833333333,"r":-0.0263157895,"e":5.9241460786}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5853_b80f6640","label":3,"code":"\/**\r\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)\r\n *\/\r\n@Override\r\npublic Integer convertToObject(final String value, final Locale locale) {\r\n    final Number number = parse(value, Integer.MIN_VALUE, Integer.MAX_VALUE, locale);\r\n    if (number == null) {\r\n        return null;\r\n    }\r\n    return number.intValue();\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)\r\n *\/\r\n","code_no_comment":"@Override\r\npublic Integer convertToObject(final String value, final Locale locale) {\r\n    final Number number = parse(value, Integer.MIN_VALUE, Integer.MAX_VALUE, locale);\r\n    if (number == null) {\r\n        return null;\r\n    }\r\n    return number.intValue();\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0734126984,"mi":0.3429175476,"fo":-0.3333333333,"r":0.1842105263,"e":-0.0964598353}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4387_ca05fd06","label":1,"code":"private void readExcerpt() throws ParseException {\r\n    read(\"(\");\r\n    if (!readIf(\")\")) {\r\n        \/\/ only rep:excerpt(.) and rep:excerpt() are currently supported\r\n        read(\".\");\r\n        read(\")\");\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void readExcerpt() throws ParseException {\r\n    read(\"(\");\r\n    if (!readIf(\")\")) {\r\n                read(\".\");\r\n        read(\")\");\r\n    }\r\n}","lc":-0.3181818182,"pi":0.014354067,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.5427766032,"fo":-0.1666666667,"r":2.1578947368,"e":-0.1627934049}
{"project_name":"Closure","project_version":"16","label":2,"code":"@Override\r\npublic void applyAlias() {\r\n    typeReference.setString(aliasName);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void applyAlias() {\r\n    typeReference.setString(aliasName);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9362931642,"fo":-0.4166666667,"r":1.7368421053,"e":-0.1627934049}
{"project_name":"Closure","project_version":"61","label":2,"code":"\/**\r\n * Returns true if calls to this function have side effects.\r\n *\r\n * @param callNode The call node to inspected.\r\n * @param compiler A compiler object to provide program state changing\r\n *     context information. Can be null.\r\n *\/\r\nstatic boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\r\n    if (callNode.getType() != Token.CALL) {\r\n        throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\r\n    }\r\n    if (callNode.isNoSideEffectsCall()) {\r\n        return false;\r\n    }\r\n    Node nameNode = callNode.getFirstChild();\r\n    \/\/ Built-in functions with no side effects.\r\n    if (nameNode.getType() == Token.NAME) {\r\n        String name = nameNode.getString();\r\n        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\r\n            return false;\r\n        }\r\n    } else if (nameNode.getType() == Token.GETPROP) {\r\n        if (callNode.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\r\n            return false;\r\n        }\r\n        if (callNode.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) {\r\n            return false;\r\n        }\r\n        if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\r\n            if (nameNode.getFirstChild().getType() == Token.REGEXP && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\r\n                return false;\r\n            } else if (nameNode.getFirstChild().getType() == Token.STRING && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\r\n                Node param = nameNode.getNext();\r\n                if (param != null && (param.getType() == Token.STRING || param.getType() == Token.REGEXP))\r\n                    return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n * Returns true if calls to this function have side effects.\r\n *\r\n * @param callNode The call node to inspected.\r\n * @param compiler A compiler object to provide program state changing\r\n *     context information. Can be null.\r\n *\/\r\n","code_no_comment":"static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\r\n    if (callNode.getType() != Token.CALL) {\r\n        throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\r\n    }\r\n    if (callNode.isNoSideEffectsCall()) {\r\n        return false;\r\n    }\r\n    Node nameNode = callNode.getFirstChild();\r\n        if (nameNode.getType() == Token.NAME) {\r\n        String name = nameNode.getString();\r\n        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\r\n            return false;\r\n        }\r\n    } else if (nameNode.getType() == Token.GETPROP) {\r\n        if (callNode.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\r\n            return false;\r\n        }\r\n        if (callNode.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) {\r\n            return false;\r\n        }\r\n        if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\r\n            if (nameNode.getFirstChild().getType() == Token.REGEXP && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\r\n                return false;\r\n            } else if (nameNode.getFirstChild().getType() == Token.STRING && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\r\n                Node param = nameNode.getNext();\r\n                if (param != null && (param.getType() == Token.STRING || param.getType() == Token.REGEXP))\r\n                    return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}","lc":0.8181818182,"pi":0.8086124402,"ma":1.8,"nbd":1.5,"ml":2.5833333333,"d":1.1626984127,"mi":-0.6349541931,"fo":2.0,"r":-0.0263157895,"e":2.0861672516}
{"project_name":"Lang","project_version":"13","label":1,"code":"\/**\r\n * Overriden version that uses the parametrized <code>ClassLoader<\/code> or the <code>ClassLoader<\/code>\r\n * of the current <code>Thread<\/code> to resolve the class.\r\n * @param desc An instance of class <code>ObjectStreamClass<\/code>.\r\n * @return A <code>Class<\/code> object corresponding to <code>desc<\/code>.\r\n * @throws IOException Any of the usual Input\/Output exceptions.\r\n * @throws ClassNotFoundException If class of a serialized object cannot be found.\r\n *\/\r\n@Override\r\nprotected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\r\n    String name = desc.getName();\r\n    try {\r\n        return Class.forName(name, false, classLoader);\r\n    } catch (ClassNotFoundException ex) {\r\n        return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\r\n    }\r\n}","code_comment":"\/**\r\n * Overriden version that uses the parametrized <code>ClassLoader<\/code> or the <code>ClassLoader<\/code>\r\n * of the current <code>Thread<\/code> to resolve the class.\r\n * @param desc An instance of class <code>ObjectStreamClass<\/code>.\r\n * @return A <code>Class<\/code> object corresponding to <code>desc<\/code>.\r\n * @throws IOException Any of the usual Input\/Output exceptions.\r\n * @throws ClassNotFoundException If class of a serialized object cannot be found.\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\r\n    String name = desc.getName();\r\n    try {\r\n        return Class.forName(name, false, classLoader);\r\n    } catch (ClassNotFoundException ex) {\r\n        return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.2662438337,"fo":-0.0833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-509_b896c926","label":3,"code":"@Override\r\n@CheckForNull\r\npublic String getJcrName(String oakName) {\r\n    checkNotNull(oakName);\r\n    \/\/ hidden name\r\n    checkArgument(!oakName.startsWith(\":\"));\r\n    \/\/ expanded name\r\n    checkArgument(isExpandedName(oakName));\r\n    if (hasSessionLocalMappings()) {\r\n        int colon = oakName.indexOf(':');\r\n        if (colon > 0) {\r\n            String oakPrefix = oakName.substring(0, colon);\r\n            String uri = getNamespaceMap().get(oakPrefix);\r\n            if (uri == null) {\r\n                throw new IllegalStateException(\"No namespace mapping found for \" + oakName);\r\n            }\r\n            Map<String, String> local = getSessionLocalMappings();\r\n            for (Map.Entry<String, String> entry : local.entrySet()) {\r\n                if (uri.equals(entry.getValue())) {\r\n                    String jcrPrefix = entry.getKey();\r\n                    if (jcrPrefix.equals(oakPrefix)) {\r\n                        return oakName;\r\n                    } else {\r\n                        return jcrPrefix + oakName.substring(colon);\r\n                    }\r\n                }\r\n            }\r\n            \/\/ is no conflicting local mapping for the prefix\r\n            if (local.containsKey(oakPrefix)) {\r\n                for (int i = 2; true; i++) {\r\n                    String jcrPrefix = oakPrefix + i;\r\n                    if (!local.containsKey(jcrPrefix)) {\r\n                        return jcrPrefix + oakName.substring(colon);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return oakName;\r\n}","code_comment":null,"code_no_comment":"@Override\r\n@CheckForNull\r\npublic String getJcrName(String oakName) {\r\n    checkNotNull(oakName);\r\n        checkArgument(!oakName.startsWith(\":\"));\r\n        checkArgument(isExpandedName(oakName));\r\n    if (hasSessionLocalMappings()) {\r\n        int colon = oakName.indexOf(':');\r\n        if (colon > 0) {\r\n            String oakPrefix = oakName.substring(0, colon);\r\n            String uri = getNamespaceMap().get(oakPrefix);\r\n            if (uri == null) {\r\n                throw new IllegalStateException(\"No namespace mapping found for \" + oakName);\r\n            }\r\n            Map<String, String> local = getSessionLocalMappings();\r\n            for (Map.Entry<String, String> entry : local.entrySet()) {\r\n                if (uri.equals(entry.getValue())) {\r\n                    String jcrPrefix = entry.getKey();\r\n                    if (jcrPrefix.equals(oakPrefix)) {\r\n                        return oakName;\r\n                    } else {\r\n                        return jcrPrefix + oakName.substring(colon);\r\n                    }\r\n                }\r\n            }\r\n                        if (local.containsKey(oakPrefix)) {\r\n                for (int i = 2; true; i++) {\r\n                    String jcrPrefix = oakPrefix + i;\r\n                    if (!local.containsKey(jcrPrefix)) {\r\n                        return jcrPrefix + oakName.substring(colon);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return oakName;\r\n}","lc":1.0454545455,"pi":2.0574162679,"ma":1.4,"nbd":1.5,"ml":1.0833333333,"d":1.0178571429,"mi":-0.6684989429,"fo":1.1666666667,"r":-0.0263157895,"e":1.6165165425}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-899_ce126bdb","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic synchronized int nextInt(int n) {\r\n    return wrapped.nextInt();\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public synchronized int nextInt(int n) {\r\n    return wrapped.nextInt();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1319238901,"fo":-0.4166666667,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3789_9319e139","label":1,"code":"\/**\r\n * Creates and prepares the output file channel. Will position itself in correct position if the file is writable\r\n *  eg. it should append or override any existing content.\r\n *\/\r\nprivate FileChannel prepareOutputFileChannel(File target, FileChannel out) throws IOException {\r\n    if (endpoint.getFileExist() == GenericFileExist.Append) {\r\n        out = new RandomAccessFile(target, \"rw\").getChannel();\r\n        out = out.position(out.size());\r\n    } else {\r\n        \/\/ will override\r\n        out = new FileOutputStream(target).getChannel();\r\n    }\r\n    return out;\r\n}","code_comment":"\/**\r\n * Creates and prepares the output file channel. Will position itself in correct position if the file is writable\r\n *  eg. it should append or override any existing content.\r\n *\/\r\n","code_no_comment":"private FileChannel prepareOutputFileChannel(File target, FileChannel out) throws IOException {\r\n    if (endpoint.getFileExist() == GenericFileExist.Append) {\r\n        out = new RandomAccessFile(target, \"rw\").getChannel();\r\n        out = out.position(out.size());\r\n    } else {\r\n                out = new FileOutputStream(target).getChannel();\r\n    }\r\n    return out;\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0496031746,"mi":0.2459478506,"fo":-0.0833333333,"r":0.3421052632,"e":-0.0663681472}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2060_0578d6ee","label":1,"code":"\/**\r\n *  Removes javascript comments and whitespace from specified string.\r\n *\r\n *  @param original\r\n *             Source string\r\n *  @return String with removed comments and whitespace\r\n *\/\r\npublic static String stripCommentsAndWhitespace(String original) {\r\n    \/\/ let's be optimistic\r\n    AppendingStringBuffer result = new AppendingStringBuffer(original.length() \/ 2);\r\n    int state = REGULAR_TEXT;\r\n    for (int i = 0; i < original.length(); ++i) {\r\n        char c = original.charAt(i);\r\n        char next = (i < original.length() - 1) ? original.charAt(i + 1) : 0;\r\n        char prev = (i > 0) ? original.charAt(i - 1) : 0;\r\n        if (state == WHITE_SPACE) {\r\n            if (Character.isWhitespace(next) == false) {\r\n                state = REGULAR_TEXT;\r\n            }\r\n            continue;\r\n        }\r\n        if (state == REGULAR_TEXT) {\r\n            if (c == '\/' && next == '\/' && prev != '\\\\') {\r\n                state = LINE_COMMENT;\r\n                continue;\r\n            } else if (c == '\/' && next == '*') {\r\n                state = MULTILINE_COMMENT;\r\n                ++i;\r\n                continue;\r\n            } else if (c == '\/') {\r\n                \/\/ This might be a divide operator, or it might be a regular expression.\r\n                \/\/ Work out if it's a regular expression by finding the previous non-whitespace\r\n                \/\/ char, which\r\n                \/\/ will be either '=' or '('. If it's not, it's just a divide operator.\r\n                int idx = result.length() - 1;\r\n                while (idx > 0) {\r\n                    char tmp = result.charAt(idx);\r\n                    if (Character.isWhitespace(tmp)) {\r\n                        idx--;\r\n                        continue;\r\n                    }\r\n                    if (tmp == '=' || tmp == '(' || tmp == '{' || tmp == ':' || tmp == ',' || tmp == '[') {\r\n                        state = REG_EXP;\r\n                        break;\r\n                    }\r\n                    break;\r\n                }\r\n            } else if (Character.isWhitespace(c) && Character.isWhitespace(next)) {\r\n                \/\/ ignore all whitespace characters after this one\r\n                state = WHITE_SPACE;\r\n                c = '\\n';\r\n            } else if (c == '\\'') {\r\n                state = STRING_SINGLE_QUOTE;\r\n            } else if (c == '\"') {\r\n                state = STRING_DOUBLE_QUOTES;\r\n            }\r\n            result.append(c);\r\n            continue;\r\n        }\r\n        if (state == LINE_COMMENT) {\r\n            if (c == '\\n' || c == '\\r') {\r\n                state = REGULAR_TEXT;\r\n                continue;\r\n            }\r\n        }\r\n        if (state == MULTILINE_COMMENT) {\r\n            if (c == '*' && next == '\/') {\r\n                state = REGULAR_TEXT;\r\n                ++i;\r\n                continue;\r\n            }\r\n        }\r\n        if (state == STRING_SINGLE_QUOTE) {\r\n            \/\/ to leave a string expression we need even (or zero) number of backslashes\r\n            int count = getPrevCount(original, i, '\\\\');\r\n            if (c == '\\'' && count % 2 == 0) {\r\n                state = REGULAR_TEXT;\r\n            }\r\n            result.append(c);\r\n            continue;\r\n        }\r\n        if (state == STRING_DOUBLE_QUOTES) {\r\n            \/\/ to leave a string expression we need even (or zero) number of backslashes\r\n            int count = getPrevCount(original, i, '\\\\');\r\n            if (c == '\"' && count % 2 == 0) {\r\n                state = REGULAR_TEXT;\r\n            }\r\n            result.append(c);\r\n            continue;\r\n        }\r\n        if (state == REG_EXP) {\r\n            \/\/ to leave regular expression we need even (or zero) number of backslashes\r\n            int count = getPrevCount(original, i, '\\\\');\r\n            if (c == '\/' && count % 2 == 0) {\r\n                state = REGULAR_TEXT;\r\n            }\r\n            result.append(c);\r\n            continue;\r\n        }\r\n    }\r\n    return result.toString();\r\n}","code_comment":"\/**\r\n *  Removes javascript comments and whitespace from specified string.\r\n *\r\n *  @param original\r\n *             Source string\r\n *  @return String with removed comments and whitespace\r\n *\/\r\n","code_no_comment":"public static String stripCommentsAndWhitespace(String original) {\r\n        AppendingStringBuffer result = new AppendingStringBuffer(original.length() \/ 2);\r\n    int state = REGULAR_TEXT;\r\n    for (int i = 0; i < original.length(); ++i) {\r\n        char c = original.charAt(i);\r\n        char next = (i < original.length() - 1) ? original.charAt(i + 1) : 0;\r\n        char prev = (i > 0) ? original.charAt(i - 1) : 0;\r\n        if (state == WHITE_SPACE) {\r\n            if (Character.isWhitespace(next) == false) {\r\n                state = REGULAR_TEXT;\r\n            }\r\n            continue;\r\n        }\r\n        if (state == REGULAR_TEXT) {\r\n            if (c == '\/' && next == '\/' && prev != '\\\\') {\r\n                state = LINE_COMMENT;\r\n                continue;\r\n            } else if (c == '\/' && next == '*') {\r\n                state = MULTILINE_COMMENT;\r\n                ++i;\r\n                continue;\r\n            } else if (c == '\/') {\r\n                                                                                int idx = result.length() - 1;\r\n                while (idx > 0) {\r\n                    char tmp = result.charAt(idx);\r\n                    if (Character.isWhitespace(tmp)) {\r\n                        idx--;\r\n                        continue;\r\n                    }\r\n                    if (tmp == '=' || tmp == '(' || tmp == '{' || tmp == ':' || tmp == ',' || tmp == '[') {\r\n                        state = REG_EXP;\r\n                        break;\r\n                    }\r\n                    break;\r\n                }\r\n            } else if (Character.isWhitespace(c) && Character.isWhitespace(next)) {\r\n                                state = WHITE_SPACE;\r\n                c = '\\n';\r\n            } else if (c == '\\'') {\r\n                state = STRING_SINGLE_QUOTE;\r\n            } else if (c == '\"') {\r\n                state = STRING_DOUBLE_QUOTES;\r\n            }\r\n            result.append(c);\r\n            continue;\r\n        }\r\n        if (state == LINE_COMMENT) {\r\n            if (c == '\\n' || c == '\\r') {\r\n                state = REGULAR_TEXT;\r\n                continue;\r\n            }\r\n        }\r\n        if (state == MULTILINE_COMMENT) {\r\n            if (c == '*' && next == '\/') {\r\n                state = REGULAR_TEXT;\r\n                ++i;\r\n                continue;\r\n            }\r\n        }\r\n        if (state == STRING_SINGLE_QUOTE) {\r\n                        int count = getPrevCount(original, i, '\\\\');\r\n            if (c == '\\'' && count % 2 == 0) {\r\n                state = REGULAR_TEXT;\r\n            }\r\n            result.append(c);\r\n            continue;\r\n        }\r\n        if (state == STRING_DOUBLE_QUOTES) {\r\n                        int count = getPrevCount(original, i, '\\\\');\r\n            if (c == '\"' && count % 2 == 0) {\r\n                state = REGULAR_TEXT;\r\n            }\r\n            result.append(c);\r\n            continue;\r\n        }\r\n        if (state == REG_EXP) {\r\n                        int count = getPrevCount(original, i, '\\\\');\r\n            if (c == '\/' && count % 2 == 0) {\r\n                state = REGULAR_TEXT;\r\n            }\r\n            result.append(c);\r\n            continue;\r\n        }\r\n    }\r\n    return result.toString();\r\n}","lc":3.2727272727,"pi":0.961722488,"ma":6.8,"nbd":3.0,"ml":3.8333333333,"d":4.5813492063,"mi":-1.3842142354,"fo":1.1666666667,"r":-0.0263157895,"e":18.2205263856}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Sets the initial capacity.  Should only be invoked by constructors.\r\n *\r\n * @param initialCapacity of the array\r\n * @throws MathIllegalArgumentException if <code>initialCapacity<\/code> is not\r\n * positive.\r\n * @deprecated As of 3.1, this is a no-op.\r\n *\/\r\n@Deprecated\r\nprotected void setInitialCapacity(int initialCapacity) throws MathIllegalArgumentException {\r\n\/\/ Body removed in 3.1.\r\n}","code_comment":"\/**\r\n * Sets the initial capacity.  Should only be invoked by constructors.\r\n *\r\n * @param initialCapacity of the array\r\n * @throws MathIllegalArgumentException if <code>initialCapacity<\/code> is not\r\n * positive.\r\n * @deprecated As of 3.1, this is a no-op.\r\n *\/\r\n","code_no_comment":"@Deprecated\r\nprotected void setInitialCapacity(int initialCapacity) throws MathIllegalArgumentException {\r\n}","lc":-0.5,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.5,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-349_4cc9a49d","label":3,"code":"\/**\r\n * Modify the normal distribution used to compute normal approximations. The\r\n * caller is responsible for insuring the normal distribution has the proper\r\n * parameter settings.\r\n *\r\n * @param value the new distribution\r\n * @since 1.2\r\n * @deprecated as of 2.1 (class will become immutable in 3.0)\r\n *\/\r\n@Deprecated\r\npublic void setNormal(NormalDistribution value) {\r\n    setNormalAndMeanInternal(value, mean);\r\n}","code_comment":"\/**\r\n * Modify the normal distribution used to compute normal approximations. The\r\n * caller is responsible for insuring the normal distribution has the proper\r\n * parameter settings.\r\n *\r\n * @param value the new distribution\r\n * @since 1.2\r\n * @deprecated as of 2.1 (class will become immutable in 3.0)\r\n *\/\r\n","code_no_comment":"@Deprecated\r\npublic void setNormal(NormalDistribution value) {\r\n    setNormalAndMeanInternal(value, mean);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.881888654,"fo":-0.4166666667,"r":2.5,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"@Override\r\npublic String toString() {\r\n    StringBuilder sb = new StringBuilder(\"setTableProperty_result(\");\r\n    boolean first = true;\r\n    sb.append(\"ouch1:\");\r\n    if (this.ouch1 == null) {\r\n        sb.append(\"null\");\r\n    } else {\r\n        sb.append(this.ouch1);\r\n    }\r\n    first = false;\r\n    if (!first)\r\n        sb.append(\", \");\r\n    sb.append(\"ouch2:\");\r\n    if (this.ouch2 == null) {\r\n        sb.append(\"null\");\r\n    } else {\r\n        sb.append(this.ouch2);\r\n    }\r\n    first = false;\r\n    sb.append(\")\");\r\n    return sb.toString();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String toString() {\r\n    StringBuilder sb = new StringBuilder(\"setTableProperty_result(\");\r\n    boolean first = true;\r\n    sb.append(\"ouch1:\");\r\n    if (this.ouch1 == null) {\r\n        sb.append(\"null\");\r\n    } else {\r\n        sb.append(this.ouch1);\r\n    }\r\n    first = false;\r\n    if (!first)\r\n        sb.append(\", \");\r\n    sb.append(\"ouch2:\");\r\n    if (this.ouch2 == null) {\r\n        sb.append(\"null\");\r\n    } else {\r\n        sb.append(this.ouch2);\r\n    }\r\n    first = false;\r\n    sb.append(\")\");\r\n    return sb.toString();\r\n}","lc":0.4090909091,"pi":-0.3157894737,"ma":0.0,"nbd":-0.5,"ml":0.0833333333,"d":0.130952381,"mi":-0.2763918252,"fo":0.25,"r":0.0,"e":0.1004569999}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-276_1bf5c550","label":1,"code":"public void writeHead(Id id) {\r\n    head = id;\r\n}","code_comment":null,"code_no_comment":"public void writeHead(Id id) {\r\n    head = id;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0451021846,"fo":-0.5,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-377_c640932d","label":1,"code":"\/**\r\n * Find eigenvalues and eigenvectors (Dubrulle et al., 1971)\r\n * @param householderMatrix Householder matrix of the transformation\r\n *  to tri-diagonal form.\r\n *\/\r\nprivate void findEigenVectors(double[][] householderMatrix) {\r\n    double[][] z = householderMatrix.clone();\r\n    final int n = main.length;\r\n    realEigenvalues = new double[n];\r\n    imagEigenvalues = new double[n];\r\n    double[] e = new double[n];\r\n    for (int i = 0; i < n - 1; i++) {\r\n        realEigenvalues[i] = main[i];\r\n        e[i] = secondary[i];\r\n    }\r\n    realEigenvalues[n - 1] = main[n - 1];\r\n    e[n - 1] = 0.0;\r\n    \/\/ Determine the largest main and secondary value in absolute term.\r\n    double maxAbsoluteValue = 0.0;\r\n    for (int i = 0; i < n; i++) {\r\n        if (Math.abs(realEigenvalues[i]) > maxAbsoluteValue) {\r\n            maxAbsoluteValue = Math.abs(realEigenvalues[i]);\r\n        }\r\n        if (Math.abs(e[i]) > maxAbsoluteValue) {\r\n            maxAbsoluteValue = Math.abs(e[i]);\r\n        }\r\n    }\r\n    \/\/ Make null any main and secondary value too small to be significant\r\n    if (maxAbsoluteValue != 0.0) {\r\n        for (int i = 0; i < n; i++) {\r\n            if (Math.abs(realEigenvalues[i]) <= MathUtils.EPSILON * maxAbsoluteValue) {\r\n                realEigenvalues[i] = 0.0;\r\n            }\r\n            if (Math.abs(e[i]) <= MathUtils.EPSILON * maxAbsoluteValue) {\r\n                e[i] = 0.0;\r\n            }\r\n        }\r\n    }\r\n    for (int j = 0; j < n; j++) {\r\n        int its = 0;\r\n        int m;\r\n        do {\r\n            for (m = j; m < n - 1; m++) {\r\n                double delta = Math.abs(realEigenvalues[m]) + Math.abs(realEigenvalues[m + 1]);\r\n                if (Math.abs(e[m]) + delta == delta) {\r\n                    break;\r\n                }\r\n            }\r\n            if (m != j) {\r\n                if (its == maxIter)\r\n                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\r\n                its++;\r\n                double q = (realEigenvalues[j + 1] - realEigenvalues[j]) \/ (2 * e[j]);\r\n                double t = Math.sqrt(1 + q * q);\r\n                if (q < 0.0) {\r\n                    q = realEigenvalues[m] - realEigenvalues[j] + e[j] \/ (q - t);\r\n                } else {\r\n                    q = realEigenvalues[m] - realEigenvalues[j] + e[j] \/ (q + t);\r\n                }\r\n                double u = 0.0;\r\n                double s = 1.0;\r\n                double c = 1.0;\r\n                int i;\r\n                for (i = m - 1; i >= j; i--) {\r\n                    double p = s * e[i];\r\n                    double h = c * e[i];\r\n                    if (Math.abs(p) >= Math.abs(q)) {\r\n                        c = q \/ p;\r\n                        t = Math.sqrt(c * c + 1.0);\r\n                        e[i + 1] = p * t;\r\n                        s = 1.0 \/ t;\r\n                        c = c * s;\r\n                    } else {\r\n                        s = p \/ q;\r\n                        t = Math.sqrt(s * s + 1.0);\r\n                        e[i + 1] = q * t;\r\n                        c = 1.0 \/ t;\r\n                        s = s * c;\r\n                    }\r\n                    if (e[i + 1] == 0.0) {\r\n                        realEigenvalues[i + 1] -= u;\r\n                        e[m] = 0.0;\r\n                        break;\r\n                    }\r\n                    q = realEigenvalues[i + 1] - u;\r\n                    t = (realEigenvalues[i] - q) * s + 2.0 * c * h;\r\n                    u = s * t;\r\n                    realEigenvalues[i + 1] = q + u;\r\n                    q = c * t - h;\r\n                    for (int ia = 0; ia < n; ia++) {\r\n                        p = z[ia][i + 1];\r\n                        z[ia][i + 1] = s * z[ia][i] + c * p;\r\n                        z[ia][i] = c * z[ia][i] - s * p;\r\n                    }\r\n                }\r\n                if (e[i + 1] == 0.0 && i >= j)\r\n                    continue;\r\n                realEigenvalues[j] -= u;\r\n                e[j] = q;\r\n                e[m] = 0.0;\r\n            }\r\n        } while (m != j);\r\n    }\r\n    \/\/ Sort the eigen values (and vectors) in increase order\r\n    for (int i = 0; i < n; i++) {\r\n        int k = i;\r\n        double p = realEigenvalues[i];\r\n        for (int j = i + 1; j < n; j++) {\r\n            if (realEigenvalues[j] > p) {\r\n                k = j;\r\n                p = realEigenvalues[j];\r\n            }\r\n        }\r\n        if (k != i) {\r\n            realEigenvalues[k] = realEigenvalues[i];\r\n            realEigenvalues[i] = p;\r\n            for (int j = 0; j < n; j++) {\r\n                p = z[j][i];\r\n                z[j][i] = z[j][k];\r\n                z[j][k] = p;\r\n            }\r\n        }\r\n    }\r\n    \/\/ Determine the largest eigen value in absolute term.\r\n    maxAbsoluteValue = 0.0;\r\n    for (int i = 0; i < n; i++) {\r\n        if (Math.abs(realEigenvalues[i]) > maxAbsoluteValue) {\r\n            maxAbsoluteValue = Math.abs(realEigenvalues[i]);\r\n        }\r\n    }\r\n    \/\/ Make null any eigen value too small to be significant\r\n    if (maxAbsoluteValue != 0.0) {\r\n        for (int i = 0; i < n; i++) {\r\n            if (Math.abs(realEigenvalues[i]) < MathUtils.EPSILON * maxAbsoluteValue) {\r\n                realEigenvalues[i] = 0.0;\r\n            }\r\n        }\r\n    }\r\n    eigenvectors = new ArrayRealVector[n];\r\n    double[] tmp = new double[n];\r\n    for (int i = 0; i < n; i++) {\r\n        for (int j = 0; j < n; j++) {\r\n            tmp[j] = z[j][i];\r\n        }\r\n        eigenvectors[i] = new ArrayRealVector(tmp);\r\n    }\r\n}","code_comment":"\/**\r\n * Find eigenvalues and eigenvectors (Dubrulle et al., 1971)\r\n * @param householderMatrix Householder matrix of the transformation\r\n *  to tri-diagonal form.\r\n *\/\r\n","code_no_comment":"private void findEigenVectors(double[][] householderMatrix) {\r\n    double[][] z = householderMatrix.clone();\r\n    final int n = main.length;\r\n    realEigenvalues = new double[n];\r\n    imagEigenvalues = new double[n];\r\n    double[] e = new double[n];\r\n    for (int i = 0; i < n - 1; i++) {\r\n        realEigenvalues[i] = main[i];\r\n        e[i] = secondary[i];\r\n    }\r\n    realEigenvalues[n - 1] = main[n - 1];\r\n    e[n - 1] = 0.0;\r\n        double maxAbsoluteValue = 0.0;\r\n    for (int i = 0; i < n; i++) {\r\n        if (Math.abs(realEigenvalues[i]) > maxAbsoluteValue) {\r\n            maxAbsoluteValue = Math.abs(realEigenvalues[i]);\r\n        }\r\n        if (Math.abs(e[i]) > maxAbsoluteValue) {\r\n            maxAbsoluteValue = Math.abs(e[i]);\r\n        }\r\n    }\r\n        if (maxAbsoluteValue != 0.0) {\r\n        for (int i = 0; i < n; i++) {\r\n            if (Math.abs(realEigenvalues[i]) <= MathUtils.EPSILON * maxAbsoluteValue) {\r\n                realEigenvalues[i] = 0.0;\r\n            }\r\n            if (Math.abs(e[i]) <= MathUtils.EPSILON * maxAbsoluteValue) {\r\n                e[i] = 0.0;\r\n            }\r\n        }\r\n    }\r\n    for (int j = 0; j < n; j++) {\r\n        int its = 0;\r\n        int m;\r\n        do {\r\n            for (m = j; m < n - 1; m++) {\r\n                double delta = Math.abs(realEigenvalues[m]) + Math.abs(realEigenvalues[m + 1]);\r\n                if (Math.abs(e[m]) + delta == delta) {\r\n                    break;\r\n                }\r\n            }\r\n            if (m != j) {\r\n                if (its == maxIter)\r\n                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\r\n                its++;\r\n                double q = (realEigenvalues[j + 1] - realEigenvalues[j]) \/ (2 * e[j]);\r\n                double t = Math.sqrt(1 + q * q);\r\n                if (q < 0.0) {\r\n                    q = realEigenvalues[m] - realEigenvalues[j] + e[j] \/ (q - t);\r\n                } else {\r\n                    q = realEigenvalues[m] - realEigenvalues[j] + e[j] \/ (q + t);\r\n                }\r\n                double u = 0.0;\r\n                double s = 1.0;\r\n                double c = 1.0;\r\n                int i;\r\n                for (i = m - 1; i >= j; i--) {\r\n                    double p = s * e[i];\r\n                    double h = c * e[i];\r\n                    if (Math.abs(p) >= Math.abs(q)) {\r\n                        c = q \/ p;\r\n                        t = Math.sqrt(c * c + 1.0);\r\n                        e[i + 1] = p * t;\r\n                        s = 1.0 \/ t;\r\n                        c = c * s;\r\n                    } else {\r\n                        s = p \/ q;\r\n                        t = Math.sqrt(s * s + 1.0);\r\n                        e[i + 1] = q * t;\r\n                        c = 1.0 \/ t;\r\n                        s = s * c;\r\n                    }\r\n                    if (e[i + 1] == 0.0) {\r\n                        realEigenvalues[i + 1] -= u;\r\n                        e[m] = 0.0;\r\n                        break;\r\n                    }\r\n                    q = realEigenvalues[i + 1] - u;\r\n                    t = (realEigenvalues[i] - q) * s + 2.0 * c * h;\r\n                    u = s * t;\r\n                    realEigenvalues[i + 1] = q + u;\r\n                    q = c * t - h;\r\n                    for (int ia = 0; ia < n; ia++) {\r\n                        p = z[ia][i + 1];\r\n                        z[ia][i + 1] = s * z[ia][i] + c * p;\r\n                        z[ia][i] = c * z[ia][i] - s * p;\r\n                    }\r\n                }\r\n                if (e[i + 1] == 0.0 && i >= j)\r\n                    continue;\r\n                realEigenvalues[j] -= u;\r\n                e[j] = q;\r\n                e[m] = 0.0;\r\n            }\r\n        } while (m != j);\r\n    }\r\n        for (int i = 0; i < n; i++) {\r\n        int k = i;\r\n        double p = realEigenvalues[i];\r\n        for (int j = i + 1; j < n; j++) {\r\n            if (realEigenvalues[j] > p) {\r\n                k = j;\r\n                p = realEigenvalues[j];\r\n            }\r\n        }\r\n        if (k != i) {\r\n            realEigenvalues[k] = realEigenvalues[i];\r\n            realEigenvalues[i] = p;\r\n            for (int j = 0; j < n; j++) {\r\n                p = z[j][i];\r\n                z[j][i] = z[j][k];\r\n                z[j][k] = p;\r\n            }\r\n        }\r\n    }\r\n        maxAbsoluteValue = 0.0;\r\n    for (int i = 0; i < n; i++) {\r\n        if (Math.abs(realEigenvalues[i]) > maxAbsoluteValue) {\r\n            maxAbsoluteValue = Math.abs(realEigenvalues[i]);\r\n        }\r\n    }\r\n        if (maxAbsoluteValue != 0.0) {\r\n        for (int i = 0; i < n; i++) {\r\n            if (Math.abs(realEigenvalues[i]) < MathUtils.EPSILON * maxAbsoluteValue) {\r\n                realEigenvalues[i] = 0.0;\r\n            }\r\n        }\r\n    }\r\n    eigenvectors = new ArrayRealVector[n];\r\n    double[] tmp = new double[n];\r\n    for (int i = 0; i < n; i++) {\r\n        for (int j = 0; j < n; j++) {\r\n            tmp[j] = z[j][i];\r\n        }\r\n        eigenvectors[i] = new ArrayRealVector(tmp);\r\n    }\r\n}","lc":5.5909090909,"pi":1.8086124402,"ma":6.6,"nbd":1.5,"ml":3.75,"d":13.0496031746,"mi":-1.7106412967,"fo":1.0,"r":-0.0263157895,"e":112.9794782248}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3989_6a8fc1cc","label":1,"code":"\/**\r\n *  Will <b>replace<\/b> the respective component's method. However by returning null, the\r\n *  component's method will be called.\r\n *\r\n *  @see MarkupContainer#getMarkup(Component)\r\n *\r\n *  @param container\r\n *             The parent containing the child. (@TODO Is container ever != child.getParent()??)\r\n *  @param child\r\n *             The component to find the markup for.\r\n *  @return markup fragment\r\n *\/\r\nIMarkupFragment getMarkup(final MarkupContainer container, final Component child);","code_comment":"\/**\r\n *  Will <b>replace<\/b> the respective component's method. However by returning null, the\r\n *  component's method will be called.\r\n *\r\n *  @see MarkupContainer#getMarkup(Component)\r\n *\r\n *  @param container\r\n *             The parent containing the child. (@TODO Is container ever != child.getParent()??)\r\n *  @param child\r\n *             The component to find the markup for.\r\n *  @return markup fragment\r\n *\/\r\n","code_no_comment":"IMarkupFragment getMarkup(final MarkupContainer container, final Component child);","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.5344608879,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-554_3f51fb09","label":1,"code":"@Override\r\npublic String toString() {\r\n    return propertyState.getValue(Type.STRING, index);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String toString() {\r\n    return propertyState.getValue(Type.STRING, index);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8469344609,"fo":-0.4166666667,"r":0.8421052632,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2642_36fe017c","label":0,"code":"\/\/ ----------------------< background operations >---------------------------\r\npublic synchronized void runBackgroundOperations() {\r\n    if (isDisposed.get()) {\r\n        return;\r\n    }\r\n    if (simpleRevisionCounter != null) {\r\n        \/\/ only when using timestamp\r\n        return;\r\n    }\r\n    try {\r\n        long start = clock.getTime();\r\n        long time = start;\r\n        \/\/ clean orphaned branches and collisions\r\n        cleanOrphanedBranches();\r\n        cleanCollisions();\r\n        long cleanTime = clock.getTime() - time;\r\n        time = clock.getTime();\r\n        \/\/ split documents (does not create new revisions)\r\n        backgroundSplit();\r\n        long splitTime = clock.getTime() - time;\r\n        time = clock.getTime();\r\n        \/\/ write back pending updates to _lastRev\r\n        backgroundWrite();\r\n        long writeTime = clock.getTime() - time;\r\n        time = clock.getTime();\r\n        \/\/ pull in changes from other cluster nodes\r\n        BackgroundReadStats readStats = backgroundRead(true);\r\n        long readTime = clock.getTime() - time;\r\n        String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\r\n        if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {\r\n            \/\/ log as info if it took more than 10 seconds\r\n            LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\r\n        } else {\r\n            LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\r\n        }\r\n    } catch (RuntimeException e) {\r\n        if (isDisposed.get()) {\r\n            return;\r\n        }\r\n        throw e;\r\n    }\r\n}","code_comment":null,"code_no_comment":"public synchronized void runBackgroundOperations() {\r\n    if (isDisposed.get()) {\r\n        return;\r\n    }\r\n    if (simpleRevisionCounter != null) {\r\n                return;\r\n    }\r\n    try {\r\n        long start = clock.getTime();\r\n        long time = start;\r\n                cleanOrphanedBranches();\r\n        cleanCollisions();\r\n        long cleanTime = clock.getTime() - time;\r\n        time = clock.getTime();\r\n                backgroundSplit();\r\n        long splitTime = clock.getTime() - time;\r\n        time = clock.getTime();\r\n                backgroundWrite();\r\n        long writeTime = clock.getTime() - time;\r\n        time = clock.getTime();\r\n                BackgroundReadStats readStats = backgroundRead(true);\r\n        long readTime = clock.getTime() - time;\r\n        String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\r\n        if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {\r\n                        LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\r\n        } else {\r\n            LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\r\n        }\r\n    } catch (RuntimeException e) {\r\n        if (isDisposed.get()) {\r\n            return;\r\n        }\r\n        throw e;\r\n    }\r\n}","lc":0.9545454545,"pi":-0.1291866029,"ma":0.6,"nbd":0.0,"ml":0.3333333333,"d":0.5099206349,"mi":-0.5988724454,"fo":1.0833333333,"r":-0.0263157895,"e":0.829900359}
{"project_name":"Codec","project_version":"14","label":3,"code":"\/**\r\n * Applies the final rules to convert from a language-specific phonetic representation to a\r\n * language-independent representation.\r\n *\r\n * @param phonemeBuilder the current phonemes\r\n * @param finalRules the final rules to apply\r\n * @return the resulting phonemes\r\n *\/\r\nprivate PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder, final Map<String, List<Rule>> finalRules) {\r\n    if (finalRules == null) {\r\n        throw new NullPointerException(\"finalRules can not be null\");\r\n    }\r\n    if (finalRules.isEmpty()) {\r\n        return phonemeBuilder;\r\n    }\r\n    final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\r\n    for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\r\n        PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\r\n        final String phonemeText = phoneme.getPhonemeText().toString();\r\n        for (int i = 0; i < phonemeText.length(); ) {\r\n            final RulesApplication rulesApplication = new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();\r\n            final boolean found = rulesApplication.isFound();\r\n            subBuilder = rulesApplication.getPhonemeBuilder();\r\n            if (!found) {\r\n                \/\/ not found, appending as-is\r\n                subBuilder.append(phonemeText.subSequence(i, i + 1));\r\n            }\r\n            i = rulesApplication.getI();\r\n        }\r\n        \/\/ the phonemes map orders the phonemes only based on their text, but ignores the language set\r\n        \/\/ when adding new phonemes, check for equal phonemes and merge their language set, otherwise\r\n        \/\/ phonemes with the same text but different language set get lost\r\n        phonemes.addAll(subBuilder.getPhonemes());\r\n    }\r\n    return new PhonemeBuilder(phonemes);\r\n}","code_comment":"\/**\r\n * Applies the final rules to convert from a language-specific phonetic representation to a\r\n * language-independent representation.\r\n *\r\n * @param phonemeBuilder the current phonemes\r\n * @param finalRules the final rules to apply\r\n * @return the resulting phonemes\r\n *\/\r\n","code_no_comment":"private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder, final Map<String, List<Rule>> finalRules) {\r\n    if (finalRules == null) {\r\n        throw new NullPointerException(\"finalRules can not be null\");\r\n    }\r\n    if (finalRules.isEmpty()) {\r\n        return phonemeBuilder;\r\n    }\r\n    final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);\r\n    for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {\r\n        PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());\r\n        final String phonemeText = phoneme.getPhonemeText().toString();\r\n        for (int i = 0; i < phonemeText.length(); ) {\r\n            final RulesApplication rulesApplication = new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();\r\n            final boolean found = rulesApplication.isFound();\r\n            subBuilder = rulesApplication.getPhonemeBuilder();\r\n            if (!found) {\r\n                                subBuilder.append(phonemeText.subSequence(i, i + 1));\r\n            }\r\n            i = rulesApplication.getI();\r\n        }\r\n                                phonemes.addAll(subBuilder.getPhonemes());\r\n    }\r\n    return new PhonemeBuilder(phonemes);\r\n}","lc":0.4545454545,"pi":0.5358851675,"ma":0.6,"nbd":0.5,"ml":0.3333333333,"d":0.4087301587,"mi":-0.4322762509,"fo":0.75,"r":-0.0263157895,"e":0.7514784784}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4648_83389c34","label":1,"code":"public void validateEffectiveModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\r\n    validateStringNotEmpty(\"modelVersion\", problems, Severity.ERROR, model.getModelVersion());\r\n    validateId(\"groupId\", problems, model.getGroupId());\r\n    validateId(\"artifactId\", problems, model.getArtifactId());\r\n    validateStringNotEmpty(\"packaging\", problems, Severity.ERROR, model.getPackaging());\r\n    if (!model.getModules().isEmpty()) {\r\n        if (!\"pom\".equals(model.getPackaging())) {\r\n            addViolation(problems, Severity.ERROR, \"packaging\", null, \"with value '\" + model.getPackaging() + \"' is invalid. Aggregator projects \" + \"require 'pom' as packaging.\");\r\n        }\r\n        for (int i = 0, n = model.getModules().size(); i < n; i++) {\r\n            String module = model.getModules().get(i);\r\n            if (StringUtils.isBlank(module)) {\r\n                addViolation(problems, Severity.WARNING, \"modules.module[\" + i + \"]\", null, \"has been specified without a path to the project directory.\");\r\n            }\r\n        }\r\n    }\r\n    validateStringNotEmpty(\"version\", problems, Severity.ERROR, model.getVersion());\r\n    Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);\r\n    validateEffectiveDependencies(problems, model.getDependencies(), false, request);\r\n    DependencyManagement mgmt = model.getDependencyManagement();\r\n    if (mgmt != null) {\r\n        validateEffectiveDependencies(problems, mgmt.getDependencies(), true, request);\r\n    }\r\n    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\r\n        Set<String> modules = new HashSet<String>();\r\n        for (int i = 0, n = model.getModules().size(); i < n; i++) {\r\n            String module = model.getModules().get(i);\r\n            if (!modules.add(module)) {\r\n                addViolation(problems, Severity.ERROR, \"modules.module[\" + i + \"]\", null, \"specifies duplicate child module \" + module);\r\n            }\r\n        }\r\n        Severity errOn31 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1);\r\n        Build build = model.getBuild();\r\n        if (build != null) {\r\n            for (Plugin p : build.getPlugins()) {\r\n                validateStringNotEmpty(\"build.plugins.plugin.artifactId\", problems, Severity.ERROR, p.getArtifactId());\r\n                validateStringNotEmpty(\"build.plugins.plugin.groupId\", problems, Severity.ERROR, p.getGroupId());\r\n                validatePluginVersion(\"build.plugins.plugin.version\", problems, p.getVersion(), p.getKey(), request);\r\n                validateBoolean(\"build.plugins.plugin.inherited\", problems, errOn30, p.getInherited(), p.getKey());\r\n                validateBoolean(\"build.plugins.plugin.extensions\", problems, errOn30, p.getExtensions(), p.getKey());\r\n                for (Dependency d : p.getDependencies()) {\r\n                    validateEnum(\"build.plugins.plugin[\" + p.getKey() + \"].dependencies.dependency.scope\", problems, errOn30, d.getScope(), d.getManagementKey(), \"compile\", \"runtime\", \"system\");\r\n                }\r\n            }\r\n            validateResources(problems, build.getResources(), \"build.resources.resource\", request);\r\n            validateResources(problems, build.getTestResources(), \"build.testResources.testResource\", request);\r\n        }\r\n        Reporting reporting = model.getReporting();\r\n        if (reporting != null) {\r\n            for (ReportPlugin p : reporting.getPlugins()) {\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.artifactId\", problems, Severity.ERROR, p.getArtifactId());\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.groupId\", problems, Severity.ERROR, p.getGroupId());\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.version\", problems, errOn31, p.getVersion(), p.getKey());\r\n            }\r\n        }\r\n        for (Repository repository : model.getRepositories()) {\r\n            validateRepository(problems, repository, \"repositories.repository\", request);\r\n        }\r\n        for (Repository repository : model.getPluginRepositories()) {\r\n            validateRepository(problems, repository, \"pluginRepositories.pluginRepository\", request);\r\n        }\r\n        DistributionManagement distMgmt = model.getDistributionManagement();\r\n        if (distMgmt != null) {\r\n            if (distMgmt.getStatus() != null) {\r\n                addViolation(problems, Severity.ERROR, \"distributionManagement.status\", null, \"must not be specified.\");\r\n            }\r\n            validateRepository(problems, distMgmt.getRepository(), \"distributionManagement.repository\", request);\r\n            validateRepository(problems, distMgmt.getSnapshotRepository(), \"distributionManagement.snapshotRepository\", request);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void validateEffectiveModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\r\n    validateStringNotEmpty(\"modelVersion\", problems, Severity.ERROR, model.getModelVersion());\r\n    validateId(\"groupId\", problems, model.getGroupId());\r\n    validateId(\"artifactId\", problems, model.getArtifactId());\r\n    validateStringNotEmpty(\"packaging\", problems, Severity.ERROR, model.getPackaging());\r\n    if (!model.getModules().isEmpty()) {\r\n        if (!\"pom\".equals(model.getPackaging())) {\r\n            addViolation(problems, Severity.ERROR, \"packaging\", null, \"with value '\" + model.getPackaging() + \"' is invalid. Aggregator projects \" + \"require 'pom' as packaging.\");\r\n        }\r\n        for (int i = 0, n = model.getModules().size(); i < n; i++) {\r\n            String module = model.getModules().get(i);\r\n            if (StringUtils.isBlank(module)) {\r\n                addViolation(problems, Severity.WARNING, \"modules.module[\" + i + \"]\", null, \"has been specified without a path to the project directory.\");\r\n            }\r\n        }\r\n    }\r\n    validateStringNotEmpty(\"version\", problems, Severity.ERROR, model.getVersion());\r\n    Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);\r\n    validateEffectiveDependencies(problems, model.getDependencies(), false, request);\r\n    DependencyManagement mgmt = model.getDependencyManagement();\r\n    if (mgmt != null) {\r\n        validateEffectiveDependencies(problems, mgmt.getDependencies(), true, request);\r\n    }\r\n    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\r\n        Set<String> modules = new HashSet<String>();\r\n        for (int i = 0, n = model.getModules().size(); i < n; i++) {\r\n            String module = model.getModules().get(i);\r\n            if (!modules.add(module)) {\r\n                addViolation(problems, Severity.ERROR, \"modules.module[\" + i + \"]\", null, \"specifies duplicate child module \" + module);\r\n            }\r\n        }\r\n        Severity errOn31 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1);\r\n        Build build = model.getBuild();\r\n        if (build != null) {\r\n            for (Plugin p : build.getPlugins()) {\r\n                validateStringNotEmpty(\"build.plugins.plugin.artifactId\", problems, Severity.ERROR, p.getArtifactId());\r\n                validateStringNotEmpty(\"build.plugins.plugin.groupId\", problems, Severity.ERROR, p.getGroupId());\r\n                validatePluginVersion(\"build.plugins.plugin.version\", problems, p.getVersion(), p.getKey(), request);\r\n                validateBoolean(\"build.plugins.plugin.inherited\", problems, errOn30, p.getInherited(), p.getKey());\r\n                validateBoolean(\"build.plugins.plugin.extensions\", problems, errOn30, p.getExtensions(), p.getKey());\r\n                for (Dependency d : p.getDependencies()) {\r\n                    validateEnum(\"build.plugins.plugin[\" + p.getKey() + \"].dependencies.dependency.scope\", problems, errOn30, d.getScope(), d.getManagementKey(), \"compile\", \"runtime\", \"system\");\r\n                }\r\n            }\r\n            validateResources(problems, build.getResources(), \"build.resources.resource\", request);\r\n            validateResources(problems, build.getTestResources(), \"build.testResources.testResource\", request);\r\n        }\r\n        Reporting reporting = model.getReporting();\r\n        if (reporting != null) {\r\n            for (ReportPlugin p : reporting.getPlugins()) {\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.artifactId\", problems, Severity.ERROR, p.getArtifactId());\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.groupId\", problems, Severity.ERROR, p.getGroupId());\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.version\", problems, errOn31, p.getVersion(), p.getKey());\r\n            }\r\n        }\r\n        for (Repository repository : model.getRepositories()) {\r\n            validateRepository(problems, repository, \"repositories.repository\", request);\r\n        }\r\n        for (Repository repository : model.getPluginRepositories()) {\r\n            validateRepository(problems, repository, \"pluginRepositories.pluginRepository\", request);\r\n        }\r\n        DistributionManagement distMgmt = model.getDistributionManagement();\r\n        if (distMgmt != null) {\r\n            if (distMgmt.getStatus() != null) {\r\n                addViolation(problems, Severity.ERROR, \"distributionManagement.status\", null, \"must not be specified.\");\r\n            }\r\n            validateRepository(problems, distMgmt.getRepository(), \"distributionManagement.repository\", request);\r\n            validateRepository(problems, distMgmt.getSnapshotRepository(), \"distributionManagement.snapshotRepository\", request);\r\n        }\r\n    }\r\n}","lc":2.5909090909,"pi":0.7177033493,"ma":2.8,"nbd":1.0,"ml":1.75,"d":1.1845238095,"mi":-1.2238195913,"fo":6.1666666667,"r":-0.0263157895,"e":8.3094298738}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-537_a8493efc","label":3,"code":"\/**\r\n * Checks whether the named property is indexed somewhere along the given\r\n * path. Lookup starts at the current path (at the root of this object) and\r\n * traverses down the path.\r\n *\r\n * @param name property name\r\n * @param path lookup path\r\n * @return true if the property is indexed\r\n *\/\r\npublic boolean isIndexed(String name, String path) {\r\n    if (getIndexDefinitionNode(name) != null) {\r\n        return true;\r\n    }\r\n    \/\/ TODO use PathUtils\r\n    if (path.startsWith(\"\/\")) {\r\n        path = path.substring(1);\r\n    }\r\n    int slash = path.indexOf('\/');\r\n    if (slash == -1) {\r\n        return false;\r\n    }\r\n    NodeState child = root.getChildNode(path.substring(0, slash));\r\n    return new Property2IndexLookup(child).isIndexed(name, path.substring(slash));\r\n}","code_comment":"\/**\r\n * Checks whether the named property is indexed somewhere along the given\r\n * path. Lookup starts at the current path (at the root of this object) and\r\n * traverses down the path.\r\n *\r\n * @param name property name\r\n * @param path lookup path\r\n * @return true if the property is indexed\r\n *\/\r\n","code_no_comment":"public boolean isIndexed(String name, String path) {\r\n    if (getIndexDefinitionNode(name) != null) {\r\n        return true;\r\n    }\r\n        if (path.startsWith(\"\/\")) {\r\n        path = path.substring(1);\r\n    }\r\n    int slash = path.indexOf('\/');\r\n    if (slash == -1) {\r\n        return false;\r\n    }\r\n    NodeState child = root.getChildNode(path.substring(0, slash));\r\n    return new Property2IndexLookup(child).isIndexed(name, path.substring(slash));\r\n}","lc":0.0,"pi":-0.2966507177,"ma":0.0,"nbd":-0.5,"ml":0.1666666667,"d":0.371031746,"mi":-0.0365045807,"fo":0.1666666667,"r":0.0263157895,"e":0.1950565631}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3019_5135cf4b","label":1,"code":"@Override\r\npublic boolean childNodeChanged(String name, NodeState before, NodeState after) {\r\n    Node node = new Node(nodeAfter, name);\r\n    return after.compareAgainstBaseState(before, new Diff(versionManager, node, exceptions));\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean childNodeChanged(String name, NodeState before, NodeState after) {\r\n    Node node = new Node(nodeAfter, name);\r\n    return after.compareAgainstBaseState(before, new Diff(versionManager, node, exceptions));\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5797040169,"fo":-0.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Cli","project_version":"8","label":1,"code":"\/**\r\n * <p>Render the specified text and return the rendered Options\r\n * in a StringBuffer.<\/p>\r\n *\r\n * @param sb The StringBuffer to place the rendered text into.\r\n * @param width The number of characters to display per line\r\n * @param nextLineTabStop The position on the next line for the first tab.\r\n * @param text The text to be rendered.\r\n *\r\n * @return the StringBuffer with the rendered Options contents.\r\n *\/\r\nprotected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\r\n    int pos = findWrapPos(text, width, 0);\r\n    if (pos == -1) {\r\n        sb.append(rtrim(text));\r\n        return sb;\r\n    }\r\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\r\n    \/\/ all following lines must be padded with nextLineTabStop space\r\n    \/\/ characters\r\n    final String padding = createPadding(nextLineTabStop);\r\n    while (true) {\r\n        text = padding + text.substring(pos).trim();\r\n        pos = findWrapPos(text, width, nextLineTabStop);\r\n        if (pos == -1) {\r\n            sb.append(text);\r\n            return sb;\r\n        }\r\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\r\n    }\r\n}","code_comment":"\/**\r\n * <p>Render the specified text and return the rendered Options\r\n * in a StringBuffer.<\/p>\r\n *\r\n * @param sb The StringBuffer to place the rendered text into.\r\n * @param width The number of characters to display per line\r\n * @param nextLineTabStop The position on the next line for the first tab.\r\n * @param text The text to be rendered.\r\n *\r\n * @return the StringBuffer with the rendered Options contents.\r\n *\/\r\n","code_no_comment":"protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\r\n    int pos = findWrapPos(text, width, 0);\r\n    if (pos == -1) {\r\n        sb.append(rtrim(text));\r\n        return sb;\r\n    }\r\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\r\n            final String padding = createPadding(nextLineTabStop);\r\n    while (true) {\r\n        text = padding + text.substring(pos).trim();\r\n        pos = findWrapPos(text, width, nextLineTabStop);\r\n        if (pos == -1) {\r\n            sb.append(text);\r\n            return sb;\r\n        }\r\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\r\n    }\r\n}","lc":0.1818181818,"pi":0.1626794258,"ma":0.0,"nbd":0.0,"ml":-0.0833333333,"d":0.8452380952,"mi":-0.2140944327,"fo":0.8333333333,"r":-0.0263157895,"e":0.7398097082}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3123_f3c9c818","label":1,"code":"\/**\r\n * Check whether {@code key} is present is this map.\r\n * @param key  the key to check for\r\n * @return  {@code true} iff {@code key} is present.\r\n *\/\r\npublic boolean containsKey(short key) {\r\n    return keys != null && binarySearch(keys, key) >= 0;\r\n}","code_comment":"\/**\r\n * Check whether {@code key} is present is this map.\r\n * @param key  the key to check for\r\n * @return  {@code true} iff {@code key} is present.\r\n *\/\r\n","code_no_comment":"public boolean containsKey(short key) {\r\n    return keys != null && binarySearch(keys, key) >= 0;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.1091269841,"mi":0.9292459479,"fo":-0.4166666667,"r":2.4473684211,"e":-0.1391654132}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"@Override\r\npublic Tree addChild(String name) {\r\n    root.checkLive();\r\n    if (!hasChild(name)) {\r\n        getNodeBuilder().child(name);\r\n        if (hasOrderableChildren()) {\r\n            getNodeBuilder().setProperty(MemoryPropertyBuilder.copy(Type.STRING, internalGetProperty(OAK_CHILD_ORDER)).addValue(name).getPropertyState());\r\n        }\r\n        root.updated();\r\n    }\r\n    TreeImpl child = getChild(name);\r\n    assert child != null;\r\n    return child;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Tree addChild(String name) {\r\n    root.checkLive();\r\n    if (!hasChild(name)) {\r\n        getNodeBuilder().child(name);\r\n        if (hasOrderableChildren()) {\r\n            getNodeBuilder().setProperty(MemoryPropertyBuilder.copy(Type.STRING, internalGetProperty(OAK_CHILD_ORDER)).addValue(name).getPropertyState());\r\n        }\r\n        root.updated();\r\n    }\r\n    TreeImpl child = getChild(name);\r\n    assert child != null;\r\n    return child;\r\n}","lc":0.0,"pi":0.2153110048,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":-0.3650793651,"mi":0.3510923185,"fo":0.5833333333,"r":0.0789473684,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4715_4fc82e35","label":1,"code":"\/**\r\n *  Pre- and post- configures the {@link WebRequest} created by user override-able\r\n *  {@link #newWebRequest(HttpServletRequest, String)}\r\n *\r\n *  @param servletRequest\r\n *             the current HTTP Sservlet request\r\n *  @param filterPath\r\n *             the filter mapping read from web.xml\r\n *  @return a WebRequest object\r\n *\/\r\nWebRequest createWebRequest(HttpServletRequest servletRequest, final String filterPath) {\r\n    if (servletRequest.getCharacterEncoding() == null) {\r\n        try {\r\n            String wicketAjaxHeader = servletRequest.getHeader(WebRequest.HEADER_AJAX);\r\n            if (Strings.isTrue(wicketAjaxHeader)) {\r\n                \/\/ WICKET-3908, WICKET-1816: Forms submitted with Ajax are always UTF-8 encoded\r\n                servletRequest.setCharacterEncoding(CharEncoding.UTF_8);\r\n            } else {\r\n                String requestEncoding = getRequestCycleSettings().getResponseRequestEncoding();\r\n                servletRequest.setCharacterEncoding(requestEncoding);\r\n            }\r\n        } catch (UnsupportedEncodingException e) {\r\n            throw new WicketRuntimeException(e);\r\n        }\r\n    }\r\n    if (hasFilterFactoryManager()) {\r\n        for (AbstractRequestWrapperFactory factory : getFilterFactoryManager()) {\r\n            servletRequest = factory.getWrapper(servletRequest);\r\n        }\r\n    }\r\n    WebRequest webRequest = newWebRequest(servletRequest, filterPath);\r\n    return webRequest;\r\n}","code_comment":"\/**\r\n *  Pre- and post- configures the {@link WebRequest} created by user override-able\r\n *  {@link #newWebRequest(HttpServletRequest, String)}\r\n *\r\n *  @param servletRequest\r\n *             the current HTTP Sservlet request\r\n *  @param filterPath\r\n *             the filter mapping read from web.xml\r\n *  @return a WebRequest object\r\n *\/\r\n","code_no_comment":"WebRequest createWebRequest(HttpServletRequest servletRequest, final String filterPath) {\r\n    if (servletRequest.getCharacterEncoding() == null) {\r\n        try {\r\n            String wicketAjaxHeader = servletRequest.getHeader(WebRequest.HEADER_AJAX);\r\n            if (Strings.isTrue(wicketAjaxHeader)) {\r\n                                servletRequest.setCharacterEncoding(CharEncoding.UTF_8);\r\n            } else {\r\n                String requestEncoding = getRequestCycleSettings().getResponseRequestEncoding();\r\n                servletRequest.setCharacterEncoding(requestEncoding);\r\n            }\r\n        } catch (UnsupportedEncodingException e) {\r\n            throw new WicketRuntimeException(e);\r\n        }\r\n    }\r\n    if (hasFilterFactoryManager()) {\r\n        for (AbstractRequestWrapperFactory factory : getFilterFactoryManager()) {\r\n            servletRequest = factory.getWrapper(servletRequest);\r\n        }\r\n    }\r\n    WebRequest webRequest = newWebRequest(servletRequest, filterPath);\r\n    return webRequest;\r\n}","lc":0.3636363636,"pi":0.8708133971,"ma":0.6,"nbd":0.5,"ml":0.1666666667,"d":-0.0476190476,"mi":-0.2972515856,"fo":0.4166666667,"r":-0.0263157895,"e":0.0326850043}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1075_79467350","label":1,"code":"public void restrictProperty(String propertyName, Operator op, PropertyValue v) {\r\n    PropertyRestriction x = addRestricition(propertyName);\r\n    PropertyValue oldFirst = x.first;\r\n    PropertyValue oldLast = x.last;\r\n    switch(op) {\r\n        case EQUAL:\r\n            if (x.first != null && x.last == x.first && x.firstIncluding && x.lastIncluding) {\r\n                \/\/ if x is a multi-valued property with value \"{1, 2}\")\r\n                return;\r\n            }\r\n            x.first = maxValue(oldFirst, v);\r\n            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\r\n            x.last = minValue(oldLast, v);\r\n            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\r\n            break;\r\n        case NOT_EQUAL:\r\n            if (v != null) {\r\n                throw new IllegalArgumentException(\"NOT_EQUAL only supported for NOT_EQUAL NULL\");\r\n            }\r\n            break;\r\n        case GREATER_THAN:\r\n            x.first = maxValue(oldFirst, v);\r\n            x.firstIncluding = false;\r\n            break;\r\n        case GREATER_OR_EQUAL:\r\n            x.first = maxValue(oldFirst, v);\r\n            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\r\n            break;\r\n        case LESS_THAN:\r\n            x.last = minValue(oldLast, v);\r\n            x.lastIncluding = false;\r\n            break;\r\n        case LESS_OR_EQUAL:\r\n            x.last = minValue(oldLast, v);\r\n            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\r\n            break;\r\n        case LIKE:\r\n            \/\/ LIKE is handled in the fulltext index\r\n            x.isLike = true;\r\n            x.first = v;\r\n            break;\r\n        case IN:\r\n    }\r\n    if (x.first != null && x.last != null) {\r\n        if (x.first.compareTo(x.last) > 0) {\r\n            setAlwaysFalse();\r\n        } else if (x.first.compareTo(x.last) == 0 && (!x.firstIncluding || !x.lastIncluding)) {\r\n            setAlwaysFalse();\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void restrictProperty(String propertyName, Operator op, PropertyValue v) {\r\n    PropertyRestriction x = addRestricition(propertyName);\r\n    PropertyValue oldFirst = x.first;\r\n    PropertyValue oldLast = x.last;\r\n    switch(op) {\r\n        case EQUAL:\r\n            if (x.first != null && x.last == x.first && x.firstIncluding && x.lastIncluding) {\r\n                                return;\r\n            }\r\n            x.first = maxValue(oldFirst, v);\r\n            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\r\n            x.last = minValue(oldLast, v);\r\n            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\r\n            break;\r\n        case NOT_EQUAL:\r\n            if (v != null) {\r\n                throw new IllegalArgumentException(\"NOT_EQUAL only supported for NOT_EQUAL NULL\");\r\n            }\r\n            break;\r\n        case GREATER_THAN:\r\n            x.first = maxValue(oldFirst, v);\r\n            x.firstIncluding = false;\r\n            break;\r\n        case GREATER_OR_EQUAL:\r\n            x.first = maxValue(oldFirst, v);\r\n            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\r\n            break;\r\n        case LESS_THAN:\r\n            x.last = minValue(oldLast, v);\r\n            x.lastIncluding = false;\r\n            break;\r\n        case LESS_OR_EQUAL:\r\n            x.last = minValue(oldLast, v);\r\n            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\r\n            break;\r\n        case LIKE:\r\n                        x.isLike = true;\r\n            x.first = v;\r\n            break;\r\n        case IN:\r\n    }\r\n    if (x.first != null && x.last != null) {\r\n        if (x.first.compareTo(x.last) > 0) {\r\n            setAlwaysFalse();\r\n        } else if (x.first.compareTo(x.last) == 0 && (!x.firstIncluding || !x.lastIncluding)) {\r\n            setAlwaysFalse();\r\n        }\r\n    }\r\n}","lc":1.5909090909,"pi":0.3397129187,"ma":4.4,"nbd":0.5,"ml":2.25,"d":1.9821428571,"mi":-0.9757575758,"fo":0.4166666667,"r":-0.0263157895,"e":5.1066037355}
{"project_name":"Math","project_version":"18","label":1,"code":"\/**\r\n * @param x Normalized objective variables.\r\n * @return the original objective variables.\r\n *\/\r\npublic double[] decode(final double[] x) {\r\n    if (boundaries == null) {\r\n        return x;\r\n    }\r\n    double[] res = new double[x.length];\r\n    for (int i = 0; i < x.length; i++) {\r\n        double diff = boundaries[1][i] - boundaries[0][i];\r\n        res[i] = diff * x[i] + boundaries[0][i];\r\n    }\r\n    return res;\r\n}","code_comment":"\/**\r\n * @param x Normalized objective variables.\r\n * @return the original objective variables.\r\n *\/\r\n","code_no_comment":"public double[] decode(final double[] x) {\r\n    if (boundaries == null) {\r\n        return x;\r\n    }\r\n    double[] res = new double[x.length];\r\n    for (int i = 0; i < x.length; i++) {\r\n        double diff = boundaries[1][i] - boundaries[0][i];\r\n        res[i] = diff * x[i] + boundaries[0][i];\r\n    }\r\n    return res;\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":1.3115079365,"mi":0.1095137421,"fo":-0.5,"r":1.8684210526,"e":0.5036081672}
{"project_name":"Lang","project_version":"35","label":1,"code":"\/**\r\n * <p>Inserts the specified element at the specified position in the array.\r\n * Shifts the element currently at that position (if any) and any subsequent\r\n * elements to the right (adds one to their indices).<\/p>\r\n *\r\n * <p>This method returns a new array with the same elements of the input\r\n * array plus the given element on the specified position. The component\r\n * type of the returned array is always the same as that of the input\r\n * array.<\/p>\r\n *\r\n * <p>If the input array is <code>null<\/code>, a new one element array is returned\r\n *  whose component type is the same as the element.<\/p>\r\n *\r\n * <pre>\r\n * ArrayUtils.add(null, 0, null)      = [null]\r\n * ArrayUtils.add(null, 0, \"a\")       = [\"a\"]\r\n * ArrayUtils.add([\"a\"], 1, null)     = [\"a\", null]\r\n * ArrayUtils.add([\"a\"], 1, \"b\")      = [\"a\", \"b\"]\r\n * ArrayUtils.add([\"a\", \"b\"], 3, \"c\") = [\"a\", \"b\", \"c\"]\r\n * <\/pre>\r\n *\r\n * @param array  the array to add the element to, may be <code>null<\/code>\r\n * @param index  the position of the new object\r\n * @param element  the object to add\r\n * @return A new array containing the existing elements and the new element\r\n * @throws IndexOutOfBoundsException if the index is out of range\r\n * (index < 0 || index > array.length).\r\n * @throws IllegalArgumentException if both array and element are null\r\n *\/\r\npublic static <T> T[] add(T[] array, int index, T element) {\r\n    Class<?> clss = null;\r\n    if (array != null) {\r\n        clss = array.getClass().getComponentType();\r\n    } else if (element != null) {\r\n        clss = element.getClass();\r\n    } else {\r\n        return (T[]) new Object[] { null };\r\n    }\r\n    \/\/ the add method creates an array of type clss, which is type T\r\n    @SuppressWarnings(\"unchecked\")\r\n    final T[] newArray = (T[]) add(array, index, element, clss);\r\n    return newArray;\r\n}","code_comment":"\/**\r\n * <p>Inserts the specified element at the specified position in the array.\r\n * Shifts the element currently at that position (if any) and any subsequent\r\n * elements to the right (adds one to their indices).<\/p>\r\n *\r\n * <p>This method returns a new array with the same elements of the input\r\n * array plus the given element on the specified position. The component\r\n * type of the returned array is always the same as that of the input\r\n * array.<\/p>\r\n *\r\n * <p>If the input array is <code>null<\/code>, a new one element array is returned\r\n *  whose component type is the same as the element.<\/p>\r\n *\r\n * <pre>\r\n * ArrayUtils.add(null, 0, null)      = [null]\r\n * ArrayUtils.add(null, 0, \"a\")       = [\"a\"]\r\n * ArrayUtils.add([\"a\"], 1, null)     = [\"a\", null]\r\n * ArrayUtils.add([\"a\"], 1, \"b\")      = [\"a\", \"b\"]\r\n * ArrayUtils.add([\"a\", \"b\"], 3, \"c\") = [\"a\", \"b\", \"c\"]\r\n * <\/pre>\r\n *\r\n * @param array  the array to add the element to, may be <code>null<\/code>\r\n * @param index  the position of the new object\r\n * @param element  the object to add\r\n * @return A new array containing the existing elements and the new element\r\n * @throws IndexOutOfBoundsException if the index is out of range\r\n * (index < 0 || index > array.length).\r\n * @throws IllegalArgumentException if both array and element are null\r\n *\/\r\n","code_no_comment":"public static <T> T[] add(T[] array, int index, T element) {\r\n    Class<?> clss = null;\r\n    if (array != null) {\r\n        clss = array.getClass().getComponentType();\r\n    } else if (element != null) {\r\n        clss = element.getClass();\r\n    } else {\r\n        return (T[]) new Object[] { null };\r\n    }\r\n        @SuppressWarnings(\"unchecked\")\r\n    final T[] newArray = (T[]) add(array, index, element, clss);\r\n    return newArray;\r\n}","lc":-0.0454545455,"pi":-0.2535885167,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":0.125,"mi":0.0291754757,"fo":-0.1666666667,"r":-0.0263157895,"e":0.0370832685}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-412_5594b2e0","label":1,"code":"@Override\r\npublic Repo<Master> call(final long tid, Master master) throws Exception {\r\n    FileSystem fs = TraceFileSystem.wrap(org.apache.accumulo.core.file.FileUtil.getFileSystem(CachedConfiguration.getInstance(), ServerConfiguration.getSiteConfiguration()));\r\n    List<FileStatus> files = new ArrayList<FileStatus>();\r\n    for (FileStatus entry : fs.listStatus(new Path(bulk))) {\r\n        files.add(entry);\r\n    }\r\n    log.debug(\"tid \" + tid + \" importing \" + files.size() + \" files\");\r\n    Path writable = new Path(this.errorDir, \".iswritable\");\r\n    if (!fs.createNewFile(writable)) {\r\n        \/\/ Maybe this is a re-try... clear the flag and try again\r\n        fs.delete(writable, false);\r\n        if (!fs.createNewFile(writable))\r\n            throw new ThriftTableOperationException(tableId, null, TableOperation.BULK_IMPORT, TableOperationExceptionType.BULK_BAD_ERROR_DIRECTORY, \"Unable to write to \" + this.errorDir);\r\n    }\r\n    fs.delete(writable, false);\r\n    \/\/ group files into N-sized chunks, send the chunks to random servers\r\n    final int SERVERS_TO_USE = Math.min(ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_SERVERS), master.onlineTabletServers().size());\r\n    log.debug(\"tid \" + tid + \" using \" + SERVERS_TO_USE + \" servers\");\r\n    \/\/ wait for success, repeat failures R times\r\n    final List<String> filesToLoad = Collections.synchronizedList(new ArrayList<String>());\r\n    for (FileStatus f : files) filesToLoad.add(f.getPath().toString());\r\n    final int RETRIES = Math.max(1, ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_RETRIES));\r\n    for (int i = 0; i < RETRIES && filesToLoad.size() > 0; i++) {\r\n        List<Future<?>> results = new ArrayList<Future<?>>();\r\n        for (List<String> chunk : groupFiles(filesToLoad, SERVERS_TO_USE)) {\r\n            final List<String> attempt = chunk;\r\n            results.add(threadPool.submit(new LoggingRunnable(log, new Runnable() {\r\n\r\n                @Override\r\n                public void run() {\r\n                    ClientService.Iface client = null;\r\n                    try {\r\n                        client = ServerClient.getConnection(HdfsZooInstance.getInstance());\r\n                        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\r\n                        attempt.removeAll(fail);\r\n                        filesToLoad.removeAll(attempt);\r\n                    } catch (Exception ex) {\r\n                        log.error(ex, ex);\r\n                    } finally {\r\n                        ServerClient.close(client);\r\n                    }\r\n                }\r\n            })));\r\n        }\r\n        for (Future<?> f : results) f.get();\r\n        if (filesToLoad.size() > 0) {\r\n            log.debug(\"tid \" + tid + \" attempt \" + (i + 1) + \" \" + filesToLoad + \" failed\");\r\n            UtilWaitThread.sleep(100);\r\n        }\r\n    }\r\n    \/\/ Copy\/Create failed file markers\r\n    for (String f : filesToLoad) {\r\n        Path orig = new Path(f);\r\n        Path dest = new Path(errorDir, orig.getName());\r\n        try {\r\n            FileUtil.copy(fs, orig, fs, dest, false, true, CachedConfiguration.getInstance());\r\n            log.debug(\"tid \" + tid + \" copied \" + orig + \" to \" + dest + \": failed\");\r\n        } catch (IOException ex) {\r\n            try {\r\n                fs.create(dest).close();\r\n                log.debug(\"tid \" + tid + \" marked \" + dest + \" failed\");\r\n            } catch (IOException e) {\r\n                log.error(\"Unable to create failure flag file \" + dest, e);\r\n            }\r\n        }\r\n    }\r\n    \/\/ return the next step, which will perform cleanup\r\n    return new CompleteBulkImport(tableId, source, bulk, errorDir);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Repo<Master> call(final long tid, Master master) throws Exception {\r\n    FileSystem fs = TraceFileSystem.wrap(org.apache.accumulo.core.file.FileUtil.getFileSystem(CachedConfiguration.getInstance(), ServerConfiguration.getSiteConfiguration()));\r\n    List<FileStatus> files = new ArrayList<FileStatus>();\r\n    for (FileStatus entry : fs.listStatus(new Path(bulk))) {\r\n        files.add(entry);\r\n    }\r\n    log.debug(\"tid \" + tid + \" importing \" + files.size() + \" files\");\r\n    Path writable = new Path(this.errorDir, \".iswritable\");\r\n    if (!fs.createNewFile(writable)) {\r\n                fs.delete(writable, false);\r\n        if (!fs.createNewFile(writable))\r\n            throw new ThriftTableOperationException(tableId, null, TableOperation.BULK_IMPORT, TableOperationExceptionType.BULK_BAD_ERROR_DIRECTORY, \"Unable to write to \" + this.errorDir);\r\n    }\r\n    fs.delete(writable, false);\r\n        final int SERVERS_TO_USE = Math.min(ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_SERVERS), master.onlineTabletServers().size());\r\n    log.debug(\"tid \" + tid + \" using \" + SERVERS_TO_USE + \" servers\");\r\n        final List<String> filesToLoad = Collections.synchronizedList(new ArrayList<String>());\r\n    for (FileStatus f : files) filesToLoad.add(f.getPath().toString());\r\n    final int RETRIES = Math.max(1, ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_RETRIES));\r\n    for (int i = 0; i < RETRIES && filesToLoad.size() > 0; i++) {\r\n        List<Future<?>> results = new ArrayList<Future<?>>();\r\n        for (List<String> chunk : groupFiles(filesToLoad, SERVERS_TO_USE)) {\r\n            final List<String> attempt = chunk;\r\n            results.add(threadPool.submit(new LoggingRunnable(log, new Runnable() {\r\n\r\n                @Override\r\n                public void run() {\r\n                    ClientService.Iface client = null;\r\n                    try {\r\n                        client = ServerClient.getConnection(HdfsZooInstance.getInstance());\r\n                        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\r\n                        attempt.removeAll(fail);\r\n                        filesToLoad.removeAll(attempt);\r\n                    } catch (Exception ex) {\r\n                        log.error(ex, ex);\r\n                    } finally {\r\n                        ServerClient.close(client);\r\n                    }\r\n                }\r\n            })));\r\n        }\r\n        for (Future<?> f : results) f.get();\r\n        if (filesToLoad.size() > 0) {\r\n            log.debug(\"tid \" + tid + \" attempt \" + (i + 1) + \" \" + filesToLoad + \" failed\");\r\n            UtilWaitThread.sleep(100);\r\n        }\r\n    }\r\n        for (String f : filesToLoad) {\r\n        Path orig = new Path(f);\r\n        Path dest = new Path(errorDir, orig.getName());\r\n        try {\r\n            FileUtil.copy(fs, orig, fs, dest, false, true, CachedConfiguration.getInstance());\r\n            log.debug(\"tid \" + tid + \" copied \" + orig + \" to \" + dest + \": failed\");\r\n        } catch (IOException ex) {\r\n            try {\r\n                fs.create(dest).close();\r\n                log.debug(\"tid \" + tid + \" marked \" + dest + \" failed\");\r\n            } catch (IOException e) {\r\n                log.error(\"Unable to create failure flag file \" + dest, e);\r\n            }\r\n        }\r\n    }\r\n        return new CompleteBulkImport(tableId, source, bulk, errorDir);\r\n}","lc":2.2727272727,"pi":1.8277511962,"ma":2.0,"nbd":1.0,"ml":0.3333333333,"d":0.9186507937,"mi":-1.1299506695,"fo":3.5833333333,"r":-0.0263157895,"e":5.9413841393}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3989_6a8fc1cc","label":1,"code":"\/**\r\n *  Get the markup for the child component, which is assumed to be a child of 'container'.\r\n *\/\r\npublic IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {\r\n    \/\/ If the sourcing strategy did not provide one, than ask the component.\r\n    \/\/ Get the markup for the container\r\n    IMarkupFragment markup = container.getMarkup();\r\n    if (markup == null) {\r\n        return null;\r\n    }\r\n    if (child == null) {\r\n        return markup;\r\n    }\r\n    \/\/ Find the child's markup\r\n    markup = markup.find(child.getId());\r\n    if (markup != null) {\r\n        return markup;\r\n    }\r\n    \/\/ \"synchronous\" search possible.\r\n    for (Component ch : container) {\r\n        if ((ch != child) && (ch instanceof MarkupContainer) && (ch instanceof IComponentResolver)) {\r\n            markup = ((MarkupContainer) ch).getMarkup(child);\r\n            if (markup != null) {\r\n                return markup;\r\n            }\r\n        }\r\n    }\r\n    \/\/ This is to make migration for Items from 1.4 to 1.5 more easy\r\n    if (Character.isDigit(child.getId().charAt(0))) {\r\n        String id = child.getId();\r\n        boolean miss = false;\r\n        for (int i = 1; i < id.length(); i++) {\r\n            if (Character.isDigit(id.charAt(i)) == false) {\r\n                miss = true;\r\n                break;\r\n            }\r\n        }\r\n        if (miss == false) {\r\n            \/\/ The LoopItems markup is equal to the Loops markup\r\n            markup = container.getMarkup();\r\n            if (!(child instanceof AbstractItem) && log.isWarnEnabled()) {\r\n                log.warn(\"1.4 to 1.5 migration issue: the childs wicket-id contains decimals only. \" + \"By convention that \" + \"is only the case for children (Items) of Loop, ListView, \" + \"Tree etc.. To avoid the warning, the childs container should implement:\\n\" + \"@Override public IMarkupFragment getMarkup(Component child) {\\n\" + \"\/\/ The childs markup is always equal to the parents markup.\\n\" + \"return getMarkup(); }\\n\" + \"Child: \" + child.toString() + \"\\nContainer: \" + container.toString());\r\n            }\r\n        }\r\n    }\r\n    return markup;\r\n}","code_comment":"\/**\r\n *  Get the markup for the child component, which is assumed to be a child of 'container'.\r\n *\/\r\n","code_no_comment":"public IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {\r\n            IMarkupFragment markup = container.getMarkup();\r\n    if (markup == null) {\r\n        return null;\r\n    }\r\n    if (child == null) {\r\n        return markup;\r\n    }\r\n        markup = markup.find(child.getId());\r\n    if (markup != null) {\r\n        return markup;\r\n    }\r\n        for (Component ch : container) {\r\n        if ((ch != child) && (ch instanceof MarkupContainer) && (ch instanceof IComponentResolver)) {\r\n            markup = ((MarkupContainer) ch).getMarkup(child);\r\n            if (markup != null) {\r\n                return markup;\r\n            }\r\n        }\r\n    }\r\n        if (Character.isDigit(child.getId().charAt(0))) {\r\n        String id = child.getId();\r\n        boolean miss = false;\r\n        for (int i = 1; i < id.length(); i++) {\r\n            if (Character.isDigit(id.charAt(i)) == false) {\r\n                miss = true;\r\n                break;\r\n            }\r\n        }\r\n        if (miss == false) {\r\n                        markup = container.getMarkup();\r\n            if (!(child instanceof AbstractItem) && log.isWarnEnabled()) {\r\n                log.warn(\"1.4 to 1.5 migration issue: the childs wicket-id contains decimals only. \" + \"By convention that \" + \"is only the case for children (Items) of Loop, ListView, \" + \"Tree etc.. To avoid the warning, the childs container should implement:\\n\" + \"@Override public IMarkupFragment getMarkup(Component child) {\\n\" + \"\/\/ The childs markup is always equal to the parents markup.\\n\" + \"return getMarkup(); }\\n\" + \"Child: \" + child.toString() + \"\\nContainer: \" + container.toString());\r\n            }\r\n        }\r\n    }\r\n    return markup;\r\n}","lc":1.0909090909,"pi":0.6507177033,"ma":1.8,"nbd":0.5,"ml":1.5833333333,"d":1.5277777778,"mi":-0.7147286822,"fo":0.8333333333,"r":-0.0263157895,"e":2.646268218}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4397_e33516d5","label":0,"code":"\/**\r\n * Recursively sync the memberships of an authorizable up-to the specified depth. If the given depth\r\n * is equal or less than 0, no syncing is performed.\r\n *\r\n * @param external the external identity\r\n * @param auth the authorizable\r\n * @param depth recursion depth.\r\n * @throws RepositoryException\r\n *\/\r\nprotected void syncMembership(@Nonnull ExternalIdentity external, @Nonnull Authorizable auth, long depth) throws RepositoryException {\r\n    if (depth <= 0) {\r\n        return;\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Syncing membership '{}' -> '{}'\", external.getExternalId().getString(), auth.getID());\r\n    }\r\n    final DebugTimer timer = new DebugTimer();\r\n    Iterable<ExternalIdentityRef> externalGroups;\r\n    try {\r\n        externalGroups = external.getDeclaredGroups();\r\n    } catch (ExternalIdentityException e) {\r\n        log.error(\"Error while retrieving external declared groups for '{}'\", external.getId(), e);\r\n        return;\r\n    }\r\n    timer.mark(\"fetching\");\r\n    \/\/ first get the set of the existing groups that are synced ones\r\n    Map<String, Group> declaredExternalGroups = new HashMap<String, Group>();\r\n    Iterator<Group> grpIter = auth.declaredMemberOf();\r\n    while (grpIter.hasNext()) {\r\n        Group grp = grpIter.next();\r\n        if (isSameIDP(grp)) {\r\n            declaredExternalGroups.put(grp.getID(), grp);\r\n        }\r\n    }\r\n    timer.mark(\"reading\");\r\n    for (ExternalIdentityRef ref : externalGroups) {\r\n        log.debug(\"- processing membership {}\", ref.getId());\r\n        \/\/ get group\r\n        ExternalGroup extGroup;\r\n        try {\r\n            ExternalIdentity extId = idp.getIdentity(ref);\r\n            if (extId instanceof ExternalGroup) {\r\n                extGroup = (ExternalGroup) extId;\r\n            } else {\r\n                log.warn(\"No external group found for ref '{}'.\", ref.getString());\r\n                continue;\r\n            }\r\n        } catch (ExternalIdentityException e) {\r\n            log.warn(\"Unable to retrieve external group '{}' from provider.\", ref.getString(), e);\r\n            continue;\r\n        }\r\n        log.debug(\"- idp returned '{}'\", extGroup.getId());\r\n        Group grp;\r\n        Authorizable a = userManager.getAuthorizable(extGroup.getId());\r\n        if (a == null) {\r\n            grp = createGroup(extGroup);\r\n            log.debug(\"- created new group\");\r\n        } else if (a.isGroup()) {\r\n            grp = (Group) a;\r\n        } else {\r\n            log.warn(\"Authorizable '{}' is not a group, but should be one.\", extGroup.getId());\r\n            continue;\r\n        }\r\n        log.debug(\"- user manager returned '{}'\", grp);\r\n        syncGroup(extGroup, grp);\r\n        \/\/ ensure membership\r\n        grp.addMember(auth);\r\n        log.debug(\"- added '{}' as member to '{}'\", auth, grp);\r\n        \/\/ remember the declared group\r\n        declaredExternalGroups.remove(grp.getID());\r\n        \/\/ recursively apply further membership\r\n        if (depth > 1) {\r\n            log.debug(\"- recursively sync group membership of '{}' (depth = {}).\", grp.getID(), depth);\r\n            syncMembership(extGroup, grp, depth - 1);\r\n        } else {\r\n            log.debug(\"- group nesting level for '{}' reached\", grp.getID());\r\n        }\r\n    }\r\n    timer.mark(\"adding\");\r\n    \/\/ remove us from the lost membership groups\r\n    for (Group grp : declaredExternalGroups.values()) {\r\n        grp.removeMember(auth);\r\n        log.debug(\"- removing member '{}' for group '{}'\", auth.getID(), grp.getID());\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        timer.mark(\"removing\");\r\n        log.debug(\"syncMembership({}) {}\", external.getId(), timer.getString());\r\n    }\r\n}","code_comment":"\/**\r\n * Recursively sync the memberships of an authorizable up-to the specified depth. If the given depth\r\n * is equal or less than 0, no syncing is performed.\r\n *\r\n * @param external the external identity\r\n * @param auth the authorizable\r\n * @param depth recursion depth.\r\n * @throws RepositoryException\r\n *\/\r\n","code_no_comment":"protected void syncMembership(@Nonnull ExternalIdentity external, @Nonnull Authorizable auth, long depth) throws RepositoryException {\r\n    if (depth <= 0) {\r\n        return;\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Syncing membership '{}' -> '{}'\", external.getExternalId().getString(), auth.getID());\r\n    }\r\n    final DebugTimer timer = new DebugTimer();\r\n    Iterable<ExternalIdentityRef> externalGroups;\r\n    try {\r\n        externalGroups = external.getDeclaredGroups();\r\n    } catch (ExternalIdentityException e) {\r\n        log.error(\"Error while retrieving external declared groups for '{}'\", external.getId(), e);\r\n        return;\r\n    }\r\n    timer.mark(\"fetching\");\r\n        Map<String, Group> declaredExternalGroups = new HashMap<String, Group>();\r\n    Iterator<Group> grpIter = auth.declaredMemberOf();\r\n    while (grpIter.hasNext()) {\r\n        Group grp = grpIter.next();\r\n        if (isSameIDP(grp)) {\r\n            declaredExternalGroups.put(grp.getID(), grp);\r\n        }\r\n    }\r\n    timer.mark(\"reading\");\r\n    for (ExternalIdentityRef ref : externalGroups) {\r\n        log.debug(\"- processing membership {}\", ref.getId());\r\n                ExternalGroup extGroup;\r\n        try {\r\n            ExternalIdentity extId = idp.getIdentity(ref);\r\n            if (extId instanceof ExternalGroup) {\r\n                extGroup = (ExternalGroup) extId;\r\n            } else {\r\n                log.warn(\"No external group found for ref '{}'.\", ref.getString());\r\n                continue;\r\n            }\r\n        } catch (ExternalIdentityException e) {\r\n            log.warn(\"Unable to retrieve external group '{}' from provider.\", ref.getString(), e);\r\n            continue;\r\n        }\r\n        log.debug(\"- idp returned '{}'\", extGroup.getId());\r\n        Group grp;\r\n        Authorizable a = userManager.getAuthorizable(extGroup.getId());\r\n        if (a == null) {\r\n            grp = createGroup(extGroup);\r\n            log.debug(\"- created new group\");\r\n        } else if (a.isGroup()) {\r\n            grp = (Group) a;\r\n        } else {\r\n            log.warn(\"Authorizable '{}' is not a group, but should be one.\", extGroup.getId());\r\n            continue;\r\n        }\r\n        log.debug(\"- user manager returned '{}'\", grp);\r\n        syncGroup(extGroup, grp);\r\n                grp.addMember(auth);\r\n        log.debug(\"- added '{}' as member to '{}'\", auth, grp);\r\n                declaredExternalGroups.remove(grp.getID());\r\n                if (depth > 1) {\r\n            log.debug(\"- recursively sync group membership of '{}' (depth = {}).\", grp.getID(), depth);\r\n            syncMembership(extGroup, grp, depth - 1);\r\n        } else {\r\n            log.debug(\"- group nesting level for '{}' reached\", grp.getID());\r\n        }\r\n    }\r\n    timer.mark(\"adding\");\r\n        for (Group grp : declaredExternalGroups.values()) {\r\n        grp.removeMember(auth);\r\n        log.debug(\"- removing member '{}' for group '{}'\", auth.getID(), grp.getID());\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        timer.mark(\"removing\");\r\n        log.debug(\"syncMembership({}) {}\", external.getId(), timer.getString());\r\n    }\r\n}","lc":2.7272727273,"pi":0.2440191388,"ma":2.6,"nbd":0.5,"ml":1.0,"d":0.6646825397,"mi":-1.1558844257,"fo":4.0,"r":-0.0263157895,"e":3.0956196009}
{"project_name":"Closure","project_version":"139","label":2,"code":"\/**\r\n * Remove duplicate VAR declarations encountered discovered during\r\n * scope creation.\r\n *\/\r\n@Override\r\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\r\n    Preconditions.checkState(n.getType() == Token.NAME);\r\n    if (parent.getType() == Token.VAR) {\r\n        \/\/ If name is \"arguments\", Var maybe null.\r\n        Preconditions.checkState(parent.hasOneChild());\r\n        replaceVarWithAssignment(n, parent, gramps);\r\n    }\r\n}","code_comment":"\/**\r\n * Remove duplicate VAR declarations encountered discovered during\r\n * scope creation.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\r\n    Preconditions.checkState(n.getType() == Token.NAME);\r\n    if (parent.getType() == Token.VAR) {\r\n                Preconditions.checkState(parent.hasOneChild());\r\n        replaceVarWithAssignment(n, parent, gramps);\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.2769556025,"fo":0.0,"r":0.1578947368,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-1895_806eaeb0","label":0,"code":"\/**\r\n * Check if the scope of the nearest needs to be updated with the scope of the farthest.\r\n * <a href=\"http:\/\/docs.codehaus.org\/x\/IGU#DependencyMediationandConflictResolution-Scoperesolution\">More info<\/a>.\r\n * @param farthest farthest resolution node\r\n * @param nearest nearest resolution node\r\n * @param listeners\r\n *\/\r\nprivate boolean checkScopeUpdate(ResolutionNode farthest, ResolutionNode nearest, List listeners) {\r\n    boolean updateScope = false;\r\n    Artifact farthestArtifact = farthest.getArtifact();\r\n    Artifact nearestArtifact = nearest.getArtifact();\r\n    if (Artifact.SCOPE_RUNTIME.equals(farthestArtifact.getScope()) && (Artifact.SCOPE_TEST.equals(nearestArtifact.getScope()) || Artifact.SCOPE_PROVIDED.equals(nearestArtifact.getScope()))) {\r\n        updateScope = true;\r\n    }\r\n    if (Artifact.SCOPE_COMPILE.equals(farthestArtifact.getScope()) && !Artifact.SCOPE_COMPILE.equals(nearestArtifact.getScope())) {\r\n        updateScope = true;\r\n    }\r\n    \/\/ current POM rules all\r\n    if (nearest.getDepth() < 2 && updateScope) {\r\n        updateScope = false;\r\n        fireEvent(ResolutionListener.UPDATE_SCOPE_CURRENT_POM, listeners, nearest, farthestArtifact);\r\n    }\r\n    return updateScope;\r\n}","code_comment":"\/**\r\n * Check if the scope of the nearest needs to be updated with the scope of the farthest.\r\n * <a href=\"http:\/\/docs.codehaus.org\/x\/IGU#DependencyMediationandConflictResolution-Scoperesolution\">More info<\/a>.\r\n * @param farthest farthest resolution node\r\n * @param nearest nearest resolution node\r\n * @param listeners\r\n *\/\r\n","code_no_comment":"private boolean checkScopeUpdate(ResolutionNode farthest, ResolutionNode nearest, List listeners) {\r\n    boolean updateScope = false;\r\n    Artifact farthestArtifact = farthest.getArtifact();\r\n    Artifact nearestArtifact = nearest.getArtifact();\r\n    if (Artifact.SCOPE_RUNTIME.equals(farthestArtifact.getScope()) && (Artifact.SCOPE_TEST.equals(nearestArtifact.getScope()) || Artifact.SCOPE_PROVIDED.equals(nearestArtifact.getScope()))) {\r\n        updateScope = true;\r\n    }\r\n    if (Artifact.SCOPE_COMPILE.equals(farthestArtifact.getScope()) && !Artifact.SCOPE_COMPILE.equals(nearestArtifact.getScope())) {\r\n        updateScope = true;\r\n    }\r\n        if (nearest.getDepth() < 2 && updateScope) {\r\n        updateScope = false;\r\n        fireEvent(ResolutionListener.UPDATE_SCOPE_CURRENT_POM, listeners, nearest, farthestArtifact);\r\n    }\r\n    return updateScope;\r\n}","lc":0.0909090909,"pi":-0.2822966507,"ma":0.0,"nbd":-0.5,"ml":0.9166666667,"d":0.5873015873,"mi":-0.1746300211,"fo":0.6666666667,"r":-0.0263157895,"e":0.6190372458}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5518_c2e12216","label":3,"code":"\/**\r\n *  Update the model of a {@link FormComponent} containing a {@link Collection}.\r\n *\r\n *  If the model object does not yet exists, a new {@link ArrayList} is filled with the converted\r\n *  input and used as the new model object. Otherwise the existing collection is modified\r\n *  in-place, then {@link Model#setObject(Object)} is called with the same instance: it allows\r\n *  the Model to be notified of changes even when {@link Model#getObject()} returns a different\r\n *  {@link Collection} at every invocation.\r\n *\r\n *  @param <S>\r\n *             collection type\r\n *  @param formComponent\r\n *             the form component to update\r\n *  @see FormComponent#updateModel()\r\n *  @throws UnsupportedOperationException\r\n *              if the existing model object Collection cannot be modified\r\n *\/\r\npublic static <S> void updateCollectionModel(FormComponent<Collection<S>> formComponent) {\r\n    Collection<S> convertedInput = formComponent.getConvertedInput();\r\n    Collection<S> collection = formComponent.getModelObject();\r\n    if (collection == null) {\r\n        collection = new ArrayList<>(convertedInput);\r\n        formComponent.setDefaultModelObject(collection);\r\n    } else {\r\n        formComponent.modelChanging();\r\n        collection.clear();\r\n        if (convertedInput != null) {\r\n            collection.addAll(convertedInput);\r\n        }\r\n        formComponent.modelChanged();\r\n        try {\r\n            formComponent.getModel().setObject(collection);\r\n        } catch (Exception e) {\r\n            \/\/ ignore this exception because it could be that there\r\n            \/\/ is not setter for this collection.\r\n            logger.info(\"An error occurred while trying to set the new value for the property attached to \" + formComponent, e);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  Update the model of a {@link FormComponent} containing a {@link Collection}.\r\n *\r\n *  If the model object does not yet exists, a new {@link ArrayList} is filled with the converted\r\n *  input and used as the new model object. Otherwise the existing collection is modified\r\n *  in-place, then {@link Model#setObject(Object)} is called with the same instance: it allows\r\n *  the Model to be notified of changes even when {@link Model#getObject()} returns a different\r\n *  {@link Collection} at every invocation.\r\n *\r\n *  @param <S>\r\n *             collection type\r\n *  @param formComponent\r\n *             the form component to update\r\n *  @see FormComponent#updateModel()\r\n *  @throws UnsupportedOperationException\r\n *              if the existing model object Collection cannot be modified\r\n *\/\r\n","code_no_comment":"public static <S> void updateCollectionModel(FormComponent<Collection<S>> formComponent) {\r\n    Collection<S> convertedInput = formComponent.getConvertedInput();\r\n    Collection<S> collection = formComponent.getModelObject();\r\n    if (collection == null) {\r\n        collection = new ArrayList<>(convertedInput);\r\n        formComponent.setDefaultModelObject(collection);\r\n    } else {\r\n        formComponent.modelChanging();\r\n        collection.clear();\r\n        if (convertedInput != null) {\r\n            collection.addAll(convertedInput);\r\n        }\r\n        formComponent.modelChanged();\r\n        try {\r\n            formComponent.getModel().setObject(collection);\r\n        } catch (Exception e) {\r\n                                    logger.info(\"An error occurred while trying to set the new value for the property attached to \" + formComponent, e);\r\n        }\r\n    }\r\n}","lc":0.2727272727,"pi":0.1818181818,"ma":0.0,"nbd":0.0,"ml":-0.0833333333,"d":0.4126984127,"mi":-0.2284707541,"fo":0.3333333333,"r":-0.0263157895,"e":0.2972862387}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5204_9e6efa61","label":1,"code":"\/**\r\n *  @see org.apache.wicket.Component#onBeforeRender()\r\n *\/\r\n@Override\r\nprotected void onBeforeRender() {\r\n    dateField.setRequired(isRequired());\r\n    hoursField.setRequired(isRequired());\r\n    minutesField.setRequired(isRequired());\r\n    boolean use12HourFormat = use12HourFormat();\r\n    amOrPmChoice.setVisible(use12HourFormat);\r\n    Date modelObject = (Date) getDefaultModelObject();\r\n    if (modelObject == null) {\r\n        date = null;\r\n        hours = null;\r\n        minutes = null;\r\n    } else {\r\n        MutableDateTime mDate;\r\n        \/\/ convert date to the client's time zone if we have that info\r\n        TimeZone zone = getClientTimeZone();\r\n        if (zone != null) {\r\n            mDate = new MutableDateTime(modelObject, DateTimeZone.forTimeZone(zone));\r\n        } else {\r\n            mDate = new MutableDateTime(modelObject);\r\n        }\r\n        date = mDate.toDate();\r\n        if (use12HourFormat) {\r\n            int hourOfHalfDay = mDate.get(DateTimeFieldType.hourOfHalfday());\r\n            hours = hourOfHalfDay == 0 ? 12 : hourOfHalfDay;\r\n        } else {\r\n            hours = mDate.get(DateTimeFieldType.hourOfDay());\r\n        }\r\n        amOrPm = (mDate.get(DateTimeFieldType.halfdayOfDay()) == 0) ? AM_PM.AM : AM_PM.PM;\r\n        minutes = mDate.getMinuteOfHour();\r\n    }\r\n    super.onBeforeRender();\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.Component#onBeforeRender()\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void onBeforeRender() {\r\n    dateField.setRequired(isRequired());\r\n    hoursField.setRequired(isRequired());\r\n    minutesField.setRequired(isRequired());\r\n    boolean use12HourFormat = use12HourFormat();\r\n    amOrPmChoice.setVisible(use12HourFormat);\r\n    Date modelObject = (Date) getDefaultModelObject();\r\n    if (modelObject == null) {\r\n        date = null;\r\n        hours = null;\r\n        minutes = null;\r\n    } else {\r\n        MutableDateTime mDate;\r\n                TimeZone zone = getClientTimeZone();\r\n        if (zone != null) {\r\n            mDate = new MutableDateTime(modelObject, DateTimeZone.forTimeZone(zone));\r\n        } else {\r\n            mDate = new MutableDateTime(modelObject);\r\n        }\r\n        date = mDate.toDate();\r\n        if (use12HourFormat) {\r\n            int hourOfHalfDay = mDate.get(DateTimeFieldType.hourOfHalfday());\r\n            hours = hourOfHalfDay == 0 ? 12 : hourOfHalfDay;\r\n        } else {\r\n            hours = mDate.get(DateTimeFieldType.hourOfDay());\r\n        }\r\n        amOrPm = (mDate.get(DateTimeFieldType.halfdayOfDay()) == 0) ? AM_PM.AM : AM_PM.PM;\r\n        minutes = mDate.getMinuteOfHour();\r\n    }\r\n    super.onBeforeRender();\r\n}","lc":0.8181818182,"pi":0.2009569378,"ma":0.4,"nbd":0.0,"ml":0.5,"d":0.0317460317,"mi":-0.5599718111,"fo":1.1666666667,"r":-0.0263157895,"e":0.3145242994}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-327_262fe4c0","label":0,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic double getConditionNumber() {\r\n    return singularValues[0] \/ singularValues[singularValues.length - 1];\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public double getConditionNumber() {\r\n    return singularValues[0] \/ singularValues[singularValues.length - 1];\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.1011904762,"mi":0.9709654686,"fo":-0.5,"r":2.5526315789,"e":-0.1443520456}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1093_d7f0f180","label":1,"code":"@Override\r\npublic Value[] getValues() throws RepositoryException {\r\n    PropertyValue[] values = row.getValues();\r\n    int len = values.length;\r\n    Value[] v2 = new Value[values.length];\r\n    for (int i = 0; i < len; i++) {\r\n        v2[i] = result.createValue(values[i]);\r\n    }\r\n    return v2;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Value[] getValues() throws RepositoryException {\r\n    PropertyValue[] values = row.getValues();\r\n    int len = values.length;\r\n    Value[] v2 = new Value[values.length];\r\n    for (int i = 0; i < len; i++) {\r\n        v2[i] = result.createValue(values[i]);\r\n    }\r\n    return v2;\r\n}","lc":-0.1818181818,"pi":-0.2822966507,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":0.0178571429,"mi":0.1785764623,"fo":-0.3333333333,"r":0.6315789474,"e":-0.0289875117}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1729_7ba9dd66","label":0,"code":"\/**\r\n * Set various split document related flag\/properties\r\n *\r\n * @param mainDoc main document from which split document is being created\r\n * @param old updateOp of the old document created via split\r\n * @param oldDoc old document created via split\r\n * @param maxRev max revision stored in the split document oldDoc\r\n *\/\r\nprivate static void setSplitDocProps(NodeDocument mainDoc, NodeDocument oldDoc, UpdateOp old, Revision maxRev) {\r\n    setSplitDocMaxRev(old, maxRev);\r\n    SplitDocType type = SplitDocType.DEFAULT;\r\n    if (!mainDoc.hasChildren()) {\r\n        type = SplitDocType.DEFAULT_NO_CHILD;\r\n    } else if (oldDoc.getLocalRevisions().isEmpty()) {\r\n        type = SplitDocType.PROP_COMMIT_ONLY;\r\n    }\r\n    \/\/ Copy over the hasBinary flag\r\n    if (mainDoc.hasBinary()) {\r\n        setHasBinary(old);\r\n    }\r\n    setSplitDocType(old, type);\r\n}","code_comment":"\/**\r\n * Set various split document related flag\/properties\r\n *\r\n * @param mainDoc main document from which split document is being created\r\n * @param old updateOp of the old document created via split\r\n * @param oldDoc old document created via split\r\n * @param maxRev max revision stored in the split document oldDoc\r\n *\/\r\n","code_no_comment":"private static void setSplitDocProps(NodeDocument mainDoc, NodeDocument oldDoc, UpdateOp old, Revision maxRev) {\r\n    setSplitDocMaxRev(old, maxRev);\r\n    SplitDocType type = SplitDocType.DEFAULT;\r\n    if (!mainDoc.hasChildren()) {\r\n        type = SplitDocType.DEFAULT_NO_CHILD;\r\n    } else if (oldDoc.getLocalRevisions().isEmpty()) {\r\n        type = SplitDocType.PROP_COMMIT_ONLY;\r\n    }\r\n        if (mainDoc.hasBinary()) {\r\n        setHasBinary(old);\r\n    }\r\n    setSplitDocType(old, type);\r\n}","lc":-0.0454545455,"pi":-0.2535885167,"ma":0.0,"nbd":0.0,"ml":0.0833333333,"d":-0.0337301587,"mi":0.0221282593,"fo":0.0833333333,"r":0.5526315789,"e":-0.0272355826}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Returns true if the internal storage array has too many unused\r\n * storage positions.\r\n *\r\n * @return true if array satisfies the contraction criteria\r\n *\/\r\nprivate synchronized boolean shouldContract() {\r\n    if (expansionMode == ExpansionMode.MULTIPLICATIVE) {\r\n        return (internalArray.length \/ ((float) numElements)) > contractionCriterion;\r\n    } else {\r\n        return (internalArray.length - numElements) > contractionCriterion;\r\n    }\r\n}","code_comment":"\/**\r\n * Returns true if the internal storage array has too many unused\r\n * storage positions.\r\n *\r\n * @return true if array satisfies the contraction criteria\r\n *\/\r\n","code_no_comment":"private synchronized boolean shouldContract() {\r\n    if (expansionMode == ExpansionMode.MULTIPLICATIVE) {\r\n        return (internalArray.length \/ ((float) numElements)) > contractionCriterion;\r\n    } else {\r\n        return (internalArray.length - numElements) > contractionCriterion;\r\n    }\r\n}","lc":-0.3181818182,"pi":0.014354067,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.2083333333,"mi":0.4604651163,"fo":-0.5,"r":2.5263157895,"e":-0.0740812457}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-320_b2f3f6db","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic RealMatrix getU() throws InvalidMatrixException {\r\n    if (cachedU == null) {\r\n        final int p = singularValues.length;\r\n        if (m >= n) {\r\n            \/\/ the tridiagonal matrix is Bt.B, where B is upper bidiagonal\r\n            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\r\n            final double[][] eData = e.getData();\r\n            final double[][] wData = new double[m][p];\r\n            double[] ei1 = eData[0];\r\n            for (int i = 0; i < p - 1; ++i) {\r\n                \/\/ compute W = B.E.S^(-1) where E is the eigenvectors matrix\r\n                final double mi = mainBidiagonal[i];\r\n                final double si = secondaryBidiagonal[i];\r\n                final double[] ei0 = ei1;\r\n                final double[] wi = wData[i];\r\n                ei1 = eData[i + 1];\r\n                for (int j = 0; j < p; ++j) {\r\n                    wi[j] = (mi * ei0[j] + si * ei1[j]) \/ singularValues[j];\r\n                }\r\n            }\r\n            \/\/ last row\r\n            final double lastMain = mainBidiagonal[p - 1];\r\n            final double[] wr1 = wData[p - 1];\r\n            for (int j = 0; j < p; ++j) {\r\n                wr1[j] = ei1[j] * lastMain \/ singularValues[j];\r\n            }\r\n            for (int i = p; i < m; ++i) {\r\n                wData[i] = new double[p];\r\n            }\r\n            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\r\n        } else {\r\n            \/\/ the tridiagonal matrix is B.Bt, where B is lower bidiagonal\r\n            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\r\n            cachedU = transformer.getU().multiply(e);\r\n        }\r\n    }\r\n    \/\/ return the cached matrix\r\n    return cachedU;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public RealMatrix getU() throws InvalidMatrixException {\r\n    if (cachedU == null) {\r\n        final int p = singularValues.length;\r\n        if (m >= n) {\r\n                        final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\r\n            final double[][] eData = e.getData();\r\n            final double[][] wData = new double[m][p];\r\n            double[] ei1 = eData[0];\r\n            for (int i = 0; i < p - 1; ++i) {\r\n                                final double mi = mainBidiagonal[i];\r\n                final double si = secondaryBidiagonal[i];\r\n                final double[] ei0 = ei1;\r\n                final double[] wi = wData[i];\r\n                ei1 = eData[i + 1];\r\n                for (int j = 0; j < p; ++j) {\r\n                    wi[j] = (mi * ei0[j] + si * ei1[j]) \/ singularValues[j];\r\n                }\r\n            }\r\n                        final double lastMain = mainBidiagonal[p - 1];\r\n            final double[] wr1 = wData[p - 1];\r\n            for (int j = 0; j < p; ++j) {\r\n                wr1[j] = ei1[j] * lastMain \/ singularValues[j];\r\n            }\r\n            for (int i = p; i < m; ++i) {\r\n                wData[i] = new double[p];\r\n            }\r\n            cachedU = transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\r\n        } else {\r\n                        final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\r\n            cachedU = transformer.getU().multiply(e);\r\n        }\r\n    }\r\n        return cachedU;\r\n}","lc":0.9090909091,"pi":0.8038277512,"ma":0.6,"nbd":1.0,"ml":0.5833333333,"d":2.3333333333,"mi":-0.6752642706,"fo":0.3333333333,"r":-0.0263157895,"e":5.4853154913}
{"project_name":"Compress","project_version":"20","label":1,"code":"private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException {\r\n    CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\r\n    ret.setDevice(readBinaryLong(2, swapHalfWord));\r\n    ret.setInode(readBinaryLong(2, swapHalfWord));\r\n    final long mode = readBinaryLong(2, swapHalfWord);\r\n    if (mode != 0) {\r\n        ret.setMode(mode);\r\n    }\r\n    ret.setUID(readBinaryLong(2, swapHalfWord));\r\n    ret.setGID(readBinaryLong(2, swapHalfWord));\r\n    ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));\r\n    ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));\r\n    ret.setTime(readBinaryLong(4, swapHalfWord));\r\n    long namesize = readBinaryLong(2, swapHalfWord);\r\n    ret.setSize(readBinaryLong(4, swapHalfWord));\r\n    final String name = readCString((int) namesize);\r\n    ret.setName(name);\r\n    if (mode == 0 && !name.equals(CPIO_TRAILER)) {\r\n        throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \" + name + \"Occured at byte: \" + getBytesRead());\r\n    }\r\n    skip(ret.getHeaderPadCount());\r\n    return ret;\r\n}","code_comment":null,"code_no_comment":"private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException {\r\n    CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\r\n    ret.setDevice(readBinaryLong(2, swapHalfWord));\r\n    ret.setInode(readBinaryLong(2, swapHalfWord));\r\n    final long mode = readBinaryLong(2, swapHalfWord);\r\n    if (mode != 0) {\r\n        ret.setMode(mode);\r\n    }\r\n    ret.setUID(readBinaryLong(2, swapHalfWord));\r\n    ret.setGID(readBinaryLong(2, swapHalfWord));\r\n    ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));\r\n    ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));\r\n    ret.setTime(readBinaryLong(4, swapHalfWord));\r\n    long namesize = readBinaryLong(2, swapHalfWord);\r\n    ret.setSize(readBinaryLong(4, swapHalfWord));\r\n    final String name = readCString((int) namesize);\r\n    ret.setName(name);\r\n    if (mode == 0 && !name.equals(CPIO_TRAILER)) {\r\n        throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \" + name + \"Occured at byte: \" + getBytesRead());\r\n    }\r\n    skip(ret.getHeaderPadCount());\r\n    return ret;\r\n}","lc":0.4090909091,"pi":-0.6315789474,"ma":0.0,"nbd":-0.5,"ml":0.0,"d":1.1329365079,"mi":-0.3871740662,"fo":1.5833333333,"r":-0.0263157895,"e":1.5287541133}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3020_147515ae","label":1,"code":"private boolean addTypedOrderedFields(List<Field> fields, PropertyState property, String pname, PropertyDefinition pd) throws CommitFailedException {\r\n    int tag = property.getType().tag();\r\n    int idxDefinedTag = pd.getType();\r\n    \/\/ Try converting type to the defined type in the index definition\r\n    if (tag != idxDefinedTag) {\r\n        log.debug(\"Ordered property defined with type {} differs from property {} with type {} in \" + \"path {}\", Type.fromTag(idxDefinedTag, false), property.toString(), Type.fromTag(tag, false), getPath());\r\n        tag = idxDefinedTag;\r\n    }\r\n    String name = FieldNames.createDocValFieldName(pname);\r\n    boolean fieldAdded = false;\r\n    for (int i = 0; i < property.count(); i++) {\r\n        Field f = null;\r\n        try {\r\n            if (tag == Type.LONG.tag()) {\r\n                \/\/ TODO Distinguish fields which need to be used for search and for sort\r\n                \/\/ If a field is only used for Sort then it can be stored with less precision\r\n                f = new NumericDocValuesField(name, property.getValue(Type.LONG, i));\r\n            } else if (tag == Type.DATE.tag()) {\r\n                String date = property.getValue(Type.DATE, i);\r\n                f = new NumericDocValuesField(name, FieldFactory.dateToLong(date));\r\n            } else if (tag == Type.DOUBLE.tag()) {\r\n                f = new DoubleDocValuesField(name, property.getValue(Type.DOUBLE, i));\r\n            } else if (tag == Type.BOOLEAN.tag()) {\r\n                f = new SortedDocValuesField(name, new BytesRef(property.getValue(Type.BOOLEAN, i).toString()));\r\n            } else if (tag == Type.STRING.tag()) {\r\n                f = new SortedDocValuesField(name, new BytesRef(property.getValue(Type.STRING, i)));\r\n            }\r\n            if (f != null) {\r\n                fields.add(f);\r\n                fieldAdded = true;\r\n            }\r\n        } catch (Exception e) {\r\n            log.warn(\"Ignoring ordered property. Could not convert property {} of type {} to type \" + \"{} for path {}\", pname, Type.fromTag(property.getType().tag(), false), Type.fromTag(tag, false), getPath(), e);\r\n        }\r\n    }\r\n    return fieldAdded;\r\n}","code_comment":null,"code_no_comment":"private boolean addTypedOrderedFields(List<Field> fields, PropertyState property, String pname, PropertyDefinition pd) throws CommitFailedException {\r\n    int tag = property.getType().tag();\r\n    int idxDefinedTag = pd.getType();\r\n        if (tag != idxDefinedTag) {\r\n        log.debug(\"Ordered property defined with type {} differs from property {} with type {} in \" + \"path {}\", Type.fromTag(idxDefinedTag, false), property.toString(), Type.fromTag(tag, false), getPath());\r\n        tag = idxDefinedTag;\r\n    }\r\n    String name = FieldNames.createDocValFieldName(pname);\r\n    boolean fieldAdded = false;\r\n    for (int i = 0; i < property.count(); i++) {\r\n        Field f = null;\r\n        try {\r\n            if (tag == Type.LONG.tag()) {\r\n                                                f = new NumericDocValuesField(name, property.getValue(Type.LONG, i));\r\n            } else if (tag == Type.DATE.tag()) {\r\n                String date = property.getValue(Type.DATE, i);\r\n                f = new NumericDocValuesField(name, FieldFactory.dateToLong(date));\r\n            } else if (tag == Type.DOUBLE.tag()) {\r\n                f = new DoubleDocValuesField(name, property.getValue(Type.DOUBLE, i));\r\n            } else if (tag == Type.BOOLEAN.tag()) {\r\n                f = new SortedDocValuesField(name, new BytesRef(property.getValue(Type.BOOLEAN, i).toString()));\r\n            } else if (tag == Type.STRING.tag()) {\r\n                f = new SortedDocValuesField(name, new BytesRef(property.getValue(Type.STRING, i)));\r\n            }\r\n            if (f != null) {\r\n                fields.add(f);\r\n                fieldAdded = true;\r\n            }\r\n        } catch (Exception e) {\r\n            log.warn(\"Ignoring ordered property. Could not convert property {} of type {} to type \" + \"{} for path {}\", pname, Type.fromTag(property.getType().tag(), false), Type.fromTag(tag, false), getPath(), e);\r\n        }\r\n    }\r\n    return fieldAdded;\r\n}","lc":0.9090909091,"pi":0.976076555,"ma":1.2,"nbd":2.5,"ml":1.0833333333,"d":1.3075396825,"mi":-0.7136011276,"fo":1.9166666667,"r":-0.0263157895,"e":3.8172346029}
{"project_name":"Closure","project_version":"156","label":2,"code":"\/**\r\n * Updates the first initialization (a.k.a \"declaration\") of a global name\r\n * that occurs at a VAR node. See comment for\r\n * {@link #updateObjLitOrFunctionDeclaration}.\r\n *\r\n * @param n An object representing a global name (e.g. \"a\")\r\n *\/\r\nprivate void updateObjLitOrFunctionDeclarationAtVarNode(Name n) {\r\n    Ref ref = n.declaration;\r\n    String name = ref.node.getString();\r\n    Node rvalue = ref.node.getFirstChild();\r\n    Node varNode = ref.node.getParent();\r\n    Node gramps = varNode.getParent();\r\n    boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;\r\n    int numChanges = 0;\r\n    if (isObjLit) {\r\n        numChanges += declareVarsForObjLitValues(n, name, rvalue, varNode, gramps.getChildBefore(varNode), gramps);\r\n    }\r\n    numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode);\r\n    if (isObjLit && n.canEliminate()) {\r\n        varNode.removeChild(ref.node);\r\n        if (!varNode.hasChildren()) {\r\n            gramps.removeChild(varNode);\r\n        }\r\n        numChanges++;\r\n        \/\/ Clear out the object reference, since we've eliminated it from the\r\n        \/\/ parse tree.\r\n        ref.node = null;\r\n    }\r\n    if (numChanges > 0) {\r\n        compiler.reportCodeChange();\r\n    }\r\n}","code_comment":"\/**\r\n * Updates the first initialization (a.k.a \"declaration\") of a global name\r\n * that occurs at a VAR node. See comment for\r\n * {@link #updateObjLitOrFunctionDeclaration}.\r\n *\r\n * @param n An object representing a global name (e.g. \"a\")\r\n *\/\r\n","code_no_comment":"private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) {\r\n    Ref ref = n.declaration;\r\n    String name = ref.node.getString();\r\n    Node rvalue = ref.node.getFirstChild();\r\n    Node varNode = ref.node.getParent();\r\n    Node gramps = varNode.getParent();\r\n    boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;\r\n    int numChanges = 0;\r\n    if (isObjLit) {\r\n        numChanges += declareVarsForObjLitValues(n, name, rvalue, varNode, gramps.getChildBefore(varNode), gramps);\r\n    }\r\n    numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode);\r\n    if (isObjLit && n.canEliminate()) {\r\n        varNode.removeChild(ref.node);\r\n        if (!varNode.hasChildren()) {\r\n            gramps.removeChild(varNode);\r\n        }\r\n        numChanges++;\r\n                        ref.node = null;\r\n    }\r\n    if (numChanges > 0) {\r\n        compiler.reportCodeChange();\r\n    }\r\n}","lc":0.4545454545,"pi":-0.1387559809,"ma":0.2,"nbd":0.0,"ml":0.3333333333,"d":0.9563492063,"mi":-0.4029598309,"fo":0.5833333333,"r":-0.0263157895,"e":1.2320925756}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7429_43956f93","label":1,"code":"private String createConstantPart(String uri, int start, int end) {\r\n    return uri.substring(start, end);\r\n}","code_comment":null,"code_no_comment":"private String createConstantPart(String uri, int start, int end) {\r\n    return uri.substring(start, end);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9667371388,"fo":-0.4166666667,"r":0.0,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public void read(org.apache.thrift.protocol.TProtocol iprot, setTableProperty_result struct) throws org.apache.thrift.TException {\r\n    org.apache.thrift.protocol.TField schemeField;\r\n    iprot.readStructBegin();\r\n    while (true) {\r\n        schemeField = iprot.readFieldBegin();\r\n        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {\r\n            break;\r\n        }\r\n        switch(schemeField.id) {\r\n            case \/\/ OUCH1\r\n            1:\r\n                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\r\n                    struct.ouch1 = new AccumuloException();\r\n                    struct.ouch1.read(iprot);\r\n                    struct.setOuch1IsSet(true);\r\n                } else {\r\n                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n                }\r\n                break;\r\n            case \/\/ OUCH2\r\n            2:\r\n                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\r\n                    struct.ouch2 = new AccumuloSecurityException();\r\n                    struct.ouch2.read(iprot);\r\n                    struct.setOuch2IsSet(true);\r\n                } else {\r\n                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n                }\r\n                break;\r\n            default:\r\n                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n        }\r\n        iprot.readFieldEnd();\r\n    }\r\n    iprot.readStructEnd();\r\n    \/\/ check for required fields of primitive type, which can't be checked in the validate method\r\n    struct.validate();\r\n}","code_comment":null,"code_no_comment":"public void read(org.apache.thrift.protocol.TProtocol iprot, setTableProperty_result struct) throws org.apache.thrift.TException {\r\n    org.apache.thrift.protocol.TField schemeField;\r\n    iprot.readStructBegin();\r\n    while (true) {\r\n        schemeField = iprot.readFieldBegin();\r\n        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {\r\n            break;\r\n        }\r\n        switch(schemeField.id) {\r\n            case             1:\r\n                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\r\n                    struct.ouch1 = new AccumuloException();\r\n                    struct.ouch1.read(iprot);\r\n                    struct.setOuch1IsSet(true);\r\n                } else {\r\n                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n                }\r\n                break;\r\n            case             2:\r\n                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\r\n                    struct.ouch2 = new AccumuloSecurityException();\r\n                    struct.ouch2.read(iprot);\r\n                    struct.setOuch2IsSet(true);\r\n                } else {\r\n                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n                }\r\n                break;\r\n            default:\r\n                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\r\n        }\r\n        iprot.readFieldEnd();\r\n    }\r\n    iprot.readStructEnd();\r\n        struct.validate();\r\n}","lc":1.0454545455,"pi":1.5358851675,"ma":1.4,"nbd":1.0,"ml":0.25,"d":0.2599206349,"mi":-0.6763918252,"fo":0.5,"r":-0.0263157895,"e":0.6848267953}
{"project_name":"JxPath","project_version":"2","label":1,"code":"public Iterator iterate(EvalContext context) {\r\n    Object result = compute(context);\r\n    if (result instanceof EvalContext) {\r\n        return new ValueIterator((EvalContext) result);\r\n    }\r\n    return ValueUtils.iterate(result);\r\n}","code_comment":null,"code_no_comment":"public Iterator iterate(EvalContext context) {\r\n    Object result = compute(context);\r\n    if (result instanceof EvalContext) {\r\n        return new ValueIterator((EvalContext) result);\r\n    }\r\n    return ValueUtils.iterate(result);\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.4703312192,"fo":-0.3333333333,"r":1.0526315789,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3545_050c542e","label":1,"code":"\/**\r\n * Validates the given bean has the method\r\n *\r\n * @param context  camel context\r\n * @param bean     the bean instance\r\n * @param method   the method, can be <tt>null<\/tt> if no method name provided\r\n * @throws org.apache.camel.RuntimeCamelException is thrown if bean does not have the method\r\n *\/\r\n@SuppressWarnings(\"rawtypes\")\r\nprotected void validateHasMethod(CamelContext context, Object bean, String method, Class parameterType) {\r\n    if (method == null) {\r\n        return;\r\n    }\r\n    BeanInfo info = new BeanInfo(context, bean.getClass());\r\n    List<Class> parameterTypes = new ArrayList<Class>();\r\n    if (parameterType != null) {\r\n        parameterTypes.add(parameterType);\r\n    }\r\n    if (!info.hasMethod(method, parameterTypes)) {\r\n        throw ObjectHelper.wrapRuntimeCamelException(new MethodNotFoundException(null, bean, method, parameterTypes));\r\n    }\r\n}","code_comment":"\/**\r\n * Validates the given bean has the method\r\n *\r\n * @param context  camel context\r\n * @param bean     the bean instance\r\n * @param method   the method, can be <tt>null<\/tt> if no method name provided\r\n * @throws org.apache.camel.RuntimeCamelException is thrown if bean does not have the method\r\n *\/\r\n","code_no_comment":"@SuppressWarnings(\"rawtypes\")\r\nprotected void validateHasMethod(CamelContext context, Object bean, String method, Class parameterType) {\r\n    if (method == null) {\r\n        return;\r\n    }\r\n    BeanInfo info = new BeanInfo(context, bean.getClass());\r\n    List<Class> parameterTypes = new ArrayList<Class>();\r\n    if (parameterType != null) {\r\n        parameterTypes.add(parameterType);\r\n    }\r\n    if (!info.hasMethod(method, parameterTypes)) {\r\n        throw ObjectHelper.wrapRuntimeCamelException(new MethodNotFoundException(null, bean, method, parameterTypes));\r\n    }\r\n}","lc":0.0,"pi":-0.1770334928,"ma":0.2,"nbd":-0.5,"ml":0.1666666667,"d":0.3134920635,"mi":-0.0514446794,"fo":-0.1666666667,"r":-0.0263157895,"e":0.185545432}
{"project_name":"JxPath","project_version":"14","label":1,"code":"protected Object functionCeiling(EvalContext context) {\r\n    assertArgCount(1);\r\n    double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\r\n    return new Double(Math.ceil(v));\r\n}","code_comment":null,"code_no_comment":"protected Object functionCeiling(EvalContext context) {\r\n    assertArgCount(1);\r\n    double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\r\n    return new Double(Math.ceil(v));\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6093023256,"fo":-0.0833333333,"r":1.1842105263,"e":-0.1627934049}
{"project_name":"Math","project_version":"72","label":0,"code":"\/**\r\n * Find a zero in the given interval with an initial guess.\r\n * <p>Throws <code>IllegalArgumentException<\/code> if the values of the\r\n * function at the three points have the same sign (note that it is\r\n * allowed to have endpoints with the same sign if the initial point has\r\n * opposite sign function-wise).<\/p>\r\n *\r\n * @param f function to solve.\r\n * @param min the lower bound for the interval.\r\n * @param max the upper bound for the interval.\r\n * @param initial the start value to use (must be set to min if no\r\n * initial point is known).\r\n * @return the value where the function is zero\r\n * @throws MaxIterationsExceededException the maximum iteration count\r\n * is exceeded\r\n * @throws FunctionEvaluationException if an error occurs evaluating\r\n *  the function\r\n * @throws IllegalArgumentException if initial is not between min and max\r\n * (even if it <em>is<\/em> a root)\r\n *\/\r\npublic double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    clearResult();\r\n    verifySequence(min, initial, max);\r\n    \/\/ return the initial guess if it is good enough\r\n    double yInitial = f.value(initial);\r\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\r\n        setResult(initial, 0);\r\n        return result;\r\n    }\r\n    \/\/ return the first endpoint if it is good enough\r\n    double yMin = f.value(min);\r\n    if (Math.abs(yMin) <= functionValueAccuracy) {\r\n        setResult(yMin, 0);\r\n        return result;\r\n    }\r\n    \/\/ reduce interval if min and initial bracket the root\r\n    if (yInitial * yMin < 0) {\r\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\r\n    }\r\n    \/\/ return the second endpoint if it is good enough\r\n    double yMax = f.value(max);\r\n    if (Math.abs(yMax) <= functionValueAccuracy) {\r\n        setResult(yMax, 0);\r\n        return result;\r\n    }\r\n    \/\/ reduce interval if initial and max bracket the root\r\n    if (yInitial * yMax < 0) {\r\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\r\n    }\r\n    if (yMin * yMax > 0) {\r\n        throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\r\n    }\r\n    \/\/ full Brent algorithm starting with provided initial guess\r\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\r\n}","code_comment":"\/**\r\n * Find a zero in the given interval with an initial guess.\r\n * <p>Throws <code>IllegalArgumentException<\/code> if the values of the\r\n * function at the three points have the same sign (note that it is\r\n * allowed to have endpoints with the same sign if the initial point has\r\n * opposite sign function-wise).<\/p>\r\n *\r\n * @param f function to solve.\r\n * @param min the lower bound for the interval.\r\n * @param max the upper bound for the interval.\r\n * @param initial the start value to use (must be set to min if no\r\n * initial point is known).\r\n * @return the value where the function is zero\r\n * @throws MaxIterationsExceededException the maximum iteration count\r\n * is exceeded\r\n * @throws FunctionEvaluationException if an error occurs evaluating\r\n *  the function\r\n * @throws IllegalArgumentException if initial is not between min and max\r\n * (even if it <em>is<\/em> a root)\r\n *\/\r\n","code_no_comment":"public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    clearResult();\r\n    verifySequence(min, initial, max);\r\n        double yInitial = f.value(initial);\r\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\r\n        setResult(initial, 0);\r\n        return result;\r\n    }\r\n        double yMin = f.value(min);\r\n    if (Math.abs(yMin) <= functionValueAccuracy) {\r\n        setResult(yMin, 0);\r\n        return result;\r\n    }\r\n        if (yInitial * yMin < 0) {\r\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\r\n    }\r\n        double yMax = f.value(max);\r\n    if (Math.abs(yMax) <= functionValueAccuracy) {\r\n        setResult(yMax, 0);\r\n        return result;\r\n    }\r\n        if (yInitial * yMax < 0) {\r\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\r\n    }\r\n    if (yMin * yMax > 0) {\r\n        throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\r\n    }\r\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\r\n}","lc":0.6818181818,"pi":-0.3444976077,"ma":0.8,"nbd":-0.5,"ml":0.6666666667,"d":1.123015873,"mi":-0.5216349542,"fo":0.75,"r":-0.0263157895,"e":1.5505748517}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Byte reusable) {\r\n    int val = 0;\r\n    boolean neg = false;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    if (bytes[startPos] == '-') {\r\n        neg = true;\r\n        startPos++;\r\n        \/\/ check for empty field with only the sign\r\n        if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\r\n            return -1;\r\n        }\r\n    }\r\n    for (int i = startPos; i < limit; i++) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            this.result = (byte) (neg ? -val : val);\r\n            return i + delimiter.length;\r\n        }\r\n        if (bytes[i] < 48 || bytes[i] > 57) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\r\n            return -1;\r\n        }\r\n        val *= 10;\r\n        val += bytes[i] - 48;\r\n        if (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\r\n            return -1;\r\n        }\r\n    }\r\n    this.result = (byte) (neg ? -val : val);\r\n    return limit;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Byte reusable) {\r\n    int val = 0;\r\n    boolean neg = false;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    if (bytes[startPos] == '-') {\r\n        neg = true;\r\n        startPos++;\r\n                if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\r\n            return -1;\r\n        }\r\n    }\r\n    for (int i = startPos; i < limit; i++) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            this.result = (byte) (neg ? -val : val);\r\n            return i + delimiter.length;\r\n        }\r\n        if (bytes[i] < 48 || bytes[i] > 57) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\r\n            return -1;\r\n        }\r\n        val *= 10;\r\n        val += bytes[i] - 48;\r\n        if (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\r\n            return -1;\r\n        }\r\n    }\r\n    this.result = (byte) (neg ? -val : val);\r\n    return limit;\r\n}","lc":0.8181818182,"pi":0.3444976077,"ma":1.0,"nbd":0.0,"ml":1.5833333333,"d":2.9384920635,"mi":-0.6166314306,"fo":-0.0833333333,"r":-0.0263157895,"e":4.9590590296}
{"project_name":"Closure","project_version":"66","label":2,"code":"\/**\r\n * This is the meat of the type checking.  It is basically one big switch,\r\n * with each case representing one type of parse tree node.  The individual\r\n * cases are usually pretty straightforward.\r\n *\r\n * @param t The node traversal object that supplies context, such as the\r\n * scope chain to use in name lookups as well as error reporting.\r\n * @param n The node being visited.\r\n * @param parent The parent of the node n.\r\n *\/\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    JSType childType;\r\n    JSType leftType, rightType;\r\n    Node left, right;\r\n    \/\/ To be explicitly set to false if the node is not typeable.\r\n    boolean typeable = true;\r\n    switch(n.getType()) {\r\n        case Token.NAME:\r\n            typeable = visitName(t, n, parent);\r\n            break;\r\n        case Token.LP:\r\n            \/\/ ignored here.\r\n            if (parent.getType() != Token.FUNCTION) {\r\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\r\n            } else {\r\n                typeable = false;\r\n            }\r\n            break;\r\n        case Token.COMMA:\r\n            ensureTyped(t, n, getJSType(n.getLastChild()));\r\n            break;\r\n        case Token.TRUE:\r\n        case Token.FALSE:\r\n            ensureTyped(t, n, BOOLEAN_TYPE);\r\n            break;\r\n        case Token.THIS:\r\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\r\n            break;\r\n        case Token.REF_SPECIAL:\r\n            ensureTyped(t, n);\r\n            break;\r\n        case Token.GET_REF:\r\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\r\n            break;\r\n        case Token.NULL:\r\n            ensureTyped(t, n, NULL_TYPE);\r\n            break;\r\n        case Token.NUMBER:\r\n            ensureTyped(t, n, NUMBER_TYPE);\r\n            break;\r\n        case Token.STRING:\r\n            \/\/ Object literal keys are handled with OBJECTLIT\r\n            if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\r\n                ensureTyped(t, n, STRING_TYPE);\r\n            \/\/ Object literal keys are not typeable\r\n            }\r\n            break;\r\n        case Token.GET:\r\n        case Token.SET:\r\n            \/\/ Object literal keys are handled with OBJECTLIT\r\n            break;\r\n        case Token.ARRAYLIT:\r\n            ensureTyped(t, n, ARRAY_TYPE);\r\n            break;\r\n        case Token.REGEXP:\r\n            ensureTyped(t, n, REGEXP_TYPE);\r\n            break;\r\n        case Token.GETPROP:\r\n            visitGetProp(t, n, parent);\r\n            typeable = !(parent.getType() == Token.ASSIGN && parent.getFirstChild() == n);\r\n            break;\r\n        case Token.GETELEM:\r\n            visitGetElem(t, n);\r\n            \/\/ The type of GETELEM is always unknown, so no point counting that.\r\n            \/\/ If that unknown leaks elsewhere (say by an assignment to another\r\n            \/\/ variable), then it will be counted.\r\n            typeable = false;\r\n            break;\r\n        case Token.VAR:\r\n            visitVar(t, n);\r\n            typeable = false;\r\n            break;\r\n        case Token.NEW:\r\n            visitNew(t, n);\r\n            typeable = true;\r\n            break;\r\n        case Token.CALL:\r\n            visitCall(t, n);\r\n            typeable = !NodeUtil.isExpressionNode(parent);\r\n            break;\r\n        case Token.RETURN:\r\n            visitReturn(t, n);\r\n            typeable = false;\r\n            break;\r\n        case Token.DEC:\r\n        case Token.INC:\r\n            left = n.getFirstChild();\r\n            validator.expectNumber(t, left, getJSType(left), \"increment\/decrement\");\r\n            ensureTyped(t, n, NUMBER_TYPE);\r\n            break;\r\n        case Token.NOT:\r\n            ensureTyped(t, n, BOOLEAN_TYPE);\r\n            break;\r\n        case Token.VOID:\r\n            ensureTyped(t, n, VOID_TYPE);\r\n            break;\r\n        case Token.TYPEOF:\r\n            ensureTyped(t, n, STRING_TYPE);\r\n            break;\r\n        case Token.BITNOT:\r\n            childType = getJSType(n.getFirstChild());\r\n            if (!childType.matchesInt32Context()) {\r\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\r\n            }\r\n            ensureTyped(t, n, NUMBER_TYPE);\r\n            break;\r\n        case Token.POS:\r\n        case Token.NEG:\r\n            left = n.getFirstChild();\r\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\r\n            ensureTyped(t, n, NUMBER_TYPE);\r\n            break;\r\n        case Token.EQ:\r\n        case Token.NE:\r\n            {\r\n                leftType = getJSType(n.getFirstChild());\r\n                rightType = getJSType(n.getLastChild());\r\n                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\r\n                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\r\n                TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted);\r\n                if (result != TernaryValue.UNKNOWN) {\r\n                    if (n.getType() == Token.NE) {\r\n                        result = result.not();\r\n                    }\r\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\r\n                }\r\n                ensureTyped(t, n, BOOLEAN_TYPE);\r\n                break;\r\n            }\r\n        case Token.SHEQ:\r\n        case Token.SHNE:\r\n            {\r\n                leftType = getJSType(n.getFirstChild());\r\n                rightType = getJSType(n.getLastChild());\r\n                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\r\n                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\r\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\r\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\r\n                }\r\n                ensureTyped(t, n, BOOLEAN_TYPE);\r\n                break;\r\n            }\r\n        case Token.LT:\r\n        case Token.LE:\r\n        case Token.GT:\r\n        case Token.GE:\r\n            leftType = getJSType(n.getFirstChild());\r\n            rightType = getJSType(n.getLastChild());\r\n            if (rightType.isNumber()) {\r\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\r\n            } else if (leftType.isNumber()) {\r\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\r\n            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {\r\n            \/\/ OK.\r\n            } else {\r\n                \/\/ Whether the comparison is numeric will be determined at runtime\r\n                \/\/ each time the expression is evaluated. Regardless, both operands\r\n                \/\/ should match a string context.\r\n                String message = \"left side of comparison\";\r\n                validator.expectString(t, n, leftType, message);\r\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\r\n                message = \"right side of comparison\";\r\n                validator.expectString(t, n, rightType, message);\r\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\r\n            }\r\n            ensureTyped(t, n, BOOLEAN_TYPE);\r\n            break;\r\n        case Token.IN:\r\n            left = n.getFirstChild();\r\n            right = n.getLastChild();\r\n            leftType = getJSType(left);\r\n            rightType = getJSType(right);\r\n            validator.expectObject(t, n, rightType, \"'in' requires an object\");\r\n            validator.expectString(t, left, leftType, \"left side of 'in'\");\r\n            ensureTyped(t, n, BOOLEAN_TYPE);\r\n            break;\r\n        case Token.INSTANCEOF:\r\n            left = n.getFirstChild();\r\n            right = n.getLastChild();\r\n            leftType = getJSType(left);\r\n            rightType = getJSType(right).restrictByNotNullOrUndefined();\r\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\r\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\r\n            ensureTyped(t, n, BOOLEAN_TYPE);\r\n            break;\r\n        case Token.ASSIGN:\r\n            visitAssign(t, n);\r\n            typeable = false;\r\n            break;\r\n        case Token.ASSIGN_LSH:\r\n        case Token.ASSIGN_RSH:\r\n        case Token.ASSIGN_URSH:\r\n        case Token.ASSIGN_DIV:\r\n        case Token.ASSIGN_MOD:\r\n        case Token.ASSIGN_BITOR:\r\n        case Token.ASSIGN_BITXOR:\r\n        case Token.ASSIGN_BITAND:\r\n        case Token.ASSIGN_SUB:\r\n        case Token.ASSIGN_ADD:\r\n        case Token.ASSIGN_MUL:\r\n        case Token.LSH:\r\n        case Token.RSH:\r\n        case Token.URSH:\r\n        case Token.DIV:\r\n        case Token.MOD:\r\n        case Token.BITOR:\r\n        case Token.BITXOR:\r\n        case Token.BITAND:\r\n        case Token.SUB:\r\n        case Token.ADD:\r\n        case Token.MUL:\r\n            visitBinaryOperator(n.getType(), t, n);\r\n            break;\r\n        case Token.DELPROP:\r\n            if (!isReference(n.getFirstChild())) {\r\n                report(t, n, BAD_DELETE);\r\n            }\r\n            ensureTyped(t, n, BOOLEAN_TYPE);\r\n            break;\r\n        case Token.CASE:\r\n            JSType switchType = getJSType(parent.getFirstChild());\r\n            JSType caseType = getJSType(n.getFirstChild());\r\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\r\n            typeable = false;\r\n            break;\r\n        case Token.WITH:\r\n            {\r\n                Node child = n.getFirstChild();\r\n                childType = getJSType(child);\r\n                validator.expectObject(t, child, childType, \"with requires an object\");\r\n                typeable = false;\r\n                break;\r\n            }\r\n        case Token.FUNCTION:\r\n            visitFunction(t, n);\r\n            break;\r\n        \/\/ These nodes have no interesting type behavior.\r\n        case Token.LABEL:\r\n        case Token.LABEL_NAME:\r\n        case Token.SWITCH:\r\n        case Token.BREAK:\r\n        case Token.CATCH:\r\n        case Token.TRY:\r\n        case Token.SCRIPT:\r\n        case Token.EXPR_RESULT:\r\n        case Token.BLOCK:\r\n        case Token.EMPTY:\r\n        case Token.DEFAULT:\r\n        case Token.CONTINUE:\r\n        case Token.DEBUGGER:\r\n        case Token.THROW:\r\n            typeable = false;\r\n            break;\r\n        \/\/ These nodes require data flow analysis.\r\n        case Token.DO:\r\n        case Token.FOR:\r\n        case Token.IF:\r\n        case Token.WHILE:\r\n            typeable = false;\r\n            break;\r\n        \/\/ These nodes are typed during the type inference.\r\n        case Token.AND:\r\n        case Token.HOOK:\r\n        case Token.OBJECTLIT:\r\n        case Token.OR:\r\n            if (n.getJSType() != null) {\r\n                \/\/ If we didn't run type inference.\r\n                ensureTyped(t, n);\r\n            } else {\r\n                \/\/ If this is an enum, then give that type to the objectlit as well.\r\n                if ((n.getType() == Token.OBJECTLIT) && (parent.getJSType() instanceof EnumType)) {\r\n                    ensureTyped(t, n, parent.getJSType());\r\n                } else {\r\n                    ensureTyped(t, n);\r\n                }\r\n            }\r\n            if (n.getType() == Token.OBJECTLIT) {\r\n                for (Node key : n.children()) {\r\n                    visitObjLitKey(t, key, n);\r\n                }\r\n            }\r\n            break;\r\n        default:\r\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\r\n            ensureTyped(t, n);\r\n            break;\r\n    }\r\n    \/\/ Don't count externs since the user's code may not even use that part.\r\n    typeable = typeable && !inExterns;\r\n    if (typeable) {\r\n        doPercentTypedAccounting(t, n);\r\n    }\r\n    checkNoTypeCheckSection(n, false);\r\n}","code_comment":"\/**\r\n * This is the meat of the type checking.  It is basically one big switch,\r\n * with each case representing one type of parse tree node.  The individual\r\n * cases are usually pretty straightforward.\r\n *\r\n * @param t The node traversal object that supplies context, such as the\r\n * scope chain to use in name lookups as well as error reporting.\r\n * @param n The node being visited.\r\n * @param parent The parent of the node n.\r\n *\/\r\n","code_no_comment":"public void visit(NodeTraversal t, Node n, Node parent) {\r\n    JSType childType;\r\n    JSType leftType, rightType;\r\n    Node left, right;\r\n        boolean typeable = true;\r\n    switch(n.getType()) {\r\n        case Token.NAME:\r\n            typeable = visitName(t, n, parent);\r\n            break;\r\n        case Token.LP:\r\n                        if (parent.getType() != Token.FUNCTION) {\r\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\r\n            } else {\r\n                typeable = false;\r\n            }\r\n            break;\r\n        case Token.COMMA:\r\n            ensureTyped(t, n, getJSType(n.getLastChild()));\r\n            break;\r\n        case Token.TRUE:\r\n        case Token.FALSE:\r\n            ensureTyped(t, n, BOOLEAN_TYPE);\r\n            break;\r\n        case Token.THIS:\r\n            ensureTyped(t, n, t.getScope().getTypeOfThis());\r\n            break;\r\n        case Token.REF_SPECIAL:\r\n            ensureTyped(t, n);\r\n            break;\r\n        case Token.GET_REF:\r\n            ensureTyped(t, n, getJSType(n.getFirstChild()));\r\n            break;\r\n        case Token.NULL:\r\n            ensureTyped(t, n, NULL_TYPE);\r\n            break;\r\n        case Token.NUMBER:\r\n            ensureTyped(t, n, NUMBER_TYPE);\r\n            break;\r\n        case Token.STRING:\r\n                        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\r\n                ensureTyped(t, n, STRING_TYPE);\r\n                        }\r\n            break;\r\n        case Token.GET:\r\n        case Token.SET:\r\n                        break;\r\n        case Token.ARRAYLIT:\r\n            ensureTyped(t, n, ARRAY_TYPE);\r\n            break;\r\n        case Token.REGEXP:\r\n            ensureTyped(t, n, REGEXP_TYPE);\r\n            break;\r\n        case Token.GETPROP:\r\n            visitGetProp(t, n, parent);\r\n            typeable = !(parent.getType() == Token.ASSIGN && parent.getFirstChild() == n);\r\n            break;\r\n        case Token.GETELEM:\r\n            visitGetElem(t, n);\r\n                                                typeable = false;\r\n            break;\r\n        case Token.VAR:\r\n            visitVar(t, n);\r\n            typeable = false;\r\n            break;\r\n        case Token.NEW:\r\n            visitNew(t, n);\r\n            typeable = true;\r\n            break;\r\n        case Token.CALL:\r\n            visitCall(t, n);\r\n            typeable = !NodeUtil.isExpressionNode(parent);\r\n            break;\r\n        case Token.RETURN:\r\n            visitReturn(t, n);\r\n            typeable = false;\r\n            break;\r\n        case Token.DEC:\r\n        case Token.INC:\r\n            left = n.getFirstChild();\r\n            validator.expectNumber(t, left, getJSType(left), \"increment\/decrement\");\r\n            ensureTyped(t, n, NUMBER_TYPE);\r\n            break;\r\n        case Token.NOT:\r\n            ensureTyped(t, n, BOOLEAN_TYPE);\r\n            break;\r\n        case Token.VOID:\r\n            ensureTyped(t, n, VOID_TYPE);\r\n            break;\r\n        case Token.TYPEOF:\r\n            ensureTyped(t, n, STRING_TYPE);\r\n            break;\r\n        case Token.BITNOT:\r\n            childType = getJSType(n.getFirstChild());\r\n            if (!childType.matchesInt32Context()) {\r\n                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());\r\n            }\r\n            ensureTyped(t, n, NUMBER_TYPE);\r\n            break;\r\n        case Token.POS:\r\n        case Token.NEG:\r\n            left = n.getFirstChild();\r\n            validator.expectNumber(t, left, getJSType(left), \"sign operator\");\r\n            ensureTyped(t, n, NUMBER_TYPE);\r\n            break;\r\n        case Token.EQ:\r\n        case Token.NE:\r\n            {\r\n                leftType = getJSType(n.getFirstChild());\r\n                rightType = getJSType(n.getLastChild());\r\n                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\r\n                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\r\n                TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted);\r\n                if (result != TernaryValue.UNKNOWN) {\r\n                    if (n.getType() == Token.NE) {\r\n                        result = result.not();\r\n                    }\r\n                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\r\n                }\r\n                ensureTyped(t, n, BOOLEAN_TYPE);\r\n                break;\r\n            }\r\n        case Token.SHEQ:\r\n        case Token.SHNE:\r\n            {\r\n                leftType = getJSType(n.getFirstChild());\r\n                rightType = getJSType(n.getLastChild());\r\n                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\r\n                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\r\n                if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\r\n                    report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\r\n                }\r\n                ensureTyped(t, n, BOOLEAN_TYPE);\r\n                break;\r\n            }\r\n        case Token.LT:\r\n        case Token.LE:\r\n        case Token.GT:\r\n        case Token.GE:\r\n            leftType = getJSType(n.getFirstChild());\r\n            rightType = getJSType(n.getLastChild());\r\n            if (rightType.isNumber()) {\r\n                validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\r\n            } else if (leftType.isNumber()) {\r\n                validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\r\n            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {\r\n                        } else {\r\n                                                                String message = \"left side of comparison\";\r\n                validator.expectString(t, n, leftType, message);\r\n                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));\r\n                message = \"right side of comparison\";\r\n                validator.expectString(t, n, rightType, message);\r\n                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));\r\n            }\r\n            ensureTyped(t, n, BOOLEAN_TYPE);\r\n            break;\r\n        case Token.IN:\r\n            left = n.getFirstChild();\r\n            right = n.getLastChild();\r\n            leftType = getJSType(left);\r\n            rightType = getJSType(right);\r\n            validator.expectObject(t, n, rightType, \"'in' requires an object\");\r\n            validator.expectString(t, left, leftType, \"left side of 'in'\");\r\n            ensureTyped(t, n, BOOLEAN_TYPE);\r\n            break;\r\n        case Token.INSTANCEOF:\r\n            left = n.getFirstChild();\r\n            right = n.getLastChild();\r\n            leftType = getJSType(left);\r\n            rightType = getJSType(right).restrictByNotNullOrUndefined();\r\n            validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\r\n            validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\r\n            ensureTyped(t, n, BOOLEAN_TYPE);\r\n            break;\r\n        case Token.ASSIGN:\r\n            visitAssign(t, n);\r\n            typeable = false;\r\n            break;\r\n        case Token.ASSIGN_LSH:\r\n        case Token.ASSIGN_RSH:\r\n        case Token.ASSIGN_URSH:\r\n        case Token.ASSIGN_DIV:\r\n        case Token.ASSIGN_MOD:\r\n        case Token.ASSIGN_BITOR:\r\n        case Token.ASSIGN_BITXOR:\r\n        case Token.ASSIGN_BITAND:\r\n        case Token.ASSIGN_SUB:\r\n        case Token.ASSIGN_ADD:\r\n        case Token.ASSIGN_MUL:\r\n        case Token.LSH:\r\n        case Token.RSH:\r\n        case Token.URSH:\r\n        case Token.DIV:\r\n        case Token.MOD:\r\n        case Token.BITOR:\r\n        case Token.BITXOR:\r\n        case Token.BITAND:\r\n        case Token.SUB:\r\n        case Token.ADD:\r\n        case Token.MUL:\r\n            visitBinaryOperator(n.getType(), t, n);\r\n            break;\r\n        case Token.DELPROP:\r\n            if (!isReference(n.getFirstChild())) {\r\n                report(t, n, BAD_DELETE);\r\n            }\r\n            ensureTyped(t, n, BOOLEAN_TYPE);\r\n            break;\r\n        case Token.CASE:\r\n            JSType switchType = getJSType(parent.getFirstChild());\r\n            JSType caseType = getJSType(n.getFirstChild());\r\n            validator.expectSwitchMatchesCase(t, n, switchType, caseType);\r\n            typeable = false;\r\n            break;\r\n        case Token.WITH:\r\n            {\r\n                Node child = n.getFirstChild();\r\n                childType = getJSType(child);\r\n                validator.expectObject(t, child, childType, \"with requires an object\");\r\n                typeable = false;\r\n                break;\r\n            }\r\n        case Token.FUNCTION:\r\n            visitFunction(t, n);\r\n            break;\r\n                case Token.LABEL:\r\n        case Token.LABEL_NAME:\r\n        case Token.SWITCH:\r\n        case Token.BREAK:\r\n        case Token.CATCH:\r\n        case Token.TRY:\r\n        case Token.SCRIPT:\r\n        case Token.EXPR_RESULT:\r\n        case Token.BLOCK:\r\n        case Token.EMPTY:\r\n        case Token.DEFAULT:\r\n        case Token.CONTINUE:\r\n        case Token.DEBUGGER:\r\n        case Token.THROW:\r\n            typeable = false;\r\n            break;\r\n                case Token.DO:\r\n        case Token.FOR:\r\n        case Token.IF:\r\n        case Token.WHILE:\r\n            typeable = false;\r\n            break;\r\n                case Token.AND:\r\n        case Token.HOOK:\r\n        case Token.OBJECTLIT:\r\n        case Token.OR:\r\n            if (n.getJSType() != null) {\r\n                                ensureTyped(t, n);\r\n            } else {\r\n                                if ((n.getType() == Token.OBJECTLIT) && (parent.getJSType() instanceof EnumType)) {\r\n                    ensureTyped(t, n, parent.getJSType());\r\n                } else {\r\n                    ensureTyped(t, n);\r\n                }\r\n            }\r\n            if (n.getType() == Token.OBJECTLIT) {\r\n                for (Node key : n.children()) {\r\n                    visitObjLitKey(t, key, n);\r\n                }\r\n            }\r\n            break;\r\n        default:\r\n            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\r\n            ensureTyped(t, n);\r\n            break;\r\n    }\r\n        typeable = typeable && !inExterns;\r\n    if (typeable) {\r\n        doPercentTypedAccounting(t, n);\r\n    }\r\n    checkNoTypeCheckSection(n, false);\r\n}","lc":11.9090909091,"pi":0.2535885167,"ma":28.2,"nbd":1.5,"ml":9.75,"d":1.0595238095,"mi":-2.7942212826,"fo":11.25,"r":-0.0263157895,"e":18.3873607533}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-434_133cbc2d","label":1,"code":"\/**\r\n * Create the tableau by itself.\r\n * @param maximize if true, goal is to maximize the objective function\r\n * @return created tableau\r\n *\/\r\nprotected RealMatrix createTableau(final boolean maximize) {\r\n    \/\/ create a matrix of the correct size\r\n    int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + \/\/ + 1 is for RHS\r\n    1;\r\n    int height = constraints.size() + getNumObjectiveFunctions();\r\n    Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);\r\n    \/\/ initialize the objective function rows\r\n    if (getNumObjectiveFunctions() == 2) {\r\n        matrix.setEntry(0, 0, -1);\r\n    }\r\n    int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\r\n    matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);\r\n    RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\r\n    copyArray(objectiveCoefficients.getData(), matrix.getDataRef()[zIndex]);\r\n    matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());\r\n    if (!restrictToNonNegative) {\r\n        matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoeffiecientSum(objectiveCoefficients));\r\n    }\r\n    \/\/ initialize the constraint rows\r\n    int slackVar = 0;\r\n    int artificialVar = 0;\r\n    for (int i = 0; i < constraints.size(); i++) {\r\n        LinearConstraint constraint = constraints.get(i);\r\n        int row = getNumObjectiveFunctions() + i;\r\n        \/\/ decision variable coefficients\r\n        copyArray(constraint.getCoefficients().getData(), matrix.getDataRef()[row]);\r\n        \/\/ x-\r\n        if (!restrictToNonNegative) {\r\n            matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoeffiecientSum(constraint.getCoefficients()));\r\n        }\r\n        \/\/ RHS\r\n        matrix.setEntry(row, width - 1, constraint.getValue());\r\n        \/\/ slack variables\r\n        if (constraint.getRelationship() == Relationship.LEQ) {\r\n            \/\/ slack\r\n            matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);\r\n        } else if (constraint.getRelationship() == Relationship.GEQ) {\r\n            \/\/ excess\r\n            matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1);\r\n        }\r\n        \/\/ artificial variables\r\n        if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {\r\n            matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);\r\n            matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);\r\n            matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));\r\n        }\r\n    }\r\n    return matrix;\r\n}","code_comment":"\/**\r\n * Create the tableau by itself.\r\n * @param maximize if true, goal is to maximize the objective function\r\n * @return created tableau\r\n *\/\r\n","code_no_comment":"protected RealMatrix createTableau(final boolean maximize) {\r\n        int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() +     1;\r\n    int height = constraints.size() + getNumObjectiveFunctions();\r\n    Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);\r\n        if (getNumObjectiveFunctions() == 2) {\r\n        matrix.setEntry(0, 0, -1);\r\n    }\r\n    int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\r\n    matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);\r\n    RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\r\n    copyArray(objectiveCoefficients.getData(), matrix.getDataRef()[zIndex]);\r\n    matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());\r\n    if (!restrictToNonNegative) {\r\n        matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoeffiecientSum(objectiveCoefficients));\r\n    }\r\n        int slackVar = 0;\r\n    int artificialVar = 0;\r\n    for (int i = 0; i < constraints.size(); i++) {\r\n        LinearConstraint constraint = constraints.get(i);\r\n        int row = getNumObjectiveFunctions() + i;\r\n                copyArray(constraint.getCoefficients().getData(), matrix.getDataRef()[row]);\r\n                if (!restrictToNonNegative) {\r\n            matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoeffiecientSum(constraint.getCoefficients()));\r\n        }\r\n                matrix.setEntry(row, width - 1, constraint.getValue());\r\n                if (constraint.getRelationship() == Relationship.LEQ) {\r\n                        matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);\r\n        } else if (constraint.getRelationship() == Relationship.GEQ) {\r\n                        matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1);\r\n        }\r\n                if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {\r\n            matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);\r\n            matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);\r\n            matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));\r\n        }\r\n    }\r\n    return matrix;\r\n}","lc":1.1363636364,"pi":0.1148325359,"ma":1.6,"nbd":0.5,"ml":1.0833333333,"d":2.3472222222,"mi":-0.8119802678,"fo":3.5,"r":-0.0263157895,"e":7.3713363646}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2057_e2d88568","label":1,"code":"\/**\r\n *  @see org.apache.wicket.ajax.IAjaxCallDecorator#decorateScript(CharSequence)\r\n *\/\r\npublic CharSequence decorateScript(CharSequence script) {\r\n    CharSequence s = (delegate == null) ? script : delegate.decorateScript(script);\r\n    return preDecorateScript(s);\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.ajax.IAjaxCallDecorator#decorateScript(CharSequence)\r\n *\/\r\n","code_no_comment":"public CharSequence decorateScript(CharSequence script) {\r\n    CharSequence s = (delegate == null) ? script : delegate.decorateScript(script);\r\n    return preDecorateScript(s);\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":0.0079365079,"mi":0.7403805497,"fo":-0.3333333333,"r":2.3947368421,"e":-0.1139745163}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-276_1bf5c550","label":1,"code":"private boolean touch(Id id, long timeMillis) throws Exception {\r\n    Timestamp ts = new Timestamp(timeMillis);\r\n    Connection con = cp.getConnection();\r\n    try {\r\n        PreparedStatement stmt = con.prepareStatement(\"update REVS set TIME = ? where ID = ? and TIME < ?\");\r\n        try {\r\n            stmt.setTimestamp(1, ts);\r\n            stmt.setBytes(2, id.getBytes());\r\n            stmt.setTimestamp(3, ts);\r\n            return stmt.executeUpdate() == 1;\r\n        } finally {\r\n            stmt.close();\r\n        }\r\n    } finally {\r\n        con.close();\r\n    }\r\n}","code_comment":null,"code_no_comment":"private boolean touch(Id id, long timeMillis) throws Exception {\r\n    Timestamp ts = new Timestamp(timeMillis);\r\n    Connection con = cp.getConnection();\r\n    try {\r\n        PreparedStatement stmt = con.prepareStatement(\"update REVS set TIME = ? where ID = ? and TIME < ?\");\r\n        try {\r\n            stmt.setTimestamp(1, ts);\r\n            stmt.setBytes(2, id.getBytes());\r\n            stmt.setTimestamp(3, ts);\r\n            return stmt.executeUpdate() == 1;\r\n        } finally {\r\n            stmt.close();\r\n        }\r\n    } finally {\r\n        con.close();\r\n    }\r\n}","lc":0.1363636364,"pi":0.4880382775,"ma":-0.6,"nbd":0.0,"ml":-0.4166666667,"d":-0.0436507937,"mi":-0.1007751938,"fo":0.25,"r":0.0,"e":-0.0113714032}
{"project_name":"Cli","project_version":"18","label":1,"code":"private void processSingleHyphen(String hyphen) {\r\n    tokens.add(hyphen);\r\n}","code_comment":null,"code_no_comment":"private void processSingleHyphen(String hyphen) {\r\n    tokens.add(hyphen);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0451021846,"fo":-0.4166666667,"r":1.8421052632,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4837_3fca2bb2","label":3,"code":"private boolean isQualifiedForInterpolation(Field field, Class<?> fieldType) {\r\n    Boolean primitive = fieldIsPrimitiveByClass.get(fieldType);\r\n    if (primitive == null) {\r\n        primitive = fieldType.isPrimitive();\r\n        fieldIsPrimitiveByClass.put(fieldType, primitive);\r\n    }\r\n    if (primitive) {\r\n        return false;\r\n    }\r\n    return !\"parent\".equals(field.getName());\r\n}","code_comment":null,"code_no_comment":"private boolean isQualifiedForInterpolation(Field field, Class<?> fieldType) {\r\n    Boolean primitive = fieldIsPrimitiveByClass.get(fieldType);\r\n    if (primitive == null) {\r\n        primitive = fieldType.isPrimitive();\r\n        fieldIsPrimitiveByClass.put(fieldType, primitive);\r\n    }\r\n    if (primitive) {\r\n        return false;\r\n    }\r\n    return !\"parent\".equals(field.getName());\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0615079365,"mi":0.1501057082,"fo":-0.0833333333,"r":0.0526315789,"e":-0.0713703659}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5796_de6dd425","label":1,"code":"\/**\r\n * Inspects the given definition and resolves any property placeholders from its properties.\r\n * <p\/>\r\n * This implementation will check all the getter\/setter pairs on this instance and for all the values\r\n * (which is a String type) will be property placeholder resolved.\r\n *\r\n * @param routeContext the route context\r\n * @param definition   the definition\r\n * @throws Exception is thrown if property placeholders was used and there was an error resolving them\r\n * @see org.apache.camel.CamelContext#resolvePropertyPlaceholders(String)\r\n * @see org.apache.camel.component.properties.PropertiesComponent\r\n *\/\r\nprotected void resolvePropertyPlaceholders(RouteContext routeContext, Object definition) throws Exception {\r\n    log.trace(\"Resolving property placeholders for: {}\", definition);\r\n    \/\/ find all getter\/setter which we can use for property placeholders\r\n    Map<String, Object> properties = new HashMap<String, Object>();\r\n    IntrospectionSupport.getProperties(definition, properties, null);\r\n    ProcessorDefinition<?> processorDefinition = null;\r\n    if (definition instanceof ProcessorDefinition) {\r\n        processorDefinition = (ProcessorDefinition<?>) definition;\r\n    }\r\n    \/\/ and when the definition parameter is this (otherAttributes belong to this)\r\n    if (processorDefinition != null && processorDefinition.getOtherAttributes() != null) {\r\n        for (Object key : processorDefinition.getOtherAttributes().keySet()) {\r\n            QName qname = (QName) key;\r\n            if (Constants.PLACEHOLDER_QNAME.equals(qname.getNamespaceURI())) {\r\n                String local = qname.getLocalPart();\r\n                Object value = processorDefinition.getOtherAttributes().get(key);\r\n                if (value != null && value instanceof String) {\r\n                    \/\/ value must be enclosed with placeholder tokens\r\n                    String s = (String) value;\r\n                    String prefixToken = routeContext.getCamelContext().getPropertyPrefixToken();\r\n                    String suffixToken = routeContext.getCamelContext().getPropertySuffixToken();\r\n                    if (prefixToken == null) {\r\n                        throw new IllegalArgumentException(\"Property with name [\" + local + \"] uses property placeholders; however, no properties component is configured.\");\r\n                    }\r\n                    if (!s.startsWith(prefixToken)) {\r\n                        s = prefixToken + s;\r\n                    }\r\n                    if (!s.endsWith(suffixToken)) {\r\n                        s = s + suffixToken;\r\n                    }\r\n                    value = s;\r\n                }\r\n                properties.put(local, value);\r\n            }\r\n        }\r\n    }\r\n    if (!properties.isEmpty()) {\r\n        log.trace(\"There are {} properties on: {}\", properties.size(), definition);\r\n        \/\/ lookup and resolve properties for String based properties\r\n        for (Map.Entry<String, Object> entry : properties.entrySet()) {\r\n            \/\/ the name is always a String\r\n            String name = entry.getKey();\r\n            Object value = entry.getValue();\r\n            if (value instanceof String) {\r\n                \/\/ value must be a String, as a String is the key for a property placeholder\r\n                String text = (String) value;\r\n                text = routeContext.getCamelContext().resolvePropertyPlaceholders(text);\r\n                if (text != value) {\r\n                    \/\/ invoke setter as the text has changed\r\n                    boolean changed = IntrospectionSupport.setProperty(routeContext.getCamelContext().getTypeConverter(), definition, name, text);\r\n                    if (!changed) {\r\n                        throw new IllegalArgumentException(\"No setter to set property: \" + name + \" to: \" + text + \" on: \" + definition);\r\n                    }\r\n                    if (log.isDebugEnabled()) {\r\n                        log.debug(\"Changed property [{}] from: {} to: {}\", new Object[] { name, value, text });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Inspects the given definition and resolves any property placeholders from its properties.\r\n * <p\/>\r\n * This implementation will check all the getter\/setter pairs on this instance and for all the values\r\n * (which is a String type) will be property placeholder resolved.\r\n *\r\n * @param routeContext the route context\r\n * @param definition   the definition\r\n * @throws Exception is thrown if property placeholders was used and there was an error resolving them\r\n * @see org.apache.camel.CamelContext#resolvePropertyPlaceholders(String)\r\n * @see org.apache.camel.component.properties.PropertiesComponent\r\n *\/\r\n","code_no_comment":"protected void resolvePropertyPlaceholders(RouteContext routeContext, Object definition) throws Exception {\r\n    log.trace(\"Resolving property placeholders for: {}\", definition);\r\n        Map<String, Object> properties = new HashMap<String, Object>();\r\n    IntrospectionSupport.getProperties(definition, properties, null);\r\n    ProcessorDefinition<?> processorDefinition = null;\r\n    if (definition instanceof ProcessorDefinition) {\r\n        processorDefinition = (ProcessorDefinition<?>) definition;\r\n    }\r\n        if (processorDefinition != null && processorDefinition.getOtherAttributes() != null) {\r\n        for (Object key : processorDefinition.getOtherAttributes().keySet()) {\r\n            QName qname = (QName) key;\r\n            if (Constants.PLACEHOLDER_QNAME.equals(qname.getNamespaceURI())) {\r\n                String local = qname.getLocalPart();\r\n                Object value = processorDefinition.getOtherAttributes().get(key);\r\n                if (value != null && value instanceof String) {\r\n                                        String s = (String) value;\r\n                    String prefixToken = routeContext.getCamelContext().getPropertyPrefixToken();\r\n                    String suffixToken = routeContext.getCamelContext().getPropertySuffixToken();\r\n                    if (prefixToken == null) {\r\n                        throw new IllegalArgumentException(\"Property with name [\" + local + \"] uses property placeholders; however, no properties component is configured.\");\r\n                    }\r\n                    if (!s.startsWith(prefixToken)) {\r\n                        s = prefixToken + s;\r\n                    }\r\n                    if (!s.endsWith(suffixToken)) {\r\n                        s = s + suffixToken;\r\n                    }\r\n                    value = s;\r\n                }\r\n                properties.put(local, value);\r\n            }\r\n        }\r\n    }\r\n    if (!properties.isEmpty()) {\r\n        log.trace(\"There are {} properties on: {}\", properties.size(), definition);\r\n                for (Map.Entry<String, Object> entry : properties.entrySet()) {\r\n                        String name = entry.getKey();\r\n            Object value = entry.getValue();\r\n            if (value instanceof String) {\r\n                                String text = (String) value;\r\n                text = routeContext.getCamelContext().resolvePropertyPlaceholders(text);\r\n                if (text != value) {\r\n                                        boolean changed = IntrospectionSupport.setProperty(routeContext.getCamelContext().getTypeConverter(), definition, name, text);\r\n                    if (!changed) {\r\n                        throw new IllegalArgumentException(\"No setter to set property: \" + name + \" to: \" + text + \" on: \" + definition);\r\n                    }\r\n                    if (log.isDebugEnabled()) {\r\n                        log.debug(\"Changed property [{}] from: {} to: {}\", new Object[] { name, value, text });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","lc":1.8181818182,"pi":1.956937799,"ma":2.6,"nbd":1.5,"ml":1.9166666667,"d":1.1845238095,"mi":-0.9932346723,"fo":2.0,"r":-0.0263157895,"e":4.1479250589}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3740_f2f5bd5b","label":1,"code":"@Override\r\npublic final void close() throws Exception {\r\n    super.close();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic final void close() throws Exception {\r\n    super.close();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0005637773,"fo":-0.4166666667,"r":1.9210526316,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1008_0c20bfd8","label":1,"code":"\/**\r\n * Finds matching classes within a jar files that contains a folder structure\r\n * matching the package structure.  If the File is not a JarFile or does not exist a warning\r\n * will be logged, but no error will be raised.\r\n *\r\n * @param test a Test used to filter the classes that are discovered\r\n * @param parent the parent package under which classes must be in order to be considered\r\n * @param jarFile the jar file to be examined for classes\r\n *\/\r\nprivate void loadImplementationsInJar(final Test test, final String parent, final File jarFile) {\r\n    @SuppressWarnings(\"resource\")\r\n    JarInputStream jarStream = null;\r\n    try {\r\n        jarStream = new JarInputStream(new FileInputStream(jarFile));\r\n        loadImplementationsInJar(test, parent, jarFile.getPath(), jarStream);\r\n    } catch (final FileNotFoundException ex) {\r\n        LOGGER.error(\"Could not search jar file '\" + jarFile + \"' for classes matching criteria: \" + test + \" file not found\", ex);\r\n    } catch (final IOException ioe) {\r\n        LOGGER.error(\"Could not search jar file '\" + jarFile + \"' for classes matching criteria: \" + test + \" due to an IOException\", ioe);\r\n    } finally {\r\n        close(jarStream, jarFile);\r\n    }\r\n}","code_comment":"\/**\r\n * Finds matching classes within a jar files that contains a folder structure\r\n * matching the package structure.  If the File is not a JarFile or does not exist a warning\r\n * will be logged, but no error will be raised.\r\n *\r\n * @param test a Test used to filter the classes that are discovered\r\n * @param parent the parent package under which classes must be in order to be considered\r\n * @param jarFile the jar file to be examined for classes\r\n *\/\r\n","code_no_comment":"private void loadImplementationsInJar(final Test test, final String parent, final File jarFile) {\r\n    @SuppressWarnings(\"resource\")\r\n    JarInputStream jarStream = null;\r\n    try {\r\n        jarStream = new JarInputStream(new FileInputStream(jarFile));\r\n        loadImplementationsInJar(test, parent, jarFile.getPath(), jarStream);\r\n    } catch (final FileNotFoundException ex) {\r\n        LOGGER.error(\"Could not search jar file '\" + jarFile + \"' for classes matching criteria: \" + test + \" file not found\", ex);\r\n    } catch (final IOException ioe) {\r\n        LOGGER.error(\"Could not search jar file '\" + jarFile + \"' for classes matching criteria: \" + test + \" due to an IOException\", ioe);\r\n    } finally {\r\n        close(jarStream, jarFile);\r\n    }\r\n}","lc":0.0,"pi":-0.1387559809,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.0138888889,"mi":-0.0505990134,"fo":-0.0833333333,"r":0.0,"e":0.0332705175}
{"project_name":"Math","project_version":"37","label":3,"code":"\/**\r\n * Compute the\r\n * <a href=\"http:\/\/mathworld.wolfram.com\/Tangent.html\" TARGET=\"_top\">\r\n * tangent<\/a> of this complex number.\r\n * Implements the formula:\r\n * <pre>\r\n *  <code>\r\n *   tan(a + bi) = sin(2a)\/(cos(2a)+cosh(2b)) + [sinh(2b)\/(cos(2a)+cosh(2b))]i\r\n *  <\/code>\r\n * <\/pre>\r\n * where the (real) functions on the right-hand side are\r\n * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\r\n * {@link FastMath#sinh}.\r\n * <br\/>\r\n * Returns {@link Complex#NaN} if either real or imaginary part of the\r\n * input argument is {@code NaN}.\r\n * <br\/>\r\n * Infinite (or critical) values in real or imaginary parts of the input may\r\n * result in infinite or NaN values returned in parts of the result.\r\n * <pre>\r\n *  Examples:\r\n *  <code>\r\n *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i\r\n *   tan(&plusmn;INFINITY + bi) = NaN + NaN i\r\n *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\r\n *   tan(&plusmn;&pi;\/2 + 0 i) = &plusmn;INFINITY + NaN i\r\n *  <\/code>\r\n * <\/pre>\r\n *\r\n * @return the tangent of {@code this}.\r\n * @since 1.2\r\n *\/\r\npublic Complex tan() {\r\n    if (isNaN) {\r\n        return NaN;\r\n    }\r\n    double real2 = 2.0 * real;\r\n    double imaginary2 = 2.0 * imaginary;\r\n    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\r\n    return createComplex(FastMath.sin(real2) \/ d, FastMath.sinh(imaginary2) \/ d);\r\n}","code_comment":"\/**\r\n * Compute the\r\n * <a href=\"http:\/\/mathworld.wolfram.com\/Tangent.html\" TARGET=\"_top\">\r\n * tangent<\/a> of this complex number.\r\n * Implements the formula:\r\n * <pre>\r\n *  <code>\r\n *   tan(a + bi) = sin(2a)\/(cos(2a)+cosh(2b)) + [sinh(2b)\/(cos(2a)+cosh(2b))]i\r\n *  <\/code>\r\n * <\/pre>\r\n * where the (real) functions on the right-hand side are\r\n * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\r\n * {@link FastMath#sinh}.\r\n * <br\/>\r\n * Returns {@link Complex#NaN} if either real or imaginary part of the\r\n * input argument is {@code NaN}.\r\n * <br\/>\r\n * Infinite (or critical) values in real or imaginary parts of the input may\r\n * result in infinite or NaN values returned in parts of the result.\r\n * <pre>\r\n *  Examples:\r\n *  <code>\r\n *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i\r\n *   tan(&plusmn;INFINITY + bi) = NaN + NaN i\r\n *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\r\n *   tan(&plusmn;&pi;\/2 + 0 i) = &plusmn;INFINITY + NaN i\r\n *  <\/code>\r\n * <\/pre>\r\n *\r\n * @return the tangent of {@code this}.\r\n * @since 1.2\r\n *\/\r\n","code_no_comment":"public Complex tan() {\r\n    if (isNaN) {\r\n        return NaN;\r\n    }\r\n    double real2 = 2.0 * real;\r\n    double imaginary2 = 2.0 * imaginary;\r\n    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\r\n    return createComplex(FastMath.sin(real2) \/ d, FastMath.sinh(imaginary2) \/ d);\r\n}","lc":-0.2272727273,"pi":-0.3444976077,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.2658730159,"mi":0.2231148696,"fo":-0.0833333333,"r":0.7105263158,"e":0.0623387101}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-880_2a9cbbab","label":1,"code":"\/**\r\n * Mark the outgoing edge as processed.\r\n *\/\r\npublic void outgoingProcessed() {\r\n    outgoingNeedsProcessing = false;\r\n}","code_comment":"\/**\r\n * Mark the outgoing edge as processed.\r\n *\/\r\n","code_no_comment":"public void outgoingProcessed() {\r\n    outgoingNeedsProcessing = false;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2882_ebe56869","label":1,"code":"\/**\r\n *  @param child\r\n *             Component being added\r\n *\/\r\nprivate final void addedComponent(final Component child) {\r\n    \/\/ Check for degenerate case\r\n    if (child == this) {\r\n        throw new IllegalArgumentException(\"Component can't be added to itself\");\r\n    }\r\n    MarkupContainer parent = child.getParent();\r\n    if (parent != null) {\r\n        parent.remove(child);\r\n    }\r\n    \/\/ Set child's parent\r\n    child.setParent(this);\r\n    final IDebugSettings debugSettings = Application.get().getDebugSettings();\r\n    if (debugSettings.isLinePreciseReportingOnAddComponentEnabled()) {\r\n        child.setMetaData(ADDED_AT_KEY, ComponentStrings.toString(child, new MarkupException(\"added\")));\r\n    }\r\n    final Page page = findPage();\r\n    if (page != null) {\r\n        child.initialize();\r\n    }\r\n    if (page != null) {\r\n        \/\/ Tell the page a component has been added\r\n        page.componentAdded(child);\r\n    }\r\n    \/\/ beforeRender on this component's children. So we need to initialize the newly added one\r\n    if (isPreparedForRender()) {\r\n        child.beforeRender();\r\n    }\r\n}","code_comment":"\/**\r\n *  @param child\r\n *             Component being added\r\n *\/\r\n","code_no_comment":"private final void addedComponent(final Component child) {\r\n        if (child == this) {\r\n        throw new IllegalArgumentException(\"Component can't be added to itself\");\r\n    }\r\n    MarkupContainer parent = child.getParent();\r\n    if (parent != null) {\r\n        parent.remove(child);\r\n    }\r\n        child.setParent(this);\r\n    final IDebugSettings debugSettings = Application.get().getDebugSettings();\r\n    if (debugSettings.isLinePreciseReportingOnAddComponentEnabled()) {\r\n        child.setMetaData(ADDED_AT_KEY, ComponentStrings.toString(child, new MarkupException(\"added\")));\r\n    }\r\n    final Page page = findPage();\r\n    if (page != null) {\r\n        child.initialize();\r\n    }\r\n    if (page != null) {\r\n                page.componentAdded(child);\r\n    }\r\n        if (isPreparedForRender()) {\r\n        child.beforeRender();\r\n    }\r\n}","lc":0.4545454545,"pi":-0.3732057416,"ma":0.8,"nbd":-0.5,"ml":0.5,"d":-0.0575396825,"mi":-0.3513742072,"fo":0.5833333333,"r":-0.0263157895,"e":0.0369495686}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7146_b6981cfd","label":3,"code":"protected Exchange onCompletion(final String key, final Exchange original, final Exchange aggregated, boolean fromTimeout) {\r\n    \/\/ store the correlation key as property before we remove so the repository has that information\r\n    if (original != null) {\r\n        original.setProperty(Exchange.AGGREGATED_CORRELATION_KEY, key);\r\n    }\r\n    aggregated.setProperty(Exchange.AGGREGATED_CORRELATION_KEY, key);\r\n    \/\/ remove from repository as its completed, we do this first as to trigger any OptimisticLockingException's\r\n    aggregationRepository.remove(aggregated.getContext(), key, original);\r\n    if (!fromTimeout && timeoutMap != null) {\r\n        \/\/ cleanup timeout map if it was a incoming exchange which triggered the timeout (and not the timeout checker)\r\n        timeoutMap.remove(key);\r\n    }\r\n    \/\/ this key has been closed so add it to the closed map\r\n    if (closedCorrelationKeys != null) {\r\n        closedCorrelationKeys.put(key, key);\r\n    }\r\n    if (fromTimeout) {\r\n        \/\/ to allow any custom processing before discarding the exchange\r\n        if (aggregationStrategy instanceof TimeoutAwareAggregationStrategy) {\r\n            long timeout = getCompletionTimeout() > 0 ? getCompletionTimeout() : -1;\r\n            ((TimeoutAwareAggregationStrategy) aggregationStrategy).timeout(aggregated, -1, -1, timeout);\r\n        }\r\n    }\r\n    Exchange answer;\r\n    if (fromTimeout && isDiscardOnCompletionTimeout()) {\r\n        \/\/ discard due timeout\r\n        LOG.debug(\"Aggregation for correlation key {} discarding aggregated exchange: {}\", key, aggregated);\r\n        \/\/ must confirm the discarded exchange\r\n        aggregationRepository.confirm(aggregated.getContext(), aggregated.getExchangeId());\r\n        \/\/ and remove redelivery state as well\r\n        redeliveryState.remove(aggregated.getExchangeId());\r\n        \/\/ the completion was from timeout and we should just discard it\r\n        answer = null;\r\n    } else {\r\n        \/\/ the aggregated exchange should be published (sent out)\r\n        answer = aggregated;\r\n    }\r\n    return answer;\r\n}","code_comment":null,"code_no_comment":"protected Exchange onCompletion(final String key, final Exchange original, final Exchange aggregated, boolean fromTimeout) {\r\n        if (original != null) {\r\n        original.setProperty(Exchange.AGGREGATED_CORRELATION_KEY, key);\r\n    }\r\n    aggregated.setProperty(Exchange.AGGREGATED_CORRELATION_KEY, key);\r\n        aggregationRepository.remove(aggregated.getContext(), key, original);\r\n    if (!fromTimeout && timeoutMap != null) {\r\n                timeoutMap.remove(key);\r\n    }\r\n        if (closedCorrelationKeys != null) {\r\n        closedCorrelationKeys.put(key, key);\r\n    }\r\n    if (fromTimeout) {\r\n                if (aggregationStrategy instanceof TimeoutAwareAggregationStrategy) {\r\n            long timeout = getCompletionTimeout() > 0 ? getCompletionTimeout() : -1;\r\n            ((TimeoutAwareAggregationStrategy) aggregationStrategy).timeout(aggregated, -1, -1, timeout);\r\n        }\r\n    }\r\n    Exchange answer;\r\n    if (fromTimeout && isDiscardOnCompletionTimeout()) {\r\n                LOG.debug(\"Aggregation for correlation key {} discarding aggregated exchange: {}\", key, aggregated);\r\n                aggregationRepository.confirm(aggregated.getContext(), aggregated.getExchangeId());\r\n                redeliveryState.remove(aggregated.getExchangeId());\r\n                answer = null;\r\n    } else {\r\n                answer = aggregated;\r\n    }\r\n    return answer;\r\n}","lc":0.6818181818,"pi":-0.0526315789,"ma":0.8,"nbd":0.0,"ml":0.9166666667,"d":1.1527777778,"mi":-0.5168428471,"fo":0.8333333333,"r":-0.0263157895,"e":1.5264766054}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-559_fc409e88","label":3,"code":"\/**\r\n * Returns true if both arguments are equal or within the range of allowed\r\n * error (inclusive).\r\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\r\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\r\n * point numbers are considered equal.\r\n * Adapted from <a\r\n * href=\"http:\/\/www.cygnus-software.com\/papers\/comparingfloats\/comparingfloats.htm\">\r\n * Bruce Dawson<\/a>\r\n *\r\n * @param x first value\r\n * @param y second value\r\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\r\n * values between {@code x} and {@code y}.\r\n * @return {@code true} if there are fewer than {@code maxUlps} floating\r\n * point values between {@code x} and {@code y}.\r\n *\/\r\npublic static boolean equals(double x, double y, int maxUlps) {\r\n    \/\/ NaN won't compare as equal to anything (except another NaN).\r\n    assert maxUlps > 0 && maxUlps < NAN_GAP;\r\n    long xInt = Double.doubleToLongBits(x);\r\n    long yInt = Double.doubleToLongBits(y);\r\n    \/\/ Make lexicographically ordered as a two's-complement integer.\r\n    if (xInt < 0) {\r\n        xInt = SGN_MASK - xInt;\r\n    }\r\n    if (yInt < 0) {\r\n        yInt = SGN_MASK - yInt;\r\n    }\r\n    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\r\n    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\r\n}","code_comment":"\/**\r\n * Returns true if both arguments are equal or within the range of allowed\r\n * error (inclusive).\r\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\r\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\r\n * point numbers are considered equal.\r\n * Adapted from <a\r\n * href=\"http:\/\/www.cygnus-software.com\/papers\/comparingfloats\/comparingfloats.htm\">\r\n * Bruce Dawson<\/a>\r\n *\r\n * @param x first value\r\n * @param y second value\r\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\r\n * values between {@code x} and {@code y}.\r\n * @return {@code true} if there are fewer than {@code maxUlps} floating\r\n * point values between {@code x} and {@code y}.\r\n *\/\r\n","code_no_comment":"public static boolean equals(double x, double y, int maxUlps) {\r\n        assert maxUlps > 0 && maxUlps < NAN_GAP;\r\n    long xInt = Double.doubleToLongBits(x);\r\n    long yInt = Double.doubleToLongBits(y);\r\n        if (xInt < 0) {\r\n        xInt = SGN_MASK - xInt;\r\n    }\r\n    if (yInt < 0) {\r\n        yInt = SGN_MASK - yInt;\r\n    }\r\n    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\r\n    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\r\n}","lc":-0.0454545455,"pi":-0.3684210526,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.4274841438,"fo":-0.0833333333,"r":0.1315789474,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4505_a4caaa57","label":1,"code":"@Override\r\npublic final Object put(String key, Object value) {\r\n    return super.put(key, unescapeHtml(value));\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic final Object put(String key, Object value) {\r\n    return super.put(key, unescapeHtml(value));\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8128259338,"fo":-0.3333333333,"r":0.3684210526,"e":-0.1627934049}
{"project_name":"Closure","project_version":"150","label":2,"code":"\/**\r\n * Visit a node in a local scope, and add any local variables or catch\r\n * parameters into the local symbol table.\r\n *\r\n * @param t The node traversal.\r\n * @param n The node being visited.\r\n * @param parent The parent of n\r\n *\/\r\n@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    if (n == scope.getRootNode())\r\n        return;\r\n    if (n.getType() == Token.LP && parent == scope.getRootNode()) {\r\n        handleFunctionInputs(parent);\r\n        return;\r\n    }\r\n    attachLiteralTypes(n);\r\n    switch(n.getType()) {\r\n        case Token.FUNCTION:\r\n            if (parent.getType() == Token.NAME) {\r\n                return;\r\n            }\r\n            defineDeclaredFunction(n, parent);\r\n            break;\r\n        case Token.CATCH:\r\n            defineCatch(n, parent);\r\n            break;\r\n        case Token.VAR:\r\n            defineVar(n, parent);\r\n            break;\r\n    }\r\n}","code_comment":"\/**\r\n * Visit a node in a local scope, and add any local variables or catch\r\n * parameters into the local symbol table.\r\n *\r\n * @param t The node traversal.\r\n * @param n The node being visited.\r\n * @param parent The parent of n\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    if (n == scope.getRootNode())\r\n        return;\r\n    if (n.getType() == Token.LP && parent == scope.getRootNode()) {\r\n        handleFunctionInputs(parent);\r\n        return;\r\n    }\r\n    attachLiteralTypes(n);\r\n    switch(n.getType()) {\r\n        case Token.FUNCTION:\r\n            if (parent.getType() == Token.NAME) {\r\n                return;\r\n            }\r\n            defineDeclaredFunction(n, parent);\r\n            break;\r\n        case Token.CATCH:\r\n            defineCatch(n, parent);\r\n            break;\r\n        case Token.VAR:\r\n            defineVar(n, parent);\r\n            break;\r\n    }\r\n}","lc":0.4545454545,"pi":0.7033492823,"ma":1.2,"nbd":0.5,"ml":0.5833333333,"d":0.0317460317,"mi":-0.3322057787,"fo":0.3333333333,"r":0.0,"e":0.0443629951}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4358_02ebc8ae","label":1,"code":"\/**\r\n *  Renders page to a {@link BufferedWebResponse}. All URLs in page will be rendered relative to\r\n *  <code>targetUrl<\/code>\r\n *\r\n *  @param targetUrl\r\n *  @param requestCycle\r\n *  @return BufferedWebResponse containing page body\r\n *\/\r\nprotected BufferedWebResponse renderPage(Url targetUrl, RequestCycle requestCycle) {\r\n    IRequestHandler scheduled = requestCycle.getRequestHandlerScheduledAfterCurrent();\r\n    \/\/ keep the original response\r\n    final Response originalResponse = requestCycle.getResponse();\r\n    \/\/ buffered web response for page\r\n    BufferedWebResponse response = new BufferedWebResponse((WebResponse) originalResponse);\r\n    \/\/ keep the original base URL\r\n    Url originalBaseUrl = requestCycle.getUrlRenderer().setBaseUrl(targetUrl);\r\n    try {\r\n        requestCycle.setResponse(response);\r\n        getPage().renderPage();\r\n        if (scheduled == null && requestCycle.getRequestHandlerScheduledAfterCurrent() != null) {\r\n            \/\/ will want to overwrite the response, so we need to let it\r\n            return null;\r\n        } else {\r\n            return response;\r\n        }\r\n    } finally {\r\n        \/\/ restore original response and base URL\r\n        requestCycle.setResponse(originalResponse);\r\n        requestCycle.getUrlRenderer().setBaseUrl(originalBaseUrl);\r\n    }\r\n}","code_comment":"\/**\r\n *  Renders page to a {@link BufferedWebResponse}. All URLs in page will be rendered relative to\r\n *  <code>targetUrl<\/code>\r\n *\r\n *  @param targetUrl\r\n *  @param requestCycle\r\n *  @return BufferedWebResponse containing page body\r\n *\/\r\n","code_no_comment":"protected BufferedWebResponse renderPage(Url targetUrl, RequestCycle requestCycle) {\r\n    IRequestHandler scheduled = requestCycle.getRequestHandlerScheduledAfterCurrent();\r\n        final Response originalResponse = requestCycle.getResponse();\r\n        BufferedWebResponse response = new BufferedWebResponse((WebResponse) originalResponse);\r\n        Url originalBaseUrl = requestCycle.getUrlRenderer().setBaseUrl(targetUrl);\r\n    try {\r\n        requestCycle.setResponse(response);\r\n        getPage().renderPage();\r\n        if (scheduled == null && requestCycle.getRequestHandlerScheduledAfterCurrent() != null) {\r\n                        return null;\r\n        } else {\r\n            return response;\r\n        }\r\n    } finally {\r\n                requestCycle.setResponse(originalResponse);\r\n        requestCycle.getUrlRenderer().setBaseUrl(originalBaseUrl);\r\n    }\r\n}","lc":0.1818181818,"pi":0.1626794258,"ma":-0.4,"nbd":0.0,"ml":-0.0833333333,"d":0.4861111111,"mi":-0.1596899225,"fo":0.4166666667,"r":-0.0263157895,"e":0.3143398858}
{"project_name":"Cli","project_version":"11","label":1,"code":"\/**\r\n * Appends the usage clause for an Option to a StringBuffer.\r\n *\r\n * @param buff the StringBuffer to append to\r\n * @param option the Option to append\r\n * @param required whether the Option is required or not\r\n *\/\r\nprivate static void appendOption(final StringBuffer buff, final Option option, final boolean required) {\r\n    if (!required) {\r\n        buff.append(\"[\");\r\n    }\r\n    if (option.getOpt() != null) {\r\n        buff.append(\"-\").append(option.getOpt());\r\n    } else {\r\n        buff.append(\"--\").append(option.getLongOpt());\r\n    }\r\n    \/\/ if the Option has a value\r\n    if (option.hasArg() && (option.getArgName() != null)) {\r\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\r\n    }\r\n    \/\/ if the Option is not a required option\r\n    if (!required) {\r\n        buff.append(\"]\");\r\n    }\r\n}","code_comment":"\/**\r\n * Appends the usage clause for an Option to a StringBuffer.\r\n *\r\n * @param buff the StringBuffer to append to\r\n * @param option the Option to append\r\n * @param required whether the Option is required or not\r\n *\/\r\n","code_no_comment":"private static void appendOption(final StringBuffer buff, final Option option, final boolean required) {\r\n    if (!required) {\r\n        buff.append(\"[\");\r\n    }\r\n    if (option.getOpt() != null) {\r\n        buff.append(\"-\").append(option.getOpt());\r\n    } else {\r\n        buff.append(\"--\").append(option.getLongOpt());\r\n    }\r\n        if (option.hasArg() && (option.getArgName() != null)) {\r\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\r\n    }\r\n        if (!required) {\r\n        buff.append(\"]\");\r\n    }\r\n}","lc":0.0909090909,"pi":-0.2153110048,"ma":0.2,"nbd":-0.5,"ml":0.3333333333,"d":0.0833333333,"mi":-0.1075405215,"fo":0.75,"r":0.0,"e":0.0605498983}
{"project_name":"Math","project_version":"30","label":3,"code":"\/**\r\n * @param Umin smallest Mann-Whitney U value\r\n * @param n1 number of subjects in first sample\r\n * @param n2 number of subjects in second sample\r\n * @return two-sided asymptotic p-value\r\n * @throws ConvergenceException if the p-value can not be computed\r\n * due to a convergence error\r\n * @throws MaxCountExceededException if the maximum number of\r\n * iterations is exceeded\r\n *\/\r\nprivate double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException {\r\n    final int n1n2prod = n1 * n2;\r\n    \/\/ http:\/\/en.wikipedia.org\/wiki\/Mann%E2%80%93Whitney_U#Normal_approximation\r\n    final double EU = n1n2prod \/ 2.0;\r\n    final double VarU = n1n2prod * (n1 + n2 + 1) \/ 12.0;\r\n    final double z = (Umin - EU) \/ FastMath.sqrt(VarU);\r\n    final NormalDistribution standardNormal = new NormalDistribution(0, 1);\r\n    return 2 * standardNormal.cumulativeProbability(z);\r\n}","code_comment":"\/**\r\n * @param Umin smallest Mann-Whitney U value\r\n * @param n1 number of subjects in first sample\r\n * @param n2 number of subjects in second sample\r\n * @return two-sided asymptotic p-value\r\n * @throws ConvergenceException if the p-value can not be computed\r\n * due to a convergence error\r\n * @throws MaxCountExceededException if the maximum number of\r\n * iterations is exceeded\r\n *\/\r\n","code_no_comment":"private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException {\r\n    final int n1n2prod = n1 * n2;\r\n        final double EU = n1n2prod \/ 2.0;\r\n    final double VarU = n1n2prod * (n1 + n2 + 1) \/ 12.0;\r\n    final double z = (Umin - EU) \/ FastMath.sqrt(VarU);\r\n    final NormalDistribution standardNormal = new NormalDistribution(0, 1);\r\n    return 2 * standardNormal.cumulativeProbability(z);\r\n}","lc":-0.2727272727,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":0.2777777778,"mi":0.230162086,"fo":-0.3333333333,"r":1.0526315789,"e":0.1670118659}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4358_74cbba24","label":1,"code":"\/**\r\n * Fetch the next document if {@code nextDoc} is\r\n * {@code null} and there are more documents.\r\n *\/\r\nprivate void fetchNextDoc() {\r\n    for (; ; ) {\r\n        if (nextDoc != null) {\r\n            break;\r\n        }\r\n        if (!previousDocs.hasNext()) {\r\n            \/\/ no more previous docs\r\n            break;\r\n        }\r\n        nextDoc = previousDocs.next();\r\n        Iterator<Revision> changes = nextDoc.getAllChanges().iterator();\r\n        if (changes.hasNext()) {\r\n            nextRevision = changes.next();\r\n            break;\r\n        } else {\r\n            \/\/ empty document, try next\r\n            nextDoc = null;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Fetch the next document if {@code nextDoc} is\r\n * {@code null} and there are more documents.\r\n *\/\r\n","code_no_comment":"private void fetchNextDoc() {\r\n    for (; ; ) {\r\n        if (nextDoc != null) {\r\n            break;\r\n        }\r\n        if (!previousDocs.hasNext()) {\r\n                        break;\r\n        }\r\n        nextDoc = previousDocs.next();\r\n        Iterator<Revision> changes = nextDoc.getAllChanges().iterator();\r\n        if (changes.hasNext()) {\r\n            nextRevision = changes.next();\r\n            break;\r\n        } else {\r\n                        nextDoc = null;\r\n        }\r\n    }\r\n}","lc":0.1818181818,"pi":0.3110047847,"ma":0.8,"nbd":0.0,"ml":0.0833333333,"d":-0.0297619048,"mi":-0.0858350951,"fo":0.0,"r":0.8947368421,"e":-0.0754090236}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5570_a57830ed","label":3,"code":"\/**\r\n * Allows an exception handler to create a new redelivery policy for this exception type\r\n *\r\n * @param context      the camel context\r\n * @param parentPolicy the current redelivery policy, is newer <tt>null<\/tt>\r\n * @return a newly created redelivery policy, or return the original policy if no customization is required\r\n *         for this exception handler.\r\n *\/\r\npublic RedeliveryPolicy createRedeliveryPolicy(CamelContext context, RedeliveryPolicy parentPolicy) {\r\n    if (redeliveryPolicyRef != null) {\r\n        return CamelContextHelper.mandatoryLookup(context, redeliveryPolicyRef, RedeliveryPolicy.class);\r\n    } else if (redeliveryPolicy != null) {\r\n        return redeliveryPolicy.createRedeliveryPolicy(context, parentPolicy);\r\n    } else if (!outputs.isEmpty() && parentPolicy.getMaximumRedeliveries() > 0) {\r\n        \/\/ if we have outputs, then do not inherit parent maximumRedeliveries\r\n        \/\/ as you would have to explicit configure maximumRedeliveries on this onException to use it\r\n        \/\/ this is the behavior Camel has always had\r\n        RedeliveryPolicy answer = parentPolicy.copy();\r\n        answer.setMaximumRedeliveries(0);\r\n        return answer;\r\n    } else {\r\n        return parentPolicy;\r\n    }\r\n}","code_comment":"\/**\r\n * Allows an exception handler to create a new redelivery policy for this exception type\r\n *\r\n * @param context      the camel context\r\n * @param parentPolicy the current redelivery policy, is newer <tt>null<\/tt>\r\n * @return a newly created redelivery policy, or return the original policy if no customization is required\r\n *         for this exception handler.\r\n *\/\r\n","code_no_comment":"public RedeliveryPolicy createRedeliveryPolicy(CamelContext context, RedeliveryPolicy parentPolicy) {\r\n    if (redeliveryPolicyRef != null) {\r\n        return CamelContextHelper.mandatoryLookup(context, redeliveryPolicyRef, RedeliveryPolicy.class);\r\n    } else if (redeliveryPolicy != null) {\r\n        return redeliveryPolicy.createRedeliveryPolicy(context, parentPolicy);\r\n    } else if (!outputs.isEmpty() && parentPolicy.getMaximumRedeliveries() > 0) {\r\n                                RedeliveryPolicy answer = parentPolicy.copy();\r\n        answer.setMaximumRedeliveries(0);\r\n        return answer;\r\n    } else {\r\n        return parentPolicy;\r\n    }\r\n}","lc":-0.0454545455,"pi":-0.04784689,"ma":0.0,"nbd":0.5,"ml":0.25,"d":0.3849206349,"mi":0.0184637068,"fo":0.0,"r":-0.0263157895,"e":0.1523509852}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-234_2d7d6311","label":1,"code":"@Override\r\npublic Result filter(final Logger logger, final Level level, final Marker marker, final Object msg, final Throwable t) {\r\n    return filter(msg.toString());\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Result filter(final Logger logger, final Level level, final Marker marker, final Object msg, final Throwable t) {\r\n    return filter(msg.toString());\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7229034531,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3535_b56d2962","label":1,"code":"public void process(Exchange exchange) throws Exception {\r\n    \/\/ compute correlation expression\r\n    String key = correlationExpression.evaluate(exchange, String.class);\r\n    if (ObjectHelper.isEmpty(key)) {\r\n        \/\/ we have a bad correlation key\r\n        if (isIgnoreInvalidCorrelationKeys()) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"Invalid correlation key. This Exchange will be ignored: \" + exchange);\r\n            }\r\n            return;\r\n        } else {\r\n            throw new CamelExchangeException(\"Invalid correlation key\", exchange);\r\n        }\r\n    }\r\n    \/\/ is the correlation key closed?\r\n    if (closedCorrelationKeys != null && closedCorrelationKeys.containsKey(key)) {\r\n        throw new ClosedCorrelationKeyException(key, exchange);\r\n    }\r\n    \/\/ when memory based then its fast using synchronized, but if the aggregation repository is IO\r\n    \/\/ bound such as JPA etc then concurrent aggregation per correlation key could\r\n    \/\/ improve performance as we can run aggregation repository get\/add in parallel\r\n    lock.lock();\r\n    try {\r\n        doAggregation(key, exchange);\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void process(Exchange exchange) throws Exception {\r\n        String key = correlationExpression.evaluate(exchange, String.class);\r\n    if (ObjectHelper.isEmpty(key)) {\r\n                if (isIgnoreInvalidCorrelationKeys()) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"Invalid correlation key. This Exchange will be ignored: \" + exchange);\r\n            }\r\n            return;\r\n        } else {\r\n            throw new CamelExchangeException(\"Invalid correlation key\", exchange);\r\n        }\r\n    }\r\n        if (closedCorrelationKeys != null && closedCorrelationKeys.containsKey(key)) {\r\n        throw new ClosedCorrelationKeyException(key, exchange);\r\n    }\r\n                lock.lock();\r\n    try {\r\n        doAggregation(key, exchange);\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}","lc":0.3636363636,"pi":0.5167464115,"ma":0.6,"nbd":0.5,"ml":0.5,"d":0.253968254,"mi":-0.2622973925,"fo":0.25,"r":-0.0263157895,"e":0.1376854941}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2260_0ac7ff20","label":1,"code":"@Override\r\npublic Segment readSegment(final String id) {\r\n    ctx.writeAndFlush(newGetSegmentReq(this.clientID, id));\r\n    return getSegment();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Segment readSegment(final String id) {\r\n    ctx.writeAndFlush(newGetSegmentReq(this.clientID, id));\r\n    return getSegment();\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6899224806,"fo":-0.25,"r":0.6842105263,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-657_97b440fc","label":3,"code":"\/**\r\n * Returns a {@code Complex} whose value is\r\n * {@code (this \/ divisor)}.\r\n * Implements the definitional formula\r\n * <pre>\r\n *  <code>\r\n *    a + bi          ac + bd + (bc - ad)i\r\n *    ----------- = -------------------------\r\n *    c + di         c<sup>2<\/sup> + d<sup>2<\/sup>\r\n *  <\/code>\r\n * <\/pre>\r\n * but uses\r\n * <a href=\"http:\/\/doi.acm.org\/10.1145\/1039813.1039814\">\r\n * prescaling of operands<\/a> to limit the effects of overflows and\r\n * underflows in the computation.\r\n * <br\/>\r\n * {@code Infinite} and {@code NaN} values are handled according to the\r\n * following rules, applied in the order presented:\r\n * <ul>\r\n *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\r\n *   in either part, {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},\r\n *   {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} and {@code divisor} are both infinite,\r\n *   {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\r\n *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\r\n *   infinite), {@link #ZERO} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} is infinite and {@code divisor} is finite,\r\n *   {@code NaN} values are returned in the parts of the result if the\r\n *   {@link java.lang.Double} rules applied to the definitional formula\r\n *   force {@code NaN} results.\r\n *  <\/li>\r\n * <\/ul>\r\n *\r\n * @param divisor Value by which this {@code Complex} is to be divided.\r\n * @return {@code this \/ divisor}.\r\n * @throws NullArgumentException if {@code divisor} is {@code null}.\r\n *\/\r\npublic Complex divide(Complex divisor) throws NullArgumentException {\r\n    MathUtils.checkNotNull(divisor);\r\n    if (isNaN || divisor.isNaN) {\r\n        return NaN;\r\n    }\r\n    if (divisor.isZero) {\r\n        return isZero ? NaN : INF;\r\n    }\r\n    if (divisor.isInfinite() && !isInfinite()) {\r\n        return ZERO;\r\n    }\r\n    final double c = divisor.getReal();\r\n    final double d = divisor.getImaginary();\r\n    if (FastMath.abs(c) < FastMath.abs(d)) {\r\n        double q = c \/ d;\r\n        double denominator = c * q + d;\r\n        return createComplex((real * q + imaginary) \/ denominator, (imaginary * q - real) \/ denominator);\r\n    } else {\r\n        double q = d \/ c;\r\n        double denominator = d * q + c;\r\n        return createComplex((imaginary * q + real) \/ denominator, (imaginary - real * q) \/ denominator);\r\n    }\r\n}","code_comment":"\/**\r\n * Returns a {@code Complex} whose value is\r\n * {@code (this \/ divisor)}.\r\n * Implements the definitional formula\r\n * <pre>\r\n *  <code>\r\n *    a + bi          ac + bd + (bc - ad)i\r\n *    ----------- = -------------------------\r\n *    c + di         c<sup>2<\/sup> + d<sup>2<\/sup>\r\n *  <\/code>\r\n * <\/pre>\r\n * but uses\r\n * <a href=\"http:\/\/doi.acm.org\/10.1145\/1039813.1039814\">\r\n * prescaling of operands<\/a> to limit the effects of overflows and\r\n * underflows in the computation.\r\n * <br\/>\r\n * {@code Infinite} and {@code NaN} values are handled according to the\r\n * following rules, applied in the order presented:\r\n * <ul>\r\n *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\r\n *   in either part, {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},\r\n *   {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} and {@code divisor} are both infinite,\r\n *   {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\r\n *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\r\n *   infinite), {@link #ZERO} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} is infinite and {@code divisor} is finite,\r\n *   {@code NaN} values are returned in the parts of the result if the\r\n *   {@link java.lang.Double} rules applied to the definitional formula\r\n *   force {@code NaN} results.\r\n *  <\/li>\r\n * <\/ul>\r\n *\r\n * @param divisor Value by which this {@code Complex} is to be divided.\r\n * @return {@code this \/ divisor}.\r\n * @throws NullArgumentException if {@code divisor} is {@code null}.\r\n *\/\r\n","code_no_comment":"public Complex divide(Complex divisor) throws NullArgumentException {\r\n    MathUtils.checkNotNull(divisor);\r\n    if (isNaN || divisor.isNaN) {\r\n        return NaN;\r\n    }\r\n    if (divisor.isZero) {\r\n        return isZero ? NaN : INF;\r\n    }\r\n    if (divisor.isInfinite() && !isInfinite()) {\r\n        return ZERO;\r\n    }\r\n    final double c = divisor.getReal();\r\n    final double d = divisor.getImaginary();\r\n    if (FastMath.abs(c) < FastMath.abs(d)) {\r\n        double q = c \/ d;\r\n        double denominator = c * q + d;\r\n        return createComplex((real * q + imaginary) \/ denominator, (imaginary * q - real) \/ denominator);\r\n    } else {\r\n        double q = d \/ c;\r\n        double denominator = d * q + c;\r\n        return createComplex((imaginary * q + real) \/ denominator, (imaginary - real * q) \/ denominator);\r\n    }\r\n}","lc":0.4090909091,"pi":-0.2440191388,"ma":0.4,"nbd":-0.5,"ml":1.0,"d":1.8174603175,"mi":-0.3964763918,"fo":0.25,"r":-0.0263157895,"e":2.2419137521}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5853_b80f6640","label":3,"code":"\/**\r\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(String, java.util.Locale)\r\n *\/\r\n@Override\r\npublic Double convertToObject(final String value, final Locale locale) {\r\n    final Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);\r\n    if (number == null) {\r\n        return null;\r\n    }\r\n    return number.doubleValue();\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(String, java.util.Locale)\r\n *\/\r\n","code_no_comment":"@Override\r\npublic Double convertToObject(final String value, final Locale locale) {\r\n    final Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);\r\n    if (number == null) {\r\n        return null;\r\n    }\r\n    return number.doubleValue();\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0535714286,"mi":0.3367159972,"fo":-0.3333333333,"r":0.2368421053,"e":-0.0887605678}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2962_2fd7633f","label":0,"code":"@Override\r\npublic void readFields(DataInput in) throws IOException {\r\n    range.readFields(in);\r\n    int numLocs = in.readInt();\r\n    locations = new String[numLocs];\r\n    for (int i = 0; i < numLocs; ++i) locations[i] = in.readUTF();\r\n    if (in.readBoolean()) {\r\n        isolatedScan = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        offline = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        localIterators = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        mockInstance = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        int numColumns = in.readInt();\r\n        List<String> columns = new ArrayList<String>(numColumns);\r\n        for (int i = 0; i < numColumns; i++) {\r\n            columns.add(in.readUTF());\r\n        }\r\n        fetchedColumns = InputConfigurator.deserializeFetchedColumns(columns);\r\n    }\r\n    if (in.readBoolean()) {\r\n        String strAuths = in.readUTF();\r\n        auths = new Authorizations(strAuths.getBytes(Charset.forName(\"UTF-8\")));\r\n    }\r\n    if (in.readBoolean()) {\r\n        principal = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        String tokenClass = in.readUTF();\r\n        byte[] base64TokenBytes = in.readUTF().getBytes(Charset.forName(\"UTF-8\"));\r\n        byte[] tokenBytes = Base64.decodeBase64(base64TokenBytes);\r\n        try {\r\n            token = CredentialHelper.extractToken(tokenClass, tokenBytes);\r\n        } catch (AccumuloSecurityException e) {\r\n            throw new IOException(e);\r\n        }\r\n    }\r\n    if (in.readBoolean()) {\r\n        instanceName = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        zooKeepers = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        level = Level.toLevel(in.readInt());\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void readFields(DataInput in) throws IOException {\r\n    range.readFields(in);\r\n    int numLocs = in.readInt();\r\n    locations = new String[numLocs];\r\n    for (int i = 0; i < numLocs; ++i) locations[i] = in.readUTF();\r\n    if (in.readBoolean()) {\r\n        isolatedScan = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        offline = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        localIterators = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        mockInstance = in.readBoolean();\r\n    }\r\n    if (in.readBoolean()) {\r\n        int numColumns = in.readInt();\r\n        List<String> columns = new ArrayList<String>(numColumns);\r\n        for (int i = 0; i < numColumns; i++) {\r\n            columns.add(in.readUTF());\r\n        }\r\n        fetchedColumns = InputConfigurator.deserializeFetchedColumns(columns);\r\n    }\r\n    if (in.readBoolean()) {\r\n        String strAuths = in.readUTF();\r\n        auths = new Authorizations(strAuths.getBytes(Charset.forName(\"UTF-8\")));\r\n    }\r\n    if (in.readBoolean()) {\r\n        principal = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        String tokenClass = in.readUTF();\r\n        byte[] base64TokenBytes = in.readUTF().getBytes(Charset.forName(\"UTF-8\"));\r\n        byte[] tokenBytes = Base64.decodeBase64(base64TokenBytes);\r\n        try {\r\n            token = CredentialHelper.extractToken(tokenClass, tokenBytes);\r\n        } catch (AccumuloSecurityException e) {\r\n            throw new IOException(e);\r\n        }\r\n    }\r\n    if (in.readBoolean()) {\r\n        instanceName = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        zooKeepers = in.readUTF();\r\n    }\r\n    if (in.readBoolean()) {\r\n        level = Level.toLevel(in.readInt());\r\n    }\r\n}","lc":1.7727272727,"pi":-0.1148325359,"ma":2.4,"nbd":0.0,"ml":1.0,"d":0.1468253968,"mi":-0.9343199436,"fo":2.5,"r":-0.0263157895,"e":0.8932510388}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1789_08ba79d4","label":1,"code":"public Map<String, PropertyState> createProperties(NodePropBundle bundle) {\r\n    Map<String, PropertyState> properties = newHashMap();\r\n    String primary;\r\n    if (bundle.getNodeTypeName() != null) {\r\n        primary = createName(bundle.getNodeTypeName());\r\n    } else {\r\n        warn(\"Missing primary node type; defaulting to nt:unstructured\");\r\n        primary = NT_UNSTRUCTURED;\r\n    }\r\n    properties.put(JCR_PRIMARYTYPE, PropertyStates.createProperty(JCR_PRIMARYTYPE, primary, Type.NAME));\r\n    Set<String> mixins = newLinkedHashSet();\r\n    if (bundle.getMixinTypeNames() != null) {\r\n        for (Name mixin : bundle.getMixinTypeNames()) {\r\n            mixins.add(createName(mixin));\r\n        }\r\n    }\r\n    if (!mixins.isEmpty()) {\r\n        properties.put(JCR_MIXINTYPES, PropertyStates.createProperty(JCR_MIXINTYPES, mixins, Type.NAMES));\r\n    }\r\n    if (bundle.isReferenceable() || isReferenceable.apply(primary, mixins)) {\r\n        properties.put(JCR_UUID, PropertyStates.createProperty(JCR_UUID, bundle.getId().toString()));\r\n    }\r\n    if (isOrderable.apply(primary, mixins)) {\r\n        properties.put(OAK_CHILD_ORDER, PropertyStates.createProperty(OAK_CHILD_ORDER, nodes.keySet(), Type.NAMES));\r\n    }\r\n    for (PropertyEntry property : bundle.getPropertyEntries()) {\r\n        String name = createName(property.getName());\r\n        try {\r\n            int type = property.getType();\r\n            if (property.isMultiValued()) {\r\n                properties.put(name, createProperty(name, type, property.getValues()));\r\n            } else {\r\n                properties.put(name, createProperty(name, type, property.getValues()[0]));\r\n            }\r\n        } catch (Exception e) {\r\n            warn(\"Skipping broken property entry \" + name, e);\r\n        }\r\n    }\r\n    return properties;\r\n}","code_comment":null,"code_no_comment":"public Map<String, PropertyState> createProperties(NodePropBundle bundle) {\r\n    Map<String, PropertyState> properties = newHashMap();\r\n    String primary;\r\n    if (bundle.getNodeTypeName() != null) {\r\n        primary = createName(bundle.getNodeTypeName());\r\n    } else {\r\n        warn(\"Missing primary node type; defaulting to nt:unstructured\");\r\n        primary = NT_UNSTRUCTURED;\r\n    }\r\n    properties.put(JCR_PRIMARYTYPE, PropertyStates.createProperty(JCR_PRIMARYTYPE, primary, Type.NAME));\r\n    Set<String> mixins = newLinkedHashSet();\r\n    if (bundle.getMixinTypeNames() != null) {\r\n        for (Name mixin : bundle.getMixinTypeNames()) {\r\n            mixins.add(createName(mixin));\r\n        }\r\n    }\r\n    if (!mixins.isEmpty()) {\r\n        properties.put(JCR_MIXINTYPES, PropertyStates.createProperty(JCR_MIXINTYPES, mixins, Type.NAMES));\r\n    }\r\n    if (bundle.isReferenceable() || isReferenceable.apply(primary, mixins)) {\r\n        properties.put(JCR_UUID, PropertyStates.createProperty(JCR_UUID, bundle.getId().toString()));\r\n    }\r\n    if (isOrderable.apply(primary, mixins)) {\r\n        properties.put(OAK_CHILD_ORDER, PropertyStates.createProperty(OAK_CHILD_ORDER, nodes.keySet(), Type.NAMES));\r\n    }\r\n    for (PropertyEntry property : bundle.getPropertyEntries()) {\r\n        String name = createName(property.getName());\r\n        try {\r\n            int type = property.getType();\r\n            if (property.isMultiValued()) {\r\n                properties.put(name, createProperty(name, type, property.getValues()));\r\n            } else {\r\n                properties.put(name, createProperty(name, type, property.getValues()[0]));\r\n            }\r\n        } catch (Exception e) {\r\n            warn(\"Skipping broken property entry \" + name, e);\r\n        }\r\n    }\r\n    return properties;\r\n}","lc":1.1818181818,"pi":0.3971291866,"ma":1.2,"nbd":0.5,"ml":0.9166666667,"d":0.5674603175,"mi":-0.7539112051,"fo":2.5833333333,"r":-0.0263157895,"e":1.5976602525}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8954_7b1253db","label":3,"code":"@Override\r\nprotected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {\r\n    \/\/ must call super\r\n    super.doReleaseExclusiveReadLock(operations, file, exchange);\r\n    String target = file.getFileName();\r\n    FileLock lock = exchange.getProperty(Exchange.FILE_LOCK_EXCLUSIVE_LOCK, FileLock.class);\r\n    RandomAccessFile rac = exchange.getProperty(Exchange.FILE_LOCK_RANDOM_ACCESS_FILE, RandomAccessFile.class);\r\n    if (lock != null) {\r\n        Channel channel = lock.acquiredBy();\r\n        try {\r\n            lock.release();\r\n        } finally {\r\n            \/\/ close channel as well\r\n            IOHelper.close(channel, \"while releasing exclusive read lock for file: \" + target, LOG);\r\n            IOHelper.close(rac, \"while releasing exclusive read lock for file: \" + target, LOG);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {\r\n        super.doReleaseExclusiveReadLock(operations, file, exchange);\r\n    String target = file.getFileName();\r\n    FileLock lock = exchange.getProperty(Exchange.FILE_LOCK_EXCLUSIVE_LOCK, FileLock.class);\r\n    RandomAccessFile rac = exchange.getProperty(Exchange.FILE_LOCK_RANDOM_ACCESS_FILE, RandomAccessFile.class);\r\n    if (lock != null) {\r\n        Channel channel = lock.acquiredBy();\r\n        try {\r\n            lock.release();\r\n        } finally {\r\n                        IOHelper.close(channel, \"while releasing exclusive read lock for file: \" + target, LOG);\r\n            IOHelper.close(rac, \"while releasing exclusive read lock for file: \" + target, LOG);\r\n        }\r\n    }\r\n}","lc":0.0909090909,"pi":0.4784688995,"ma":-0.4,"nbd":0.0,"ml":-0.25,"d":-0.0079365079,"mi":-0.14136716,"fo":0.1666666667,"r":-0.0263157895,"e":0.0925594878}
{"project_name":"Time","project_version":"26","label":2,"code":"public long roundFloor(long instant) {\r\n    if (iTimeField) {\r\n        int offset = getOffsetToAdd(instant);\r\n        instant = iField.roundFloor(instant + offset);\r\n        return instant - offset;\r\n    } else {\r\n        long localInstant = iZone.convertUTCToLocal(instant);\r\n        localInstant = iField.roundFloor(localInstant);\r\n        return iZone.convertLocalToUTC(localInstant, false);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public long roundFloor(long instant) {\r\n    if (iTimeField) {\r\n        int offset = getOffsetToAdd(instant);\r\n        instant = iField.roundFloor(instant + offset);\r\n        return instant - offset;\r\n    } else {\r\n        long localInstant = iZone.convertUTCToLocal(instant);\r\n        localInstant = iField.roundFloor(localInstant);\r\n        return iZone.convertLocalToUTC(localInstant, false);\r\n    }\r\n}","lc":-0.1363636364,"pi":0.04784689,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.0654761905,"mi":0.1619450317,"fo":-0.0833333333,"r":0.1842105263,"e":-0.0379085193}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5060_8e6a6ec5","label":3,"code":"\/**\r\n *  Search for the child's markup in the fragment markup.\r\n *\/\r\n@Override\r\npublic IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {\r\n    \/\/ Get the markup to search for the fragment markup\r\n    IMarkupFragment markup = chooseMarkup(container);\r\n    if (markup == null) {\r\n        throw new MarkupException(\"The fragments markup provider has no associated markup. \" + \"No markup to search for fragment markup with id: \" + markupId);\r\n    }\r\n    \/\/ Search for the fragment markup\r\n    IMarkupFragment childMarkup = markup.find(markupId);\r\n    if (childMarkup == null) {\r\n        \/\/ There is one more option if the markup provider has associated markup\r\n        MarkupContainer markupProvider = getMarkupProvider(container);\r\n        Markup associatedMarkup = markupProvider.getAssociatedMarkup();\r\n        if (associatedMarkup != null) {\r\n            markup = associatedMarkup;\r\n            if (markup != null) {\r\n                childMarkup = markup.find(markupId);\r\n            }\r\n        }\r\n    }\r\n    if (childMarkup == null) {\r\n        throw new MarkupNotFoundException(\"No Markup found for Fragment \" + markupId + \" in providing markup container \" + getMarkupProvider(container));\r\n    } else {\r\n        MarkupElement fragmentTag = childMarkup.get(0);\r\n        if ((fragmentTag instanceof WicketTag && ((WicketTag) fragmentTag).isFragementTag()) == false) {\r\n            throw new MarkupNotFoundException(\"Markup found for Fragment '\" + markupId + \"' in providing markup container \" + getMarkupProvider(container) + \" is not a fragment tag\");\r\n        }\r\n    }\r\n    if (child == null) {\r\n        return childMarkup;\r\n    }\r\n    \/\/ search for the child inside the fragment markup\r\n    return childMarkup.find(child.getId());\r\n}","code_comment":"\/**\r\n *  Search for the child's markup in the fragment markup.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic IMarkupFragment getMarkup(final MarkupContainer container, final Component child) {\r\n        IMarkupFragment markup = chooseMarkup(container);\r\n    if (markup == null) {\r\n        throw new MarkupException(\"The fragments markup provider has no associated markup. \" + \"No markup to search for fragment markup with id: \" + markupId);\r\n    }\r\n        IMarkupFragment childMarkup = markup.find(markupId);\r\n    if (childMarkup == null) {\r\n                MarkupContainer markupProvider = getMarkupProvider(container);\r\n        Markup associatedMarkup = markupProvider.getAssociatedMarkup();\r\n        if (associatedMarkup != null) {\r\n            markup = associatedMarkup;\r\n            if (markup != null) {\r\n                childMarkup = markup.find(markupId);\r\n            }\r\n        }\r\n    }\r\n    if (childMarkup == null) {\r\n        throw new MarkupNotFoundException(\"No Markup found for Fragment \" + markupId + \" in providing markup container \" + getMarkupProvider(container));\r\n    } else {\r\n        MarkupElement fragmentTag = childMarkup.get(0);\r\n        if ((fragmentTag instanceof WicketTag && ((WicketTag) fragmentTag).isFragementTag()) == false) {\r\n            throw new MarkupNotFoundException(\"Markup found for Fragment '\" + markupId + \"' in providing markup container \" + getMarkupProvider(container) + \" is not a fragment tag\");\r\n        }\r\n    }\r\n    if (child == null) {\r\n        return childMarkup;\r\n    }\r\n        return childMarkup.find(child.getId());\r\n}","lc":0.7272727273,"pi":0.3923444976,"ma":1.4,"nbd":0.5,"ml":0.75,"d":0.4722222222,"mi":-0.5588442565,"fo":0.4166666667,"r":-0.0263157895,"e":0.8175262069}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1822_016df669","label":1,"code":"\/**\r\n * Set the property to the given value.\r\n *\r\n * @param property the property name\r\n * @param value the value\r\n *\/\r\nvoid set(String property, Object value) {\r\n    Operation op = new Operation();\r\n    op.type = Operation.Type.SET;\r\n    op.value = value;\r\n    changes.put(new Key(property, null), op);\r\n}","code_comment":"\/**\r\n * Set the property to the given value.\r\n *\r\n * @param property the property name\r\n * @param value the value\r\n *\/\r\n","code_no_comment":"void set(String property, Object value) {\r\n    Operation op = new Operation();\r\n    op.type = Operation.Type.SET;\r\n    op.value = value;\r\n    changes.put(new Key(property, null), op);\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4720225511,"fo":-0.4166666667,"r":1.6315789474,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2294_fef9f115","label":0,"code":"@Override\r\npublic void collect(T record) {\r\n    try {\r\n        operator.processElement(serializer.copy(record));\r\n    } catch (Exception e) {\r\n        if (LOG.isErrorEnabled()) {\r\n            LOG.error(\"Could not forward element to operator.\", e);\r\n        }\r\n        throw new RuntimeException(e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void collect(T record) {\r\n    try {\r\n        operator.processElement(serializer.copy(record));\r\n    } catch (Exception e) {\r\n        if (LOG.isErrorEnabled()) {\r\n            LOG.error(\"Could not forward element to operator.\", e);\r\n        }\r\n        throw new RuntimeException(e);\r\n    }\r\n}","lc":-0.1363636364,"pi":0.4114832536,"ma":0.0,"nbd":0.0,"ml":-0.25,"d":-0.3650793651,"mi":0.2143763214,"fo":-0.1666666667,"r":0.4473684211,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5546_f1af9e03","label":3,"code":"\/**\r\n *  Initializes Page by adding it to the Session and initializing it.\r\n *\/\r\nprivate void init() {\r\n    if (isBookmarkable() == false) {\r\n        setStatelessHint(false);\r\n    }\r\n    \/\/ Set versioning of page based on default\r\n    setVersioned(getApplication().getPageSettings().getVersionPagesByDefault());\r\n    \/\/ All Pages are born dirty so they get clustered right away\r\n    dirty(true);\r\n    \/\/ this is a bit of a dirty hack, but calling dirty(true) results in isStateless called\r\n    \/\/ which is bound to set the stateless cache to true as there are no components yet\r\n    stateless = null;\r\n}","code_comment":"\/**\r\n *  Initializes Page by adding it to the Session and initializing it.\r\n *\/\r\n","code_no_comment":"private void init() {\r\n    if (isBookmarkable() == false) {\r\n        setStatelessHint(false);\r\n    }\r\n        setVersioned(getApplication().getPageSettings().getVersionPagesByDefault());\r\n        dirty(true);\r\n            stateless = null;\r\n}","lc":-0.2727272727,"pi":-0.2822966507,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1507936508,"mi":0.4088794926,"fo":0.0833333333,"r":2.3947368421,"e":-0.1317565971}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5683_0c3c7d1b","label":1,"code":"\/**\r\n * Creates the {@link LRUCache} to be used.\r\n * <p\/>\r\n * This implementation returns a {@link org.apache.camel.util.LRUSoftCache} instance.\r\n *\r\n * @param cacheSize the cache size\r\n * @return the cache\r\n *\/\r\nprotected static LRUCache<String, PollingConsumer> createLRUCache(int cacheSize) {\r\n    \/\/ We use a soft reference cache to allow the JVM to re-claim memory if it runs low on memory.\r\n    return new LRUSoftCache<String, PollingConsumer>(cacheSize);\r\n}","code_comment":"\/**\r\n * Creates the {@link LRUCache} to be used.\r\n * <p\/>\r\n * This implementation returns a {@link org.apache.camel.util.LRUSoftCache} instance.\r\n *\r\n * @param cacheSize the cache size\r\n * @return the cache\r\n *\/\r\n","code_no_comment":"protected static LRUCache<String, PollingConsumer> createLRUCache(int cacheSize) {\r\n        return new LRUSoftCache<String, PollingConsumer>(cacheSize);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9805496829,"fo":-0.5,"r":2.3421052632,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2544_7ec60f1b","label":1,"code":"@Override\r\npublic void deleteRows(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n    if (!exists(tableName))\r\n        throw new TableNotFoundException(tableName, tableName, \"\");\r\n    MockTable t = acu.tables.get(tableName);\r\n    Set<Key> keep = new TreeSet<Key>(t.table.tailMap(new Key(start)).headMap(new Key(end)).keySet());\r\n    t.table.keySet().removeAll(keep);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void deleteRows(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n    if (!exists(tableName))\r\n        throw new TableNotFoundException(tableName, tableName, \"\");\r\n    MockTable t = acu.tables.get(tableName);\r\n    Set<Key> keep = new TreeSet<Key>(t.table.tailMap(new Key(start)).headMap(new Key(end)).keySet());\r\n    t.table.keySet().removeAll(keep);\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.2,"nbd":-1.0,"ml":-0.1666666667,"d":-0.0496031746,"mi":0.215503876,"fo":0.0833333333,"r":-0.0263157895,"e":0.0012839796}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-366_db4a291f","label":1,"code":"void flush(long tableFlushID) {\r\n    boolean updateMetadata = false;\r\n    boolean initiateMinor = false;\r\n    try {\r\n        synchronized (this) {\r\n            \/\/ only want one thing at a time to update flush ID to ensure that metadata table and tablet in memory state are consistent\r\n            if (updatingFlushID)\r\n                return;\r\n            if (lastFlushID >= tableFlushID)\r\n                return;\r\n            if (closing || closed || tabletMemory.memoryReservedForMinC())\r\n                return;\r\n            if (tabletMemory.getMemTable().getNumEntries() == 0) {\r\n                lastFlushID = tableFlushID;\r\n                updatingFlushID = true;\r\n                updateMetadata = true;\r\n            } else\r\n                initiateMinor = true;\r\n        }\r\n        if (updateMetadata) {\r\n            AuthInfo creds = SecurityConstants.getSystemCredentials();\r\n            \/\/ if multiple threads were allowed to update this outside of a sync block, then it would be\r\n            \/\/ a race condition\r\n            MetadataTable.updateTabletFlushID(extent, tableFlushID, creds, tabletServer.getLock());\r\n        } else if (initiateMinor)\r\n            initiateMinorCompaction(tableFlushID);\r\n    } finally {\r\n        if (updateMetadata) {\r\n            synchronized (this) {\r\n                updatingFlushID = false;\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"void flush(long tableFlushID) {\r\n    boolean updateMetadata = false;\r\n    boolean initiateMinor = false;\r\n    try {\r\n        synchronized (this) {\r\n                        if (updatingFlushID)\r\n                return;\r\n            if (lastFlushID >= tableFlushID)\r\n                return;\r\n            if (closing || closed || tabletMemory.memoryReservedForMinC())\r\n                return;\r\n            if (tabletMemory.getMemTable().getNumEntries() == 0) {\r\n                lastFlushID = tableFlushID;\r\n                updatingFlushID = true;\r\n                updateMetadata = true;\r\n            } else\r\n                initiateMinor = true;\r\n        }\r\n        if (updateMetadata) {\r\n            AuthInfo creds = SecurityConstants.getSystemCredentials();\r\n                                    MetadataTable.updateTabletFlushID(extent, tableFlushID, creds, tabletServer.getLock());\r\n        } else if (initiateMinor)\r\n            initiateMinorCompaction(tableFlushID);\r\n    } finally {\r\n        if (updateMetadata) {\r\n            synchronized (this) {\r\n                updatingFlushID = false;\r\n            }\r\n        }\r\n    }\r\n}","lc":0.7727272727,"pi":0.8947368421,"ma":0.8,"nbd":0.5,"ml":1.0833333333,"d":0.3055555556,"mi":-0.4630021142,"fo":0.0833333333,"r":-0.0263157895,"e":0.2583334774}
{"project_name":"Lang","project_version":"46","label":0,"code":"\/**\r\n * <p>Escapes the characters in a <code>String<\/code> using Java String rules to\r\n * a <code>Writer<\/code>.<\/p>\r\n *\r\n * <p>A <code>null<\/code> string input has no effect.<\/p>\r\n *\r\n * @see #escapeJava(java.lang.String)\r\n * @param out  Writer to write escaped string into\r\n * @param str  String to escape values in, may be null\r\n * @throws IllegalArgumentException if the Writer is <code>null<\/code>\r\n * @throws IOException if error occurs on underlying Writer\r\n *\/\r\npublic static void escapeJava(Writer out, String str) throws IOException {\r\n    escapeJavaStyleString(out, str, false);\r\n}","code_comment":"\/**\r\n * <p>Escapes the characters in a <code>String<\/code> using Java String rules to\r\n * a <code>Writer<\/code>.<\/p>\r\n *\r\n * <p>A <code>null<\/code> string input has no effect.<\/p>\r\n *\r\n * @see #escapeJava(java.lang.String)\r\n * @param out  Writer to write escaped string into\r\n * @param str  String to escape values in, may be null\r\n * @throws IllegalArgumentException if the Writer is <code>null<\/code>\r\n * @throws IOException if error occurs on underlying Writer\r\n *\/\r\n","code_no_comment":"public static void escapeJava(Writer out, String str) throws IOException {\r\n    escapeJavaStyleString(out, str, false);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.948696265,"fo":-0.4166666667,"r":0.8947368421,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1877_716e1237","label":0,"code":"private static boolean isAlreadyRunning(NodeStore store, String name) {\r\n    NodeState indexState = store.getRoot().getChildNode(INDEX_DEFINITIONS_NAME);\r\n    \/\/ Probably the first run\r\n    if (!indexState.exists()) {\r\n        return false;\r\n    }\r\n    \/\/ Check if already running or timed out\r\n    if (STATUS_RUNNING.equals(indexState.getString(name + \"-status\"))) {\r\n        PropertyState startTime = indexState.getProperty(name + \"-start\");\r\n        Calendar start = Conversions.convert(startTime.getValue(Type.DATE)).toCalendar();\r\n        Calendar now = Calendar.getInstance();\r\n        long delta = now.getTimeInMillis() - start.getTimeInMillis();\r\n        \/\/ Check if the job has timed out and we need to take over\r\n        if (TimeUnit.MILLISECONDS.toMinutes(delta) > ASYNC_TIMEOUT) {\r\n            log.info(\"Async job found which stated on {} has timed out in {} minutes. \" + \"This node would take over the job.\", startTime.getValue(Type.DATE), ASYNC_TIMEOUT);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"private static boolean isAlreadyRunning(NodeStore store, String name) {\r\n    NodeState indexState = store.getRoot().getChildNode(INDEX_DEFINITIONS_NAME);\r\n        if (!indexState.exists()) {\r\n        return false;\r\n    }\r\n        if (STATUS_RUNNING.equals(indexState.getString(name + \"-status\"))) {\r\n        PropertyState startTime = indexState.getProperty(name + \"-start\");\r\n        Calendar start = Conversions.convert(startTime.getValue(Type.DATE)).toCalendar();\r\n        Calendar now = Calendar.getInstance();\r\n        long delta = now.getTimeInMillis() - start.getTimeInMillis();\r\n                if (TimeUnit.MILLISECONDS.toMinutes(delta) > ASYNC_TIMEOUT) {\r\n            log.info(\"Async job found which stated on {} has timed out in {} minutes. \" + \"This node would take over the job.\", startTime.getValue(Type.DATE), ASYNC_TIMEOUT);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}","lc":0.1818181818,"pi":0.1626794258,"ma":0.0,"nbd":0.0,"ml":0.3333333333,"d":0.2202380952,"mi":-0.2484848485,"fo":0.75,"r":-0.0263157895,"e":0.389133429}
{"project_name":"Closure","project_version":"85","label":1,"code":"\/**\r\n * Tries to remove n if an unconditional branch node (break, continue or\r\n * return) if the target of n is the same as the the follow of n. That is, if\r\n * we remove n, the control flow remains the same. Also if n targets to\r\n * another unconditional branch, this function will recursively try to remove\r\n * the target branch as well. The reason why we want to cascade this removal\r\n * is because we only run this pass once. If we have code such as\r\n *\r\n * break -> break -> break\r\n *\r\n * where all 3 break's are useless. The order of removal matters. When we\r\n * first look at the first break, we see that it branches to the 2nd break.\r\n * However, if we remove the last break, the 2nd break becomes useless and\r\n * finally the first break becomes useless as well.\r\n *\r\n * @return The target of this jump. If the target is also useless jump,\r\n *     the target of that useless jump recursively.\r\n *\/\r\n@SuppressWarnings(\"fallthrough\")\r\nprivate Node tryRemoveUnconditionalBranching(Node n) {\r\n    \/\/ If n is null the target is the end of the function, nothing to do.\r\n    if (n == null) {\r\n        return n;\r\n    }\r\n    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);\r\n    if (gNode == null) {\r\n        return n;\r\n    }\r\n    if (n.getParent() == null) {\r\n        List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();\r\n        if (outEdges.size() == 1) {\r\n            return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\r\n        }\r\n    }\r\n    switch(n.getType()) {\r\n        case Token.BLOCK:\r\n            if (n.hasChildren()) {\r\n                Node first = n.getFirstChild();\r\n                return tryRemoveUnconditionalBranching(first);\r\n            } else {\r\n                return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));\r\n            }\r\n        case Token.RETURN:\r\n            if (n.hasChildren()) {\r\n                break;\r\n            }\r\n        case Token.BREAK:\r\n        case Token.CONTINUE:\r\n            \/\/ We are looking for a control flow changing statement that always\r\n            \/\/ branches to the same node. If removing it the control flow still\r\n            \/\/ branches to that same node. It is safe to remove it.\r\n            List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();\r\n            if (outEdges.size() == 1 && \/\/ If there is a next node, there is no chance this jump is useless.\r\n            (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\r\n                Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\r\n                Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));\r\n                Node nextCfgNode = outEdges.get(0).getDestination().getValue();\r\n                if (nextCfgNode == fallThrough) {\r\n                    removeDeadExprStatementSafely(n);\r\n                    return fallThrough;\r\n                }\r\n            }\r\n    }\r\n    return n;\r\n}","code_comment":"\/**\r\n * Tries to remove n if an unconditional branch node (break, continue or\r\n * return) if the target of n is the same as the the follow of n. That is, if\r\n * we remove n, the control flow remains the same. Also if n targets to\r\n * another unconditional branch, this function will recursively try to remove\r\n * the target branch as well. The reason why we want to cascade this removal\r\n * is because we only run this pass once. If we have code such as\r\n *\r\n * break -> break -> break\r\n *\r\n * where all 3 break's are useless. The order of removal matters. When we\r\n * first look at the first break, we see that it branches to the 2nd break.\r\n * However, if we remove the last break, the 2nd break becomes useless and\r\n * finally the first break becomes useless as well.\r\n *\r\n * @return The target of this jump. If the target is also useless jump,\r\n *     the target of that useless jump recursively.\r\n *\/\r\n","code_no_comment":"@SuppressWarnings(\"fallthrough\")\r\nprivate Node tryRemoveUnconditionalBranching(Node n) {\r\n        if (n == null) {\r\n        return n;\r\n    }\r\n    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);\r\n    if (gNode == null) {\r\n        return n;\r\n    }\r\n    if (n.getParent() == null) {\r\n        List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();\r\n        if (outEdges.size() == 1) {\r\n            return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\r\n        }\r\n    }\r\n    switch(n.getType()) {\r\n        case Token.BLOCK:\r\n            if (n.hasChildren()) {\r\n                Node first = n.getFirstChild();\r\n                return tryRemoveUnconditionalBranching(first);\r\n            } else {\r\n                return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));\r\n            }\r\n        case Token.RETURN:\r\n            if (n.hasChildren()) {\r\n                break;\r\n            }\r\n        case Token.BREAK:\r\n        case Token.CONTINUE:\r\n                                                List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();\r\n            if (outEdges.size() == 1 &&             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\r\n                Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\r\n                Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));\r\n                Node nextCfgNode = outEdges.get(0).getDestination().getValue();\r\n                if (nextCfgNode == fallThrough) {\r\n                    removeDeadExprStatementSafely(n);\r\n                    return fallThrough;\r\n                }\r\n            }\r\n    }\r\n    return n;\r\n}","lc":1.3181818182,"pi":1.1531100478,"ma":2.0,"nbd":1.0,"ml":1.5833333333,"d":0.623015873,"mi":-0.7885835095,"fo":1.9166666667,"r":-0.0263157895,"e":1.4175527164}
{"project_name":"JxPath","project_version":"14","label":1,"code":"protected Object functionFloor(EvalContext context) {\r\n    assertArgCount(1);\r\n    double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\r\n    return new Double(Math.floor(v));\r\n}","code_comment":null,"code_no_comment":"protected Object functionFloor(EvalContext context) {\r\n    assertArgCount(1);\r\n    double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\r\n    return new Double(Math.floor(v));\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6093023256,"fo":-0.0833333333,"r":1.2105263158,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4927_8c827e33","label":1,"code":"@Override\r\npublic void flush() {\r\n    if (!bufferedWritten) {\r\n        bufferedResponse.writeTo(originalResponse);\r\n        bufferedResponse.reset();\r\n    }\r\n    originalResponse.flush();\r\n    flushed = true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void flush() {\r\n    if (!bufferedWritten) {\r\n        bufferedResponse.writeTo(originalResponse);\r\n        bufferedResponse.reset();\r\n    }\r\n    originalResponse.flush();\r\n    flushed = true;\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1071428571,"mi":0.3770260747,"fo":-0.25,"r":0.7894736842,"e":-0.1305625191}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5965_31c88569","label":1,"code":"\/**\r\n *  Insert &lt;head&gt; open and close tag (with empty body) to the current position.\r\n *\/\r\nprivate void insertHeadTag() {\r\n    \/\/ Note: only the open-tag must be a AutoComponentTag\r\n    final ComponentTag openTag = new ComponentTag(HEAD, TagType.OPEN);\r\n    openTag.setId(HEADER_ID);\r\n    openTag.setAutoComponentTag(true);\r\n    openTag.setModified(true);\r\n    final ComponentTag closeTag = new ComponentTag(HEAD, TagType.CLOSE);\r\n    closeTag.setOpenTag(openTag);\r\n    closeTag.setModified(true);\r\n    \/\/ insert the tags into the markup stream\r\n    markup.addMarkupElement(openTag);\r\n    markup.addMarkupElement(closeTag);\r\n}","code_comment":"\/**\r\n *  Insert &lt;head&gt; open and close tag (with empty body) to the current position.\r\n *\/\r\n","code_no_comment":"private void insertHeadTag() {\r\n        final ComponentTag openTag = new ComponentTag(HEAD, TagType.OPEN);\r\n    openTag.setId(HEADER_ID);\r\n    openTag.setAutoComponentTag(true);\r\n    openTag.setModified(true);\r\n    final ComponentTag closeTag = new ComponentTag(HEAD, TagType.CLOSE);\r\n    closeTag.setOpenTag(openTag);\r\n    closeTag.setModified(true);\r\n        markup.addMarkupElement(openTag);\r\n    markup.addMarkupElement(closeTag);\r\n}","lc":-0.1363636364,"pi":-0.6937799043,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.1374207188,"fo":0.0833333333,"r":0.3157894737,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2487_f2920c26","label":0,"code":"\/**\r\n * Get the data from the BytesWritable.\r\n *\r\n * @return The data is only valid between 0 and getSize() - 1.\r\n *\/\r\npublic byte[] get() {\r\n    if (this.value == null) {\r\n        throw new IllegalStateException(\"Uninitialized. Null constructor \" + \"called w\/o accompanying readFields invocation\");\r\n    }\r\n    return this.value;\r\n}","code_comment":"\/**\r\n * Get the data from the BytesWritable.\r\n *\r\n * @return The data is only valid between 0 and getSize() - 1.\r\n *\/\r\n","code_no_comment":"public byte[] get() {\r\n    if (this.value == null) {\r\n        throw new IllegalStateException(\"Uninitialized. Null constructor \" + \"called w\/o accompanying readFields invocation\");\r\n    }\r\n    return this.value;\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.1388888889,"mi":0.6332628612,"fo":-0.5,"r":2.5526315789,"e":-0.1460901437}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4309_b4274415","label":1,"code":"\/**\r\n *  Convert to object types, returning null if text is null.\r\n *\r\n *  @return converted\r\n *  @throws StringValueConversionException\r\n *\/\r\npublic final Character toOptionalCharacter() throws StringValueConversionException {\r\n    return (text == null) ? null : toCharacter();\r\n}","code_comment":"\/**\r\n *  Convert to object types, returning null if text is null.\r\n *\r\n *  @return converted\r\n *  @throws StringValueConversionException\r\n *\/\r\n","code_no_comment":"public final Character toOptionalCharacter() throws StringValueConversionException {\r\n    return (text == null) ? null : toCharacter();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.3650793651,"mi":0.9797040169,"fo":-0.4166666667,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1070_8e5867ed","label":0,"code":"\/**\r\n * Rounds the given non-negative value to the \"nearest\" integer. Nearest is\r\n * determined by the rounding method specified. Rounding methods are defined\r\n * in {@link BigDecimal}.\r\n *\r\n * @param unscaled Value to round.\r\n * @param sign Sign of the original, scaled value.\r\n * @param roundingMethod Rounding method, as defined in {@link BigDecimal}.\r\n * @return the rounded value.\r\n * @throws MathArithmeticException if an exact operation is required but result is not exact\r\n * @throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.\r\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\r\n *\/\r\nprivate static double roundUnscaled(double unscaled, double sign, int roundingMethod) throws MathArithmeticException, MathIllegalArgumentException {\r\n    switch(roundingMethod) {\r\n        case BigDecimal.ROUND_CEILING:\r\n            if (sign == -1) {\r\n                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\r\n            } else {\r\n                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\r\n            }\r\n            break;\r\n        case BigDecimal.ROUND_DOWN:\r\n            unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\r\n            break;\r\n        case BigDecimal.ROUND_FLOOR:\r\n            if (sign == -1) {\r\n                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\r\n            } else {\r\n                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\r\n            }\r\n            break;\r\n        case BigDecimal.ROUND_HALF_DOWN:\r\n            {\r\n                unscaled = FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY);\r\n                double fraction = unscaled - FastMath.floor(unscaled);\r\n                if (fraction > 0.5) {\r\n                    unscaled = FastMath.ceil(unscaled);\r\n                } else {\r\n                    unscaled = FastMath.floor(unscaled);\r\n                }\r\n                break;\r\n            }\r\n        case BigDecimal.ROUND_HALF_EVEN:\r\n            {\r\n                double fraction = unscaled - FastMath.floor(unscaled);\r\n                if (fraction > 0.5) {\r\n                    unscaled = FastMath.ceil(unscaled);\r\n                } else if (fraction < 0.5) {\r\n                    unscaled = FastMath.floor(unscaled);\r\n                } else {\r\n                    \/\/ The following equality test is intentional and needed for rounding purposes\r\n                    if (FastMath.floor(unscaled) \/ 2.0 == FastMath.floor(Math.floor(unscaled) \/ 2.0)) {\r\n                        \/\/ even\r\n                        unscaled = FastMath.floor(unscaled);\r\n                    } else {\r\n                        \/\/ odd\r\n                        unscaled = FastMath.ceil(unscaled);\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        case BigDecimal.ROUND_HALF_UP:\r\n            {\r\n                unscaled = FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY);\r\n                double fraction = unscaled - FastMath.floor(unscaled);\r\n                if (fraction >= 0.5) {\r\n                    unscaled = FastMath.ceil(unscaled);\r\n                } else {\r\n                    unscaled = FastMath.floor(unscaled);\r\n                }\r\n                break;\r\n            }\r\n        case BigDecimal.ROUND_UNNECESSARY:\r\n            if (unscaled != FastMath.floor(unscaled)) {\r\n                throw new MathArithmeticException();\r\n            }\r\n            break;\r\n        case BigDecimal.ROUND_UP:\r\n            unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\r\n            break;\r\n        default:\r\n            throw new MathIllegalArgumentException(LocalizedFormats.INVALID_ROUNDING_METHOD, roundingMethod, \"ROUND_CEILING\", BigDecimal.ROUND_CEILING, \"ROUND_DOWN\", BigDecimal.ROUND_DOWN, \"ROUND_FLOOR\", BigDecimal.ROUND_FLOOR, \"ROUND_HALF_DOWN\", BigDecimal.ROUND_HALF_DOWN, \"ROUND_HALF_EVEN\", BigDecimal.ROUND_HALF_EVEN, \"ROUND_HALF_UP\", BigDecimal.ROUND_HALF_UP, \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY, \"ROUND_UP\", BigDecimal.ROUND_UP);\r\n    }\r\n    return unscaled;\r\n}","code_comment":"\/**\r\n * Rounds the given non-negative value to the \"nearest\" integer. Nearest is\r\n * determined by the rounding method specified. Rounding methods are defined\r\n * in {@link BigDecimal}.\r\n *\r\n * @param unscaled Value to round.\r\n * @param sign Sign of the original, scaled value.\r\n * @param roundingMethod Rounding method, as defined in {@link BigDecimal}.\r\n * @return the rounded value.\r\n * @throws MathArithmeticException if an exact operation is required but result is not exact\r\n * @throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.\r\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\r\n *\/\r\n","code_no_comment":"private static double roundUnscaled(double unscaled, double sign, int roundingMethod) throws MathArithmeticException, MathIllegalArgumentException {\r\n    switch(roundingMethod) {\r\n        case BigDecimal.ROUND_CEILING:\r\n            if (sign == -1) {\r\n                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\r\n            } else {\r\n                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\r\n            }\r\n            break;\r\n        case BigDecimal.ROUND_DOWN:\r\n            unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\r\n            break;\r\n        case BigDecimal.ROUND_FLOOR:\r\n            if (sign == -1) {\r\n                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\r\n            } else {\r\n                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\r\n            }\r\n            break;\r\n        case BigDecimal.ROUND_HALF_DOWN:\r\n            {\r\n                unscaled = FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY);\r\n                double fraction = unscaled - FastMath.floor(unscaled);\r\n                if (fraction > 0.5) {\r\n                    unscaled = FastMath.ceil(unscaled);\r\n                } else {\r\n                    unscaled = FastMath.floor(unscaled);\r\n                }\r\n                break;\r\n            }\r\n        case BigDecimal.ROUND_HALF_EVEN:\r\n            {\r\n                double fraction = unscaled - FastMath.floor(unscaled);\r\n                if (fraction > 0.5) {\r\n                    unscaled = FastMath.ceil(unscaled);\r\n                } else if (fraction < 0.5) {\r\n                    unscaled = FastMath.floor(unscaled);\r\n                } else {\r\n                                        if (FastMath.floor(unscaled) \/ 2.0 == FastMath.floor(Math.floor(unscaled) \/ 2.0)) {\r\n                                                unscaled = FastMath.floor(unscaled);\r\n                    } else {\r\n                                                unscaled = FastMath.ceil(unscaled);\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        case BigDecimal.ROUND_HALF_UP:\r\n            {\r\n                unscaled = FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY);\r\n                double fraction = unscaled - FastMath.floor(unscaled);\r\n                if (fraction >= 0.5) {\r\n                    unscaled = FastMath.ceil(unscaled);\r\n                } else {\r\n                    unscaled = FastMath.floor(unscaled);\r\n                }\r\n                break;\r\n            }\r\n        case BigDecimal.ROUND_UNNECESSARY:\r\n            if (unscaled != FastMath.floor(unscaled)) {\r\n                throw new MathArithmeticException();\r\n            }\r\n            break;\r\n        case BigDecimal.ROUND_UP:\r\n            unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\r\n            break;\r\n        default:\r\n            throw new MathIllegalArgumentException(LocalizedFormats.INVALID_ROUNDING_METHOD, roundingMethod, \"ROUND_CEILING\", BigDecimal.ROUND_CEILING, \"ROUND_DOWN\", BigDecimal.ROUND_DOWN, \"ROUND_FLOOR\", BigDecimal.ROUND_FLOOR, \"ROUND_HALF_DOWN\", BigDecimal.ROUND_HALF_DOWN, \"ROUND_HALF_EVEN\", BigDecimal.ROUND_HALF_EVEN, \"ROUND_HALF_UP\", BigDecimal.ROUND_HALF_UP, \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY, \"ROUND_UP\", BigDecimal.ROUND_UP);\r\n    }\r\n    return unscaled;\r\n}","lc":2.5454545455,"pi":0.9282296651,"ma":4.8,"nbd":1.5,"ml":1.5,"d":4.5813492063,"mi":-1.178435518,"fo":1.9166666667,"r":-0.0263157895,"e":13.1691476058}
{"project_name":"Csv","project_version":"15","label":1,"code":"\/*\r\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\r\n     *\/\r\n\/\/ the original object is needed so can check for Number\r\nprivate void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {\r\n    boolean quote = false;\r\n    int start = offset;\r\n    int pos = offset;\r\n    final int end = offset + len;\r\n    final char delimChar = getDelimiter();\r\n    final char quoteChar = getQuoteCharacter().charValue();\r\n    QuoteMode quoteModePolicy = getQuoteMode();\r\n    if (quoteModePolicy == null) {\r\n        quoteModePolicy = QuoteMode.MINIMAL;\r\n    }\r\n    switch(quoteModePolicy) {\r\n        case ALL:\r\n        case ALL_NON_NULL:\r\n            quote = true;\r\n            break;\r\n        case NON_NUMERIC:\r\n            quote = !(object instanceof Number);\r\n            break;\r\n        case NONE:\r\n            \/\/ Use the existing escaping code\r\n            printAndEscape(value, offset, len, out);\r\n            return;\r\n        case MINIMAL:\r\n            if (len <= 0) {\r\n                \/\/ an empty line has no tokens.\r\n                if (newRecord) {\r\n                    quote = true;\r\n                }\r\n            } else {\r\n                char c = value.charAt(pos);\r\n                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\r\n                    quote = true;\r\n                } else if (c <= COMMENT) {\r\n                    \/\/ Some other chars at the start of a value caused the parser to fail, so for now\r\n                    \/\/ encapsulate if we start in anything less than '#'. We are being conservative\r\n                    \/\/ by including the default comment char too.\r\n                    quote = true;\r\n                } else {\r\n                    while (pos < end) {\r\n                        c = value.charAt(pos);\r\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\r\n                            quote = true;\r\n                            break;\r\n                        }\r\n                        pos++;\r\n                    }\r\n                    if (!quote) {\r\n                        pos = end - 1;\r\n                        c = value.charAt(pos);\r\n                        \/\/ encapsulate if we end in anything less than ' '\r\n                        if (c <= SP) {\r\n                            quote = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!quote) {\r\n                \/\/ no encapsulation needed - write out the original value\r\n                out.append(value, start, end);\r\n                return;\r\n            }\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\r\n    }\r\n    if (!quote) {\r\n        \/\/ no encapsulation needed - write out the original value\r\n        out.append(value, start, end);\r\n        return;\r\n    }\r\n    \/\/ we hit something that needed encapsulation\r\n    out.append(quoteChar);\r\n    \/\/ the need for encapsulation.\r\n    while (pos < end) {\r\n        final char c = value.charAt(pos);\r\n        if (c == quoteChar) {\r\n            \/\/ write out the chunk up until this point\r\n            \/\/ add 1 to the length to write out the encapsulator also\r\n            out.append(value, start, pos + 1);\r\n            \/\/ put the next starting position on the encapsulator so we will\r\n            \/\/ write it out again with the next string (effectively doubling it)\r\n            start = pos;\r\n        }\r\n        pos++;\r\n    }\r\n    \/\/ write the last segment\r\n    out.append(value, start, pos);\r\n    out.append(quoteChar);\r\n}","code_comment":null,"code_no_comment":"private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException {\r\n    boolean quote = false;\r\n    int start = offset;\r\n    int pos = offset;\r\n    final int end = offset + len;\r\n    final char delimChar = getDelimiter();\r\n    final char quoteChar = getQuoteCharacter().charValue();\r\n    QuoteMode quoteModePolicy = getQuoteMode();\r\n    if (quoteModePolicy == null) {\r\n        quoteModePolicy = QuoteMode.MINIMAL;\r\n    }\r\n    switch(quoteModePolicy) {\r\n        case ALL:\r\n        case ALL_NON_NULL:\r\n            quote = true;\r\n            break;\r\n        case NON_NUMERIC:\r\n            quote = !(object instanceof Number);\r\n            break;\r\n        case NONE:\r\n                        printAndEscape(value, offset, len, out);\r\n            return;\r\n        case MINIMAL:\r\n            if (len <= 0) {\r\n                                if (newRecord) {\r\n                    quote = true;\r\n                }\r\n            } else {\r\n                char c = value.charAt(pos);\r\n                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\r\n                    quote = true;\r\n                } else if (c <= COMMENT) {\r\n                                                                                quote = true;\r\n                } else {\r\n                    while (pos < end) {\r\n                        c = value.charAt(pos);\r\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\r\n                            quote = true;\r\n                            break;\r\n                        }\r\n                        pos++;\r\n                    }\r\n                    if (!quote) {\r\n                        pos = end - 1;\r\n                        c = value.charAt(pos);\r\n                                                if (c <= SP) {\r\n                            quote = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!quote) {\r\n                                out.append(value, start, end);\r\n                return;\r\n            }\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\r\n    }\r\n    if (!quote) {\r\n                out.append(value, start, end);\r\n        return;\r\n    }\r\n        out.append(quoteChar);\r\n        while (pos < end) {\r\n        final char c = value.charAt(pos);\r\n        if (c == quoteChar) {\r\n                                    out.append(value, start, pos + 1);\r\n                                    start = pos;\r\n        }\r\n        pos++;\r\n    }\r\n        out.append(value, start, pos);\r\n    out.append(quoteChar);\r\n}","lc":2.7727272727,"pi":2.1291866029,"ma":4.2,"nbd":2.5,"ml":2.5833333333,"d":2.5535714286,"mi":-1.1992952784,"fo":0.75,"r":-0.0263157895,"e":8.1935720337}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-1205_1bdeeccc","label":1,"code":"private void recurse(ResolutionNode node, Map resolvedArtifacts, Map managedVersions, ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List listeners) throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException {\r\n    fireEvent(ResolutionListener.TEST_ARTIFACT, listeners, node);\r\n    \/\/ TODO: use as a conflict resolver\r\n    Object key = node.getKey();\r\n    if (managedVersions.containsKey(key)) {\r\n        Artifact artifact = (Artifact) managedVersions.get(key);\r\n        fireEvent(ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact);\r\n        if (artifact.getVersion() != null) {\r\n            node.getArtifact().setVersion(artifact.getVersion());\r\n        }\r\n        if (artifact.getScope() != null) {\r\n            node.getArtifact().setScope(artifact.getScope());\r\n        }\r\n    }\r\n    List previousNodes = (List) resolvedArtifacts.get(key);\r\n    if (previousNodes != null) {\r\n        for (Iterator i = previousNodes.iterator(); i.hasNext(); ) {\r\n            ResolutionNode previous = (ResolutionNode) i.next();\r\n            if (previous.isActive()) {\r\n                \/\/ Version mediation\r\n                VersionRange previousRange = previous.getArtifact().getVersionRange();\r\n                VersionRange currentRange = node.getArtifact().getVersionRange();\r\n                \/\/ TODO: why do we force the version on it? what if they don't match?\r\n                if (previousRange == null) {\r\n                    \/\/ version was already resolved\r\n                    node.getArtifact().setVersion(previous.getArtifact().getVersion());\r\n                } else if (currentRange == null) {\r\n                    \/\/ version was already resolved\r\n                    previous.getArtifact().setVersion(node.getArtifact().getVersion());\r\n                } else {\r\n                    \/\/ TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended\r\n                    \/\/ version but the restriction is identical\r\n                    VersionRange newRange = previousRange.restrict(currentRange);\r\n                    \/\/ TODO: ick. this forces the OCE that should have come from the previous call. It is still correct\r\n                    if (newRange.isSelectedVersionKnown(previous.getArtifact())) {\r\n                        fireEvent(ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(), newRange);\r\n                    }\r\n                    previous.getArtifact().setVersionRange(newRange);\r\n                    node.getArtifact().setVersionRange(currentRange.restrict(previousRange));\r\n                    \/\/ Select an appropriate available version from the (now restricted) range\r\n                    \/\/ Note this version was selected before to get the appropriate POM\r\n                    \/\/ But it was reset by the call to setVersionRange on restricting the version\r\n                    ResolutionNode[] resetNodes = { previous, node };\r\n                    for (int j = 0; j < 2; j++) {\r\n                        Artifact resetArtifact = resetNodes[j].getArtifact();\r\n                        if (resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null && resetArtifact.getAvailableVersions() != null) {\r\n                            resetArtifact.selectVersion(resetArtifact.getVersionRange().matchVersion(resetArtifact.getAvailableVersions()).toString());\r\n                            fireEvent(ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j]);\r\n                        }\r\n                    }\r\n                }\r\n                \/\/ previous one is more dominant\r\n                if (previous.getDepth() <= node.getDepth()) {\r\n                    checkScopeUpdate(node, previous, listeners);\r\n                } else {\r\n                    checkScopeUpdate(previous, node, listeners);\r\n                }\r\n                if (previous.getDepth() <= node.getDepth()) {\r\n                    \/\/ previous was nearer\r\n                    fireEvent(ResolutionListener.OMIT_FOR_NEARER, listeners, node, previous.getArtifact());\r\n                    node.disable();\r\n                } else {\r\n                    fireEvent(ResolutionListener.OMIT_FOR_NEARER, listeners, previous, node.getArtifact());\r\n                    previous.disable();\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        previousNodes = new ArrayList();\r\n        resolvedArtifacts.put(key, previousNodes);\r\n    }\r\n    previousNodes.add(node);\r\n    fireEvent(ResolutionListener.INCLUDE_ARTIFACT, listeners, node);\r\n    if (node.isActive()) {\r\n        fireEvent(ResolutionListener.PROCESS_CHILDREN, listeners, node);\r\n        for (Iterator i = node.getChildrenIterator(); i.hasNext(); ) {\r\n            ResolutionNode child = (ResolutionNode) i.next();\r\n            \/\/ We leave in optional ones, but don't pick up its dependencies\r\n            if (!child.isResolved() && !child.getArtifact().isOptional()) {\r\n                Artifact artifact = child.getArtifact();\r\n                try {\r\n                    if (artifact.getVersion() == null) {\r\n                        \/\/ set the recommended version\r\n                        \/\/ TODO: maybe its better to just pass the range through to retrieval and use a transformation?\r\n                        ArtifactVersion version;\r\n                        if (!artifact.isSelectedVersionKnown()) {\r\n                            List versions = artifact.getAvailableVersions();\r\n                            if (versions == null) {\r\n                                versions = source.retrieveAvailableVersions(artifact, localRepository, remoteRepositories);\r\n                                artifact.setAvailableVersions(versions);\r\n                            }\r\n                            VersionRange versionRange = artifact.getVersionRange();\r\n                            version = versionRange.matchVersion(versions);\r\n                            if (version == null) {\r\n                                if (versions.isEmpty()) {\r\n                                    throw new OverConstrainedVersionException(\"No versions are present in the repository for the artifact with a range \" + versionRange, artifact, remoteRepositories);\r\n                                } else {\r\n                                    throw new OverConstrainedVersionException(\"Couldn't find a version in \" + versions + \" to match range \" + versionRange, artifact, remoteRepositories);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            version = artifact.getSelectedVersion();\r\n                        }\r\n                        artifact.selectVersion(version.toString());\r\n                        fireEvent(ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child);\r\n                    }\r\n                    ResolutionGroup rGroup = source.retrieve(artifact, localRepository, remoteRepositories);\r\n                    \/\/ and catch here rather than have it return null\r\n                    if (rGroup == null) {\r\n                        \/\/ relocated dependency artifact is declared excluded, no need to add and recurse further\r\n                        continue;\r\n                    }\r\n                    child.addDependencies(rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter);\r\n                } catch (CyclicDependencyException e) {\r\n                    \/\/ would like to throw this, but we have crappy stuff in the repo\r\n                    fireEvent(ResolutionListener.OMIT_FOR_CYCLE, listeners, new ResolutionNode(e.getArtifact(), remoteRepositories, child));\r\n                } catch (ArtifactMetadataRetrievalException e) {\r\n                    artifact.setDependencyTrail(node.getDependencyTrail());\r\n                    throw new ArtifactResolutionException(\"Unable to get dependency information: \" + e.getMessage(), artifact, remoteRepositories, e);\r\n                }\r\n                recurse(child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter, listeners);\r\n            }\r\n        }\r\n        fireEvent(ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void recurse(ResolutionNode node, Map resolvedArtifacts, Map managedVersions, ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List listeners) throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException {\r\n    fireEvent(ResolutionListener.TEST_ARTIFACT, listeners, node);\r\n        Object key = node.getKey();\r\n    if (managedVersions.containsKey(key)) {\r\n        Artifact artifact = (Artifact) managedVersions.get(key);\r\n        fireEvent(ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact);\r\n        if (artifact.getVersion() != null) {\r\n            node.getArtifact().setVersion(artifact.getVersion());\r\n        }\r\n        if (artifact.getScope() != null) {\r\n            node.getArtifact().setScope(artifact.getScope());\r\n        }\r\n    }\r\n    List previousNodes = (List) resolvedArtifacts.get(key);\r\n    if (previousNodes != null) {\r\n        for (Iterator i = previousNodes.iterator(); i.hasNext(); ) {\r\n            ResolutionNode previous = (ResolutionNode) i.next();\r\n            if (previous.isActive()) {\r\n                                VersionRange previousRange = previous.getArtifact().getVersionRange();\r\n                VersionRange currentRange = node.getArtifact().getVersionRange();\r\n                                if (previousRange == null) {\r\n                                        node.getArtifact().setVersion(previous.getArtifact().getVersion());\r\n                } else if (currentRange == null) {\r\n                                        previous.getArtifact().setVersion(node.getArtifact().getVersion());\r\n                } else {\r\n                                                            VersionRange newRange = previousRange.restrict(currentRange);\r\n                                        if (newRange.isSelectedVersionKnown(previous.getArtifact())) {\r\n                        fireEvent(ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(), newRange);\r\n                    }\r\n                    previous.getArtifact().setVersionRange(newRange);\r\n                    node.getArtifact().setVersionRange(currentRange.restrict(previousRange));\r\n                                                                                ResolutionNode[] resetNodes = { previous, node };\r\n                    for (int j = 0; j < 2; j++) {\r\n                        Artifact resetArtifact = resetNodes[j].getArtifact();\r\n                        if (resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null && resetArtifact.getAvailableVersions() != null) {\r\n                            resetArtifact.selectVersion(resetArtifact.getVersionRange().matchVersion(resetArtifact.getAvailableVersions()).toString());\r\n                            fireEvent(ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j]);\r\n                        }\r\n                    }\r\n                }\r\n                                if (previous.getDepth() <= node.getDepth()) {\r\n                    checkScopeUpdate(node, previous, listeners);\r\n                } else {\r\n                    checkScopeUpdate(previous, node, listeners);\r\n                }\r\n                if (previous.getDepth() <= node.getDepth()) {\r\n                                        fireEvent(ResolutionListener.OMIT_FOR_NEARER, listeners, node, previous.getArtifact());\r\n                    node.disable();\r\n                } else {\r\n                    fireEvent(ResolutionListener.OMIT_FOR_NEARER, listeners, previous, node.getArtifact());\r\n                    previous.disable();\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        previousNodes = new ArrayList();\r\n        resolvedArtifacts.put(key, previousNodes);\r\n    }\r\n    previousNodes.add(node);\r\n    fireEvent(ResolutionListener.INCLUDE_ARTIFACT, listeners, node);\r\n    if (node.isActive()) {\r\n        fireEvent(ResolutionListener.PROCESS_CHILDREN, listeners, node);\r\n        for (Iterator i = node.getChildrenIterator(); i.hasNext(); ) {\r\n            ResolutionNode child = (ResolutionNode) i.next();\r\n                        if (!child.isResolved() && !child.getArtifact().isOptional()) {\r\n                Artifact artifact = child.getArtifact();\r\n                try {\r\n                    if (artifact.getVersion() == null) {\r\n                                                                        ArtifactVersion version;\r\n                        if (!artifact.isSelectedVersionKnown()) {\r\n                            List versions = artifact.getAvailableVersions();\r\n                            if (versions == null) {\r\n                                versions = source.retrieveAvailableVersions(artifact, localRepository, remoteRepositories);\r\n                                artifact.setAvailableVersions(versions);\r\n                            }\r\n                            VersionRange versionRange = artifact.getVersionRange();\r\n                            version = versionRange.matchVersion(versions);\r\n                            if (version == null) {\r\n                                if (versions.isEmpty()) {\r\n                                    throw new OverConstrainedVersionException(\"No versions are present in the repository for the artifact with a range \" + versionRange, artifact, remoteRepositories);\r\n                                } else {\r\n                                    throw new OverConstrainedVersionException(\"Couldn't find a version in \" + versions + \" to match range \" + versionRange, artifact, remoteRepositories);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            version = artifact.getSelectedVersion();\r\n                        }\r\n                        artifact.selectVersion(version.toString());\r\n                        fireEvent(ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child);\r\n                    }\r\n                    ResolutionGroup rGroup = source.retrieve(artifact, localRepository, remoteRepositories);\r\n                                        if (rGroup == null) {\r\n                                                continue;\r\n                    }\r\n                    child.addDependencies(rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter);\r\n                } catch (CyclicDependencyException e) {\r\n                                        fireEvent(ResolutionListener.OMIT_FOR_CYCLE, listeners, new ResolutionNode(e.getArtifact(), remoteRepositories, child));\r\n                } catch (ArtifactMetadataRetrievalException e) {\r\n                    artifact.setDependencyTrail(node.getDependencyTrail());\r\n                    throw new ArtifactResolutionException(\"Unable to get dependency information: \" + e.getMessage(), artifact, remoteRepositories, e);\r\n                }\r\n                recurse(child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter, listeners);\r\n            }\r\n        }\r\n        fireEvent(ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node);\r\n    }\r\n}","lc":4.2272727273,"pi":2.6507177033,"ma":5.0,"nbd":3.0,"ml":3.75,"d":2.4563492063,"mi":-1.5048625793,"fo":7.5833333333,"r":-0.0263157895,"e":17.8399151697}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-1931_986848f7","label":1,"code":"\/**\r\n *  Returns an input stream if there has been added some uploaded files. Use\r\n *  {@link #addFile(String, File, String)} to add some uploaded files.\r\n *\r\n *  @return The input stream\r\n *  @throws IOException\r\n *              If an I\/O related problem occurs\r\n *\/\r\npublic ServletInputStream getInputStream() throws IOException {\r\n    if (uploadedFiles != null && uploadedFiles.size() > 0) {\r\n        byte[] request = buildRequest();\r\n        \/\/ Ok lets make an input stream to return\r\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\r\n        return new ServletInputStream() {\r\n\r\n            @Override\r\n            public int read() {\r\n                return bais.read();\r\n            }\r\n        };\r\n    } else {\r\n        return new ServletInputStream() {\r\n\r\n            @Override\r\n            public int read() {\r\n                return -1;\r\n            }\r\n        };\r\n    }\r\n}","code_comment":"\/**\r\n *  Returns an input stream if there has been added some uploaded files. Use\r\n *  {@link #addFile(String, File, String)} to add some uploaded files.\r\n *\r\n *  @return The input stream\r\n *  @throws IOException\r\n *              If an I\/O related problem occurs\r\n *\/\r\n","code_no_comment":"public ServletInputStream getInputStream() throws IOException {\r\n    if (uploadedFiles != null && uploadedFiles.size() > 0) {\r\n        byte[] request = buildRequest();\r\n                final ByteArrayInputStream bais = new ByteArrayInputStream(request);\r\n        return new ServletInputStream() {\r\n\r\n            @Override\r\n            public int read() {\r\n                return bais.read();\r\n            }\r\n        };\r\n    } else {\r\n        return new ServletInputStream() {\r\n\r\n            @Override\r\n            public int read() {\r\n                return -1;\r\n            }\r\n        };\r\n    }\r\n}","lc":0.2272727273,"pi":0.7416267943,"ma":-0.4,"nbd":0.0,"ml":-0.0833333333,"d":0.2698412698,"mi":-0.0931642001,"fo":-0.25,"r":0.8421052632,"e":0.0284942054}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2899_31aea2ad","label":0,"code":"\/\/ TODO Remove deprecation warning suppression when Hadoop1 support is dropped\r\n@SuppressWarnings(\"deprecation\")\r\n\/**\r\n * Scans write-ahead log directories for logs. The maps passed in are\r\n * populated with scan information.\r\n *\r\n * @param walDirs write-ahead log directories\r\n * @param fileToServerMap map of file paths to servers\r\n * @param nameToFileMap map of file names to paths\r\n * @return number of servers located (including those with no logs present)\r\n *\/\r\nint scanServers(String[] walDirs, Map<Path, String> fileToServerMap, Map<String, Path> nameToFileMap) throws Exception {\r\n    Set<String> servers = new HashSet<String>();\r\n    for (String walDir : walDirs) {\r\n        Path walRoot = new Path(walDir);\r\n        FileStatus[] listing = null;\r\n        try {\r\n            listing = fs.listStatus(walRoot);\r\n        } catch (FileNotFoundException e) {\r\n        \/\/ ignore dir\r\n        }\r\n        if (listing == null)\r\n            continue;\r\n        for (FileStatus status : listing) {\r\n            String server = status.getPath().getName();\r\n            servers.add(server);\r\n            if (status.isDir()) {\r\n                for (FileStatus file : fs.listStatus(new Path(walRoot, server))) {\r\n                    if (isUUID(file.getPath().getName())) {\r\n                        fileToServerMap.put(file.getPath(), server);\r\n                        nameToFileMap.put(file.getPath().getName(), file.getPath());\r\n                    } else {\r\n                        log.info(\"Ignoring file \" + file.getPath() + \" because it doesn't look like a uuid\");\r\n                    }\r\n                }\r\n            } else if (isUUID(server)) {\r\n                \/\/ old-style WAL are not under a directory\r\n                fileToServerMap.put(status.getPath(), \"\");\r\n            } else {\r\n                log.info(\"Ignoring file \" + status.getPath() + \" because it doesn't look like a uuid\");\r\n            }\r\n        }\r\n    }\r\n    return servers.size();\r\n}","code_comment":"\/**\r\n * Scans write-ahead log directories for logs. The maps passed in are\r\n * populated with scan information.\r\n *\r\n * @param walDirs write-ahead log directories\r\n * @param fileToServerMap map of file paths to servers\r\n * @param nameToFileMap map of file names to paths\r\n * @return number of servers located (including those with no logs present)\r\n *\/\r\n","code_no_comment":"@SuppressWarnings(\"deprecation\")\r\nint scanServers(String[] walDirs, Map<Path, String> fileToServerMap, Map<String, Path> nameToFileMap) throws Exception {\r\n    Set<String> servers = new HashSet<String>();\r\n    for (String walDir : walDirs) {\r\n        Path walRoot = new Path(walDir);\r\n        FileStatus[] listing = null;\r\n        try {\r\n            listing = fs.listStatus(walRoot);\r\n        } catch (FileNotFoundException e) {\r\n                }\r\n        if (listing == null)\r\n            continue;\r\n        for (FileStatus status : listing) {\r\n            String server = status.getPath().getName();\r\n            servers.add(server);\r\n            if (status.isDir()) {\r\n                for (FileStatus file : fs.listStatus(new Path(walRoot, server))) {\r\n                    if (isUUID(file.getPath().getName())) {\r\n                        fileToServerMap.put(file.getPath(), server);\r\n                        nameToFileMap.put(file.getPath().getName(), file.getPath());\r\n                    } else {\r\n                        log.info(\"Ignoring file \" + file.getPath() + \" because it doesn't look like a uuid\");\r\n                    }\r\n                }\r\n            } else if (isUUID(server)) {\r\n                                fileToServerMap.put(status.getPath(), \"\");\r\n            } else {\r\n                log.info(\"Ignoring file \" + status.getPath() + \" because it doesn't look like a uuid\");\r\n            }\r\n        }\r\n    }\r\n    return servers.size();\r\n}","lc":0.8636363636,"pi":1.7799043062,"ma":1.2,"nbd":1.5,"ml":0.4166666667,"d":0.130952381,"mi":-0.6093023256,"fo":1.4166666667,"r":-0.0263157895,"e":0.4732352484}
{"project_name":"Closure","project_version":"121","label":2,"code":"private void inlineNonConstants(Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) {\r\n    int refCount = referenceInfo.references.size();\r\n    Reference declaration = referenceInfo.references.get(0);\r\n    Reference init = referenceInfo.getInitializingReference();\r\n    int firstRefAfterInit = (declaration == init) ? 2 : 3;\r\n    if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) {\r\n        \/\/ if the variable is referenced more than once, we can only\r\n        \/\/ inline it if it's immutable and never defined before referenced.\r\n        Node value;\r\n        if (init != null) {\r\n            value = init.getAssignedValue();\r\n        } else {\r\n            \/\/ Create a new node for variable that is never initialized.\r\n            Node srcLocation = declaration.getNode();\r\n            value = NodeUtil.newUndefinedNode(srcLocation);\r\n        }\r\n        Preconditions.checkNotNull(value);\r\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\r\n        staleVars.add(v);\r\n    } else if (refCount == firstRefAfterInit) {\r\n        \/\/ The variable likely only read once, try some more\r\n        \/\/ complex inlining heuristics.\r\n        Reference reference = referenceInfo.references.get(firstRefAfterInit - 1);\r\n        if (canInline(declaration, init, reference)) {\r\n            inline(v, declaration, init, reference);\r\n            staleVars.add(v);\r\n        }\r\n    } else if (declaration != init && refCount == 2) {\r\n        if (isValidDeclaration(declaration) && isValidInitialization(init)) {\r\n            \/\/ The only reference is the initialization, remove the assignment and\r\n            \/\/ the variable declaration.\r\n            Node value = init.getAssignedValue();\r\n            Preconditions.checkNotNull(value);\r\n            inlineWellDefinedVariable(v, value, referenceInfo.references);\r\n            staleVars.add(v);\r\n        }\r\n    }\r\n    \/\/ the next pass.)\r\n    if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {\r\n        \/\/ Inlining the variable based solely on well-defined and assigned\r\n        \/\/ once is *NOT* correct. We relax the correctness requirement if\r\n        \/\/ the variable is declared constant.\r\n        List<Reference> refs = referenceInfo.references;\r\n        for (int i = 1; \/* start from a read *\/\r\n        i < refs.size(); i++) {\r\n            Node nameNode = refs.get(i).getNode();\r\n            if (aliasCandidates.containsKey(nameNode)) {\r\n                AliasCandidate candidate = aliasCandidates.get(nameNode);\r\n                if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) {\r\n                    Reference aliasInit;\r\n                    aliasInit = candidate.refInfo.getInitializingReference();\r\n                    Node value = aliasInit.getAssignedValue();\r\n                    Preconditions.checkNotNull(value);\r\n                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\r\n                    staleVars.add(candidate.alias);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void inlineNonConstants(Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) {\r\n    int refCount = referenceInfo.references.size();\r\n    Reference declaration = referenceInfo.references.get(0);\r\n    Reference init = referenceInfo.getInitializingReference();\r\n    int firstRefAfterInit = (declaration == init) ? 2 : 3;\r\n    if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) {\r\n                        Node value;\r\n        if (init != null) {\r\n            value = init.getAssignedValue();\r\n        } else {\r\n                        Node srcLocation = declaration.getNode();\r\n            value = NodeUtil.newUndefinedNode(srcLocation);\r\n        }\r\n        Preconditions.checkNotNull(value);\r\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\r\n        staleVars.add(v);\r\n    } else if (refCount == firstRefAfterInit) {\r\n                        Reference reference = referenceInfo.references.get(firstRefAfterInit - 1);\r\n        if (canInline(declaration, init, reference)) {\r\n            inline(v, declaration, init, reference);\r\n            staleVars.add(v);\r\n        }\r\n    } else if (declaration != init && refCount == 2) {\r\n        if (isValidDeclaration(declaration) && isValidInitialization(init)) {\r\n                                    Node value = init.getAssignedValue();\r\n            Preconditions.checkNotNull(value);\r\n            inlineWellDefinedVariable(v, value, referenceInfo.references);\r\n            staleVars.add(v);\r\n        }\r\n    }\r\n        if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) {\r\n                                List<Reference> refs = referenceInfo.references;\r\n        for (int i = 1;         i < refs.size(); i++) {\r\n            Node nameNode = refs.get(i).getNode();\r\n            if (aliasCandidates.containsKey(nameNode)) {\r\n                AliasCandidate candidate = aliasCandidates.get(nameNode);\r\n                if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) {\r\n                    Reference aliasInit;\r\n                    aliasInit = candidate.refInfo.getInitializingReference();\r\n                    Node value = aliasInit.getAssignedValue();\r\n                    Preconditions.checkNotNull(value);\r\n                    inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references);\r\n                    staleVars.add(candidate.alias);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","lc":1.5909090909,"pi":1.1052631579,"ma":1.6,"nbd":1.0,"ml":2.9166666667,"d":2.0595238095,"mi":-0.9145877378,"fo":2.4166666667,"r":-0.0263157895,"e":6.5060723939}
{"project_name":"Math","project_version":"51","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\nprotected final double doSolve() {\r\n    \/\/ Get initial solution\r\n    double x0 = getMin();\r\n    double x1 = getMax();\r\n    double f0 = computeObjectiveValue(x0);\r\n    double f1 = computeObjectiveValue(x1);\r\n    \/\/ regardless of the allowed solutions.\r\n    if (f0 == 0.0) {\r\n        return x0;\r\n    }\r\n    if (f1 == 0.0) {\r\n        return x1;\r\n    }\r\n    \/\/ Verify bracketing of initial solution.\r\n    verifyBracketing(x0, x1);\r\n    \/\/ Get accuracies.\r\n    final double ftol = getFunctionValueAccuracy();\r\n    final double atol = getAbsoluteAccuracy();\r\n    final double rtol = getRelativeAccuracy();\r\n    \/\/ Keep track of inverted intervals, meaning that the left bound is\r\n    \/\/ larger than the right bound.\r\n    boolean inverted = false;\r\n    \/\/ Keep finding better approximations.\r\n    while (true) {\r\n        \/\/ Calculate the next approximation.\r\n        final double x = x1 - ((f1 * (x1 - x0)) \/ (f1 - f0));\r\n        final double fx = computeObjectiveValue(x);\r\n        \/\/ we can return it regardless of the allowed solutions.\r\n        if (fx == 0.0) {\r\n            return x;\r\n        }\r\n        \/\/ Update the bounds with the new approximation.\r\n        if (f1 * fx < 0) {\r\n            \/\/ The value of x1 has switched to the other bound, thus inverting\r\n            \/\/ the interval.\r\n            x0 = x1;\r\n            f0 = f1;\r\n            inverted = !inverted;\r\n        } else {\r\n            switch(method) {\r\n                case ILLINOIS:\r\n                    f0 *= 0.5;\r\n                    break;\r\n                case PEGASUS:\r\n                    f0 *= f1 \/ (f1 + fx);\r\n                    break;\r\n                \/\/ search interval.\r\n                default:\r\n            }\r\n        }\r\n        \/\/ Update from [x0, x1] to [x0, x].\r\n        x1 = x;\r\n        f1 = fx;\r\n        \/\/ the root than we already are.\r\n        if (FastMath.abs(f1) <= ftol) {\r\n            switch(allowed) {\r\n                case ANY_SIDE:\r\n                    return x1;\r\n                case LEFT_SIDE:\r\n                    if (inverted) {\r\n                        return x1;\r\n                    }\r\n                    break;\r\n                case RIGHT_SIDE:\r\n                    if (!inverted) {\r\n                        return x1;\r\n                    }\r\n                    break;\r\n                case BELOW_SIDE:\r\n                    if (f1 <= 0) {\r\n                        return x1;\r\n                    }\r\n                    break;\r\n                case ABOVE_SIDE:\r\n                    if (f1 >= 0) {\r\n                        return x1;\r\n                    }\r\n                    break;\r\n                default:\r\n                    throw new MathInternalError();\r\n            }\r\n        }\r\n        \/\/ are satisfied with the current approximation.\r\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\r\n            switch(allowed) {\r\n                case ANY_SIDE:\r\n                    return x1;\r\n                case LEFT_SIDE:\r\n                    return inverted ? x1 : x0;\r\n                case RIGHT_SIDE:\r\n                    return inverted ? x0 : x1;\r\n                case BELOW_SIDE:\r\n                    return (f1 <= 0) ? x1 : x0;\r\n                case ABOVE_SIDE:\r\n                    return (f1 >= 0) ? x1 : x0;\r\n                default:\r\n                    throw new MathInternalError();\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"protected final double doSolve() {\r\n        double x0 = getMin();\r\n    double x1 = getMax();\r\n    double f0 = computeObjectiveValue(x0);\r\n    double f1 = computeObjectiveValue(x1);\r\n        if (f0 == 0.0) {\r\n        return x0;\r\n    }\r\n    if (f1 == 0.0) {\r\n        return x1;\r\n    }\r\n        verifyBracketing(x0, x1);\r\n        final double ftol = getFunctionValueAccuracy();\r\n    final double atol = getAbsoluteAccuracy();\r\n    final double rtol = getRelativeAccuracy();\r\n            boolean inverted = false;\r\n        while (true) {\r\n                final double x = x1 - ((f1 * (x1 - x0)) \/ (f1 - f0));\r\n        final double fx = computeObjectiveValue(x);\r\n                if (fx == 0.0) {\r\n            return x;\r\n        }\r\n                if (f1 * fx < 0) {\r\n                                    x0 = x1;\r\n            f0 = f1;\r\n            inverted = !inverted;\r\n        } else {\r\n            switch(method) {\r\n                case ILLINOIS:\r\n                    f0 *= 0.5;\r\n                    break;\r\n                case PEGASUS:\r\n                    f0 *= f1 \/ (f1 + fx);\r\n                    break;\r\n                                default:\r\n            }\r\n        }\r\n                x1 = x;\r\n        f1 = fx;\r\n                if (FastMath.abs(f1) <= ftol) {\r\n            switch(allowed) {\r\n                case ANY_SIDE:\r\n                    return x1;\r\n                case LEFT_SIDE:\r\n                    if (inverted) {\r\n                        return x1;\r\n                    }\r\n                    break;\r\n                case RIGHT_SIDE:\r\n                    if (!inverted) {\r\n                        return x1;\r\n                    }\r\n                    break;\r\n                case BELOW_SIDE:\r\n                    if (f1 <= 0) {\r\n                        return x1;\r\n                    }\r\n                    break;\r\n                case ABOVE_SIDE:\r\n                    if (f1 >= 0) {\r\n                        return x1;\r\n                    }\r\n                    break;\r\n                default:\r\n                    throw new MathInternalError();\r\n            }\r\n        }\r\n                if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\r\n            switch(allowed) {\r\n                case ANY_SIDE:\r\n                    return x1;\r\n                case LEFT_SIDE:\r\n                    return inverted ? x1 : x0;\r\n                case RIGHT_SIDE:\r\n                    return inverted ? x0 : x1;\r\n                case BELOW_SIDE:\r\n                    return (f1 <= 0) ? x1 : x0;\r\n                case ABOVE_SIDE:\r\n                    return (f1 >= 0) ? x1 : x0;\r\n                default:\r\n                    throw new MathInternalError();\r\n            }\r\n        }\r\n    }\r\n}","lc":3.2272727273,"pi":1.7416267943,"ma":7.0,"nbd":1.5,"ml":3.0833333333,"d":2.8531746032,"mi":-1.2990838619,"fo":0.5833333333,"r":-0.0263157895,"e":6.4761651193}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-392_731c84b5","label":1,"code":"\/**\r\n * Tear down the configuration.\r\n *\/\r\n@Override\r\npublic void stop() {\r\n    this.setStopping();\r\n    LOGGER.trace(\"Stopping {}...\", this);\r\n    \/\/ LOG4J2-392 first stop AsyncLogger Disruptor thread\r\n    final LoggerContextFactory factory = LogManager.getFactory();\r\n    if (factory instanceof Log4jContextFactory) {\r\n        ContextSelector selector = ((Log4jContextFactory) factory).getSelector();\r\n        if (selector instanceof AsyncLoggerContextSelector) {\r\n        \/\/ all loggers are async\r\n        \/\/ TODO until LOG4J2-493 is fixed we can only stop AsyncLogger once!\r\n        \/\/ but LoggerContext.setConfiguration will call config.stop()\r\n        \/\/ every time the configuration changes...\r\n        \/\/ \r\n        \/\/ Uncomment the line below after LOG4J2-493 is fixed\r\n        \/\/ AsyncLogger.stop();\r\n        \/\/ LOGGER.trace(\"AbstractConfiguration stopped AsyncLogger disruptor.\");\r\n        }\r\n    }\r\n    \/\/ similarly, first stop AsyncLoggerConfig Disruptor thread(s)\r\n    Set<LoggerConfig> alreadyStopped = new HashSet<LoggerConfig>();\r\n    int asyncLoggerConfigCount = 0;\r\n    for (final LoggerConfig logger : loggers.values()) {\r\n        if (logger instanceof AsyncLoggerConfig) {\r\n            \/\/ LOG4J2-520, LOG4J2-392:\r\n            \/\/ Important: do not clear appenders until after all AsyncLoggerConfigs\r\n            \/\/ have been stopped! Stopping the last AsyncLoggerConfig will\r\n            \/\/ shut down the disruptor and wait for all enqueued events to be processed.\r\n            \/\/ Only *after this* the appenders can be cleared or events will be lost.\r\n            logger.stop();\r\n            asyncLoggerConfigCount++;\r\n            alreadyStopped.add(logger);\r\n        }\r\n    }\r\n    if (root instanceof AsyncLoggerConfig) {\r\n        root.stop();\r\n        asyncLoggerConfigCount++;\r\n        alreadyStopped.add(root);\r\n    }\r\n    LOGGER.trace(\"AbstractConfiguration stopped {} AsyncLoggerConfigs.\", asyncLoggerConfigCount);\r\n    \/\/ Stop the appenders in reverse order in case they still have activity.\r\n    final Appender[] array = appenders.values().toArray(new Appender[appenders.size()]);\r\n    \/\/ LOG4J2-511, LOG4J2-392 stop AsyncAppenders first\r\n    int asyncAppenderCount = 0;\r\n    for (int i = array.length - 1; i >= 0; --i) {\r\n        if (array[i] instanceof AsyncAppender) {\r\n            array[i].stop();\r\n            asyncAppenderCount++;\r\n        }\r\n    }\r\n    LOGGER.trace(\"AbstractConfiguration stopped {} AsyncAppenders.\", asyncAppenderCount);\r\n    int appenderCount = 0;\r\n    for (int i = array.length - 1; i >= 0; --i) {\r\n        if (array[i].isStarted()) {\r\n            \/\/ then stop remaining Appenders\r\n            array[i].stop();\r\n            appenderCount++;\r\n        }\r\n    }\r\n    LOGGER.trace(\"AbstractConfiguration stopped {} Appenders.\", appenderCount);\r\n    int loggerCount = 0;\r\n    for (final LoggerConfig logger : loggers.values()) {\r\n        \/\/ clear appenders, even if this logger is already stopped.\r\n        logger.clearAppenders();\r\n        \/\/ the shared Disruptor may be shut down prematurely, resulting in NPE or other errors.\r\n        if (alreadyStopped.contains(logger)) {\r\n            continue;\r\n        }\r\n        logger.stop();\r\n        loggerCount++;\r\n    }\r\n    LOGGER.trace(\"AbstractConfiguration stopped {} Loggers.\", loggerCount);\r\n    \/\/ the shared Disruptor may be shut down prematurely, resulting in NPE or other errors.\r\n    if (!alreadyStopped.contains(root)) {\r\n        root.stop();\r\n    }\r\n    super.stop();\r\n    if (advertiser != null && advertisement != null) {\r\n        advertiser.unadvertise(advertisement);\r\n    }\r\n    LOGGER.debug(\"Stopped {} OK\", this);\r\n}","code_comment":"\/**\r\n * Tear down the configuration.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void stop() {\r\n    this.setStopping();\r\n    LOGGER.trace(\"Stopping {}...\", this);\r\n        final LoggerContextFactory factory = LogManager.getFactory();\r\n    if (factory instanceof Log4jContextFactory) {\r\n        ContextSelector selector = ((Log4jContextFactory) factory).getSelector();\r\n        if (selector instanceof AsyncLoggerContextSelector) {\r\n                                                                        }\r\n    }\r\n        Set<LoggerConfig> alreadyStopped = new HashSet<LoggerConfig>();\r\n    int asyncLoggerConfigCount = 0;\r\n    for (final LoggerConfig logger : loggers.values()) {\r\n        if (logger instanceof AsyncLoggerConfig) {\r\n                                                                        logger.stop();\r\n            asyncLoggerConfigCount++;\r\n            alreadyStopped.add(logger);\r\n        }\r\n    }\r\n    if (root instanceof AsyncLoggerConfig) {\r\n        root.stop();\r\n        asyncLoggerConfigCount++;\r\n        alreadyStopped.add(root);\r\n    }\r\n    LOGGER.trace(\"AbstractConfiguration stopped {} AsyncLoggerConfigs.\", asyncLoggerConfigCount);\r\n        final Appender[] array = appenders.values().toArray(new Appender[appenders.size()]);\r\n        int asyncAppenderCount = 0;\r\n    for (int i = array.length - 1; i >= 0; --i) {\r\n        if (array[i] instanceof AsyncAppender) {\r\n            array[i].stop();\r\n            asyncAppenderCount++;\r\n        }\r\n    }\r\n    LOGGER.trace(\"AbstractConfiguration stopped {} AsyncAppenders.\", asyncAppenderCount);\r\n    int appenderCount = 0;\r\n    for (int i = array.length - 1; i >= 0; --i) {\r\n        if (array[i].isStarted()) {\r\n                        array[i].stop();\r\n            appenderCount++;\r\n        }\r\n    }\r\n    LOGGER.trace(\"AbstractConfiguration stopped {} Appenders.\", appenderCount);\r\n    int loggerCount = 0;\r\n    for (final LoggerConfig logger : loggers.values()) {\r\n                logger.clearAppenders();\r\n                if (alreadyStopped.contains(logger)) {\r\n            continue;\r\n        }\r\n        logger.stop();\r\n        loggerCount++;\r\n    }\r\n    LOGGER.trace(\"AbstractConfiguration stopped {} Loggers.\", loggerCount);\r\n        if (!alreadyStopped.contains(root)) {\r\n        root.stop();\r\n    }\r\n    super.stop();\r\n    if (advertiser != null && advertisement != null) {\r\n        advertiser.unadvertise(advertisement);\r\n    }\r\n    LOGGER.debug(\"Stopped {} OK\", this);\r\n}","lc":2.1363636364,"pi":0.0622009569,"ma":2.2,"nbd":0.0,"ml":1.4166666667,"d":1.626984127,"mi":-1.0,"fo":1.8333333333,"r":-0.0263157895,"e":4.1736599759}
{"project_name":"Closure","project_version":"76","label":2,"code":"\/**\r\n * Give an expression and a variable. It returns READ, if the first\r\n * reference of that variable is a read. It returns KILL, if the first\r\n * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\r\n *\/\r\nprivate VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\r\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\r\n        if (NodeUtil.isLhs(n, n.getParent())) {\r\n            Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\r\n            \/\/ The expression to which the assignment is made is evaluated before\r\n            \/\/ the RHS is evaluated (normal left to right evaluation) but the KILL\r\n            \/\/ occurs after the RHS is evaluated.\r\n            Node rhs = n.getNext();\r\n            VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\r\n            if (state == VariableLiveness.READ) {\r\n                return state;\r\n            }\r\n            return VariableLiveness.KILL;\r\n        } else {\r\n            return VariableLiveness.READ;\r\n        }\r\n    }\r\n    switch(n.getType()) {\r\n        \/\/ Conditionals\r\n        case Token.OR:\r\n        case Token.AND:\r\n        \/\/ may not.\r\n        case Token.HOOK:\r\n            return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);\r\n        default:\r\n            \/\/ Expressions are evaluated left-right, depth first.\r\n            for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\r\n                if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\r\n                    \/\/ Not a FUNCTION\r\n                    VariableLiveness state = isVariableReadBeforeKill(child, variable);\r\n                    if (state != VariableLiveness.MAYBE_LIVE) {\r\n                        return state;\r\n                    }\r\n                }\r\n            }\r\n    }\r\n    return VariableLiveness.MAYBE_LIVE;\r\n}","code_comment":"\/**\r\n * Give an expression and a variable. It returns READ, if the first\r\n * reference of that variable is a read. It returns KILL, if the first\r\n * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\r\n *\/\r\n","code_no_comment":"private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\r\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\r\n        if (NodeUtil.isLhs(n, n.getParent())) {\r\n            Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\r\n                                                Node rhs = n.getNext();\r\n            VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\r\n            if (state == VariableLiveness.READ) {\r\n                return state;\r\n            }\r\n            return VariableLiveness.KILL;\r\n        } else {\r\n            return VariableLiveness.READ;\r\n        }\r\n    }\r\n    switch(n.getType()) {\r\n                case Token.OR:\r\n        case Token.AND:\r\n                case Token.HOOK:\r\n            return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable);\r\n        default:\r\n                        for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\r\n                if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\r\n                                        VariableLiveness state = isVariableReadBeforeKill(child, variable);\r\n                    if (state != VariableLiveness.MAYBE_LIVE) {\r\n                        return state;\r\n                    }\r\n                }\r\n            }\r\n    }\r\n    return VariableLiveness.MAYBE_LIVE;\r\n}","lc":0.7727272727,"pi":1.3444976077,"ma":1.4,"nbd":1.5,"ml":1.25,"d":0.5793650794,"mi":-0.5687103594,"fo":1.0833333333,"r":-0.0263157895,"e":0.9053624015}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Float reusable) {\r\n    int i = startPos;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    while (i < limit) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            break;\r\n        }\r\n        i++;\r\n    }\r\n    String str = new String(bytes, startPos, i - startPos);\r\n    try {\r\n        this.result = Float.parseFloat(str);\r\n        return (i == limit) ? limit : i + delimiter.length;\r\n    } catch (NumberFormatException e) {\r\n        setErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);\r\n        return -1;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Float reusable) {\r\n    int i = startPos;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    while (i < limit) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            break;\r\n        }\r\n        i++;\r\n    }\r\n    String str = new String(bytes, startPos, i - startPos);\r\n    try {\r\n        this.result = Float.parseFloat(str);\r\n        return (i == limit) ? limit : i + delimiter.length;\r\n    } catch (NumberFormatException e) {\r\n        setErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);\r\n        return -1;\r\n    }\r\n}","lc":0.2272727273,"pi":0.0956937799,"ma":0.4,"nbd":0.0,"ml":0.4166666667,"d":0.876984127,"mi":-0.24397463,"fo":-0.25,"r":0.0,"e":0.7153518554}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4518_a88882f7","label":1,"code":"\/**\r\n *  Makes this url the result of resolving the {@code relative} url against this url.\r\n *  <p>\r\n *  Segments will be properly resolved, handling any {@code ..} references, while the query\r\n *  parameters will be completely replaced with {@code relative}'s query parameters.\r\n *  <\/p>\r\n *  <p>\r\n *  For example:\r\n *\r\n *  <pre>\r\n *  wicket\/page\/render?foo=bar\r\n *  <\/pre>\r\n *\r\n *  resolved with\r\n *\r\n *  <pre>\r\n *  ..\/component\/render?a=b\r\n *  <\/pre>\r\n *\r\n *  will become\r\n *\r\n *  <pre>\r\n *  wicket\/component\/render?a=b\r\n *  <\/pre>\r\n *\r\n *  <\/p>\r\n *\r\n *  @param relative\r\n *             relative url\r\n *\/\r\npublic void resolveRelative(final Url relative) {\r\n    if (getSegments().size() > 0) {\r\n        \/\/ strip the first non-folder segment\r\n        getSegments().remove(getSegments().size() - 1);\r\n    }\r\n    \/\/ remove all '.\/' (current folder) from the relative url\r\n    if (!relative.getSegments().isEmpty() && \".\".equals(relative.getSegments().get(0))) {\r\n        relative.getSegments().remove(0);\r\n    }\r\n    \/\/ process any ..\/ segments in the relative url\r\n    while (!relative.getSegments().isEmpty() && \"..\".equals(relative.getSegments().get(0))) {\r\n        relative.getSegments().remove(0);\r\n        getSegments().remove(getSegments().size() - 1);\r\n    }\r\n    \/\/ append the remaining relative segments\r\n    getSegments().addAll(relative.getSegments());\r\n    \/\/ replace query params with the ones from relative\r\n    parameters.clear();\r\n    parameters.addAll(relative.getQueryParameters());\r\n}","code_comment":"\/**\r\n *  Makes this url the result of resolving the {@code relative} url against this url.\r\n *  <p>\r\n *  Segments will be properly resolved, handling any {@code ..} references, while the query\r\n *  parameters will be completely replaced with {@code relative}'s query parameters.\r\n *  <\/p>\r\n *  <p>\r\n *  For example:\r\n *\r\n *  <pre>\r\n *  wicket\/page\/render?foo=bar\r\n *  <\/pre>\r\n *\r\n *  resolved with\r\n *\r\n *  <pre>\r\n *  ..\/component\/render?a=b\r\n *  <\/pre>\r\n *\r\n *  will become\r\n *\r\n *  <pre>\r\n *  wicket\/component\/render?a=b\r\n *  <\/pre>\r\n *\r\n *  <\/p>\r\n *\r\n *  @param relative\r\n *             relative url\r\n *\/\r\n","code_no_comment":"public void resolveRelative(final Url relative) {\r\n    if (getSegments().size() > 0) {\r\n                getSegments().remove(getSegments().size() - 1);\r\n    }\r\n        if (!relative.getSegments().isEmpty() && \".\".equals(relative.getSegments().get(0))) {\r\n        relative.getSegments().remove(0);\r\n    }\r\n        while (!relative.getSegments().isEmpty() && \"..\".equals(relative.getSegments().get(0))) {\r\n        relative.getSegments().remove(0);\r\n        getSegments().remove(getSegments().size() - 1);\r\n    }\r\n        getSegments().addAll(relative.getSegments());\r\n        parameters.clear();\r\n    parameters.addAll(relative.getQueryParameters());\r\n}","lc":0.0454545455,"pi":-0.2488038278,"ma":0.0,"nbd":-0.5,"ml":0.4166666667,"d":0.8035714286,"mi":-0.1044397463,"fo":2.0,"r":-0.0263157895,"e":0.5636440126}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-47_b62f1c26","label":1,"code":"\/**\r\n * Update the index with the given changes.\r\n *\r\n * @param t the changes\r\n * @param lastRevision\r\n *\/\r\npublic void updateIndex(String rootPath, JsopReader t, String lastRevision) {\r\n    while (true) {\r\n        int r = t.read();\r\n        if (r == JsopTokenizer.END) {\r\n            break;\r\n        }\r\n        String path = PathUtils.concat(rootPath, t.readString());\r\n        switch(r) {\r\n            case '+':\r\n                {\r\n                    t.read(':');\r\n                    NodeMap map = new NodeMap();\r\n                    if (t.matches('{')) {\r\n                        NodeImpl n = NodeImpl.parse(map, t, 0, path);\r\n                        addOrRemoveRecursive(n, false, true);\r\n                    } else {\r\n                        String value = t.readRawValue().trim();\r\n                        String nodePath = PathUtils.getParentPath(path);\r\n                        NodeImpl node = new NodeImpl(map, 0);\r\n                        node.setPath(nodePath);\r\n                        String propertyName = PathUtils.getName(path);\r\n                        node.cloneAndSetProperty(propertyName, value, 0);\r\n                        addOrRemoveRecursive(node, true, true);\r\n                    }\r\n                    break;\r\n                }\r\n            case '-':\r\n                moveNode(path, null, lastRevision);\r\n                break;\r\n            case '^':\r\n                {\r\n                    removeProperty(path, lastRevision);\r\n                    t.read(':');\r\n                    if (t.matches(JsopTokenizer.NULL)) {\r\n                    \/\/ ignore\r\n                    } else {\r\n                        String value = t.readRawValue().trim();\r\n                        addProperty(path, value);\r\n                    }\r\n                    break;\r\n                }\r\n            case '>':\r\n                t.read(':');\r\n                String name = PathUtils.getName(path);\r\n                String target, position;\r\n                if (t.matches('{')) {\r\n                    position = t.readString();\r\n                    t.read(':');\r\n                    target = t.readString();\r\n                    t.read('}');\r\n                } else {\r\n                    position = null;\r\n                    target = t.readString();\r\n                }\r\n                if (\"last\".equals(position) || \"first\".equals(position)) {\r\n                    target = PathUtils.concat(target, name);\r\n                } else if (\"before\".equals(position) || \"after\".equals(position)) {\r\n                    target = PathUtils.getParentPath(target);\r\n                    target = PathUtils.concat(target, name);\r\n                } else if (position == null) {\r\n                \/\/ move\r\n                } else {\r\n                    throw ExceptionFactory.get(\"position: \" + position);\r\n                }\r\n                moveNode(path, target, lastRevision);\r\n                break;\r\n            default:\r\n                throw new AssertionError(\"token: \" + (char) t.getTokenType());\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Update the index with the given changes.\r\n *\r\n * @param t the changes\r\n * @param lastRevision\r\n *\/\r\n","code_no_comment":"public void updateIndex(String rootPath, JsopReader t, String lastRevision) {\r\n    while (true) {\r\n        int r = t.read();\r\n        if (r == JsopTokenizer.END) {\r\n            break;\r\n        }\r\n        String path = PathUtils.concat(rootPath, t.readString());\r\n        switch(r) {\r\n            case '+':\r\n                {\r\n                    t.read(':');\r\n                    NodeMap map = new NodeMap();\r\n                    if (t.matches('{')) {\r\n                        NodeImpl n = NodeImpl.parse(map, t, 0, path);\r\n                        addOrRemoveRecursive(n, false, true);\r\n                    } else {\r\n                        String value = t.readRawValue().trim();\r\n                        String nodePath = PathUtils.getParentPath(path);\r\n                        NodeImpl node = new NodeImpl(map, 0);\r\n                        node.setPath(nodePath);\r\n                        String propertyName = PathUtils.getName(path);\r\n                        node.cloneAndSetProperty(propertyName, value, 0);\r\n                        addOrRemoveRecursive(node, true, true);\r\n                    }\r\n                    break;\r\n                }\r\n            case '-':\r\n                moveNode(path, null, lastRevision);\r\n                break;\r\n            case '^':\r\n                {\r\n                    removeProperty(path, lastRevision);\r\n                    t.read(':');\r\n                    if (t.matches(JsopTokenizer.NULL)) {\r\n                                        } else {\r\n                        String value = t.readRawValue().trim();\r\n                        addProperty(path, value);\r\n                    }\r\n                    break;\r\n                }\r\n            case '>':\r\n                t.read(':');\r\n                String name = PathUtils.getName(path);\r\n                String target, position;\r\n                if (t.matches('{')) {\r\n                    position = t.readString();\r\n                    t.read(':');\r\n                    target = t.readString();\r\n                    t.read('}');\r\n                } else {\r\n                    position = null;\r\n                    target = t.readString();\r\n                }\r\n                if (\"last\".equals(position) || \"first\".equals(position)) {\r\n                    target = PathUtils.concat(target, name);\r\n                } else if (\"before\".equals(position) || \"after\".equals(position)) {\r\n                    target = PathUtils.getParentPath(target);\r\n                    target = PathUtils.concat(target, name);\r\n                } else if (position == null) {\r\n                                } else {\r\n                    throw ExceptionFactory.get(\"position: \" + position);\r\n                }\r\n                moveNode(path, target, lastRevision);\r\n                break;\r\n            default:\r\n                throw new AssertionError(\"token: \" + (char) t.getTokenType());\r\n        }\r\n    }\r\n}","lc":2.5,"pi":1.3349282297,"ma":3.4,"nbd":2.0,"ml":1.4166666667,"d":0.7599206349,"mi":-1.1291050035,"fo":2.75,"r":-0.0263157895,"e":2.9239628176}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-596_9b268da0","label":1,"code":"@Override\r\npublic MongoNode copy() {\r\n    MongoNode copy = new MongoNode();\r\n    copy.putAll((Map) super.copy());\r\n    return copy;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic MongoNode copy() {\r\n    MongoNode copy = new MongoNode();\r\n    copy.putAll((Map) super.copy());\r\n    return copy;\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6256518675,"fo":-0.3333333333,"r":0.7894736842,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1505_994df698","label":1,"code":"@Override\r\npublic void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {\r\n    for (Mutation m : iterable) {\r\n        acu.addMutation(tablename, m);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {\r\n    for (Mutation m : iterable) {\r\n        acu.addMutation(tablename, m);\r\n    }\r\n}","lc":-0.3636363636,"pi":-0.004784689,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5777307963,"fo":-0.4166666667,"r":0.5,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-763_97203de8","label":1,"code":"@Override\r\npublic String toString() {\r\n    return \"ObjectMessage[obj=\" + obj.toString() + ']';\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String toString() {\r\n    return \"ObjectMessage[obj=\" + obj.toString() + ']';\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8548273432,"fo":-0.4166666667,"r":2.3421052632,"e":-0.1627934049}
{"project_name":"Cli","project_version":"30","label":3,"code":"\/**\r\n * Sets the values of Options using the values in <code>properties<\/code>.\r\n *\r\n * @param properties The value properties to be processed.\r\n *\/\r\nprivate void handleProperties(Properties properties) throws ParseException {\r\n    if (properties == null) {\r\n        return;\r\n    }\r\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements(); ) {\r\n        String option = e.nextElement().toString();\r\n        if (!cmd.hasOption(option)) {\r\n            Option opt = options.getOption(option);\r\n            \/\/ if the option is part of a group, check if another option of the group has been selected\r\n            \/\/ get the value from the properties\r\n            String value = properties.getProperty(option);\r\n            if (opt.hasArg()) {\r\n                if (opt.getValues() == null || opt.getValues().length == 0) {\r\n                    opt.addValueForProcessing(value);\r\n                }\r\n            } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\r\n                \/\/ if the value is not yes, true or 1 then don't add the option to the CommandLine\r\n                continue;\r\n            }\r\n            handleOption(opt);\r\n            currentOption = null;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Sets the values of Options using the values in <code>properties<\/code>.\r\n *\r\n * @param properties The value properties to be processed.\r\n *\/\r\n","code_no_comment":"private void handleProperties(Properties properties) throws ParseException {\r\n    if (properties == null) {\r\n        return;\r\n    }\r\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements(); ) {\r\n        String option = e.nextElement().toString();\r\n        if (!cmd.hasOption(option)) {\r\n            Option opt = options.getOption(option);\r\n                                    String value = properties.getProperty(option);\r\n            if (opt.hasArg()) {\r\n                if (opt.getValues() == null || opt.getValues().length == 0) {\r\n                    opt.addValueForProcessing(value);\r\n                }\r\n            } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\r\n                                continue;\r\n            }\r\n            handleOption(opt);\r\n            currentOption = null;\r\n        }\r\n    }\r\n}","lc":0.3181818182,"pi":1.1100478469,"ma":0.8,"nbd":1.0,"ml":1.25,"d":0.3075396825,"mi":-0.3251585624,"fo":0.75,"r":-0.0263157895,"e":0.3914985333}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1364_05c89637","label":1,"code":"protected Collection<V> values() {\r\n    ArrayList<V> list = new ArrayList<V>();\r\n    for (K k : keySet()) {\r\n        V v = find(k).value;\r\n        if (v != null) {\r\n            list.add(v);\r\n        }\r\n    }\r\n    return list;\r\n}","code_comment":null,"code_no_comment":"protected Collection<V> values() {\r\n    ArrayList<V> list = new ArrayList<V>();\r\n    for (K k : keySet()) {\r\n        V v = find(k).value;\r\n        if (v != null) {\r\n            list.add(v);\r\n        }\r\n    }\r\n    return list;\r\n}","lc":-0.1818181818,"pi":0.2918660287,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.0396825397,"mi":0.2259337562,"fo":-0.25,"r":1.1578947368,"e":-0.0840211384}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5989_a255bbca","label":1,"code":"\/**\r\n *  Handle tag &lt;wicket:header-items&gt;\r\n *\r\n *  @param tag\r\n *\/\r\nprivate void handleHeaderItemsTag(ComponentTag tag) {\r\n    if (foundHeaderItemsTag) {\r\n        throw new MarkupException(new MarkupStream(markup), \"More than one <wicket:header-items\/> detected in the <head> element. Only one is allowed.\");\r\n    } else if (foundClosingHead) {\r\n        throw new MarkupException(new MarkupStream(markup), \"Detected <wicket:header-items\/> after the closing <\/head> element.\");\r\n    }\r\n    foundHeaderItemsTag = true;\r\n    tag.setId(HEADER_ID);\r\n    tag.setAutoComponentTag(true);\r\n    tag.setModified(true);\r\n    tag.setAutoComponentFactory(HTML_HEADER_ITEMS_FACTORY);\r\n}","code_comment":"\/**\r\n *  Handle tag &lt;wicket:header-items&gt;\r\n *\r\n *  @param tag\r\n *\/\r\n","code_no_comment":"private void handleHeaderItemsTag(ComponentTag tag) {\r\n    if (foundHeaderItemsTag) {\r\n        throw new MarkupException(new MarkupStream(markup), \"More than one <wicket:header-items\/> detected in the <head> element. Only one is allowed.\");\r\n    } else if (foundClosingHead) {\r\n        throw new MarkupException(new MarkupStream(markup), \"Detected <wicket:header-items\/> after the closing <\/head> element.\");\r\n    }\r\n    foundHeaderItemsTag = true;\r\n    tag.setId(HEADER_ID);\r\n    tag.setAutoComponentTag(true);\r\n    tag.setModified(true);\r\n    tag.setAutoComponentFactory(HTML_HEADER_ITEMS_FACTORY);\r\n}","lc":-0.0909090909,"pi":-0.3253588517,"ma":0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.104721635,"fo":-0.1666666667,"r":0.0526315789,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8227_54d7fc59","label":3,"code":"protected Exchange configureExchange(Exchange exchange, ExchangePattern pattern) {\r\n    if (pattern != null) {\r\n        exchange.setPattern(pattern);\r\n    }\r\n    \/\/ set property which endpoint we send to\r\n    exchange.setProperty(Exchange.TO_ENDPOINT, destination.getEndpointUri());\r\n    return exchange;\r\n}","code_comment":null,"code_no_comment":"protected Exchange configureExchange(Exchange exchange, ExchangePattern pattern) {\r\n    if (pattern != null) {\r\n        exchange.setPattern(pattern);\r\n    }\r\n        exchange.setProperty(Exchange.TO_ENDPOINT, destination.getEndpointUri());\r\n    return exchange;\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.4449612403,"fo":-0.25,"r":0.3947368421,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5916_def03add","label":1,"code":"\/**\r\n *  @see java.lang.Object#toString()\r\n *\/\r\n@Override\r\npublic String toString() {\r\n    StringBuilder sb = new StringBuilder(super.toString());\r\n    sb.append(\":attached=\").append(attached).append(\":tempModelObject=[\").append(this.transientModelObject).append(\"]\");\r\n    return sb.toString();\r\n}","code_comment":"\/**\r\n *  @see java.lang.Object#toString()\r\n *\/\r\n","code_no_comment":"@Override\r\npublic String toString() {\r\n    StringBuilder sb = new StringBuilder(super.toString());\r\n    sb.append(\":attached=\").append(attached).append(\":tempModelObject=[\").append(this.transientModelObject).append(\"]\");\r\n    return sb.toString();\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5081042988,"fo":0.0833333333,"r":1.3947368421,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4292_9cb617ae","label":1,"code":"\/**\r\n *  Add a cookie to the response.\r\n *\r\n *  @param cookie\r\n *             The cookie to add\r\n *\/\r\n@Override\r\npublic void addCookie(final Cookie cookie) {\r\n    \/\/ remove any potential duplicates\r\n    cookies.remove(cookie);\r\n    cookies.add(cookie);\r\n}","code_comment":"\/**\r\n *  Add a cookie to the response.\r\n *\r\n *  @param cookie\r\n *             The cookie to add\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void addCookie(final Cookie cookie) {\r\n        cookies.remove(cookie);\r\n    cookies.add(cookie);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7237491191,"fo":-0.3333333333,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"Closure","project_version":"49","label":3,"code":"@Override\r\npublic void enterScope(NodeTraversal t) {\r\n    Node declarationRoot = t.getScopeRoot();\r\n    Renamer renamer;\r\n    if (nameStack.isEmpty()) {\r\n        \/\/ If the contextual renamer is being used the starting context can not\r\n        \/\/ be a function.\r\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\r\n        Preconditions.checkState(t.inGlobalScope());\r\n        renamer = rootRenamer;\r\n    } else {\r\n        renamer = nameStack.peek().forChildScope();\r\n    }\r\n    if (declarationRoot.getType() == Token.FUNCTION) {\r\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\r\n            String name = c.getString();\r\n            renamer.addDeclaredName(name);\r\n        }\r\n        Node functionBody = declarationRoot.getLastChild();\r\n        findDeclaredNames(functionBody, null, renamer);\r\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\r\n        \/\/ Add the block declarations\r\n        findDeclaredNames(declarationRoot, null, renamer);\r\n    }\r\n    nameStack.push(renamer);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void enterScope(NodeTraversal t) {\r\n    Node declarationRoot = t.getScopeRoot();\r\n    Renamer renamer;\r\n    if (nameStack.isEmpty()) {\r\n                        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\r\n        Preconditions.checkState(t.inGlobalScope());\r\n        renamer = rootRenamer;\r\n    } else {\r\n        renamer = nameStack.peek().forChildScope();\r\n    }\r\n    if (declarationRoot.getType() == Token.FUNCTION) {\r\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\r\n            String name = c.getString();\r\n            renamer.addDeclaredName(name);\r\n        }\r\n        Node functionBody = declarationRoot.getLastChild();\r\n        findDeclaredNames(functionBody, null, renamer);\r\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\r\n                findDeclaredNames(declarationRoot, null, renamer);\r\n    }\r\n    nameStack.push(renamer);\r\n}","lc":0.4090909091,"pi":0.1483253589,"ma":0.2,"nbd":0.0,"ml":0.1666666667,"d":0.4761904762,"mi":-0.3818181818,"fo":1.1666666667,"r":-0.0263157895,"e":0.7144343977}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-1895_806eaeb0","label":0,"code":"public String toString() {\r\n    return artifact.toString() + \" (\" + depth + \")\";\r\n}","code_comment":null,"code_no_comment":"public String toString() {\r\n    return artifact.toString() + \" (\" + depth + \")\";\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.986187456,"fo":-0.4166666667,"r":2.2368421053,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-209_397f86f6","label":1,"code":"@Override\r\npublic boolean validateOptions(Map<String, String> options) {\r\n    super.validateOptions(options);\r\n    if (options.containsKey(ROW_REGEX))\r\n        Pattern.compile(options.get(ROW_REGEX)).matcher(\"\");\r\n    if (options.containsKey(COLF_REGEX))\r\n        Pattern.compile(options.get(COLF_REGEX)).matcher(\"\");\r\n    if (options.containsKey(COLQ_REGEX))\r\n        Pattern.compile(options.get(COLQ_REGEX)).matcher(\"\");\r\n    if (options.containsKey(VALUE_REGEX))\r\n        Pattern.compile(options.get(VALUE_REGEX)).matcher(\"\");\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean validateOptions(Map<String, String> options) {\r\n    super.validateOptions(options);\r\n    if (options.containsKey(ROW_REGEX))\r\n        Pattern.compile(options.get(ROW_REGEX)).matcher(\"\");\r\n    if (options.containsKey(COLF_REGEX))\r\n        Pattern.compile(options.get(COLF_REGEX)).matcher(\"\");\r\n    if (options.containsKey(COLQ_REGEX))\r\n        Pattern.compile(options.get(COLQ_REGEX)).matcher(\"\");\r\n    if (options.containsKey(VALUE_REGEX))\r\n        Pattern.compile(options.get(VALUE_REGEX)).matcher(\"\");\r\n    return true;\r\n}","lc":-0.0454545455,"pi":-0.033492823,"ma":0.2,"nbd":-1.0,"ml":0.25,"d":-0.3650793651,"mi":-0.0060606061,"fo":0.9166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-434_133cbc2d","label":1,"code":"\/**\r\n * Returns the column with the most negative coefficient in the objective function row.\r\n * @param tableau simple tableau for the problem\r\n * @return column with the most negative coefficient\r\n *\/\r\nprivate Integer getPivotColumn(SimplexTableau tableau) {\r\n    double minValue = 0;\r\n    Integer minPos = null;\r\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\r\n        if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\r\n            minValue = tableau.getEntry(0, i);\r\n            minPos = i;\r\n        }\r\n    }\r\n    return minPos;\r\n}","code_comment":"\/**\r\n * Returns the column with the most negative coefficient in the objective function row.\r\n * @param tableau simple tableau for the problem\r\n * @return column with the most negative coefficient\r\n *\/\r\n","code_no_comment":"private Integer getPivotColumn(SimplexTableau tableau) {\r\n    double minValue = 0;\r\n    Integer minPos = null;\r\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\r\n        if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\r\n            minValue = tableau.getEntry(0, i);\r\n            minPos = i;\r\n        }\r\n    }\r\n    return minPos;\r\n}","lc":-0.1363636364,"pi":0.4449760766,"ma":-0.2,"nbd":0.0,"ml":0.25,"d":0.4523809524,"mi":0.0914728682,"fo":-0.0833333333,"r":0.1052631579,"e":0.2040882189}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2147_a1556c30","label":1,"code":"\/**\r\n * set the value of the the :next at position 0\r\n *\r\n * @param node the node to modify\r\n * @param next the 'next' value\r\n *\/\r\nstatic void setPropertyNext(@Nonnull final NodeBuilder node, final String... next) {\r\n    if (node != null && next != null) {\r\n        String n1 = (next.length > 0) ? next[0] : \"\";\r\n        String n2 = (next.length > 1) ? next[1] : \"\";\r\n        String n3 = (next.length > 2) ? next[2] : \"\";\r\n        String n4 = (next.length > 3) ? next[3] : \"\";\r\n        node.setProperty(NEXT, ImmutableList.of(n1, n2, n3, n4), Type.STRINGS);\r\n    }\r\n}","code_comment":"\/**\r\n * set the value of the the :next at position 0\r\n *\r\n * @param node the node to modify\r\n * @param next the 'next' value\r\n *\/\r\n","code_no_comment":"static void setPropertyNext(@Nonnull final NodeBuilder node, final String... next) {\r\n    if (node != null && next != null) {\r\n        String n1 = (next.length > 0) ? next[0] : \"\";\r\n        String n2 = (next.length > 1) ? next[1] : \"\";\r\n        String n3 = (next.length > 2) ? next[2] : \"\";\r\n        String n4 = (next.length > 3) ? next[3] : \"\";\r\n        node.setProperty(NEXT, ImmutableList.of(n1, n2, n3, n4), Type.STRINGS);\r\n    }\r\n}","lc":-0.2272727273,"pi":0.1339712919,"ma":0.4,"nbd":-0.5,"ml":0.3333333333,"d":0.5277777778,"mi":0.0931642001,"fo":-0.3333333333,"r":-0.0263157895,"e":0.4854895316}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5683_0c3c7d1b","label":1,"code":"\/**\r\n * Creates the {@link LRUCache} to be used.\r\n * <p\/>\r\n * This implementation returns a {@link LRUSoftCache} instance.\r\n *\r\n * @param cacheSize the cache size\r\n * @return the cache\r\n *\/\r\nprotected static LRUCache<String, Producer> createLRUCache(int cacheSize) {\r\n    \/\/ We use a soft reference cache to allow the JVM to re-claim memory if it runs low on memory.\r\n    return new LRUSoftCache<String, Producer>(cacheSize);\r\n}","code_comment":"\/**\r\n * Creates the {@link LRUCache} to be used.\r\n * <p\/>\r\n * This implementation returns a {@link LRUSoftCache} instance.\r\n *\r\n * @param cacheSize the cache size\r\n * @return the cache\r\n *\/\r\n","code_no_comment":"protected static LRUCache<String, Producer> createLRUCache(int cacheSize) {\r\n        return new LRUSoftCache<String, Producer>(cacheSize);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9805496829,"fo":-0.5,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1093_7cfbc0da","label":1,"code":"\/**\r\n * Compute the relative position of the instance with respect\r\n * to an arc.\r\n * <p>\r\n * The {@link Side#MINUS} side of the arc is the one covered by the arc.\r\n * <\/p>\r\n * @param arc arc to check instance against\r\n * @return one of {@link Side#PLUS}, {@link Side#MINUS}, {@link Side#BOTH}\r\n * or {@link Side#HYPER}\r\n *\/\r\npublic Side side(final Arc arc) {\r\n    final double reference = FastMath.PI + arc.getInf();\r\n    final double arcLength = arc.getSup() - arc.getInf();\r\n    boolean inMinus = false;\r\n    boolean inPlus = false;\r\n    for (final double[] a : this) {\r\n        final double syncedStart = MathUtils.normalizeAngle(a[0], reference) - arc.getInf();\r\n        final double arcOffset = a[0] - syncedStart;\r\n        final double syncedEnd = a[1] - arcOffset;\r\n        if (syncedStart < arcLength || syncedEnd > MathUtils.TWO_PI) {\r\n            inMinus = true;\r\n        }\r\n        if (syncedEnd > arcLength) {\r\n            inPlus = true;\r\n        }\r\n    }\r\n    if (inMinus) {\r\n        if (inPlus) {\r\n            return Side.BOTH;\r\n        } else {\r\n            return Side.MINUS;\r\n        }\r\n    } else {\r\n        if (inPlus) {\r\n            return Side.PLUS;\r\n        } else {\r\n            return Side.HYPER;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Compute the relative position of the instance with respect\r\n * to an arc.\r\n * <p>\r\n * The {@link Side#MINUS} side of the arc is the one covered by the arc.\r\n * <\/p>\r\n * @param arc arc to check instance against\r\n * @return one of {@link Side#PLUS}, {@link Side#MINUS}, {@link Side#BOTH}\r\n * or {@link Side#HYPER}\r\n *\/\r\n","code_no_comment":"public Side side(final Arc arc) {\r\n    final double reference = FastMath.PI + arc.getInf();\r\n    final double arcLength = arc.getSup() - arc.getInf();\r\n    boolean inMinus = false;\r\n    boolean inPlus = false;\r\n    for (final double[] a : this) {\r\n        final double syncedStart = MathUtils.normalizeAngle(a[0], reference) - arc.getInf();\r\n        final double arcOffset = a[0] - syncedStart;\r\n        final double syncedEnd = a[1] - arcOffset;\r\n        if (syncedStart < arcLength || syncedEnd > MathUtils.TWO_PI) {\r\n            inMinus = true;\r\n        }\r\n        if (syncedEnd > arcLength) {\r\n            inPlus = true;\r\n        }\r\n    }\r\n    if (inMinus) {\r\n        if (inPlus) {\r\n            return Side.BOTH;\r\n        } else {\r\n            return Side.MINUS;\r\n        }\r\n    } else {\r\n        if (inPlus) {\r\n            return Side.PLUS;\r\n        } else {\r\n            return Side.HYPER;\r\n        }\r\n    }\r\n}","lc":0.7272727273,"pi":0.1866028708,"ma":0.6,"nbd":0.0,"ml":0.5,"d":0.8670634921,"mi":-0.4942917548,"fo":-0.0833333333,"r":-0.0263157895,"e":0.9449513897}
{"project_name":"Closure","project_version":"26","label":2,"code":"\/**\r\n * Emit <code>if (moduleName.module$exports) {\r\n *    moduleName = moduleName.module$export;\r\n * }<\/code> at end of file.\r\n *\/\r\nprivate void emitOptionalModuleExportsOverride(Node script, String moduleName) {\r\n    Node moduleExportsProp = IR.getprop(IR.name(moduleName), IR.string(\"module$exports\"));\r\n    script.addChildToBack(IR.ifNode(moduleExportsProp, IR.block(IR.exprResult(IR.assign(IR.name(moduleName), moduleExportsProp.cloneTree())))).copyInformationFromForTree(script));\r\n}","code_comment":"\/**\r\n * Emit <code>if (moduleName.module$exports) {\r\n *    moduleName = moduleName.module$export;\r\n * }<\/code> at end of file.\r\n *\/\r\n","code_no_comment":"private void emitOptionalModuleExportsOverride(Node script, String moduleName) {\r\n    Node moduleExportsProp = IR.getprop(IR.name(moduleName), IR.string(\"module$exports\"));\r\n    script.addChildToBack(IR.ifNode(moduleExportsProp, IR.block(IR.exprResult(IR.assign(IR.name(moduleName), moduleExportsProp.cloneTree())))).copyInformationFromForTree(script));\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6022551092,"fo":0.4166666667,"r":0.0,"e":-0.1627934049}
{"project_name":"Math","project_version":"90","label":1,"code":"\/**\r\n * Adds 1 to the frequency count for v.\r\n * <p>\r\n * If other objects have already been added to this Frequency, v must\r\n * be comparable to those that have already been added.\r\n * <\/p>\r\n *\r\n * @param v the value to add.\r\n * @throws IllegalArgumentException if <code>v<\/code> is not comparable with previous entries\r\n * @throws ClassCastException if <code>v<\/code> is not Comparable\r\n * @deprecated use {@link #addValue(Comparable)} instead\r\n *\/\r\n@Deprecated\r\npublic void addValue(Object v) {\r\n    \/**\r\n     * Adds 1 to the frequency count for v.\r\n     * <p>\r\n     * If other objects have already been added to this Frequency, v must\r\n     * be comparable to those that have already been added.\r\n     * <\/p>\r\n     *\r\n     * @param v the value to add.\r\n     * @throws IllegalArgumentException if <code>v<\/code> is not comparable with previous entries\r\n     *\/\r\n    Object obj = v;\r\n    if (v instanceof Integer) {\r\n        obj = Long.valueOf(((Integer) v).longValue());\r\n    }\r\n    try {\r\n        Long count = (Long) freqTable.get(obj);\r\n        if (count == null) {\r\n            freqTable.put(obj, Long.valueOf(1));\r\n        } else {\r\n            freqTable.put(obj, Long.valueOf(count.longValue() + 1));\r\n        }\r\n    } catch (ClassCastException ex) {\r\n        \/\/ TreeMap will throw ClassCastException if v is not comparable\r\n        throw new IllegalArgumentException(\"Value not comparable to existing values.\");\r\n    }\r\n}","code_comment":"\/**\r\n * Adds 1 to the frequency count for v.\r\n * <p>\r\n * If other objects have already been added to this Frequency, v must\r\n * be comparable to those that have already been added.\r\n * <\/p>\r\n *\r\n * @param v the value to add.\r\n * @throws IllegalArgumentException if <code>v<\/code> is not comparable with previous entries\r\n * @throws ClassCastException if <code>v<\/code> is not Comparable\r\n * @deprecated use {@link #addValue(Comparable)} instead\r\n *\/\r\n\/**\r\n * Adds 1 to the frequency count for v.\r\n * <p>\r\n * If other objects have already been added to this Frequency, v must\r\n * be comparable to those that have already been added.\r\n * <\/p>\r\n *\r\n * @param v the value to add.\r\n * @throws IllegalArgumentException if <code>v<\/code> is not comparable with previous entries\r\n *\/\r\n","code_no_comment":"@Deprecated\r\npublic void addValue(Object v) {\r\n    \/**\r\n     * Adds 1 to the frequency count for v.\r\n     * <p>\r\n     * If other objects have already been added to this Frequency, v must\r\n     * be comparable to those that have already been added.\r\n     * <\/p>\r\n     *\r\n     * @param v the value to add.\r\n     * @throws IllegalArgumentException if <code>v<\/code> is not comparable with previous entries\r\n     *\/\r\n    Object obj = v;\r\n    if (v instanceof Integer) {\r\n        obj = Long.valueOf(((Integer) v).longValue());\r\n    }\r\n    try {\r\n        Long count = (Long) freqTable.get(obj);\r\n        if (count == null) {\r\n            freqTable.put(obj, Long.valueOf(1));\r\n        } else {\r\n            freqTable.put(obj, Long.valueOf(count.longValue() + 1));\r\n        }\r\n    } catch (ClassCastException ex) {\r\n                throw new IllegalArgumentException(\"Value not comparable to existing values.\");\r\n    }\r\n}","lc":0.5909090909,"pi":-0.033492823,"ma":0.2,"nbd":0.0,"ml":-0.0833333333,"d":0.0515873016,"mi":-0.3454545455,"fo":0.1666666667,"r":0.0,"e":0.0430490483}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_46f62443","label":1,"code":"@Override\r\npublic void setLocalityGroups(String tableName, Map<String, Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void setLocalityGroups(String tableName, Map<String, Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n}","lc":-0.5,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9064129669,"fo":-0.5,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-178_efef09b0","label":3,"code":"protected Key buildDocKey() {\r\n    if (log.isTraceEnabled())\r\n        log.trace(\"building doc key for \" + currentPartition + \" \" + currentDocID);\r\n    int zeroIndex = currentDocID.find(\"\\0\");\r\n    if (zeroIndex < 0)\r\n        throw new IllegalArgumentException(\"bad current docID\");\r\n    Text colf = new Text(docColf);\r\n    colf.append(nullByte, 0, 1);\r\n    colf.append(currentDocID.getBytes(), 0, zeroIndex);\r\n    docColfSet = Collections.singleton((ByteSequence) new ArrayByteSequence(colf.getBytes(), 0, colf.getLength()));\r\n    if (log.isTraceEnabled())\r\n        log.trace(zeroIndex + \" \" + currentDocID.getLength());\r\n    Text colq = new Text();\r\n    colq.set(currentDocID.getBytes(), zeroIndex + 1, currentDocID.getLength() - zeroIndex - 2);\r\n    Key k = new Key(currentPartition, colf, colq);\r\n    if (log.isTraceEnabled())\r\n        log.trace(\"built doc key for seek: \" + k.toString());\r\n    return k;\r\n}","code_comment":null,"code_no_comment":"protected Key buildDocKey() {\r\n    if (log.isTraceEnabled())\r\n        log.trace(\"building doc key for \" + currentPartition + \" \" + currentDocID);\r\n    int zeroIndex = currentDocID.find(\"\\0\");\r\n    if (zeroIndex < 0)\r\n        throw new IllegalArgumentException(\"bad current docID\");\r\n    Text colf = new Text(docColf);\r\n    colf.append(nullByte, 0, 1);\r\n    colf.append(currentDocID.getBytes(), 0, zeroIndex);\r\n    docColfSet = Collections.singleton((ByteSequence) new ArrayByteSequence(colf.getBytes(), 0, colf.getLength()));\r\n    if (log.isTraceEnabled())\r\n        log.trace(zeroIndex + \" \" + currentDocID.getLength());\r\n    Text colq = new Text();\r\n    colq.set(currentDocID.getBytes(), zeroIndex + 1, currentDocID.getLength() - zeroIndex - 2);\r\n    Key k = new Key(currentPartition, colf, colq);\r\n    if (log.isTraceEnabled())\r\n        log.trace(\"built doc key for seek: \" + k.toString());\r\n    return k;\r\n}","lc":0.2272727273,"pi":-0.3732057416,"ma":0.4,"nbd":-1.0,"ml":0.0833333333,"d":0.5297619048,"mi":-0.3096546864,"fo":1.0,"r":-0.0263157895,"e":0.8272217516}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-554_3f51fb09","label":1,"code":"\/**\r\n * @see Object#hashCode()\r\n *\/\r\n@Override\r\npublic int hashCode() {\r\n    if (getType() == PropertyType.BINARY) {\r\n        return propertyState.getValue(Type.BINARY, index).hashCode();\r\n    } else {\r\n        return propertyState.getValue(Type.STRING, index).hashCode();\r\n    }\r\n}","code_comment":"\/**\r\n * @see Object#hashCode()\r\n *\/\r\n","code_no_comment":"@Override\r\npublic int hashCode() {\r\n    if (getType() == PropertyType.BINARY) {\r\n        return propertyState.getValue(Type.BINARY, index).hashCode();\r\n    } else {\r\n        return propertyState.getValue(Type.STRING, index).hashCode();\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.3961945032,"fo":-0.0833333333,"r":0.8157894737,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3310_4416a9f8","label":1,"code":"private Property internalRemoveProperty(final String jcrName) throws RepositoryException {\r\n    final String oakName = getOakName(checkNotNull(jcrName));\r\n    return perform(new ItemWriteOperation<Property>(\"internalRemoveProperty\") {\r\n\r\n        @Nonnull\r\n        @Override\r\n        public Property perform() throws RepositoryException {\r\n            PropertyDelegate property = dlg.getPropertyOrNull(oakName);\r\n            if (property != null) {\r\n                property.remove();\r\n            } else {\r\n                \/\/ Return an instance which throws on access; see OAK-395\r\n                property = dlg.getProperty(oakName);\r\n            }\r\n            return new PropertyImpl(property, sessionContext);\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"Removing property [%s]\", jcrName);\r\n        }\r\n    });\r\n}","code_comment":null,"code_no_comment":"private Property internalRemoveProperty(final String jcrName) throws RepositoryException {\r\n    final String oakName = getOakName(checkNotNull(jcrName));\r\n    return perform(new ItemWriteOperation<Property>(\"internalRemoveProperty\") {\r\n\r\n        @Nonnull\r\n        @Override\r\n        public Property perform() throws RepositoryException {\r\n            PropertyDelegate property = dlg.getPropertyOrNull(oakName);\r\n            if (property != null) {\r\n                property.remove();\r\n            } else {\r\n                                property = dlg.getProperty(oakName);\r\n            }\r\n            return new PropertyImpl(property, sessionContext);\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"Removing property [%s]\", jcrName);\r\n        }\r\n    });\r\n}","lc":0.2727272727,"pi":0.6889952153,"ma":-0.4,"nbd":0.0,"ml":-0.25,"d":-0.0238095238,"mi":-0.1963354475,"fo":0.0833333333,"r":0.0526315789,"e":0.0144234482}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1024_ecc5bdfd","label":1,"code":"@Override\r\npublic boolean evaluate() {\r\n    \/\/ such as index aggregation\r\n    if (selector.index instanceof FulltextQueryIndex) {\r\n        \/\/ aggregation bits\r\n        if (relativePath == null && propertyName != null) {\r\n            PropertyValue p = selector.currentProperty(propertyName);\r\n            if (p == null) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    StringBuilder buff = new StringBuilder();\r\n    if (relativePath == null && propertyName != null) {\r\n        PropertyValue p = selector.currentProperty(propertyName);\r\n        if (p == null) {\r\n            return false;\r\n        }\r\n        appendString(buff, p);\r\n    } else {\r\n        String path = selector.currentPath();\r\n        if (relativePath != null) {\r\n            path = PathUtils.concat(path, relativePath);\r\n        }\r\n        Tree tree = getTree(path);\r\n        if (tree == null || !tree.exists()) {\r\n            return false;\r\n        }\r\n        if (propertyName != null) {\r\n            PropertyState p = tree.getProperty(propertyName);\r\n            if (p == null) {\r\n                return false;\r\n            }\r\n            appendString(buff, PropertyValues.create(p));\r\n        } else {\r\n            for (PropertyState p : tree.getProperties()) {\r\n                appendString(buff, PropertyValues.create(p));\r\n            }\r\n        }\r\n    }\r\n    return getFullTextConstraint(selector).evaluate(buff.toString());\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean evaluate() {\r\n        if (selector.index instanceof FulltextQueryIndex) {\r\n                if (relativePath == null && propertyName != null) {\r\n            PropertyValue p = selector.currentProperty(propertyName);\r\n            if (p == null) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    StringBuilder buff = new StringBuilder();\r\n    if (relativePath == null && propertyName != null) {\r\n        PropertyValue p = selector.currentProperty(propertyName);\r\n        if (p == null) {\r\n            return false;\r\n        }\r\n        appendString(buff, p);\r\n    } else {\r\n        String path = selector.currentPath();\r\n        if (relativePath != null) {\r\n            path = PathUtils.concat(path, relativePath);\r\n        }\r\n        Tree tree = getTree(path);\r\n        if (tree == null || !tree.exists()) {\r\n            return false;\r\n        }\r\n        if (propertyName != null) {\r\n            PropertyState p = tree.getProperty(propertyName);\r\n            if (p == null) {\r\n                return false;\r\n            }\r\n            appendString(buff, PropertyValues.create(p));\r\n        } else {\r\n            for (PropertyState p : tree.getProperties()) {\r\n                appendString(buff, PropertyValues.create(p));\r\n            }\r\n        }\r\n    }\r\n    return getFullTextConstraint(selector).evaluate(buff.toString());\r\n}","lc":1.2272727273,"pi":0.5167464115,"ma":1.4,"nbd":0.5,"ml":1.0833333333,"d":1.1865079365,"mi":-0.7186751233,"fo":0.8333333333,"r":-0.0263157895,"e":1.8756591345}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"@Override\r\npublic IndexRow next() {\r\n    final IndexRow r = c.next();\r\n    return new IndexRow() {\r\n\r\n        @Override\r\n        public String getPath() {\r\n            String sub = r.getPath();\r\n            if (PathUtils.isAbsolute(sub)) {\r\n                return path + sub;\r\n            } else {\r\n                return PathUtils.concat(path, r.getPath());\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public PropertyValue getValue(String columnName) {\r\n            return r.getValue(columnName);\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic IndexRow next() {\r\n    final IndexRow r = c.next();\r\n    return new IndexRow() {\r\n\r\n        @Override\r\n        public String getPath() {\r\n            String sub = r.getPath();\r\n            if (PathUtils.isAbsolute(sub)) {\r\n                return path + sub;\r\n            } else {\r\n                return PathUtils.concat(path, r.getPath());\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public PropertyValue getValue(String columnName) {\r\n            return r.getValue(columnName);\r\n        }\r\n    };\r\n}","lc":0.2272727273,"pi":0.8947368421,"ma":-0.4,"nbd":0.0,"ml":-0.1666666667,"d":0.0555555556,"mi":-0.118534179,"fo":0.0,"r":1.0526315789,"e":-0.0116388029}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1648_fdc54465","label":3,"code":"public Revision create(long lifetimeInMillis, Map<String, String> info) {\r\n    Revision r = nodeStore.getHeadRevision();\r\n    createCounter.getAndIncrement();\r\n    performCleanupIfRequired();\r\n    UpdateOp op = new UpdateOp(ID, false);\r\n    long endTime = BigInteger.valueOf(nodeStore.getClock().getTime()).add(BigInteger.valueOf(lifetimeInMillis)).min(BigInteger.valueOf(Long.MAX_VALUE)).longValue();\r\n    op.setMapEntry(PROP_CHECKPOINT, r, new Info(endTime, info).toString());\r\n    store.createOrUpdate(Collection.SETTINGS, op);\r\n    return r;\r\n}","code_comment":null,"code_no_comment":"public Revision create(long lifetimeInMillis, Map<String, String> info) {\r\n    Revision r = nodeStore.getHeadRevision();\r\n    createCounter.getAndIncrement();\r\n    performCleanupIfRequired();\r\n    UpdateOp op = new UpdateOp(ID, false);\r\n    long endTime = BigInteger.valueOf(nodeStore.getClock().getTime()).add(BigInteger.valueOf(lifetimeInMillis)).min(BigInteger.valueOf(Long.MAX_VALUE)).longValue();\r\n    op.setMapEntry(PROP_CHECKPOINT, r, new Info(endTime, info).toString());\r\n    store.createOrUpdate(Collection.SETTINGS, op);\r\n    return r;\r\n}","lc":-0.1818181818,"pi":-0.6650717703,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.0968287526,"fo":0.6666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3413_499a9c6b","label":1,"code":"\/**\r\n *  @param model\r\n *\/\r\nvoid setModelImpl(IModel<?> model) {\r\n    if (getFlag(FLAG_MODEL_SET)) {\r\n        if (model != null) {\r\n            data_set(0, model);\r\n        } else {\r\n            data_remove(0);\r\n            setFlag(FLAG_MODEL_SET, false);\r\n        }\r\n    } else {\r\n        if (model != null) {\r\n            data_insert(0, model);\r\n            setFlag(FLAG_MODEL_SET, true);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  @param model\r\n *\/\r\n","code_no_comment":"void setModelImpl(IModel<?> model) {\r\n    if (getFlag(FLAG_MODEL_SET)) {\r\n        if (model != null) {\r\n            data_set(0, model);\r\n        } else {\r\n            data_remove(0);\r\n            setFlag(FLAG_MODEL_SET, false);\r\n        }\r\n    } else {\r\n        if (model != null) {\r\n            data_insert(0, model);\r\n            setFlag(FLAG_MODEL_SET, true);\r\n        }\r\n    }\r\n}","lc":0.0454545455,"pi":0.5311004785,"ma":0.0,"nbd":0.0,"ml":0.0,"d":-0.3650793651,"mi":0.0376321353,"fo":0.0,"r":0.7368421053,"e":-0.1627934049}
{"project_name":"Closure","project_version":"167","label":2,"code":"\/**\r\n * @see maybeRestrictName\r\n *\/\r\nprivate FlowScope maybeRestrictTwoNames(FlowScope blindScope, Node left, boolean leftIsRefineable, JSType restrictedLeftType, Node right, boolean rightIsRefineable, JSType restrictedRightType) {\r\n    boolean shouldRefineLeft = leftIsRefineable && restrictedLeftType != null;\r\n    boolean shouldRefineRight = rightIsRefineable && restrictedRightType != null;\r\n    if (shouldRefineLeft || shouldRefineRight) {\r\n        FlowScope informed = blindScope.createChildFlowScope();\r\n        if (shouldRefineLeft) {\r\n            declareNameInScope(informed, left, restrictedLeftType);\r\n        }\r\n        if (shouldRefineRight) {\r\n            declareNameInScope(informed, right, restrictedRightType);\r\n        }\r\n        return informed;\r\n    }\r\n    return blindScope;\r\n}","code_comment":"\/**\r\n * @see maybeRestrictName\r\n *\/\r\n","code_no_comment":"private FlowScope maybeRestrictTwoNames(FlowScope blindScope, Node left, boolean leftIsRefineable, JSType restrictedLeftType, Node right, boolean rightIsRefineable, JSType restrictedRightType) {\r\n    boolean shouldRefineLeft = leftIsRefineable && restrictedLeftType != null;\r\n    boolean shouldRefineRight = rightIsRefineable && restrictedRightType != null;\r\n    if (shouldRefineLeft || shouldRefineRight) {\r\n        FlowScope informed = blindScope.createChildFlowScope();\r\n        if (shouldRefineLeft) {\r\n            declareNameInScope(informed, left, restrictedLeftType);\r\n        }\r\n        if (shouldRefineRight) {\r\n            declareNameInScope(informed, right, restrictedRightType);\r\n        }\r\n        return informed;\r\n    }\r\n    return blindScope;\r\n}","lc":0.0454545455,"pi":0.2631578947,"ma":0.0,"nbd":0.0,"ml":0.0833333333,"d":0.5396825397,"mi":-0.074559549,"fo":-0.25,"r":-0.0263157895,"e":0.2961382641}
{"project_name":"Compress","project_version":"3","label":1,"code":"\/**\r\n * Close an entry. This method MUST be called for all file\r\n * entries that contain data. The reason is that we must\r\n * buffer data written to the stream in order to satisfy\r\n * the buffer's record based writes. Thus, there may be\r\n * data fragments still being assembled that must be written\r\n * to the output stream before this entry is closed and the\r\n * next entry written.\r\n * @throws IOException on error\r\n *\/\r\npublic void closeArchiveEntry() throws IOException {\r\n    if (assemLen > 0) {\r\n        for (int i = assemLen; i < assemBuf.length; ++i) {\r\n            assemBuf[i] = 0;\r\n        }\r\n        buffer.writeRecord(assemBuf);\r\n        currBytes += assemLen;\r\n        assemLen = 0;\r\n    }\r\n    if (currBytes < currSize) {\r\n        throw new IOException(\"entry '\" + currName + \"' closed at '\" + currBytes + \"' before the '\" + currSize + \"' bytes specified in the header were written\");\r\n    }\r\n}","code_comment":"\/**\r\n * Close an entry. This method MUST be called for all file\r\n * entries that contain data. The reason is that we must\r\n * buffer data written to the stream in order to satisfy\r\n * the buffer's record based writes. Thus, there may be\r\n * data fragments still being assembled that must be written\r\n * to the output stream before this entry is closed and the\r\n * next entry written.\r\n * @throws IOException on error\r\n *\/\r\n","code_no_comment":"public void closeArchiveEntry() throws IOException {\r\n    if (assemLen > 0) {\r\n        for (int i = assemLen; i < assemBuf.length; ++i) {\r\n            assemBuf[i] = 0;\r\n        }\r\n        buffer.writeRecord(assemBuf);\r\n        currBytes += assemLen;\r\n        assemLen = 0;\r\n    }\r\n    if (currBytes < currSize) {\r\n        throw new IOException(\"entry '\" + currName + \"' closed at '\" + currBytes + \"' before the '\" + currSize + \"' bytes specified in the header were written\");\r\n    }\r\n}","lc":-0.0454545455,"pi":0.1818181818,"ma":0.2,"nbd":0.0,"ml":0.25,"d":0.7202380952,"mi":0.0119802678,"fo":-0.4166666667,"r":0.2105263158,"e":0.2935656945}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-434_133cbc2d","label":1,"code":"\/**\r\n * Get the -1 times the sum of all coefficients in the given array.\r\n * @param coefficients coefficients to sum\r\n * @return the -1 times the sum of all coefficients in the given array.\r\n *\/\r\nprotected static double getInvertedCoeffiecientSum(final RealVector coefficients) {\r\n    double sum = 0;\r\n    for (double coefficient : coefficients.getData()) {\r\n        sum -= coefficient;\r\n    }\r\n    return sum;\r\n}","code_comment":"\/**\r\n * Get the -1 times the sum of all coefficients in the given array.\r\n * @param coefficients coefficients to sum\r\n * @return the -1 times the sum of all coefficients in the given array.\r\n *\/\r\n","code_no_comment":"protected static double getInvertedCoeffiecientSum(final RealVector coefficients) {\r\n    double sum = 0;\r\n    for (double coefficient : coefficients.getData()) {\r\n        sum -= coefficient;\r\n    }\r\n    return sum;\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.0674603175,"mi":0.5131782946,"fo":-0.4166666667,"r":1.8684210526,"e":-0.1306316742}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-395_e6c31270","label":1,"code":"@Override\r\npublic Property perform() throws RepositoryException {\r\n    if (value == null) {\r\n        Property property = getProperty(jcrName);\r\n        property.remove();\r\n        return property;\r\n    } else {\r\n        String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\r\n        PropertyDefinition definition;\r\n        if (hasProperty(jcrName)) {\r\n            definition = getProperty(jcrName).getDefinition();\r\n        } else {\r\n            definition = dlg.sessionDelegate.getDefinitionProvider().getDefinition(NodeImpl.this, oakName, false, type, exactTypeMatch);\r\n        }\r\n        checkProtected(definition);\r\n        if (definition.isMultiple()) {\r\n            throw new ValueFormatException(\"Cannot set single value to multivalued property\");\r\n        }\r\n        int targetType = getTargetType(value, definition);\r\n        Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\r\n        return new PropertyImpl(dlg.setProperty(oakName, targetValue));\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Property perform() throws RepositoryException {\r\n    if (value == null) {\r\n        Property property = getProperty(jcrName);\r\n        property.remove();\r\n        return property;\r\n    } else {\r\n        String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\r\n        PropertyDefinition definition;\r\n        if (hasProperty(jcrName)) {\r\n            definition = getProperty(jcrName).getDefinition();\r\n        } else {\r\n            definition = dlg.sessionDelegate.getDefinitionProvider().getDefinition(NodeImpl.this, oakName, false, type, exactTypeMatch);\r\n        }\r\n        checkProtected(definition);\r\n        if (definition.isMultiple()) {\r\n            throw new ValueFormatException(\"Cannot set single value to multivalued property\");\r\n        }\r\n        int targetType = getTargetType(value, definition);\r\n        Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\r\n        return new PropertyImpl(dlg.setProperty(oakName, targetValue));\r\n    }\r\n}","lc":0.4090909091,"pi":0.1866028708,"ma":0.2,"nbd":0.0,"ml":0.1666666667,"d":-0.0575396825,"mi":-0.3457364341,"fo":0.6666666667,"r":-0.0263157895,"e":0.0886360886}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6667_1fc7bd7a","label":1,"code":"@Override\r\npublic boolean process(Exchange exchange, AsyncCallback callback) {\r\n    \/\/ use atomic integer to be able to pass reference and keep track on the values\r\n    AtomicInteger index = new AtomicInteger();\r\n    AtomicInteger count = new AtomicInteger();\r\n    \/\/ Intermediate conversion to String is needed when direct conversion to Integer is not available\r\n    \/\/ but evaluation result is a textual representation of a numeric value.\r\n    String text = expression.evaluate(exchange, String.class);\r\n    try {\r\n        int num = ExchangeHelper.convertToMandatoryType(exchange, Integer.class, text);\r\n        count.set(num);\r\n    } catch (NoTypeConversionAvailableException e) {\r\n        exchange.setException(e);\r\n        callback.done(true);\r\n        return true;\r\n    }\r\n    Exchange target = exchange;\r\n    \/\/ set the size before we start\r\n    exchange.setProperty(Exchange.LOOP_SIZE, count);\r\n    \/\/ loop synchronously\r\n    while (index.get() < count.get()) {\r\n        \/\/ and prepare for next iteration\r\n        target = prepareExchange(exchange, index.get());\r\n        boolean sync = process(target, callback, index, count);\r\n        if (!sync) {\r\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", target.getExchangeId());\r\n            \/\/ so we break out now, then the callback will be invoked which then continue routing from where we left here\r\n            return false;\r\n        }\r\n        LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", target.getExchangeId());\r\n        \/\/ increment counter before next loop\r\n        index.getAndIncrement();\r\n    }\r\n    \/\/ we are done so prepare the result\r\n    ExchangeHelper.copyResults(exchange, target);\r\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n    callback.done(true);\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean process(Exchange exchange, AsyncCallback callback) {\r\n        AtomicInteger index = new AtomicInteger();\r\n    AtomicInteger count = new AtomicInteger();\r\n            String text = expression.evaluate(exchange, String.class);\r\n    try {\r\n        int num = ExchangeHelper.convertToMandatoryType(exchange, Integer.class, text);\r\n        count.set(num);\r\n    } catch (NoTypeConversionAvailableException e) {\r\n        exchange.setException(e);\r\n        callback.done(true);\r\n        return true;\r\n    }\r\n    Exchange target = exchange;\r\n        exchange.setProperty(Exchange.LOOP_SIZE, count);\r\n        while (index.get() < count.get()) {\r\n                target = prepareExchange(exchange, index.get());\r\n        boolean sync = process(target, callback, index, count);\r\n        if (!sync) {\r\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", target.getExchangeId());\r\n                        return false;\r\n        }\r\n        LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", target.getExchangeId());\r\n                index.getAndIncrement();\r\n    }\r\n        ExchangeHelper.copyResults(exchange, target);\r\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n    callback.done(true);\r\n    return true;\r\n}","lc":0.7272727273,"pi":0.019138756,"ma":0.0,"nbd":0.0,"ml":0.0,"d":0.0833333333,"mi":-0.5190979563,"fo":1.1666666667,"r":-0.0263157895,"e":0.381332734}
{"project_name":"Closure","project_version":"134","label":2,"code":"\/**\r\n * Returns true if prop is in an independent set from all properties in\r\n * this sub graph.  That is, if none of its types is contained in the\r\n * related types for this sub graph and if none if its related types is one\r\n * of the types in the sub graph.\r\n *\/\r\npublic boolean isIndependentOf(Property prop) {\r\n    if (typesRelatedToSet.intersects(prop.typesSet)) {\r\n        return false;\r\n    }\r\n    return !getRelated(prop.type).intersects(typesInSet);\r\n}","code_comment":"\/**\r\n * Returns true if prop is in an independent set from all properties in\r\n * this sub graph.  That is, if none of its types is contained in the\r\n * related types for this sub graph and if none if its related types is one\r\n * of the types in the sub graph.\r\n *\/\r\n","code_no_comment":"public boolean isIndependentOf(Property prop) {\r\n    if (typesRelatedToSet.intersects(prop.typesSet)) {\r\n        return false;\r\n    }\r\n    return !getRelated(prop.type).intersects(typesInSet);\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.5622269204,"fo":-0.25,"r":1.2368421053,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2418_039f892d","label":0,"code":"private void init() {\r\n    if (result != null) {\r\n        return;\r\n    }\r\n    ArrayList<K> list = new ArrayList<K>();\r\n    while (source.hasNext()) {\r\n        K x = source.next();\r\n        list.add(x);\r\n        checkMemoryLimit(list.size(), settings);\r\n        \/\/ which is close to the optimum O(n*log(keep))\r\n        if (list.size() > max * 2) {\r\n            \/\/ remove tail entries right now, to save memory\r\n            Collections.sort(list, orderBy);\r\n            keepFirst(list, max);\r\n        }\r\n    }\r\n    Collections.sort(list, orderBy);\r\n    keepFirst(list, max);\r\n    result = list.iterator();\r\n}","code_comment":null,"code_no_comment":"private void init() {\r\n    if (result != null) {\r\n        return;\r\n    }\r\n    ArrayList<K> list = new ArrayList<K>();\r\n    while (source.hasNext()) {\r\n        K x = source.next();\r\n        list.add(x);\r\n        checkMemoryLimit(list.size(), settings);\r\n                if (list.size() > max * 2) {\r\n                        Collections.sort(list, orderBy);\r\n            keepFirst(list, max);\r\n        }\r\n    }\r\n    Collections.sort(list, orderBy);\r\n    keepFirst(list, max);\r\n    result = list.iterator();\r\n}","lc":0.1818181818,"pi":0.1626794258,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":0.4107142857,"mi":-0.1656095842,"fo":0.4166666667,"r":-0.0263157895,"e":0.2522985426}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3276_205420e2","label":3,"code":"\/**\r\n * Copies the results of a message exchange from the source exchange to the result exchange\r\n * which will copy the out and fault message contents and the exception\r\n *\r\n * @param result the result exchange which will have the output and error state added\r\n * @param source the source exchange which is not modified\r\n *\/\r\npublic static void copyResults(Exchange result, Exchange source) {\r\n    if (result != source) {\r\n        result.setException(source.getException());\r\n        if (source.hasOut()) {\r\n            result.getOut().copyFrom(source.getOut());\r\n        } else if (result.getPattern() == ExchangePattern.InOptionalOut) {\r\n            \/\/ special case where the result is InOptionalOut and with no OUT response\r\n            \/\/ so we should return null to indicate this fact\r\n            result.setOut(null);\r\n        } else {\r\n            \/\/ so lets assume the last IN is the OUT\r\n            if (result.getPattern().isOutCapable()) {\r\n                \/\/ only set OUT if its OUT capable\r\n                result.getOut().copyFrom(source.getIn());\r\n            } else {\r\n                \/\/ if not replace IN instead to keep the MEP\r\n                result.getIn().copyFrom(source.getIn());\r\n            }\r\n        }\r\n        if (source.hasProperties()) {\r\n            result.getProperties().putAll(source.getProperties());\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Copies the results of a message exchange from the source exchange to the result exchange\r\n * which will copy the out and fault message contents and the exception\r\n *\r\n * @param result the result exchange which will have the output and error state added\r\n * @param source the source exchange which is not modified\r\n *\/\r\n","code_no_comment":"public static void copyResults(Exchange result, Exchange source) {\r\n    if (result != source) {\r\n        result.setException(source.getException());\r\n        if (source.hasOut()) {\r\n            result.getOut().copyFrom(source.getOut());\r\n        } else if (result.getPattern() == ExchangePattern.InOptionalOut) {\r\n                                    result.setOut(null);\r\n        } else {\r\n                        if (result.getPattern().isOutCapable()) {\r\n                                result.getOut().copyFrom(source.getIn());\r\n            } else {\r\n                                result.getIn().copyFrom(source.getIn());\r\n            }\r\n        }\r\n        if (source.hasProperties()) {\r\n            result.getProperties().putAll(source.getProperties());\r\n        }\r\n    }\r\n}","lc":0.2272727273,"pi":0.6842105263,"ma":0.4,"nbd":1.0,"ml":0.5833333333,"d":0.0912698413,"mi":-0.1923890063,"fo":1.1666666667,"r":-0.0263157895,"e":0.0641828461}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public void write(org.apache.thrift.protocol.TProtocol oprot, removeTableProperty_result struct) throws org.apache.thrift.TException {\r\n    struct.validate();\r\n    oprot.writeStructBegin(STRUCT_DESC);\r\n    if (struct.ouch1 != null) {\r\n        oprot.writeFieldBegin(OUCH1_FIELD_DESC);\r\n        struct.ouch1.write(oprot);\r\n        oprot.writeFieldEnd();\r\n    }\r\n    if (struct.ouch2 != null) {\r\n        oprot.writeFieldBegin(OUCH2_FIELD_DESC);\r\n        struct.ouch2.write(oprot);\r\n        oprot.writeFieldEnd();\r\n    }\r\n    oprot.writeFieldStop();\r\n    oprot.writeStructEnd();\r\n}","code_comment":null,"code_no_comment":"public void write(org.apache.thrift.protocol.TProtocol oprot, removeTableProperty_result struct) throws org.apache.thrift.TException {\r\n    struct.validate();\r\n    oprot.writeStructBegin(STRUCT_DESC);\r\n    if (struct.ouch1 != null) {\r\n        oprot.writeFieldBegin(OUCH1_FIELD_DESC);\r\n        struct.ouch1.write(oprot);\r\n        oprot.writeFieldEnd();\r\n    }\r\n    if (struct.ouch2 != null) {\r\n        oprot.writeFieldBegin(OUCH2_FIELD_DESC);\r\n        struct.ouch2.write(oprot);\r\n        oprot.writeFieldEnd();\r\n    }\r\n    oprot.writeFieldStop();\r\n    oprot.writeStructEnd();\r\n}","lc":0.0909090909,"pi":-0.1626794258,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":-0.1016208598,"fo":0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-498_f2a2edec","label":1,"code":"@Override\r\n@Nonnull\r\npublic String getJcrPath(String oakPath) {\r\n    final List<String> elements = new ArrayList<String>();\r\n    if (\"\/\".equals(oakPath)) {\r\n        \/\/ avoid the need to special case the root path later on\r\n        return \"\/\";\r\n    }\r\n    JcrPathParser.Listener listener = new JcrPathParser.Listener() {\r\n\r\n        @Override\r\n        public boolean root() {\r\n            if (!elements.isEmpty()) {\r\n                throw new IllegalArgumentException(\"\/ on non-empty path\");\r\n            }\r\n            elements.add(\"\");\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean current() {\r\n            \/\/ nothing to do here\r\n            return false;\r\n        }\r\n\r\n        @Override\r\n        public boolean parent() {\r\n            if (elements.isEmpty() || \"..\".equals(elements.get(elements.size() - 1))) {\r\n                elements.add(\"..\");\r\n                return true;\r\n            }\r\n            elements.remove(elements.size() - 1);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public void error(String message) {\r\n            throw new IllegalArgumentException(message);\r\n        }\r\n\r\n        @Override\r\n        public boolean name(String name, int index) {\r\n            if (index > 1) {\r\n                throw new IllegalArgumentException(\"index > 1\");\r\n            }\r\n            String p = nameMapper.getJcrName(name);\r\n            elements.add(p);\r\n            return true;\r\n        }\r\n    };\r\n    JcrPathParser.parse(oakPath, listener);\r\n    \/\/ empty path: map to \".\"\r\n    if (elements.isEmpty()) {\r\n        return \".\";\r\n    }\r\n    StringBuilder jcrPath = new StringBuilder();\r\n    for (String element : elements) {\r\n        if (element.isEmpty()) {\r\n            \/\/ root\r\n            jcrPath.append('\/');\r\n        } else {\r\n            jcrPath.append(element);\r\n            jcrPath.append('\/');\r\n        }\r\n    }\r\n    jcrPath.deleteCharAt(jcrPath.length() - 1);\r\n    return jcrPath.toString();\r\n}","code_comment":null,"code_no_comment":"@Override\r\n@Nonnull\r\npublic String getJcrPath(String oakPath) {\r\n    final List<String> elements = new ArrayList<String>();\r\n    if (\"\/\".equals(oakPath)) {\r\n                return \"\/\";\r\n    }\r\n    JcrPathParser.Listener listener = new JcrPathParser.Listener() {\r\n\r\n        @Override\r\n        public boolean root() {\r\n            if (!elements.isEmpty()) {\r\n                throw new IllegalArgumentException(\"\/ on non-empty path\");\r\n            }\r\n            elements.add(\"\");\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean current() {\r\n                        return false;\r\n        }\r\n\r\n        @Override\r\n        public boolean parent() {\r\n            if (elements.isEmpty() || \"..\".equals(elements.get(elements.size() - 1))) {\r\n                elements.add(\"..\");\r\n                return true;\r\n            }\r\n            elements.remove(elements.size() - 1);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public void error(String message) {\r\n            throw new IllegalArgumentException(message);\r\n        }\r\n\r\n        @Override\r\n        public boolean name(String name, int index) {\r\n            if (index > 1) {\r\n                throw new IllegalArgumentException(\"index > 1\");\r\n            }\r\n            String p = nameMapper.getJcrName(name);\r\n            elements.add(p);\r\n            return true;\r\n        }\r\n    };\r\n    JcrPathParser.parse(oakPath, listener);\r\n        if (elements.isEmpty()) {\r\n        return \".\";\r\n    }\r\n    StringBuilder jcrPath = new StringBuilder();\r\n    for (String element : elements) {\r\n        if (element.isEmpty()) {\r\n                        jcrPath.append('\/');\r\n        } else {\r\n            jcrPath.append(element);\r\n            jcrPath.append('\/');\r\n        }\r\n    }\r\n    jcrPath.deleteCharAt(jcrPath.length() - 1);\r\n    return jcrPath.toString();\r\n}","lc":2.0454545455,"pi":0.5406698565,"ma":1.4,"nbd":0.0,"ml":0.8333333333,"d":0.5833333333,"mi":-0.91205074,"fo":1.25,"r":-0.0263157895,"e":1.3380935092}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4915_1c3abfba","label":1,"code":"private boolean validateVersion(String fieldName, ModelProblemCollector problems, Severity severity, String string, String sourceHint, InputLocationTracker tracker) {\r\n    if (string == null || string.length() <= 0) {\r\n        return true;\r\n    }\r\n    if (!hasExpression(string)) {\r\n        return true;\r\n    }\r\n    addViolation(problems, severity, fieldName, sourceHint, \"must be a valid version but is '\" + string + \"'.\", tracker);\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"private boolean validateVersion(String fieldName, ModelProblemCollector problems, Severity severity, String string, String sourceHint, InputLocationTracker tracker) {\r\n    if (string == null || string.length() <= 0) {\r\n        return true;\r\n    }\r\n    if (!hasExpression(string)) {\r\n        return true;\r\n    }\r\n    addViolation(problems, severity, fieldName, sourceHint, \"must be a valid version but is '\" + string + \"'.\", tracker);\r\n    return false;\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":-0.2,"nbd":-0.5,"ml":0.0833333333,"d":0.2579365079,"mi":0.1464411557,"fo":-0.25,"r":-0.0263157895,"e":0.0960172427}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-366_db4a291f","label":1,"code":"synchronized void completeClose(boolean saveState, boolean completeClose) throws IOException {\r\n    if (!closing || closeComplete || closeCompleting) {\r\n        throw new IllegalStateException(\"closing = \" + closing + \" closed = \" + closed + \" closeComplete = \" + closeComplete + \" closeCompleting = \" + closeCompleting);\r\n    }\r\n    log.debug(\"completeClose(saveState=\" + saveState + \" completeClose=\" + completeClose + \") \" + getExtent());\r\n    \/\/ ensure this method is only called once, also guards against multiple\r\n    \/\/ threads entering the method at the same time\r\n    closeCompleting = true;\r\n    closed = true;\r\n    \/\/ modify dataSourceDeletions so scans will try to switch data sources and fail because the tablet is closed\r\n    dataSourceDeletions.incrementAndGet();\r\n    for (ScanDataSource activeScan : activeScans) {\r\n        activeScan.interrupt();\r\n    }\r\n    \/\/ wait for reads and writes to complete\r\n    while (writesInProgress > 0 || activeScans.size() > 0) {\r\n        try {\r\n            this.wait(50);\r\n        } catch (InterruptedException e) {\r\n            log.error(e.toString());\r\n        }\r\n    }\r\n    tabletMemory.waitForMinC();\r\n    if (saveState && tabletMemory.getMemTable().getNumEntries() > 0) {\r\n        prepareForMinC(getFlushID()).run();\r\n    }\r\n    if (saveState) {\r\n        \/\/ at this point all tablet data is flushed, so do a consistency check\r\n        RuntimeException err = null;\r\n        for (int i = 0; i < 5; i++) {\r\n            try {\r\n                closeConsistencyCheck();\r\n                err = null;\r\n            } catch (RuntimeException t) {\r\n                err = t;\r\n                log.error(\"Consistency check fails, retrying \" + t);\r\n                UtilWaitThread.sleep(500);\r\n            }\r\n        }\r\n        if (err != null) {\r\n            ProblemReports.getInstance().report(new ProblemReport(extent.getTableId().toString(), ProblemType.TABLET_LOAD, this.extent.toString(), err));\r\n            log.error(\"Tablet closed consistency check has failed for \" + this.extent + \" giving up and closing\");\r\n        }\r\n    }\r\n    try {\r\n        tabletMemory.getMemTable().delete(0);\r\n    } catch (Throwable t) {\r\n        log.error(\"Failed to delete mem table : \" + t.getMessage(), t);\r\n    }\r\n    tabletMemory = null;\r\n    \/\/ close map files\r\n    tabletResources.close();\r\n    log.log(TLevel.TABLET_HIST, extent + \" closed\");\r\n    acuTableConf.removeObserver(configObserver);\r\n    closeComplete = completeClose;\r\n}","code_comment":null,"code_no_comment":"synchronized void completeClose(boolean saveState, boolean completeClose) throws IOException {\r\n    if (!closing || closeComplete || closeCompleting) {\r\n        throw new IllegalStateException(\"closing = \" + closing + \" closed = \" + closed + \" closeComplete = \" + closeComplete + \" closeCompleting = \" + closeCompleting);\r\n    }\r\n    log.debug(\"completeClose(saveState=\" + saveState + \" completeClose=\" + completeClose + \") \" + getExtent());\r\n            closeCompleting = true;\r\n    closed = true;\r\n        dataSourceDeletions.incrementAndGet();\r\n    for (ScanDataSource activeScan : activeScans) {\r\n        activeScan.interrupt();\r\n    }\r\n        while (writesInProgress > 0 || activeScans.size() > 0) {\r\n        try {\r\n            this.wait(50);\r\n        } catch (InterruptedException e) {\r\n            log.error(e.toString());\r\n        }\r\n    }\r\n    tabletMemory.waitForMinC();\r\n    if (saveState && tabletMemory.getMemTable().getNumEntries() > 0) {\r\n        prepareForMinC(getFlushID()).run();\r\n    }\r\n    if (saveState) {\r\n                RuntimeException err = null;\r\n        for (int i = 0; i < 5; i++) {\r\n            try {\r\n                closeConsistencyCheck();\r\n                err = null;\r\n            } catch (RuntimeException t) {\r\n                err = t;\r\n                log.error(\"Consistency check fails, retrying \" + t);\r\n                UtilWaitThread.sleep(500);\r\n            }\r\n        }\r\n        if (err != null) {\r\n            ProblemReports.getInstance().report(new ProblemReport(extent.getTableId().toString(), ProblemType.TABLET_LOAD, this.extent.toString(), err));\r\n            log.error(\"Tablet closed consistency check has failed for \" + this.extent + \" giving up and closing\");\r\n        }\r\n    }\r\n    try {\r\n        tabletMemory.getMemTable().delete(0);\r\n    } catch (Throwable t) {\r\n        log.error(\"Failed to delete mem table : \" + t.getMessage(), t);\r\n    }\r\n    tabletMemory = null;\r\n        tabletResources.close();\r\n    log.log(TLevel.TABLET_HIST, extent + \" closed\");\r\n    acuTableConf.removeObserver(configObserver);\r\n    closeComplete = completeClose;\r\n}","lc":1.6363636364,"pi":0.5933014354,"ma":1.6,"nbd":0.5,"ml":1.1666666667,"d":0.9900793651,"mi":-0.8951374207,"fo":2.0,"r":-0.0263157895,"e":2.8952496211}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1364_05c89637","label":1,"code":"\/**\r\n * Get the value for the given key if the entry is cached. This method does\r\n * not modify the internal state.\r\n *\r\n * @param key the key (may not be null)\r\n * @return the value, or null if there is no resident entry\r\n *\/\r\npublic V peek(K key) {\r\n    Entry<K, V> e = find(key);\r\n    return e == null ? null : e.value;\r\n}","code_comment":"\/**\r\n * Get the value for the given key if the entry is cached. This method does\r\n * not modify the internal state.\r\n *\r\n * @param key the key (may not be null)\r\n * @return the value, or null if there is no resident entry\r\n *\/\r\n","code_no_comment":"public V peek(K key) {\r\n    Entry<K, V> e = find(key);\r\n    return e == null ? null : e.value;\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.0476190476,"mi":0.7206483439,"fo":-0.4166666667,"r":1.9473684211,"e":-0.1151916461}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, ByteValue reusable) {\r\n    int val = 0;\r\n    boolean neg = false;\r\n    this.result = reusable;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    if (bytes[startPos] == '-') {\r\n        neg = true;\r\n        startPos++;\r\n        \/\/ check for empty field with only the sign\r\n        if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\r\n            return -1;\r\n        }\r\n    }\r\n    for (int i = startPos; i < limit; i++) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            reusable.setValue((byte) (neg ? -val : val));\r\n            return i + delimiter.length;\r\n        }\r\n        if (bytes[i] < 48 || bytes[i] > 57) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\r\n            return -1;\r\n        }\r\n        val *= 10;\r\n        val += bytes[i] - 48;\r\n        if (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\r\n            return -1;\r\n        }\r\n    }\r\n    reusable.setValue((byte) (neg ? -val : val));\r\n    return limit;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, ByteValue reusable) {\r\n    int val = 0;\r\n    boolean neg = false;\r\n    this.result = reusable;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    if (bytes[startPos] == '-') {\r\n        neg = true;\r\n        startPos++;\r\n                if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\r\n            return -1;\r\n        }\r\n    }\r\n    for (int i = startPos; i < limit; i++) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            reusable.setValue((byte) (neg ? -val : val));\r\n            return i + delimiter.length;\r\n        }\r\n        if (bytes[i] < 48 || bytes[i] > 57) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\r\n            return -1;\r\n        }\r\n        val *= 10;\r\n        val += bytes[i] - 48;\r\n        if (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\r\n            return -1;\r\n        }\r\n    }\r\n    reusable.setValue((byte) (neg ? -val : val));\r\n    return limit;\r\n}","lc":0.8636363636,"pi":0.3349282297,"ma":1.0,"nbd":0.0,"ml":1.5833333333,"d":2.880952381,"mi":-0.6360817477,"fo":0.0833333333,"r":-0.0263157895,"e":5.0575866024}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5707_3f70d612","label":3,"code":"\/**\r\n * Sets a condition when tne <tt>n'th<\/tt> (by index) {@link Exchange} is done being processed.\r\n * <p\/>\r\n * The difference between <i>done<\/i> and <i>completed<\/i> is that done can also include failed\r\n * messages, where as completed is only successful processed messages.\r\n *\r\n * @param index the message by index to be done\r\n * @return the builder\r\n *\/\r\npublic NotifyBuilder whenDoneByIndex(final int index) {\r\n    stack.add(new EventPredicateSupport() {\r\n\r\n        private AtomicInteger current = new AtomicInteger();\r\n\r\n        private String id;\r\n\r\n        private AtomicBoolean done = new AtomicBoolean();\r\n\r\n        @Override\r\n        public boolean onExchangeCreated(Exchange exchange) {\r\n            if (current.get() == index) {\r\n                id = exchange.getExchangeId();\r\n            }\r\n            current.incrementAndGet();\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean onExchangeCompleted(Exchange exchange) {\r\n            if (exchange.getExchangeId().equals(id)) {\r\n                done.set(false);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean onExchangeFailed(Exchange exchange) {\r\n            if (exchange.getExchangeId().equals(id)) {\r\n                done.set(true);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        public boolean matches() {\r\n            return done.get();\r\n        }\r\n\r\n        @Override\r\n        public void reset() {\r\n            current.set(0);\r\n            id = null;\r\n            done.set(false);\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"whenDoneByIndex(\" + index + \")\";\r\n        }\r\n    });\r\n    return this;\r\n}","code_comment":"\/**\r\n * Sets a condition when tne <tt>n'th<\/tt> (by index) {@link Exchange} is done being processed.\r\n * <p\/>\r\n * The difference between <i>done<\/i> and <i>completed<\/i> is that done can also include failed\r\n * messages, where as completed is only successful processed messages.\r\n *\r\n * @param index the message by index to be done\r\n * @return the builder\r\n *\/\r\n","code_no_comment":"public NotifyBuilder whenDoneByIndex(final int index) {\r\n    stack.add(new EventPredicateSupport() {\r\n\r\n        private AtomicInteger current = new AtomicInteger();\r\n\r\n        private String id;\r\n\r\n        private AtomicBoolean done = new AtomicBoolean();\r\n\r\n        @Override\r\n        public boolean onExchangeCreated(Exchange exchange) {\r\n            if (current.get() == index) {\r\n                id = exchange.getExchangeId();\r\n            }\r\n            current.incrementAndGet();\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean onExchangeCompleted(Exchange exchange) {\r\n            if (exchange.getExchangeId().equals(id)) {\r\n                done.set(false);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean onExchangeFailed(Exchange exchange) {\r\n            if (exchange.getExchangeId().equals(id)) {\r\n                done.set(true);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        public boolean matches() {\r\n            return done.get();\r\n        }\r\n\r\n        @Override\r\n        public void reset() {\r\n            current.set(0);\r\n            id = null;\r\n            done.set(false);\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"whenDoneByIndex(\" + index + \")\";\r\n        }\r\n    });\r\n    return this;\r\n}","lc":1.3181818182,"pi":0.2583732057,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":0.0615079365,"mi":-0.6434108527,"fo":0.5833333333,"r":-0.0263157895,"e":0.2320729817}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1959_93c1aa40","label":1,"code":"@Override\r\n@Nonnull\r\npublic NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {\r\n    \/\/ check for concurrent updates by this async task\r\n    NodeState async = before.getChildNode(ASYNC);\r\n    if (Objects.equal(checkpoint, async.getString(name)) && lease == async.getLong(name + \"-lease\")) {\r\n        return after;\r\n    } else {\r\n        throw CONCURRENT_UPDATE;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\n@Nonnull\r\npublic NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {\r\n        NodeState async = before.getChildNode(ASYNC);\r\n    if (Objects.equal(checkpoint, async.getString(name)) && lease == async.getLong(name + \"-lease\")) {\r\n        return after;\r\n    } else {\r\n        throw CONCURRENT_UPDATE;\r\n    }\r\n}","lc":-0.1818181818,"pi":0.0,"ma":-0.2,"nbd":-0.5,"ml":0.25,"d":0.1765873016,"mi":0.1627906977,"fo":-0.1666666667,"r":0.0526315789,"e":0.0381528673}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1848_7164b2b6","label":0,"code":"\/**\r\n *  Normalizes a path string.\r\n *\r\n *  @param path\r\n *         the path string to normalize\r\n *  @return the normalized path string\r\n *\/\r\nprivate String normalizePath(String path) {\r\n    \/\/ remove leading and tailing whitespaces\r\n    path = path.trim();\r\n    \/\/ remove consecutive slashes & backslashes\r\n    path = path.replace(\"\\\\\", \"\/\");\r\n    path = path.replaceAll(\"\/+\", \"\/\");\r\n    \/\/ remove tailing separator\r\n    if (!path.equals(SEPARATOR) && path.endsWith(SEPARATOR)) {\r\n        path = path.substring(0, path.length() - SEPARATOR.length());\r\n    }\r\n    return path;\r\n}","code_comment":"\/**\r\n *  Normalizes a path string.\r\n *\r\n *  @param path\r\n *         the path string to normalize\r\n *  @return the normalized path string\r\n *\/\r\n","code_no_comment":"private String normalizePath(String path) {\r\n        path = path.trim();\r\n        path = path.replace(\"\\\\\", \"\/\");\r\n    path = path.replaceAll(\"\/+\", \"\/\");\r\n        if (!path.equals(SEPARATOR) && path.endsWith(SEPARATOR)) {\r\n        path = path.substring(0, path.length() - SEPARATOR.length());\r\n    }\r\n    return path;\r\n}","lc":-0.2272727273,"pi":-0.3444976077,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":0.4523809524,"mi":0.2059196617,"fo":0.1666666667,"r":0.0,"e":0.1659791497}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3310_4416a9f8","label":1,"code":"private void internalSetValue(@Nonnull final Value value) throws RepositoryException {\r\n    sessionDelegate.performVoid(new ItemWriteOperation(\"internalSetValue\") {\r\n\r\n        @Override\r\n        public void performVoid() throws RepositoryException {\r\n            Type<?> type = dlg.getPropertyState().getType();\r\n            if (type.isArray()) {\r\n                throw new ValueFormatException(\"This is a multi-valued property\");\r\n            }\r\n            Value converted = ValueHelper.convert(value, type.tag(), getValueFactory());\r\n            dlg.setState(createSingleState(dlg.getName(), converted, type));\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"Setting property [%s\/%s]\", dlg.getPath(), dlg.getName());\r\n        }\r\n    });\r\n}","code_comment":null,"code_no_comment":"private void internalSetValue(@Nonnull final Value value) throws RepositoryException {\r\n    sessionDelegate.performVoid(new ItemWriteOperation(\"internalSetValue\") {\r\n\r\n        @Override\r\n        public void performVoid() throws RepositoryException {\r\n            Type<?> type = dlg.getPropertyState().getType();\r\n            if (type.isArray()) {\r\n                throw new ValueFormatException(\"This is a multi-valued property\");\r\n            }\r\n            Value converted = ValueHelper.convert(value, type.tag(), getValueFactory());\r\n            dlg.setState(createSingleState(dlg.getName(), converted, type));\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"Setting property [%s\/%s]\", dlg.getPath(), dlg.getName());\r\n        }\r\n    });\r\n}","lc":0.1363636364,"pi":0.6315789474,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.3650793651,"mi":-0.1419309373,"fo":0.5833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3333_194999ed","label":1,"code":"\/**\r\n * Collect _revisions and _commitRoot entries that can be moved to a\r\n * previous document.\r\n *\/\r\nprivate void collectRevisionsAndCommitRoot() {\r\n    NavigableMap<Revision, String> revisions = new TreeMap<Revision, String>(context.getRevisionComparator());\r\n    for (Map.Entry<Revision, String> entry : doc.getLocalRevisions().entrySet()) {\r\n        if (splitRevs.contains(entry.getKey())) {\r\n            revisions.put(entry.getKey(), entry.getValue());\r\n            numValues++;\r\n        } else {\r\n            \/\/ local changes\r\n            if (context.getClusterId() != entry.getKey().getClusterId()) {\r\n                \/\/ only consider local changes\r\n                continue;\r\n            }\r\n            if (doc.isCommitted(entry.getKey()) && !mostRecentRevs.contains(entry.getKey())) {\r\n                \/\/ this is a commit root for changes in other documents\r\n                revisions.put(entry.getKey(), entry.getValue());\r\n                numValues++;\r\n                trackHigh(entry.getKey());\r\n                trackLow(entry.getKey());\r\n            }\r\n        }\r\n    }\r\n    committedChanges.put(REVISIONS, revisions);\r\n    NavigableMap<Revision, String> commitRoot = new TreeMap<Revision, String>(context.getRevisionComparator());\r\n    for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {\r\n        Revision r = entry.getKey();\r\n        if (splitRevs.contains(r)) {\r\n            commitRoot.put(r, entry.getValue());\r\n            numValues++;\r\n        } else if (r.getClusterId() == context.getClusterId() && !changes.contains(r)) {\r\n            \/\/ OAK-2528: _commitRoot entry without associated\r\n            \/\/ change -> consider as garbage\r\n            addGarbage(r, COMMIT_ROOT);\r\n        }\r\n    }\r\n    committedChanges.put(COMMIT_ROOT, commitRoot);\r\n}","code_comment":"\/**\r\n * Collect _revisions and _commitRoot entries that can be moved to a\r\n * previous document.\r\n *\/\r\n","code_no_comment":"private void collectRevisionsAndCommitRoot() {\r\n    NavigableMap<Revision, String> revisions = new TreeMap<Revision, String>(context.getRevisionComparator());\r\n    for (Map.Entry<Revision, String> entry : doc.getLocalRevisions().entrySet()) {\r\n        if (splitRevs.contains(entry.getKey())) {\r\n            revisions.put(entry.getKey(), entry.getValue());\r\n            numValues++;\r\n        } else {\r\n                        if (context.getClusterId() != entry.getKey().getClusterId()) {\r\n                                continue;\r\n            }\r\n            if (doc.isCommitted(entry.getKey()) && !mostRecentRevs.contains(entry.getKey())) {\r\n                                revisions.put(entry.getKey(), entry.getValue());\r\n                numValues++;\r\n                trackHigh(entry.getKey());\r\n                trackLow(entry.getKey());\r\n            }\r\n        }\r\n    }\r\n    committedChanges.put(REVISIONS, revisions);\r\n    NavigableMap<Revision, String> commitRoot = new TreeMap<Revision, String>(context.getRevisionComparator());\r\n    for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {\r\n        Revision r = entry.getKey();\r\n        if (splitRevs.contains(r)) {\r\n            commitRoot.put(r, entry.getValue());\r\n            numValues++;\r\n        } else if (r.getClusterId() == context.getClusterId() && !changes.contains(r)) {\r\n                                    addGarbage(r, COMMIT_ROOT);\r\n        }\r\n    }\r\n    committedChanges.put(COMMIT_ROOT, commitRoot);\r\n}","lc":0.7727272727,"pi":0.8325358852,"ma":1.0,"nbd":0.5,"ml":1.0,"d":1.4563492063,"mi":-0.5906976744,"fo":2.4166666667,"r":-0.0263157895,"e":2.4489825556}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1668_63070cf9","label":1,"code":"@Override\r\npublic Cursor query(Filter filter, NodeState root) {\r\n    if (!isLive(root)) {\r\n        throw new IllegalStateException(\"Lucene index is not live\");\r\n    }\r\n    FullTextExpression ft = filter.getFullTextConstraint();\r\n    Set<String> relPaths = getRelativePaths(ft);\r\n    if (relPaths.size() > 1) {\r\n        return new MultiLuceneIndex(filter, root, relPaths).query();\r\n    }\r\n    String parent = relPaths.size() == 0 ? \"\" : relPaths.iterator().next();\r\n    \/\/ we only restrict non-full-text conditions if there is\r\n    \/\/ no relative property in the full-text constraint\r\n    boolean nonFullTextConstraints = parent.isEmpty();\r\n    Directory directory = newDirectory(root);\r\n    QueryEngineSettings settings = filter.getQueryEngineSettings();\r\n    if (directory == null) {\r\n        return newPathCursor(Collections.<String>emptySet(), settings);\r\n    }\r\n    long s = System.currentTimeMillis();\r\n    try {\r\n        try {\r\n            IndexReader reader = DirectoryReader.open(directory);\r\n            try {\r\n                IndexSearcher searcher = new IndexSearcher(reader);\r\n                List<LuceneResultRow> rows = new ArrayList<LuceneResultRow>();\r\n                Query query = getQuery(filter, reader, nonFullTextConstraints, analyzer);\r\n                \/\/ TODO OAK-828\r\n                HashSet<String> seenPaths = new HashSet<String>();\r\n                int parentDepth = getDepth(parent);\r\n                if (query != null) {\r\n                    \/\/ OAK-925\r\n                    \/\/ TODO how to best avoid loading all entries in memory?\r\n                    \/\/ (memory problem and performance problem)\r\n                    TopDocs docs = searcher.search(query, Integer.MAX_VALUE);\r\n                    for (ScoreDoc doc : docs.scoreDocs) {\r\n                        String path = reader.document(doc.doc, PATH_SELECTOR).get(PATH);\r\n                        if (path != null) {\r\n                            if (\"\".equals(path)) {\r\n                                path = \"\/\";\r\n                            }\r\n                            if (!parent.isEmpty()) {\r\n                                \/\/ TODO OAK-828 this breaks node aggregation\r\n                                \/\/ get the base path\r\n                                \/\/ ensure the path ends with the given\r\n                                \/\/ relative path\r\n                                \/\/ if (!path.endsWith(\"\/\" + parent)) {\r\n                                \/\/ continue;\r\n                                \/\/ }\r\n                                path = getAncestorPath(path, parentDepth);\r\n                                \/\/ avoid duplicate entries\r\n                                if (seenPaths.contains(path)) {\r\n                                    continue;\r\n                                }\r\n                                seenPaths.add(path);\r\n                            }\r\n                            LuceneResultRow r = new LuceneResultRow();\r\n                            r.path = path;\r\n                            r.score = doc.score;\r\n                            rows.add(r);\r\n                        }\r\n                    }\r\n                }\r\n                LOG.debug(\"query via {} took {} ms.\", this, System.currentTimeMillis() - s);\r\n                return new LucenePathCursor(rows, settings);\r\n            } finally {\r\n                reader.close();\r\n            }\r\n        } finally {\r\n            directory.close();\r\n        }\r\n    } catch (IOException e) {\r\n        LOG.warn(\"query via {} failed.\", this, e);\r\n        return newPathCursor(Collections.<String>emptySet(), settings);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Cursor query(Filter filter, NodeState root) {\r\n    if (!isLive(root)) {\r\n        throw new IllegalStateException(\"Lucene index is not live\");\r\n    }\r\n    FullTextExpression ft = filter.getFullTextConstraint();\r\n    Set<String> relPaths = getRelativePaths(ft);\r\n    if (relPaths.size() > 1) {\r\n        return new MultiLuceneIndex(filter, root, relPaths).query();\r\n    }\r\n    String parent = relPaths.size() == 0 ? \"\" : relPaths.iterator().next();\r\n            boolean nonFullTextConstraints = parent.isEmpty();\r\n    Directory directory = newDirectory(root);\r\n    QueryEngineSettings settings = filter.getQueryEngineSettings();\r\n    if (directory == null) {\r\n        return newPathCursor(Collections.<String>emptySet(), settings);\r\n    }\r\n    long s = System.currentTimeMillis();\r\n    try {\r\n        try {\r\n            IndexReader reader = DirectoryReader.open(directory);\r\n            try {\r\n                IndexSearcher searcher = new IndexSearcher(reader);\r\n                List<LuceneResultRow> rows = new ArrayList<LuceneResultRow>();\r\n                Query query = getQuery(filter, reader, nonFullTextConstraints, analyzer);\r\n                                HashSet<String> seenPaths = new HashSet<String>();\r\n                int parentDepth = getDepth(parent);\r\n                if (query != null) {\r\n                                                                                TopDocs docs = searcher.search(query, Integer.MAX_VALUE);\r\n                    for (ScoreDoc doc : docs.scoreDocs) {\r\n                        String path = reader.document(doc.doc, PATH_SELECTOR).get(PATH);\r\n                        if (path != null) {\r\n                            if (\"\".equals(path)) {\r\n                                path = \"\/\";\r\n                            }\r\n                            if (!parent.isEmpty()) {\r\n                                                                                                                                                                                                                                                                path = getAncestorPath(path, parentDepth);\r\n                                                                if (seenPaths.contains(path)) {\r\n                                    continue;\r\n                                }\r\n                                seenPaths.add(path);\r\n                            }\r\n                            LuceneResultRow r = new LuceneResultRow();\r\n                            r.path = path;\r\n                            r.score = doc.score;\r\n                            rows.add(r);\r\n                        }\r\n                    }\r\n                }\r\n                LOG.debug(\"query via {} took {} ms.\", this, System.currentTimeMillis() - s);\r\n                return new LucenePathCursor(rows, settings);\r\n            } finally {\r\n                reader.close();\r\n            }\r\n        } finally {\r\n            directory.close();\r\n        }\r\n    } catch (IOException e) {\r\n        LOG.warn(\"query via {} failed.\", this, e);\r\n        return newPathCursor(Collections.<String>emptySet(), settings);\r\n    }\r\n}","lc":2.1818181818,"pi":3.5071770335,"ma":2.0,"nbd":3.0,"ml":1.0833333333,"d":0.7698412698,"mi":-1.0453840733,"fo":2.25,"r":-0.0263157895,"e":3.1850601937}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5655_d558004b","label":3,"code":"\/**\r\n *  @param model\r\n *\/\r\nvoid setModelImpl(IModel<?> model) {\r\n    if (getFlag(FLAG_MODEL_SET)) {\r\n        if (model != null) {\r\n            data_set(0, model);\r\n            \/\/ and a new one is not IComponentInheritedModel\r\n            if (getFlag(FLAG_INHERITABLE_MODEL) && !(model instanceof IComponentInheritedModel)) {\r\n                setFlag(FLAG_INHERITABLE_MODEL, false);\r\n            }\r\n        } else {\r\n            data_remove(0);\r\n            setFlag(FLAG_MODEL_SET, false);\r\n        }\r\n    } else {\r\n        if (model != null) {\r\n            data_insert(0, model);\r\n            setFlag(FLAG_MODEL_SET, true);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  @param model\r\n *\/\r\n","code_no_comment":"void setModelImpl(IModel<?> model) {\r\n    if (getFlag(FLAG_MODEL_SET)) {\r\n        if (model != null) {\r\n            data_set(0, model);\r\n                        if (getFlag(FLAG_INHERITABLE_MODEL) && !(model instanceof IComponentInheritedModel)) {\r\n                setFlag(FLAG_INHERITABLE_MODEL, false);\r\n            }\r\n        } else {\r\n            data_remove(0);\r\n            setFlag(FLAG_MODEL_SET, false);\r\n        }\r\n    } else {\r\n        if (model != null) {\r\n            data_insert(0, model);\r\n            setFlag(FLAG_MODEL_SET, true);\r\n        }\r\n    }\r\n}","lc":0.1818181818,"pi":0.6746411483,"ma":0.2,"nbd":0.5,"ml":0.25,"d":0.0198412698,"mi":-0.1078224101,"fo":0.1666666667,"r":0.3157894737,"e":-0.0299879555}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3498_b4606700","label":1,"code":"public Object next() {\r\n    Object part = iterator.next();\r\n    Exchange newExchange = ExchangeHelper.createCopy(exchange, true);\r\n    if (part instanceof Message) {\r\n        newExchange.setIn((Message) part);\r\n    } else {\r\n        Message in = newExchange.getIn();\r\n        in.setBody(part);\r\n    }\r\n    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\r\n}","code_comment":null,"code_no_comment":"public Object next() {\r\n    Object part = iterator.next();\r\n    Exchange newExchange = ExchangeHelper.createCopy(exchange, true);\r\n    if (part instanceof Message) {\r\n        newExchange.setIn((Message) part);\r\n    } else {\r\n        Message in = newExchange.getIn();\r\n        in.setBody(part);\r\n    }\r\n    return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0317460317,"mi":0.1272727273,"fo":0.25,"r":0.0526315789,"e":-0.0400154446}
{"project_name":"Closure","project_version":"148","label":2,"code":"private void closeLine() throws IOException {\r\n    out.append(\"]\\n\");\r\n}","code_comment":null,"code_no_comment":"private void closeLine() throws IOException {\r\n    out.append(\"]\\n\");\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.067653277,"fo":-0.4166666667,"r":2.2631578947,"e":-0.1627934049}
{"project_name":"Closure","project_version":"75","label":2,"code":"\/**\r\n * Copied from Rhino's ScriptRuntime\r\n *\/\r\nstatic TernaryValue isStrWhiteSpaceChar(int c) {\r\n    switch(c) {\r\n        case \/\/ <VT>\r\n        '\\u000B':\r\n            return TernaryValue.TRUE;\r\n        \/\/ <SP>\r\n        case ' ':\r\n        \/\/ <LF>\r\n        case '\\n':\r\n        \/\/ <CR>\r\n        case '\\r':\r\n        \/\/ <TAB>\r\n        case '\\t':\r\n        \/\/ <NBSP>\r\n        case '\\u00A0':\r\n        \/\/ <FF>\r\n        case '\\u000C':\r\n        \/\/ <LS>\r\n        case '\\u2028':\r\n        \/\/ <PS>\r\n        case '\\u2029':\r\n        case \/\/ <BOM>\r\n        '\\uFEFF':\r\n            return TernaryValue.TRUE;\r\n        default:\r\n            return (Character.getType(c) == Character.SPACE_SEPARATOR) ? TernaryValue.TRUE : TernaryValue.FALSE;\r\n    }\r\n}","code_comment":"\/**\r\n * Copied from Rhino's ScriptRuntime\r\n *\/\r\n","code_no_comment":"static TernaryValue isStrWhiteSpaceChar(int c) {\r\n    switch(c) {\r\n        case         '\\u000B':\r\n            return TernaryValue.TRUE;\r\n                case ' ':\r\n                case '\\n':\r\n                case '\\r':\r\n                case '\\t':\r\n                case '\\u00A0':\r\n                case '\\u000C':\r\n                case '\\u2028':\r\n                case '\\u2029':\r\n        case         '\\uFEFF':\r\n            return TernaryValue.TRUE;\r\n        default:\r\n            return (Character.getType(c) == Character.SPACE_SEPARATOR) ? TernaryValue.TRUE : TernaryValue.FALSE;\r\n    }\r\n}","lc":0.2727272727,"pi":0.0861244019,"ma":1.8,"nbd":0.0,"ml":0.6666666667,"d":-0.3650793651,"mi":-0.1828047921,"fo":-0.4166666667,"r":0.4473684211,"e":-0.1627934049}
{"project_name":"Closure","project_version":"148","label":2,"code":"\/**\r\n * Write any needed entries to complete the provided mapping.\r\n *\/\r\nprivate void writeCharsBetween(Mapping prev, Mapping next) throws IOException {\r\n    int nextLine = getAdjustedLine(next.startPosition);\r\n    int nextCol = getAdjustedCol(next.startPosition);\r\n    \/\/ If the previous value is null, no mapping exists.\r\n    int id = (prev != null) ? prev.id : UNMAPPED;\r\n    writeCharsUpTo(nextLine, nextCol, id);\r\n}","code_comment":"\/**\r\n * Write any needed entries to complete the provided mapping.\r\n *\/\r\n","code_no_comment":"private void writeCharsBetween(Mapping prev, Mapping next) throws IOException {\r\n    int nextLine = getAdjustedLine(next.startPosition);\r\n    int nextCol = getAdjustedCol(next.startPosition);\r\n        int id = (prev != null) ? prev.id : UNMAPPED;\r\n    writeCharsUpTo(nextLine, nextCol, id);\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.0337301587,"mi":0.4463706836,"fo":-0.25,"r":1.9210526316,"e":-0.071711531}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5655_96337372","label":1,"code":"public void beforeMojoExecution(MojoExecutionEvent event) throws MojoExecutionException {\r\n    for (Object provided : getScopeState().provided.values()) {\r\n        if (provided instanceof WeakMojoExecutionListener) {\r\n            ((WeakMojoExecutionListener) provided).beforeMojoExecution(event);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void beforeMojoExecution(MojoExecutionEvent event) throws MojoExecutionException {\r\n    for (Object provided : getScopeState().provided.values()) {\r\n        if (provided instanceof WeakMojoExecutionListener) {\r\n            ((WeakMojoExecutionListener) provided).beforeMojoExecution(event);\r\n        }\r\n    }\r\n}","lc":-0.3181818182,"pi":0.5406698565,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.3650793651,"mi":0.4872445384,"fo":-0.25,"r":0.0,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1272_26e878ab","label":3,"code":"\/**\r\n * Computes this^e.\r\n * @param e exponent (beware, here it MUST be > 0)\r\n * @return d^e, split in high and low bits\r\n * @since 4.0\r\n *\/\r\nprivate Split pow(final long e) {\r\n    \/\/ prepare result\r\n    Split result = new Split(1);\r\n    \/\/ d^(2p)\r\n    Split d2p = new Split(full, high, low);\r\n    for (long p = e; p != 0; p >>= 1) {\r\n        if ((p & 0x1) != 0) {\r\n            \/\/ accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm\r\n            result = result.multiply(d2p);\r\n        }\r\n        \/\/ accurate squaring d^(2(p+1)) = d^(2p) * d^(2p) using Veltkamp TwoProduct algorithm\r\n        d2p = d2p.multiply(d2p);\r\n    }\r\n    if (Double.isNaN(result.full)) {\r\n        if (Double.isNaN(full)) {\r\n            return Split.NAN;\r\n        } else {\r\n            \/\/ and the low order bits became NaN (because infinity - infinity = NaN)\r\n            if (FastMath.abs(full) < 1) {\r\n                return new Split(FastMath.copySign(0.0, full), 0.0);\r\n            } else if (full < 0 && (e & 0x1) == 1) {\r\n                return Split.NEGATIVE_INFINITY;\r\n            } else {\r\n                return Split.POSITIVE_INFINITY;\r\n            }\r\n        }\r\n    } else {\r\n        return result;\r\n    }\r\n}","code_comment":"\/**\r\n * Computes this^e.\r\n * @param e exponent (beware, here it MUST be > 0)\r\n * @return d^e, split in high and low bits\r\n * @since 4.0\r\n *\/\r\n","code_no_comment":"private Split pow(final long e) {\r\n        Split result = new Split(1);\r\n        Split d2p = new Split(full, high, low);\r\n    for (long p = e; p != 0; p >>= 1) {\r\n        if ((p & 0x1) != 0) {\r\n                        result = result.multiply(d2p);\r\n        }\r\n                d2p = d2p.multiply(d2p);\r\n    }\r\n    if (Double.isNaN(result.full)) {\r\n        if (Double.isNaN(full)) {\r\n            return Split.NAN;\r\n        } else {\r\n                        if (FastMath.abs(full) < 1) {\r\n                return new Split(FastMath.copySign(0.0, full), 0.0);\r\n            } else if (full < 0 && (e & 0x1) == 1) {\r\n                return Split.NEGATIVE_INFINITY;\r\n            } else {\r\n                return Split.POSITIVE_INFINITY;\r\n            }\r\n        }\r\n    } else {\r\n        return result;\r\n    }\r\n}","lc":0.5,"pi":0.7655502392,"ma":0.6,"nbd":1.0,"ml":0.75,"d":1.1884920635,"mi":-0.4018322763,"fo":0.0,"r":0.0,"e":1.1473406984}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5209_87884c7b","label":3,"code":"public List<String> getRuntimeClasspathElements() throws DependencyResolutionRequiredException {\r\n    List<String> list = new ArrayList<String>(getArtifacts().size() + 1);\r\n    list.add(getBuild().getOutputDirectory());\r\n    for (Artifact a : getArtifacts()) {\r\n        if (a.getArtifactHandler().isAddedToClasspath()) {\r\n            \/\/ TODO: let the scope handler deal with this\r\n            if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_RUNTIME.equals(a.getScope())) {\r\n                addArtifactPath(a, list);\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}","code_comment":null,"code_no_comment":"public List<String> getRuntimeClasspathElements() throws DependencyResolutionRequiredException {\r\n    List<String> list = new ArrayList<String>(getArtifacts().size() + 1);\r\n    list.add(getBuild().getOutputDirectory());\r\n    for (Artifact a : getArtifacts()) {\r\n        if (a.getArtifactHandler().isAddedToClasspath()) {\r\n                        if (Artifact.SCOPE_COMPILE.equals(a.getScope()) || Artifact.SCOPE_RUNTIME.equals(a.getScope())) {\r\n                addArtifactPath(a, list);\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}","lc":-0.0909090909,"pi":0.8421052632,"ma":0.0,"nbd":0.5,"ml":0.1666666667,"d":-0.0317460317,"mi":0.0511627907,"fo":0.5833333333,"r":0.0,"e":-0.0187663883}
{"project_name":"Closure","project_version":"156","label":2,"code":"\/**\r\n * Updates the first initialization (a.k.a \"declaration\") of a global name\r\n * that occurs at an ASSIGN node. See comment for\r\n * {@link #updateObjLitOrFunctionDeclaration}.\r\n *\r\n * @param n An object representing a global name (e.g. \"a\", \"a.b.c\")\r\n * @param alias The flattened name for {@code n} (e.g. \"a\", \"a$b$c\")\r\n *\/\r\nprivate void updateObjLitOrFunctionDeclarationAtAssignNode(Name n, String alias) {\r\n    \/\/ NOTE: It's important that we don't add additional nodes\r\n    \/\/ (e.g. a var node before the exprstmt) because the exprstmt might be\r\n    \/\/ the child of an if statement that's not inside a block).\r\n    Ref ref = n.declaration;\r\n    Node rvalue = ref.node.getNext();\r\n    Node varNode = new Node(Token.VAR);\r\n    Node varParent = ref.node.getAncestor(3);\r\n    Node gramps = ref.node.getAncestor(2);\r\n    boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;\r\n    boolean insertedVarNode = false;\r\n    if (isObjLit && n.canEliminate()) {\r\n        \/\/ Eliminate the object literal altogether.\r\n        varParent.replaceChild(gramps, varNode);\r\n        ref.node = null;\r\n        insertedVarNode = true;\r\n    } else if (!n.isSimpleName()) {\r\n        \/\/ Create a VAR node to declare the name.\r\n        if (rvalue.getType() == Token.FUNCTION) {\r\n            checkForHosedThisReferences(rvalue, n.docInfo, n);\r\n        }\r\n        ref.node.getParent().removeChild(rvalue);\r\n        Node nameNode = NodeUtil.newName(compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.fullName());\r\n        if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {\r\n            nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\r\n        }\r\n        varNode.addChildToBack(nameNode);\r\n        nameNode.addChildToFront(rvalue);\r\n        varParent.replaceChild(gramps, varNode);\r\n        \/\/ Update the node ancestry stored in the reference.\r\n        ref.node = nameNode;\r\n        insertedVarNode = true;\r\n    }\r\n    if (isObjLit) {\r\n        declareVarsForObjLitValues(n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent);\r\n    }\r\n    addStubsForUndeclaredProperties(n, alias, varParent, varNode);\r\n    if (insertedVarNode) {\r\n        if (!varNode.hasChildren()) {\r\n            varParent.removeChild(varNode);\r\n        }\r\n        compiler.reportCodeChange();\r\n    }\r\n}","code_comment":"\/**\r\n * Updates the first initialization (a.k.a \"declaration\") of a global name\r\n * that occurs at an ASSIGN node. See comment for\r\n * {@link #updateObjLitOrFunctionDeclaration}.\r\n *\r\n * @param n An object representing a global name (e.g. \"a\", \"a.b.c\")\r\n * @param alias The flattened name for {@code n} (e.g. \"a\", \"a$b$c\")\r\n *\/\r\n","code_no_comment":"private void updateObjLitOrFunctionDeclarationAtAssignNode(Name n, String alias) {\r\n                Ref ref = n.declaration;\r\n    Node rvalue = ref.node.getNext();\r\n    Node varNode = new Node(Token.VAR);\r\n    Node varParent = ref.node.getAncestor(3);\r\n    Node gramps = ref.node.getAncestor(2);\r\n    boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;\r\n    boolean insertedVarNode = false;\r\n    if (isObjLit && n.canEliminate()) {\r\n                varParent.replaceChild(gramps, varNode);\r\n        ref.node = null;\r\n        insertedVarNode = true;\r\n    } else if (!n.isSimpleName()) {\r\n                if (rvalue.getType() == Token.FUNCTION) {\r\n            checkForHosedThisReferences(rvalue, n.docInfo, n);\r\n        }\r\n        ref.node.getParent().removeChild(rvalue);\r\n        Node nameNode = NodeUtil.newName(compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.fullName());\r\n        if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {\r\n            nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\r\n        }\r\n        varNode.addChildToBack(nameNode);\r\n        nameNode.addChildToFront(rvalue);\r\n        varParent.replaceChild(gramps, varNode);\r\n                ref.node = nameNode;\r\n        insertedVarNode = true;\r\n    }\r\n    if (isObjLit) {\r\n        declareVarsForObjLitValues(n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent);\r\n    }\r\n    addStubsForUndeclaredProperties(n, alias, varParent, varNode);\r\n    if (insertedVarNode) {\r\n        if (!varNode.hasChildren()) {\r\n            varParent.removeChild(varNode);\r\n        }\r\n        compiler.reportCodeChange();\r\n    }\r\n}","lc":1.0909090909,"pi":-0.0669856459,"ma":0.8,"nbd":0.5,"ml":0.8333333333,"d":0.6011904762,"mi":-0.7243128964,"fo":1.75,"r":-0.0263157895,"e":1.7484368066}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1093_7cfbc0da","label":1,"code":"\/**\r\n * Split the instance in two parts by an arc.\r\n * @param arc splitting arc\r\n * @return an object containing both the part of the instance\r\n * on the plus side of the arc and the part of the\r\n * instance on the minus side of the arc\r\n *\/\r\npublic Split split(final Arc arc) {\r\n    final BSPTree<Sphere1D> minus = new BSPTree<Sphere1D>();\r\n    minus.setAttribute(Boolean.FALSE);\r\n    final BSPTree<Sphere1D> plus = new BSPTree<Sphere1D>();\r\n    plus.setAttribute(Boolean.FALSE);\r\n    final double reference = FastMath.PI + arc.getInf();\r\n    final double arcLength = arc.getSup() - arc.getInf();\r\n    for (final double[] a : this) {\r\n        final double syncedStart = MathUtils.normalizeAngle(a[0], reference) - arc.getInf();\r\n        final double arcOffset = a[0] - syncedStart;\r\n        final double syncedEnd = a[1] - arcOffset;\r\n        if (syncedStart < arcLength) {\r\n            \/\/ the start point a[0] is in the minus part of the arc\r\n            addArcLimit(minus, a[0], true);\r\n            if (syncedEnd > arcLength) {\r\n                \/\/ the end point a[1] is past the end of the arc\r\n                \/\/ so we leave the minus part and enter the plus part\r\n                final double minusToPlus = arcLength + arcOffset;\r\n                addArcLimit(minus, minusToPlus, false);\r\n                addArcLimit(plus, minusToPlus, true);\r\n                if (syncedEnd > MathUtils.TWO_PI) {\r\n                    \/\/ in fact the end point a[1] goes far enough that we\r\n                    \/\/ leave the plus part of the arc and enter the minus part again\r\n                    final double plusToMinus = MathUtils.TWO_PI + arcOffset;\r\n                    addArcLimit(plus, plusToMinus, false);\r\n                    addArcLimit(minus, plusToMinus, true);\r\n                    addArcLimit(minus, a[1], false);\r\n                } else {\r\n                    \/\/ the end point a[1] is in the plus part of the arc\r\n                    addArcLimit(plus, a[1], false);\r\n                }\r\n            } else {\r\n                \/\/ the end point a[1] is in the minus part of the arc\r\n                addArcLimit(minus, a[1], false);\r\n            }\r\n        } else {\r\n            \/\/ the start point a[0] is in the plus part of the arc\r\n            addArcLimit(plus, a[0], true);\r\n            if (syncedEnd > MathUtils.TWO_PI) {\r\n                \/\/ the end point a[1] wraps around to the start of the arc\r\n                \/\/ so we leave the plus part and enter the minus part\r\n                final double plusToMinus = MathUtils.TWO_PI + arcOffset;\r\n                addArcLimit(plus, plusToMinus, false);\r\n                addArcLimit(minus, plusToMinus, true);\r\n                if (syncedEnd > MathUtils.TWO_PI + arcLength) {\r\n                    \/\/ in fact the end point a[1] goes far enough that we\r\n                    \/\/ leave the minus part of the arc and enter the plus part again\r\n                    final double minusToPlus = MathUtils.TWO_PI + arcLength + arcOffset;\r\n                    addArcLimit(minus, minusToPlus, false);\r\n                    addArcLimit(plus, minusToPlus, true);\r\n                    addArcLimit(plus, a[1], false);\r\n                } else {\r\n                    \/\/ the end point a[1] is in the minus part of the arc\r\n                    addArcLimit(minus, a[1], false);\r\n                }\r\n            } else {\r\n                \/\/ the end point a[1] is in the plus part of the arc\r\n                addArcLimit(plus, a[1], false);\r\n            }\r\n        }\r\n    }\r\n    return new Split(createSplitPart(plus), createSplitPart(minus));\r\n}","code_comment":"\/**\r\n * Split the instance in two parts by an arc.\r\n * @param arc splitting arc\r\n * @return an object containing both the part of the instance\r\n * on the plus side of the arc and the part of the\r\n * instance on the minus side of the arc\r\n *\/\r\n","code_no_comment":"public Split split(final Arc arc) {\r\n    final BSPTree<Sphere1D> minus = new BSPTree<Sphere1D>();\r\n    minus.setAttribute(Boolean.FALSE);\r\n    final BSPTree<Sphere1D> plus = new BSPTree<Sphere1D>();\r\n    plus.setAttribute(Boolean.FALSE);\r\n    final double reference = FastMath.PI + arc.getInf();\r\n    final double arcLength = arc.getSup() - arc.getInf();\r\n    for (final double[] a : this) {\r\n        final double syncedStart = MathUtils.normalizeAngle(a[0], reference) - arc.getInf();\r\n        final double arcOffset = a[0] - syncedStart;\r\n        final double syncedEnd = a[1] - arcOffset;\r\n        if (syncedStart < arcLength) {\r\n                        addArcLimit(minus, a[0], true);\r\n            if (syncedEnd > arcLength) {\r\n                                                final double minusToPlus = arcLength + arcOffset;\r\n                addArcLimit(minus, minusToPlus, false);\r\n                addArcLimit(plus, minusToPlus, true);\r\n                if (syncedEnd > MathUtils.TWO_PI) {\r\n                                                            final double plusToMinus = MathUtils.TWO_PI + arcOffset;\r\n                    addArcLimit(plus, plusToMinus, false);\r\n                    addArcLimit(minus, plusToMinus, true);\r\n                    addArcLimit(minus, a[1], false);\r\n                } else {\r\n                                        addArcLimit(plus, a[1], false);\r\n                }\r\n            } else {\r\n                                addArcLimit(minus, a[1], false);\r\n            }\r\n        } else {\r\n                        addArcLimit(plus, a[0], true);\r\n            if (syncedEnd > MathUtils.TWO_PI) {\r\n                                                final double plusToMinus = MathUtils.TWO_PI + arcOffset;\r\n                addArcLimit(plus, plusToMinus, false);\r\n                addArcLimit(minus, plusToMinus, true);\r\n                if (syncedEnd > MathUtils.TWO_PI + arcLength) {\r\n                                                            final double minusToPlus = MathUtils.TWO_PI + arcLength + arcOffset;\r\n                    addArcLimit(minus, minusToPlus, false);\r\n                    addArcLimit(plus, minusToPlus, true);\r\n                    addArcLimit(plus, a[1], false);\r\n                } else {\r\n                                        addArcLimit(minus, a[1], false);\r\n                }\r\n            } else {\r\n                                addArcLimit(plus, a[1], false);\r\n            }\r\n        }\r\n    }\r\n    return new Split(createSplitPart(plus), createSplitPart(minus));\r\n}","lc":1.5909090909,"pi":1.4832535885,"ma":0.6,"nbd":1.0,"ml":0.25,"d":1.5238095238,"mi":-0.851726568,"fo":1.5833333333,"r":-0.0263157895,"e":4.050167413}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-880_2a9cbbab","label":1,"code":"\/**\r\n * Build the BSP tree of a polygons set from a simple list of vertices.\r\n * <p>The boundary is provided as a list of points considering to\r\n * represent the vertices of a simple loop. The interior part of the\r\n * region is on the left side of this path and the exterior is on its\r\n * right side.<\/p>\r\n * <p>This constructor does not handle polygons with a boundary\r\n * forming several disconnected paths (such as polygons with holes).<\/p>\r\n * <p>For cases where this simple constructor applies, it is expected to\r\n * be numerically more robust than the {@link #PolygonsSet(Collection) general\r\n * constructor} using {@link SubHyperplane subhyperplanes}.<\/p>\r\n * @param hyperplaneThickness tolerance below which points are consider to\r\n * belong to the hyperplane (which is therefore more a slab)\r\n * @param vertices vertices of the simple loop boundary\r\n *\/\r\nprivate static BSPTree<Euclidean2D> verticesToTree(final double hyperplaneThickness, final Vector2D... vertices) {\r\n    if (vertices.length == 0) {\r\n        \/\/ the tree represents the whole space\r\n        return new BSPTree<Euclidean2D>(Boolean.TRUE);\r\n    }\r\n    \/\/ at start, none of the edges have been processed\r\n    final BSPTree<Euclidean2D> tree = new BSPTree<Euclidean2D>();\r\n    List<Vertex> list = new ArrayList<PolygonsSet.Vertex>(vertices.length);\r\n    for (final Vector2D vertex : vertices) {\r\n        list.add(new Vertex(vertex));\r\n    }\r\n    \/\/ build the tree top-down\r\n    insertVertices(hyperplaneThickness, tree, list);\r\n    return tree;\r\n}","code_comment":"\/**\r\n * Build the BSP tree of a polygons set from a simple list of vertices.\r\n * <p>The boundary is provided as a list of points considering to\r\n * represent the vertices of a simple loop. The interior part of the\r\n * region is on the left side of this path and the exterior is on its\r\n * right side.<\/p>\r\n * <p>This constructor does not handle polygons with a boundary\r\n * forming several disconnected paths (such as polygons with holes).<\/p>\r\n * <p>For cases where this simple constructor applies, it is expected to\r\n * be numerically more robust than the {@link #PolygonsSet(Collection) general\r\n * constructor} using {@link SubHyperplane subhyperplanes}.<\/p>\r\n * @param hyperplaneThickness tolerance below which points are consider to\r\n * belong to the hyperplane (which is therefore more a slab)\r\n * @param vertices vertices of the simple loop boundary\r\n *\/\r\n","code_no_comment":"private static BSPTree<Euclidean2D> verticesToTree(final double hyperplaneThickness, final Vector2D... vertices) {\r\n    if (vertices.length == 0) {\r\n                return new BSPTree<Euclidean2D>(Boolean.TRUE);\r\n    }\r\n        final BSPTree<Euclidean2D> tree = new BSPTree<Euclidean2D>();\r\n    List<Vertex> list = new ArrayList<PolygonsSet.Vertex>(vertices.length);\r\n    for (final Vector2D vertex : vertices) {\r\n        list.add(new Vertex(vertex));\r\n    }\r\n        insertVertices(hyperplaneThickness, tree, list);\r\n    return tree;\r\n}","lc":-0.0909090909,"pi":-0.3253588517,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":0.0218253968,"mi":0.0562367865,"fo":-0.3333333333,"r":-0.0263157895,"e":0.0055900371}
{"project_name":"Math","project_version":"64","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\r\n    \/\/ arrays shared with the other private methods\r\n    solvedCols = Math.min(rows, cols);\r\n    diagR = new double[cols];\r\n    jacNorm = new double[cols];\r\n    beta = new double[cols];\r\n    permutation = new int[cols];\r\n    lmDir = new double[cols];\r\n    \/\/ local point\r\n    double delta = 0;\r\n    double xNorm = 0;\r\n    double[] diag = new double[cols];\r\n    double[] oldX = new double[cols];\r\n    double[] oldRes = new double[rows];\r\n    double[] work1 = new double[cols];\r\n    double[] work2 = new double[cols];\r\n    double[] work3 = new double[cols];\r\n    \/\/ evaluate the function at the starting point and calculate its norm\r\n    updateResidualsAndCost();\r\n    \/\/ outer loop\r\n    lmPar = 0;\r\n    boolean firstIteration = true;\r\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\r\n    while (true) {\r\n        incrementIterationsCounter();\r\n        \/\/ compute the Q.R. decomposition of the jacobian matrix\r\n        VectorialPointValuePair previous = current;\r\n        updateJacobian();\r\n        qrDecomposition();\r\n        \/\/ compute Qt.res\r\n        qTy(residuals);\r\n        \/\/ so let jacobian contain the R matrix with its diagonal elements\r\n        for (int k = 0; k < solvedCols; ++k) {\r\n            int pk = permutation[k];\r\n            jacobian[k][pk] = diagR[pk];\r\n        }\r\n        if (firstIteration) {\r\n            \/\/ scale the point according to the norms of the columns\r\n            \/\/ of the initial jacobian\r\n            xNorm = 0;\r\n            for (int k = 0; k < cols; ++k) {\r\n                double dk = jacNorm[k];\r\n                if (dk == 0) {\r\n                    dk = 1.0;\r\n                }\r\n                double xk = dk * point[k];\r\n                xNorm += xk * xk;\r\n                diag[k] = dk;\r\n            }\r\n            xNorm = Math.sqrt(xNorm);\r\n            \/\/ initialize the step bound delta\r\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\r\n        }\r\n        \/\/ check orthogonality between function vector and jacobian columns\r\n        double maxCosine = 0;\r\n        if (cost != 0) {\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                double s = jacNorm[pj];\r\n                if (s != 0) {\r\n                    double sum = 0;\r\n                    for (int i = 0; i <= j; ++i) {\r\n                        sum += jacobian[i][pj] * residuals[i];\r\n                    }\r\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) \/ (s * cost));\r\n                }\r\n            }\r\n        }\r\n        if (maxCosine <= orthoTolerance) {\r\n            \/\/ convergence has been reached\r\n            return current;\r\n        }\r\n        \/\/ rescale if necessary\r\n        for (int j = 0; j < cols; ++j) {\r\n            diag[j] = Math.max(diag[j], jacNorm[j]);\r\n        }\r\n        \/\/ inner loop\r\n        for (double ratio = 0; ratio < 1.0e-4; ) {\r\n            \/\/ save the state\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                oldX[pj] = point[pj];\r\n            }\r\n            double previousCost = cost;\r\n            double[] tmpVec = residuals;\r\n            residuals = oldRes;\r\n            oldRes = tmpVec;\r\n            \/\/ determine the Levenberg-Marquardt parameter\r\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\r\n            \/\/ compute the new point and the norm of the evolution direction\r\n            double lmNorm = 0;\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                lmDir[pj] = -lmDir[pj];\r\n                point[pj] = oldX[pj] + lmDir[pj];\r\n                double s = diag[pj] * lmDir[pj];\r\n                lmNorm += s * s;\r\n            }\r\n            lmNorm = Math.sqrt(lmNorm);\r\n            \/\/ on the first iteration, adjust the initial step bound.\r\n            if (firstIteration) {\r\n                delta = Math.min(delta, lmNorm);\r\n            }\r\n            \/\/ evaluate the function at x + p and calculate its norm\r\n            updateResidualsAndCost();\r\n            current = new VectorialPointValuePair(point, objective);\r\n            \/\/ compute the scaled actual reduction\r\n            double actRed = -1.0;\r\n            if (0.1 * cost < previousCost) {\r\n                double r = cost \/ previousCost;\r\n                actRed = 1.0 - r * r;\r\n            }\r\n            \/\/ and the scaled directional derivative\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                double dirJ = lmDir[pj];\r\n                work1[j] = 0;\r\n                for (int i = 0; i <= j; ++i) {\r\n                    work1[i] += jacobian[i][pj] * dirJ;\r\n                }\r\n            }\r\n            double coeff1 = 0;\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                coeff1 += work1[j] * work1[j];\r\n            }\r\n            double pc2 = previousCost * previousCost;\r\n            coeff1 = coeff1 \/ pc2;\r\n            double coeff2 = lmPar * lmNorm * lmNorm \/ pc2;\r\n            double preRed = coeff1 + 2 * coeff2;\r\n            double dirDer = -(coeff1 + coeff2);\r\n            \/\/ ratio of the actual to the predicted reduction\r\n            ratio = (preRed == 0) ? 0 : (actRed \/ preRed);\r\n            \/\/ update the step bound\r\n            if (ratio <= 0.25) {\r\n                double tmp = (actRed < 0) ? (0.5 * dirDer \/ (dirDer + 0.5 * actRed)) : 0.5;\r\n                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\r\n                    tmp = 0.1;\r\n                }\r\n                delta = tmp * Math.min(delta, 10.0 * lmNorm);\r\n                lmPar \/= tmp;\r\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\r\n                delta = 2 * lmNorm;\r\n                lmPar *= 0.5;\r\n            }\r\n            \/\/ test for successful iteration.\r\n            if (ratio >= 1.0e-4) {\r\n                \/\/ successful iteration, update the norm\r\n                firstIteration = false;\r\n                xNorm = 0;\r\n                for (int k = 0; k < cols; ++k) {\r\n                    double xK = diag[k] * point[k];\r\n                    xNorm += xK * xK;\r\n                }\r\n                xNorm = Math.sqrt(xNorm);\r\n            \/\/ tests for convergence.\r\n            \/\/ we use the vectorial convergence checker\r\n            } else {\r\n                \/\/ failed iteration, reset the previous values\r\n                cost = previousCost;\r\n                for (int j = 0; j < solvedCols; ++j) {\r\n                    int pj = permutation[j];\r\n                    point[pj] = oldX[pj];\r\n                }\r\n                tmpVec = residuals;\r\n                residuals = oldRes;\r\n                oldRes = tmpVec;\r\n            }\r\n            if (checker == null) {\r\n                if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {\r\n                    return current;\r\n                }\r\n            } else {\r\n                if (checker.converged(getIterations(), previous, current)) {\r\n                    return current;\r\n                }\r\n            }\r\n            \/\/ (2.2204e-16 is the machine epsilon for IEEE754)\r\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\r\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\r\n            } else if (delta <= 2.2204e-16 * xNorm) {\r\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\r\n            } else if (maxCosine <= 2.2204e-16) {\r\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\r\n        solvedCols = Math.min(rows, cols);\r\n    diagR = new double[cols];\r\n    jacNorm = new double[cols];\r\n    beta = new double[cols];\r\n    permutation = new int[cols];\r\n    lmDir = new double[cols];\r\n        double delta = 0;\r\n    double xNorm = 0;\r\n    double[] diag = new double[cols];\r\n    double[] oldX = new double[cols];\r\n    double[] oldRes = new double[rows];\r\n    double[] work1 = new double[cols];\r\n    double[] work2 = new double[cols];\r\n    double[] work3 = new double[cols];\r\n        updateResidualsAndCost();\r\n        lmPar = 0;\r\n    boolean firstIteration = true;\r\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\r\n    while (true) {\r\n        incrementIterationsCounter();\r\n                VectorialPointValuePair previous = current;\r\n        updateJacobian();\r\n        qrDecomposition();\r\n                qTy(residuals);\r\n                for (int k = 0; k < solvedCols; ++k) {\r\n            int pk = permutation[k];\r\n            jacobian[k][pk] = diagR[pk];\r\n        }\r\n        if (firstIteration) {\r\n                                    xNorm = 0;\r\n            for (int k = 0; k < cols; ++k) {\r\n                double dk = jacNorm[k];\r\n                if (dk == 0) {\r\n                    dk = 1.0;\r\n                }\r\n                double xk = dk * point[k];\r\n                xNorm += xk * xk;\r\n                diag[k] = dk;\r\n            }\r\n            xNorm = Math.sqrt(xNorm);\r\n                        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\r\n        }\r\n                double maxCosine = 0;\r\n        if (cost != 0) {\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                double s = jacNorm[pj];\r\n                if (s != 0) {\r\n                    double sum = 0;\r\n                    for (int i = 0; i <= j; ++i) {\r\n                        sum += jacobian[i][pj] * residuals[i];\r\n                    }\r\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) \/ (s * cost));\r\n                }\r\n            }\r\n        }\r\n        if (maxCosine <= orthoTolerance) {\r\n                        return current;\r\n        }\r\n                for (int j = 0; j < cols; ++j) {\r\n            diag[j] = Math.max(diag[j], jacNorm[j]);\r\n        }\r\n                for (double ratio = 0; ratio < 1.0e-4; ) {\r\n                        for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                oldX[pj] = point[pj];\r\n            }\r\n            double previousCost = cost;\r\n            double[] tmpVec = residuals;\r\n            residuals = oldRes;\r\n            oldRes = tmpVec;\r\n                        determineLMParameter(oldRes, delta, diag, work1, work2, work3);\r\n                        double lmNorm = 0;\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                lmDir[pj] = -lmDir[pj];\r\n                point[pj] = oldX[pj] + lmDir[pj];\r\n                double s = diag[pj] * lmDir[pj];\r\n                lmNorm += s * s;\r\n            }\r\n            lmNorm = Math.sqrt(lmNorm);\r\n                        if (firstIteration) {\r\n                delta = Math.min(delta, lmNorm);\r\n            }\r\n                        updateResidualsAndCost();\r\n            current = new VectorialPointValuePair(point, objective);\r\n                        double actRed = -1.0;\r\n            if (0.1 * cost < previousCost) {\r\n                double r = cost \/ previousCost;\r\n                actRed = 1.0 - r * r;\r\n            }\r\n                        for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                double dirJ = lmDir[pj];\r\n                work1[j] = 0;\r\n                for (int i = 0; i <= j; ++i) {\r\n                    work1[i] += jacobian[i][pj] * dirJ;\r\n                }\r\n            }\r\n            double coeff1 = 0;\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                coeff1 += work1[j] * work1[j];\r\n            }\r\n            double pc2 = previousCost * previousCost;\r\n            coeff1 = coeff1 \/ pc2;\r\n            double coeff2 = lmPar * lmNorm * lmNorm \/ pc2;\r\n            double preRed = coeff1 + 2 * coeff2;\r\n            double dirDer = -(coeff1 + coeff2);\r\n                        ratio = (preRed == 0) ? 0 : (actRed \/ preRed);\r\n                        if (ratio <= 0.25) {\r\n                double tmp = (actRed < 0) ? (0.5 * dirDer \/ (dirDer + 0.5 * actRed)) : 0.5;\r\n                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\r\n                    tmp = 0.1;\r\n                }\r\n                delta = tmp * Math.min(delta, 10.0 * lmNorm);\r\n                lmPar \/= tmp;\r\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\r\n                delta = 2 * lmNorm;\r\n                lmPar *= 0.5;\r\n            }\r\n                        if (ratio >= 1.0e-4) {\r\n                                firstIteration = false;\r\n                xNorm = 0;\r\n                for (int k = 0; k < cols; ++k) {\r\n                    double xK = diag[k] * point[k];\r\n                    xNorm += xK * xK;\r\n                }\r\n                xNorm = Math.sqrt(xNorm);\r\n                                    } else {\r\n                                cost = previousCost;\r\n                for (int j = 0; j < solvedCols; ++j) {\r\n                    int pj = permutation[j];\r\n                    point[pj] = oldX[pj];\r\n                }\r\n                tmpVec = residuals;\r\n                residuals = oldRes;\r\n                oldRes = tmpVec;\r\n            }\r\n            if (checker == null) {\r\n                if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {\r\n                    return current;\r\n                }\r\n            } else {\r\n                if (checker.converged(getIterations(), previous, current)) {\r\n                    return current;\r\n                }\r\n            }\r\n                        if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\r\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\r\n            } else if (delta <= 2.2204e-16 * xNorm) {\r\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\r\n            } else if (maxCosine <= 2.2204e-16) {\r\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\r\n            }\r\n        }\r\n    }\r\n}","lc":6.5909090909,"pi":0.8995215311,"ma":6.8,"nbd":1.5,"ml":5.25,"d":7.0714285714,"mi":-1.8056377731,"fo":1.1666666667,"r":-0.0263157895,"e":71.9677114849}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4520_b91154ea","label":1,"code":"@Override\r\nprotected MarkupElement onComponentTag(final ComponentTag tag) throws ParseException {\r\n    \/\/ We only need ComponentTags\r\n    if (tag instanceof WicketTag) {\r\n        return tag;\r\n    }\r\n    \/\/ Has wicket:enclosure attribute?\r\n    String enclosureAttr = getInlineEnclosureAttribute(tag);\r\n    if (enclosureAttr != null) {\r\n        if (tag.isOpen()) {\r\n            \/\/ Make sure 'wicket:id' and 'id' are consistent\r\n            String htmlId = tag.getAttribute(\"id\");\r\n            if ((tag.getId() != null) && !Strings.isEmpty(htmlId) && !htmlId.equals(tag.getId())) {\r\n                throw new ParseException(\"Make sure that 'id' and 'wicket:id' are the same if both are provided. Tag:\" + tag.toString(), tag.getPos());\r\n            }\r\n            \/\/ if it doesn't have a wicket-id already, than assign one now.\r\n            if (Strings.isEmpty(tag.getId())) {\r\n                if (Strings.isEmpty(htmlId)) {\r\n                    tag.setId(INLINE_ENCLOSURE_ID_PREFIX);\r\n                } else {\r\n                    tag.setId(htmlId);\r\n                }\r\n                tag.setAutoComponentTag(true);\r\n                tag.setModified(true);\r\n            }\r\n            \/\/ Put the enclosure on the stack. The most current one will be on top\r\n            if (enclosures == null) {\r\n                enclosures = new Stack<ComponentTag>();\r\n            }\r\n            enclosures.push(tag);\r\n        } else {\r\n            throw new ParseException(\"Open-close tags don't make sense for InlineEnclosure. Tag:\" + tag.toString(), tag.getPos());\r\n        }\r\n    } else \/\/ Are we within an enclosure?\r\n    if ((enclosures != null) && (enclosures.size() > 0)) {\r\n        \/\/ first ComponentTag's id found as the controlling child to the enclosure.\r\n        if (tag.isOpen() && (tag.getId() != null) && !(tag instanceof WicketTag) && !tag.isAutoComponentTag()) {\r\n            for (int i = enclosures.size() - 1; i >= 0; i--) {\r\n                ComponentTag lastEnclosure = enclosures.get(i);\r\n                String attr = getInlineEnclosureAttribute(lastEnclosure);\r\n                if (Strings.isEmpty(attr) == true) {\r\n                    lastEnclosure.getAttributes().put(INLINE_ENCLOSURE_ATTRIBUTE_NAME, tag.getId());\r\n                    lastEnclosure.setModified(true);\r\n                }\r\n            }\r\n        } else if (tag.isClose() && tag.closes(enclosures.peek())) {\r\n            ComponentTag lastEnclosure = enclosures.pop();\r\n            String attr = getInlineEnclosureAttribute(lastEnclosure);\r\n            if (Strings.isEmpty(attr) == true) {\r\n                throw new ParseException(\"Did not find any child for InlineEnclosure. Tag:\" + lastEnclosure.toString(), tag.getPos());\r\n            }\r\n        }\r\n    }\r\n    return tag;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected MarkupElement onComponentTag(final ComponentTag tag) throws ParseException {\r\n        if (tag instanceof WicketTag) {\r\n        return tag;\r\n    }\r\n        String enclosureAttr = getInlineEnclosureAttribute(tag);\r\n    if (enclosureAttr != null) {\r\n        if (tag.isOpen()) {\r\n                        String htmlId = tag.getAttribute(\"id\");\r\n            if ((tag.getId() != null) && !Strings.isEmpty(htmlId) && !htmlId.equals(tag.getId())) {\r\n                throw new ParseException(\"Make sure that 'id' and 'wicket:id' are the same if both are provided. Tag:\" + tag.toString(), tag.getPos());\r\n            }\r\n                        if (Strings.isEmpty(tag.getId())) {\r\n                if (Strings.isEmpty(htmlId)) {\r\n                    tag.setId(INLINE_ENCLOSURE_ID_PREFIX);\r\n                } else {\r\n                    tag.setId(htmlId);\r\n                }\r\n                tag.setAutoComponentTag(true);\r\n                tag.setModified(true);\r\n            }\r\n                        if (enclosures == null) {\r\n                enclosures = new Stack<ComponentTag>();\r\n            }\r\n            enclosures.push(tag);\r\n        } else {\r\n            throw new ParseException(\"Open-close tags don't make sense for InlineEnclosure. Tag:\" + tag.toString(), tag.getPos());\r\n        }\r\n    } else     if ((enclosures != null) && (enclosures.size() > 0)) {\r\n                if (tag.isOpen() && (tag.getId() != null) && !(tag instanceof WicketTag) && !tag.isAutoComponentTag()) {\r\n            for (int i = enclosures.size() - 1; i >= 0; i--) {\r\n                ComponentTag lastEnclosure = enclosures.get(i);\r\n                String attr = getInlineEnclosureAttribute(lastEnclosure);\r\n                if (Strings.isEmpty(attr) == true) {\r\n                    lastEnclosure.getAttributes().put(INLINE_ENCLOSURE_ATTRIBUTE_NAME, tag.getId());\r\n                    lastEnclosure.setModified(true);\r\n                }\r\n            }\r\n        } else if (tag.isClose() && tag.closes(enclosures.peek())) {\r\n            ComponentTag lastEnclosure = enclosures.pop();\r\n            String attr = getInlineEnclosureAttribute(lastEnclosure);\r\n            if (Strings.isEmpty(attr) == true) {\r\n                throw new ParseException(\"Did not find any child for InlineEnclosure. Tag:\" + lastEnclosure.toString(), tag.getPos());\r\n            }\r\n        }\r\n    }\r\n    return tag;\r\n}","lc":1.5909090909,"pi":1.1770334928,"ma":2.6,"nbd":1.5,"ml":2.6666666667,"d":2.5277777778,"mi":-0.9219168428,"fo":2.75,"r":-0.0263157895,"e":6.5327616512}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-795_9453bcfa","label":3,"code":"\/**\r\n * @param tableName\r\n *          the name of the table\r\n * @param timeType\r\n *          specifies logical or real-time based time recording for entries in the table\r\n * @param limitVersion\r\n *          Enables\/disables the versioning iterator, which will limit the number of Key versions kept.\r\n *\/\r\npublic void create(String tableName, boolean limitVersion, TimeType timeType) throws AccumuloException, AccumuloSecurityException, TableExistsException {\r\n    ArgumentChecker.notNull(tableName, timeType);\r\n    List<ByteBuffer> args = Arrays.asList(ByteBuffer.wrap(tableName.getBytes()), ByteBuffer.wrap(timeType.name().getBytes()));\r\n    Map<String, String> opts;\r\n    if (limitVersion) {\r\n        opts = IteratorUtil.generateInitialTableProperties();\r\n    } else\r\n        opts = Collections.emptyMap();\r\n    try {\r\n        doTableOperation(TableOperation.CREATE, args, opts);\r\n    } catch (TableNotFoundException e1) {\r\n        \/\/ should not happen\r\n        throw new RuntimeException(e1);\r\n    }\r\n}","code_comment":"\/**\r\n * @param tableName\r\n *          the name of the table\r\n * @param timeType\r\n *          specifies logical or real-time based time recording for entries in the table\r\n * @param limitVersion\r\n *          Enables\/disables the versioning iterator, which will limit the number of Key versions kept.\r\n *\/\r\n","code_no_comment":"public void create(String tableName, boolean limitVersion, TimeType timeType) throws AccumuloException, AccumuloSecurityException, TableExistsException {\r\n    ArgumentChecker.notNull(tableName, timeType);\r\n    List<ByteBuffer> args = Arrays.asList(ByteBuffer.wrap(tableName.getBytes()), ByteBuffer.wrap(timeType.name().getBytes()));\r\n    Map<String, String> opts;\r\n    if (limitVersion) {\r\n        opts = IteratorUtil.generateInitialTableProperties();\r\n    } else\r\n        opts = Collections.emptyMap();\r\n    try {\r\n        doTableOperation(TableOperation.CREATE, args, opts);\r\n    } catch (TableNotFoundException e1) {\r\n                throw new RuntimeException(e1);\r\n    }\r\n}","lc":0.0,"pi":-0.2057416268,"ma":0.0,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":-0.0669485553,"fo":0.3333333333,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"Math","project_version":"66","label":1,"code":"\/**\r\n * Find the minimum of the function within the interval {@code (lo, hi)}.\r\n *\r\n * If the function is defined on the interval {@code (lo, hi)}, then\r\n * this method finds an approximation {@code x} to the point at which\r\n * the function attains its minimum.<br\/>\r\n * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}\r\n * and the function is never evaluated at two points closer together than\r\n * {@code tol}. {@code eps} should be no smaller than <em>2 macheps<\/em> and\r\n * preferable not much less than <em>sqrt(macheps)<\/em>, where\r\n * <em>macheps<\/em> is the relative machine precision. {@code t} should be\r\n * positive.\r\n * @param isMinim {@code true} when minimizing the function.\r\n * @param lo Lower bound of the interval.\r\n * @param mid Point inside the interval {@code [lo, hi]}.\r\n * @param hi Higher bound of the interval.\r\n * @param eps Relative accuracy.\r\n * @param t Absolute accuracy.\r\n * @return the optimum point.\r\n * @throws MaxIterationsExceededException if the maximum iteration count\r\n * is exceeded.\r\n * @throws FunctionEvaluationException if an error occurs evaluating\r\n * the function.\r\n *\/\r\nprivate double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    if (eps <= 0) {\r\n        throw new NotStrictlyPositiveException(eps);\r\n    }\r\n    if (t <= 0) {\r\n        throw new NotStrictlyPositiveException(t);\r\n    }\r\n    double a, b;\r\n    if (lo < hi) {\r\n        a = lo;\r\n        b = hi;\r\n    } else {\r\n        a = hi;\r\n        b = lo;\r\n    }\r\n    double x = mid;\r\n    double v = x;\r\n    double w = x;\r\n    double d = 0;\r\n    double e = 0;\r\n    double fx = computeObjectiveValue(f, x);\r\n    if (goalType == GoalType.MAXIMIZE) {\r\n        fx = -fx;\r\n    }\r\n    double fv = fx;\r\n    double fw = fx;\r\n    int count = 0;\r\n    while (count < maximalIterationCount) {\r\n        double m = 0.5 * (a + b);\r\n        final double tol1 = eps * Math.abs(x) + t;\r\n        final double tol2 = 2 * tol1;\r\n        \/\/ Check stopping criterion.\r\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\r\n            double p = 0;\r\n            double q = 0;\r\n            double r = 0;\r\n            double u = 0;\r\n            if (Math.abs(e) > tol1) {\r\n                \/\/ Fit parabola.\r\n                r = (x - w) * (fx - fv);\r\n                q = (x - v) * (fx - fw);\r\n                p = (x - v) * q - (x - w) * r;\r\n                q = 2 * (q - r);\r\n                if (q > 0) {\r\n                    p = -p;\r\n                } else {\r\n                    q = -q;\r\n                }\r\n                r = e;\r\n                e = d;\r\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\r\n                    \/\/ Parabolic interpolation step.\r\n                    d = p \/ q;\r\n                    u = x + d;\r\n                    \/\/ f must not be evaluated too close to a or b.\r\n                    if (u - a < tol2 || b - u < tol2) {\r\n                        if (x <= m) {\r\n                            d = tol1;\r\n                        } else {\r\n                            d = -tol1;\r\n                        }\r\n                    }\r\n                } else {\r\n                    \/\/ Golden section step.\r\n                    if (x < m) {\r\n                        e = b - x;\r\n                    } else {\r\n                        e = a - x;\r\n                    }\r\n                    d = GOLDEN_SECTION * e;\r\n                }\r\n            } else {\r\n                \/\/ Golden section step.\r\n                if (x < m) {\r\n                    e = b - x;\r\n                } else {\r\n                    e = a - x;\r\n                }\r\n                d = GOLDEN_SECTION * e;\r\n            }\r\n            \/\/ Update by at least \"tol1\".\r\n            if (Math.abs(d) < tol1) {\r\n                if (d >= 0) {\r\n                    u = x + tol1;\r\n                } else {\r\n                    u = x - tol1;\r\n                }\r\n            } else {\r\n                u = x + d;\r\n            }\r\n            double fu = computeObjectiveValue(f, u);\r\n            if (goalType == GoalType.MAXIMIZE) {\r\n                fu = -fu;\r\n            }\r\n            \/\/ Update a, b, v, w and x.\r\n            if (fu <= fx) {\r\n                if (u < x) {\r\n                    b = x;\r\n                } else {\r\n                    a = x;\r\n                }\r\n                v = w;\r\n                fv = fw;\r\n                w = x;\r\n                fw = fx;\r\n                x = u;\r\n                fx = fu;\r\n            } else {\r\n                if (u < x) {\r\n                    a = u;\r\n                } else {\r\n                    b = u;\r\n                }\r\n                if (fu <= fw || w == x) {\r\n                    v = w;\r\n                    fv = fw;\r\n                    w = u;\r\n                    fw = fu;\r\n                } else if (fu <= fv || v == x || v == w) {\r\n                    v = u;\r\n                    fv = fu;\r\n                }\r\n            }\r\n        } else {\r\n            \/\/ termination\r\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\r\n            return x;\r\n        }\r\n        ++count;\r\n    }\r\n    throw new MaxIterationsExceededException(maximalIterationCount);\r\n}","code_comment":"\/**\r\n * Find the minimum of the function within the interval {@code (lo, hi)}.\r\n *\r\n * If the function is defined on the interval {@code (lo, hi)}, then\r\n * this method finds an approximation {@code x} to the point at which\r\n * the function attains its minimum.<br\/>\r\n * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}\r\n * and the function is never evaluated at two points closer together than\r\n * {@code tol}. {@code eps} should be no smaller than <em>2 macheps<\/em> and\r\n * preferable not much less than <em>sqrt(macheps)<\/em>, where\r\n * <em>macheps<\/em> is the relative machine precision. {@code t} should be\r\n * positive.\r\n * @param isMinim {@code true} when minimizing the function.\r\n * @param lo Lower bound of the interval.\r\n * @param mid Point inside the interval {@code [lo, hi]}.\r\n * @param hi Higher bound of the interval.\r\n * @param eps Relative accuracy.\r\n * @param t Absolute accuracy.\r\n * @return the optimum point.\r\n * @throws MaxIterationsExceededException if the maximum iteration count\r\n * is exceeded.\r\n * @throws FunctionEvaluationException if an error occurs evaluating\r\n * the function.\r\n *\/\r\n","code_no_comment":"private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    if (eps <= 0) {\r\n        throw new NotStrictlyPositiveException(eps);\r\n    }\r\n    if (t <= 0) {\r\n        throw new NotStrictlyPositiveException(t);\r\n    }\r\n    double a, b;\r\n    if (lo < hi) {\r\n        a = lo;\r\n        b = hi;\r\n    } else {\r\n        a = hi;\r\n        b = lo;\r\n    }\r\n    double x = mid;\r\n    double v = x;\r\n    double w = x;\r\n    double d = 0;\r\n    double e = 0;\r\n    double fx = computeObjectiveValue(f, x);\r\n    if (goalType == GoalType.MAXIMIZE) {\r\n        fx = -fx;\r\n    }\r\n    double fv = fx;\r\n    double fw = fx;\r\n    int count = 0;\r\n    while (count < maximalIterationCount) {\r\n        double m = 0.5 * (a + b);\r\n        final double tol1 = eps * Math.abs(x) + t;\r\n        final double tol2 = 2 * tol1;\r\n                if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\r\n            double p = 0;\r\n            double q = 0;\r\n            double r = 0;\r\n            double u = 0;\r\n            if (Math.abs(e) > tol1) {\r\n                                r = (x - w) * (fx - fv);\r\n                q = (x - v) * (fx - fw);\r\n                p = (x - v) * q - (x - w) * r;\r\n                q = 2 * (q - r);\r\n                if (q > 0) {\r\n                    p = -p;\r\n                } else {\r\n                    q = -q;\r\n                }\r\n                r = e;\r\n                e = d;\r\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\r\n                                        d = p \/ q;\r\n                    u = x + d;\r\n                                        if (u - a < tol2 || b - u < tol2) {\r\n                        if (x <= m) {\r\n                            d = tol1;\r\n                        } else {\r\n                            d = -tol1;\r\n                        }\r\n                    }\r\n                } else {\r\n                                        if (x < m) {\r\n                        e = b - x;\r\n                    } else {\r\n                        e = a - x;\r\n                    }\r\n                    d = GOLDEN_SECTION * e;\r\n                }\r\n            } else {\r\n                                if (x < m) {\r\n                    e = b - x;\r\n                } else {\r\n                    e = a - x;\r\n                }\r\n                d = GOLDEN_SECTION * e;\r\n            }\r\n                        if (Math.abs(d) < tol1) {\r\n                if (d >= 0) {\r\n                    u = x + tol1;\r\n                } else {\r\n                    u = x - tol1;\r\n                }\r\n            } else {\r\n                u = x + d;\r\n            }\r\n            double fu = computeObjectiveValue(f, u);\r\n            if (goalType == GoalType.MAXIMIZE) {\r\n                fu = -fu;\r\n            }\r\n                        if (fu <= fx) {\r\n                if (u < x) {\r\n                    b = x;\r\n                } else {\r\n                    a = x;\r\n                }\r\n                v = w;\r\n                fv = fw;\r\n                w = x;\r\n                fw = fx;\r\n                x = u;\r\n                fx = fu;\r\n            } else {\r\n                if (u < x) {\r\n                    a = u;\r\n                } else {\r\n                    b = u;\r\n                }\r\n                if (fu <= fw || w == x) {\r\n                    v = w;\r\n                    fv = fw;\r\n                    w = u;\r\n                    fw = fu;\r\n                } else if (fu <= fv || v == x || v == w) {\r\n                    v = u;\r\n                    fv = fu;\r\n                }\r\n            }\r\n        } else {\r\n                        setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\r\n            return x;\r\n        }\r\n        ++count;\r\n    }\r\n    throw new MaxIterationsExceededException(maximalIterationCount);\r\n}","lc":4.9545454545,"pi":1.6267942584,"ma":4.4,"nbd":2.0,"ml":4.4166666667,"d":6.8055555556,"mi":-1.5274136716,"fo":0.25,"r":-0.0263157895,"e":39.2908582724}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3055_94c2a31f","label":0,"code":"\/**\r\n * Starts Accumulo and Zookeeper processes. Can only be called once.\r\n *\r\n * @throws IllegalStateException\r\n *           if already started\r\n *\/\r\npublic void start() throws IOException, InterruptedException {\r\n    if (zooKeeperProcess != null)\r\n        throw new IllegalStateException(\"Already started\");\r\n    Runtime.getRuntime().addShutdownHook(new Thread() {\r\n\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                MiniAccumuloCluster.this.stop();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    });\r\n    zooKeeperProcess = exec(Main.class, ZooKeeperServerMain.class.getName(), zooCfgFile.getAbsolutePath());\r\n    \/\/ sleep a little bit to let zookeeper come up before calling init, seems to work better\r\n    UtilWaitThread.sleep(250);\r\n    Process initProcess = exec(Initialize.class, \"--instance-name\", INSTANCE_NAME, \"--password\", config.getRootPassword());\r\n    int ret = initProcess.waitFor();\r\n    if (ret != 0) {\r\n        throw new RuntimeException(\"Initialize process returned \" + ret + \". Check the logs in \" + logDir + \" for errors.\");\r\n    }\r\n    tabletServerProcesses = new Process[config.getNumTservers()];\r\n    for (int i = 0; i < config.getNumTservers(); i++) {\r\n        tabletServerProcesses[i] = exec(TabletServer.class);\r\n    }\r\n    masterProcess = exec(Master.class);\r\n    gcProcess = exec(SimpleGarbageCollector.class);\r\n    if (null == executor) {\r\n        executor = Executors.newSingleThreadExecutor();\r\n    }\r\n}","code_comment":"\/**\r\n * Starts Accumulo and Zookeeper processes. Can only be called once.\r\n *\r\n * @throws IllegalStateException\r\n *           if already started\r\n *\/\r\n","code_no_comment":"public void start() throws IOException, InterruptedException {\r\n    if (zooKeeperProcess != null)\r\n        throw new IllegalStateException(\"Already started\");\r\n    Runtime.getRuntime().addShutdownHook(new Thread() {\r\n\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                MiniAccumuloCluster.this.stop();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    });\r\n    zooKeeperProcess = exec(Main.class, ZooKeeperServerMain.class.getName(), zooCfgFile.getAbsolutePath());\r\n        UtilWaitThread.sleep(250);\r\n    Process initProcess = exec(Initialize.class, \"--instance-name\", INSTANCE_NAME, \"--password\", config.getRootPassword());\r\n    int ret = initProcess.waitFor();\r\n    if (ret != 0) {\r\n        throw new RuntimeException(\"Initialize process returned \" + ret + \". Check the logs in \" + logDir + \" for errors.\");\r\n    }\r\n    tabletServerProcesses = new Process[config.getNumTservers()];\r\n    for (int i = 0; i < config.getNumTservers(); i++) {\r\n        tabletServerProcesses[i] = exec(TabletServer.class);\r\n    }\r\n    masterProcess = exec(Master.class);\r\n    gcProcess = exec(SimpleGarbageCollector.class);\r\n    if (null == executor) {\r\n        executor = Executors.newSingleThreadExecutor();\r\n    }\r\n}","lc":0.8181818182,"pi":0.6220095694,"ma":1.0,"nbd":0.0,"ml":0.3333333333,"d":0.505952381,"mi":-0.5898520085,"fo":1.0,"r":-0.0263157895,"e":0.9607095313}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-1897_8ee095bf","label":1,"code":"\/**\r\n *  @return The interface name\r\n *\/\r\npublic String getInterfaceName() {\r\n    return interfaceName;\r\n}","code_comment":"\/**\r\n *  @return The interface name\r\n *\/\r\n","code_no_comment":"public String getInterfaceName() {\r\n    return interfaceName;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1646229739,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1081_4ce4e3c9","label":3,"code":"\/\/ FIXME this should be package private. OAK-672\r\n@Nonnull\r\npublic Tree getTree() throws InvalidItemStateException {\r\n    if (!tree.exists()) {\r\n        throw new InvalidItemStateException(\"Item is stale\");\r\n    }\r\n    return tree;\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\npublic Tree getTree() throws InvalidItemStateException {\r\n    if (!tree.exists()) {\r\n        throw new InvalidItemStateException(\"Item is stale\");\r\n    }\r\n    return tree;\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.5489781536,"fo":-0.4166666667,"r":2.1578947368,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, FloatValue reusable) {\r\n    int i = startPos;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    while (i < limit) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            break;\r\n        }\r\n        i++;\r\n    }\r\n    String str = new String(bytes, startPos, i - startPos);\r\n    try {\r\n        float value = Float.parseFloat(str);\r\n        reusable.setValue(value);\r\n        this.result = reusable;\r\n        return (i == limit) ? limit : i + delimiter.length;\r\n    } catch (NumberFormatException e) {\r\n        setErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);\r\n        return -1;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, FloatValue reusable) {\r\n    int i = startPos;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    while (i < limit) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            break;\r\n        }\r\n        i++;\r\n    }\r\n    String str = new String(bytes, startPos, i - startPos);\r\n    try {\r\n        float value = Float.parseFloat(str);\r\n        reusable.setValue(value);\r\n        this.result = reusable;\r\n        return (i == limit) ? limit : i + delimiter.length;\r\n    } catch (NumberFormatException e) {\r\n        setErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);\r\n        return -1;\r\n    }\r\n}","lc":0.3181818182,"pi":0.0717703349,"ma":0.4,"nbd":0.0,"ml":0.4166666667,"d":0.8492063492,"mi":-0.3073995772,"fo":-0.1666666667,"r":0.0,"e":0.8043129729}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1432_808ac9c0","label":1,"code":"\/**\r\n * The \"and\" combination of two conditions.\r\n *\r\n * @param old the first expression (may be null)\r\n * @param add the second expression (may be null)\r\n * @return the combined expression (may be null)\r\n *\/\r\npublic static Expression and(Expression old, Expression add) {\r\n    if (old == null) {\r\n        return add;\r\n    } else if (add == null) {\r\n        return old;\r\n    }\r\n    return new Expression.Condition(old, \"and\", add, Expression.PRECEDENCE_AND);\r\n}","code_comment":"\/**\r\n * The \"and\" combination of two conditions.\r\n *\r\n * @param old the first expression (may be null)\r\n * @param add the second expression (may be null)\r\n * @return the combined expression (may be null)\r\n *\/\r\n","code_no_comment":"public static Expression and(Expression old, Expression add) {\r\n    if (old == null) {\r\n        return add;\r\n    } else if (add == null) {\r\n        return old;\r\n    }\r\n    return new Expression.Condition(old, \"and\", add, Expression.PRECEDENCE_AND);\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.3863284003,"fo":-0.5,"r":2.2368421053,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2250_08b25cb0","label":3,"code":"private Map<String, PropertyDefinition> collectPropertyDefns(NodeBuilder defn) {\r\n    Map<String, PropertyDefinition> propDefns = newHashMap();\r\n    NodeBuilder propNode = defn.getChildNode(LuceneIndexConstants.PROP_NODE);\r\n    for (String propName : Iterables.concat(includes, orderedProps)) {\r\n        NodeBuilder propDefnNode;\r\n        if (relativeProps.containsKey(propName)) {\r\n            propDefnNode = relativeProps.get(propName).getPropDefnNode(propNode);\r\n        } else {\r\n            propDefnNode = propNode.getChildNode(propName);\r\n        }\r\n        if (propDefnNode.exists()) {\r\n            propDefns.put(propName, new PropertyDefinition(this, propName, propDefnNode));\r\n        }\r\n    }\r\n    return ImmutableMap.copyOf(propDefns);\r\n}","code_comment":null,"code_no_comment":"private Map<String, PropertyDefinition> collectPropertyDefns(NodeBuilder defn) {\r\n    Map<String, PropertyDefinition> propDefns = newHashMap();\r\n    NodeBuilder propNode = defn.getChildNode(LuceneIndexConstants.PROP_NODE);\r\n    for (String propName : Iterables.concat(includes, orderedProps)) {\r\n        NodeBuilder propDefnNode;\r\n        if (relativeProps.containsKey(propName)) {\r\n            propDefnNode = relativeProps.get(propName).getPropDefnNode(propNode);\r\n        } else {\r\n            propDefnNode = propNode.getChildNode(propName);\r\n        }\r\n        if (propDefnNode.exists()) {\r\n            propDefns.put(propName, new PropertyDefinition(this, propName, propDefnNode));\r\n        }\r\n    }\r\n    return ImmutableMap.copyOf(propDefns);\r\n}","lc":0.0909090909,"pi":0.3444976077,"ma":0.0,"nbd":0.0,"ml":0.0,"d":-0.3650793651,"mi":-0.1292459479,"fo":0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"@Override\r\npublic boolean equals(Object that) {\r\n    if (that == null)\r\n        return false;\r\n    if (that instanceof update_result)\r\n        return this.equals((update_result) that);\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean equals(Object that) {\r\n    if (that == null)\r\n        return false;\r\n    if (that instanceof update_result)\r\n        return this.equals((update_result) that);\r\n    return false;\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.2,"nbd":-1.0,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.4424242424,"fo":-0.4166666667,"r":1.4473684211,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3256_44061882","label":0,"code":"public void resetForNewExecution() {\r\n    if (!(numSubtasksInFinalState == 0 || numSubtasksInFinalState == parallelism)) {\r\n        throw new IllegalStateException(\"Cannot reset vertex that is not in final state\");\r\n    }\r\n    synchronized (stateMonitor) {\r\n        \/\/ check and reset the sharing groups with scheduler hints\r\n        if (slotSharingGroup != null) {\r\n            slotSharingGroup.clearTaskAssignment();\r\n        }\r\n        if (coLocationGroup != null) {\r\n            coLocationGroup.resetConstraints();\r\n        }\r\n        \/\/ fields will be consistent to handle triggered cancel calls\r\n        for (int i = 0; i < parallelism; i++) {\r\n            taskVertices[i].resetForNewExecution();\r\n            if (finishedSubtasks[i]) {\r\n                finishedSubtasks[i] = false;\r\n                numSubtasksInFinalState--;\r\n            }\r\n        }\r\n        if (numSubtasksInFinalState != 0) {\r\n            throw new RuntimeException(\"Bug: resetting the execution job vertex failed.\");\r\n        }\r\n        \/\/ set up the input splits again\r\n        try {\r\n            if (this.inputSplits != null) {\r\n                if (inputSplitsPerSubtask == null) {\r\n                    \/\/ lazy assignment\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    InputSplitSource<InputSplit> splitSource = (InputSplitSource<InputSplit>) jobVertex.getInputSplitSource();\r\n                    this.splitAssigner = splitSource.getInputSplitAssigner(this.inputSplits);\r\n                } else {\r\n                \/\/ eager assignment\r\n                \/\/ TODO: this.splitAssigner = new AssignBasedOnPreAssignment();\r\n                }\r\n            }\r\n        } catch (Throwable t) {\r\n            throw new RuntimeException(\"Re-creating the input split assigner failed: \" + t.getMessage(), t);\r\n        }\r\n        \/\/ Reset intermediate results\r\n        for (IntermediateResult result : producedDataSets) {\r\n            result.resetForNewExecution();\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void resetForNewExecution() {\r\n    if (!(numSubtasksInFinalState == 0 || numSubtasksInFinalState == parallelism)) {\r\n        throw new IllegalStateException(\"Cannot reset vertex that is not in final state\");\r\n    }\r\n    synchronized (stateMonitor) {\r\n                if (slotSharingGroup != null) {\r\n            slotSharingGroup.clearTaskAssignment();\r\n        }\r\n        if (coLocationGroup != null) {\r\n            coLocationGroup.resetConstraints();\r\n        }\r\n                for (int i = 0; i < parallelism; i++) {\r\n            taskVertices[i].resetForNewExecution();\r\n            if (finishedSubtasks[i]) {\r\n                finishedSubtasks[i] = false;\r\n                numSubtasksInFinalState--;\r\n            }\r\n        }\r\n        if (numSubtasksInFinalState != 0) {\r\n            throw new RuntimeException(\"Bug: resetting the execution job vertex failed.\");\r\n        }\r\n                try {\r\n            if (this.inputSplits != null) {\r\n                if (inputSplitsPerSubtask == null) {\r\n                                        @SuppressWarnings(\"unchecked\")\r\n                    InputSplitSource<InputSplit> splitSource = (InputSplitSource<InputSplit>) jobVertex.getInputSplitSource();\r\n                    this.splitAssigner = splitSource.getInputSplitAssigner(this.inputSplits);\r\n                } else {\r\n                                                }\r\n            }\r\n        } catch (Throwable t) {\r\n            throw new RuntimeException(\"Re-creating the input split assigner failed: \" + t.getMessage(), t);\r\n        }\r\n                for (IntermediateResult result : producedDataSets) {\r\n            result.resetForNewExecution();\r\n        }\r\n    }\r\n}","lc":1.0909090909,"pi":0.9234449761,"ma":2.0,"nbd":1.0,"ml":0.9166666667,"d":1.0079365079,"mi":-0.6690627202,"fo":0.0833333333,"r":-0.0263157895,"e":1.2643741752}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_add180fb","label":1,"code":"@Override\r\npublic IteratorSetting getIteratorSetting(String tableName, String name, IteratorScope scope) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\r\n    int priority = -1;\r\n    String classname = null;\r\n    Map<String, String> settings = new HashMap<String, String>();\r\n    String root = String.format(\"%s%s.%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), name);\r\n    String opt = root + \".opt.\";\r\n    for (Entry<String, String> property : this.getProperties(tableName)) {\r\n        if (property.getKey().equals(root)) {\r\n            String[] parts = property.getValue().split(\",\");\r\n            if (parts.length != 2) {\r\n                throw new AccumuloException(\"Bad value for iterator setting: \" + property.getValue());\r\n            }\r\n            priority = Integer.parseInt(parts[0]);\r\n            classname = parts[1];\r\n        } else if (property.getKey().startsWith(opt)) {\r\n            settings.put(property.getKey().substring(opt.length()), property.getValue());\r\n        }\r\n    }\r\n    if (priority <= 0 || classname == null) {\r\n        return null;\r\n    }\r\n    return new IteratorSetting(priority, name, classname, EnumSet.of(scope), settings);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic IteratorSetting getIteratorSetting(String tableName, String name, IteratorScope scope) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\r\n    int priority = -1;\r\n    String classname = null;\r\n    Map<String, String> settings = new HashMap<String, String>();\r\n    String root = String.format(\"%s%s.%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), name);\r\n    String opt = root + \".opt.\";\r\n    for (Entry<String, String> property : this.getProperties(tableName)) {\r\n        if (property.getKey().equals(root)) {\r\n            String[] parts = property.getValue().split(\",\");\r\n            if (parts.length != 2) {\r\n                throw new AccumuloException(\"Bad value for iterator setting: \" + property.getValue());\r\n            }\r\n            priority = Integer.parseInt(parts[0]);\r\n            classname = parts[1];\r\n        } else if (property.getKey().startsWith(opt)) {\r\n            settings.put(property.getKey().substring(opt.length()), property.getValue());\r\n        }\r\n    }\r\n    if (priority <= 0 || classname == null) {\r\n        return null;\r\n    }\r\n    return new IteratorSetting(priority, name, classname, EnumSet.of(scope), settings);\r\n}","lc":0.4545454545,"pi":0.6842105263,"ma":0.6,"nbd":0.5,"ml":0.5833333333,"d":0.8630952381,"mi":-0.467230444,"fo":1.0,"r":-0.0263157895,"e":1.6770595253}
{"project_name":"Math","project_version":"47","label":3,"code":"\/**\r\n * Returns a {@code Complex} whose value is {@code (this \/ divisor)},\r\n * with {@code divisor} interpreted as a real number.\r\n *\r\n * @param  divisor Value by which this {@code Complex} is to be divided.\r\n * @return {@code this \/ divisor}.\r\n * @see #divide(Complex)\r\n *\/\r\npublic Complex divide(double divisor) {\r\n    if (isNaN || Double.isNaN(divisor)) {\r\n        return NaN;\r\n    }\r\n    if (divisor == 0d) {\r\n        return NaN;\r\n    }\r\n    if (Double.isInfinite(divisor)) {\r\n        return !isInfinite() ? ZERO : NaN;\r\n    }\r\n    return createComplex(real \/ divisor, imaginary \/ divisor);\r\n}","code_comment":"\/**\r\n * Returns a {@code Complex} whose value is {@code (this \/ divisor)},\r\n * with {@code divisor} interpreted as a real number.\r\n *\r\n * @param  divisor Value by which this {@code Complex} is to be divided.\r\n * @return {@code this \/ divisor}.\r\n * @see #divide(Complex)\r\n *\/\r\n","code_no_comment":"public Complex divide(double divisor) {\r\n    if (isNaN || Double.isNaN(divisor)) {\r\n        return NaN;\r\n    }\r\n    if (divisor == 0d) {\r\n        return NaN;\r\n    }\r\n    if (Double.isInfinite(divisor)) {\r\n        return !isInfinite() ? ZERO : NaN;\r\n    }\r\n    return createComplex(real \/ divisor, imaginary \/ divisor);\r\n}","lc":-0.0909090909,"pi":-0.2057416268,"ma":0.2,"nbd":-0.5,"ml":0.4166666667,"d":0.3373015873,"mi":0.1157152925,"fo":-0.1666666667,"r":0.3421052632,"e":0.0239115276}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1312_d9ab8449","label":1,"code":"\/**\r\n * Converts the current object to the relevant thrift type. The object returned from this contains a non-destroyable version of the\r\n * {@link AuthenticationToken}, so this should be used just before placing on the wire, and references to it should be tightly controlled.\r\n *\/\r\npublic TCredentials toThrift(Instance instance) {\r\n    return new TCredentials(principal, token.getClass().getName(), ByteBuffer.wrap(AuthenticationTokenSerializer.serialize(token)), instance.getInstanceID());\r\n}","code_comment":"\/**\r\n * Converts the current object to the relevant thrift type. The object returned from this contains a non-destroyable version of the\r\n * {@link AuthenticationToken}, so this should be used just before placing on the wire, and references to it should be tightly controlled.\r\n *\/\r\n","code_no_comment":"public TCredentials toThrift(Instance instance) {\r\n    return new TCredentials(principal, token.getClass().getName(), ByteBuffer.wrap(AuthenticationTokenSerializer.serialize(token)), instance.getInstanceID());\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.858210007,"fo":-0.0833333333,"r":0.1052631579,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-519_26a61077","label":1,"code":"\/**\r\n * Interpolates using the specified points to determine X at the specified\r\n * Y.\r\n *\r\n * @param points points to use for interpolation\r\n * @param startIdx index within points from which to start search for\r\n *        interpolation bounds points\r\n * @param idxStep index step for search for interpolation bounds points\r\n * @param y Y value for which X should be determined\r\n *\r\n * @return value of X at the specified Y\r\n *\r\n * @throws IllegalArgumentException if idxStep is 0\r\n * @throws OutOfRangeException if specified <code>y<\/code> is not within the\r\n *         range of the specified <code>points<\/code>\r\n *\/\r\nprivate double interpolateXAtY(WeightedObservedPoint[] points, int startIdx, int idxStep, double y) throws OutOfRangeException {\r\n    if (idxStep == 0) {\r\n        throw new ZeroException();\r\n    }\r\n    WeightedObservedPoint[] twoPoints = getInterpolationPointsForY(points, startIdx, idxStep, y);\r\n    WeightedObservedPoint pointA = twoPoints[0];\r\n    WeightedObservedPoint pointB = twoPoints[1];\r\n    if (pointA.getY() == y) {\r\n        return pointA.getX();\r\n    }\r\n    if (pointB.getY() == y) {\r\n        return pointB.getX();\r\n    }\r\n    return pointA.getX() + (((y - pointA.getY()) * (pointB.getX() - pointA.getX())) \/ (pointB.getY() - pointA.getY()));\r\n}","code_comment":"\/**\r\n * Interpolates using the specified points to determine X at the specified\r\n * Y.\r\n *\r\n * @param points points to use for interpolation\r\n * @param startIdx index within points from which to start search for\r\n *        interpolation bounds points\r\n * @param idxStep index step for search for interpolation bounds points\r\n * @param y Y value for which X should be determined\r\n *\r\n * @return value of X at the specified Y\r\n *\r\n * @throws IllegalArgumentException if idxStep is 0\r\n * @throws OutOfRangeException if specified <code>y<\/code> is not within the\r\n *         range of the specified <code>points<\/code>\r\n *\/\r\n","code_no_comment":"private double interpolateXAtY(WeightedObservedPoint[] points, int startIdx, int idxStep, double y) throws OutOfRangeException {\r\n    if (idxStep == 0) {\r\n        throw new ZeroException();\r\n    }\r\n    WeightedObservedPoint[] twoPoints = getInterpolationPointsForY(points, startIdx, idxStep, y);\r\n    WeightedObservedPoint pointA = twoPoints[0];\r\n    WeightedObservedPoint pointB = twoPoints[1];\r\n    if (pointA.getY() == y) {\r\n        return pointA.getX();\r\n    }\r\n    if (pointB.getY() == y) {\r\n        return pointB.getX();\r\n    }\r\n    return pointA.getX() + (((y - pointA.getY()) * (pointB.getX() - pointA.getX())) \/ (pointB.getY() - pointA.getY()));\r\n}","lc":0.0454545455,"pi":-0.3349282297,"ma":0.2,"nbd":-0.5,"ml":0.1666666667,"d":1.3511904762,"mi":-0.1154334038,"fo":0.4166666667,"r":-0.0263157895,"e":0.9372567325}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2434_8159fc21","label":1,"code":"@Override\r\npublic boolean visit(FullTextAnd and) {\r\n    BooleanQuery q = new BooleanQuery();\r\n    for (FullTextExpression e : and.list) {\r\n        Query x = getFullTextQuery(e, analyzer, reader);\r\n        \/\/ Lucene can't deal with \"must(must_not(x))\"\r\n        if (x instanceof BooleanQuery) {\r\n            BooleanQuery bq = (BooleanQuery) x;\r\n            for (BooleanClause c : bq.clauses()) {\r\n                q.add(c);\r\n            }\r\n        } else {\r\n            q.add(x, MUST);\r\n        }\r\n    }\r\n    result.set(q);\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean visit(FullTextAnd and) {\r\n    BooleanQuery q = new BooleanQuery();\r\n    for (FullTextExpression e : and.list) {\r\n        Query x = getFullTextQuery(e, analyzer, reader);\r\n                if (x instanceof BooleanQuery) {\r\n            BooleanQuery bq = (BooleanQuery) x;\r\n            for (BooleanClause c : bq.clauses()) {\r\n                q.add(c);\r\n            }\r\n        } else {\r\n            q.add(x, MUST);\r\n        }\r\n    }\r\n    result.set(q);\r\n    return true;\r\n}","lc":0.1363636364,"pi":0.8229665072,"ma":0.0,"nbd":0.5,"ml":-0.25,"d":-0.3650793651,"mi":-0.1151515152,"fo":-0.0833333333,"r":0.1052631579,"e":-0.1627934049}
{"project_name":"Closure","project_version":"21","label":2,"code":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    \/\/ so we'll allow it.\r\n    if (n.isEmpty() || n.isComma()) {\r\n        return;\r\n    }\r\n    if (parent == null) {\r\n        return;\r\n    }\r\n    \/\/ fix up the tree in more clever ways when these are removed.\r\n    if (n.isExprResult()) {\r\n        return;\r\n    }\r\n    \/\/ be attached to the name. This check should not complain about it.\r\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\r\n        return;\r\n    }\r\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\r\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\r\n    if (parent.getType() == Token.COMMA) {\r\n        if (isResultUsed) {\r\n            return;\r\n        }\r\n        if (n == parent.getLastChild()) {\r\n            for (Node an : parent.getAncestors()) {\r\n                int ancestorType = an.getType();\r\n                if (ancestorType == Token.COMMA)\r\n                    continue;\r\n                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\r\n                    return;\r\n                else\r\n                    break;\r\n            }\r\n        }\r\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\r\n        if (!(parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\r\n            return;\r\n        }\r\n    }\r\n    if ((isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\r\n        String msg = \"This code lacks side-effects. Is there a bug?\";\r\n        if (n.isString()) {\r\n            msg = \"Is there a missing '+' on the previous line?\";\r\n        } else if (isSimpleOp) {\r\n            msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";\r\n        }\r\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\r\n        \/\/ try to protect side-effect free statements as well.\r\n        if (!NodeUtil.isStatement(n)) {\r\n            problemNodes.add(n);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n        if (n.isEmpty() || n.isComma()) {\r\n        return;\r\n    }\r\n    if (parent == null) {\r\n        return;\r\n    }\r\n        if (n.isExprResult()) {\r\n        return;\r\n    }\r\n        if (n.isQualifiedName() && n.getJSDocInfo() != null) {\r\n        return;\r\n    }\r\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\r\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\r\n    if (parent.getType() == Token.COMMA) {\r\n        if (isResultUsed) {\r\n            return;\r\n        }\r\n        if (n == parent.getLastChild()) {\r\n            for (Node an : parent.getAncestors()) {\r\n                int ancestorType = an.getType();\r\n                if (ancestorType == Token.COMMA)\r\n                    continue;\r\n                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\r\n                    return;\r\n                else\r\n                    break;\r\n            }\r\n        }\r\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\r\n        if (!(parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\r\n            return;\r\n        }\r\n    }\r\n    if ((isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\r\n        String msg = \"This code lacks side-effects. Is there a bug?\";\r\n        if (n.isString()) {\r\n            msg = \"Is there a missing '+' on the previous line?\";\r\n        } else if (isSimpleOp) {\r\n            msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\";\r\n        }\r\n        t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\r\n                if (!NodeUtil.isStatement(n)) {\r\n            problemNodes.add(n);\r\n        }\r\n    }\r\n}","lc":1.5909090909,"pi":0.966507177,"ma":3.0,"nbd":0.5,"ml":3.0833333333,"d":0.9761904762,"mi":-0.9123326286,"fo":2.0833333333,"r":-0.0263157895,"e":2.5045740334}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1364_05c89637","label":1,"code":"\/**\r\n * Get the entry set for all resident entries.\r\n *\r\n * @return the entry set\r\n *\/\r\npublic synchronized Set<Map.Entry<K, V>> entrySet() {\r\n    HashMap<K, V> map = new HashMap<K, V>();\r\n    for (K k : keySet()) {\r\n        map.put(k, find(k).value);\r\n    }\r\n    return map.entrySet();\r\n}","code_comment":"\/**\r\n * Get the entry set for all resident entries.\r\n *\r\n * @return the entry set\r\n *\/\r\n","code_no_comment":"public synchronized Set<Map.Entry<K, V>> entrySet() {\r\n    HashMap<K, V> map = new HashMap<K, V>();\r\n    for (K k : keySet()) {\r\n        map.put(k, find(k).value);\r\n    }\r\n    return map.entrySet();\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.3987315011,"fo":-0.1666666667,"r":0.8421052632,"e":-0.1627934049}
{"project_name":"Lang","project_version":"15","label":1,"code":"\/**\r\n * <p> Checks if the subject type may be implicitly cast to the target\r\n * parameterized type following the Java generics rules. <\/p>\r\n *\r\n * @param type the subject type to be assigned to the target type\r\n * @param toParameterizedType the target parameterized type\r\n * @param typeVarAssigns a map with type variables\r\n * @return true if <code>type<\/code> is assignable to <code>toType<\/code>.\r\n *\/\r\nprivate static boolean isAssignable(Type type, ParameterizedType toParameterizedType, Map<TypeVariable<?>, Type> typeVarAssigns) {\r\n    if (type == null) {\r\n        return true;\r\n    }\r\n    \/\/ would have cause the previous to return true\r\n    if (toParameterizedType == null) {\r\n        return false;\r\n    }\r\n    \/\/ all types are assignable to themselves\r\n    if (toParameterizedType.equals(type)) {\r\n        return true;\r\n    }\r\n    \/\/ get the target type's raw type\r\n    Class<?> toClass = getRawType(toParameterizedType);\r\n    \/\/ get the subject type's type arguments including owner type arguments\r\n    \/\/ and supertype arguments up to and including the target class.\r\n    Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);\r\n    \/\/ null means the two types are not compatible\r\n    if (fromTypeVarAssigns == null) {\r\n        return false;\r\n    }\r\n    \/\/ to parameterized types.\r\n    if (fromTypeVarAssigns.isEmpty()) {\r\n        return true;\r\n    }\r\n    \/\/ get the target type's type arguments including owner type arguments\r\n    Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns);\r\n    \/\/ now to check each type argument\r\n    for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\r\n        Type toTypeArg = entry.getValue();\r\n        Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\r\n        \/\/ parameters of the target type.\r\n        if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n * <p> Checks if the subject type may be implicitly cast to the target\r\n * parameterized type following the Java generics rules. <\/p>\r\n *\r\n * @param type the subject type to be assigned to the target type\r\n * @param toParameterizedType the target parameterized type\r\n * @param typeVarAssigns a map with type variables\r\n * @return true if <code>type<\/code> is assignable to <code>toType<\/code>.\r\n *\/\r\n","code_no_comment":"private static boolean isAssignable(Type type, ParameterizedType toParameterizedType, Map<TypeVariable<?>, Type> typeVarAssigns) {\r\n    if (type == null) {\r\n        return true;\r\n    }\r\n        if (toParameterizedType == null) {\r\n        return false;\r\n    }\r\n        if (toParameterizedType.equals(type)) {\r\n        return true;\r\n    }\r\n        Class<?> toClass = getRawType(toParameterizedType);\r\n            Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);\r\n        if (fromTypeVarAssigns == null) {\r\n        return false;\r\n    }\r\n        if (fromTypeVarAssigns.isEmpty()) {\r\n        return true;\r\n    }\r\n        Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns);\r\n        for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\r\n        Type toTypeArg = entry.getValue();\r\n        Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\r\n                if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}","lc":0.6363636364,"pi":-0.1722488038,"ma":0.8,"nbd":0.0,"ml":1.1666666667,"d":0.6746031746,"mi":-0.4940098661,"fo":0.4166666667,"r":-0.0263157895,"e":0.9436328325}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3757_c1b2f2f8","label":3,"code":"public Producer createProducer() throws Exception {\r\n    producer = delegate.createProducer();\r\n    return new Producer() {\r\n\r\n        public Endpoint getEndpoint() {\r\n            return producer.getEndpoint();\r\n        }\r\n\r\n        public Exchange createExchange() {\r\n            return producer.createExchange();\r\n        }\r\n\r\n        public Exchange createExchange(ExchangePattern pattern) {\r\n            return producer.createExchange(pattern);\r\n        }\r\n\r\n        public Exchange createExchange(Exchange exchange) {\r\n            return producer.createExchange(exchange);\r\n        }\r\n\r\n        public void process(Exchange exchange) throws Exception {\r\n            \/\/ process the detour so we do the detour routing\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"Sending to endpoint: \" + getEndpointUri() + \" is intercepted and detoured to: \" + detour + \" for exchange: \" + exchange);\r\n            }\r\n            \/\/ add header with the real endpoint uri\r\n            exchange.getIn().setHeader(Exchange.INTERCEPTED_ENDPOINT, delegate.getEndpointUri());\r\n            try {\r\n                detour.process(exchange);\r\n            } catch (Exception e) {\r\n                exchange.setException(e);\r\n            }\r\n            \/\/ check for error if so we should break out\r\n            if (!continueProcessing(exchange, \"skip sending to original intended destination: \" + getEndpointUri(), LOG)) {\r\n                return;\r\n            }\r\n            if (!skip) {\r\n                if (exchange.hasOut()) {\r\n                    \/\/ replace OUT with IN as detour changed something\r\n                    exchange.setIn(exchange.getOut());\r\n                    exchange.setOut(null);\r\n                }\r\n                \/\/ route to original destination\r\n                producer.process(exchange);\r\n            } else {\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Stop() means skip sending exchange to original intended destination: \" + getEndpointUri() + \" for exchange: \" + exchange);\r\n                }\r\n            }\r\n        }\r\n\r\n        public boolean isSingleton() {\r\n            return producer.isSingleton();\r\n        }\r\n\r\n        public void start() throws Exception {\r\n            ServiceHelper.startService(detour);\r\n        }\r\n\r\n        public void stop() throws Exception {\r\n            ServiceHelper.stopService(detour);\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"public Producer createProducer() throws Exception {\r\n    producer = delegate.createProducer();\r\n    return new Producer() {\r\n\r\n        public Endpoint getEndpoint() {\r\n            return producer.getEndpoint();\r\n        }\r\n\r\n        public Exchange createExchange() {\r\n            return producer.createExchange();\r\n        }\r\n\r\n        public Exchange createExchange(ExchangePattern pattern) {\r\n            return producer.createExchange(pattern);\r\n        }\r\n\r\n        public Exchange createExchange(Exchange exchange) {\r\n            return producer.createExchange(exchange);\r\n        }\r\n\r\n        public void process(Exchange exchange) throws Exception {\r\n                        if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"Sending to endpoint: \" + getEndpointUri() + \" is intercepted and detoured to: \" + detour + \" for exchange: \" + exchange);\r\n            }\r\n                        exchange.getIn().setHeader(Exchange.INTERCEPTED_ENDPOINT, delegate.getEndpointUri());\r\n            try {\r\n                detour.process(exchange);\r\n            } catch (Exception e) {\r\n                exchange.setException(e);\r\n            }\r\n                        if (!continueProcessing(exchange, \"skip sending to original intended destination: \" + getEndpointUri(), LOG)) {\r\n                return;\r\n            }\r\n            if (!skip) {\r\n                if (exchange.hasOut()) {\r\n                                        exchange.setIn(exchange.getOut());\r\n                    exchange.setOut(null);\r\n                }\r\n                                producer.process(exchange);\r\n            } else {\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Stop() means skip sending exchange to original intended destination: \" + getEndpointUri() + \" for exchange: \" + exchange);\r\n                }\r\n            }\r\n        }\r\n\r\n        public boolean isSingleton() {\r\n            return producer.isSingleton();\r\n        }\r\n\r\n        public void start() throws Exception {\r\n            ServiceHelper.startService(detour);\r\n        }\r\n\r\n        public void stop() throws Exception {\r\n            ServiceHelper.stopService(detour);\r\n        }\r\n    };\r\n}","lc":1.6818181818,"pi":0.7081339713,"ma":0.6,"nbd":0.5,"ml":0.5,"d":0.0972222222,"mi":-0.7936575053,"fo":1.6666666667,"r":-0.0263157895,"e":0.4516219752}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"private final Component children_get(final String id) {\r\n    if (children instanceof Component) {\r\n        final Component component = (Component) children;\r\n        if (component.getId().equals(id)) {\r\n            return component;\r\n        }\r\n    } else {\r\n        if (children != null) {\r\n            final Component[] components = (Component[]) children;\r\n            for (Component element : components) {\r\n                if (element.getId().equals(id)) {\r\n                    return element;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"private final Component children_get(final String id) {\r\n    if (children instanceof Component) {\r\n        final Component component = (Component) children;\r\n        if (component.getId().equals(id)) {\r\n            return component;\r\n        }\r\n    } else {\r\n        if (children != null) {\r\n            final Component[] components = (Component[]) children;\r\n            for (Component element : components) {\r\n                if (element.getId().equals(id)) {\r\n                    return element;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}","lc":0.1818181818,"pi":1.1387559809,"ma":0.4,"nbd":1.0,"ml":0.25,"d":0.1468253968,"mi":-0.0940098661,"fo":-0.1666666667,"r":0.0526315789,"e":-0.0086190303}
{"project_name":"Closure","project_version":"110","label":2,"code":"private void findAliases(NodeTraversal t) {\r\n    Scope scope = t.getScope();\r\n    for (Var v : scope.getVarIterable()) {\r\n        Node n = v.getNode();\r\n        Node parent = n.getParent();\r\n        boolean isVar = parent.isVar();\r\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\r\n            recordAlias(v);\r\n        } else if (v.isBleedingFunction()) {\r\n        \/\/ Bleeding functions already get a BAD_PARAMETERS error, so just\r\n        \/\/ do nothing.\r\n        } else if (parent.getType() == Token.LP) {\r\n        \/\/ Parameters of the scope function also get a BAD_PARAMETERS\r\n        \/\/ error.\r\n        } else if (isVar) {\r\n            Node grandparent = parent.getParent();\r\n            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\r\n            Node varNode = parent;\r\n            String name = n.getString();\r\n            int nameCount = scopedAliasNames.count(name);\r\n            scopedAliasNames.add(name);\r\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\r\n            compiler.ensureLibraryInjected(\"base\");\r\n            \/\/ Make sure we copy over all the jsdoc and debug info.\r\n            if (value != null || v.getJSDocInfo() != null) {\r\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\r\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\r\n                grandparent.addChildBefore(newDecl, varNode);\r\n            }\r\n            \/\/ Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\r\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\r\n            recordAlias(v);\r\n        } else {\r\n            \/\/ Do not other kinds of local symbols, like catch params.\r\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void findAliases(NodeTraversal t) {\r\n    Scope scope = t.getScope();\r\n    for (Var v : scope.getVarIterable()) {\r\n        Node n = v.getNode();\r\n        Node parent = n.getParent();\r\n        boolean isVar = parent.isVar();\r\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\r\n            recordAlias(v);\r\n        } else if (v.isBleedingFunction()) {\r\n                        } else if (parent.getType() == Token.LP) {\r\n                        } else if (isVar) {\r\n            Node grandparent = parent.getParent();\r\n            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\r\n            Node varNode = parent;\r\n            String name = n.getString();\r\n            int nameCount = scopedAliasNames.count(name);\r\n            scopedAliasNames.add(name);\r\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\r\n            compiler.ensureLibraryInjected(\"base\");\r\n                        if (value != null || v.getJSDocInfo() != null) {\r\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\r\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\r\n                grandparent.addChildBefore(newDecl, varNode);\r\n            }\r\n                        v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\r\n            recordAlias(v);\r\n        } else {\r\n                        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\r\n        }\r\n    }\r\n}","lc":0.7727272727,"pi":0.5023923445,"ma":1.0,"nbd":2.0,"ml":1.1666666667,"d":0.8968253968,"mi":-0.6400281889,"fo":2.4166666667,"r":-0.0263157895,"e":2.3714320292}
{"project_name":"Closure","project_version":"122","label":2,"code":"\/**\r\n * Check to see if the given block comment looks like it should be JSDoc.\r\n *\/\r\nprivate void handleBlockComment(Comment comment) {\r\n    if (comment.getValue().indexOf(\"\/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\r\n        errorReporter.warning(SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0);\r\n    }\r\n}","code_comment":"\/**\r\n * Check to see if the given block comment looks like it should be JSDoc.\r\n *\/\r\n","code_no_comment":"private void handleBlockComment(Comment comment) {\r\n    if (comment.getValue().indexOf(\"\/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\r\n        errorReporter.warning(SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0);\r\n    }\r\n}","lc":-0.4090909091,"pi":0.0,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0912698413,"mi":0.5346018323,"fo":0.0,"r":2.3684210526,"e":-0.0900883456}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5319_c863b032","label":3,"code":"@Override\r\npublic Url mapHandler(final IRequestHandler requestHandler) {\r\n    final Url url = wrappedMapper.mapHandler(requestHandler);\r\n    if (url == null) {\r\n        return null;\r\n    }\r\n    return encryptUrl(url);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Url mapHandler(final IRequestHandler requestHandler) {\r\n    final Url url = wrappedMapper.mapHandler(requestHandler);\r\n    if (url == null) {\r\n        return null;\r\n    }\r\n    return encryptUrl(url);\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0476190476,"mi":0.4040873855,"fo":-0.3333333333,"r":1.5526315789,"e":-0.1151916461}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4138_eb0f9b41","label":1,"code":"\/**\r\n * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.\r\n *\r\n * @param tableName\r\n *          the table to compact\r\n * @param start\r\n *          first tablet to be compacted contains the row after this row, null means the first tablet in table\r\n * @param end\r\n *          last tablet to be merged contains this row, null means the last tablet in table\r\n * @param flush\r\n *          when true, table memory is flushed before compaction starts\r\n * @param wait\r\n *          when true, the call will not return until compactions are finished\r\n *\/\r\nvoid compact(String tableName, Text start, Text end, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;","code_comment":"\/**\r\n * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.\r\n *\r\n * @param tableName\r\n *          the table to compact\r\n * @param start\r\n *          first tablet to be compacted contains the row after this row, null means the first tablet in table\r\n * @param end\r\n *          last tablet to be merged contains this row, null means the last tablet in table\r\n * @param flush\r\n *          when true, table memory is flushed before compaction starts\r\n * @param wait\r\n *          when true, the call will not return until compactions are finished\r\n *\/\r\n","code_no_comment":"void compact(String tableName, Text start, Text end, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.4078928823,"fo":-0.5,"r":0.8421052632,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1045_a4ffd393","label":3,"code":"\/**\r\n * Checks whether the decomposed matrix is non-singular.\r\n *\r\n * @return true if the decomposed matrix is non-singular.\r\n *\/\r\npublic boolean isNonSingular() {\r\n    for (int i = 0; i < realEigenvalues.length; ++i) {\r\n        if (realEigenvalues[i] == 0 && imagEigenvalues[i] == 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n * Checks whether the decomposed matrix is non-singular.\r\n *\r\n * @return true if the decomposed matrix is non-singular.\r\n *\/\r\n","code_no_comment":"public boolean isNonSingular() {\r\n    for (int i = 0; i < realEigenvalues.length; ++i) {\r\n        if (realEigenvalues[i] == 0 && imagEigenvalues[i] == 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}","lc":-0.2727272727,"pi":0.4210526316,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":0.3412698413,"mi":0.3595489782,"fo":-0.5,"r":2.5,"e":-0.0254882638}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"@Override\r\npublic void write(org.apache.thrift.protocol.TProtocol prot, setTableProperty_result struct) throws org.apache.thrift.TException {\r\n    TTupleProtocol oprot = (TTupleProtocol) prot;\r\n    BitSet optionals = new BitSet();\r\n    if (struct.isSetOuch1()) {\r\n        optionals.set(0);\r\n    }\r\n    if (struct.isSetOuch2()) {\r\n        optionals.set(1);\r\n    }\r\n    oprot.writeBitSet(optionals, 2);\r\n    if (struct.isSetOuch1()) {\r\n        struct.ouch1.write(oprot);\r\n    }\r\n    if (struct.isSetOuch2()) {\r\n        struct.ouch2.write(oprot);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void write(org.apache.thrift.protocol.TProtocol prot, setTableProperty_result struct) throws org.apache.thrift.TException {\r\n    TTupleProtocol oprot = (TTupleProtocol) prot;\r\n    BitSet optionals = new BitSet();\r\n    if (struct.isSetOuch1()) {\r\n        optionals.set(0);\r\n    }\r\n    if (struct.isSetOuch2()) {\r\n        optionals.set(1);\r\n    }\r\n    oprot.writeBitSet(optionals, 2);\r\n    if (struct.isSetOuch1()) {\r\n        struct.ouch1.write(oprot);\r\n    }\r\n    if (struct.isSetOuch2()) {\r\n        struct.ouch2.write(oprot);\r\n    }\r\n}","lc":0.1818181818,"pi":-0.2440191388,"ma":0.2,"nbd":-0.5,"ml":0.0833333333,"d":-0.3650793651,"mi":-0.1749119098,"fo":0.25,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7359_9cb09d14","label":1,"code":"private Expression createSimpleExpressionBodyOrHeader(String function, boolean strict) {\r\n    \/\/ bodyAs\r\n    String remainder = ifStartsWithReturnRemainder(\"bodyAs\", function);\r\n    if (remainder != null) {\r\n        String type = ObjectHelper.between(remainder, \"(\", \")\");\r\n        remainder = ObjectHelper.after(remainder, \")\");\r\n        if (type == null || ObjectHelper.isNotEmpty(remainder)) {\r\n            throw new SimpleParserException(\"Valid syntax: ${bodyAs(type)} was: \" + function, token.getIndex());\r\n        }\r\n        type = StringHelper.removeQuotes(type);\r\n        return ExpressionBuilder.bodyExpression(type);\r\n    }\r\n    \/\/ mandatoryBodyAs\r\n    remainder = ifStartsWithReturnRemainder(\"mandatoryBodyAs\", function);\r\n    if (remainder != null) {\r\n        String type = ObjectHelper.between(remainder, \"(\", \")\");\r\n        remainder = ObjectHelper.after(remainder, \")\");\r\n        if (type == null || ObjectHelper.isNotEmpty(remainder)) {\r\n            throw new SimpleParserException(\"Valid syntax: ${mandatoryBodyAs(type)} was: \" + function, token.getIndex());\r\n        }\r\n        type = StringHelper.removeQuotes(type);\r\n        return ExpressionBuilder.mandatoryBodyExpression(type);\r\n    }\r\n    \/\/ body OGNL\r\n    remainder = ifStartsWithReturnRemainder(\"body\", function);\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"in.body\", function);\r\n    }\r\n    if (remainder != null) {\r\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\r\n        if (invalid) {\r\n            throw new SimpleParserException(\"Valid syntax: ${body.OGNL} was: \" + function, token.getIndex());\r\n        }\r\n        return ExpressionBuilder.bodyOgnlExpression(remainder);\r\n    }\r\n    \/\/ headerAs\r\n    remainder = ifStartsWithReturnRemainder(\"headerAs\", function);\r\n    if (remainder != null) {\r\n        String keyAndType = ObjectHelper.between(remainder, \"(\", \")\");\r\n        if (keyAndType == null) {\r\n            throw new SimpleParserException(\"Valid syntax: ${headerAs(key, type)} was: \" + function, token.getIndex());\r\n        }\r\n        String key = ObjectHelper.before(keyAndType, \",\");\r\n        String type = ObjectHelper.after(keyAndType, \",\");\r\n        if (ObjectHelper.isEmpty(key) || ObjectHelper.isEmpty(type)) {\r\n            throw new SimpleParserException(\"Valid syntax: ${headerAs(key, type)} was: \" + function, token.getIndex());\r\n        }\r\n        key = StringHelper.removeQuotes(key);\r\n        type = StringHelper.removeQuotes(type);\r\n        return ExpressionBuilder.headerExpression(key, type);\r\n    }\r\n    \/\/ headers function\r\n    if (\"in.headers\".equals(function) || \"headers\".equals(function)) {\r\n        return ExpressionBuilder.headersExpression();\r\n    }\r\n    \/\/ in header function\r\n    remainder = ifStartsWithReturnRemainder(\"in.headers\", function);\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"in.header\", function);\r\n    }\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"headers\", function);\r\n    }\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"header\", function);\r\n    }\r\n    if (remainder != null) {\r\n        \/\/ remove leading character (dot or ?)\r\n        if (remainder.startsWith(\".\") || remainder.startsWith(\"?\")) {\r\n            remainder = remainder.substring(1);\r\n        }\r\n        \/\/ remove starting and ending brackets\r\n        if (remainder.startsWith(\"[\") && remainder.endsWith(\"]\")) {\r\n            remainder = remainder.substring(1, remainder.length() - 1);\r\n        }\r\n        \/\/ remove quotes from key\r\n        String key = StringHelper.removeLeadingAndEndingQuotes(remainder);\r\n        \/\/ validate syntax\r\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(key);\r\n        if (invalid) {\r\n            throw new SimpleParserException(\"Valid syntax: ${header.name[key]} was: \" + function, token.getIndex());\r\n        }\r\n        if (OgnlHelper.isValidOgnlExpression(key)) {\r\n            \/\/ ognl based header\r\n            return ExpressionBuilder.headersOgnlExpression(key);\r\n        } else {\r\n            \/\/ regular header\r\n            return ExpressionBuilder.headerExpression(key);\r\n        }\r\n    }\r\n    \/\/ out header function\r\n    remainder = ifStartsWithReturnRemainder(\"out.header.\", function);\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"out.headers.\", function);\r\n    }\r\n    if (remainder != null) {\r\n        return ExpressionBuilder.outHeaderExpression(remainder);\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"private Expression createSimpleExpressionBodyOrHeader(String function, boolean strict) {\r\n        String remainder = ifStartsWithReturnRemainder(\"bodyAs\", function);\r\n    if (remainder != null) {\r\n        String type = ObjectHelper.between(remainder, \"(\", \")\");\r\n        remainder = ObjectHelper.after(remainder, \")\");\r\n        if (type == null || ObjectHelper.isNotEmpty(remainder)) {\r\n            throw new SimpleParserException(\"Valid syntax: ${bodyAs(type)} was: \" + function, token.getIndex());\r\n        }\r\n        type = StringHelper.removeQuotes(type);\r\n        return ExpressionBuilder.bodyExpression(type);\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"mandatoryBodyAs\", function);\r\n    if (remainder != null) {\r\n        String type = ObjectHelper.between(remainder, \"(\", \")\");\r\n        remainder = ObjectHelper.after(remainder, \")\");\r\n        if (type == null || ObjectHelper.isNotEmpty(remainder)) {\r\n            throw new SimpleParserException(\"Valid syntax: ${mandatoryBodyAs(type)} was: \" + function, token.getIndex());\r\n        }\r\n        type = StringHelper.removeQuotes(type);\r\n        return ExpressionBuilder.mandatoryBodyExpression(type);\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"body\", function);\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"in.body\", function);\r\n    }\r\n    if (remainder != null) {\r\n        boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);\r\n        if (invalid) {\r\n            throw new SimpleParserException(\"Valid syntax: ${body.OGNL} was: \" + function, token.getIndex());\r\n        }\r\n        return ExpressionBuilder.bodyOgnlExpression(remainder);\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"headerAs\", function);\r\n    if (remainder != null) {\r\n        String keyAndType = ObjectHelper.between(remainder, \"(\", \")\");\r\n        if (keyAndType == null) {\r\n            throw new SimpleParserException(\"Valid syntax: ${headerAs(key, type)} was: \" + function, token.getIndex());\r\n        }\r\n        String key = ObjectHelper.before(keyAndType, \",\");\r\n        String type = ObjectHelper.after(keyAndType, \",\");\r\n        if (ObjectHelper.isEmpty(key) || ObjectHelper.isEmpty(type)) {\r\n            throw new SimpleParserException(\"Valid syntax: ${headerAs(key, type)} was: \" + function, token.getIndex());\r\n        }\r\n        key = StringHelper.removeQuotes(key);\r\n        type = StringHelper.removeQuotes(type);\r\n        return ExpressionBuilder.headerExpression(key, type);\r\n    }\r\n        if (\"in.headers\".equals(function) || \"headers\".equals(function)) {\r\n        return ExpressionBuilder.headersExpression();\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"in.headers\", function);\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"in.header\", function);\r\n    }\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"headers\", function);\r\n    }\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"header\", function);\r\n    }\r\n    if (remainder != null) {\r\n                if (remainder.startsWith(\".\") || remainder.startsWith(\"?\")) {\r\n            remainder = remainder.substring(1);\r\n        }\r\n                if (remainder.startsWith(\"[\") && remainder.endsWith(\"]\")) {\r\n            remainder = remainder.substring(1, remainder.length() - 1);\r\n        }\r\n                String key = StringHelper.removeLeadingAndEndingQuotes(remainder);\r\n                boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(key);\r\n        if (invalid) {\r\n            throw new SimpleParserException(\"Valid syntax: ${header.name[key]} was: \" + function, token.getIndex());\r\n        }\r\n        if (OgnlHelper.isValidOgnlExpression(key)) {\r\n                        return ExpressionBuilder.headersOgnlExpression(key);\r\n        } else {\r\n                        return ExpressionBuilder.headerExpression(key);\r\n        }\r\n    }\r\n        remainder = ifStartsWithReturnRemainder(\"out.header.\", function);\r\n    if (remainder == null) {\r\n        remainder = ifStartsWithReturnRemainder(\"out.headers.\", function);\r\n    }\r\n    if (remainder != null) {\r\n        return ExpressionBuilder.outHeaderExpression(remainder);\r\n    }\r\n    return null;\r\n}","lc":3.3181818182,"pi":-0.1052631579,"ma":4.8,"nbd":0.0,"ml":3.1666666667,"d":1.9424603175,"mi":-1.3489781536,"fo":3.9166666667,"r":-0.0263157895,"e":9.9609873043}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-859_66dece12","label":1,"code":"\/**\r\n * Use this method to get information about whether the upper bound\r\n * of the support is inclusive or not.\r\n *\r\n * @return whether the upper bound of the support is inclusive or not\r\n *\/\r\nboolean isSupportUpperBoundInclusive();","code_comment":"\/**\r\n * Use this method to get information about whether the upper bound\r\n * of the support is inclusive or not.\r\n *\r\n * @return whether the upper bound of the support is inclusive or not\r\n *\/\r\n","code_no_comment":"boolean isSupportUpperBoundInclusive();","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.8696264975,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1300_1d635088","label":1,"code":"\/**\r\n * Generates random bytes and places them into a user-supplied\r\n * byte array.  The number of random bytes produced is equal to\r\n * the length of the byte array.\r\n * <p>\r\n * The default implementation fills the array with bytes extracted from\r\n * random integers generated using {@link #nextInt}.<\/p>\r\n *\r\n * @param bytes the non-null byte array in which to put the\r\n * random bytes\r\n *\/\r\n@Override\r\npublic void nextBytes(byte[] bytes) {\r\n    int bytesOut = 0;\r\n    while (bytesOut < bytes.length) {\r\n        int randInt = nextInt();\r\n        for (int i = 0; i < 3; i++) {\r\n            if (i > 0) {\r\n                randInt >>= 8;\r\n            }\r\n            bytes[bytesOut++] = (byte) randInt;\r\n            if (bytesOut == bytes.length) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Generates random bytes and places them into a user-supplied\r\n * byte array.  The number of random bytes produced is equal to\r\n * the length of the byte array.\r\n * <p>\r\n * The default implementation fills the array with bytes extracted from\r\n * random integers generated using {@link #nextInt}.<\/p>\r\n *\r\n * @param bytes the non-null byte array in which to put the\r\n * random bytes\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void nextBytes(byte[] bytes) {\r\n    int bytesOut = 0;\r\n    while (bytesOut < bytes.length) {\r\n        int randInt = nextInt();\r\n        for (int i = 0; i < 3; i++) {\r\n            if (i > 0) {\r\n                randInt >>= 8;\r\n            }\r\n            bytes[bytesOut++] = (byte) randInt;\r\n            if (bytesOut == bytes.length) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}","lc":0.0909090909,"pi":1.1004784689,"ma":0.2,"nbd":0.5,"ml":0.1666666667,"d":0.9246031746,"mi":-0.0596194503,"fo":-0.4166666667,"r":0.2368421053,"e":0.2995637466}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-379_621a5101","label":1,"code":"@Nonnull\r\n@Override\r\npublic LoginContextProvider getLoginContextProvider(NodeStore nodeStore) {\r\n    String appName = configuration.getConfigValue(PARAM_APP_NAME, DEFAULT_APP_NAME);\r\n    Configuration loginConfig;\r\n    try {\r\n        loginConfig = Configuration.getConfiguration();\r\n    } catch (SecurityException e) {\r\n        log.warn(\"Failed to retrieve login configuration: using default.\", e);\r\n        loginConfig = new OakConfiguration();\r\n        Configuration.setConfiguration(loginConfig);\r\n    }\r\n    return new LoginContextProviderImpl(appName, loginConfig, nodeStore, this);\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\n@Override\r\npublic LoginContextProvider getLoginContextProvider(NodeStore nodeStore) {\r\n    String appName = configuration.getConfigValue(PARAM_APP_NAME, DEFAULT_APP_NAME);\r\n    Configuration loginConfig;\r\n    try {\r\n        loginConfig = Configuration.getConfiguration();\r\n    } catch (SecurityException e) {\r\n        log.warn(\"Failed to retrieve login configuration: using default.\", e);\r\n        loginConfig = new OakConfiguration();\r\n        Configuration.setConfiguration(loginConfig);\r\n    }\r\n    return new LoginContextProviderImpl(appName, loginConfig, nodeStore, this);\r\n}","lc":0.0,"pi":0.014354067,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.0091613813,"fo":-0.1666666667,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2748_ff8c2383","label":0,"code":"@Override\r\npublic void deleteRows(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n    if (!exists(tableName))\r\n        throw new TableNotFoundException(tableName, tableName, \"\");\r\n    MockTable t = acu.tables.get(tableName);\r\n    Text startText = new Text(start);\r\n    Text endText = new Text(end);\r\n    startText.append(ZERO, 0, 1);\r\n    endText.append(ZERO, 0, 1);\r\n    Set<Key> keep = new TreeSet<Key>(t.table.subMap(new Key(startText), new Key(endText)).keySet());\r\n    t.table.keySet().removeAll(keep);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void deleteRows(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n    if (!exists(tableName))\r\n        throw new TableNotFoundException(tableName, tableName, \"\");\r\n    MockTable t = acu.tables.get(tableName);\r\n    Text startText = new Text(start);\r\n    Text endText = new Text(end);\r\n    startText.append(ZERO, 0, 1);\r\n    endText.append(ZERO, 0, 1);\r\n    Set<Key> keep = new TreeSet<Key>(t.table.subMap(new Key(startText), new Key(endText)).keySet());\r\n    t.table.keySet().removeAll(keep);\r\n}","lc":-0.0909090909,"pi":-0.3732057416,"ma":-0.2,"nbd":-1.0,"ml":-0.1666666667,"d":0.0079365079,"mi":-0.0269203665,"fo":0.1666666667,"r":-0.0263157895,"e":0.1230614962}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1822_3e83a4c1","label":1,"code":"\/**\r\n * Checks if the named key exists or is absent in the MongoDB document. This\r\n * method can be used to make a conditional update.\r\n *\r\n * @param property the property name\r\n * @param revision the revision\r\n *\/\r\nvoid containsMapEntry(@Nonnull String property, @Nonnull Revision revision, boolean exists) {\r\n    if (isNew) {\r\n        throw new IllegalStateException(\"Cannot use containsMapEntry() on new document\");\r\n    }\r\n    Operation op = new Operation();\r\n    op.type = Operation.Type.CONTAINS_MAP_ENTRY;\r\n    op.value = exists;\r\n    changes.put(new Key(property, checkNotNull(revision)), op);\r\n}","code_comment":"\/**\r\n * Checks if the named key exists or is absent in the MongoDB document. This\r\n * method can be used to make a conditional update.\r\n *\r\n * @param property the property name\r\n * @param revision the revision\r\n *\/\r\n","code_no_comment":"void containsMapEntry(@Nonnull String property, @Nonnull Revision revision, boolean exists) {\r\n    if (isNew) {\r\n        throw new IllegalStateException(\"Cannot use containsMapEntry() on new document\");\r\n    }\r\n    Operation op = new Operation();\r\n    op.type = Operation.Type.CONTAINS_MAP_ENTRY;\r\n    op.value = exists;\r\n    changes.put(new Key(property, checkNotNull(revision)), op);\r\n}","lc":-0.2272727273,"pi":-0.3444976077,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.2231148696,"fo":-0.3333333333,"r":1.6052631579,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7018_3244c1e5","label":1,"code":"public boolean isSingleton() {\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"public boolean isSingleton() {\r\n    return true;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.2407329105,"fo":-0.5,"r":1.9210526316,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5681_78c73502","label":1,"code":"protected void doProcessParallel(final Exchange original, final AtomicExchange result, final Iterable<ProcessorExchangePair> pairs, final boolean streaming, final AsyncCallback callback) throws Exception {\r\n    ObjectHelper.notNull(executorService, \"ExecutorService\", this);\r\n    ObjectHelper.notNull(aggregateExecutorService, \"AggregateExecutorService\", this);\r\n    final CompletionService<Exchange> completion;\r\n    if (streaming) {\r\n        \/\/ execute tasks in parallel+streaming and aggregate in the order they are finished (out of order sequence)\r\n        completion = new ExecutorCompletionService<Exchange>(executorService);\r\n    } else {\r\n        \/\/ execute tasks in parallel and aggregate in the order the tasks are submitted (in order sequence)\r\n        completion = new SubmitOrderedCompletionService<Exchange>(executorService);\r\n    }\r\n    final AtomicInteger total = new AtomicInteger(0);\r\n    final Iterator<ProcessorExchangePair> it = pairs.iterator();\r\n    if (it.hasNext()) {\r\n        \/\/ when parallel then aggregate on the fly\r\n        final AtomicBoolean running = new AtomicBoolean(true);\r\n        final AtomicBoolean allTasksSubmitted = new AtomicBoolean();\r\n        final CountDownLatch aggregationOnTheFlyDone = new CountDownLatch(1);\r\n        final AtomicException executionException = new AtomicException();\r\n        \/\/ issue task to execute in separate thread so it can aggregate on-the-fly\r\n        \/\/ while we submit new tasks, and those tasks complete concurrently\r\n        \/\/ this allows us to optimize work and reduce memory consumption\r\n        final AggregateOnTheFlyTask aggregateOnTheFlyTask = new AggregateOnTheFlyTask(result, original, total, completion, running, aggregationOnTheFlyDone, allTasksSubmitted, executionException);\r\n        final AtomicBoolean aggregationTaskSubmitted = new AtomicBoolean();\r\n        LOG.trace(\"Starting to submit parallel tasks\");\r\n        while (it.hasNext()) {\r\n            final ProcessorExchangePair pair = it.next();\r\n            final Exchange subExchange = pair.getExchange();\r\n            updateNewExchange(subExchange, total.intValue(), pairs, it);\r\n            completion.submit(new Callable<Exchange>() {\r\n\r\n                public Exchange call() throws Exception {\r\n                    \/\/ the aggregation task to early and pile up too many threads\r\n                    if (aggregationTaskSubmitted.compareAndSet(false, true)) {\r\n                        \/\/ but only submit the task once\r\n                        aggregateExecutorService.submit(aggregateOnTheFlyTask);\r\n                    }\r\n                    if (!running.get()) {\r\n                        \/\/ do not start processing the task if we are not running\r\n                        return subExchange;\r\n                    }\r\n                    try {\r\n                        doProcessParallel(pair);\r\n                    } catch (Throwable e) {\r\n                        subExchange.setException(e);\r\n                    }\r\n                    \/\/ Decide whether to continue with the multicast or not; similar logic to the Pipeline\r\n                    Integer number = getExchangeIndex(subExchange);\r\n                    boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Parallel processing failed for number \" + number, LOG);\r\n                    if (stopOnException && !continueProcessing) {\r\n                        \/\/ signal to stop running\r\n                        running.set(false);\r\n                        \/\/ throw caused exception\r\n                        if (subExchange.getException() != null) {\r\n                            \/\/ wrap in exception to explain where it failed\r\n                            throw new CamelExchangeException(\"Parallel processing failed for number \" + number, subExchange, subExchange.getException());\r\n                        }\r\n                    }\r\n                    LOG.trace(\"Parallel processing complete for exchange: {}\", subExchange);\r\n                    return subExchange;\r\n                }\r\n            });\r\n            total.incrementAndGet();\r\n        }\r\n        \/\/ signal all tasks has been submitted\r\n        LOG.trace(\"Signaling that all {} tasks has been submitted.\", total.get());\r\n        allTasksSubmitted.set(true);\r\n        \/\/ its to hard to do parallel async routing so we let the caller thread be synchronously\r\n        \/\/ and have it pickup the replies and do the aggregation (eg we use a latch to wait)\r\n        \/\/ wait for aggregation to be done\r\n        LOG.debug(\"Waiting for on-the-fly aggregation to complete aggregating {} responses for exchangeId: {}\", total.get(), original.getExchangeId());\r\n        aggregationOnTheFlyDone.await();\r\n        \/\/ did we fail for whatever reason, if so throw that caused exception\r\n        if (executionException.get() != null) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"Parallel processing failed due {}\", executionException.get().getMessage());\r\n            }\r\n            throw executionException.get();\r\n        }\r\n    }\r\n    \/\/ no everything is okay so we are done\r\n    LOG.debug(\"Done parallel processing {} exchanges\", total);\r\n}","code_comment":null,"code_no_comment":"protected void doProcessParallel(final Exchange original, final AtomicExchange result, final Iterable<ProcessorExchangePair> pairs, final boolean streaming, final AsyncCallback callback) throws Exception {\r\n    ObjectHelper.notNull(executorService, \"ExecutorService\", this);\r\n    ObjectHelper.notNull(aggregateExecutorService, \"AggregateExecutorService\", this);\r\n    final CompletionService<Exchange> completion;\r\n    if (streaming) {\r\n                completion = new ExecutorCompletionService<Exchange>(executorService);\r\n    } else {\r\n                completion = new SubmitOrderedCompletionService<Exchange>(executorService);\r\n    }\r\n    final AtomicInteger total = new AtomicInteger(0);\r\n    final Iterator<ProcessorExchangePair> it = pairs.iterator();\r\n    if (it.hasNext()) {\r\n                final AtomicBoolean running = new AtomicBoolean(true);\r\n        final AtomicBoolean allTasksSubmitted = new AtomicBoolean();\r\n        final CountDownLatch aggregationOnTheFlyDone = new CountDownLatch(1);\r\n        final AtomicException executionException = new AtomicException();\r\n                                final AggregateOnTheFlyTask aggregateOnTheFlyTask = new AggregateOnTheFlyTask(result, original, total, completion, running, aggregationOnTheFlyDone, allTasksSubmitted, executionException);\r\n        final AtomicBoolean aggregationTaskSubmitted = new AtomicBoolean();\r\n        LOG.trace(\"Starting to submit parallel tasks\");\r\n        while (it.hasNext()) {\r\n            final ProcessorExchangePair pair = it.next();\r\n            final Exchange subExchange = pair.getExchange();\r\n            updateNewExchange(subExchange, total.intValue(), pairs, it);\r\n            completion.submit(new Callable<Exchange>() {\r\n\r\n                public Exchange call() throws Exception {\r\n                                        if (aggregationTaskSubmitted.compareAndSet(false, true)) {\r\n                                                aggregateExecutorService.submit(aggregateOnTheFlyTask);\r\n                    }\r\n                    if (!running.get()) {\r\n                                                return subExchange;\r\n                    }\r\n                    try {\r\n                        doProcessParallel(pair);\r\n                    } catch (Throwable e) {\r\n                        subExchange.setException(e);\r\n                    }\r\n                                        Integer number = getExchangeIndex(subExchange);\r\n                    boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Parallel processing failed for number \" + number, LOG);\r\n                    if (stopOnException && !continueProcessing) {\r\n                                                running.set(false);\r\n                                                if (subExchange.getException() != null) {\r\n                                                        throw new CamelExchangeException(\"Parallel processing failed for number \" + number, subExchange, subExchange.getException());\r\n                        }\r\n                    }\r\n                    LOG.trace(\"Parallel processing complete for exchange: {}\", subExchange);\r\n                    return subExchange;\r\n                }\r\n            });\r\n            total.incrementAndGet();\r\n        }\r\n                LOG.trace(\"Signaling that all {} tasks has been submitted.\", total.get());\r\n        allTasksSubmitted.set(true);\r\n                                LOG.debug(\"Waiting for on-the-fly aggregation to complete aggregating {} responses for exchangeId: {}\", total.get(), original.getExchangeId());\r\n        aggregationOnTheFlyDone.await();\r\n                if (executionException.get() != null) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"Parallel processing failed due {}\", executionException.get().getMessage());\r\n            }\r\n            throw executionException.get();\r\n        }\r\n    }\r\n        LOG.debug(\"Done parallel processing {} exchanges\", total);\r\n}","lc":2.2272727273,"pi":2.0765550239,"ma":1.8,"nbd":1.5,"ml":1.1666666667,"d":0.5099206349,"mi":-1.0498942918,"fo":2.5833333333,"r":-0.0263157895,"e":2.486091181}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8964_ea8ee025","label":1,"code":"public synchronized void suspendRoute(String routeId) throws Exception {\r\n    if (!routeSupportsSuspension(routeId)) {\r\n        \/\/ stop if we suspend is not supported\r\n        stopRoute(routeId);\r\n        return;\r\n    }\r\n    RouteService routeService = routeServices.get(routeId);\r\n    if (routeService != null) {\r\n        List<RouteStartupOrder> routes = new ArrayList<RouteStartupOrder>(1);\r\n        RouteStartupOrder order = new DefaultRouteStartupOrder(1, routeService.getRoutes().iterator().next(), routeService);\r\n        routes.add(order);\r\n        getShutdownStrategy().suspend(this, routes);\r\n        \/\/ must suspend route service as well\r\n        suspendRouteService(routeService);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public synchronized void suspendRoute(String routeId) throws Exception {\r\n    if (!routeSupportsSuspension(routeId)) {\r\n                stopRoute(routeId);\r\n        return;\r\n    }\r\n    RouteService routeService = routeServices.get(routeId);\r\n    if (routeService != null) {\r\n        List<RouteStartupOrder> routes = new ArrayList<RouteStartupOrder>(1);\r\n        RouteStartupOrder order = new DefaultRouteStartupOrder(1, routeService.getRoutes().iterator().next(), routeService);\r\n        routes.add(order);\r\n        getShutdownStrategy().suspend(this, routes);\r\n                suspendRouteService(routeService);\r\n    }\r\n}","lc":0.0,"pi":-0.0574162679,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":-0.0674603175,"mi":-0.0334038055,"fo":0.3333333333,"r":0.0263157895,"e":-0.0149720786}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-9444_baece126","label":1,"code":"protected Processor createCompositeProcessor(RouteContext routeContext, List<Processor> list) throws Exception {\r\n    AggregationStrategy strategy = createAggregationStrategy(routeContext);\r\n    if (strategy == null) {\r\n        \/\/ default to use latest aggregation strategy\r\n        strategy = new UseLatestAggregationStrategy();\r\n    }\r\n    boolean isParallelProcessing = getParallelProcessing() != null && getParallelProcessing();\r\n    boolean isShareUnitOfWork = getShareUnitOfWork() != null && getShareUnitOfWork();\r\n    boolean isStreaming = getStreaming() != null && getStreaming();\r\n    boolean isStopOnException = getStopOnException() != null && getStopOnException();\r\n    boolean isParallelAggregate = getParallelAggregate() != null && getParallelAggregate();\r\n    boolean shutdownThreadPool = ProcessorDefinitionHelper.willCreateNewThreadPool(routeContext, this, isParallelProcessing);\r\n    ExecutorService threadPool = ProcessorDefinitionHelper.getConfiguredExecutorService(routeContext, \"Multicast\", this, isParallelProcessing);\r\n    long timeout = getTimeout() != null ? getTimeout() : 0;\r\n    if (timeout > 0 && !isParallelProcessing) {\r\n        throw new IllegalArgumentException(\"Timeout is used but ParallelProcessing has not been enabled.\");\r\n    }\r\n    if (onPrepareRef != null) {\r\n        onPrepare = CamelContextHelper.mandatoryLookup(routeContext.getCamelContext(), onPrepareRef, Processor.class);\r\n    }\r\n    MulticastProcessor answer = new MulticastProcessor(routeContext.getCamelContext(), list, strategy, isParallelProcessing, threadPool, shutdownThreadPool, isStreaming, isStopOnException, timeout, onPrepare, isShareUnitOfWork, isParallelAggregate);\r\n    return answer;\r\n}","code_comment":null,"code_no_comment":"protected Processor createCompositeProcessor(RouteContext routeContext, List<Processor> list) throws Exception {\r\n    AggregationStrategy strategy = createAggregationStrategy(routeContext);\r\n    if (strategy == null) {\r\n                strategy = new UseLatestAggregationStrategy();\r\n    }\r\n    boolean isParallelProcessing = getParallelProcessing() != null && getParallelProcessing();\r\n    boolean isShareUnitOfWork = getShareUnitOfWork() != null && getShareUnitOfWork();\r\n    boolean isStreaming = getStreaming() != null && getStreaming();\r\n    boolean isStopOnException = getStopOnException() != null && getStopOnException();\r\n    boolean isParallelAggregate = getParallelAggregate() != null && getParallelAggregate();\r\n    boolean shutdownThreadPool = ProcessorDefinitionHelper.willCreateNewThreadPool(routeContext, this, isParallelProcessing);\r\n    ExecutorService threadPool = ProcessorDefinitionHelper.getConfiguredExecutorService(routeContext, \"Multicast\", this, isParallelProcessing);\r\n    long timeout = getTimeout() != null ? getTimeout() : 0;\r\n    if (timeout > 0 && !isParallelProcessing) {\r\n        throw new IllegalArgumentException(\"Timeout is used but ParallelProcessing has not been enabled.\");\r\n    }\r\n    if (onPrepareRef != null) {\r\n        onPrepare = CamelContextHelper.mandatoryLookup(routeContext.getCamelContext(), onPrepareRef, Processor.class);\r\n    }\r\n    MulticastProcessor answer = new MulticastProcessor(routeContext.getCamelContext(), list, strategy, isParallelProcessing, threadPool, shutdownThreadPool, isStreaming, isStopOnException, timeout, onPrepare, isShareUnitOfWork, isParallelAggregate);\r\n    return answer;\r\n}","lc":0.3636363636,"pi":-0.5215311005,"ma":0.4,"nbd":-0.5,"ml":0.4166666667,"d":0.8392857143,"mi":-0.4178999295,"fo":1.0,"r":-0.0263157895,"e":1.6037412908}
{"project_name":"Math","project_version":"2","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\r\n * For population size {@code N}, number of successes {@code m}, and sample\r\n * size {@code n}, the mean is {@code n * m \/ N}.\r\n *\/\r\npublic double getNumericalMean() {\r\n    return (double) (getSampleSize() * getNumberOfSuccesses()) \/ (double) getPopulationSize();\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\r\n * For population size {@code N}, number of successes {@code m}, and sample\r\n * size {@code n}, the mean is {@code n * m \/ N}.\r\n *\/\r\n","code_no_comment":"public double getNumericalMean() {\r\n    return (double) (getSampleSize() * getNumberOfSuccesses()) \/ (double) getPopulationSize();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.1666666667,"mi":1.0329809725,"fo":-0.25,"r":2.5789473684,"e":-0.1537340871}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-813_0bea17d7","label":3,"code":"@Override\r\npublic boolean hasParents() {\r\n    return this.parents == null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean hasParents() {\r\n    return this.parents == null;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9362931642,"fo":-0.5,"r":2.1842105263,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4170_2a489d05","label":3,"code":"@Override\r\npublic void restrict(FilterImpl f) {\r\n    if (propertyName != null) {\r\n        if (f.getSelector().equals(selector)) {\r\n            String p = propertyName;\r\n            if (relativePath != null) {\r\n                p = PathUtils.concat(relativePath, p);\r\n            }\r\n            p = normalizePropertyName(p);\r\n            restrictPropertyOnFilter(p, f);\r\n        }\r\n    }\r\n    f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void restrict(FilterImpl f) {\r\n    if (propertyName != null) {\r\n        if (f.getSelector().equals(selector)) {\r\n            String p = propertyName;\r\n            if (relativePath != null) {\r\n                p = PathUtils.concat(relativePath, p);\r\n            }\r\n            p = normalizePropertyName(p);\r\n            restrictPropertyOnFilter(p, f);\r\n        }\r\n    }\r\n    f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));\r\n}","lc":0.0,"pi":1.0622009569,"ma":0.0,"nbd":0.5,"ml":0.1666666667,"d":-0.0714285714,"mi":-0.0156448203,"fo":0.1666666667,"r":0.3684210526,"e":-0.0393607764}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4113_27300d81","label":0,"code":"public String toString() {\r\n    return new String(data, offset, length, UTF_8);\r\n}","code_comment":null,"code_no_comment":"public String toString() {\r\n    return new String(data, offset, length, UTF_8);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0132487667,"fo":-0.5,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-724_9c8bb934","label":1,"code":"\/**\r\n * Generate a random int value uniformly distributed between\r\n * <code>lower<\/code> and <code>upper<\/code>, inclusive. This algorithm uses\r\n * a secure random number generator.\r\n *\r\n * @param lower\r\n *            the lower bound.\r\n * @param upper\r\n *            the upper bound.\r\n * @return the random integer.\r\n * @throws NumberIsTooLargeException if {@code lower >= upper}.\r\n *\/\r\npublic int nextSecureInt(int lower, int upper) {\r\n    if (lower >= upper) {\r\n        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false);\r\n    }\r\n    SecureRandom sec = getSecRan();\r\n    return lower + (int) (sec.nextDouble() * (upper - lower + 1));\r\n}","code_comment":"\/**\r\n * Generate a random int value uniformly distributed between\r\n * <code>lower<\/code> and <code>upper<\/code>, inclusive. This algorithm uses\r\n * a secure random number generator.\r\n *\r\n * @param lower\r\n *            the lower bound.\r\n * @param upper\r\n *            the upper bound.\r\n * @return the random integer.\r\n * @throws NumberIsTooLargeException if {@code lower >= upper}.\r\n *\/\r\n","code_no_comment":"public int nextSecureInt(int lower, int upper) {\r\n    if (lower >= upper) {\r\n        throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false);\r\n    }\r\n    SecureRandom sec = getSecRan();\r\n    return lower + (int) (sec.nextDouble() * (upper - lower + 1));\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":0.2757936508,"mi":0.3770260747,"fo":-0.3333333333,"r":0.2368421053,"e":0.0049077068}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8954_7b1253db","label":3,"code":"@Override\r\npublic boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {\r\n    if (!markerFile) {\r\n        \/\/ if not using marker file then we assume acquired\r\n        return true;\r\n    }\r\n    String lockFileName = getLockFileName(file);\r\n    LOG.trace(\"Locking the file: {} using the lock file name: {}\", file, lockFileName);\r\n    \/\/ create a plain file as marker filer for locking (do not use FileLock)\r\n    boolean acquired = FileUtil.createNewFile(new File(lockFileName));\r\n    exchange.setProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, acquired);\r\n    exchange.setProperty(Exchange.FILE_LOCK_FILE_NAME, lockFileName);\r\n    return acquired;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {\r\n    if (!markerFile) {\r\n                return true;\r\n    }\r\n    String lockFileName = getLockFileName(file);\r\n    LOG.trace(\"Locking the file: {} using the lock file name: {}\", file, lockFileName);\r\n        boolean acquired = FileUtil.createNewFile(new File(lockFileName));\r\n    exchange.setProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, acquired);\r\n    exchange.setProperty(Exchange.FILE_LOCK_FILE_NAME, lockFileName);\r\n    return acquired;\r\n}","lc":-0.0909090909,"pi":-0.3732057416,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0555555556,"mi":0.0534178999,"fo":-0.0833333333,"r":-0.0263157895,"e":-0.0191628775}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-2408_b92af0e4","label":0,"code":"protected void updateRepositoryMetadata(ArtifactRepository localRepository, ArtifactRepository remoteRepository) throws IOException, XmlPullParserException {\r\n    MetadataXpp3Reader mappingReader = new MetadataXpp3Reader();\r\n    Metadata metadata = null;\r\n    File metadataFile = new File(localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata(this, remoteRepository));\r\n    if (metadataFile.exists()) {\r\n        Reader reader = null;\r\n        try {\r\n            reader = new FileReader(metadataFile);\r\n            metadata = mappingReader.read(reader, false);\r\n        } finally {\r\n            IOUtil.close(reader);\r\n        }\r\n    }\r\n    boolean changed;\r\n    \/\/ If file could not be found or was not valid, start from scratch\r\n    if (metadata == null) {\r\n        metadata = this.metadata;\r\n        changed = true;\r\n    } else {\r\n        changed = metadata.merge(this.metadata);\r\n    }\r\n    if (changed) {\r\n        Writer writer = null;\r\n        try {\r\n            metadataFile.getParentFile().mkdirs();\r\n            writer = new FileWriter(metadataFile);\r\n            MetadataXpp3Writer mappingWriter = new MetadataXpp3Writer();\r\n            mappingWriter.write(writer, metadata);\r\n        } finally {\r\n            IOUtil.close(writer);\r\n        }\r\n    } else {\r\n        metadataFile.setLastModified(System.currentTimeMillis());\r\n    }\r\n}","code_comment":null,"code_no_comment":"protected void updateRepositoryMetadata(ArtifactRepository localRepository, ArtifactRepository remoteRepository) throws IOException, XmlPullParserException {\r\n    MetadataXpp3Reader mappingReader = new MetadataXpp3Reader();\r\n    Metadata metadata = null;\r\n    File metadataFile = new File(localRepository.getBasedir(), localRepository.pathOfLocalRepositoryMetadata(this, remoteRepository));\r\n    if (metadataFile.exists()) {\r\n        Reader reader = null;\r\n        try {\r\n            reader = new FileReader(metadataFile);\r\n            metadata = mappingReader.read(reader, false);\r\n        } finally {\r\n            IOUtil.close(reader);\r\n        }\r\n    }\r\n    boolean changed;\r\n        if (metadata == null) {\r\n        metadata = this.metadata;\r\n        changed = true;\r\n    } else {\r\n        changed = metadata.merge(this.metadata);\r\n    }\r\n    if (changed) {\r\n        Writer writer = null;\r\n        try {\r\n            metadataFile.getParentFile().mkdirs();\r\n            writer = new FileWriter(metadataFile);\r\n            MetadataXpp3Writer mappingWriter = new MetadataXpp3Writer();\r\n            mappingWriter.write(writer, metadata);\r\n        } finally {\r\n            IOUtil.close(writer);\r\n        }\r\n    } else {\r\n        metadataFile.setLastModified(System.currentTimeMillis());\r\n    }\r\n}","lc":0.9090909091,"pi":0.2488038278,"ma":0.0,"nbd":0.0,"ml":0.0833333333,"d":0.0158730159,"mi":-0.5565891473,"fo":0.5,"r":-0.0263157895,"e":0.2425661152}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7459_57ba1bde","label":3,"code":"\/**\r\n * Parses the query part of the uri (eg the parameters).\r\n * <p\/>\r\n * The URI parameters will by default be URI encoded. However you can define a parameter\r\n * values with the syntax: <tt>key=RAW(value)<\/tt> which tells Camel to not encode the value,\r\n * and use the value as is (eg key=value) and the value has <b>not<\/b> been encoded.\r\n *\r\n * @param uri the uri\r\n * @param useRaw whether to force using raw values\r\n * @return the parameters, or an empty map if no parameters (eg never null)\r\n * @throws URISyntaxException is thrown if uri has invalid syntax.\r\n * @see #RAW_TOKEN_START\r\n * @see #RAW_TOKEN_END\r\n *\/\r\npublic static Map<String, Object> parseQuery(String uri, boolean useRaw) throws URISyntaxException {\r\n    \/\/ must check for trailing & as the uri.split(\"&\") will ignore those\r\n    if (uri != null && uri.endsWith(\"&\")) {\r\n        throw new URISyntaxException(uri, \"Invalid uri syntax: Trailing & marker found. \" + \"Check the uri and remove the trailing & marker.\");\r\n    }\r\n    if (ObjectHelper.isEmpty(uri)) {\r\n        \/\/ return an empty map\r\n        return new LinkedHashMap<String, Object>(0);\r\n    }\r\n    try {\r\n        \/\/ use a linked map so the parameters is in the same order\r\n        Map<String, Object> rc = new LinkedHashMap<String, Object>();\r\n        boolean isKey = true;\r\n        boolean isValue = false;\r\n        boolean isRaw = false;\r\n        StringBuilder key = new StringBuilder();\r\n        StringBuilder value = new StringBuilder();\r\n        \/\/ parse the uri parameters char by char\r\n        for (int i = 0; i < uri.length(); i++) {\r\n            \/\/ current char\r\n            char ch = uri.charAt(i);\r\n            \/\/ look ahead of the next char\r\n            char next;\r\n            if (i < uri.length() - 2) {\r\n                next = uri.charAt(i + 1);\r\n            } else {\r\n                next = '\\u0000';\r\n            }\r\n            \/\/ are we a raw value\r\n            isRaw = value.toString().startsWith(RAW_TOKEN_START);\r\n            \/\/ if we are in raw mode, then we keep adding until we hit the end marker\r\n            if (isRaw) {\r\n                if (isKey) {\r\n                    key.append(ch);\r\n                } else if (isValue) {\r\n                    value.append(ch);\r\n                }\r\n                \/\/ we only end the raw marker if its )& or at the end of the value\r\n                boolean end = ch == RAW_TOKEN_END.charAt(0) && (next == '&' || next == '\\u0000');\r\n                if (end) {\r\n                    \/\/ raw value end, so add that as a parameter, and reset flags\r\n                    addParameter(key.toString(), value.toString(), rc, useRaw || isRaw);\r\n                    key.setLength(0);\r\n                    value.setLength(0);\r\n                    isKey = true;\r\n                    isValue = false;\r\n                    isRaw = false;\r\n                    \/\/ skip to next as we are in raw mode and have already added the value\r\n                    i++;\r\n                }\r\n                continue;\r\n            }\r\n            \/\/ if its a key and there is a = sign then the key ends and we are in value mode\r\n            if (isKey && ch == '=') {\r\n                isKey = false;\r\n                isValue = true;\r\n                isRaw = false;\r\n                continue;\r\n            }\r\n            \/\/ the & denote parameter is ended\r\n            if (ch == '&') {\r\n                \/\/ parameter is ended, as we hit & separator\r\n                addParameter(key.toString(), value.toString(), rc, useRaw || isRaw);\r\n                key.setLength(0);\r\n                value.setLength(0);\r\n                isKey = true;\r\n                isValue = false;\r\n                isRaw = false;\r\n                continue;\r\n            }\r\n            \/\/ regular char so add it to the key or value\r\n            if (isKey) {\r\n                key.append(ch);\r\n            } else if (isValue) {\r\n                value.append(ch);\r\n            }\r\n        }\r\n        \/\/ any left over parameters, then add that\r\n        if (key.length() > 0) {\r\n            addParameter(key.toString(), value.toString(), rc, useRaw || isRaw);\r\n        }\r\n        return rc;\r\n    } catch (UnsupportedEncodingException e) {\r\n        URISyntaxException se = new URISyntaxException(e.toString(), \"Invalid encoding\");\r\n        se.initCause(e);\r\n        throw se;\r\n    }\r\n}","code_comment":"\/**\r\n * Parses the query part of the uri (eg the parameters).\r\n * <p\/>\r\n * The URI parameters will by default be URI encoded. However you can define a parameter\r\n * values with the syntax: <tt>key=RAW(value)<\/tt> which tells Camel to not encode the value,\r\n * and use the value as is (eg key=value) and the value has <b>not<\/b> been encoded.\r\n *\r\n * @param uri the uri\r\n * @param useRaw whether to force using raw values\r\n * @return the parameters, or an empty map if no parameters (eg never null)\r\n * @throws URISyntaxException is thrown if uri has invalid syntax.\r\n * @see #RAW_TOKEN_START\r\n * @see #RAW_TOKEN_END\r\n *\/\r\n","code_no_comment":"public static Map<String, Object> parseQuery(String uri, boolean useRaw) throws URISyntaxException {\r\n        if (uri != null && uri.endsWith(\"&\")) {\r\n        throw new URISyntaxException(uri, \"Invalid uri syntax: Trailing & marker found. \" + \"Check the uri and remove the trailing & marker.\");\r\n    }\r\n    if (ObjectHelper.isEmpty(uri)) {\r\n                return new LinkedHashMap<String, Object>(0);\r\n    }\r\n    try {\r\n                Map<String, Object> rc = new LinkedHashMap<String, Object>();\r\n        boolean isKey = true;\r\n        boolean isValue = false;\r\n        boolean isRaw = false;\r\n        StringBuilder key = new StringBuilder();\r\n        StringBuilder value = new StringBuilder();\r\n                for (int i = 0; i < uri.length(); i++) {\r\n                        char ch = uri.charAt(i);\r\n                        char next;\r\n            if (i < uri.length() - 2) {\r\n                next = uri.charAt(i + 1);\r\n            } else {\r\n                next = '\\u0000';\r\n            }\r\n                        isRaw = value.toString().startsWith(RAW_TOKEN_START);\r\n                        if (isRaw) {\r\n                if (isKey) {\r\n                    key.append(ch);\r\n                } else if (isValue) {\r\n                    value.append(ch);\r\n                }\r\n                                boolean end = ch == RAW_TOKEN_END.charAt(0) && (next == '&' || next == '\\u0000');\r\n                if (end) {\r\n                                        addParameter(key.toString(), value.toString(), rc, useRaw || isRaw);\r\n                    key.setLength(0);\r\n                    value.setLength(0);\r\n                    isKey = true;\r\n                    isValue = false;\r\n                    isRaw = false;\r\n                                        i++;\r\n                }\r\n                continue;\r\n            }\r\n                        if (isKey && ch == '=') {\r\n                isKey = false;\r\n                isValue = true;\r\n                isRaw = false;\r\n                continue;\r\n            }\r\n                        if (ch == '&') {\r\n                                addParameter(key.toString(), value.toString(), rc, useRaw || isRaw);\r\n                key.setLength(0);\r\n                value.setLength(0);\r\n                isKey = true;\r\n                isValue = false;\r\n                isRaw = false;\r\n                continue;\r\n            }\r\n                        if (isKey) {\r\n                key.append(ch);\r\n            } else if (isValue) {\r\n                value.append(ch);\r\n            }\r\n        }\r\n                if (key.length() > 0) {\r\n            addParameter(key.toString(), value.toString(), rc, useRaw || isRaw);\r\n        }\r\n        return rc;\r\n    } catch (UnsupportedEncodingException e) {\r\n        URISyntaxException se = new URISyntaxException(e.toString(), \"Invalid encoding\");\r\n        se.initCause(e);\r\n        throw se;\r\n    }\r\n}","lc":2.6363636364,"pi":1.038277512,"ma":3.2,"nbd":1.5,"ml":1.75,"d":3.2301587302,"mi":-1.1527836505,"fo":1.9166666667,"r":-0.0263157895,"e":10.4595079615}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-43_668f08f2","label":1,"code":"public void dispose() {\r\n    gate.commit(\"end\");\r\n    if (rep != null) {\r\n        try {\r\n            rep.shutDown();\r\n        } catch (Exception ignore) {\r\n        \/\/ fail silently\r\n        }\r\n        rep = null;\r\n    }\r\n    diffCache.clear();\r\n}","code_comment":null,"code_no_comment":"public void dispose() {\r\n    gate.commit(\"end\");\r\n    if (rep != null) {\r\n        try {\r\n            rep.shutDown();\r\n        } catch (Exception ignore) {\r\n                }\r\n        rep = null;\r\n    }\r\n    diffCache.clear();\r\n}","lc":-0.1363636364,"pi":0.2583732057,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.1170634921,"mi":0.2518675123,"fo":-0.25,"r":2.1052631579,"e":-0.1254911453}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6687_617eab1c","label":1,"code":"\/**\r\n * Evaluate using parameter values where the values can be provided in the method name syntax.\r\n * <p\/>\r\n * This methods returns accordingly:\r\n * <ul>\r\n *     <li><tt>null<\/tt> - if not a parameter value<\/li>\r\n *     <li><tt>Void.TYPE<\/tt> - if an explicit null, forcing Camel to pass in <tt>null<\/tt> for that given parameter<\/li>\r\n *     <li>a non <tt>null<\/tt> value - if the parameter was a parameter value, and to be used<\/li>\r\n * <\/ul>\r\n *\r\n * @since 2.9\r\n *\/\r\nprivate Object evaluateParameterValue(Exchange exchange, int index, Object parameterValue, Class<?> parameterType) {\r\n    Object answer = null;\r\n    \/\/ convert the parameter value to a String\r\n    String exp = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, parameterValue);\r\n    if (exp != null) {\r\n        \/\/ check if its a valid parameter value\r\n        boolean valid = BeanHelper.isValidParameterValue(exp);\r\n        if (!valid) {\r\n            \/\/ it may be a parameter type instead, and if so, then we should return null,\r\n            \/\/ as this method is only for evaluating parameter values\r\n            Boolean isClass = BeanHelper.isAssignableToExpectedType(exchange.getContext().getClassResolver(), exp, parameterType);\r\n            \/\/ the method will return a non null value if exp is a class\r\n            if (isClass != null) {\r\n                return null;\r\n            }\r\n        }\r\n        \/\/ use simple language to evaluate the expression, as it may use the simple language to refer to message body, headers etc.\r\n        Expression expression = null;\r\n        try {\r\n            expression = exchange.getContext().resolveLanguage(\"simple\").createExpression(exp);\r\n            parameterValue = expression.evaluate(exchange, Object.class);\r\n        } catch (Exception e) {\r\n            throw new ExpressionEvaluationException(expression, \"Cannot create\/evaluate simple expression: \" + exp + \" to be bound to parameter at index: \" + index + \" on method: \" + getMethod(), exchange, e);\r\n        }\r\n        if (parameterValue != null) {\r\n            \/\/ see method javadoc for details\r\n            if (\"null\".equals(parameterValue)) {\r\n                return Void.TYPE;\r\n            }\r\n            \/\/ the parameter value was not already valid, but since the simple language have evaluated the expression\r\n            \/\/ which may change the parameterValue, so we have to check it again to see if its now valid\r\n            exp = exchange.getContext().getTypeConverter().convertTo(String.class, parameterValue);\r\n            \/\/ String values from the simple language is always valid\r\n            if (!valid) {\r\n                \/\/ re validate if the parameter was not valid the first time (String values should be accepted)\r\n                valid = parameterValue instanceof String || BeanHelper.isValidParameterValue(exp);\r\n            }\r\n            if (valid) {\r\n                \/\/ we need to unquote String parameters, as the enclosing quotes is there to denote a parameter value\r\n                if (parameterValue instanceof String) {\r\n                    parameterValue = StringHelper.removeLeadingAndEndingQuotes((String) parameterValue);\r\n                }\r\n                if (parameterValue != null) {\r\n                    try {\r\n                        \/\/ its a valid parameter value, so convert it to the expected type of the parameter\r\n                        answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, exchange, parameterValue);\r\n                        if (LOG.isTraceEnabled()) {\r\n                            LOG.trace(\"Parameter #{} evaluated as: {} type: \", new Object[] { index, answer, ObjectHelper.type(answer) });\r\n                        }\r\n                    } catch (Exception e) {\r\n                        if (LOG.isDebugEnabled()) {\r\n                            LOG.debug(\"Cannot convert from type: {} to type: {} for parameter #{}\", new Object[] { ObjectHelper.type(parameterValue), parameterType, index });\r\n                        }\r\n                        throw new ParameterBindingException(e, method, index, parameterType, parameterValue);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return answer;\r\n}","code_comment":"\/**\r\n * Evaluate using parameter values where the values can be provided in the method name syntax.\r\n * <p\/>\r\n * This methods returns accordingly:\r\n * <ul>\r\n *     <li><tt>null<\/tt> - if not a parameter value<\/li>\r\n *     <li><tt>Void.TYPE<\/tt> - if an explicit null, forcing Camel to pass in <tt>null<\/tt> for that given parameter<\/li>\r\n *     <li>a non <tt>null<\/tt> value - if the parameter was a parameter value, and to be used<\/li>\r\n * <\/ul>\r\n *\r\n * @since 2.9\r\n *\/\r\n","code_no_comment":"private Object evaluateParameterValue(Exchange exchange, int index, Object parameterValue, Class<?> parameterType) {\r\n    Object answer = null;\r\n        String exp = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, parameterValue);\r\n    if (exp != null) {\r\n                boolean valid = BeanHelper.isValidParameterValue(exp);\r\n        if (!valid) {\r\n                                    Boolean isClass = BeanHelper.isAssignableToExpectedType(exchange.getContext().getClassResolver(), exp, parameterType);\r\n                        if (isClass != null) {\r\n                return null;\r\n            }\r\n        }\r\n                Expression expression = null;\r\n        try {\r\n            expression = exchange.getContext().resolveLanguage(\"simple\").createExpression(exp);\r\n            parameterValue = expression.evaluate(exchange, Object.class);\r\n        } catch (Exception e) {\r\n            throw new ExpressionEvaluationException(expression, \"Cannot create\/evaluate simple expression: \" + exp + \" to be bound to parameter at index: \" + index + \" on method: \" + getMethod(), exchange, e);\r\n        }\r\n        if (parameterValue != null) {\r\n                        if (\"null\".equals(parameterValue)) {\r\n                return Void.TYPE;\r\n            }\r\n                                    exp = exchange.getContext().getTypeConverter().convertTo(String.class, parameterValue);\r\n                        if (!valid) {\r\n                                valid = parameterValue instanceof String || BeanHelper.isValidParameterValue(exp);\r\n            }\r\n            if (valid) {\r\n                                if (parameterValue instanceof String) {\r\n                    parameterValue = StringHelper.removeLeadingAndEndingQuotes((String) parameterValue);\r\n                }\r\n                if (parameterValue != null) {\r\n                    try {\r\n                                                answer = exchange.getContext().getTypeConverter().mandatoryConvertTo(parameterType, exchange, parameterValue);\r\n                        if (LOG.isTraceEnabled()) {\r\n                            LOG.trace(\"Parameter #{} evaluated as: {} type: \", new Object[] { index, answer, ObjectHelper.type(answer) });\r\n                        }\r\n                    } catch (Exception e) {\r\n                        if (LOG.isDebugEnabled()) {\r\n                            LOG.debug(\"Cannot convert from type: {} to type: {} for parameter #{}\", new Object[] { ObjectHelper.type(parameterValue), parameterType, index });\r\n                        }\r\n                        throw new ParameterBindingException(e, method, index, parameterType, parameterValue);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return answer;\r\n}","lc":1.5454545455,"pi":1.961722488,"ma":2.4,"nbd":2.0,"ml":1.0833333333,"d":0.6686507937,"mi":-0.8942917548,"fo":1.75,"r":-0.0263157895,"e":2.0452827579}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7241_18c23fa8","label":1,"code":"@Converter\r\npublic static String toString(ByteBuffer buffer, Exchange exchange) throws IOException {\r\n    return IOConverter.toString(buffer.array(), exchange);\r\n}","code_comment":null,"code_no_comment":"@Converter\r\npublic static String toString(ByteBuffer buffer, Exchange exchange) throws IOException {\r\n    return IOConverter.toString(buffer.array(), exchange);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.769415081,"fo":-0.3333333333,"r":0.2105263158,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-373_bfe4623c","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic void increment(final double d) {\r\n    if (n == 0) {\r\n        value = d;\r\n    } else {\r\n        value += d;\r\n    }\r\n    n++;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void increment(final double d) {\r\n    if (n == 0) {\r\n        value = d;\r\n    } else {\r\n        value += d;\r\n    }\r\n    n++;\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.2579365079,"mi":0.3823819591,"fo":-0.5,"r":2.5789473684,"e":-0.0876033725}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-579_7d72e6ed","label":3,"code":"@Override\r\npublic void prepare() {\r\n    if (queryConstraint != null) {\r\n        queryConstraint.restrictPushDown(this);\r\n    }\r\n    if (!outerJoinLeftHandSide && !outerJoinRightHandSide) {\r\n        for (JoinConditionImpl c : allJoinConditions) {\r\n            c.restrictPushDown(this);\r\n        }\r\n    }\r\n    index = query.getBestIndex(createFilter());\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void prepare() {\r\n    if (queryConstraint != null) {\r\n        queryConstraint.restrictPushDown(this);\r\n    }\r\n    if (!outerJoinLeftHandSide && !outerJoinRightHandSide) {\r\n        for (JoinConditionImpl c : allJoinConditions) {\r\n            c.restrictPushDown(this);\r\n        }\r\n    }\r\n    index = query.getBestIndex(createFilter());\r\n}","lc":-0.0909090909,"pi":0.2870813397,"ma":0.0,"nbd":0.0,"ml":0.0833333333,"d":0.1111111111,"mi":0.1453136011,"fo":-0.1666666667,"r":0.7105263158,"e":-0.054685546}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1215_a9efe3c4","label":0,"code":"\/**\r\n * Normalize the property name (including namespace remapping).\r\n *\r\n * @param propertyName the property name to normalize\r\n * @return the normalized property name\r\n *\/\r\nprotected String normalizePropertyName(String propertyName) {\r\n    \/\/ where possible)\r\n    if (query == null) {\r\n        return propertyName;\r\n    }\r\n    if (propertyName == null) {\r\n        return null;\r\n    }\r\n    int slash = propertyName.indexOf('\/');\r\n    if (slash < 0) {\r\n        return normalizeNonRelativePropertyName(propertyName);\r\n    }\r\n    \/\/ relative properties\r\n    String relativePath = PathUtils.getParentPath(propertyName);\r\n    relativePath = query.getOakPath(relativePath);\r\n    propertyName = PathUtils.getName(propertyName);\r\n    propertyName = normalizeNonRelativePropertyName(propertyName);\r\n    return PathUtils.concat(relativePath, propertyName);\r\n}","code_comment":"\/**\r\n * Normalize the property name (including namespace remapping).\r\n *\r\n * @param propertyName the property name to normalize\r\n * @return the normalized property name\r\n *\/\r\n","code_no_comment":"protected String normalizePropertyName(String propertyName) {\r\n        if (query == null) {\r\n        return propertyName;\r\n    }\r\n    if (propertyName == null) {\r\n        return null;\r\n    }\r\n    int slash = propertyName.indexOf('\/');\r\n    if (slash < 0) {\r\n        return normalizeNonRelativePropertyName(propertyName);\r\n    }\r\n        String relativePath = PathUtils.getParentPath(propertyName);\r\n    relativePath = query.getOakPath(relativePath);\r\n    propertyName = PathUtils.getName(propertyName);\r\n    propertyName = normalizeNonRelativePropertyName(propertyName);\r\n    return PathUtils.concat(relativePath, propertyName);\r\n}","lc":0.1363636364,"pi":-0.3971291866,"ma":0.0,"nbd":-0.5,"ml":0.0833333333,"d":0.0892857143,"mi":-0.1210711769,"fo":0.0833333333,"r":0.0,"e":0.052053042}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5578_5cdc1c8d","label":1,"code":"@Override\r\npublic boolean canCallListenerInterfaceAfterExpiry() {\r\n    return getApplication().getPageSettings().getCallListenerInterfaceAfterExpiry();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean canCallListenerInterfaceAfterExpiry() {\r\n    return getApplication().getPageSettings().getCallListenerInterfaceAfterExpiry();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9362931642,"fo":-0.25,"r":0.2368421053,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2713_63d9800e","label":1,"code":"@SuppressWarnings(\"unchecked\")\r\npublic void restoreState(StateHandle<Serializable> snapshot, ClassLoader userCodeClassLoader) throws Exception {\r\n    update(checkpointer.restoreState((C) snapshot.getState(userCodeClassLoader)));\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings(\"unchecked\")\r\npublic void restoreState(StateHandle<Serializable> snapshot, ClassLoader userCodeClassLoader) throws Exception {\r\n    update(checkpointer.restoreState((C) snapshot.getState(userCodeClassLoader)));\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7268498943,"fo":-0.25,"r":0.6315789474,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2147_a1556c30","label":1,"code":"\/**\r\n * set the value of the :next at the given position. If the property :next won't be there by the\r\n * time this method is invoked it won't perform any action\r\n *\r\n * @param node\r\n * @param value\r\n * @param lane\r\n *\/\r\nstatic void setPropertyNext(@Nonnull final NodeBuilder node, final String value, final int lane) {\r\n    if (node != null && value != null && lane >= 0 && lane < OrderedIndex.LANES) {\r\n        PropertyState next = node.getProperty(NEXT);\r\n        if (next != null) {\r\n            String[] values;\r\n            if (next.isArray()) {\r\n                values = Iterables.toArray(next.getValue(Type.STRINGS), String.class);\r\n                if (values.length < OrderedIndex.LANES) {\r\n                    \/\/ it could be we increased the number of lanes and running on some existing\r\n                    \/\/ content\r\n                    LOG.debug(\"topping-up the number of lanes.\");\r\n                    List<String> vv = Lists.newArrayList(values);\r\n                    for (int i = vv.size(); i <= OrderedIndex.LANES; i++) {\r\n                        vv.add(\"\");\r\n                    }\r\n                    values = vv.toArray(new String[vv.size()]);\r\n                }\r\n            } else {\r\n                values = Iterables.toArray(EMPTY_NEXT, String.class);\r\n                values[0] = next.getValue(Type.STRING);\r\n            }\r\n            values[lane] = value;\r\n            setPropertyNext(node, values);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * set the value of the :next at the given position. If the property :next won't be there by the\r\n * time this method is invoked it won't perform any action\r\n *\r\n * @param node\r\n * @param value\r\n * @param lane\r\n *\/\r\n","code_no_comment":"static void setPropertyNext(@Nonnull final NodeBuilder node, final String value, final int lane) {\r\n    if (node != null && value != null && lane >= 0 && lane < OrderedIndex.LANES) {\r\n        PropertyState next = node.getProperty(NEXT);\r\n        if (next != null) {\r\n            String[] values;\r\n            if (next.isArray()) {\r\n                values = Iterables.toArray(next.getValue(Type.STRINGS), String.class);\r\n                if (values.length < OrderedIndex.LANES) {\r\n                                                            LOG.debug(\"topping-up the number of lanes.\");\r\n                    List<String> vv = Lists.newArrayList(values);\r\n                    for (int i = vv.size(); i <= OrderedIndex.LANES; i++) {\r\n                        vv.add(\"\");\r\n                    }\r\n                    values = vv.toArray(new String[vv.size()]);\r\n                }\r\n            } else {\r\n                values = Iterables.toArray(EMPTY_NEXT, String.class);\r\n                values[0] = next.getValue(Type.STRING);\r\n            }\r\n            values[lane] = value;\r\n            setPropertyNext(node, values);\r\n        }\r\n    }\r\n}","lc":0.4545454545,"pi":1.6459330144,"ma":0.4,"nbd":1.5,"ml":0.8333333333,"d":0.9543650794,"mi":-0.437914024,"fo":0.5833333333,"r":-0.0263157895,"e":1.527394063}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-1677_01a3dd66","label":1,"code":"\/**\r\n *  @see org.apache.wicket.Component#onComponentTagBody(MarkupStream, ComponentTag)\r\n *\/\r\n@Override\r\nprotected final void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag) {\r\n    \/\/ Iterate through choices\r\n    final List<? extends T> choices = getChoices();\r\n    \/\/ Buffer to hold generated body\r\n    final AppendingStringBuffer buffer = new AppendingStringBuffer((choices.size() + 1) * 70);\r\n    \/\/ The selected value\r\n    final String selected = getValue();\r\n    \/\/ Loop through choices\r\n    for (int index = 0; index < choices.size(); index++) {\r\n        \/\/ Get next choice\r\n        final T choice = choices.get(index);\r\n        Object displayValue = getChoiceRenderer().getDisplayValue(choice);\r\n        Class<?> objectClass = (displayValue == null ? null : displayValue.getClass());\r\n        \/\/ Get label for choice\r\n        String label = \"\";\r\n        if (objectClass != null && objectClass != String.class) {\r\n            final IConverter converter = getConverter(objectClass);\r\n            label = converter.convertToString(displayValue, getLocale());\r\n        } else if (displayValue != null) {\r\n            label = displayValue.toString();\r\n        }\r\n        \/\/ location in the page markup!\r\n        if (label != null) {\r\n            \/\/ Append option suffix\r\n            buffer.append(getPrefix());\r\n            String id = getChoiceRenderer().getIdValue(choice, index);\r\n            final String idAttr = getMarkupId() + \"_\" + id;\r\n            boolean enabled = isEnabledInHierarchy() && !isDisabled(choice, index, selected);\r\n            \/\/ Add radio tag\r\n            buffer.append(\"<input name=\\\"\").append(getInputName()).append(\"\\\"\").append(\" type=\\\"radio\\\"\").append((isSelected(choice, index, selected) ? \" checked=\\\"checked\\\"\" : \"\")).append((enabled ? \"\" : \" disabled=\\\"disabled\\\"\")).append(\" value=\\\"\").append(id).append(\"\\\" id=\\\"\").append(idAttr).append(\"\\\"\");\r\n            \/\/ when the option is clicked?\r\n            if (wantOnSelectionChangedNotifications()) {\r\n                CharSequence url = urlFor(IOnChangeListener.INTERFACE);\r\n                Form<?> form = findParent(Form.class);\r\n                if (form != null) {\r\n                    RequestContext rc = RequestContext.get();\r\n                    if (rc.isPortletRequest()) {\r\n                        \/\/ restore url back to real wicket path as its going to be interpreted\r\n                        \/\/ by the form itself\r\n                        url = ((PortletRequestContext) rc).getLastEncodedPath();\r\n                    }\r\n                    buffer.append(\" onclick=\\\"\").append(form.getJsForInterfaceUrl(url)).append(\";\\\"\");\r\n                } else {\r\n                    \/\/ TODO: following doesn't work with portlets, should be posted to a dynamic\r\n                    \/\/ hidden form\r\n                    \/\/ with an ActionURL or something\r\n                    \/\/ NOTE: do not encode the url as that would give\r\n                    \/\/ invalid JavaScript\r\n                    buffer.append(\" onclick=\\\"window.location.href='\").append(url).append((url.toString().indexOf('?') > -1 ? \"&amp;\" : \"?\") + getInputName()).append(\"=\").append(id).append(\"';\\\"\");\r\n                }\r\n            }\r\n            buffer.append(\"\/>\");\r\n            \/\/ Add label for radio button\r\n            String display = label;\r\n            if (localizeDisplayValues()) {\r\n                display = getLocalizer().getString(label, this, label);\r\n            }\r\n            final CharSequence escaped;\r\n            if (getEscapeModelStrings()) {\r\n                escaped = Strings.escapeMarkup(display, false, true);\r\n            } else {\r\n                escaped = display;\r\n            }\r\n            buffer.append(\"<label for=\\\"\").append(idAttr).append(\"\\\">\").append(escaped).append(\"<\/label>\");\r\n            \/\/ Append option suffix\r\n            buffer.append(getSuffix());\r\n        }\r\n    }\r\n    \/\/ Replace body\r\n    replaceComponentTagBody(markupStream, openTag, buffer);\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.Component#onComponentTagBody(MarkupStream, ComponentTag)\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected final void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag) {\r\n        final List<? extends T> choices = getChoices();\r\n        final AppendingStringBuffer buffer = new AppendingStringBuffer((choices.size() + 1) * 70);\r\n        final String selected = getValue();\r\n        for (int index = 0; index < choices.size(); index++) {\r\n                final T choice = choices.get(index);\r\n        Object displayValue = getChoiceRenderer().getDisplayValue(choice);\r\n        Class<?> objectClass = (displayValue == null ? null : displayValue.getClass());\r\n                String label = \"\";\r\n        if (objectClass != null && objectClass != String.class) {\r\n            final IConverter converter = getConverter(objectClass);\r\n            label = converter.convertToString(displayValue, getLocale());\r\n        } else if (displayValue != null) {\r\n            label = displayValue.toString();\r\n        }\r\n                if (label != null) {\r\n                        buffer.append(getPrefix());\r\n            String id = getChoiceRenderer().getIdValue(choice, index);\r\n            final String idAttr = getMarkupId() + \"_\" + id;\r\n            boolean enabled = isEnabledInHierarchy() && !isDisabled(choice, index, selected);\r\n                        buffer.append(\"<input name=\\\"\").append(getInputName()).append(\"\\\"\").append(\" type=\\\"radio\\\"\").append((isSelected(choice, index, selected) ? \" checked=\\\"checked\\\"\" : \"\")).append((enabled ? \"\" : \" disabled=\\\"disabled\\\"\")).append(\" value=\\\"\").append(id).append(\"\\\" id=\\\"\").append(idAttr).append(\"\\\"\");\r\n                        if (wantOnSelectionChangedNotifications()) {\r\n                CharSequence url = urlFor(IOnChangeListener.INTERFACE);\r\n                Form<?> form = findParent(Form.class);\r\n                if (form != null) {\r\n                    RequestContext rc = RequestContext.get();\r\n                    if (rc.isPortletRequest()) {\r\n                                                                        url = ((PortletRequestContext) rc).getLastEncodedPath();\r\n                    }\r\n                    buffer.append(\" onclick=\\\"\").append(form.getJsForInterfaceUrl(url)).append(\";\\\"\");\r\n                } else {\r\n                                                                                                                        buffer.append(\" onclick=\\\"window.location.href='\").append(url).append((url.toString().indexOf('?') > -1 ? \"&amp;\" : \"?\") + getInputName()).append(\"=\").append(id).append(\"';\\\"\");\r\n                }\r\n            }\r\n            buffer.append(\"\/>\");\r\n                        String display = label;\r\n            if (localizeDisplayValues()) {\r\n                display = getLocalizer().getString(label, this, label);\r\n            }\r\n            final CharSequence escaped;\r\n            if (getEscapeModelStrings()) {\r\n                escaped = Strings.escapeMarkup(display, false, true);\r\n            } else {\r\n                escaped = display;\r\n            }\r\n            buffer.append(\"<label for=\\\"\").append(idAttr).append(\"\\\">\").append(escaped).append(\"<\/label>\");\r\n                        buffer.append(getSuffix());\r\n        }\r\n    }\r\n        replaceComponentTagBody(markupStream, openTag, buffer);\r\n}","lc":1.7272727273,"pi":1.1626794258,"ma":2.0,"nbd":1.5,"ml":2.0,"d":1.7718253968,"mi":-1.0056377731,"fo":4.9166666667,"r":-0.0263157895,"e":8.157666707}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1822_016df669","label":1,"code":"public static void setModified(@Nonnull UpdateOp op, @Nonnull Revision revision) {\r\n    checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\r\n}","code_comment":null,"code_no_comment":"public static void setModified(@Nonnull UpdateOp op, @Nonnull Revision revision) {\r\n    checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8759689922,"fo":-0.0833333333,"r":0.1315789474,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3511_4a875f46","label":1,"code":"\/**\r\n *  {@inheritDoc}\r\n *\r\n *  Checks for {@link IResourceStreamReference} in the cache and returns <code>null<\/code> if the\r\n *  result is {@link NullResourceStreamReference#INSTANCE}, or {@link FileResourceStream} \/\r\n *  {@link UrlResourceStream} if there is an entry in the cache. Otherwise asks the delegate to\r\n *  find one and puts it in the cache.\r\n *\/\r\npublic IResourceStream locate(Class<?> clazz, String path) {\r\n    Key key = new Key(clazz.getName(), path, null, null, null);\r\n    IResourceStream resourceStream = getCopyFromCache(key);\r\n    if (resourceStream == null) {\r\n        resourceStream = delegate.locate(clazz, path);\r\n        updateCache(key, resourceStream);\r\n    }\r\n    return resourceStream;\r\n}","code_comment":"\/**\r\n *  {@inheritDoc}\r\n *\r\n *  Checks for {@link IResourceStreamReference} in the cache and returns <code>null<\/code> if the\r\n *  result is {@link NullResourceStreamReference#INSTANCE}, or {@link FileResourceStream} \/\r\n *  {@link UrlResourceStream} if there is an entry in the cache. Otherwise asks the delegate to\r\n *  find one and puts it in the cache.\r\n *\/\r\n","code_no_comment":"public IResourceStream locate(Class<?> clazz, String path) {\r\n    Key key = new Key(clazz.getName(), path, null, null, null);\r\n    IResourceStream resourceStream = getCopyFromCache(key);\r\n    if (resourceStream == null) {\r\n        resourceStream = delegate.locate(clazz, path);\r\n        updateCache(key, resourceStream);\r\n    }\r\n    return resourceStream;\r\n}","lc":-0.2272727273,"pi":-0.1531100478,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.0456349206,"mi":0.2338266385,"fo":-0.1666666667,"r":0.1578947368,"e":-0.0264840972}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_46f62443","label":1,"code":"\/**\r\n * @deprecated since 1.4 {@link #attachIterator(String, IteratorSetting)}\r\n *\/\r\n@Override\r\npublic void addAggregators(String tableName, List<? extends PerColumnIteratorConfig> aggregators) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {\r\n    acu.addAggregators(tableName, aggregators);\r\n}","code_comment":"\/**\r\n * @deprecated since 1.4 {@link #attachIterator(String, IteratorSetting)}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void addAggregators(String tableName, List<? extends PerColumnIteratorConfig> aggregators) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {\r\n    acu.addAggregators(tableName, aggregators);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7539112051,"fo":-0.4166666667,"r":1.3157894737,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1215_a9efe3c4","label":0,"code":"private boolean matchesPropertyType(PropertyState state) {\r\n    if (state == null) {\r\n        return false;\r\n    }\r\n    if (propertyType == PropertyType.UNDEFINED) {\r\n        return true;\r\n    }\r\n    return state.getType().tag() == propertyType;\r\n}","code_comment":null,"code_no_comment":"private boolean matchesPropertyType(PropertyState state) {\r\n    if (state == null) {\r\n        return false;\r\n    }\r\n    if (propertyType == PropertyType.UNDEFINED) {\r\n        return true;\r\n    }\r\n    return state.getType().tag() == propertyType;\r\n}","lc":-0.2272727273,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.3392529951,"fo":-0.3333333333,"r":1.0789473684,"e":-0.1627934049}
{"project_name":"Lang","project_version":"46","label":0,"code":"\/**\r\n * <p>Escapes the characters in a <code>String<\/code> using JavaScript String rules\r\n * to a <code>Writer<\/code>.<\/p>\r\n *\r\n * <p>A <code>null<\/code> string input has no effect.<\/p>\r\n *\r\n * @see #escapeJavaScript(java.lang.String)\r\n * @param out  Writer to write escaped string into\r\n * @param str  String to escape values in, may be null\r\n * @throws IllegalArgumentException if the Writer is <code>null<\/code>\r\n * @throws IOException if error occurs on underlying Writer\r\n *\/\r\npublic static void escapeJavaScript(Writer out, String str) throws IOException {\r\n    escapeJavaStyleString(out, str, true);\r\n}","code_comment":"\/**\r\n * <p>Escapes the characters in a <code>String<\/code> using JavaScript String rules\r\n * to a <code>Writer<\/code>.<\/p>\r\n *\r\n * <p>A <code>null<\/code> string input has no effect.<\/p>\r\n *\r\n * @see #escapeJavaScript(java.lang.String)\r\n * @param out  Writer to write escaped string into\r\n * @param str  String to escape values in, may be null\r\n * @throws IllegalArgumentException if the Writer is <code>null<\/code>\r\n * @throws IOException if error occurs on underlying Writer\r\n *\/\r\n","code_no_comment":"public static void escapeJavaScript(Writer out, String str) throws IOException {\r\n    escapeJavaStyleString(out, str, true);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.948696265,"fo":-0.4166666667,"r":0.9473684211,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-4482_e38494f1","label":1,"code":"@Override\r\nprotected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) {\r\n    Object value = expression.evaluate(exchange, Object.class);\r\n    if (isStreaming()) {\r\n        return createProcessorExchangePairsIterable(exchange, value);\r\n    } else {\r\n        return createProcessorExchangePairsList(exchange, value);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) {\r\n    Object value = expression.evaluate(exchange, Object.class);\r\n    if (isStreaming()) {\r\n        return createProcessorExchangePairsIterable(exchange, value);\r\n    } else {\r\n        return createProcessorExchangePairsList(exchange, value);\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.3152924595,"fo":-0.1666666667,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"Math","project_version":"87","label":1,"code":"\/**\r\n * Checks whether the given column is basic.\r\n * @param col index of the column to check\r\n * @return the row that the variable is basic in.  null if the column is not basic\r\n *\/\r\nprivate Integer getBasicRow(final int col) {\r\n    Integer row = null;\r\n    for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\r\n        if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\r\n            if (row == null) {\r\n                row = i;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    return row;\r\n}","code_comment":"\/**\r\n * Checks whether the given column is basic.\r\n * @param col index of the column to check\r\n * @return the row that the variable is basic in.  null if the column is not basic\r\n *\/\r\n","code_no_comment":"private Integer getBasicRow(final int col) {\r\n    Integer row = null;\r\n    for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\r\n        if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\r\n            if (row == null) {\r\n                row = i;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    return row;\r\n}","lc":-0.0454545455,"pi":1.1100478469,"ma":0.0,"nbd":0.5,"ml":0.4166666667,"d":0.3432539683,"mi":0.0601832276,"fo":-0.1666666667,"r":1.3947368421,"e":0.0610293736}
{"project_name":"Math","project_version":"6","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic PointVectorValuePair doOptimize() {\r\n    checkParameters();\r\n    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\r\n    \/\/ Computation will be useless without a checker (see \"for-loop\").\r\n    if (checker == null) {\r\n        throw new NullArgumentException();\r\n    }\r\n    final double[] targetValues = getTarget();\r\n    \/\/ Number of observed data.\r\n    final int nR = targetValues.length;\r\n    final RealMatrix weightMatrix = getWeight();\r\n    \/\/ Diagonal of the weight matrix.\r\n    final double[] residualsWeights = new double[nR];\r\n    for (int i = 0; i < nR; i++) {\r\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\r\n    }\r\n    final double[] currentPoint = getStartPoint();\r\n    final int nC = currentPoint.length;\r\n    \/\/ iterate until convergence is reached\r\n    PointVectorValuePair current = null;\r\n    int iter = 0;\r\n    for (boolean converged = false; !converged; ) {\r\n        ++iter;\r\n        \/\/ evaluate the objective function and its jacobian\r\n        PointVectorValuePair previous = current;\r\n        \/\/ Value of the objective function at \"currentPoint\".\r\n        final double[] currentObjective = computeObjectiveValue(currentPoint);\r\n        final double[] currentResiduals = computeResiduals(currentObjective);\r\n        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\r\n        current = new PointVectorValuePair(currentPoint, currentObjective);\r\n        \/\/ build the linear problem\r\n        final double[] b = new double[nC];\r\n        final double[][] a = new double[nC][nC];\r\n        for (int i = 0; i < nR; ++i) {\r\n            final double[] grad = weightedJacobian.getRow(i);\r\n            final double weight = residualsWeights[i];\r\n            final double residual = currentResiduals[i];\r\n            \/\/ compute the normal equation\r\n            final double wr = weight * residual;\r\n            for (int j = 0; j < nC; ++j) {\r\n                b[j] += wr * grad[j];\r\n            }\r\n            \/\/ build the contribution matrix for measurement i\r\n            for (int k = 0; k < nC; ++k) {\r\n                double[] ak = a[k];\r\n                double wgk = weight * grad[k];\r\n                for (int l = 0; l < nC; ++l) {\r\n                    ak[l] += wgk * grad[l];\r\n                }\r\n            }\r\n        }\r\n        try {\r\n            \/\/ solve the linearized least squares problem\r\n            RealMatrix mA = new BlockRealMatrix(a);\r\n            DecompositionSolver solver = useLU ? new LUDecomposition(mA).getSolver() : new QRDecomposition(mA).getSolver();\r\n            final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\r\n            \/\/ update the estimated parameters\r\n            for (int i = 0; i < nC; ++i) {\r\n                currentPoint[i] += dX[i];\r\n            }\r\n        } catch (SingularMatrixException e) {\r\n            throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\r\n        }\r\n        \/\/ Check convergence.\r\n        if (previous != null) {\r\n            converged = checker.converged(iter, previous, current);\r\n            if (converged) {\r\n                setCost(computeCost(currentResiduals));\r\n                return current;\r\n            }\r\n        }\r\n    }\r\n    \/\/ Must never happen.\r\n    throw new MathInternalError();\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic PointVectorValuePair doOptimize() {\r\n    checkParameters();\r\n    final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\r\n        if (checker == null) {\r\n        throw new NullArgumentException();\r\n    }\r\n    final double[] targetValues = getTarget();\r\n        final int nR = targetValues.length;\r\n    final RealMatrix weightMatrix = getWeight();\r\n        final double[] residualsWeights = new double[nR];\r\n    for (int i = 0; i < nR; i++) {\r\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\r\n    }\r\n    final double[] currentPoint = getStartPoint();\r\n    final int nC = currentPoint.length;\r\n        PointVectorValuePair current = null;\r\n    int iter = 0;\r\n    for (boolean converged = false; !converged; ) {\r\n        ++iter;\r\n                PointVectorValuePair previous = current;\r\n                final double[] currentObjective = computeObjectiveValue(currentPoint);\r\n        final double[] currentResiduals = computeResiduals(currentObjective);\r\n        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\r\n        current = new PointVectorValuePair(currentPoint, currentObjective);\r\n                final double[] b = new double[nC];\r\n        final double[][] a = new double[nC][nC];\r\n        for (int i = 0; i < nR; ++i) {\r\n            final double[] grad = weightedJacobian.getRow(i);\r\n            final double weight = residualsWeights[i];\r\n            final double residual = currentResiduals[i];\r\n                        final double wr = weight * residual;\r\n            for (int j = 0; j < nC; ++j) {\r\n                b[j] += wr * grad[j];\r\n            }\r\n                        for (int k = 0; k < nC; ++k) {\r\n                double[] ak = a[k];\r\n                double wgk = weight * grad[k];\r\n                for (int l = 0; l < nC; ++l) {\r\n                    ak[l] += wgk * grad[l];\r\n                }\r\n            }\r\n        }\r\n        try {\r\n                        RealMatrix mA = new BlockRealMatrix(a);\r\n            DecompositionSolver solver = useLU ? new LUDecomposition(mA).getSolver() : new QRDecomposition(mA).getSolver();\r\n            final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\r\n                        for (int i = 0; i < nC; ++i) {\r\n                currentPoint[i] += dX[i];\r\n            }\r\n        } catch (SingularMatrixException e) {\r\n            throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\r\n        }\r\n                if (previous != null) {\r\n            converged = checker.converged(iter, previous, current);\r\n            if (converged) {\r\n                setCost(computeCost(currentResiduals));\r\n                return current;\r\n            }\r\n        }\r\n    }\r\n        throw new MathInternalError();\r\n}","lc":2.2272727273,"pi":0.7846889952,"ma":2.4,"nbd":1.0,"ml":1.3333333333,"d":1.6130952381,"mi":-1.0794926004,"fo":0.9166666667,"r":-0.0263157895,"e":6.2506042427}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public void recv_removeTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\r\n    removeTableProperty_result result = new removeTableProperty_result();\r\n    receiveBase(result, \"removeTableProperty\");\r\n    if (result.ouch1 != null) {\r\n        throw result.ouch1;\r\n    }\r\n    if (result.ouch2 != null) {\r\n        throw result.ouch2;\r\n    }\r\n    return;\r\n}","code_comment":null,"code_no_comment":"public void recv_removeTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\r\n    removeTableProperty_result result = new removeTableProperty_result();\r\n    receiveBase(result, \"removeTableProperty\");\r\n    if (result.ouch1 != null) {\r\n        throw result.ouch1;\r\n    }\r\n    if (result.ouch2 != null) {\r\n        throw result.ouch2;\r\n    }\r\n    return;\r\n}","lc":-0.1363636364,"pi":-0.2775119617,"ma":0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0476190476,"mi":0.1605355884,"fo":-0.4166666667,"r":-0.0263157895,"e":-0.081384024}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4387_ca05fd06","label":1,"code":"private Statement convertToStatement(String query) throws ParseException {\r\n    query = query.trim();\r\n    Statement statement = new Statement();\r\n    if (query.startsWith(\"explain \")) {\r\n        query = query.substring(\"explain\".length()).trim();\r\n        statement.setExplain(true);\r\n    }\r\n    if (query.startsWith(\"measure\")) {\r\n        query = query.substring(\"measure\".length()).trim();\r\n        statement.setMeasure(true);\r\n    }\r\n    if (query.isEmpty()) {\r\n        \/\/ special case, will always result in an empty result\r\n        query = \"\/\/jcr:root\";\r\n    }\r\n    statement.setOriginalQuery(query);\r\n    initialize(query);\r\n    expected = new ArrayList<String>();\r\n    read();\r\n    if (currentTokenType == END) {\r\n        throw getSyntaxError(\"the query may not be empty\");\r\n    }\r\n    currentSelector.name = \"a\";\r\n    String pathPattern = \"\";\r\n    boolean startOfQuery = true;\r\n    while (true) {\r\n        \/\/ if true, path or nodeType conditions are not allowed\r\n        boolean shortcut = false;\r\n        boolean slash = readIf(\"\/\");\r\n        if (!slash) {\r\n            if (startOfQuery) {\r\n                \/\/ the query doesn't start with \"\/\"\r\n                currentSelector.path = \"\/\";\r\n                pathPattern = \"\/\";\r\n                currentSelector.isChild = true;\r\n            } else {\r\n                break;\r\n            }\r\n        } else if (readIf(\"jcr:root\")) {\r\n            \/\/ \"\/jcr:root\" may only appear at the beginning\r\n            if (!pathPattern.isEmpty()) {\r\n                throw getSyntaxError(\"jcr:root needs to be at the beginning\");\r\n            }\r\n            if (readIf(\"\/\")) {\r\n                \/\/ \"\/jcr:root\/\"\r\n                currentSelector.path = \"\/\";\r\n                pathPattern = \"\/\";\r\n                if (readIf(\"\/\")) {\r\n                    \/\/ \"\/jcr:root\/\/\"\r\n                    pathPattern = \"\/\/\";\r\n                    currentSelector.isDescendant = true;\r\n                } else {\r\n                    currentSelector.isChild = true;\r\n                }\r\n            } else {\r\n                \/\/ for example \"\/jcr:root[condition]\"\r\n                pathPattern = \"\/%\";\r\n                currentSelector.path = \"\/\";\r\n                shortcut = true;\r\n            }\r\n        } else if (readIf(\"\/\")) {\r\n            \/\/ \"\/\/\" was read\r\n            pathPattern += \"%\";\r\n            if (currentSelector.isDescendant) {\r\n                \/\/ the query started with \"\/\/\", and now \"\/\/\" was read\r\n                nextSelector(true);\r\n            }\r\n            currentSelector.isDescendant = true;\r\n        } else {\r\n            \/\/ the token \"\/\" was read\r\n            pathPattern += \"\/\";\r\n            if (startOfQuery) {\r\n                currentSelector.path = \"\/\";\r\n            } else {\r\n                if (currentSelector.isDescendant) {\r\n                    \/\/ the query started with \"\/\/\", and now \"\/\" was read\r\n                    nextSelector(true);\r\n                }\r\n                currentSelector.isChild = true;\r\n            }\r\n        }\r\n        int startParseIndex = parseIndex;\r\n        if (shortcut) {\r\n        \/\/ \"*\" and so on are not allowed now\r\n        } else if (readIf(\"*\")) {\r\n            \/\/ \"...*\"\r\n            pathPattern += \"%\";\r\n            if (!currentSelector.isDescendant) {\r\n                if (selectors.size() == 0 && currentSelector.path.equals(\"\")) {\r\n                    \/\/ the query \/* is special\r\n                    currentSelector.path = \"\/\";\r\n                }\r\n            }\r\n        } else if (readIf(\"text\")) {\r\n            \/\/ \"...text()\"\r\n            currentSelector.isChild = false;\r\n            pathPattern += \"jcr:xmltext\";\r\n            read(\"(\");\r\n            read(\")\");\r\n            if (currentSelector.isDescendant) {\r\n                currentSelector.nodeName = \"jcr:xmltext\";\r\n            } else {\r\n                currentSelector.path = PathUtils.concat(currentSelector.path, \"jcr:xmltext\");\r\n            }\r\n        } else if (readIf(\"element\")) {\r\n            \/\/ \"...element(...\"\r\n            read(\"(\");\r\n            if (readIf(\")\")) {\r\n                \/\/ any\r\n                pathPattern += \"%\";\r\n            } else {\r\n                if (readIf(\"*\")) {\r\n                    \/\/ any\r\n                    pathPattern += \"%\";\r\n                } else {\r\n                    String name = readPathSegment();\r\n                    pathPattern += name;\r\n                    appendNodeName(name);\r\n                }\r\n                if (readIf(\",\")) {\r\n                    currentSelector.nodeType = readIdentifier();\r\n                }\r\n                read(\")\");\r\n            }\r\n        } else if (readIf(\"@\")) {\r\n            rewindSelector();\r\n            Expression.Property p = readProperty();\r\n            statement.addSelectColumn(p);\r\n        } else if (readIf(\"rep:excerpt\")) {\r\n            rewindSelector();\r\n            readExcerpt();\r\n            Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\r\n            statement.addSelectColumn(p);\r\n        } else if (readIf(\"(\")) {\r\n            rewindSelector();\r\n            do {\r\n                if (readIf(\"@\")) {\r\n                    Expression.Property p = readProperty();\r\n                    statement.addSelectColumn(p);\r\n                } else if (readIf(\"rep:excerpt\")) {\r\n                    readExcerpt();\r\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\r\n                    statement.addSelectColumn(p);\r\n                } else if (readIf(\"rep:spellcheck\")) {\r\n                    \/\/ only rep:spellcheck() is currently supported\r\n                    read(\"(\");\r\n                    read(\")\");\r\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:spellcheck()\", false);\r\n                    statement.addSelectColumn(p);\r\n                } else if (readIf(\"rep:suggest\")) {\r\n                    readExcerpt();\r\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:suggest()\", false);\r\n                    statement.addSelectColumn(p);\r\n                }\r\n            } while (readIf(\"|\"));\r\n            if (!readIf(\")\")) {\r\n                return convertToUnion(query, statement, startParseIndex - 1);\r\n            }\r\n        } else if (currentTokenType == IDENTIFIER) {\r\n            \/\/ path restriction\r\n            String name = readPathSegment();\r\n            pathPattern += name;\r\n            appendNodeName(name);\r\n        } else if (readIf(\".\")) {\r\n            \/\/ \"a\/.\/b\" is the same as \"a\/b\"\r\n            if (readIf(\".\")) {\r\n                \/\/ \"..\" means \"the parent of the node\"\r\n                \/\/ handle like a regular path restriction\r\n                String name = \"..\";\r\n                pathPattern += name;\r\n                if (!currentSelector.isChild) {\r\n                    currentSelector.nodeName = name;\r\n                } else {\r\n                    if (currentSelector.isChild) {\r\n                        currentSelector.isChild = false;\r\n                        currentSelector.isParent = true;\r\n                    }\r\n                }\r\n            } else {\r\n                if (selectors.size() > 0) {\r\n                    currentSelector = selectors.remove(selectors.size() - 1);\r\n                    currentSelector.condition = null;\r\n                    currentSelector.joinCondition = null;\r\n                }\r\n            }\r\n        } else {\r\n            throw getSyntaxError();\r\n        }\r\n        if (readIf(\"[\")) {\r\n            Expression c = parseConstraint();\r\n            currentSelector.condition = Expression.and(currentSelector.condition, c);\r\n            read(\"]\");\r\n        }\r\n        startOfQuery = false;\r\n        nextSelector(false);\r\n    }\r\n    if (selectors.size() == 0) {\r\n        nextSelector(true);\r\n    }\r\n    \/\/ the current selector wasn't used so far\r\n    \/\/ go back to the last one\r\n    currentSelector = selectors.get(selectors.size() - 1);\r\n    if (selectors.size() == 1) {\r\n        currentSelector.onlySelector = true;\r\n    }\r\n    if (readIf(\"order\")) {\r\n        read(\"by\");\r\n        do {\r\n            Order order = new Order();\r\n            order.expr = parseExpression();\r\n            if (readIf(\"descending\")) {\r\n                order.descending = true;\r\n            } else {\r\n                readIf(\"ascending\");\r\n            }\r\n            statement.addOrderBy(order);\r\n        } while (readIf(\",\"));\r\n    }\r\n    if (!currentToken.isEmpty()) {\r\n        throw getSyntaxError(\"<end>\");\r\n    }\r\n    statement.setColumnSelector(currentSelector);\r\n    statement.setSelectors(selectors);\r\n    Expression where = null;\r\n    for (Selector s : selectors) {\r\n        where = Expression.and(where, s.condition);\r\n    }\r\n    statement.setWhere(where);\r\n    return statement;\r\n}","code_comment":null,"code_no_comment":"private Statement convertToStatement(String query) throws ParseException {\r\n    query = query.trim();\r\n    Statement statement = new Statement();\r\n    if (query.startsWith(\"explain \")) {\r\n        query = query.substring(\"explain\".length()).trim();\r\n        statement.setExplain(true);\r\n    }\r\n    if (query.startsWith(\"measure\")) {\r\n        query = query.substring(\"measure\".length()).trim();\r\n        statement.setMeasure(true);\r\n    }\r\n    if (query.isEmpty()) {\r\n                query = \"\/\/jcr:root\";\r\n    }\r\n    statement.setOriginalQuery(query);\r\n    initialize(query);\r\n    expected = new ArrayList<String>();\r\n    read();\r\n    if (currentTokenType == END) {\r\n        throw getSyntaxError(\"the query may not be empty\");\r\n    }\r\n    currentSelector.name = \"a\";\r\n    String pathPattern = \"\";\r\n    boolean startOfQuery = true;\r\n    while (true) {\r\n                boolean shortcut = false;\r\n        boolean slash = readIf(\"\/\");\r\n        if (!slash) {\r\n            if (startOfQuery) {\r\n                                currentSelector.path = \"\/\";\r\n                pathPattern = \"\/\";\r\n                currentSelector.isChild = true;\r\n            } else {\r\n                break;\r\n            }\r\n        } else if (readIf(\"jcr:root\")) {\r\n                        if (!pathPattern.isEmpty()) {\r\n                throw getSyntaxError(\"jcr:root needs to be at the beginning\");\r\n            }\r\n            if (readIf(\"\/\")) {\r\n                                currentSelector.path = \"\/\";\r\n                pathPattern = \"\/\";\r\n                if (readIf(\"\/\")) {\r\n                                        pathPattern = \"\/\/\";\r\n                    currentSelector.isDescendant = true;\r\n                } else {\r\n                    currentSelector.isChild = true;\r\n                }\r\n            } else {\r\n                                pathPattern = \"\/%\";\r\n                currentSelector.path = \"\/\";\r\n                shortcut = true;\r\n            }\r\n        } else if (readIf(\"\/\")) {\r\n                        pathPattern += \"%\";\r\n            if (currentSelector.isDescendant) {\r\n                                nextSelector(true);\r\n            }\r\n            currentSelector.isDescendant = true;\r\n        } else {\r\n                        pathPattern += \"\/\";\r\n            if (startOfQuery) {\r\n                currentSelector.path = \"\/\";\r\n            } else {\r\n                if (currentSelector.isDescendant) {\r\n                                        nextSelector(true);\r\n                }\r\n                currentSelector.isChild = true;\r\n            }\r\n        }\r\n        int startParseIndex = parseIndex;\r\n        if (shortcut) {\r\n                } else if (readIf(\"*\")) {\r\n                        pathPattern += \"%\";\r\n            if (!currentSelector.isDescendant) {\r\n                if (selectors.size() == 0 && currentSelector.path.equals(\"\")) {\r\n                                        currentSelector.path = \"\/\";\r\n                }\r\n            }\r\n        } else if (readIf(\"text\")) {\r\n                        currentSelector.isChild = false;\r\n            pathPattern += \"jcr:xmltext\";\r\n            read(\"(\");\r\n            read(\")\");\r\n            if (currentSelector.isDescendant) {\r\n                currentSelector.nodeName = \"jcr:xmltext\";\r\n            } else {\r\n                currentSelector.path = PathUtils.concat(currentSelector.path, \"jcr:xmltext\");\r\n            }\r\n        } else if (readIf(\"element\")) {\r\n                        read(\"(\");\r\n            if (readIf(\")\")) {\r\n                                pathPattern += \"%\";\r\n            } else {\r\n                if (readIf(\"*\")) {\r\n                                        pathPattern += \"%\";\r\n                } else {\r\n                    String name = readPathSegment();\r\n                    pathPattern += name;\r\n                    appendNodeName(name);\r\n                }\r\n                if (readIf(\",\")) {\r\n                    currentSelector.nodeType = readIdentifier();\r\n                }\r\n                read(\")\");\r\n            }\r\n        } else if (readIf(\"@\")) {\r\n            rewindSelector();\r\n            Expression.Property p = readProperty();\r\n            statement.addSelectColumn(p);\r\n        } else if (readIf(\"rep:excerpt\")) {\r\n            rewindSelector();\r\n            readExcerpt();\r\n            Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\r\n            statement.addSelectColumn(p);\r\n        } else if (readIf(\"(\")) {\r\n            rewindSelector();\r\n            do {\r\n                if (readIf(\"@\")) {\r\n                    Expression.Property p = readProperty();\r\n                    statement.addSelectColumn(p);\r\n                } else if (readIf(\"rep:excerpt\")) {\r\n                    readExcerpt();\r\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\r\n                    statement.addSelectColumn(p);\r\n                } else if (readIf(\"rep:spellcheck\")) {\r\n                                        read(\"(\");\r\n                    read(\")\");\r\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:spellcheck()\", false);\r\n                    statement.addSelectColumn(p);\r\n                } else if (readIf(\"rep:suggest\")) {\r\n                    readExcerpt();\r\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:suggest()\", false);\r\n                    statement.addSelectColumn(p);\r\n                }\r\n            } while (readIf(\"|\"));\r\n            if (!readIf(\")\")) {\r\n                return convertToUnion(query, statement, startParseIndex - 1);\r\n            }\r\n        } else if (currentTokenType == IDENTIFIER) {\r\n                        String name = readPathSegment();\r\n            pathPattern += name;\r\n            appendNodeName(name);\r\n        } else if (readIf(\".\")) {\r\n                        if (readIf(\".\")) {\r\n                                                String name = \"..\";\r\n                pathPattern += name;\r\n                if (!currentSelector.isChild) {\r\n                    currentSelector.nodeName = name;\r\n                } else {\r\n                    if (currentSelector.isChild) {\r\n                        currentSelector.isChild = false;\r\n                        currentSelector.isParent = true;\r\n                    }\r\n                }\r\n            } else {\r\n                if (selectors.size() > 0) {\r\n                    currentSelector = selectors.remove(selectors.size() - 1);\r\n                    currentSelector.condition = null;\r\n                    currentSelector.joinCondition = null;\r\n                }\r\n            }\r\n        } else {\r\n            throw getSyntaxError();\r\n        }\r\n        if (readIf(\"[\")) {\r\n            Expression c = parseConstraint();\r\n            currentSelector.condition = Expression.and(currentSelector.condition, c);\r\n            read(\"]\");\r\n        }\r\n        startOfQuery = false;\r\n        nextSelector(false);\r\n    }\r\n    if (selectors.size() == 0) {\r\n        nextSelector(true);\r\n    }\r\n            currentSelector = selectors.get(selectors.size() - 1);\r\n    if (selectors.size() == 1) {\r\n        currentSelector.onlySelector = true;\r\n    }\r\n    if (readIf(\"order\")) {\r\n        read(\"by\");\r\n        do {\r\n            Order order = new Order();\r\n            order.expr = parseExpression();\r\n            if (readIf(\"descending\")) {\r\n                order.descending = true;\r\n            } else {\r\n                readIf(\"ascending\");\r\n            }\r\n            statement.addOrderBy(order);\r\n        } while (readIf(\",\"));\r\n    }\r\n    if (!currentToken.isEmpty()) {\r\n        throw getSyntaxError(\"<end>\");\r\n    }\r\n    statement.setColumnSelector(currentSelector);\r\n    statement.setSelectors(selectors);\r\n    Expression where = null;\r\n    for (Selector s : selectors) {\r\n        where = Expression.and(where, s.condition);\r\n    }\r\n    statement.setWhere(where);\r\n    return statement;\r\n}","lc":8.6818181818,"pi":1.1339712919,"ma":10.0,"nbd":5.5,"ml":6.0833333333,"d":1.8095238095,"mi":-1.9984496124,"fo":7.6666666667,"r":-0.0263157895,"e":17.376931012}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-208_daf9a4ef","label":1,"code":"\/\/ ------------------------------------------------------------< private >---\r\n\/**\r\n * Purge all pending changes to the underlying {@link NodeStoreBranch}.\r\n * All registered {@link PurgeListener}s are notified.\r\n *\/\r\nprivate void purgePendingChanges() {\r\n    if (hasPendingChanges()) {\r\n        branch.setRoot(rootTree.getNodeState());\r\n    }\r\n    notifyListeners();\r\n}","code_comment":"\/**\r\n * Purge all pending changes to the underlying {@link NodeStoreBranch}.\r\n * All registered {@link PurgeListener}s are notified.\r\n *\/\r\n","code_no_comment":"private void purgePendingChanges() {\r\n    if (hasPendingChanges()) {\r\n        branch.setRoot(rootTree.getNodeState());\r\n    }\r\n    notifyListeners();\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.680620155,"fo":-0.1666666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4370_7ca927c1","label":3,"code":"\/**\r\n *  Get the session.\r\n *\r\n *  @param b\r\n *             Ignored, there is always a session\r\n *  @return The session\r\n *\/\r\n@Override\r\npublic HttpSession getSession(boolean b) {\r\n    if (b && session instanceof MockHttpSession) {\r\n        ((MockHttpSession) session).setTemporary(false);\r\n    }\r\n    return getSession();\r\n}","code_comment":"\/**\r\n *  Get the session.\r\n *\r\n *  @param b\r\n *             Ignored, there is always a session\r\n *  @return The session\r\n *\/\r\n","code_no_comment":"@Override\r\npublic HttpSession getSession(boolean b) {\r\n    if (b && session instanceof MockHttpSession) {\r\n        ((MockHttpSession) session).setTemporary(false);\r\n    }\r\n    return getSession();\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.5131782946,"fo":-0.3333333333,"r":2.5,"e":-0.1627934049}
{"project_name":"Closure","project_version":"165","label":2,"code":"\/**\r\n * Returns whether the given property can possibly be set on the given type.\r\n *\/\r\npublic boolean canPropertyBeDefined(JSType type, String propertyName) {\r\n    if (typesIndexedByProperty.containsKey(propertyName)) {\r\n        for (JSType alt : typesIndexedByProperty.get(propertyName).getAlternates()) {\r\n            JSType greatestSubtype = alt.getGreatestSubtype(type);\r\n            if (!greatestSubtype.isEmptyType()) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":"\/**\r\n * Returns whether the given property can possibly be set on the given type.\r\n *\/\r\n","code_no_comment":"public boolean canPropertyBeDefined(JSType type, String propertyName) {\r\n    if (typesIndexedByProperty.containsKey(propertyName)) {\r\n        for (JSType alt : typesIndexedByProperty.get(propertyName).getAlternates()) {\r\n            JSType greatestSubtype = alt.getGreatestSubtype(type);\r\n            if (!greatestSubtype.isEmptyType()) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}","lc":-0.1363636364,"pi":0.990430622,"ma":0.0,"nbd":0.5,"ml":0.0,"d":-0.0674603175,"mi":0.169837914,"fo":-0.0833333333,"r":0.6578947368,"e":-0.0878154481}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5484_ecdfc124","label":1,"code":"\/**\r\n *  Should the page be rendered immediately.\r\n *\/\r\nprotected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url currentUrl, Url targetUrl) {\r\n    return neverRedirect(getRedirectPolicy()) || (!isAjax(cycle) && ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(), isPageStateless())))) || (targetUrl.equals(currentUrl) && isRedirectToRender()) || shouldPreserveClientUrl(cycle);\r\n}","code_comment":"\/**\r\n *  Should the page be rendered immediately.\r\n *\/\r\n","code_no_comment":"protected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url currentUrl, Url targetUrl) {\r\n    return neverRedirect(getRedirectPolicy()) || (!isAjax(cycle) && ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(), isPageStateless())))) || (targetUrl.equals(currentUrl) && isRedirectToRender()) || shouldPreserveClientUrl(cycle);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.0674603175,"mi":0.7355884426,"fo":0.5833333333,"r":2.5,"e":-0.0595171822}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_add180fb","label":1,"code":"\/**\r\n * @deprecated since 1.4 {@link #attachIterator(String, IteratorSetting)}\r\n *\/\r\n@Override\r\npublic void addAggregators(String tableName, List<? extends PerColumnIteratorConfig> aggregators) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {\r\n    acu.addAggregators(tableName, aggregators);\r\n}","code_comment":"\/**\r\n * @deprecated since 1.4 {@link #attachIterator(String, IteratorSetting)}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void addAggregators(String tableName, List<? extends PerColumnIteratorConfig> aggregators) throws AccumuloSecurityException, TableNotFoundException, AccumuloException {\r\n    acu.addAggregators(tableName, aggregators);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7539112051,"fo":-0.4166666667,"r":1.3157894737,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3281_f7dd2fff","label":1,"code":"\/**\r\n * Applies a route for an interceptor if an exchange is send to the given endpoint\r\n *\r\n * @param uri  endpoint uri\r\n * @return the builder\r\n *\/\r\npublic InterceptSendToEndpointDefinition interceptSendToEndpoint(String uri) {\r\n    routeCollection.setCamelContext(getContext());\r\n    return routeCollection.interceptSendToEndpoint(uri);\r\n}","code_comment":"\/**\r\n * Applies a route for an interceptor if an exchange is send to the given endpoint\r\n *\r\n * @param uri  endpoint uri\r\n * @return the builder\r\n *\/\r\n","code_no_comment":"public InterceptSendToEndpointDefinition interceptSendToEndpoint(String uri) {\r\n    routeCollection.setCamelContext(getContext());\r\n    return routeCollection.interceptSendToEndpoint(uri);\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8255109232,"fo":-0.25,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"Closure","project_version":"156","label":2,"code":"\/**\r\n * Updates the first initialization (a.k.a \"declaration\") of a global name\r\n * that occurs at a FUNCTION node. See comment for\r\n * {@link #updateObjLitOrFunctionDeclaration}.\r\n *\r\n * @param n An object representing a global name (e.g. \"a\")\r\n *\/\r\nprivate void updateFunctionDeclarationAtFunctionNode(Name n) {\r\n    Ref ref = n.declaration;\r\n    String fnName = ref.node.getString();\r\n    addStubsForUndeclaredProperties(n, fnName, ref.node.getAncestor(2), ref.node.getParent());\r\n}","code_comment":"\/**\r\n * Updates the first initialization (a.k.a \"declaration\") of a global name\r\n * that occurs at a FUNCTION node. See comment for\r\n * {@link #updateObjLitOrFunctionDeclaration}.\r\n *\r\n * @param n An object representing a global name (e.g. \"a\")\r\n *\/\r\n","code_no_comment":"private void updateFunctionDeclarationAtFunctionNode(Name n) {\r\n    Ref ref = n.declaration;\r\n    String fnName = ref.node.getString();\r\n    addStubsForUndeclaredProperties(n, fnName, ref.node.getAncestor(2), ref.node.getParent());\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5610993658,"fo":-0.1666666667,"r":1.2894736842,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-991_3cee912e","label":1,"code":"@PluginFactory\r\npublic static LoggerConfig createLogger(@PluginAttribute(\"additivity\") final String additivity, @PluginAttribute(\"level\") final String levelName, @PluginAttribute(\"includeLocation\") final String includeLocation, @PluginElement(\"AppenderRef\") final AppenderRef[] refs, @PluginElement(\"Properties\") final Property[] properties, @PluginConfiguration final Configuration config, @PluginElement(\"Filter\") final Filter filter) {\r\n    final List<AppenderRef> appenderRefs = Arrays.asList(refs);\r\n    Level level;\r\n    try {\r\n        level = Level.toLevel(levelName, Level.ERROR);\r\n    } catch (final Exception ex) {\r\n        LOGGER.error(\"Invalid Log level specified: {}. Defaulting to Error\", levelName);\r\n        level = Level.ERROR;\r\n    }\r\n    final boolean additive = Booleans.parseBoolean(additivity, true);\r\n    return new AsyncLoggerConfig(LogManager.ROOT_LOGGER_NAME, appenderRefs, filter, level, additive, properties, config, includeLocation(includeLocation));\r\n}","code_comment":null,"code_no_comment":"@PluginFactory\r\npublic static LoggerConfig createLogger(@PluginAttribute(\"additivity\") final String additivity, @PluginAttribute(\"level\") final String levelName, @PluginAttribute(\"includeLocation\") final String includeLocation, @PluginElement(\"AppenderRef\") final AppenderRef[] refs, @PluginElement(\"Properties\") final Property[] properties, @PluginConfiguration final Configuration config, @PluginElement(\"Filter\") final Filter filter) {\r\n    final List<AppenderRef> appenderRefs = Arrays.asList(refs);\r\n    Level level;\r\n    try {\r\n        level = Level.toLevel(levelName, Level.ERROR);\r\n    } catch (final Exception ex) {\r\n        LOGGER.error(\"Invalid Log level specified: {}. Defaulting to Error\", levelName);\r\n        level = Level.ERROR;\r\n    }\r\n    final boolean additive = Booleans.parseBoolean(additivity, true);\r\n    return new AsyncLoggerConfig(LogManager.ROOT_LOGGER_NAME, appenderRefs, filter, level, additive, properties, config, includeLocation(includeLocation));\r\n}","lc":-0.0454545455,"pi":-0.1291866029,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.0835799859,"fo":-0.0833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8227_54d7fc59","label":3,"code":"protected ExchangePattern resolveExchangePattern(Exchange exchange, Object recipient) throws UnsupportedEncodingException, URISyntaxException {\r\n    \/\/ trim strings as end users might have added spaces between separators\r\n    if (recipient instanceof String) {\r\n        String s = ((String) recipient).trim();\r\n        \/\/ see if exchangePattern is a parameter in the url\r\n        s = URISupport.normalizeUri(s);\r\n        URI url = new URI(s);\r\n        Map<String, Object> parameters = URISupport.parseParameters(url);\r\n        String pattern = (String) parameters.get(\"exchangePattern\");\r\n        if (pattern != null) {\r\n            return ExchangePattern.asEnum(pattern);\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"protected ExchangePattern resolveExchangePattern(Exchange exchange, Object recipient) throws UnsupportedEncodingException, URISyntaxException {\r\n        if (recipient instanceof String) {\r\n        String s = ((String) recipient).trim();\r\n                s = URISupport.normalizeUri(s);\r\n        URI url = new URI(s);\r\n        Map<String, Object> parameters = URISupport.parseParameters(url);\r\n        String pattern = (String) parameters.get(\"exchangePattern\");\r\n        if (pattern != null) {\r\n            return ExchangePattern.asEnum(pattern);\r\n        }\r\n    }\r\n    return null;\r\n}","lc":-0.0454545455,"pi":0.1818181818,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0099206349,"mi":-0.0105708245,"fo":-0.0833333333,"r":0.1578947368,"e":0.0274568789}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5515_b3bb8670","label":1,"code":"\/**\r\n * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.\r\n *\r\n * @param poolSize    the core pool size\r\n * @param maxPoolSize the maximum pool size\r\n * @return the builder\r\n *\/\r\npublic ThreadsDefinition threads(int poolSize, int maxPoolSize) {\r\n    ThreadsDefinition answer = threads();\r\n    answer.setPoolSize(poolSize);\r\n    answer.setMaxPoolSize(maxPoolSize);\r\n    addOutput(answer);\r\n    return answer;\r\n}","code_comment":"\/**\r\n * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.\r\n *\r\n * @param poolSize    the core pool size\r\n * @param maxPoolSize the maximum pool size\r\n * @return the builder\r\n *\/\r\n","code_no_comment":"public ThreadsDefinition threads(int poolSize, int maxPoolSize) {\r\n    ThreadsDefinition answer = threads();\r\n    answer.setPoolSize(poolSize);\r\n    answer.setMaxPoolSize(maxPoolSize);\r\n    addOutput(answer);\r\n    return answer;\r\n}","lc":-0.3181818182,"pi":-0.5645933014,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4827343199,"fo":-0.1666666667,"r":2.2631578947,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"public void write(org.apache.thrift.protocol.TProtocol oprot, update_result struct) throws org.apache.thrift.TException {\r\n    struct.validate();\r\n    oprot.writeStructBegin(STRUCT_DESC);\r\n    if (struct.ouch1 != null) {\r\n        oprot.writeFieldBegin(OUCH1_FIELD_DESC);\r\n        struct.ouch1.write(oprot);\r\n        oprot.writeFieldEnd();\r\n    }\r\n    if (struct.ouch2 != null) {\r\n        oprot.writeFieldBegin(OUCH2_FIELD_DESC);\r\n        struct.ouch2.write(oprot);\r\n        oprot.writeFieldEnd();\r\n    }\r\n    oprot.writeFieldStop();\r\n    oprot.writeStructEnd();\r\n}","code_comment":null,"code_no_comment":"public void write(org.apache.thrift.protocol.TProtocol oprot, update_result struct) throws org.apache.thrift.TException {\r\n    struct.validate();\r\n    oprot.writeStructBegin(STRUCT_DESC);\r\n    if (struct.ouch1 != null) {\r\n        oprot.writeFieldBegin(OUCH1_FIELD_DESC);\r\n        struct.ouch1.write(oprot);\r\n        oprot.writeFieldEnd();\r\n    }\r\n    if (struct.ouch2 != null) {\r\n        oprot.writeFieldBegin(OUCH2_FIELD_DESC);\r\n        struct.ouch2.write(oprot);\r\n        oprot.writeFieldEnd();\r\n    }\r\n    oprot.writeFieldStop();\r\n    oprot.writeStructEnd();\r\n}","lc":0.0909090909,"pi":-0.1626794258,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":-0.1016208598,"fo":0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5147_184e51e9","label":1,"code":"\/**\r\n *  A filterPath should have all leading slashes removed and exactly one trailing slash. A\r\n *  wildcard asterisk character has no special meaning. If your intention is to mean the top\r\n *  level \"\/\" then an empty string should be used instead.\r\n *\r\n *  @param filterPath\r\n *  @return\r\n *\/\r\nstatic String canonicaliseFilterPath(String filterPath) {\r\n    if (Strings.isEmpty(filterPath)) {\r\n        return filterPath;\r\n    }\r\n    int beginIndex = 0;\r\n    int endIndex = filterPath.length();\r\n    while (beginIndex < endIndex) {\r\n        char c = filterPath.charAt(beginIndex);\r\n        if (c != '\/') {\r\n            break;\r\n        }\r\n        beginIndex++;\r\n    }\r\n    int o;\r\n    int i = o = beginIndex;\r\n    while (i < endIndex) {\r\n        char c = filterPath.charAt(i);\r\n        i++;\r\n        if (c != '\/') {\r\n            o = i;\r\n        }\r\n    }\r\n    if (o < endIndex) {\r\n        \/\/ include exactly one trailing slash\r\n        o++;\r\n        filterPath = filterPath.substring(beginIndex, o);\r\n    } else {\r\n        \/\/ ensure to append trailing slash\r\n        filterPath = filterPath.substring(beginIndex) + '\/';\r\n    }\r\n    if (filterPath.equals(\"\/\")) {\r\n        return \"\";\r\n    }\r\n    return filterPath;\r\n}","code_comment":"\/**\r\n *  A filterPath should have all leading slashes removed and exactly one trailing slash. A\r\n *  wildcard asterisk character has no special meaning. If your intention is to mean the top\r\n *  level \"\/\" then an empty string should be used instead.\r\n *\r\n *  @param filterPath\r\n *  @return\r\n *\/\r\n","code_no_comment":"static String canonicaliseFilterPath(String filterPath) {\r\n    if (Strings.isEmpty(filterPath)) {\r\n        return filterPath;\r\n    }\r\n    int beginIndex = 0;\r\n    int endIndex = filterPath.length();\r\n    while (beginIndex < endIndex) {\r\n        char c = filterPath.charAt(beginIndex);\r\n        if (c != '\/') {\r\n            break;\r\n        }\r\n        beginIndex++;\r\n    }\r\n    int o;\r\n    int i = o = beginIndex;\r\n    while (i < endIndex) {\r\n        char c = filterPath.charAt(i);\r\n        i++;\r\n        if (c != '\/') {\r\n            o = i;\r\n        }\r\n    }\r\n    if (o < endIndex) {\r\n                o++;\r\n        filterPath = filterPath.substring(beginIndex, o);\r\n    } else {\r\n                filterPath = filterPath.substring(beginIndex) + '\/';\r\n    }\r\n    if (filterPath.equals(\"\/\")) {\r\n        return \"\";\r\n    }\r\n    return filterPath;\r\n}","lc":0.8636363636,"pi":-0.0909090909,"ma":1.0,"nbd":0.0,"ml":0.8333333333,"d":0.869047619,"mi":-0.5295278365,"fo":0.0833333333,"r":-0.0263157895,"e":0.7974712286}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-412_5594b2e0","label":1,"code":"public void run() {\r\n    List<TabletLocation> tabletsToAssignMapFileTo = Collections.emptyList();\r\n    try {\r\n        tabletsToAssignMapFileTo = findOverlappingTablets(instance.getConfiguration(), fs, locator, mapFile);\r\n    } catch (Exception ex) {\r\n        log.warn(\"Unable to find tablets that overlap file \" + mapFile.toString());\r\n    }\r\n    if (tabletsToAssignMapFileTo.size() == 0) {\r\n        List<KeyExtent> empty = Collections.emptyList();\r\n        completeFailures.put(mapFile, empty);\r\n    } else\r\n        assignments.put(mapFile, tabletsToAssignMapFileTo);\r\n}","code_comment":null,"code_no_comment":"public void run() {\r\n    List<TabletLocation> tabletsToAssignMapFileTo = Collections.emptyList();\r\n    try {\r\n        tabletsToAssignMapFileTo = findOverlappingTablets(instance.getConfiguration(), fs, locator, mapFile);\r\n    } catch (Exception ex) {\r\n        log.warn(\"Unable to find tablets that overlap file \" + mapFile.toString());\r\n    }\r\n    if (tabletsToAssignMapFileTo.size() == 0) {\r\n        List<KeyExtent> empty = Collections.emptyList();\r\n        completeFailures.put(mapFile, empty);\r\n    } else\r\n        assignments.put(mapFile, tabletsToAssignMapFileTo);\r\n}","lc":-0.0454545455,"pi":-0.0956937799,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0833333333,"mi":0.0071881607,"fo":0.25,"r":0.0,"e":-0.0289275773}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-1856_faa5cf27","label":3,"code":"private void assembleDistributionInheritence(Model child, Model parent, String childPathAdjustment, boolean appendPaths) {\r\n    if (parent.getDistributionManagement() != null) {\r\n        DistributionManagement parentDistMgmt = parent.getDistributionManagement();\r\n        DistributionManagement childDistMgmt = child.getDistributionManagement();\r\n        if (childDistMgmt == null) {\r\n            childDistMgmt = new DistributionManagement();\r\n            child.setDistributionManagement(childDistMgmt);\r\n        }\r\n        if (childDistMgmt.getSite() == null) {\r\n            if (parentDistMgmt.getSite() != null) {\r\n                Site site = new Site();\r\n                childDistMgmt.setSite(site);\r\n                site.setId(parentDistMgmt.getSite().getId());\r\n                site.setName(parentDistMgmt.getSite().getName());\r\n                site.setUrl(parentDistMgmt.getSite().getUrl());\r\n                if (site.getUrl() != null) {\r\n                    site.setUrl(appendPath(site.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));\r\n                }\r\n            }\r\n        }\r\n        if (childDistMgmt.getRepository() == null) {\r\n            if (parentDistMgmt.getRepository() != null) {\r\n                DeploymentRepository repository = new DeploymentRepository();\r\n                childDistMgmt.setRepository(repository);\r\n                repository.setId(parentDistMgmt.getRepository().getId());\r\n                repository.setName(parentDistMgmt.getRepository().getName());\r\n                repository.setUrl(parentDistMgmt.getRepository().getUrl());\r\n                repository.setUniqueVersion(parentDistMgmt.getRepository().isUniqueVersion());\r\n            }\r\n        }\r\n        if (childDistMgmt.getSnapshotRepository() == null) {\r\n            if (parentDistMgmt.getSnapshotRepository() != null) {\r\n                DeploymentRepository repository = new DeploymentRepository();\r\n                childDistMgmt.setSnapshotRepository(repository);\r\n                repository.setId(parentDistMgmt.getSnapshotRepository().getId());\r\n                repository.setName(parentDistMgmt.getSnapshotRepository().getName());\r\n                repository.setUrl(parentDistMgmt.getSnapshotRepository().getUrl());\r\n                repository.setUniqueVersion(parentDistMgmt.getSnapshotRepository().isUniqueVersion());\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void assembleDistributionInheritence(Model child, Model parent, String childPathAdjustment, boolean appendPaths) {\r\n    if (parent.getDistributionManagement() != null) {\r\n        DistributionManagement parentDistMgmt = parent.getDistributionManagement();\r\n        DistributionManagement childDistMgmt = child.getDistributionManagement();\r\n        if (childDistMgmt == null) {\r\n            childDistMgmt = new DistributionManagement();\r\n            child.setDistributionManagement(childDistMgmt);\r\n        }\r\n        if (childDistMgmt.getSite() == null) {\r\n            if (parentDistMgmt.getSite() != null) {\r\n                Site site = new Site();\r\n                childDistMgmt.setSite(site);\r\n                site.setId(parentDistMgmt.getSite().getId());\r\n                site.setName(parentDistMgmt.getSite().getName());\r\n                site.setUrl(parentDistMgmt.getSite().getUrl());\r\n                if (site.getUrl() != null) {\r\n                    site.setUrl(appendPath(site.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths));\r\n                }\r\n            }\r\n        }\r\n        if (childDistMgmt.getRepository() == null) {\r\n            if (parentDistMgmt.getRepository() != null) {\r\n                DeploymentRepository repository = new DeploymentRepository();\r\n                childDistMgmt.setRepository(repository);\r\n                repository.setId(parentDistMgmt.getRepository().getId());\r\n                repository.setName(parentDistMgmt.getRepository().getName());\r\n                repository.setUrl(parentDistMgmt.getRepository().getUrl());\r\n                repository.setUniqueVersion(parentDistMgmt.getRepository().isUniqueVersion());\r\n            }\r\n        }\r\n        if (childDistMgmt.getSnapshotRepository() == null) {\r\n            if (parentDistMgmt.getSnapshotRepository() != null) {\r\n                DeploymentRepository repository = new DeploymentRepository();\r\n                childDistMgmt.setSnapshotRepository(repository);\r\n                repository.setId(parentDistMgmt.getSnapshotRepository().getId());\r\n                repository.setName(parentDistMgmt.getSnapshotRepository().getName());\r\n                repository.setUrl(parentDistMgmt.getSnapshotRepository().getUrl());\r\n                repository.setUniqueVersion(parentDistMgmt.getSnapshotRepository().isUniqueVersion());\r\n            }\r\n        }\r\n    }\r\n}","lc":1.2727272727,"pi":0.8373205742,"ma":1.2,"nbd":1.0,"ml":1.0833333333,"d":0.3928571429,"mi":-0.7654686399,"fo":3.75,"r":-0.0263157895,"e":1.1687557269}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-3991_2169c4a3","label":3,"code":"public void validateEffectiveModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\r\n    validateStringNotEmpty(\"modelVersion\", problems, false, model.getModelVersion());\r\n    validateId(\"groupId\", problems, model.getGroupId());\r\n    validateId(\"artifactId\", problems, model.getArtifactId());\r\n    validateStringNotEmpty(\"packaging\", problems, false, model.getPackaging());\r\n    if (!model.getModules().isEmpty() && !\"pom\".equals(model.getPackaging())) {\r\n        addViolation(problems, false, \"Packaging '\" + model.getPackaging() + \"' is invalid. Aggregator projects \" + \"require 'pom' as packaging.\");\r\n    }\r\n    Parent parent = model.getParent();\r\n    if (parent != null) {\r\n        if (parent.getGroupId().equals(model.getGroupId()) && parent.getArtifactId().equals(model.getArtifactId())) {\r\n            addViolation(problems, false, \"The parent element cannot have the same ID as the project.\");\r\n        }\r\n    }\r\n    validateStringNotEmpty(\"version\", problems, false, model.getVersion());\r\n    boolean warnOnBadBoolean = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\r\n    boolean warnOnBadDependencyScope = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\r\n    for (Dependency d : model.getDependencies()) {\r\n        validateId(\"dependencies.dependency.artifactId\", problems, d.getArtifactId());\r\n        validateId(\"dependencies.dependency.groupId\", problems, d.getGroupId());\r\n        validateStringNotEmpty(\"dependencies.dependency.type\", problems, false, d.getType(), d.getManagementKey());\r\n        validateStringNotEmpty(\"dependencies.dependency.version\", problems, false, d.getVersion(), d.getManagementKey());\r\n        if (\"system\".equals(d.getScope())) {\r\n            String systemPath = d.getSystemPath();\r\n            if (StringUtils.isEmpty(systemPath)) {\r\n                addViolation(problems, false, \"For dependency \" + d + \": system-scoped dependency must specify systemPath.\");\r\n            } else {\r\n                if (!new File(systemPath).isAbsolute()) {\r\n                    addViolation(problems, false, \"For dependency \" + d + \": system-scoped dependency must \" + \"specify an absolute path systemPath.\");\r\n                }\r\n            }\r\n        } else if (StringUtils.isNotEmpty(d.getSystemPath())) {\r\n            addViolation(problems, false, \"For dependency \" + d + \": only dependency with system scope can specify systemPath.\");\r\n        }\r\n        if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\r\n            validateBoolean(\"dependencies.dependency.optional\", problems, warnOnBadBoolean, d.getOptional(), d.getManagementKey());\r\n            validateEnum(\"dependencies.dependency.scope\", problems, warnOnBadDependencyScope, d.getScope(), d.getManagementKey(), \"provided\", \"compile\", \"runtime\", \"test\", \"system\");\r\n        }\r\n    }\r\n    DependencyManagement mgmt = model.getDependencyManagement();\r\n    if (mgmt != null) {\r\n        for (Dependency d : mgmt.getDependencies()) {\r\n            validateSubElementStringNotEmpty(d, \"dependencyManagement.dependencies.dependency.artifactId\", problems, d.getArtifactId());\r\n            validateSubElementStringNotEmpty(d, \"dependencyManagement.dependencies.dependency.groupId\", problems, d.getGroupId());\r\n            if (\"system\".equals(d.getScope())) {\r\n                String systemPath = d.getSystemPath();\r\n                if (StringUtils.isEmpty(systemPath)) {\r\n                    addViolation(problems, false, \"For managed dependency \" + d + \": system-scoped dependency must specify systemPath.\");\r\n                } else {\r\n                    if (!new File(systemPath).isAbsolute()) {\r\n                        addViolation(problems, false, \"For managed dependency \" + d + \": system-scoped dependency must \" + \"specify an absolute path systemPath.\");\r\n                    }\r\n                }\r\n            } else if (StringUtils.isNotEmpty(d.getSystemPath())) {\r\n                addViolation(problems, false, \"For managed dependency \" + d + \": only dependency with system scope can specify systemPath.\");\r\n            }\r\n            if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\r\n                validateBoolean(\"dependencyManagement.dependencies.dependency.optional\", problems, warnOnBadBoolean, d.getOptional(), d.getManagementKey());\r\n            }\r\n        }\r\n    }\r\n    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\r\n        boolean warnOnMissingPluginVersion = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1;\r\n        Build build = model.getBuild();\r\n        if (build != null) {\r\n            for (Plugin p : build.getPlugins()) {\r\n                validateStringNotEmpty(\"build.plugins.plugin.artifactId\", problems, false, p.getArtifactId());\r\n                validateStringNotEmpty(\"build.plugins.plugin.groupId\", problems, false, p.getGroupId());\r\n                validateStringNotEmpty(\"build.plugins.plugin.version\", problems, warnOnMissingPluginVersion, p.getVersion(), p.getKey());\r\n                validateBoolean(\"build.plugins.plugin.inherited\", problems, warnOnBadBoolean, p.getInherited(), p.getKey());\r\n                validateBoolean(\"build.plugins.plugin.extensions\", problems, warnOnBadBoolean, p.getExtensions(), p.getKey());\r\n                for (Dependency d : p.getDependencies()) {\r\n                    validateEnum(\"build.plugins.plugin[\" + p.getKey() + \"].dependencies.dependency.scope\", problems, warnOnBadDependencyScope, d.getScope(), d.getManagementKey(), \"compile\", \"runtime\", \"system\");\r\n                }\r\n            }\r\n            validateResources(problems, build.getResources(), \"build.resources.resource\", request);\r\n            validateResources(problems, build.getTestResources(), \"build.testResources.testResource\", request);\r\n        }\r\n        Reporting reporting = model.getReporting();\r\n        if (reporting != null) {\r\n            for (ReportPlugin p : reporting.getPlugins()) {\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.artifactId\", problems, false, p.getArtifactId());\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.groupId\", problems, false, p.getGroupId());\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.version\", problems, warnOnMissingPluginVersion, p.getVersion(), p.getKey());\r\n            }\r\n        }\r\n        forcePluginExecutionIdCollision(model, problems);\r\n        for (Repository repository : model.getRepositories()) {\r\n            validateRepositoryLayout(problems, repository, \"repositories.repository\", request);\r\n        }\r\n        for (Repository repository : model.getPluginRepositories()) {\r\n            validateRepositoryLayout(problems, repository, \"pluginRepositories.pluginRepository\", request);\r\n        }\r\n        DistributionManagement distMgmt = model.getDistributionManagement();\r\n        if (distMgmt != null) {\r\n            validateRepositoryLayout(problems, distMgmt.getRepository(), \"distributionManagement.repository\", request);\r\n            validateRepositoryLayout(problems, distMgmt.getSnapshotRepository(), \"distributionManagement.snapshotRepository\", request);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void validateEffectiveModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\r\n    validateStringNotEmpty(\"modelVersion\", problems, false, model.getModelVersion());\r\n    validateId(\"groupId\", problems, model.getGroupId());\r\n    validateId(\"artifactId\", problems, model.getArtifactId());\r\n    validateStringNotEmpty(\"packaging\", problems, false, model.getPackaging());\r\n    if (!model.getModules().isEmpty() && !\"pom\".equals(model.getPackaging())) {\r\n        addViolation(problems, false, \"Packaging '\" + model.getPackaging() + \"' is invalid. Aggregator projects \" + \"require 'pom' as packaging.\");\r\n    }\r\n    Parent parent = model.getParent();\r\n    if (parent != null) {\r\n        if (parent.getGroupId().equals(model.getGroupId()) && parent.getArtifactId().equals(model.getArtifactId())) {\r\n            addViolation(problems, false, \"The parent element cannot have the same ID as the project.\");\r\n        }\r\n    }\r\n    validateStringNotEmpty(\"version\", problems, false, model.getVersion());\r\n    boolean warnOnBadBoolean = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\r\n    boolean warnOnBadDependencyScope = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\r\n    for (Dependency d : model.getDependencies()) {\r\n        validateId(\"dependencies.dependency.artifactId\", problems, d.getArtifactId());\r\n        validateId(\"dependencies.dependency.groupId\", problems, d.getGroupId());\r\n        validateStringNotEmpty(\"dependencies.dependency.type\", problems, false, d.getType(), d.getManagementKey());\r\n        validateStringNotEmpty(\"dependencies.dependency.version\", problems, false, d.getVersion(), d.getManagementKey());\r\n        if (\"system\".equals(d.getScope())) {\r\n            String systemPath = d.getSystemPath();\r\n            if (StringUtils.isEmpty(systemPath)) {\r\n                addViolation(problems, false, \"For dependency \" + d + \": system-scoped dependency must specify systemPath.\");\r\n            } else {\r\n                if (!new File(systemPath).isAbsolute()) {\r\n                    addViolation(problems, false, \"For dependency \" + d + \": system-scoped dependency must \" + \"specify an absolute path systemPath.\");\r\n                }\r\n            }\r\n        } else if (StringUtils.isNotEmpty(d.getSystemPath())) {\r\n            addViolation(problems, false, \"For dependency \" + d + \": only dependency with system scope can specify systemPath.\");\r\n        }\r\n        if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\r\n            validateBoolean(\"dependencies.dependency.optional\", problems, warnOnBadBoolean, d.getOptional(), d.getManagementKey());\r\n            validateEnum(\"dependencies.dependency.scope\", problems, warnOnBadDependencyScope, d.getScope(), d.getManagementKey(), \"provided\", \"compile\", \"runtime\", \"test\", \"system\");\r\n        }\r\n    }\r\n    DependencyManagement mgmt = model.getDependencyManagement();\r\n    if (mgmt != null) {\r\n        for (Dependency d : mgmt.getDependencies()) {\r\n            validateSubElementStringNotEmpty(d, \"dependencyManagement.dependencies.dependency.artifactId\", problems, d.getArtifactId());\r\n            validateSubElementStringNotEmpty(d, \"dependencyManagement.dependencies.dependency.groupId\", problems, d.getGroupId());\r\n            if (\"system\".equals(d.getScope())) {\r\n                String systemPath = d.getSystemPath();\r\n                if (StringUtils.isEmpty(systemPath)) {\r\n                    addViolation(problems, false, \"For managed dependency \" + d + \": system-scoped dependency must specify systemPath.\");\r\n                } else {\r\n                    if (!new File(systemPath).isAbsolute()) {\r\n                        addViolation(problems, false, \"For managed dependency \" + d + \": system-scoped dependency must \" + \"specify an absolute path systemPath.\");\r\n                    }\r\n                }\r\n            } else if (StringUtils.isNotEmpty(d.getSystemPath())) {\r\n                addViolation(problems, false, \"For managed dependency \" + d + \": only dependency with system scope can specify systemPath.\");\r\n            }\r\n            if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\r\n                validateBoolean(\"dependencyManagement.dependencies.dependency.optional\", problems, warnOnBadBoolean, d.getOptional(), d.getManagementKey());\r\n            }\r\n        }\r\n    }\r\n    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\r\n        boolean warnOnMissingPluginVersion = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1;\r\n        Build build = model.getBuild();\r\n        if (build != null) {\r\n            for (Plugin p : build.getPlugins()) {\r\n                validateStringNotEmpty(\"build.plugins.plugin.artifactId\", problems, false, p.getArtifactId());\r\n                validateStringNotEmpty(\"build.plugins.plugin.groupId\", problems, false, p.getGroupId());\r\n                validateStringNotEmpty(\"build.plugins.plugin.version\", problems, warnOnMissingPluginVersion, p.getVersion(), p.getKey());\r\n                validateBoolean(\"build.plugins.plugin.inherited\", problems, warnOnBadBoolean, p.getInherited(), p.getKey());\r\n                validateBoolean(\"build.plugins.plugin.extensions\", problems, warnOnBadBoolean, p.getExtensions(), p.getKey());\r\n                for (Dependency d : p.getDependencies()) {\r\n                    validateEnum(\"build.plugins.plugin[\" + p.getKey() + \"].dependencies.dependency.scope\", problems, warnOnBadDependencyScope, d.getScope(), d.getManagementKey(), \"compile\", \"runtime\", \"system\");\r\n                }\r\n            }\r\n            validateResources(problems, build.getResources(), \"build.resources.resource\", request);\r\n            validateResources(problems, build.getTestResources(), \"build.testResources.testResource\", request);\r\n        }\r\n        Reporting reporting = model.getReporting();\r\n        if (reporting != null) {\r\n            for (ReportPlugin p : reporting.getPlugins()) {\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.artifactId\", problems, false, p.getArtifactId());\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.groupId\", problems, false, p.getGroupId());\r\n                validateStringNotEmpty(\"reporting.plugins.plugin.version\", problems, warnOnMissingPluginVersion, p.getVersion(), p.getKey());\r\n            }\r\n        }\r\n        forcePluginExecutionIdCollision(model, problems);\r\n        for (Repository repository : model.getRepositories()) {\r\n            validateRepositoryLayout(problems, repository, \"repositories.repository\", request);\r\n        }\r\n        for (Repository repository : model.getPluginRepositories()) {\r\n            validateRepositoryLayout(problems, repository, \"pluginRepositories.pluginRepository\", request);\r\n        }\r\n        DistributionManagement distMgmt = model.getDistributionManagement();\r\n        if (distMgmt != null) {\r\n            validateRepositoryLayout(problems, distMgmt.getRepository(), \"distributionManagement.repository\", request);\r\n            validateRepositoryLayout(problems, distMgmt.getSnapshotRepository(), \"distributionManagement.snapshotRepository\", request);\r\n        }\r\n    }\r\n}","lc":3.9090909091,"pi":0.9473684211,"ma":4.4,"nbd":1.5,"ml":2.9166666667,"d":1.5456349206,"mi":-1.4699083862,"fo":9.4166666667,"r":-0.0263157895,"e":13.3570051232}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-606_f0fbacab","label":1,"code":"\/\/ ------------------------------------------------------------< private >---\r\n\/**\r\n * The underlying {@link org.apache.jackrabbit.oak.api.TreeLocation} of this item.\r\n * The location is only re-resolved when the revision of this item does not match\r\n * the revision of the session.\r\n * @return  tree location of the underlying item.\r\n *\/\r\n@Nonnull\r\nprivate synchronized TreeLocation getLocationOrNull() {\r\n    if (location.exists() && sessionDelegate.getRevision() != revision) {\r\n        location = sessionDelegate.getLocation(location.getPath());\r\n        revision = sessionDelegate.getRevision();\r\n    }\r\n    return location;\r\n}","code_comment":"\/**\r\n * The underlying {@link org.apache.jackrabbit.oak.api.TreeLocation} of this item.\r\n * The location is only re-resolved when the revision of this item does not match\r\n * the revision of the session.\r\n * @return  tree location of the underlying item.\r\n *\/\r\n","code_no_comment":"@Nonnull\r\nprivate synchronized TreeLocation getLocationOrNull() {\r\n    if (location.exists() && sessionDelegate.getRevision() != revision) {\r\n        location = sessionDelegate.getLocation(location.getPath());\r\n        revision = sessionDelegate.getRevision();\r\n    }\r\n    return location;\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":0.0,"d":-0.0396825397,"mi":0.3660324172,"fo":-0.0833333333,"r":2.0263157895,"e":-0.0996040871}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5359_61122bab","label":3,"code":"\/**\r\n *  {@inheritDoc}\r\n *\/\r\n@Override\r\npublic boolean equals(final Object obj) {\r\n    if (obj instanceof StringValue) {\r\n        StringValue stringValue = (StringValue) obj;\r\n        return Objects.isEqual(text, stringValue.text) && Objects.isEqual(locale, stringValue.locale);\r\n    } else {\r\n        return false;\r\n    }\r\n}","code_comment":"\/**\r\n *  {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic boolean equals(final Object obj) {\r\n    if (obj instanceof StringValue) {\r\n        StringValue stringValue = (StringValue) obj;\r\n        return Objects.isEqual(text, stringValue.text) && Objects.isEqual(locale, stringValue.locale);\r\n    } else {\r\n        return false;\r\n    }\r\n}","lc":-0.2272727273,"pi":0.1339712919,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.001984127,"mi":0.2995066949,"fo":-0.3333333333,"r":1.9210526316,"e":-0.0855609919}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3448_b345dd82","label":0,"code":"public void addExceptionPolicy(OnExceptionDefinition exceptionType) {\r\n    Processor processor = exceptionType.getErrorHandler();\r\n    addChildService(processor);\r\n    List<Class> list = exceptionType.getExceptionClasses();\r\n    for (Class clazz : list) {\r\n        ExceptionPolicyKey key = new ExceptionPolicyKey(clazz, exceptionType.getOnWhen());\r\n        exceptionPolicies.put(key, exceptionType);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void addExceptionPolicy(OnExceptionDefinition exceptionType) {\r\n    Processor processor = exceptionType.getErrorHandler();\r\n    addChildService(processor);\r\n    List<Class> list = exceptionType.getExceptionClasses();\r\n    for (Class clazz : list) {\r\n        ExceptionPolicyKey key = new ExceptionPolicyKey(clazz, exceptionType.getOnWhen());\r\n        exceptionPolicies.put(key, exceptionType);\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.1531100478,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.2459478506,"fo":-0.0833333333,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3579_2565d74a","label":3,"code":"@Override\r\npublic void run() {\r\n    while (delay != 0 && !isDisposed.get()) {\r\n        synchronized (isDisposed) {\r\n            try {\r\n                isDisposed.wait(delay);\r\n            } catch (InterruptedException e) {\r\n            \/\/ ignore\r\n            }\r\n        }\r\n        DocumentNodeStore nodeStore = ref.get();\r\n        if (nodeStore != null) {\r\n            try {\r\n                execute(nodeStore);\r\n            } catch (Throwable t) {\r\n                LOG.warn(\"Background operation failed: \" + t.toString(), t);\r\n            }\r\n            delay = nodeStore.getAsyncDelay();\r\n        } else {\r\n            \/\/ node store not in use anymore\r\n            break;\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void run() {\r\n    while (delay != 0 && !isDisposed.get()) {\r\n        synchronized (isDisposed) {\r\n            try {\r\n                isDisposed.wait(delay);\r\n            } catch (InterruptedException e) {\r\n                        }\r\n        }\r\n        DocumentNodeStore nodeStore = ref.get();\r\n        if (nodeStore != null) {\r\n            try {\r\n                execute(nodeStore);\r\n            } catch (Throwable t) {\r\n                LOG.warn(\"Background operation failed: \" + t.toString(), t);\r\n            }\r\n            delay = nodeStore.getAsyncDelay();\r\n        } else {\r\n                        break;\r\n        }\r\n    }\r\n}","lc":0.3636363636,"pi":0.8899521531,"ma":0.4,"nbd":0.5,"ml":0.0833333333,"d":0.2123015873,"mi":-0.2383368569,"fo":0.0833333333,"r":0.6052631579,"e":0.0859159881}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2465_60186813","label":1,"code":"private void init() {\r\n    long cnt = 0;\r\n    existingNames.clear();\r\n    for (String name : principalNames) {\r\n        long n = cache.getNumEntries(store, name, maxSize);\r\n        cnt += n;\r\n        if (n > 0) {\r\n            existingNames.add(name);\r\n        }\r\n    }\r\n    if (cnt < maxSize) {\r\n        \/\/ cache all entries of all principals\r\n        pathEntryMap = new HashMap<String, Collection<PermissionEntry>>();\r\n        for (String name : principalNames) {\r\n            cache.load(store, pathEntryMap, name);\r\n        }\r\n    } else {\r\n        pathEntryMap = null;\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void init() {\r\n    long cnt = 0;\r\n    existingNames.clear();\r\n    for (String name : principalNames) {\r\n        long n = cache.getNumEntries(store, name, maxSize);\r\n        cnt += n;\r\n        if (n > 0) {\r\n            existingNames.add(name);\r\n        }\r\n    }\r\n    if (cnt < maxSize) {\r\n                pathEntryMap = new HashMap<String, Collection<PermissionEntry>>();\r\n        for (String name : principalNames) {\r\n            cache.load(store, pathEntryMap, name);\r\n        }\r\n    } else {\r\n        pathEntryMap = null;\r\n    }\r\n}","lc":0.2272727273,"pi":0.1387559809,"ma":0.2,"nbd":0.0,"ml":0.0,"d":0.371031746,"mi":-0.1856236786,"fo":-0.1666666667,"r":0.0526315789,"e":0.2030093993}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_46f62443","label":1,"code":"@Override\r\npublic Map<String, Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Map<String, Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {\r\n    return null;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7919661734,"fo":-0.5,"r":0.2105263158,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6610_ed7e7c9f","label":1,"code":"\/**\r\n * Sets the id of this node.\r\n * <p\/>\r\n * <b>Important:<\/b> If you want to set the id of the route,\r\n * then you <b>must<\/b> use {@link #routeId(String)} instead.\r\n *\r\n * @param id  the id\r\n * @return the builder\r\n *\/\r\n@SuppressWarnings(\"unchecked\")\r\npublic Type id(String id) {\r\n    if (isOutputSupported() && getOutputs().isEmpty()) {\r\n        \/\/ set id on this\r\n        setId(id);\r\n    } else {\r\n        \/\/ set it on last output as this is what the user means to do\r\n        \/\/ for Block(s) with non empty getOutputs() the id probably refers\r\n        \/\/ to the last definition in the current Block\r\n        List<ProcessorDefinition<?>> outputs = getOutputs();\r\n        if (!blocks.isEmpty()) {\r\n            if (blocks.getLast() instanceof ProcessorDefinition) {\r\n                ProcessorDefinition<?> block = (ProcessorDefinition<?>) blocks.getLast();\r\n                if (!block.getOutputs().isEmpty()) {\r\n                    outputs = block.getOutputs();\r\n                }\r\n            }\r\n        }\r\n        outputs.get(outputs.size() - 1).setId(id);\r\n    }\r\n    return (Type) this;\r\n}","code_comment":"\/**\r\n * Sets the id of this node.\r\n * <p\/>\r\n * <b>Important:<\/b> If you want to set the id of the route,\r\n * then you <b>must<\/b> use {@link #routeId(String)} instead.\r\n *\r\n * @param id  the id\r\n * @return the builder\r\n *\/\r\n","code_no_comment":"@SuppressWarnings(\"unchecked\")\r\npublic Type id(String id) {\r\n    if (isOutputSupported() && getOutputs().isEmpty()) {\r\n                setId(id);\r\n    } else {\r\n                                List<ProcessorDefinition<?>> outputs = getOutputs();\r\n        if (!blocks.isEmpty()) {\r\n            if (blocks.getLast() instanceof ProcessorDefinition) {\r\n                ProcessorDefinition<?> block = (ProcessorDefinition<?>) blocks.getLast();\r\n                if (!block.getOutputs().isEmpty()) {\r\n                    outputs = block.getOutputs();\r\n                }\r\n            }\r\n        }\r\n        outputs.get(outputs.size() - 1).setId(id);\r\n    }\r\n    return (Type) this;\r\n}","lc":0.1818181818,"pi":1.3827751196,"ma":0.2,"nbd":1.0,"ml":0.4166666667,"d":0.4702380952,"mi":-0.1602536998,"fo":0.6666666667,"r":0.0,"e":0.2499196072}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-554_3f51fb09","label":1,"code":"\/**\r\n * @see javax.jcr.Value#getString()\r\n *\/\r\n@Override\r\npublic String getString() throws RepositoryException {\r\n    checkState(getType() != PropertyType.BINARY || stream == null, \"getStream has previously been called on this Value instance. \" + \"In this case a new Value instance must be acquired in order to successfully call this method.\");\r\n    switch(getType()) {\r\n        case PropertyType.NAME:\r\n            return namePathMapper.getJcrName(propertyState.getValue(Type.STRING, index));\r\n        case PropertyType.PATH:\r\n            String s = propertyState.getValue(Type.STRING, index);\r\n            if (s.startsWith(\"[\") && s.endsWith(\"]\")) {\r\n                \/\/ identifier paths are returned as-is (JCR 2.0, 3.4.3.1)\r\n                return s;\r\n            } else {\r\n                return namePathMapper.getJcrPath(s);\r\n            }\r\n        default:\r\n            return propertyState.getValue(Type.STRING, index);\r\n    }\r\n}","code_comment":"\/**\r\n * @see javax.jcr.Value#getString()\r\n *\/\r\n","code_no_comment":"@Override\r\npublic String getString() throws RepositoryException {\r\n    checkState(getType() != PropertyType.BINARY || stream == null, \"getStream has previously been called on this Value instance. \" + \"In this case a new Value instance must be acquired in order to successfully call this method.\");\r\n    switch(getType()) {\r\n        case PropertyType.NAME:\r\n            return namePathMapper.getJcrName(propertyState.getValue(Type.STRING, index));\r\n        case PropertyType.PATH:\r\n            String s = propertyState.getValue(Type.STRING, index);\r\n            if (s.startsWith(\"[\") && s.endsWith(\"]\")) {\r\n                                return s;\r\n            } else {\r\n                return namePathMapper.getJcrPath(s);\r\n            }\r\n        default:\r\n            return propertyState.getValue(Type.STRING, index);\r\n    }\r\n}","lc":0.1363636364,"pi":1.0669856459,"ma":0.2,"nbd":0.5,"ml":0.1666666667,"d":0.6349206349,"mi":-0.1689922481,"fo":0.3333333333,"r":-0.0263157895,"e":0.4632031489}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-499_61381ea2","label":3,"code":"private void read() throws ParseException {\r\n    currentTokenQuoted = false;\r\n    if (expected != null) {\r\n        expected.clear();\r\n    }\r\n    int[] types = characterTypes;\r\n    int i = parseIndex;\r\n    int type = types[i];\r\n    while (type == 0) {\r\n        type = types[++i];\r\n    }\r\n    int start = i;\r\n    char[] chars = statementChars;\r\n    char c = chars[i++];\r\n    currentToken = \"\";\r\n    switch(type) {\r\n        case CHAR_NAME:\r\n            while (true) {\r\n                type = types[i];\r\n                if (type != CHAR_NAME && type != CHAR_VALUE) {\r\n                    c = chars[i];\r\n                    if (supportSQL1 && c == ':') {\r\n                        i++;\r\n                        continue;\r\n                    }\r\n                    break;\r\n                }\r\n                i++;\r\n            }\r\n            currentToken = statement.substring(start, i);\r\n            if (currentToken.isEmpty()) {\r\n                throw getSyntaxError();\r\n            }\r\n            currentTokenType = IDENTIFIER;\r\n            parseIndex = i;\r\n            return;\r\n        case CHAR_SPECIAL_2:\r\n            if (types[i] == CHAR_SPECIAL_2) {\r\n                i++;\r\n            }\r\n        \/\/ fall through\r\n        case CHAR_SPECIAL_1:\r\n            currentToken = statement.substring(start, i);\r\n            switch(c) {\r\n                case '$':\r\n                    currentTokenType = PARAMETER;\r\n                    break;\r\n                case '+':\r\n                    currentTokenType = PLUS;\r\n                    break;\r\n                case '-':\r\n                    currentTokenType = MINUS;\r\n                    break;\r\n                case '(':\r\n                    currentTokenType = OPEN;\r\n                    break;\r\n                case ')':\r\n                    currentTokenType = CLOSE;\r\n                    break;\r\n                default:\r\n                    currentTokenType = KEYWORD;\r\n            }\r\n            parseIndex = i;\r\n            return;\r\n        case CHAR_VALUE:\r\n            long number = c - '0';\r\n            while (true) {\r\n                c = chars[i];\r\n                if (c < '0' || c > '9') {\r\n                    if (c == '.') {\r\n                        readDecimal(start, i);\r\n                        break;\r\n                    }\r\n                    if (c == 'E' || c == 'e') {\r\n                        readDecimal(start, i);\r\n                        break;\r\n                    }\r\n                    checkLiterals(false);\r\n                    currentValue = PropertyValues.newLong(number);\r\n                    currentTokenType = VALUE;\r\n                    currentToken = \"0\";\r\n                    parseIndex = i;\r\n                    break;\r\n                }\r\n                number = number * 10 + (c - '0');\r\n                if (number > Integer.MAX_VALUE) {\r\n                    readDecimal(start, i);\r\n                    break;\r\n                }\r\n                i++;\r\n            }\r\n            return;\r\n        case CHAR_DECIMAL:\r\n            if (types[i] != CHAR_VALUE) {\r\n                currentTokenType = KEYWORD;\r\n                currentToken = \".\";\r\n                parseIndex = i;\r\n                return;\r\n            }\r\n            readDecimal(i - 1, i);\r\n            return;\r\n        case CHAR_BRACKETED:\r\n            readString(i, ']');\r\n            currentTokenType = IDENTIFIER;\r\n            currentToken = currentValue.getValue(Type.STRING);\r\n            return;\r\n        case CHAR_STRING:\r\n            readString(i, '\\'');\r\n            return;\r\n        case CHAR_QUOTED:\r\n            readString(i, '\\\"');\r\n            if (supportSQL1) {\r\n                \/\/ for SQL-2, this is a literal, as defined in\r\n                \/\/ the JCR 2.0 spec, 6.7.34 Literal - UncastLiteral\r\n                \/\/ but for compatibility with Jackrabbit 2.x, for\r\n                \/\/ SQL-1, this is an identifier, as in ANSI SQL\r\n                \/\/ (not in the JCR 1.0 spec)\r\n                \/\/ (confusing isn't it?)\r\n                currentTokenType = IDENTIFIER;\r\n                currentToken = currentValue.getValue(Type.STRING);\r\n            }\r\n            return;\r\n        case CHAR_END:\r\n            currentToken = \"\";\r\n            currentTokenType = END;\r\n            parseIndex = i;\r\n            return;\r\n        default:\r\n            throw getSyntaxError();\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void read() throws ParseException {\r\n    currentTokenQuoted = false;\r\n    if (expected != null) {\r\n        expected.clear();\r\n    }\r\n    int[] types = characterTypes;\r\n    int i = parseIndex;\r\n    int type = types[i];\r\n    while (type == 0) {\r\n        type = types[++i];\r\n    }\r\n    int start = i;\r\n    char[] chars = statementChars;\r\n    char c = chars[i++];\r\n    currentToken = \"\";\r\n    switch(type) {\r\n        case CHAR_NAME:\r\n            while (true) {\r\n                type = types[i];\r\n                if (type != CHAR_NAME && type != CHAR_VALUE) {\r\n                    c = chars[i];\r\n                    if (supportSQL1 && c == ':') {\r\n                        i++;\r\n                        continue;\r\n                    }\r\n                    break;\r\n                }\r\n                i++;\r\n            }\r\n            currentToken = statement.substring(start, i);\r\n            if (currentToken.isEmpty()) {\r\n                throw getSyntaxError();\r\n            }\r\n            currentTokenType = IDENTIFIER;\r\n            parseIndex = i;\r\n            return;\r\n        case CHAR_SPECIAL_2:\r\n            if (types[i] == CHAR_SPECIAL_2) {\r\n                i++;\r\n            }\r\n                case CHAR_SPECIAL_1:\r\n            currentToken = statement.substring(start, i);\r\n            switch(c) {\r\n                case '$':\r\n                    currentTokenType = PARAMETER;\r\n                    break;\r\n                case '+':\r\n                    currentTokenType = PLUS;\r\n                    break;\r\n                case '-':\r\n                    currentTokenType = MINUS;\r\n                    break;\r\n                case '(':\r\n                    currentTokenType = OPEN;\r\n                    break;\r\n                case ')':\r\n                    currentTokenType = CLOSE;\r\n                    break;\r\n                default:\r\n                    currentTokenType = KEYWORD;\r\n            }\r\n            parseIndex = i;\r\n            return;\r\n        case CHAR_VALUE:\r\n            long number = c - '0';\r\n            while (true) {\r\n                c = chars[i];\r\n                if (c < '0' || c > '9') {\r\n                    if (c == '.') {\r\n                        readDecimal(start, i);\r\n                        break;\r\n                    }\r\n                    if (c == 'E' || c == 'e') {\r\n                        readDecimal(start, i);\r\n                        break;\r\n                    }\r\n                    checkLiterals(false);\r\n                    currentValue = PropertyValues.newLong(number);\r\n                    currentTokenType = VALUE;\r\n                    currentToken = \"0\";\r\n                    parseIndex = i;\r\n                    break;\r\n                }\r\n                number = number * 10 + (c - '0');\r\n                if (number > Integer.MAX_VALUE) {\r\n                    readDecimal(start, i);\r\n                    break;\r\n                }\r\n                i++;\r\n            }\r\n            return;\r\n        case CHAR_DECIMAL:\r\n            if (types[i] != CHAR_VALUE) {\r\n                currentTokenType = KEYWORD;\r\n                currentToken = \".\";\r\n                parseIndex = i;\r\n                return;\r\n            }\r\n            readDecimal(i - 1, i);\r\n            return;\r\n        case CHAR_BRACKETED:\r\n            readString(i, ']');\r\n            currentTokenType = IDENTIFIER;\r\n            currentToken = currentValue.getValue(Type.STRING);\r\n            return;\r\n        case CHAR_STRING:\r\n            readString(i, '\\'');\r\n            return;\r\n        case CHAR_QUOTED:\r\n            readString(i, '\\\"');\r\n            if (supportSQL1) {\r\n                                                                                                                currentTokenType = IDENTIFIER;\r\n                currentToken = currentValue.getValue(Type.STRING);\r\n            }\r\n            return;\r\n        case CHAR_END:\r\n            currentToken = \"\";\r\n            currentTokenType = END;\r\n            parseIndex = i;\r\n            return;\r\n        default:\r\n            throw getSyntaxError();\r\n    }\r\n}","lc":5.0,"pi":1.2966507177,"ma":8.0,"nbd":1.5,"ml":2.75,"d":2.2261904762,"mi":-1.5928118393,"fo":0.9166666667,"r":-0.0263157895,"e":9.6219936262}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4483_53442bb4","label":1,"code":"\/**\r\n *  Sets the given model.\r\n *  <p>\r\n *  WARNING: DO NOT OVERRIDE THIS METHOD UNLESS YOU HAVE A VERY GOOD REASON FOR IT. OVERRIDING\r\n *  THIS MIGHT OPEN UP SECURITY LEAKS AND BREAK BACK-BUTTON SUPPORT.\r\n *  <\/p>\r\n *\r\n *  @param model\r\n *             The model\r\n *  @return This\r\n *\/\r\npublic Component setDefaultModel(final IModel<?> model) {\r\n    IModel<?> prevModel = getModelImpl();\r\n    \/\/ Detach current model\r\n    if (prevModel != null) {\r\n        prevModel.detach();\r\n    }\r\n    IModel<?> wrappedModel = prevModel;\r\n    if (prevModel instanceof IWrapModel) {\r\n        wrappedModel = ((IWrapModel<?>) prevModel).getWrappedModel();\r\n    }\r\n    \/\/ Change model\r\n    if (wrappedModel != model) {\r\n        if (wrappedModel != null) {\r\n            addStateChange();\r\n        }\r\n        setModelImpl(wrap(model));\r\n    }\r\n    modelChanged();\r\n    return this;\r\n}","code_comment":"\/**\r\n *  Sets the given model.\r\n *  <p>\r\n *  WARNING: DO NOT OVERRIDE THIS METHOD UNLESS YOU HAVE A VERY GOOD REASON FOR IT. OVERRIDING\r\n *  THIS MIGHT OPEN UP SECURITY LEAKS AND BREAK BACK-BUTTON SUPPORT.\r\n *  <\/p>\r\n *\r\n *  @param model\r\n *             The model\r\n *  @return This\r\n *\/\r\n","code_no_comment":"public Component setDefaultModel(final IModel<?> model) {\r\n    IModel<?> prevModel = getModelImpl();\r\n        if (prevModel != null) {\r\n        prevModel.detach();\r\n    }\r\n    IModel<?> wrappedModel = prevModel;\r\n    if (prevModel instanceof IWrapModel) {\r\n        wrappedModel = ((IWrapModel<?>) prevModel).getWrappedModel();\r\n    }\r\n        if (wrappedModel != model) {\r\n        if (wrappedModel != null) {\r\n            addStateChange();\r\n        }\r\n        setModelImpl(wrap(model));\r\n    }\r\n    modelChanged();\r\n    return this;\r\n}","lc":0.1818181818,"pi":-0.033492823,"ma":0.2,"nbd":0.0,"ml":0.1666666667,"d":0.0079365079,"mi":-0.1092318534,"fo":0.0833333333,"r":0.7631578947,"e":-0.0330261694}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-738_8ed779dc","label":1,"code":"@Override\r\npublic Node perform() throws RepositoryException {\r\n    String oakPath = sessionContext.getOakPathOrThrowNotFound(relPath);\r\n    String oakName = PathUtils.getName(oakPath);\r\n    String parentPath = PathUtils.getParentPath(oakPath);\r\n    NodeDelegate parent = dlg.getChild(parentPath);\r\n    if (parent == null) {\r\n        \/\/ is it a property?\r\n        String grandParentPath = PathUtils.getParentPath(parentPath);\r\n        NodeDelegate grandParent = dlg.getChild(grandParentPath);\r\n        if (grandParent != null) {\r\n            String propName = PathUtils.getName(parentPath);\r\n            if (grandParent.getPropertyOrNull(propName) != null) {\r\n                throw new ConstraintViolationException(\"Can't add new node to property.\");\r\n            }\r\n        }\r\n        throw new PathNotFoundException(relPath);\r\n    }\r\n    if (parent.getChild(oakName) != null) {\r\n        throw new ItemExistsException(relPath);\r\n    }\r\n    String ntName = primaryNodeTypeName;\r\n    if (ntName == null) {\r\n        DefinitionProvider dp = getDefinitionProvider();\r\n        String childName = getOakName(PathUtils.getName(relPath));\r\n        NodeDefinition def = dp.getDefinition(parent.getTree(), childName);\r\n        ntName = def.getDefaultPrimaryTypeName();\r\n        if (ntName == null) {\r\n            throw new ConstraintViolationException(\"no matching child node definition found for \" + relPath);\r\n        }\r\n    }\r\n    \/\/ TODO: figure out the right place for this check\r\n    \/\/ throws on not found\r\n    NodeType nt = getNodeTypeManager().getNodeType(ntName);\r\n    if (nt.isAbstract() || nt.isMixin()) {\r\n        throw new ConstraintViolationException();\r\n    }\r\n    \/\/ TODO: END\r\n    NodeDelegate added = parent.addChild(oakName);\r\n    if (added == null) {\r\n        throw new ItemExistsException();\r\n    }\r\n    if (getPrimaryNodeType().hasOrderableChildNodes()) {\r\n        dlg.setOrderableChildren(true);\r\n    }\r\n    NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added, sessionContext);\r\n    childNode.internalSetPrimaryType(ntName);\r\n    childNode.autoCreateItems();\r\n    return childNode;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Node perform() throws RepositoryException {\r\n    String oakPath = sessionContext.getOakPathOrThrowNotFound(relPath);\r\n    String oakName = PathUtils.getName(oakPath);\r\n    String parentPath = PathUtils.getParentPath(oakPath);\r\n    NodeDelegate parent = dlg.getChild(parentPath);\r\n    if (parent == null) {\r\n                String grandParentPath = PathUtils.getParentPath(parentPath);\r\n        NodeDelegate grandParent = dlg.getChild(grandParentPath);\r\n        if (grandParent != null) {\r\n            String propName = PathUtils.getName(parentPath);\r\n            if (grandParent.getPropertyOrNull(propName) != null) {\r\n                throw new ConstraintViolationException(\"Can't add new node to property.\");\r\n            }\r\n        }\r\n        throw new PathNotFoundException(relPath);\r\n    }\r\n    if (parent.getChild(oakName) != null) {\r\n        throw new ItemExistsException(relPath);\r\n    }\r\n    String ntName = primaryNodeTypeName;\r\n    if (ntName == null) {\r\n        DefinitionProvider dp = getDefinitionProvider();\r\n        String childName = getOakName(PathUtils.getName(relPath));\r\n        NodeDefinition def = dp.getDefinition(parent.getTree(), childName);\r\n        ntName = def.getDefaultPrimaryTypeName();\r\n        if (ntName == null) {\r\n            throw new ConstraintViolationException(\"no matching child node definition found for \" + relPath);\r\n        }\r\n    }\r\n            NodeType nt = getNodeTypeManager().getNodeType(ntName);\r\n    if (nt.isAbstract() || nt.isMixin()) {\r\n        throw new ConstraintViolationException();\r\n    }\r\n        NodeDelegate added = parent.addChild(oakName);\r\n    if (added == null) {\r\n        throw new ItemExistsException();\r\n    }\r\n    if (getPrimaryNodeType().hasOrderableChildNodes()) {\r\n        dlg.setOrderableChildren(true);\r\n    }\r\n    NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added, sessionContext);\r\n    childNode.internalSetPrimaryType(ntName);\r\n    childNode.autoCreateItems();\r\n    return childNode;\r\n}","lc":1.4545454545,"pi":0.1531100478,"ma":2.4,"nbd":0.5,"ml":1.3333333333,"d":0.4841269841,"mi":-0.8666666667,"fo":1.5833333333,"r":-0.0263157895,"e":1.5528385286}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5570_57d8f051","label":1,"code":"private void clearTimeout(IHeaderResponse headerResponse) {\r\n    if (hasTimeout) {\r\n        hasTimeout = false;\r\n        String timeoutHandle = getTimeoutHandle();\r\n        headerResponse.render(OnLoadHeaderItem.forScript(\"clearTimeout(\" + timeoutHandle + \"); delete \" + timeoutHandle + \";\"));\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void clearTimeout(IHeaderResponse headerResponse) {\r\n    if (hasTimeout) {\r\n        hasTimeout = false;\r\n        String timeoutHandle = getTimeoutHandle();\r\n        headerResponse.render(OnLoadHeaderItem.forScript(\"clearTimeout(\" + timeoutHandle + \"); delete \" + timeoutHandle + \";\"));\r\n    }\r\n}","lc":-0.3181818182,"pi":0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1130952381,"mi":0.4164904863,"fo":-0.25,"r":0.7631578947,"e":-0.1102816341}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3388_0919a0f6","label":1,"code":"public Object evaluate(Exchange exchange) {\r\n    return exchange.getOut().getHeaders();\r\n}","code_comment":null,"code_no_comment":"public Object evaluate(Exchange exchange) {\r\n    return exchange.getOut().getHeaders();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0132487667,"fo":-0.3333333333,"r":1.0,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1877_716e1237","label":0,"code":"@Override\r\npublic synchronized void run() {\r\n    log.debug(\"Running background index task {}\", name);\r\n    if (isAlreadyRunning(store, name)) {\r\n        log.debug(\"The {} indexer is already running; skipping this update\", name);\r\n        return;\r\n    }\r\n    NodeState before;\r\n    NodeState root = store.getRoot();\r\n    String refCheckpoint = root.getChildNode(ASYNC).getString(name);\r\n    if (refCheckpoint != null) {\r\n        NodeState state = store.retrieve(refCheckpoint);\r\n        if (state == null) {\r\n            log.warn(\"Failed to retrieve previously indexed checkpoint {};\" + \" rerunning the initial {} index update\", refCheckpoint, name);\r\n            before = MISSING_NODE;\r\n        } else if (noVisibleChanges(state, root)) {\r\n            log.debug(\"No changes since last checkpoint;\" + \" skipping the {} index update\", name);\r\n            return;\r\n        } else {\r\n            before = state;\r\n        }\r\n    } else {\r\n        log.info(\"Initial {} index update\", name);\r\n        before = MISSING_NODE;\r\n    }\r\n    String checkpoint = store.checkpoint(lifetime);\r\n    NodeState after = store.retrieve(checkpoint);\r\n    if (after == null) {\r\n        log.warn(\"Unable to retrieve newly created checkpoint {},\" + \" skipping the {} index update\", checkpoint, name);\r\n        return;\r\n    }\r\n    NodeBuilder builder = store.getRoot().builder();\r\n    NodeBuilder async = builder.child(ASYNC);\r\n    AsyncUpdateCallback callback = new AsyncUpdateCallback();\r\n    preAsyncRunStatsStats(indexStats);\r\n    IndexUpdate indexUpdate = new IndexUpdate(provider, name, after, builder, callback);\r\n    CommitFailedException exception = EditorDiff.process(indexUpdate, before, after);\r\n    if (exception == null) {\r\n        if (callback.dirty) {\r\n            async.setProperty(name, checkpoint);\r\n            try {\r\n                store.merge(builder, newCommitHook(name, refCheckpoint), CommitInfo.EMPTY);\r\n            } catch (CommitFailedException e) {\r\n                if (e != CONCURRENT_UPDATE) {\r\n                    exception = e;\r\n                }\r\n            }\r\n            if (switchOnSync) {\r\n                reindexedDefinitions.addAll(indexUpdate.getReindexedDefinitions());\r\n            }\r\n        } else if (switchOnSync) {\r\n            log.debug(\"No changes detected after diff, will try to switch to synchronous updates on \" + reindexedDefinitions);\r\n            async.setProperty(name, checkpoint);\r\n            \/\/ no changes after diff, switch to sync on the async defs\r\n            for (String path : reindexedDefinitions) {\r\n                NodeBuilder c = builder;\r\n                for (String p : elements(path)) {\r\n                    c = c.getChildNode(p);\r\n                }\r\n                if (c.exists() && !c.getBoolean(REINDEX_PROPERTY_NAME)) {\r\n                    c.removeProperty(ASYNC_PROPERTY_NAME);\r\n                }\r\n            }\r\n            try {\r\n                store.merge(builder, newCommitHook(name, refCheckpoint), CommitInfo.EMPTY);\r\n                reindexedDefinitions.clear();\r\n            } catch (CommitFailedException e) {\r\n                if (e != CONCURRENT_UPDATE) {\r\n                    exception = e;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    postAsyncRunStatsStatus(indexStats);\r\n    \/\/ checkpoints cleanup\r\n    if (exception != null || (exception == null && !callback.dirty)) {\r\n        log.debug(\"The {} index update failed; releasing the related checkpoint {}\", name, checkpoint);\r\n        store.release(checkpoint);\r\n    } else {\r\n        if (refCheckpoint != null) {\r\n            log.debug(\"The {} index update succeeded; releasing the previous checkpoint {}\", name, refCheckpoint);\r\n            store.release(refCheckpoint);\r\n        }\r\n    }\r\n    if (exception != null) {\r\n        if (!failing) {\r\n            log.warn(\"Index update {} failed\", name, exception);\r\n        }\r\n        failing = true;\r\n    } else {\r\n        if (failing) {\r\n            log.info(\"Index update {} no longer fails\", name);\r\n        }\r\n        failing = false;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic synchronized void run() {\r\n    log.debug(\"Running background index task {}\", name);\r\n    if (isAlreadyRunning(store, name)) {\r\n        log.debug(\"The {} indexer is already running; skipping this update\", name);\r\n        return;\r\n    }\r\n    NodeState before;\r\n    NodeState root = store.getRoot();\r\n    String refCheckpoint = root.getChildNode(ASYNC).getString(name);\r\n    if (refCheckpoint != null) {\r\n        NodeState state = store.retrieve(refCheckpoint);\r\n        if (state == null) {\r\n            log.warn(\"Failed to retrieve previously indexed checkpoint {};\" + \" rerunning the initial {} index update\", refCheckpoint, name);\r\n            before = MISSING_NODE;\r\n        } else if (noVisibleChanges(state, root)) {\r\n            log.debug(\"No changes since last checkpoint;\" + \" skipping the {} index update\", name);\r\n            return;\r\n        } else {\r\n            before = state;\r\n        }\r\n    } else {\r\n        log.info(\"Initial {} index update\", name);\r\n        before = MISSING_NODE;\r\n    }\r\n    String checkpoint = store.checkpoint(lifetime);\r\n    NodeState after = store.retrieve(checkpoint);\r\n    if (after == null) {\r\n        log.warn(\"Unable to retrieve newly created checkpoint {},\" + \" skipping the {} index update\", checkpoint, name);\r\n        return;\r\n    }\r\n    NodeBuilder builder = store.getRoot().builder();\r\n    NodeBuilder async = builder.child(ASYNC);\r\n    AsyncUpdateCallback callback = new AsyncUpdateCallback();\r\n    preAsyncRunStatsStats(indexStats);\r\n    IndexUpdate indexUpdate = new IndexUpdate(provider, name, after, builder, callback);\r\n    CommitFailedException exception = EditorDiff.process(indexUpdate, before, after);\r\n    if (exception == null) {\r\n        if (callback.dirty) {\r\n            async.setProperty(name, checkpoint);\r\n            try {\r\n                store.merge(builder, newCommitHook(name, refCheckpoint), CommitInfo.EMPTY);\r\n            } catch (CommitFailedException e) {\r\n                if (e != CONCURRENT_UPDATE) {\r\n                    exception = e;\r\n                }\r\n            }\r\n            if (switchOnSync) {\r\n                reindexedDefinitions.addAll(indexUpdate.getReindexedDefinitions());\r\n            }\r\n        } else if (switchOnSync) {\r\n            log.debug(\"No changes detected after diff, will try to switch to synchronous updates on \" + reindexedDefinitions);\r\n            async.setProperty(name, checkpoint);\r\n                        for (String path : reindexedDefinitions) {\r\n                NodeBuilder c = builder;\r\n                for (String p : elements(path)) {\r\n                    c = c.getChildNode(p);\r\n                }\r\n                if (c.exists() && !c.getBoolean(REINDEX_PROPERTY_NAME)) {\r\n                    c.removeProperty(ASYNC_PROPERTY_NAME);\r\n                }\r\n            }\r\n            try {\r\n                store.merge(builder, newCommitHook(name, refCheckpoint), CommitInfo.EMPTY);\r\n                reindexedDefinitions.clear();\r\n            } catch (CommitFailedException e) {\r\n                if (e != CONCURRENT_UPDATE) {\r\n                    exception = e;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    postAsyncRunStatsStatus(indexStats);\r\n        if (exception != null || (exception == null && !callback.dirty)) {\r\n        log.debug(\"The {} index update failed; releasing the related checkpoint {}\", name, checkpoint);\r\n        store.release(checkpoint);\r\n    } else {\r\n        if (refCheckpoint != null) {\r\n            log.debug(\"The {} index update succeeded; releasing the previous checkpoint {}\", name, refCheckpoint);\r\n            store.release(refCheckpoint);\r\n        }\r\n    }\r\n    if (exception != null) {\r\n        if (!failing) {\r\n            log.warn(\"Index update {} failed\", name, exception);\r\n        }\r\n        failing = true;\r\n    } else {\r\n        if (failing) {\r\n            log.info(\"Index update {} no longer fails\", name);\r\n        }\r\n        failing = false;\r\n    }\r\n}","lc":3.6363636364,"pi":0.9282296651,"ma":3.6,"nbd":1.5,"ml":2.5,"d":1.2678571429,"mi":-1.3309372798,"fo":2.9166666667,"r":-0.0263157895,"e":6.325277917}
{"project_name":"Lang","project_version":"54","label":1,"code":"\/\/ -----------------------------------------------------------------------\r\n\/**\r\n * <p>Converts a String to a Locale.<\/p>\r\n *\r\n * <p>This method takes the string format of a locale and creates the\r\n * locale object from it.<\/p>\r\n *\r\n * <pre>\r\n *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\r\n *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\r\n *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\r\n * <\/pre>\r\n *\r\n * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\r\n * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\r\n * Thus, the result from getVariant() may vary depending on your JDK.<\/p>\r\n *\r\n * <p>This method validates the input strictly.\r\n * The language code must be lowercase.\r\n * The country code must be uppercase.\r\n * The separator must be an underscore.\r\n * The length must be correct.\r\n * <\/p>\r\n *\r\n * @param str  the locale String to convert, null returns null\r\n * @return a Locale, null if null input\r\n * @throws IllegalArgumentException if the string is an invalid format\r\n *\/\r\npublic static Locale toLocale(String str) {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    int len = str.length();\r\n    if (len != 2 && len != 5 && len < 7) {\r\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\r\n    }\r\n    char ch0 = str.charAt(0);\r\n    char ch1 = str.charAt(1);\r\n    if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\r\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\r\n    }\r\n    if (len == 2) {\r\n        return new Locale(str, \"\");\r\n    } else {\r\n        if (str.charAt(2) != '_') {\r\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\r\n        }\r\n        char ch3 = str.charAt(3);\r\n        char ch4 = str.charAt(4);\r\n        if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\r\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\r\n        }\r\n        if (len == 5) {\r\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\r\n        } else {\r\n            if (str.charAt(5) != '_') {\r\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\r\n            }\r\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * <p>Converts a String to a Locale.<\/p>\r\n *\r\n * <p>This method takes the string format of a locale and creates the\r\n * locale object from it.<\/p>\r\n *\r\n * <pre>\r\n *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\r\n *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\r\n *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\r\n * <\/pre>\r\n *\r\n * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\r\n * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\r\n * Thus, the result from getVariant() may vary depending on your JDK.<\/p>\r\n *\r\n * <p>This method validates the input strictly.\r\n * The language code must be lowercase.\r\n * The country code must be uppercase.\r\n * The separator must be an underscore.\r\n * The length must be correct.\r\n * <\/p>\r\n *\r\n * @param str  the locale String to convert, null returns null\r\n * @return a Locale, null if null input\r\n * @throws IllegalArgumentException if the string is an invalid format\r\n *\/\r\n","code_no_comment":"public static Locale toLocale(String str) {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    int len = str.length();\r\n    if (len != 2 && len != 5 && len < 7) {\r\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\r\n    }\r\n    char ch0 = str.charAt(0);\r\n    char ch1 = str.charAt(1);\r\n    if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\r\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\r\n    }\r\n    if (len == 2) {\r\n        return new Locale(str, \"\");\r\n    } else {\r\n        if (str.charAt(2) != '_') {\r\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\r\n        }\r\n        char ch3 = str.charAt(3);\r\n        char ch4 = str.charAt(4);\r\n        if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\r\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\r\n        }\r\n        if (len == 5) {\r\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\r\n        } else {\r\n            if (str.charAt(5) != '_') {\r\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\r\n            }\r\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\r\n        }\r\n    }\r\n}","lc":0.9090909091,"pi":0.3110047847,"ma":2.0,"nbd":0.5,"ml":1.5833333333,"d":2.2797619048,"mi":-0.6845665962,"fo":0.5,"r":-0.0263157895,"e":4.159999539}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-9673_7944093f","label":3,"code":"public void done(boolean doneSync) {\r\n    if (e == null) {\r\n        exchange.removeProperty(Exchange.FAILURE_ENDPOINT);\r\n    } else {\r\n        \/\/ set exception back on exchange\r\n        exchange.setException(e);\r\n        exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);\r\n    }\r\n    if (!doneSync) {\r\n        \/\/ signal callback to continue routing async\r\n        ExchangeHelper.prepareOutToIn(exchange);\r\n        LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n    }\r\n    callback.done(doneSync);\r\n}","code_comment":null,"code_no_comment":"public void done(boolean doneSync) {\r\n    if (e == null) {\r\n        exchange.removeProperty(Exchange.FAILURE_ENDPOINT);\r\n    } else {\r\n                exchange.setException(e);\r\n        exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);\r\n    }\r\n    if (!doneSync) {\r\n                ExchangeHelper.prepareOutToIn(exchange);\r\n        LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n    }\r\n    callback.done(doneSync);\r\n}","lc":-0.0454545455,"pi":-0.0956937799,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0515873016,"mi":0.0618745595,"fo":0.0833333333,"r":-0.0263157895,"e":-0.0604761328}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8081_2e985f9b","label":1,"code":"private void aggregateOnTheFly() throws InterruptedException, ExecutionException {\r\n    boolean timedOut = false;\r\n    boolean stoppedOnException = false;\r\n    final StopWatch watch = new StopWatch();\r\n    int aggregated = 0;\r\n    boolean done = false;\r\n    \/\/ not a for loop as on the fly may still run\r\n    while (!done) {\r\n        \/\/ check if we have already aggregate everything\r\n        if (allTasksSubmitted.get() && aggregated >= total.get()) {\r\n            LOG.debug(\"Done aggregating {} exchanges on the fly.\", aggregated);\r\n            break;\r\n        }\r\n        Future<Exchange> future;\r\n        if (timedOut) {\r\n            \/\/ we are timed out but try to grab if some tasks has been completed\r\n            \/\/ poll will return null if no tasks is present\r\n            future = completion.poll();\r\n            LOG.trace(\"Polled completion task #{} after timeout to grab already completed tasks: {}\", aggregated, future);\r\n        } else if (timeout > 0) {\r\n            long left = timeout - watch.taken();\r\n            if (left < 0) {\r\n                left = 0;\r\n            }\r\n            LOG.trace(\"Polling completion task #{} using timeout {} millis.\", aggregated, left);\r\n            future = completion.poll(left, TimeUnit.MILLISECONDS);\r\n        } else {\r\n            LOG.trace(\"Polling completion task #{}\", aggregated);\r\n            \/\/ we must not block so poll every second\r\n            future = completion.poll(1, TimeUnit.SECONDS);\r\n            if (future == null) {\r\n                \/\/ and continue loop which will recheck if we are done\r\n                continue;\r\n            }\r\n        }\r\n        if (future == null && timedOut) {\r\n            \/\/ we are timed out and no more tasks complete so break out\r\n            break;\r\n        } else if (future == null) {\r\n            \/\/ timeout occurred\r\n            AggregationStrategy strategy = getAggregationStrategy(null);\r\n            if (strategy instanceof TimeoutAwareAggregationStrategy) {\r\n                \/\/ notify the strategy we timed out\r\n                Exchange oldExchange = result.get();\r\n                if (oldExchange == null) {\r\n                    \/\/ if they all timed out the result may not have been set yet, so use the original exchange\r\n                    oldExchange = original;\r\n                }\r\n                ((TimeoutAwareAggregationStrategy) strategy).timeout(oldExchange, aggregated, total.intValue(), timeout);\r\n            } else {\r\n                \/\/ log a WARN we timed out since it will not be aggregated and the Exchange will be lost\r\n                LOG.warn(\"Parallel processing timed out after {} millis for number {}. This task will be cancelled and will not be aggregated.\", timeout, aggregated);\r\n            }\r\n            LOG.debug(\"Timeout occurred after {} millis for number {} task.\", timeout, aggregated);\r\n            timedOut = true;\r\n            \/\/ any already completed tasks in the next loop\r\n            if (completion instanceof SubmitOrderedCompletionService) {\r\n                ((SubmitOrderedCompletionService<?>) completion).timeoutTask();\r\n            }\r\n        } else {\r\n            \/\/ there is a result to aggregate\r\n            Exchange subExchange = future.get();\r\n            \/\/ Decide whether to continue with the multicast or not; similar logic to the Pipeline\r\n            Integer number = getExchangeIndex(subExchange);\r\n            boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Parallel processing failed for number \" + number, LOG);\r\n            if (stopOnException && !continueProcessing) {\r\n                \/\/ we want to stop on exception and an exception or failure occurred\r\n                \/\/ this is similar to what the pipeline does, so we should do the same to not surprise end users\r\n                \/\/ so we should set the failed exchange as the result and break out\r\n                result.set(subExchange);\r\n                stoppedOnException = true;\r\n                break;\r\n            }\r\n            \/\/ we got a result so aggregate it\r\n            AggregationStrategy strategy = getAggregationStrategy(subExchange);\r\n            doAggregate(strategy, result, subExchange);\r\n        }\r\n        aggregated++;\r\n    }\r\n    if (timedOut || stoppedOnException) {\r\n        if (timedOut) {\r\n            LOG.debug(\"Cancelling tasks due timeout after {} millis.\", timeout);\r\n        }\r\n        if (stoppedOnException) {\r\n            LOG.debug(\"Cancelling tasks due stopOnException.\");\r\n        }\r\n        \/\/ cancel tasks as we timed out (its safe to cancel done tasks)\r\n        running.set(false);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void aggregateOnTheFly() throws InterruptedException, ExecutionException {\r\n    boolean timedOut = false;\r\n    boolean stoppedOnException = false;\r\n    final StopWatch watch = new StopWatch();\r\n    int aggregated = 0;\r\n    boolean done = false;\r\n        while (!done) {\r\n                if (allTasksSubmitted.get() && aggregated >= total.get()) {\r\n            LOG.debug(\"Done aggregating {} exchanges on the fly.\", aggregated);\r\n            break;\r\n        }\r\n        Future<Exchange> future;\r\n        if (timedOut) {\r\n                                    future = completion.poll();\r\n            LOG.trace(\"Polled completion task #{} after timeout to grab already completed tasks: {}\", aggregated, future);\r\n        } else if (timeout > 0) {\r\n            long left = timeout - watch.taken();\r\n            if (left < 0) {\r\n                left = 0;\r\n            }\r\n            LOG.trace(\"Polling completion task #{} using timeout {} millis.\", aggregated, left);\r\n            future = completion.poll(left, TimeUnit.MILLISECONDS);\r\n        } else {\r\n            LOG.trace(\"Polling completion task #{}\", aggregated);\r\n                        future = completion.poll(1, TimeUnit.SECONDS);\r\n            if (future == null) {\r\n                                continue;\r\n            }\r\n        }\r\n        if (future == null && timedOut) {\r\n                        break;\r\n        } else if (future == null) {\r\n                        AggregationStrategy strategy = getAggregationStrategy(null);\r\n            if (strategy instanceof TimeoutAwareAggregationStrategy) {\r\n                                Exchange oldExchange = result.get();\r\n                if (oldExchange == null) {\r\n                                        oldExchange = original;\r\n                }\r\n                ((TimeoutAwareAggregationStrategy) strategy).timeout(oldExchange, aggregated, total.intValue(), timeout);\r\n            } else {\r\n                                LOG.warn(\"Parallel processing timed out after {} millis for number {}. This task will be cancelled and will not be aggregated.\", timeout, aggregated);\r\n            }\r\n            LOG.debug(\"Timeout occurred after {} millis for number {} task.\", timeout, aggregated);\r\n            timedOut = true;\r\n                        if (completion instanceof SubmitOrderedCompletionService) {\r\n                ((SubmitOrderedCompletionService<?>) completion).timeoutTask();\r\n            }\r\n        } else {\r\n                        Exchange subExchange = future.get();\r\n                        Integer number = getExchangeIndex(subExchange);\r\n            boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Parallel processing failed for number \" + number, LOG);\r\n            if (stopOnException && !continueProcessing) {\r\n                                                                result.set(subExchange);\r\n                stoppedOnException = true;\r\n                break;\r\n            }\r\n                        AggregationStrategy strategy = getAggregationStrategy(subExchange);\r\n            doAggregate(strategy, result, subExchange);\r\n        }\r\n        aggregated++;\r\n    }\r\n    if (timedOut || stoppedOnException) {\r\n        if (timedOut) {\r\n            LOG.debug(\"Cancelling tasks due timeout after {} millis.\", timeout);\r\n        }\r\n        if (stoppedOnException) {\r\n            LOG.debug(\"Cancelling tasks due stopOnException.\");\r\n        }\r\n                running.set(false);\r\n    }\r\n}","lc":2.5909090909,"pi":0.5358851675,"ma":3.2,"nbd":1.5,"ml":2.3333333333,"d":2.1785714286,"mi":-1.1381254405,"fo":1.6666666667,"r":-0.0263157895,"e":6.9360649597}
{"project_name":"Time","project_version":"14","label":2,"code":"\/\/ -----------------------------------------------------------------------\r\npublic int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\r\n    \/\/ 2004-02-29 + 48 months -> 2008-02-29 type dates\r\n    if (valueToAdd == 0) {\r\n        return values;\r\n    }\r\n    \/\/ month is largest field and being added to, such as month-day\r\n    if (DateTimeUtils.isContiguous(partial)) {\r\n        long instant = 0L;\r\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\r\n            instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\r\n        }\r\n        instant = add(instant, valueToAdd);\r\n        return iChronology.get(partial, instant);\r\n    } else {\r\n        return super.add(partial, fieldIndex, values, valueToAdd);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\r\n        if (valueToAdd == 0) {\r\n        return values;\r\n    }\r\n        if (DateTimeUtils.isContiguous(partial)) {\r\n        long instant = 0L;\r\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\r\n            instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\r\n        }\r\n        instant = add(instant, valueToAdd);\r\n        return iChronology.get(partial, instant);\r\n    } else {\r\n        return super.add(partial, fieldIndex, values, valueToAdd);\r\n    }\r\n}","lc":0.0454545455,"pi":0.1100478469,"ma":0.0,"nbd":0.0,"ml":0.25,"d":0.5476190476,"mi":-0.0928823115,"fo":0.1666666667,"r":0.0,"e":0.3622781994}
{"project_name":"Closure","project_version":"19","label":2,"code":"\/**\r\n * Declares a refined type in {@code scope} for the name represented by\r\n * {@code node}. It must be possible to refine the type of the given node in\r\n * the given scope, as determined by {@link #getTypeIfRefinable}.\r\n *\/\r\nprotected void declareNameInScope(FlowScope scope, Node node, JSType type) {\r\n    switch(node.getType()) {\r\n        case Token.NAME:\r\n            scope.inferSlotType(node.getString(), type);\r\n            break;\r\n        case Token.GETPROP:\r\n            String qualifiedName = node.getQualifiedName();\r\n            Preconditions.checkNotNull(qualifiedName);\r\n            JSType origType = node.getJSType();\r\n            origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\r\n            scope.inferQualifiedSlot(node, qualifiedName, origType, type);\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Node cannot be refined. \\n\" + node.toStringTree());\r\n    }\r\n}","code_comment":"\/**\r\n * Declares a refined type in {@code scope} for the name represented by\r\n * {@code node}. It must be possible to refine the type of the given node in\r\n * the given scope, as determined by {@link #getTypeIfRefinable}.\r\n *\/\r\n","code_no_comment":"protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\r\n    switch(node.getType()) {\r\n        case Token.NAME:\r\n            scope.inferSlotType(node.getString(), type);\r\n            break;\r\n        case Token.GETPROP:\r\n            String qualifiedName = node.getQualifiedName();\r\n            Preconditions.checkNotNull(qualifiedName);\r\n            JSType origType = node.getJSType();\r\n            origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\r\n            scope.inferQualifiedSlot(node, qualifiedName, origType, type);\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Node cannot be refined. \\n\" + node.toStringTree());\r\n    }\r\n}","lc":0.0909090909,"pi":0.6220095694,"ma":0.8,"nbd":0.0,"ml":0.0,"d":-0.0396825397,"mi":-0.1512332629,"fo":0.25,"r":-0.0263157895,"e":0.0285771915}
{"project_name":"Math","project_version":"4","label":1,"code":"\/**\r\n * Get the intersection of the instance and another sub-line.\r\n * <p>\r\n * This method is related to the {@link Line#intersection(Line)\r\n * intersection} method in the {@link Line Line} class, but in addition\r\n * to compute the point along infinite lines, it also checks the point\r\n * lies on both sub-line ranges.\r\n * <\/p>\r\n * @param subLine other sub-line which may intersect instance\r\n * @param includeEndPoints if true, endpoints are considered to belong to\r\n * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\r\n * are considered to not belong to instance (i.e. they are open sets) and intersection\r\n * occurring on endpoints lead to null being returned\r\n * @return the intersection point if there is one, null if the sub-lines don't intersect\r\n *\/\r\npublic Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\r\n    \/\/ compute the intersection on infinite line\r\n    Vector3D v1D = line.intersection(subLine.line);\r\n    \/\/ check location of point with respect to first sub-line\r\n    Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\r\n    \/\/ check location of point with respect to second sub-line\r\n    Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\r\n    if (includeEndPoints) {\r\n        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\r\n    } else {\r\n        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\r\n    }\r\n}","code_comment":"\/**\r\n * Get the intersection of the instance and another sub-line.\r\n * <p>\r\n * This method is related to the {@link Line#intersection(Line)\r\n * intersection} method in the {@link Line Line} class, but in addition\r\n * to compute the point along infinite lines, it also checks the point\r\n * lies on both sub-line ranges.\r\n * <\/p>\r\n * @param subLine other sub-line which may intersect instance\r\n * @param includeEndPoints if true, endpoints are considered to belong to\r\n * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\r\n * are considered to not belong to instance (i.e. they are open sets) and intersection\r\n * occurring on endpoints lead to null being returned\r\n * @return the intersection point if there is one, null if the sub-lines don't intersect\r\n *\/\r\n","code_no_comment":"public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\r\n        Vector3D v1D = line.intersection(subLine.line);\r\n        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\r\n        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\r\n    if (includeEndPoints) {\r\n        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\r\n    } else {\r\n        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\r\n    }\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":0.0,"nbd":-0.5,"ml":0.25,"d":0.6845238095,"mi":0.0985200846,"fo":-0.0833333333,"r":-0.0263157895,"e":0.4161223584}
{"project_name":"Closure","project_version":"64","label":2,"code":"\/**\r\n * Generates JavaScript source code for an AST, doesn't generate source\r\n * map info.\r\n *\/\r\n@Override\r\nString toSource(Node n) {\r\n    initCompilerOptionsIfTesting();\r\n    return toSource(n, null);\r\n}","code_comment":"\/**\r\n * Generates JavaScript source code for an AST, doesn't generate source\r\n * map info.\r\n *\/\r\n","code_no_comment":"@Override\r\nString toSource(Node n) {\r\n    initCompilerOptionsIfTesting();\r\n    return toSource(n, null);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7375616631,"fo":-0.3333333333,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7364_7bbb88ba","label":1,"code":"\/\/ Implementation\r\n\/\/ -------------------------------------------------------------------------\r\n\/**\r\n * Creates a {@link org.apache.camel.spi.RestConfiguration} instance based on the definition\r\n *\r\n * @param context     the camel context\r\n * @return the configuration\r\n * @throws Exception is thrown if error creating the configuration\r\n *\/\r\npublic RestConfiguration asRestConfiguration(CamelContext context) throws Exception {\r\n    RestConfiguration answer = new RestConfiguration();\r\n    if (getComponent() != null) {\r\n        answer.setComponent(CamelContextHelper.parseText(context, getComponent()));\r\n    }\r\n    if (getHost() != null) {\r\n        answer.setHost(CamelContextHelper.parseText(context, getHost()));\r\n    }\r\n    if (getPort() != null) {\r\n        answer.setPort(CamelContextHelper.parseInteger(context, getPort()));\r\n    }\r\n    \/*if (!properties.isEmpty()) {\r\n            Map<String, Object> props = new HashMap<String, Object>();\r\n            for (PropertyDefinition prop : properties) {\r\n                String key = prop.getKey();\r\n                String value = CamelContextHelper.parseText(context, prop.getValue());\r\n                props.put(key, value);\r\n            }\r\n            answer.setProperties(props);\r\n        }*\/\r\n    return answer;\r\n}","code_comment":"\/**\r\n * Creates a {@link org.apache.camel.spi.RestConfiguration} instance based on the definition\r\n *\r\n * @param context     the camel context\r\n * @return the configuration\r\n * @throws Exception is thrown if error creating the configuration\r\n *\/\r\n","code_no_comment":"public RestConfiguration asRestConfiguration(CamelContext context) throws Exception {\r\n    RestConfiguration answer = new RestConfiguration();\r\n    if (getComponent() != null) {\r\n        answer.setComponent(CamelContextHelper.parseText(context, getComponent()));\r\n    }\r\n    if (getHost() != null) {\r\n        answer.setHost(CamelContextHelper.parseText(context, getHost()));\r\n    }\r\n    if (getPort() != null) {\r\n        answer.setPort(CamelContextHelper.parseInteger(context, getPort()));\r\n    }\r\n        return answer;\r\n}","lc":-0.0454545455,"pi":-0.2535885167,"ma":0.0,"nbd":-0.5,"ml":0.0833333333,"d":0.0317460317,"mi":0.0350951374,"fo":0.5,"r":0.3684210526,"e":-0.0139531935}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3455_f30bd1cb","label":1,"code":"\/**\r\n *  Removes all children from this container.\r\n *  <p>\r\n *  Note: implementation does not call {@link MarkupContainer#remove(Component) } for each\r\n *  component.\r\n *\/\r\npublic final void removeAll() {\r\n    if (children != null) {\r\n        addStateChange();\r\n        \/\/ Loop through child components\r\n        int size = children_size();\r\n        for (int i = 0; i < size; i++) {\r\n            Object childObject = children_get(i, false);\r\n            if (childObject instanceof Component) {\r\n                \/\/ Get next child\r\n                final Component child = (Component) childObject;\r\n                \/\/ Do not call remove() because the state change would than be\r\n                \/\/ recorded twice.\r\n                child.detachModel();\r\n                child.setParent(null);\r\n            }\r\n        }\r\n        children = null;\r\n    }\r\n}","code_comment":"\/**\r\n *  Removes all children from this container.\r\n *  <p>\r\n *  Note: implementation does not call {@link MarkupContainer#remove(Component) } for each\r\n *  component.\r\n *\/\r\n","code_no_comment":"public final void removeAll() {\r\n    if (children != null) {\r\n        addStateChange();\r\n                int size = children_size();\r\n        for (int i = 0; i < size; i++) {\r\n            Object childObject = children_get(i, false);\r\n            if (childObject instanceof Component) {\r\n                                final Component child = (Component) childObject;\r\n                                                child.detachModel();\r\n                child.setParent(null);\r\n            }\r\n        }\r\n        children = null;\r\n    }\r\n}","lc":0.0454545455,"pi":1.009569378,"ma":0.0,"nbd":0.5,"ml":0.1666666667,"d":0.3353174603,"mi":-0.0350951374,"fo":-0.0833333333,"r":1.7368421053,"e":0.1087971047}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-699_b2e24119","label":3,"code":"public double value(double x) {\r\n    return cumulativeProbability(x) - p;\r\n}","code_comment":null,"code_no_comment":"public double value(double x) {\r\n    return cumulativeProbability(x) - p;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0451021846,"fo":-0.4166666667,"r":2.4473684211,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4816_66bfc885","label":1,"code":"\/**\r\n *  Strip any jsessionid and possibly other redundant info that might be in our way.\r\n *\r\n *  @param url\r\n *             The url to strip\r\n *  @return The stripped url\r\n *\/\r\npublic static String stripJSessionId(final String url) {\r\n    if (url == null) {\r\n        return null;\r\n    }\r\n    \/\/ http:\/\/...\/abc;jsessionid=...?param=...\r\n    int ixSemiColon = url.indexOf(\";\");\r\n    if (ixSemiColon == -1) {\r\n        return url;\r\n    }\r\n    int ixQuestionMark = url.indexOf(\"?\");\r\n    if (ixQuestionMark == -1) {\r\n        \/\/ http:\/\/...\/abc;jsession=...\r\n        return url.substring(0, ixSemiColon);\r\n    }\r\n    if (ixQuestionMark <= ixSemiColon) {\r\n        \/\/ ? is before ; - no jsessionid in the url\r\n        return url;\r\n    }\r\n    return url.substring(0, ixSemiColon) + url.substring(ixQuestionMark);\r\n}","code_comment":"\/**\r\n *  Strip any jsessionid and possibly other redundant info that might be in our way.\r\n *\r\n *  @param url\r\n *             The url to strip\r\n *  @return The stripped url\r\n *\/\r\n","code_no_comment":"public static String stripJSessionId(final String url) {\r\n    if (url == null) {\r\n        return null;\r\n    }\r\n        int ixSemiColon = url.indexOf(\";\");\r\n    if (ixSemiColon == -1) {\r\n        return url;\r\n    }\r\n    int ixQuestionMark = url.indexOf(\"?\");\r\n    if (ixQuestionMark == -1) {\r\n                return url.substring(0, ixSemiColon);\r\n    }\r\n    if (ixQuestionMark <= ixSemiColon) {\r\n                return url;\r\n    }\r\n    return url.substring(0, ixSemiColon) + url.substring(ixQuestionMark);\r\n}","lc":0.1363636364,"pi":-0.3157894737,"ma":0.2,"nbd":-0.5,"ml":0.1666666667,"d":0.7023809524,"mi":-0.1126145173,"fo":-0.0833333333,"r":-0.0263157895,"e":0.2926851196}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5398_19e7c1cd","label":3,"code":"\/**\r\n *  Reads and parses markup from an input stream, using UTF-8 encoding by default when not\r\n *  specified in XML declaration.\r\n *\r\n *  @param in\r\n *             The input stream to read and parse\r\n *  @throws IOException\r\n *\/\r\n@Override\r\npublic void parse(final InputStream in) throws IOException {\r\n    \/\/ When XML declaration does not specify encoding, it defaults to UTF-8\r\n    parse(in, \"UTF-8\");\r\n}","code_comment":"\/**\r\n *  Reads and parses markup from an input stream, using UTF-8 encoding by default when not\r\n *  specified in XML declaration.\r\n *\r\n *  @param in\r\n *             The input stream to read and parse\r\n *  @throws IOException\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void parse(final InputStream in) throws IOException {\r\n        parse(in, \"UTF-8\");\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8646934461,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2649_72d24f4b","label":3,"code":"private void copy(final FileReference reference) {\r\n    executor.execute(new Runnable() {\r\n\r\n        @Override\r\n        public void run() {\r\n            String name = reference.name;\r\n            try {\r\n                if (!local.fileExists(name)) {\r\n                    long start = System.currentTimeMillis();\r\n                    remote.copy(local, name, name, IOContext.READ);\r\n                    reference.markValid();\r\n                    downloadTime.addAndGet(System.currentTimeMillis() - start);\r\n                    downloadSize.addAndGet(remote.fileLength(name));\r\n                } else {\r\n                    long localLength = local.fileLength(name);\r\n                    long remoteLength = remote.fileLength(name);\r\n                    \/\/ updated but still do a check if the copy is consistent\r\n                    if (localLength != remoteLength) {\r\n                        log.warn(\"Found local copy for {} in {} but size of local {} differs from remote {}. \" + \"Content would be read from remote file only\", name, local, localLength, remoteLength);\r\n                        invalidFileCount.incrementAndGet();\r\n                    } else {\r\n                        reference.markValid();\r\n                    }\r\n                }\r\n            } catch (IOException e) {\r\n                \/\/ TODO In case of exception there would not be any other attempt\r\n                \/\/ to download the file. Look into support for retry\r\n                log.warn(\"Error occurred while copying file [{}] \" + \"from {} to {}\", name, remote, local, e);\r\n            }\r\n        }\r\n    });\r\n}","code_comment":null,"code_no_comment":"private void copy(final FileReference reference) {\r\n    executor.execute(new Runnable() {\r\n\r\n        @Override\r\n        public void run() {\r\n            String name = reference.name;\r\n            try {\r\n                if (!local.fileExists(name)) {\r\n                    long start = System.currentTimeMillis();\r\n                    remote.copy(local, name, name, IOContext.READ);\r\n                    reference.markValid();\r\n                    downloadTime.addAndGet(System.currentTimeMillis() - start);\r\n                    downloadSize.addAndGet(remote.fileLength(name));\r\n                } else {\r\n                    long localLength = local.fileLength(name);\r\n                    long remoteLength = remote.fileLength(name);\r\n                                        if (localLength != remoteLength) {\r\n                        log.warn(\"Found local copy for {} in {} but size of local {} differs from remote {}. \" + \"Content would be read from remote file only\", name, local, localLength, remoteLength);\r\n                        invalidFileCount.incrementAndGet();\r\n                    } else {\r\n                        reference.markValid();\r\n                    }\r\n                }\r\n            } catch (IOException e) {\r\n                                                log.warn(\"Error occurred while copying file [{}] \" + \"from {} to {}\", name, remote, local, e);\r\n            }\r\n        }\r\n    });\r\n}","lc":0.6363636364,"pi":1.9186602871,"ma":0.0,"nbd":1.0,"ml":0.0833333333,"d":0.4067460317,"mi":-0.4565186751,"fo":0.75,"r":-0.0263157895,"e":0.5960500913}
{"project_name":"Closure","project_version":"170","label":2,"code":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    if (n.isName() && n.getString().equals(varName) && \/\/ and remove this special case.\r\n    !(parent.isAssign() && (parent.getFirstChild() == n))) {\r\n        \/\/ Don't count lhs of top-level assignment chain\r\n        numUsesWithinCfgNode++;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    if (n.isName() && n.getString().equals(varName) &&     !(parent.isAssign() && (parent.getFirstChild() == n))) {\r\n                numUsesWithinCfgNode++;\r\n    }\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":0.4166666667,"d":0.1904761905,"mi":0.3863284003,"fo":-0.0833333333,"r":0.6578947368,"e":-0.0202186454}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4717_6a1b2f61","label":3,"code":"@Override\r\npublic void validate(IValidatable<V> validatable) {\r\n    R value = getValue(validatable);\r\n    final R min = getMinimum();\r\n    final R max = getMaximum();\r\n    if ((min != null && value.compareTo(min) < 0) || (max != null && value.compareTo(max) > 0)) {\r\n        ValidationError error = new ValidationError(this, getMode().getVariation());\r\n        if (min != null) {\r\n            error.setVariable(\"minimum\", min);\r\n        }\r\n        if (max != null) {\r\n            error.setVariable(\"maximum\", max);\r\n        }\r\n        validatable.error(decorate(error, validatable));\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void validate(IValidatable<V> validatable) {\r\n    R value = getValue(validatable);\r\n    final R min = getMinimum();\r\n    final R max = getMaximum();\r\n    if ((min != null && value.compareTo(min) < 0) || (max != null && value.compareTo(max) > 0)) {\r\n        ValidationError error = new ValidationError(this, getMode().getVariation());\r\n        if (min != null) {\r\n            error.setVariable(\"minimum\", min);\r\n        }\r\n        if (max != null) {\r\n            error.setVariable(\"maximum\", max);\r\n        }\r\n        validatable.error(decorate(error, validatable));\r\n    }\r\n}","lc":0.0909090909,"pi":0.3540669856,"ma":0.0,"nbd":0.0,"ml":0.4166666667,"d":0.875,"mi":-0.1548978154,"fo":0.4166666667,"r":0.0526315789,"e":0.7279657452}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4358_74cbba24","label":1,"code":"private void fillStackIfNeeded() {\r\n    for (; ; ) {\r\n        fetchNextDoc();\r\n        \/\/ no more changes to compare with\r\n        if (nextDoc == null) {\r\n            return;\r\n        }\r\n        \/\/ most recent revision of next document\r\n        if (!stack.isEmpty()) {\r\n            Revision top = stack.first();\r\n            if (top.compareRevisionTimeThenClusterId(nextRevision) > 0) {\r\n                return;\r\n            }\r\n        }\r\n        \/\/ if we get here, we need to pull in changes\r\n        \/\/ from nextDoc\r\n        Iterables.addAll(stack, nextDoc.getAllChanges());\r\n        nextDoc = null;\r\n        nextRevision = null;\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void fillStackIfNeeded() {\r\n    for (; ; ) {\r\n        fetchNextDoc();\r\n                if (nextDoc == null) {\r\n            return;\r\n        }\r\n                if (!stack.isEmpty()) {\r\n            Revision top = stack.first();\r\n            if (top.compareRevisionTimeThenClusterId(nextRevision) > 0) {\r\n                return;\r\n            }\r\n        }\r\n                        Iterables.addAll(stack, nextDoc.getAllChanges());\r\n        nextDoc = null;\r\n        nextRevision = null;\r\n    }\r\n}","lc":0.1363636364,"pi":0.5406698565,"ma":0.2,"nbd":0.5,"ml":0.1666666667,"d":0.2301587302,"mi":-0.0618745595,"fo":0.0,"r":1.1052631579,"e":0.0165349838}
{"project_name":"Closure","project_version":"25","label":2,"code":"private FlowScope traverseNew(Node n, FlowScope scope) {\r\n    Node constructor = n.getFirstChild();\r\n    scope = traverse(constructor, scope);\r\n    JSType constructorType = constructor.getJSType();\r\n    JSType type = null;\r\n    if (constructorType != null) {\r\n        constructorType = constructorType.restrictByNotNullOrUndefined();\r\n        if (constructorType.isUnknownType()) {\r\n            type = getNativeType(UNKNOWN_TYPE);\r\n        } else {\r\n            FunctionType ct = constructorType.toMaybeFunctionType();\r\n            if (ct == null && constructorType instanceof FunctionType) {\r\n                \/\/ If constructorType is a NoObjectType, then toMaybeFunctionType will\r\n                \/\/ return null. But NoObjectType implements the FunctionType\r\n                \/\/ interface, precisely because it can validly construct objects.\r\n                ct = (FunctionType) constructorType;\r\n            }\r\n            if (ct != null && ct.isConstructor()) {\r\n                type = ct.getInstanceType();\r\n            }\r\n        }\r\n    }\r\n    n.setJSType(type);\r\n    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\r\n        scope = traverse(arg, scope);\r\n    }\r\n    return scope;\r\n}","code_comment":null,"code_no_comment":"private FlowScope traverseNew(Node n, FlowScope scope) {\r\n    Node constructor = n.getFirstChild();\r\n    scope = traverse(constructor, scope);\r\n    JSType constructorType = constructor.getJSType();\r\n    JSType type = null;\r\n    if (constructorType != null) {\r\n        constructorType = constructorType.restrictByNotNullOrUndefined();\r\n        if (constructorType.isUnknownType()) {\r\n            type = getNativeType(UNKNOWN_TYPE);\r\n        } else {\r\n            FunctionType ct = constructorType.toMaybeFunctionType();\r\n            if (ct == null && constructorType instanceof FunctionType) {\r\n                                                                ct = (FunctionType) constructorType;\r\n            }\r\n            if (ct != null && ct.isConstructor()) {\r\n                type = ct.getInstanceType();\r\n            }\r\n        }\r\n    }\r\n    n.setJSType(type);\r\n    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\r\n        scope = traverse(arg, scope);\r\n    }\r\n    return scope;\r\n}","lc":0.5,"pi":0.7129186603,"ma":0.4,"nbd":0.5,"ml":0.5833333333,"d":0.6567460317,"mi":-0.4156448203,"fo":0.5833333333,"r":-0.0263157895,"e":0.828245247}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-4513_9e05f77f","label":3,"code":"public void process(Exchange exchange) throws Exception {\r\n    BeanProcessor processor = new BeanProcessor(beanHolder);\r\n    if (methodName != null) {\r\n        processor.setMethod(methodName);\r\n        \/\/ enable OGNL like invocation\r\n        processor.setShorthandMethod(true);\r\n    }\r\n    try {\r\n        \/\/ copy the original exchange to avoid side effects on it\r\n        Exchange resultExchange = exchange.copy();\r\n        \/\/ force to use InOut to retrieve the result on the OUT message\r\n        resultExchange.setPattern(ExchangePattern.InOut);\r\n        processor.process(resultExchange);\r\n        result = resultExchange.getOut().getBody();\r\n        \/\/ propagate exceptions\r\n        if (resultExchange.getException() != null) {\r\n            exchange.setException(resultExchange.getException());\r\n        }\r\n    } catch (Exception e) {\r\n        throw new RuntimeBeanExpressionException(exchange, beanName, methodName, e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void process(Exchange exchange) throws Exception {\r\n    BeanProcessor processor = new BeanProcessor(beanHolder);\r\n    if (methodName != null) {\r\n        processor.setMethod(methodName);\r\n                processor.setShorthandMethod(true);\r\n    }\r\n    try {\r\n                Exchange resultExchange = exchange.copy();\r\n                resultExchange.setPattern(ExchangePattern.InOut);\r\n        processor.process(resultExchange);\r\n        result = resultExchange.getOut().getBody();\r\n                if (resultExchange.getException() != null) {\r\n            exchange.setException(resultExchange.getException());\r\n        }\r\n    } catch (Exception e) {\r\n        throw new RuntimeBeanExpressionException(exchange, beanName, methodName, e);\r\n    }\r\n}","lc":0.1818181818,"pi":0.033492823,"ma":0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0138888889,"mi":-0.1811134602,"fo":0.3333333333,"r":0.0,"e":0.0371893063}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3079_33c18762","label":1,"code":"\/**\r\n * Determines the last committed modification to the given document by\r\n * a {@code clusterId}.\r\n *\r\n * @param doc a document.\r\n * @param clusterId clusterId for which the last committed modification is\r\n *                  looked up.\r\n * @return the commit revision of the last modification by {@code clusterId}\r\n *          to the given document.\r\n *\/\r\n@CheckForNull\r\nprivate Revision determineLastModification(NodeDocument doc, int clusterId) {\r\n    ClusterPredicate cp = new ClusterPredicate(clusterId);\r\n    \/\/ Merge sort the revs for which changes have been made\r\n    \/\/ to this doc\r\n    \/\/ localMap always keeps the most recent valid commit entry\r\n    \/\/ per cluster node so looking into that should be sufficient\r\n    Iterable<Revision> revs = mergeSorted(of(filter(doc.getLocalCommitRoot().keySet(), cp), filter(doc.getLocalRevisions().keySet(), cp)), StableRevisionComparator.REVERSE);\r\n    Revision lastModified = null;\r\n    \/\/ Look for latest valid revision\r\n    for (Revision rev : revs) {\r\n        lastModified = Utils.max(lastModified, doc.getCommitRevision(rev));\r\n    }\r\n    return lastModified;\r\n}","code_comment":"\/**\r\n * Determines the last committed modification to the given document by\r\n * a {@code clusterId}.\r\n *\r\n * @param doc a document.\r\n * @param clusterId clusterId for which the last committed modification is\r\n *                  looked up.\r\n * @return the commit revision of the last modification by {@code clusterId}\r\n *          to the given document.\r\n *\/\r\n","code_no_comment":"@CheckForNull\r\nprivate Revision determineLastModification(NodeDocument doc, int clusterId) {\r\n    ClusterPredicate cp = new ClusterPredicate(clusterId);\r\n                    Iterable<Revision> revs = mergeSorted(of(filter(doc.getLocalCommitRoot().keySet(), cp), filter(doc.getLocalRevisions().keySet(), cp)), StableRevisionComparator.REVERSE);\r\n    Revision lastModified = null;\r\n        for (Revision rev : revs) {\r\n        lastModified = Utils.max(lastModified, doc.getCommitRevision(rev));\r\n    }\r\n    return lastModified;\r\n}","lc":-0.1818181818,"pi":-0.2822966507,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.125017618,"fo":0.3333333333,"r":0.0526315789,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8954_7b1253db","label":3,"code":"\/**\r\n * Creates a copy based on the source\r\n *\r\n * @param source the source\r\n * @return a copy of the source\r\n *\/\r\n@SuppressWarnings(\"unchecked\")\r\npublic GenericFile<T> copyFrom(GenericFile<T> source) {\r\n    GenericFile<T> result;\r\n    try {\r\n        result = source.getClass().newInstance();\r\n    } catch (Exception e) {\r\n        throw ObjectHelper.wrapRuntimeCamelException(e);\r\n    }\r\n    result.setEndpointPath(source.getEndpointPath());\r\n    result.setAbsolute(source.isAbsolute());\r\n    result.setDirectory(source.isDirectory());\r\n    result.setAbsoluteFilePath(source.getAbsoluteFilePath());\r\n    result.setRelativeFilePath(source.getRelativeFilePath());\r\n    result.setFileName(source.getFileName());\r\n    result.setFileNameOnly(source.getFileNameOnly());\r\n    result.setFileLength(source.getFileLength());\r\n    result.setLastModified(source.getLastModified());\r\n    result.setFile(source.getFile());\r\n    result.setBody(source.getBody());\r\n    result.setBinding(source.getBinding());\r\n    result.setCharset(source.getCharset());\r\n    copyFromPopulateAdditional(source, result);\r\n    return result;\r\n}","code_comment":"\/**\r\n * Creates a copy based on the source\r\n *\r\n * @param source the source\r\n * @return a copy of the source\r\n *\/\r\n","code_no_comment":"@SuppressWarnings(\"unchecked\")\r\npublic GenericFile<T> copyFrom(GenericFile<T> source) {\r\n    GenericFile<T> result;\r\n    try {\r\n        result = source.getClass().newInstance();\r\n    } catch (Exception e) {\r\n        throw ObjectHelper.wrapRuntimeCamelException(e);\r\n    }\r\n    result.setEndpointPath(source.getEndpointPath());\r\n    result.setAbsolute(source.isAbsolute());\r\n    result.setDirectory(source.isDirectory());\r\n    result.setAbsoluteFilePath(source.getAbsoluteFilePath());\r\n    result.setRelativeFilePath(source.getRelativeFilePath());\r\n    result.setFileName(source.getFileName());\r\n    result.setFileNameOnly(source.getFileNameOnly());\r\n    result.setFileLength(source.getFileLength());\r\n    result.setLastModified(source.getLastModified());\r\n    result.setFile(source.getFile());\r\n    result.setBody(source.getBody());\r\n    result.setBinding(source.getBinding());\r\n    result.setCharset(source.getCharset());\r\n    copyFromPopulateAdditional(source, result);\r\n    return result;\r\n}","lc":0.4545454545,"pi":-0.5598086124,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.3787174066,"fo":2.0,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-644_55a4f738","label":3,"code":"@Override\r\npublic CommitHook getCommitHook(String workspaceName) {\r\n    return new CompositeHook(new PermissionHook(workspaceName), new VersionablePathHook(workspaceName));\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic CommitHook getCommitHook(String workspaceName) {\r\n    return new CompositeHook(new PermissionHook(workspaceName), new VersionablePathHook(workspaceName));\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8173361522,"fo":-0.5,"r":1.0526315789,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3242_15e83709","label":1,"code":"public static void recursiveCopyPersistent(ZooKeeperConnectionInfo info, String source, String destination, NodeExistsPolicy policy) throws KeeperException, InterruptedException {\r\n    Stat stat = null;\r\n    if (!exists(info, source))\r\n        throw KeeperException.create(Code.NONODE, source);\r\n    if (exists(info, destination)) {\r\n        switch(policy) {\r\n            case OVERWRITE:\r\n                break;\r\n            case SKIP:\r\n                return;\r\n            case FAIL:\r\n            default:\r\n                throw KeeperException.create(Code.NODEEXISTS, source);\r\n        }\r\n    }\r\n    stat = new Stat();\r\n    byte[] data = getData(info, source, stat);\r\n    if (stat.getEphemeralOwner() == 0) {\r\n        if (data == null)\r\n            throw KeeperException.create(Code.NONODE, source);\r\n        putPersistentData(info, destination, data, policy);\r\n        if (stat.getNumChildren() > 0) {\r\n            List<String> children;\r\n            final Retry retry = RETRY_FACTORY.create();\r\n            while (true) {\r\n                try {\r\n                    children = getZooKeeper(info).getChildren(source, false);\r\n                    break;\r\n                } catch (KeeperException e) {\r\n                    final Code c = e.code();\r\n                    if (c == Code.CONNECTIONLOSS || c == Code.OPERATIONTIMEOUT || c == Code.SESSIONEXPIRED) {\r\n                        retryOrThrow(retry, e);\r\n                    } else {\r\n                        throw e;\r\n                    }\r\n                }\r\n                retry.waitForNextAttempt();\r\n            }\r\n            for (String child : children) recursiveCopyPersistent(info, source + \"\/\" + child, destination + \"\/\" + child, policy);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public static void recursiveCopyPersistent(ZooKeeperConnectionInfo info, String source, String destination, NodeExistsPolicy policy) throws KeeperException, InterruptedException {\r\n    Stat stat = null;\r\n    if (!exists(info, source))\r\n        throw KeeperException.create(Code.NONODE, source);\r\n    if (exists(info, destination)) {\r\n        switch(policy) {\r\n            case OVERWRITE:\r\n                break;\r\n            case SKIP:\r\n                return;\r\n            case FAIL:\r\n            default:\r\n                throw KeeperException.create(Code.NODEEXISTS, source);\r\n        }\r\n    }\r\n    stat = new Stat();\r\n    byte[] data = getData(info, source, stat);\r\n    if (stat.getEphemeralOwner() == 0) {\r\n        if (data == null)\r\n            throw KeeperException.create(Code.NONODE, source);\r\n        putPersistentData(info, destination, data, policy);\r\n        if (stat.getNumChildren() > 0) {\r\n            List<String> children;\r\n            final Retry retry = RETRY_FACTORY.create();\r\n            while (true) {\r\n                try {\r\n                    children = getZooKeeper(info).getChildren(source, false);\r\n                    break;\r\n                } catch (KeeperException e) {\r\n                    final Code c = e.code();\r\n                    if (c == Code.CONNECTIONLOSS || c == Code.OPERATIONTIMEOUT || c == Code.SESSIONEXPIRED) {\r\n                        retryOrThrow(retry, e);\r\n                    } else {\r\n                        throw e;\r\n                    }\r\n                }\r\n                retry.waitForNextAttempt();\r\n            }\r\n            for (String child : children) recursiveCopyPersistent(info, source + \"\/\" + child, destination + \"\/\" + child, policy);\r\n        }\r\n    }\r\n}","lc":1.2727272727,"pi":1.6028708134,"ma":3.2,"nbd":1.5,"ml":1.4166666667,"d":0.9900793651,"mi":-0.8212825934,"fo":0.8333333333,"r":-0.0263157895,"e":2.0736547893}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-189_6dbbdc21","label":3,"code":"@Override\r\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\r\n    RegExFilter result = new RegExFilter();\r\n    result.setSource(getSource().deepCopy(env));\r\n    result.rowMatcher = rowMatcher.pattern().matcher(\"\");\r\n    result.colfMatcher = colfMatcher.pattern().matcher(\"\");\r\n    result.colqMatcher = colqMatcher.pattern().matcher(\"\");\r\n    result.valueMatcher = valueMatcher.pattern().matcher(\"\");\r\n    result.orFields = orFields;\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\r\n    RegExFilter result = new RegExFilter();\r\n    result.setSource(getSource().deepCopy(env));\r\n    result.rowMatcher = rowMatcher.pattern().matcher(\"\");\r\n    result.colfMatcher = colfMatcher.pattern().matcher(\"\");\r\n    result.colqMatcher = colqMatcher.pattern().matcher(\"\");\r\n    result.valueMatcher = valueMatcher.pattern().matcher(\"\");\r\n    result.orFields = orFields;\r\n    return result;\r\n}","lc":-0.1363636364,"pi":-0.5789473684,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.0858350951,"fo":0.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Math","project_version":"8","label":1,"code":"\/**\r\n * Generate a random sample from the distribution.\r\n *\r\n * @param sampleSize the number of random values to generate.\r\n * @return an array representing the random sample.\r\n * @throws NotStrictlyPositiveException if {@code sampleSize} is not\r\n * positive.\r\n *\/\r\npublic T[] sample(int sampleSize) throws NotStrictlyPositiveException {\r\n    if (sampleSize <= 0) {\r\n        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);\r\n    }\r\n    final T[] out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\r\n    for (int i = 0; i < sampleSize; i++) {\r\n        out[i] = sample();\r\n    }\r\n    return out;\r\n}","code_comment":"\/**\r\n * Generate a random sample from the distribution.\r\n *\r\n * @param sampleSize the number of random values to generate.\r\n * @return an array representing the random sample.\r\n * @throws NotStrictlyPositiveException if {@code sampleSize} is not\r\n * positive.\r\n *\/\r\n","code_no_comment":"public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\r\n    if (sampleSize <= 0) {\r\n        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize);\r\n    }\r\n    final T[] out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\r\n    for (int i = 0; i < sampleSize; i++) {\r\n        out[i] = sample();\r\n    }\r\n    return out;\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":0.3630952381,"mi":0.1439041579,"fo":-0.1666666667,"r":0.5,"e":0.1312079667}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2065_9da430fb","label":1,"code":"\/**\r\n *  @see org.apache.wicket.request.target.coding.IRequestTargetUrlCodingStrategy#encode(org.apache.wicket.IRequestTarget)\r\n *\/\r\npublic final CharSequence encode(IRequestTarget requestTarget) {\r\n    if (!(requestTarget instanceof IBookmarkablePageRequestTarget)) {\r\n        throw new IllegalArgumentException(\"this encoder can only be used with instances of \" + IBookmarkablePageRequestTarget.class.getName());\r\n    }\r\n    AppendingStringBuffer url = new AppendingStringBuffer(40);\r\n    url.append(getMountPath());\r\n    IBookmarkablePageRequestTarget target = (IBookmarkablePageRequestTarget) requestTarget;\r\n    url.append(\"\/\").append(Classes.simpleName(target.getPageClass())).append(\"\/\");\r\n    PageParameters pageParameters = target.getPageParameters();\r\n    if (target.getPageMapName() != null) {\r\n        pageParameters.put(WebRequestCodingStrategy.PAGEMAP, WebRequestCodingStrategy.encodePageMapName(target.getPageMapName()));\r\n    }\r\n    appendParameters(url, pageParameters);\r\n    return url;\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.request.target.coding.IRequestTargetUrlCodingStrategy#encode(org.apache.wicket.IRequestTarget)\r\n *\/\r\n","code_no_comment":"public final CharSequence encode(IRequestTarget requestTarget) {\r\n    if (!(requestTarget instanceof IBookmarkablePageRequestTarget)) {\r\n        throw new IllegalArgumentException(\"this encoder can only be used with instances of \" + IBookmarkablePageRequestTarget.class.getName());\r\n    }\r\n    AppendingStringBuffer url = new AppendingStringBuffer(40);\r\n    url.append(getMountPath());\r\n    IBookmarkablePageRequestTarget target = (IBookmarkablePageRequestTarget) requestTarget;\r\n    url.append(\"\/\").append(Classes.simpleName(target.getPageClass())).append(\"\/\");\r\n    PageParameters pageParameters = target.getPageParameters();\r\n    if (target.getPageMapName() != null) {\r\n        pageParameters.put(WebRequestCodingStrategy.PAGEMAP, WebRequestCodingStrategy.encodePageMapName(target.getPageMapName()));\r\n    }\r\n    appendParameters(url, pageParameters);\r\n    return url;\r\n}","lc":0.0454545455,"pi":-0.4401913876,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":0.3333333333,"mi":-0.1148696265,"fo":0.6666666667,"r":-0.0263157895,"e":0.3034548734}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"@Override\r\npublic Status getStatus() {\r\n    root.checkLive();\r\n    if (isDisconnected()) {\r\n        return Status.DISCONNECTED;\r\n    }\r\n    NodeBuilder builder = getNodeBuilder();\r\n    if (builder.isNew()) {\r\n        return Status.NEW;\r\n    } else if (builder.isModified()) {\r\n        return Status.MODIFIED;\r\n    } else {\r\n        return Status.EXISTING;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Status getStatus() {\r\n    root.checkLive();\r\n    if (isDisconnected()) {\r\n        return Status.DISCONNECTED;\r\n    }\r\n    NodeBuilder builder = getNodeBuilder();\r\n    if (builder.isNew()) {\r\n        return Status.NEW;\r\n    } else if (builder.isModified()) {\r\n        return Status.MODIFIED;\r\n    } else {\r\n        return Status.EXISTING;\r\n    }\r\n}","lc":0.0454545455,"pi":-0.1291866029,"ma":0.0,"nbd":0.0,"ml":0.0833333333,"d":-0.3650793651,"mi":0.0489076815,"fo":-0.0833333333,"r":0.1842105263,"e":-0.1627934049}
{"project_name":"Lang","project_version":"27","label":1,"code":"\/\/ -----------------------------------------------------------------------\r\n\/\/ must handle Long, Float, Integer, Float, Short,\r\n\/\/ BigDecimal, BigInteger and Byte\r\n\/\/ useful methods:\r\n\/\/ Byte.decode(String)\r\n\/\/ Byte.valueOf(String,int radix)\r\n\/\/ Byte.valueOf(String)\r\n\/\/ Double.valueOf(String)\r\n\/\/ Float.valueOf(String)\r\n\/\/ new Float(String)\r\n\/\/ Integer.valueOf(String,int radix)\r\n\/\/ Integer.valueOf(String)\r\n\/\/ Integer.decode(String)\r\n\/\/ Integer.getInteger(String)\r\n\/\/ Integer.getInteger(String,int val)\r\n\/\/ Integer.getInteger(String,Integer val)\r\n\/\/ new Integer(String)\r\n\/\/ new Double(String)\r\n\/\/ new Byte(String)\r\n\/\/ new Long(String)\r\n\/\/ Long.getLong(String)\r\n\/\/ Long.getLong(String,int)\r\n\/\/ Long.getLong(String,Integer)\r\n\/\/ Long.valueOf(String,int)\r\n\/\/ Long.valueOf(String)\r\n\/\/ new Short(String)\r\n\/\/ Short.decode(String)\r\n\/\/ Short.valueOf(String,int)\r\n\/\/ Short.valueOf(String)\r\n\/\/ new BigDecimal(String)\r\n\/\/ new BigInteger(String)\r\n\/\/ new BigInteger(String,int radix)\r\n\/\/ Possible inputs:\r\n\/\/ 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\r\n\/\/ plus minus everything. Prolly more. A lot are not separable.\r\n\/**\r\n * <p>Turns a string value into a java.lang.Number.<\/p>\r\n *\r\n * <p>First, the value is examined for a type qualifier on the end\r\n * (<code>'f','F','d','D','l','L'<\/code>).  If it is found, it starts\r\n * trying to create successively larger types from the type specified\r\n * until one is found that can represent the value.<\/p>\r\n *\r\n * <p>If a type specifier is not found, it will check for a decimal point\r\n * and then try successively larger types from <code>Integer<\/code> to\r\n * <code>BigInteger<\/code> and from <code>Float<\/code> to\r\n * <code>BigDecimal<\/code>.<\/p>\r\n *\r\n * <p>If the string starts with <code>0x<\/code> or <code>-0x<\/code>, it\r\n * will be interpreted as a hexadecimal integer.  Values with leading\r\n * <code>0<\/code>'s will not be interpreted as octal.<\/p>\r\n *\r\n * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\r\n *\r\n * <p>This method does not trim the input string, i.e., strings with leading\r\n * or trailing spaces will generate NumberFormatExceptions.<\/p>\r\n *\r\n * @param str  String containing a number, may be null\r\n * @return Number created from the string\r\n * @throws NumberFormatException if the value cannot be converted\r\n *\/\r\npublic static Number createNumber(String str) throws NumberFormatException {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    if (StringUtils.isBlank(str)) {\r\n        throw new NumberFormatException(\"A blank string is not a valid number\");\r\n    }\r\n    if (str.startsWith(\"--\")) {\r\n        \/\/ a wrong value.\r\n        return null;\r\n    }\r\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\r\n        return createInteger(str);\r\n    }\r\n    char lastChar = str.charAt(str.length() - 1);\r\n    String mant;\r\n    String dec;\r\n    String exp;\r\n    int decPos = str.indexOf('.');\r\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\r\n    if (decPos > -1) {\r\n        if (expPos > -1) {\r\n            if (expPos < decPos) {\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            }\r\n            dec = str.substring(decPos + 1, expPos);\r\n        } else {\r\n            dec = str.substring(decPos + 1);\r\n        }\r\n        mant = str.substring(0, decPos);\r\n    } else {\r\n        if (expPos > -1) {\r\n            mant = str.substring(0, expPos);\r\n        } else {\r\n            mant = str;\r\n        }\r\n        dec = null;\r\n    }\r\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\r\n        if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length() - 1);\r\n        } else {\r\n            exp = null;\r\n        }\r\n        \/\/ Requesting a specific type..\r\n        String numeric = str.substring(0, str.length() - 1);\r\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n        switch(lastChar) {\r\n            case 'l':\r\n            case 'L':\r\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\r\n                    try {\r\n                        return createLong(numeric);\r\n                    } catch (NumberFormatException nfe) {\r\n                    \/\/ Too big for a long\r\n                    }\r\n                    return createBigInteger(numeric);\r\n                }\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            case 'f':\r\n            case 'F':\r\n                try {\r\n                    Float f = NumberUtils.createFloat(numeric);\r\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                        \/\/ has non-zeros in it, then float does not have the precision we want\r\n                        return f;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                \/\/ ignore the bad number\r\n                }\r\n            \/\/ $FALL-THROUGH$\r\n            case 'd':\r\n            case 'D':\r\n                try {\r\n                    Double d = NumberUtils.createDouble(numeric);\r\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\r\n                        return d;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                \/\/ ignore the bad number\r\n                }\r\n                try {\r\n                    return createBigDecimal(numeric);\r\n                } catch (NumberFormatException e) {\r\n                \/\/ ignore the bad number\r\n                }\r\n            \/\/ $FALL-THROUGH$\r\n            default:\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n        }\r\n    } else {\r\n        \/\/ small and go from there...\r\n        if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length());\r\n        } else {\r\n            exp = null;\r\n        }\r\n        if (dec == null && exp == null) {\r\n            \/\/ Must be an int,long,bigint\r\n            try {\r\n                return createInteger(str);\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ ignore the bad number\r\n            }\r\n            try {\r\n                return createLong(str);\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ ignore the bad number\r\n            }\r\n            return createBigInteger(str);\r\n        } else {\r\n            \/\/ Must be a float,double,BigDec\r\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n            try {\r\n                Float f = createFloat(str);\r\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                    return f;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ ignore the bad number\r\n            }\r\n            try {\r\n                Double d = createDouble(str);\r\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\r\n                    return d;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n            \/\/ ignore the bad number\r\n            }\r\n            return createBigDecimal(str);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * <p>Turns a string value into a java.lang.Number.<\/p>\r\n *\r\n * <p>First, the value is examined for a type qualifier on the end\r\n * (<code>'f','F','d','D','l','L'<\/code>).  If it is found, it starts\r\n * trying to create successively larger types from the type specified\r\n * until one is found that can represent the value.<\/p>\r\n *\r\n * <p>If a type specifier is not found, it will check for a decimal point\r\n * and then try successively larger types from <code>Integer<\/code> to\r\n * <code>BigInteger<\/code> and from <code>Float<\/code> to\r\n * <code>BigDecimal<\/code>.<\/p>\r\n *\r\n * <p>If the string starts with <code>0x<\/code> or <code>-0x<\/code>, it\r\n * will be interpreted as a hexadecimal integer.  Values with leading\r\n * <code>0<\/code>'s will not be interpreted as octal.<\/p>\r\n *\r\n * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\r\n *\r\n * <p>This method does not trim the input string, i.e., strings with leading\r\n * or trailing spaces will generate NumberFormatExceptions.<\/p>\r\n *\r\n * @param str  String containing a number, may be null\r\n * @return Number created from the string\r\n * @throws NumberFormatException if the value cannot be converted\r\n *\/\r\n","code_no_comment":"public static Number createNumber(String str) throws NumberFormatException {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    if (StringUtils.isBlank(str)) {\r\n        throw new NumberFormatException(\"A blank string is not a valid number\");\r\n    }\r\n    if (str.startsWith(\"--\")) {\r\n                return null;\r\n    }\r\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\r\n        return createInteger(str);\r\n    }\r\n    char lastChar = str.charAt(str.length() - 1);\r\n    String mant;\r\n    String dec;\r\n    String exp;\r\n    int decPos = str.indexOf('.');\r\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\r\n    if (decPos > -1) {\r\n        if (expPos > -1) {\r\n            if (expPos < decPos) {\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            }\r\n            dec = str.substring(decPos + 1, expPos);\r\n        } else {\r\n            dec = str.substring(decPos + 1);\r\n        }\r\n        mant = str.substring(0, decPos);\r\n    } else {\r\n        if (expPos > -1) {\r\n            mant = str.substring(0, expPos);\r\n        } else {\r\n            mant = str;\r\n        }\r\n        dec = null;\r\n    }\r\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\r\n        if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length() - 1);\r\n        } else {\r\n            exp = null;\r\n        }\r\n                String numeric = str.substring(0, str.length() - 1);\r\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n        switch(lastChar) {\r\n            case 'l':\r\n            case 'L':\r\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\r\n                    try {\r\n                        return createLong(numeric);\r\n                    } catch (NumberFormatException nfe) {\r\n                                        }\r\n                    return createBigInteger(numeric);\r\n                }\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            case 'f':\r\n            case 'F':\r\n                try {\r\n                    Float f = NumberUtils.createFloat(numeric);\r\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                                                return f;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                                }\r\n                        case 'd':\r\n            case 'D':\r\n                try {\r\n                    Double d = NumberUtils.createDouble(numeric);\r\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\r\n                        return d;\r\n                    }\r\n                } catch (NumberFormatException nfe) {\r\n                                }\r\n                try {\r\n                    return createBigDecimal(numeric);\r\n                } catch (NumberFormatException e) {\r\n                                }\r\n                        default:\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n        }\r\n    } else {\r\n                if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length());\r\n        } else {\r\n            exp = null;\r\n        }\r\n        if (dec == null && exp == null) {\r\n                        try {\r\n                return createInteger(str);\r\n            } catch (NumberFormatException nfe) {\r\n                        }\r\n            try {\r\n                return createLong(str);\r\n            } catch (NumberFormatException nfe) {\r\n                        }\r\n            return createBigInteger(str);\r\n        } else {\r\n                        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n            try {\r\n                Float f = createFloat(str);\r\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                    return f;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n                        }\r\n            try {\r\n                Double d = createDouble(str);\r\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\r\n                    return d;\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n                        }\r\n            return createBigDecimal(str);\r\n        }\r\n    }\r\n}","lc":4.6818181818,"pi":1.2057416268,"ma":6.6,"nbd":1.5,"ml":4.8333333333,"d":3.8591269841,"mi":-1.5527836505,"fo":3.6666666667,"r":-0.0263157895,"e":19.6774168266}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1496_0a4c7694","label":1,"code":"\/\/ TODO This is a work-around for the union reader\r\nboolean hasInputChannelWithData() {\r\n    return !inputChannelsWithData.isEmpty();\r\n}","code_comment":null,"code_no_comment":"boolean hasInputChannelWithData() {\r\n    return !inputChannelsWithData.isEmpty();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.4166666667,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-766_6fc5ea9d","label":1,"code":"\/**\r\n * Get a tree for the tree identified by {@code path}.\r\n *\r\n * @param path the path to the child\r\n * @return a {@link Tree} instance for the child at {@code path} or\r\n *         {@code null} if no such tree exits or if the tree is not accessible.\r\n *\/\r\n@CheckForNull\r\nTreeImpl getTree(String path) {\r\n    checkArgument(PathUtils.isAbsolute(path));\r\n    TreeImpl child = this;\r\n    for (String name : elements(path)) {\r\n        child = child.internalGetChild(name);\r\n        if (child == null) {\r\n            return null;\r\n        }\r\n    }\r\n    return (canRead(child)) ? child : null;\r\n}","code_comment":"\/**\r\n * Get a tree for the tree identified by {@code path}.\r\n *\r\n * @param path the path to the child\r\n * @return a {@link Tree} instance for the child at {@code path} or\r\n *         {@code null} if no such tree exits or if the tree is not accessible.\r\n *\/\r\n","code_no_comment":"@CheckForNull\r\nTreeImpl getTree(String path) {\r\n    checkArgument(PathUtils.isAbsolute(path));\r\n    TreeImpl child = this;\r\n    for (String name : elements(path)) {\r\n        child = child.internalGetChild(name);\r\n        if (child == null) {\r\n            return null;\r\n        }\r\n    }\r\n    return (canRead(child)) ? child : null;\r\n}","lc":-0.0909090909,"pi":0.2870813397,"ma":0.0,"nbd":0.0,"ml":-0.0833333333,"d":-0.0079365079,"mi":0.11205074,"fo":-0.0833333333,"r":0.5263157895,"e":-0.061033984}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1364_05c89637","label":1,"code":"private Entry<K, V> find(Object key) {\r\n    int hash = getHash(key);\r\n    return getSegment(hash).find(key, hash);\r\n}","code_comment":null,"code_no_comment":"private Entry<K, V> find(Object key) {\r\n    int hash = getHash(key);\r\n    return getSegment(hash).find(key, hash);\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7496828753,"fo":-0.25,"r":0.1315789474,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-9666_da035952","label":3,"code":"public Exchange copy(boolean safeCopy) {\r\n    DefaultExchange exchange = new DefaultExchange(this);\r\n    if (hasProperties()) {\r\n        exchange.setProperties(safeCopyProperties(getProperties()));\r\n    }\r\n    if (safeCopy) {\r\n        exchange.getIn().setBody(getIn().getBody());\r\n        if (getIn().hasHeaders()) {\r\n            exchange.getIn().setHeaders(safeCopyHeaders(getIn().getHeaders()));\r\n            \/\/ just copy the attachments here\r\n            exchange.getIn().copyAttachments(getIn());\r\n        }\r\n        if (hasOut()) {\r\n            exchange.getOut().setBody(getOut().getBody());\r\n            if (getOut().hasHeaders()) {\r\n                exchange.getOut().setHeaders(safeCopyHeaders(getOut().getHeaders()));\r\n            }\r\n            \/\/ Just copy the attachments here\r\n            exchange.getOut().copyAttachments(getOut());\r\n        }\r\n    } else {\r\n        \/\/ old way of doing copy which is @deprecated\r\n        \/\/ TODO: remove this in Camel 3.0, and always do a safe copy\r\n        exchange.setIn(getIn().copy());\r\n        if (hasOut()) {\r\n            exchange.setOut(getOut().copy());\r\n        }\r\n    }\r\n    exchange.setException(getException());\r\n    return exchange;\r\n}","code_comment":null,"code_no_comment":"public Exchange copy(boolean safeCopy) {\r\n    DefaultExchange exchange = new DefaultExchange(this);\r\n    if (hasProperties()) {\r\n        exchange.setProperties(safeCopyProperties(getProperties()));\r\n    }\r\n    if (safeCopy) {\r\n        exchange.getIn().setBody(getIn().getBody());\r\n        if (getIn().hasHeaders()) {\r\n            exchange.getIn().setHeaders(safeCopyHeaders(getIn().getHeaders()));\r\n                        exchange.getIn().copyAttachments(getIn());\r\n        }\r\n        if (hasOut()) {\r\n            exchange.getOut().setBody(getOut().getBody());\r\n            if (getOut().hasHeaders()) {\r\n                exchange.getOut().setHeaders(safeCopyHeaders(getOut().getHeaders()));\r\n            }\r\n                        exchange.getOut().copyAttachments(getOut());\r\n        }\r\n    } else {\r\n                        exchange.setIn(getIn().copy());\r\n        if (hasOut()) {\r\n            exchange.setOut(getOut().copy());\r\n        }\r\n    }\r\n    exchange.setException(getException());\r\n    return exchange;\r\n}","lc":0.5909090909,"pi":0.4736842105,"ma":0.6,"nbd":0.5,"ml":0.5,"d":-0.3650793651,"mi":-0.4029598309,"fo":3.0,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-234_2d7d6311","label":1,"code":"@Override\r\npublic Result filter(final Logger logger, final Level level, final Marker marker, final Message msg, final Throwable t) {\r\n    final String text = useRawMessage ? msg.getFormat() : msg.getFormattedMessage();\r\n    return filter(text);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Result filter(final Logger logger, final Level level, final Marker marker, final Message msg, final Throwable t) {\r\n    final String text = useRawMessage ? msg.getFormat() : msg.getFormattedMessage();\r\n    return filter(text);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.3650793651,"mi":0.5492600423,"fo":-0.25,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5571_0e87b84f","label":1,"code":"public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\r\n    BeanInvocation invocation = new BeanInvocation(method, args);\r\n    MethodInfo methodInfo = methodInfoCache.getMethodInfo(method);\r\n    final ExchangePattern pattern = methodInfo != null ? methodInfo.getPattern() : ExchangePattern.InOut;\r\n    return invokeWithbody(method, invocation, pattern);\r\n}","code_comment":null,"code_no_comment":"public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\r\n    BeanInvocation invocation = new BeanInvocation(method, args);\r\n    MethodInfo methodInfo = methodInfoCache.getMethodInfo(method);\r\n    final ExchangePattern pattern = methodInfo != null ? methodInfo.getPattern() : ExchangePattern.InOut;\r\n    return invokeWithbody(method, invocation, pattern);\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.0476190476,"mi":0.4021141649,"fo":-0.25,"r":0.0526315789,"e":-0.0443722158}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3143_ddd2c3bc","label":0,"code":"\/**\r\n * Reads the fields in the {@link DataInput} into the current object\r\n *\r\n * @param dataInput\r\n *          the input fields to read into the current object\r\n *\/\r\n@Override\r\npublic void readFields(DataInput dataInput) throws IOException {\r\n    \/\/ load iterators\r\n    long iterSize = dataInput.readInt();\r\n    if (iterSize > 0)\r\n        iterators = new ArrayList<IteratorSetting>();\r\n    for (int i = 0; i < iterSize; i++) iterators.add(new IteratorSetting(dataInput));\r\n    \/\/ load ranges\r\n    long rangeSize = dataInput.readInt();\r\n    if (rangeSize > 0)\r\n        ranges = new ArrayList<Range>();\r\n    for (int i = 0; i < rangeSize; i++) {\r\n        Range range = new Range();\r\n        range.readFields(dataInput);\r\n        ranges.add(range);\r\n    }\r\n    \/\/ load columns\r\n    long columnSize = dataInput.readInt();\r\n    if (columnSize > 0)\r\n        columns = new HashSet<Pair<Text, Text>>();\r\n    for (int i = 0; i < columnSize; i++) {\r\n        long numPairs = dataInput.readInt();\r\n        Text colFam = new Text();\r\n        colFam.readFields(dataInput);\r\n        if (numPairs == 1) {\r\n            columns.add(new Pair<Text, Text>(colFam, null));\r\n        } else if (numPairs == 2) {\r\n            Text colQual = new Text();\r\n            colQual.readFields(dataInput);\r\n            columns.add(new Pair<Text, Text>(colFam, colQual));\r\n        }\r\n    }\r\n    autoAdjustRanges = dataInput.readBoolean();\r\n    useLocalIterators = dataInput.readBoolean();\r\n    useIsolatedScanners = dataInput.readBoolean();\r\n}","code_comment":"\/**\r\n * Reads the fields in the {@link DataInput} into the current object\r\n *\r\n * @param dataInput\r\n *          the input fields to read into the current object\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void readFields(DataInput dataInput) throws IOException {\r\n        long iterSize = dataInput.readInt();\r\n    if (iterSize > 0)\r\n        iterators = new ArrayList<IteratorSetting>();\r\n    for (int i = 0; i < iterSize; i++) iterators.add(new IteratorSetting(dataInput));\r\n        long rangeSize = dataInput.readInt();\r\n    if (rangeSize > 0)\r\n        ranges = new ArrayList<Range>();\r\n    for (int i = 0; i < rangeSize; i++) {\r\n        Range range = new Range();\r\n        range.readFields(dataInput);\r\n        ranges.add(range);\r\n    }\r\n        long columnSize = dataInput.readInt();\r\n    if (columnSize > 0)\r\n        columns = new HashSet<Pair<Text, Text>>();\r\n    for (int i = 0; i < columnSize; i++) {\r\n        long numPairs = dataInput.readInt();\r\n        Text colFam = new Text();\r\n        colFam.readFields(dataInput);\r\n        if (numPairs == 1) {\r\n            columns.add(new Pair<Text, Text>(colFam, null));\r\n        } else if (numPairs == 2) {\r\n            Text colQual = new Text();\r\n            colQual.readFields(dataInput);\r\n            columns.add(new Pair<Text, Text>(colFam, colQual));\r\n        }\r\n    }\r\n    autoAdjustRanges = dataInput.readBoolean();\r\n    useLocalIterators = dataInput.readBoolean();\r\n    useIsolatedScanners = dataInput.readBoolean();\r\n}","lc":0.8636363636,"pi":0.1387559809,"ma":1.0,"nbd":0.5,"ml":0.6666666667,"d":0.8611111111,"mi":-0.6329809725,"fo":0.6666666667,"r":-0.0263157895,"e":1.7666245973}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1227_117b0a3d","label":1,"code":"@Override\r\npublic boolean hasProperty(String relPath) throws RepositoryException {\r\n    final String oakPath = getOakPathOrThrow(relPath);\r\n    return perform(new NodeOperation<Boolean>(dlg) {\r\n\r\n        @Override\r\n        public Boolean perform() throws RepositoryException {\r\n            return node.getPropertyOrNull(oakPath) != null;\r\n        }\r\n    });\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean hasProperty(String relPath) throws RepositoryException {\r\n    final String oakPath = getOakPathOrThrow(relPath);\r\n    return perform(new NodeOperation<Boolean>(dlg) {\r\n\r\n        @Override\r\n        public Boolean perform() throws RepositoryException {\r\n            return node.getPropertyOrNull(oakPath) != null;\r\n        }\r\n    });\r\n}","lc":-0.1818181818,"pi":0.4449760766,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.0734126984,"mi":0.2473572939,"fo":-0.25,"r":1.5526315789,"e":-0.0964598353}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4933_469d0096","label":1,"code":"public void unalignFromBaseDirectory(Model model, File basedir) {\r\n    Build build = model.getBuild();\r\n    if (build != null) {\r\n        build.setDirectory(unalignFromBaseDirectory(build.getDirectory(), basedir));\r\n        build.setSourceDirectory(unalignFromBaseDirectory(build.getSourceDirectory(), basedir));\r\n        build.setTestSourceDirectory(unalignFromBaseDirectory(build.getTestSourceDirectory(), basedir));\r\n        for (Resource resource : build.getResources()) {\r\n            resource.setDirectory(unalignFromBaseDirectory(resource.getDirectory(), basedir));\r\n        }\r\n        for (Resource resource : build.getTestResources()) {\r\n            resource.setDirectory(unalignFromBaseDirectory(resource.getDirectory(), basedir));\r\n        }\r\n        if (build.getFilters() != null) {\r\n            List<String> filters = new ArrayList<String>();\r\n            for (String filter : build.getFilters()) {\r\n                filters.add(unalignFromBaseDirectory(filter, basedir));\r\n            }\r\n            build.setFilters(filters);\r\n        }\r\n        build.setOutputDirectory(unalignFromBaseDirectory(build.getOutputDirectory(), basedir));\r\n        build.setTestOutputDirectory(unalignFromBaseDirectory(build.getTestOutputDirectory(), basedir));\r\n    }\r\n    Reporting reporting = model.getReporting();\r\n    if (reporting != null) {\r\n        reporting.setOutputDirectory(unalignFromBaseDirectory(reporting.getOutputDirectory(), basedir));\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void unalignFromBaseDirectory(Model model, File basedir) {\r\n    Build build = model.getBuild();\r\n    if (build != null) {\r\n        build.setDirectory(unalignFromBaseDirectory(build.getDirectory(), basedir));\r\n        build.setSourceDirectory(unalignFromBaseDirectory(build.getSourceDirectory(), basedir));\r\n        build.setTestSourceDirectory(unalignFromBaseDirectory(build.getTestSourceDirectory(), basedir));\r\n        for (Resource resource : build.getResources()) {\r\n            resource.setDirectory(unalignFromBaseDirectory(resource.getDirectory(), basedir));\r\n        }\r\n        for (Resource resource : build.getTestResources()) {\r\n            resource.setDirectory(unalignFromBaseDirectory(resource.getDirectory(), basedir));\r\n        }\r\n        if (build.getFilters() != null) {\r\n            List<String> filters = new ArrayList<String>();\r\n            for (String filter : build.getFilters()) {\r\n                filters.add(unalignFromBaseDirectory(filter, basedir));\r\n            }\r\n            build.setFilters(filters);\r\n        }\r\n        build.setOutputDirectory(unalignFromBaseDirectory(build.getOutputDirectory(), basedir));\r\n        build.setTestOutputDirectory(unalignFromBaseDirectory(build.getTestOutputDirectory(), basedir));\r\n    }\r\n    Reporting reporting = model.getReporting();\r\n    if (reporting != null) {\r\n        reporting.setOutputDirectory(unalignFromBaseDirectory(reporting.getOutputDirectory(), basedir));\r\n    }\r\n}","lc":0.5909090909,"pi":0.3684210526,"ma":0.6,"nbd":0.5,"ml":0.0833333333,"d":0.1686507937,"mi":-0.4897815363,"fo":2.25,"r":-0.0263157895,"e":0.4822438524}
{"project_name":"Math","project_version":"71","label":0,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\r\n    sanityChecks(equations, t0, y0, t, y);\r\n    setEquations(equations);\r\n    resetEvaluations();\r\n    final boolean forward = t > t0;\r\n    \/\/ create some internal working arrays\r\n    final int stages = c.length + 1;\r\n    if (y != y0) {\r\n        System.arraycopy(y0, 0, y, 0, y0.length);\r\n    }\r\n    final double[][] yDotK = new double[stages][y0.length];\r\n    final double[] yTmp = new double[y0.length];\r\n    \/\/ set up an interpolator sharing the integrator arrays\r\n    AbstractStepInterpolator interpolator;\r\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\r\n        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\r\n        rki.reinitialize(this, yTmp, yDotK, forward);\r\n        interpolator = rki;\r\n    } else {\r\n        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\r\n    }\r\n    interpolator.storeTime(t0);\r\n    \/\/ set up integration control objects\r\n    stepStart = t0;\r\n    double hNew = 0;\r\n    boolean firstTime = true;\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.reset();\r\n    }\r\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\r\n    boolean lastStep = false;\r\n    \/\/ main integration loop\r\n    while (!lastStep) {\r\n        interpolator.shift();\r\n        double error = 0;\r\n        for (boolean loop = true; loop; ) {\r\n            if (firstTime || !fsal) {\r\n                \/\/ first stage\r\n                computeDerivatives(stepStart, y, yDotK[0]);\r\n            }\r\n            if (firstTime) {\r\n                final double[] scale = new double[y0.length];\r\n                if (vecAbsoluteTolerance == null) {\r\n                    for (int i = 0; i < scale.length; ++i) {\r\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\r\n                    }\r\n                } else {\r\n                    for (int i = 0; i < scale.length; ++i) {\r\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\r\n                    }\r\n                }\r\n                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\r\n                firstTime = false;\r\n            }\r\n            stepSize = hNew;\r\n            \/\/ next stages\r\n            for (int k = 1; k < stages; ++k) {\r\n                for (int j = 0; j < y0.length; ++j) {\r\n                    double sum = a[k - 1][0] * yDotK[0][j];\r\n                    for (int l = 1; l < k; ++l) {\r\n                        sum += a[k - 1][l] * yDotK[l][j];\r\n                    }\r\n                    yTmp[j] = y[j] + stepSize * sum;\r\n                }\r\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\r\n            }\r\n            \/\/ estimate the state at the end of the step\r\n            for (int j = 0; j < y0.length; ++j) {\r\n                double sum = b[0] * yDotK[0][j];\r\n                for (int l = 1; l < stages; ++l) {\r\n                    sum += b[l] * yDotK[l][j];\r\n                }\r\n                yTmp[j] = y[j] + stepSize * sum;\r\n            }\r\n            \/\/ estimate the error at the end of the step\r\n            error = estimateError(yDotK, y, yTmp, stepSize);\r\n            if (error <= 1.0) {\r\n                \/\/ discrete events handling\r\n                interpolator.storeTime(stepStart + stepSize);\r\n                if (manager.evaluateStep(interpolator)) {\r\n                    final double dt = manager.getEventTime() - stepStart;\r\n                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\r\n                        \/\/ we cannot simply truncate the step, reject the current computation\r\n                        \/\/ and let the loop compute another state with the truncated step.\r\n                        \/\/ it is so small (much probably exactly 0 due to limited accuracy)\r\n                        \/\/ that the code above would fail handling it.\r\n                        \/\/ So we set up an artificial 0 size step by copying states\r\n                        loop = false;\r\n                    } else {\r\n                        \/\/ reject the step to match exactly the next switch time\r\n                        hNew = dt;\r\n                    }\r\n                } else {\r\n                    \/\/ accept the step\r\n                    loop = false;\r\n                }\r\n            } else {\r\n                \/\/ reject the step and attempt to reduce error by stepsize control\r\n                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\r\n                hNew = filterStep(stepSize * factor, forward, false);\r\n            }\r\n        }\r\n        \/\/ the step has been accepted\r\n        final double nextStep = stepStart + stepSize;\r\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\r\n        manager.stepAccepted(nextStep, y);\r\n        lastStep = manager.stop();\r\n        \/\/ provide the step data to the step handler\r\n        interpolator.storeTime(nextStep);\r\n        for (StepHandler handler : stepHandlers) {\r\n            handler.handleStep(interpolator, lastStep);\r\n        }\r\n        stepStart = nextStep;\r\n        if (fsal) {\r\n            \/\/ save the last evaluation for the next step\r\n            System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\r\n        }\r\n        if (manager.reset(stepStart, y) && !lastStep) {\r\n            \/\/ some event handler has triggered changes that\r\n            \/\/ invalidate the derivatives, we need to recompute them\r\n            computeDerivatives(stepStart, y, yDotK[0]);\r\n        }\r\n        if (!lastStep) {\r\n            \/\/ in some rare cases we may get here with stepSize = 0, for example\r\n            \/\/ when an event occurs at integration start, reducing the first step\r\n            \/\/ to zero; we have to reset the step to some safe non zero value\r\n            stepSize = filterStep(stepSize, forward, true);\r\n            \/\/ stepsize control for next step\r\n            final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\r\n            final double scaledH = stepSize * factor;\r\n            final double nextT = stepStart + scaledH;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            hNew = filterStep(scaledH, forward, nextIsLast);\r\n        }\r\n    }\r\n    final double stopTime = stepStart;\r\n    resetInternalState();\r\n    return stopTime;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\r\n    sanityChecks(equations, t0, y0, t, y);\r\n    setEquations(equations);\r\n    resetEvaluations();\r\n    final boolean forward = t > t0;\r\n        final int stages = c.length + 1;\r\n    if (y != y0) {\r\n        System.arraycopy(y0, 0, y, 0, y0.length);\r\n    }\r\n    final double[][] yDotK = new double[stages][y0.length];\r\n    final double[] yTmp = new double[y0.length];\r\n        AbstractStepInterpolator interpolator;\r\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\r\n        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\r\n        rki.reinitialize(this, yTmp, yDotK, forward);\r\n        interpolator = rki;\r\n    } else {\r\n        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\r\n    }\r\n    interpolator.storeTime(t0);\r\n        stepStart = t0;\r\n    double hNew = 0;\r\n    boolean firstTime = true;\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.reset();\r\n    }\r\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\r\n    boolean lastStep = false;\r\n        while (!lastStep) {\r\n        interpolator.shift();\r\n        double error = 0;\r\n        for (boolean loop = true; loop; ) {\r\n            if (firstTime || !fsal) {\r\n                                computeDerivatives(stepStart, y, yDotK[0]);\r\n            }\r\n            if (firstTime) {\r\n                final double[] scale = new double[y0.length];\r\n                if (vecAbsoluteTolerance == null) {\r\n                    for (int i = 0; i < scale.length; ++i) {\r\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\r\n                    }\r\n                } else {\r\n                    for (int i = 0; i < scale.length; ++i) {\r\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\r\n                    }\r\n                }\r\n                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\r\n                firstTime = false;\r\n            }\r\n            stepSize = hNew;\r\n                        for (int k = 1; k < stages; ++k) {\r\n                for (int j = 0; j < y0.length; ++j) {\r\n                    double sum = a[k - 1][0] * yDotK[0][j];\r\n                    for (int l = 1; l < k; ++l) {\r\n                        sum += a[k - 1][l] * yDotK[l][j];\r\n                    }\r\n                    yTmp[j] = y[j] + stepSize * sum;\r\n                }\r\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\r\n            }\r\n                        for (int j = 0; j < y0.length; ++j) {\r\n                double sum = b[0] * yDotK[0][j];\r\n                for (int l = 1; l < stages; ++l) {\r\n                    sum += b[l] * yDotK[l][j];\r\n                }\r\n                yTmp[j] = y[j] + stepSize * sum;\r\n            }\r\n                        error = estimateError(yDotK, y, yTmp, stepSize);\r\n            if (error <= 1.0) {\r\n                                interpolator.storeTime(stepStart + stepSize);\r\n                if (manager.evaluateStep(interpolator)) {\r\n                    final double dt = manager.getEventTime() - stepStart;\r\n                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\r\n                                                                                                                                                loop = false;\r\n                    } else {\r\n                                                hNew = dt;\r\n                    }\r\n                } else {\r\n                                        loop = false;\r\n                }\r\n            } else {\r\n                                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\r\n                hNew = filterStep(stepSize * factor, forward, false);\r\n            }\r\n        }\r\n                final double nextStep = stepStart + stepSize;\r\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\r\n        manager.stepAccepted(nextStep, y);\r\n        lastStep = manager.stop();\r\n                interpolator.storeTime(nextStep);\r\n        for (StepHandler handler : stepHandlers) {\r\n            handler.handleStep(interpolator, lastStep);\r\n        }\r\n        stepStart = nextStep;\r\n        if (fsal) {\r\n                        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\r\n        }\r\n        if (manager.reset(stepStart, y) && !lastStep) {\r\n                                    computeDerivatives(stepStart, y, yDotK[0]);\r\n        }\r\n        if (!lastStep) {\r\n                                                stepSize = filterStep(stepSize, forward, true);\r\n                        final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\r\n            final double scaledH = stepSize * factor;\r\n            final double nextT = stepStart + scaledH;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            hNew = filterStep(scaledH, forward, nextIsLast);\r\n        }\r\n    }\r\n    final double stopTime = stepStart;\r\n    resetInternalState();\r\n    return stopTime;\r\n}","lc":4.5454545455,"pi":1.5263157895,"ma":4.0,"nbd":1.5,"ml":3.6666666667,"d":5.0456349206,"mi":-1.5268498943,"fo":3.0,"r":-0.0263157895,"e":40.9264869787}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5251_3d2393c7","label":1,"code":"\/**\r\n *  @return How the minified file should be named.\r\n *\/\r\nprotected String getMinifiedName() {\r\n    String name = super.getName();\r\n    String minifiedName;\r\n    int idxOfExtension = name.lastIndexOf('.');\r\n    if (idxOfExtension > -1) {\r\n        String extension = name.substring(idxOfExtension);\r\n        minifiedName = name.substring(0, name.length() - extension.length() + 1) + \"min\" + extension;\r\n    } else {\r\n        minifiedName = name + \".min\";\r\n    }\r\n    return minifiedName;\r\n}","code_comment":"\/**\r\n *  @return How the minified file should be named.\r\n *\/\r\n","code_no_comment":"protected String getMinifiedName() {\r\n    String name = super.getName();\r\n    String minifiedName;\r\n    int idxOfExtension = name.lastIndexOf('.');\r\n    if (idxOfExtension > -1) {\r\n        String extension = name.substring(idxOfExtension);\r\n        minifiedName = name.substring(0, name.length() - extension.length() + 1) + \"min\" + extension;\r\n    } else {\r\n        minifiedName = name + \".min\";\r\n    }\r\n    return minifiedName;\r\n}","lc":-0.0909090909,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.4781746032,"mi":0.0573643411,"fo":0.0,"r":0.2368421053,"e":0.2182834552}
{"project_name":"Closure","project_version":"37","label":2,"code":"@Override\r\nNode processFunctionNode(FunctionNode functionNode) {\r\n    Name name = functionNode.getFunctionName();\r\n    Boolean isUnnamedFunction = false;\r\n    if (name == null) {\r\n        int functionType = functionNode.getFunctionType();\r\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\r\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\r\n            \/\/ Return the bare minimum to put the AST in a valid state.\r\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\r\n        }\r\n        name = new Name();\r\n        name.setIdentifier(\"\");\r\n        isUnnamedFunction = true;\r\n    }\r\n    Node node = newNode(Token.FUNCTION);\r\n    Node newName = transform(name);\r\n    if (isUnnamedFunction) {\r\n        \/\/ Old Rhino tagged the empty name node with the line number of the\r\n        \/\/ declaration.\r\n        newName.setLineno(functionNode.getLineno());\r\n        \/\/ TODO(bowdidge) Mark line number of paren correctly.\r\n        \/\/ Same problem as below - the left paren might not be on the\r\n        \/\/ same line as the function keyword.\r\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\r\n        newName.setCharno(position2charno(lpColumn));\r\n        maybeSetLengthFrom(newName, name);\r\n    }\r\n    node.addChildToBack(newName);\r\n    Node lp = newNode(Token.PARAM_LIST);\r\n    \/\/ The left paren's complicated because it's not represented by an\r\n    \/\/ AstNode, so there's nothing that has the actual line number that it\r\n    \/\/ appeared on.  We know the paren has to appear on the same line as the\r\n    \/\/ function name (or else a semicolon will be inserted.)  If there's no\r\n    \/\/ function name, assume the paren was on the same line as the function.\r\n    \/\/ TODO(bowdidge): Mark line number of paren correctly.\r\n    Name fnName = functionNode.getFunctionName();\r\n    if (fnName != null) {\r\n        lp.setLineno(fnName.getLineno());\r\n    } else {\r\n        lp.setLineno(functionNode.getLineno());\r\n    }\r\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\r\n    lp.setCharno(position2charno(lparenCharno));\r\n    for (AstNode param : functionNode.getParams()) {\r\n        lp.addChildToBack(transform(param));\r\n    }\r\n    node.addChildToBack(lp);\r\n    Node bodyNode = transform(functionNode.getBody());\r\n    \/\/ When in ideMode Rhino tries to parse some constructs the compiler\r\n    \/\/ doesn't support, repair it here. see Rhino's\r\n    \/\/ Parser#parseFunctionBodyExpr.\r\n    parseDirectives(bodyNode);\r\n    node.addChildToBack(bodyNode);\r\n    return node;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nNode processFunctionNode(FunctionNode functionNode) {\r\n    Name name = functionNode.getFunctionName();\r\n    Boolean isUnnamedFunction = false;\r\n    if (name == null) {\r\n        int functionType = functionNode.getFunctionType();\r\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\r\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\r\n                        return newNode(Token.EXPR_RESULT, Node.newNumber(0));\r\n        }\r\n        name = new Name();\r\n        name.setIdentifier(\"\");\r\n        isUnnamedFunction = true;\r\n    }\r\n    Node node = newNode(Token.FUNCTION);\r\n    Node newName = transform(name);\r\n    if (isUnnamedFunction) {\r\n                        newName.setLineno(functionNode.getLineno());\r\n                                int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\r\n        newName.setCharno(position2charno(lpColumn));\r\n        maybeSetLengthFrom(newName, name);\r\n    }\r\n    node.addChildToBack(newName);\r\n    Node lp = newNode(Token.PARAM_LIST);\r\n                            Name fnName = functionNode.getFunctionName();\r\n    if (fnName != null) {\r\n        lp.setLineno(fnName.getLineno());\r\n    } else {\r\n        lp.setLineno(functionNode.getLineno());\r\n    }\r\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\r\n    lp.setCharno(position2charno(lparenCharno));\r\n    for (AstNode param : functionNode.getParams()) {\r\n        lp.addChildToBack(transform(param));\r\n    }\r\n    node.addChildToBack(lp);\r\n    Node bodyNode = transform(functionNode.getBody());\r\n                parseDirectives(bodyNode);\r\n    node.addChildToBack(bodyNode);\r\n    return node;\r\n}","lc":1.2272727273,"pi":-0.1196172249,"ma":0.4,"nbd":0.0,"ml":0.25,"d":0.5773809524,"mi":-0.7367159972,"fo":2.4166666667,"r":-0.0263157895,"e":1.5825752206}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4695_bb39b480","label":1,"code":"public void validateRawModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\r\n    Parent parent = model.getParent();\r\n    if (parent != null) {\r\n        validateStringNotEmpty(\"parent.groupId\", problems, Severity.FATAL, parent.getGroupId(), parent);\r\n        validateStringNotEmpty(\"parent.artifactId\", problems, Severity.FATAL, parent.getArtifactId(), parent);\r\n        validateStringNotEmpty(\"parent.version\", problems, Severity.FATAL, parent.getVersion(), parent);\r\n        if (equals(parent.getGroupId(), model.getGroupId()) && equals(parent.getArtifactId(), model.getArtifactId())) {\r\n            addViolation(problems, Severity.FATAL, \"parent.artifactId\", null, \"must be changed\" + \", the parent element cannot have the same groupId:artifactId as the project.\", parent);\r\n        }\r\n    }\r\n    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\r\n        Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);\r\n        validateEnum(\"modelVersion\", problems, Severity.ERROR, model.getModelVersion(), null, model, \"4.0.0\");\r\n        validateStringNoExpression(\"groupId\", problems, Severity.WARNING, model.getGroupId(), model);\r\n        validateStringNoExpression(\"artifactId\", problems, Severity.WARNING, model.getArtifactId(), model);\r\n        validateStringNoExpression(\"version\", problems, Severity.WARNING, model.getVersion(), model);\r\n        validateRawDependencies(problems, model.getDependencies(), \"dependencies.dependency\", request);\r\n        if (model.getDependencyManagement() != null) {\r\n            validateRawDependencies(problems, model.getDependencyManagement().getDependencies(), \"dependencyManagement.dependencies.dependency\", request);\r\n        }\r\n        validateRepositories(problems, model.getRepositories(), \"repositories.repository\", request);\r\n        validateRepositories(problems, model.getPluginRepositories(), \"pluginRepositories.pluginRepository\", request);\r\n        Build build = model.getBuild();\r\n        if (build != null) {\r\n            validateRawPlugins(problems, build.getPlugins(), false, request);\r\n            PluginManagement mngt = build.getPluginManagement();\r\n            if (mngt != null) {\r\n                validateRawPlugins(problems, mngt.getPlugins(), true, request);\r\n            }\r\n        }\r\n        Set<String> profileIds = new HashSet<String>();\r\n        for (Profile profile : model.getProfiles()) {\r\n            if (!profileIds.add(profile.getId())) {\r\n                addViolation(problems, errOn30, \"profiles.profile.id\", null, \"must be unique but found duplicate profile with id \" + profile.getId(), profile);\r\n            }\r\n            validateRawDependencies(problems, profile.getDependencies(), \"profiles.profile[\" + profile.getId() + \"].dependencies.dependency\", request);\r\n            if (profile.getDependencyManagement() != null) {\r\n                validateRawDependencies(problems, profile.getDependencyManagement().getDependencies(), \"profiles.profile[\" + profile.getId() + \"].dependencyManagement.dependencies.dependency\", request);\r\n            }\r\n            validateRepositories(problems, profile.getRepositories(), \"profiles.profile[\" + profile.getId() + \"].repositories.repository\", request);\r\n            validateRepositories(problems, profile.getPluginRepositories(), \"profiles.profile[\" + profile.getId() + \"].pluginRepositories.pluginRepository\", request);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void validateRawModel(Model model, ModelBuildingRequest request, ModelProblemCollector problems) {\r\n    Parent parent = model.getParent();\r\n    if (parent != null) {\r\n        validateStringNotEmpty(\"parent.groupId\", problems, Severity.FATAL, parent.getGroupId(), parent);\r\n        validateStringNotEmpty(\"parent.artifactId\", problems, Severity.FATAL, parent.getArtifactId(), parent);\r\n        validateStringNotEmpty(\"parent.version\", problems, Severity.FATAL, parent.getVersion(), parent);\r\n        if (equals(parent.getGroupId(), model.getGroupId()) && equals(parent.getArtifactId(), model.getArtifactId())) {\r\n            addViolation(problems, Severity.FATAL, \"parent.artifactId\", null, \"must be changed\" + \", the parent element cannot have the same groupId:artifactId as the project.\", parent);\r\n        }\r\n    }\r\n    if (request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0) {\r\n        Severity errOn30 = getSeverity(request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0);\r\n        validateEnum(\"modelVersion\", problems, Severity.ERROR, model.getModelVersion(), null, model, \"4.0.0\");\r\n        validateStringNoExpression(\"groupId\", problems, Severity.WARNING, model.getGroupId(), model);\r\n        validateStringNoExpression(\"artifactId\", problems, Severity.WARNING, model.getArtifactId(), model);\r\n        validateStringNoExpression(\"version\", problems, Severity.WARNING, model.getVersion(), model);\r\n        validateRawDependencies(problems, model.getDependencies(), \"dependencies.dependency\", request);\r\n        if (model.getDependencyManagement() != null) {\r\n            validateRawDependencies(problems, model.getDependencyManagement().getDependencies(), \"dependencyManagement.dependencies.dependency\", request);\r\n        }\r\n        validateRepositories(problems, model.getRepositories(), \"repositories.repository\", request);\r\n        validateRepositories(problems, model.getPluginRepositories(), \"pluginRepositories.pluginRepository\", request);\r\n        Build build = model.getBuild();\r\n        if (build != null) {\r\n            validateRawPlugins(problems, build.getPlugins(), false, request);\r\n            PluginManagement mngt = build.getPluginManagement();\r\n            if (mngt != null) {\r\n                validateRawPlugins(problems, mngt.getPlugins(), true, request);\r\n            }\r\n        }\r\n        Set<String> profileIds = new HashSet<String>();\r\n        for (Profile profile : model.getProfiles()) {\r\n            if (!profileIds.add(profile.getId())) {\r\n                addViolation(problems, errOn30, \"profiles.profile.id\", null, \"must be unique but found duplicate profile with id \" + profile.getId(), profile);\r\n            }\r\n            validateRawDependencies(problems, profile.getDependencies(), \"profiles.profile[\" + profile.getId() + \"].dependencies.dependency\", request);\r\n            if (profile.getDependencyManagement() != null) {\r\n                validateRawDependencies(problems, profile.getDependencyManagement().getDependencies(), \"profiles.profile[\" + profile.getId() + \"].dependencyManagement.dependencies.dependency\", request);\r\n            }\r\n            validateRepositories(problems, profile.getRepositories(), \"profiles.profile[\" + profile.getId() + \"].repositories.repository\", request);\r\n            validateRepositories(problems, profile.getPluginRepositories(), \"profiles.profile[\" + profile.getId() + \"].pluginRepositories.pluginRepository\", request);\r\n        }\r\n    }\r\n}","lc":1.3636363636,"pi":0.2918660287,"ma":1.2,"nbd":0.5,"ml":1.5,"d":1.3194444444,"mi":-0.8861169838,"fo":4.4166666667,"r":-0.0263157895,"e":5.6580372631}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-523_837dcd89","label":1,"code":"private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\r\n    in.defaultReadObject();\r\n    formattedMessage = in.readUTF();\r\n    messagePattern = in.readUTF();\r\n    baseName = in.readUTF();\r\n    final int length = in.readInt();\r\n    stringArgs = new String[length];\r\n    for (int i = 0; i < length; ++i) {\r\n        stringArgs[i] = in.readUTF();\r\n    }\r\n    logger = StatusLogger.getLogger();\r\n    resourceBundle = null;\r\n    argArray = null;\r\n}","code_comment":null,"code_no_comment":"private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\r\n    in.defaultReadObject();\r\n    formattedMessage = in.readUTF();\r\n    messagePattern = in.readUTF();\r\n    baseName = in.readUTF();\r\n    final int length = in.readInt();\r\n    stringArgs = new String[length];\r\n    for (int i = 0; i < length; ++i) {\r\n        stringArgs[i] = in.readUTF();\r\n    }\r\n    logger = StatusLogger.getLogger();\r\n    resourceBundle = null;\r\n    argArray = null;\r\n}","lc":0.0,"pi":-0.5550239234,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0277777778,"mi":-0.0438336857,"fo":0.0833333333,"r":0.0526315789,"e":0.0246122992}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7213_336663c9","label":1,"code":"@Converter\r\npublic static ByteBuffer toByteBuffer(Long value) {\r\n    ByteBuffer buf = ByteBuffer.allocate(8);\r\n    buf.putLong(value);\r\n    return buf;\r\n}","code_comment":null,"code_no_comment":"@Converter\r\npublic static ByteBuffer toByteBuffer(Long value) {\r\n    ByteBuffer buf = ByteBuffer.allocate(8);\r\n    buf.putLong(value);\r\n    return buf;\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5644820296,"fo":-0.3333333333,"r":1.2105263158,"e":-0.1627934049}
{"project_name":"Closure","project_version":"59","label":2,"code":"\/**\r\n * Initialize the compiler options. Only necessary if you're not doing\r\n * a normal compile() job.\r\n *\/\r\npublic void initOptions(CompilerOptions options) {\r\n    this.options = options;\r\n    if (errorManager == null) {\r\n        if (outStream == null) {\r\n            setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger));\r\n        } else {\r\n            PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream);\r\n            printer.setSummaryDetailLevel(options.summaryDetailLevel);\r\n            setErrorManager(printer);\r\n        }\r\n    }\r\n    \/\/ DiagnosticGroups override the plain checkTypes option.\r\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\r\n        options.checkTypes = true;\r\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\r\n        options.checkTypes = false;\r\n    } else if (!options.checkTypes) {\r\n        \/\/ If DiagnosticGroups did not override the plain checkTypes\r\n        \/\/ option, and checkTypes is enabled, then turn off the\r\n        \/\/ parser type warnings.\r\n        options.setWarningLevel(DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF);\r\n    }\r\n    if (options.checkGlobalThisLevel.isOn()) {\r\n        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);\r\n    }\r\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\r\n        options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR);\r\n    }\r\n    \/\/ Initialize the warnings guard.\r\n    List<WarningsGuard> guards = Lists.newArrayList();\r\n    guards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));\r\n    guards.add(options.getWarningsGuard());\r\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\r\n    \/\/ error off.\r\n    if (!options.checkSymbols && !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\r\n        composedGuards.addGuard(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\r\n    }\r\n    this.warningsGuard = composedGuards;\r\n}","code_comment":"\/**\r\n * Initialize the compiler options. Only necessary if you're not doing\r\n * a normal compile() job.\r\n *\/\r\n","code_no_comment":"public void initOptions(CompilerOptions options) {\r\n    this.options = options;\r\n    if (errorManager == null) {\r\n        if (outStream == null) {\r\n            setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger));\r\n        } else {\r\n            PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream);\r\n            printer.setSummaryDetailLevel(options.summaryDetailLevel);\r\n            setErrorManager(printer);\r\n        }\r\n    }\r\n        if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\r\n        options.checkTypes = true;\r\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\r\n        options.checkTypes = false;\r\n    } else if (!options.checkTypes) {\r\n                                options.setWarningLevel(DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF);\r\n    }\r\n    if (options.checkGlobalThisLevel.isOn()) {\r\n        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel);\r\n    }\r\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\r\n        options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR);\r\n    }\r\n        List<WarningsGuard> guards = Lists.newArrayList();\r\n    guards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups()));\r\n    guards.add(options.getWarningsGuard());\r\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\r\n        if (!options.checkSymbols && !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\r\n        composedGuards.addGuard(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\r\n    }\r\n    this.warningsGuard = composedGuards;\r\n}","lc":0.8636363636,"pi":0.0669856459,"ma":1.0,"nbd":0.5,"ml":1.0833333333,"d":0.376984127,"mi":-0.6321353066,"fo":1.25,"r":-0.0263157895,"e":0.9990214554}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-859_66dece12","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic boolean isSupportLowerBoundInclusive() {\r\n    return true;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public boolean isSupportLowerBoundInclusive() {\r\n    return true;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.2407329105,"fo":-0.5,"r":2.5,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4309_b4274415","label":1,"code":"\/**\r\n *  Convert to object types, returning null if text is null.\r\n *\r\n *  @return converted\r\n *  @throws StringValueConversionException\r\n *\/\r\npublic final Duration toOptionalDuration() throws StringValueConversionException {\r\n    return (text == null) ? null : toDuration();\r\n}","code_comment":"\/**\r\n *  Convert to object types, returning null if text is null.\r\n *\r\n *  @return converted\r\n *  @throws StringValueConversionException\r\n *\/\r\n","code_no_comment":"public final Duration toOptionalDuration() throws StringValueConversionException {\r\n    return (text == null) ? null : toDuration();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.3650793651,"mi":0.9797040169,"fo":-0.4166666667,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"public double getCost(Filter filter, String propertyName, PropertyValue value) {\r\n    NodeState indexMeta = getIndexNode(root, propertyName, filter);\r\n    if (indexMeta == null) {\r\n        return Double.POSITIVE_INFINITY;\r\n    }\r\n    return COST_OVERHEAD + getStrategy(indexMeta).count(indexMeta, encode(value), MAX_COST);\r\n}","code_comment":null,"code_no_comment":"public double getCost(Filter filter, String propertyName, PropertyValue value) {\r\n    NodeState indexMeta = getIndexNode(root, propertyName, filter);\r\n    if (indexMeta == null) {\r\n        return Double.POSITIVE_INFINITY;\r\n    }\r\n    return COST_OVERHEAD + getStrategy(indexMeta).count(indexMeta, encode(value), MAX_COST);\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1071428571,"mi":0.3612403101,"fo":-0.1666666667,"r":0.0,"e":-0.0841686693}
{"project_name":"Closure","project_version":"80","label":1,"code":"static boolean isBooleanResultHelper(Node n) {\r\n    switch(n.getType()) {\r\n        \/\/ Primitives\r\n        case Token.TRUE:\r\n        case Token.FALSE:\r\n        \/\/ Comparisons\r\n        case Token.EQ:\r\n        case Token.NE:\r\n        case Token.SHEQ:\r\n        case Token.SHNE:\r\n        case Token.LT:\r\n        case Token.GT:\r\n        case Token.LE:\r\n        case Token.GE:\r\n        \/\/ Queryies\r\n        case Token.IN:\r\n        case Token.INSTANCEOF:\r\n        \/\/ Inversion\r\n        case Token.NOT:\r\n            \/\/ delete operator returns a boolean.\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}","code_comment":null,"code_no_comment":"static boolean isBooleanResultHelper(Node n) {\r\n    switch(n.getType()) {\r\n                case Token.TRUE:\r\n        case Token.FALSE:\r\n                case Token.EQ:\r\n        case Token.NE:\r\n        case Token.SHEQ:\r\n        case Token.SHNE:\r\n        case Token.LT:\r\n        case Token.GT:\r\n        case Token.LE:\r\n        case Token.GE:\r\n                case Token.IN:\r\n        case Token.INSTANCEOF:\r\n                case Token.NOT:\r\n                        return true;\r\n        default:\r\n            return false;\r\n    }\r\n}","lc":0.2727272727,"pi":0.0,"ma":2.2,"nbd":0.0,"ml":0.75,"d":-0.3650793651,"mi":-0.2214235377,"fo":-0.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1269_b8fe2ded","label":1,"code":"public double getCost(Filter filter) {\r\n    PropertyIndexLookup lookup = new PropertyIndexLookup(root);\r\n    return lookup.getCost(null, JCR_PRIMARYTYPE, newName(filter.getPrimaryTypes())) + lookup.getCost(null, JCR_MIXINTYPES, newName(filter.getMixinTypes()));\r\n}","code_comment":null,"code_no_comment":"public double getCost(Filter filter) {\r\n    PropertyIndexLookup lookup = new PropertyIndexLookup(root);\r\n    return lookup.getCost(null, JCR_PRIMARYTYPE, newName(filter.getPrimaryTypes())) + lookup.getCost(null, JCR_MIXINTYPES, newName(filter.getMixinTypes()));\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.0297619048,"mi":0.6724453841,"fo":0.0,"r":-0.0263157895,"e":-0.0896365323}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-448_999097e1","label":1,"code":"@Override\r\npublic NodeState getBaseState() {\r\n    return baseState;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic NodeState getBaseState() {\r\n    return baseState;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9785764623,"fo":-0.5,"r":2.0789473684,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2430_be3a9114","label":1,"code":"@Override\r\npublic boolean childNodeAdded(String name, NodeState after) {\r\n    if (!loader.isRunning()) {\r\n        return false;\r\n    }\r\n    NodeBuilder child = EmptyNodeState.EMPTY_NODE.builder();\r\n    boolean success = EmptyNodeState.compareAgainstEmptyState(after, new StandbyApplyDiff(child, store, loader, path + name + \"\/\"));\r\n    if (success) {\r\n        builder.setChildNode(name, child.getNodeState());\r\n    }\r\n    return success;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean childNodeAdded(String name, NodeState after) {\r\n    if (!loader.isRunning()) {\r\n        return false;\r\n    }\r\n    NodeBuilder child = EmptyNodeState.EMPTY_NODE.builder();\r\n    boolean success = EmptyNodeState.compareAgainstEmptyState(after, new StandbyApplyDiff(child, store, loader, path + name + \"\/\"));\r\n    if (success) {\r\n        builder.setChildNode(name, child.getNodeState());\r\n    }\r\n    return success;\r\n}","lc":-0.0909090909,"pi":-0.2057416268,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0813492063,"mi":0.067230444,"fo":-0.0833333333,"r":0.0263157895,"e":-0.0477515949}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-939_49444ee6","label":1,"code":"\/**\r\n * Create a covariance matrix from a matrix whose columns represent\r\n * covariates. Covariances are computed using the bias-corrected formula.\r\n * @param matrix input matrix (must have at least two columns and two rows)\r\n * @return covariance matrix\r\n * @throws MathIllegalArgumentException if matrix does not contain sufficient data\r\n * @see #Covariance\r\n *\/\r\nprotected RealMatrix computeCovarianceMatrix(RealMatrix matrix) throws MathIllegalArgumentException {\r\n    return computeCovarianceMatrix(matrix, true);\r\n}","code_comment":"\/**\r\n * Create a covariance matrix from a matrix whose columns represent\r\n * covariates. Covariances are computed using the bias-corrected formula.\r\n * @param matrix input matrix (must have at least two columns and two rows)\r\n * @return covariance matrix\r\n * @throws MathIllegalArgumentException if matrix does not contain sufficient data\r\n * @see #Covariance\r\n *\/\r\n","code_no_comment":"protected RealMatrix computeCovarianceMatrix(RealMatrix matrix) throws MathIllegalArgumentException {\r\n    return computeCovarianceMatrix(matrix, true);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.008174771,"fo":-0.4166666667,"r":2.4473684211,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3861_d1e0e411","label":3,"code":"@Override\r\npublic void onComponentTag(final Component component, final ComponentTag tag) {\r\n    tag.put(\"xmlns:wicket\", \"http:\/\/wicket.apache.org\/dtds.data\/wicket-xhtml1.3-strict.dtd\");\r\n    \/\/ Make the XSLT processor happy and allow it to handle the wicket tags\r\n    \/\/ and attributes that are in the wicket namespace\r\n    super.onComponentTag(component, tag);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void onComponentTag(final Component component, final ComponentTag tag) {\r\n    tag.put(\"xmlns:wicket\", \"http:\/\/wicket.apache.org\/dtds.data\/wicket-xhtml1.3-strict.dtd\");\r\n            super.onComponentTag(component, tag);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.67329105,"fo":-0.3333333333,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4291_cdb34ffc","label":0,"code":"\/**\r\n * Flush any pending changes on any {@link SegmentBufferWriter} managed by this instance.\r\n * This method <em>does not block<\/em> to wait for concurrent write operations. However, if\r\n * a write operation is currently in progress a call to this method ensures the respective\r\n * changes are properly flushed at the end of that call.\r\n * @throws IOException\r\n *\/\r\nvoid flush() throws IOException;","code_comment":"\/**\r\n * Flush any pending changes on any {@link SegmentBufferWriter} managed by this instance.\r\n * This method <em>does not block<\/em> to wait for concurrent write operations. However, if\r\n * a write operation is currently in progress a call to this method ensures the respective\r\n * changes are properly flushed at the end of that call.\r\n * @throws IOException\r\n *\/\r\n","code_no_comment":"void flush() throws IOException;","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.7424947146,"fo":-0.5,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7429_43956f93","label":1,"code":"private boolean isNestProperty(String uri, String prefixToken, String suffixToken) {\r\n    if (ObjectHelper.isNotEmpty(uri)) {\r\n        uri = uri.trim();\r\n        if (uri.startsWith(prefixToken) && uri.endsWith(suffixToken)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"private boolean isNestProperty(String uri, String prefixToken, String suffixToken) {\r\n    if (ObjectHelper.isNotEmpty(uri)) {\r\n        uri = uri.trim();\r\n        if (uri.startsWith(prefixToken) && uri.endsWith(suffixToken)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","lc":-0.2272727273,"pi":0.3732057416,"ma":-0.2,"nbd":0.0,"ml":0.3333333333,"d":-0.0297619048,"mi":0.2890768147,"fo":-0.1666666667,"r":0.0526315789,"e":-0.0896365323}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7146_b6981cfd","label":3,"code":"\/**\r\n * Confirms the completion of the {@link Exchange}.\r\n *\r\n * @param camelContext  the current CamelContext\r\n * @param exchangeId    exchange id to confirm\r\n *\/\r\nvoid confirm(CamelContext camelContext, String exchangeId);","code_comment":"\/**\r\n * Confirms the completion of the {@link Exchange}.\r\n *\r\n * @param camelContext  the current CamelContext\r\n * @param exchangeId    exchange id to confirm\r\n *\/\r\n","code_no_comment":"void confirm(CamelContext camelContext, String exchangeId);","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.5691331924,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"@Override\r\npublic boolean remove() {\r\n    root.checkLive();\r\n    if (isDisconnected()) {\r\n        throw new IllegalStateException(\"Cannot remove a disconnected tree\");\r\n    }\r\n    if (!isRoot() && parent.hasChild(name)) {\r\n        NodeBuilder builder = parent.getNodeBuilder();\r\n        builder.removeNode(name);\r\n        if (parent.hasOrderableChildren()) {\r\n            builder.setProperty(MemoryPropertyBuilder.copy(Type.STRING, parent.internalGetProperty(OAK_CHILD_ORDER)).removeValue(name).getPropertyState());\r\n        }\r\n        root.updated();\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean remove() {\r\n    root.checkLive();\r\n    if (isDisconnected()) {\r\n        throw new IllegalStateException(\"Cannot remove a disconnected tree\");\r\n    }\r\n    if (!isRoot() && parent.hasChild(name)) {\r\n        NodeBuilder builder = parent.getNodeBuilder();\r\n        builder.removeNode(name);\r\n        if (parent.hasOrderableChildren()) {\r\n            builder.setProperty(MemoryPropertyBuilder.copy(Type.STRING, parent.internalGetProperty(OAK_CHILD_ORDER)).removeValue(name).getPropertyState());\r\n        }\r\n        root.updated();\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}","lc":0.1818181818,"pi":0.1483253589,"ma":0.2,"nbd":0.0,"ml":0.3333333333,"d":-0.1111111111,"mi":-0.1515151515,"fo":0.5833333333,"r":0.0,"e":-0.0451513632}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3448_b345dd82","label":0,"code":"public OnExceptionDefinition getExceptionPolicy(Map<ExceptionPolicyKey, OnExceptionDefinition> exceptionPolicies, Exchange exchange, Throwable exception) {\r\n    Map<Integer, OnExceptionDefinition> candidates = new TreeMap<Integer, OnExceptionDefinition>();\r\n    \/\/ recursive up the tree using the iterator\r\n    boolean exactMatch = false;\r\n    Iterator<Throwable> it = createExceptionIterator(exception);\r\n    while (!exactMatch && it.hasNext()) {\r\n        \/\/ we should stop looking if we have found an exact match\r\n        exactMatch = findMatchedExceptionPolicy(exceptionPolicies, exchange, it.next(), candidates);\r\n    }\r\n    if (LOG.isTraceEnabled()) {\r\n        LOG.trace(\"Found \" + candidates.size() + \" candidates\");\r\n    }\r\n    if (candidates.isEmpty()) {\r\n        \/\/ no type found\r\n        return null;\r\n    } else {\r\n        \/\/ return the first in the map as its sorted and\r\n        return candidates.values().iterator().next();\r\n    }\r\n}","code_comment":null,"code_no_comment":"public OnExceptionDefinition getExceptionPolicy(Map<ExceptionPolicyKey, OnExceptionDefinition> exceptionPolicies, Exchange exchange, Throwable exception) {\r\n    Map<Integer, OnExceptionDefinition> candidates = new TreeMap<Integer, OnExceptionDefinition>();\r\n        boolean exactMatch = false;\r\n    Iterator<Throwable> it = createExceptionIterator(exception);\r\n    while (!exactMatch && it.hasNext()) {\r\n                exactMatch = findMatchedExceptionPolicy(exceptionPolicies, exchange, it.next(), candidates);\r\n    }\r\n    if (LOG.isTraceEnabled()) {\r\n        LOG.trace(\"Found \" + candidates.size() + \" candidates\");\r\n    }\r\n    if (candidates.isEmpty()) {\r\n                return null;\r\n    } else {\r\n                return candidates.values().iterator().next();\r\n    }\r\n}","lc":0.0909090909,"pi":-0.2822966507,"ma":0.0,"nbd":-0.5,"ml":0.25,"d":0.2757936508,"mi":-0.1467230444,"fo":0.4166666667,"r":-0.0263157895,"e":0.2720215764}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4102_e743fd7e","label":1,"code":"@Override\r\nprotected void executeInsideBufferedZone() {\r\n    TextLabel.super.onComponentTagBody(markupStream, openTag);\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void executeInsideBufferedZone() {\r\n    TextLabel.super.onComponentTagBody(markupStream, openTag);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9016208598,"fo":-0.4166666667,"r":0.3157894737,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Returns a double array containing the elements of this\r\n * <code>ResizableArray<\/code>.  This method returns a copy, not a\r\n * reference to the underlying array, so that changes made to the returned\r\n *  array have no effect on this <code>ResizableArray.<\/code>\r\n * @return the double array.\r\n *\/\r\n@Override\r\npublic synchronized double[] getElements() {\r\n    final double[] elementArray = new double[numElements];\r\n    System.arraycopy(internalArray, startIndex, elementArray, 0, numElements);\r\n    return elementArray;\r\n}","code_comment":"\/**\r\n * Returns a double array containing the elements of this\r\n * <code>ResizableArray<\/code>.  This method returns a copy, not a\r\n * reference to the underlying array, so that changes made to the returned\r\n *  array have no effect on this <code>ResizableArray.<\/code>\r\n * @return the double array.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic synchronized double[] getElements() {\r\n    final double[] elementArray = new double[numElements];\r\n    System.arraycopy(internalArray, startIndex, elementArray, 0, numElements);\r\n    return elementArray;\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5842142354,"fo":-0.4166666667,"r":0.4473684211,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"@Override\r\npublic Cursor query(IndexPlan plan, NodeState root) {\r\n    LOG.debug(\"query(IndexPlan, NodeState)\");\r\n    LOG.debug(\"query() - plan: {}\", plan);\r\n    LOG.debug(\"query() - rootState: {}\", root);\r\n    Filter filter = plan.getFilter();\r\n    List<OrderEntry> sortOrder = plan.getSortOrder();\r\n    Iterable<String> paths = null;\r\n    OrderedContentMirrorStoreStrategy strategy = OrderedPropertyIndexLookup.getStrategy(plan.getDefinition());\r\n    int depth = 1;\r\n    PropertyRestriction pr = plan.getPropertyRestriction();\r\n    if (pr != null) {\r\n        String propertyName = PathUtils.getName(pr.propertyName);\r\n        depth = PathUtils.getDepth(propertyName);\r\n        paths = strategy.query(plan.getFilter(), propertyName, plan.getDefinition(), pr);\r\n    }\r\n    if (paths == null && sortOrder != null && !sortOrder.isEmpty()) {\r\n        \/\/ we could be here if we have a query where the ORDER BY makes us play it.\r\n        for (OrderEntry oe : sortOrder) {\r\n            String propertyName = PathUtils.getName(oe.getPropertyName());\r\n            depth = PathUtils.getDepth(oe.getPropertyName());\r\n            paths = strategy.query(plan.getFilter(), propertyName, plan.getDefinition(), new PropertyRestriction());\r\n        }\r\n    }\r\n    if (paths == null) {\r\n        \/\/ if still here then something went wrong.\r\n        throw new IllegalStateException(\"OrderedPropertyIndex index is used even when no index is available for filter \" + filter);\r\n    }\r\n    Cursor cursor = Cursors.newPathCursor(paths, filter.getQueryEngineSettings());\r\n    cursor = Cursors.newPrefixCursor(cursor, plan.getPathPrefix());\r\n    if (depth > 1) {\r\n        cursor = Cursors.newAncestorCursor(cursor, depth - 1, filter.getQueryEngineSettings());\r\n    }\r\n    return cursor;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Cursor query(IndexPlan plan, NodeState root) {\r\n    LOG.debug(\"query(IndexPlan, NodeState)\");\r\n    LOG.debug(\"query() - plan: {}\", plan);\r\n    LOG.debug(\"query() - rootState: {}\", root);\r\n    Filter filter = plan.getFilter();\r\n    List<OrderEntry> sortOrder = plan.getSortOrder();\r\n    Iterable<String> paths = null;\r\n    OrderedContentMirrorStoreStrategy strategy = OrderedPropertyIndexLookup.getStrategy(plan.getDefinition());\r\n    int depth = 1;\r\n    PropertyRestriction pr = plan.getPropertyRestriction();\r\n    if (pr != null) {\r\n        String propertyName = PathUtils.getName(pr.propertyName);\r\n        depth = PathUtils.getDepth(propertyName);\r\n        paths = strategy.query(plan.getFilter(), propertyName, plan.getDefinition(), pr);\r\n    }\r\n    if (paths == null && sortOrder != null && !sortOrder.isEmpty()) {\r\n                for (OrderEntry oe : sortOrder) {\r\n            String propertyName = PathUtils.getName(oe.getPropertyName());\r\n            depth = PathUtils.getDepth(oe.getPropertyName());\r\n            paths = strategy.query(plan.getFilter(), propertyName, plan.getDefinition(), new PropertyRestriction());\r\n        }\r\n    }\r\n    if (paths == null) {\r\n                throw new IllegalStateException(\"OrderedPropertyIndex index is used even when no index is available for filter \" + filter);\r\n    }\r\n    Cursor cursor = Cursors.newPathCursor(paths, filter.getQueryEngineSettings());\r\n    cursor = Cursors.newPrefixCursor(cursor, plan.getPathPrefix());\r\n    if (depth > 1) {\r\n        cursor = Cursors.newAncestorCursor(cursor, depth - 1, filter.getQueryEngineSettings());\r\n    }\r\n    return cursor;\r\n}","lc":0.8636363636,"pi":0.019138756,"ma":0.6,"nbd":0.0,"ml":0.5,"d":1.5873015873,"mi":-0.6560958421,"fo":1.75,"r":-0.0263157895,"e":3.7703290054}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1516_7c62bd81","label":1,"code":"private static Term[] extractMatchingTokens(IndexReader reader, String token) {\r\n    if (reader == null) {\r\n        \/\/ getPlan call\r\n        return null;\r\n    }\r\n    try {\r\n        List<Term> terms = new ArrayList<Term>();\r\n        Terms t = MultiFields.getTerms(reader, FieldNames.FULLTEXT);\r\n        Automaton a = WildcardQuery.toAutomaton(newFulltextTerm(token));\r\n        CompiledAutomaton ca = new CompiledAutomaton(a);\r\n        TermsEnum te = ca.getTermsEnum(t);\r\n        BytesRef text;\r\n        while ((text = te.next()) != null) {\r\n            terms.add(newFulltextTerm(text.utf8ToString()));\r\n        }\r\n        return terms.toArray(new Term[terms.size()]);\r\n    } catch (IOException e) {\r\n        LOG.error(\"Building fulltext query failed\", e.getMessage());\r\n        return null;\r\n    }\r\n}","code_comment":null,"code_no_comment":"private static Term[] extractMatchingTokens(IndexReader reader, String token) {\r\n    if (reader == null) {\r\n                return null;\r\n    }\r\n    try {\r\n        List<Term> terms = new ArrayList<Term>();\r\n        Terms t = MultiFields.getTerms(reader, FieldNames.FULLTEXT);\r\n        Automaton a = WildcardQuery.toAutomaton(newFulltextTerm(token));\r\n        CompiledAutomaton ca = new CompiledAutomaton(a);\r\n        TermsEnum te = ca.getTermsEnum(t);\r\n        BytesRef text;\r\n        while ((text = te.next()) != null) {\r\n            terms.add(newFulltextTerm(text.utf8ToString()));\r\n        }\r\n        return terms.toArray(new Term[terms.size()]);\r\n    } catch (IOException e) {\r\n        LOG.error(\"Building fulltext query failed\", e.getMessage());\r\n        return null;\r\n    }\r\n}","lc":0.2727272727,"pi":-0.023923445,"ma":0.0,"nbd":0.0,"ml":-0.1666666667,"d":-0.0634920635,"mi":-0.2848484848,"fo":0.5,"r":0.0263157895,"e":0.1004477793}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5359_61122bab","label":3,"code":"\/**\r\n *  Convert this text to an enum.\r\n *\r\n *  @param eClass\r\n *             enum type\r\n *  @param defaultValue\r\n *             This will be returned if there is an error converting the value\r\n *  @return The value as an enum\r\n *\/\r\npublic final <T extends Enum<T>> T toEnum(Class<T> eClass, final T defaultValue) {\r\n    if (text != null) {\r\n        try {\r\n            return toEnum(eClass);\r\n        } catch (StringValueConversionException x) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a %s: %s\", text, eClass, x.getMessage()), x);\r\n            }\r\n        }\r\n    }\r\n    return defaultValue;\r\n}","code_comment":"\/**\r\n *  Convert this text to an enum.\r\n *\r\n *  @param eClass\r\n *             enum type\r\n *  @param defaultValue\r\n *             This will be returned if there is an error converting the value\r\n *  @return The value as an enum\r\n *\/\r\n","code_no_comment":"public final <T extends Enum<T>> T toEnum(Class<T> eClass, final T defaultValue) {\r\n    if (text != null) {\r\n        try {\r\n            return toEnum(eClass);\r\n        } catch (StringValueConversionException x) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a %s: %s\", text, eClass, x.getMessage()), x);\r\n            }\r\n        }\r\n    }\r\n    return defaultValue;\r\n}","lc":-0.0909090909,"pi":0.8899521531,"ma":0.0,"nbd":0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.1016208598,"fo":-0.0833333333,"r":1.5,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3052_8dc70f2e","label":1,"code":"@Override\r\nprotected void instantiate(OperatorDescriptorDual operator, Channel solutionSetIn, Channel worksetIn, List<Set<? extends NamedChannel>> broadcastPlanChannels, List<PlanNode> target, CostEstimator estimator, RequestedGlobalProperties globPropsReqSolutionSet, RequestedGlobalProperties globPropsReqWorkset, RequestedLocalProperties locPropsReqSolutionSet, RequestedLocalProperties locPropsReqWorkset) {\r\n    \/\/ check for pipeline breaking using hash join with build on the solution set side\r\n    placePipelineBreakersIfNecessary(DriverStrategy.HYBRIDHASH_BUILD_FIRST, solutionSetIn, worksetIn);\r\n    \/\/ NOTES ON THE ENUMERATION OF THE STEP FUNCTION PLANS:\r\n    \/\/ Whenever we instantiate the iteration, we enumerate new candidates for the step function.\r\n    \/\/ That way, we make sure we have an appropriate plan for each candidate for the initial partial solution,\r\n    \/\/ we have a fitting candidate for the step function (often, work is pushed out of the step function).\r\n    \/\/ Among the candidates of the step function, we keep only those that meet the requested properties of the\r\n    \/\/ current candidate initial partial solution. That makes sure these properties exist at the beginning of\r\n    \/\/ every iteration.\r\n    \/\/ 1) Because we enumerate multiple times, we may need to clean the cached plans\r\n    \/\/ before starting another enumeration\r\n    this.nextWorkset.accept(PlanCacheCleaner.INSTANCE);\r\n    this.solutionSetDelta.accept(PlanCacheCleaner.INSTANCE);\r\n    \/\/ 2) Give the partial solution the properties of the current candidate for the initial partial solution\r\n    \/\/ This concerns currently only the workset.\r\n    this.worksetNode.setCandidateProperties(worksetIn.getGlobalProperties(), worksetIn.getLocalProperties(), worksetIn);\r\n    this.solutionSetNode.setCandidateProperties(this.partitionedProperties, new LocalProperties(), solutionSetIn);\r\n    final SolutionSetPlanNode sspn = this.solutionSetNode.getCurrentSolutionSetPlanNode();\r\n    final WorksetPlanNode wspn = this.worksetNode.getCurrentWorksetPlanNode();\r\n    \/\/ 3) Get the alternative plans\r\n    List<PlanNode> solutionSetDeltaCandidates = this.solutionSetDelta.getAlternativePlans(estimator);\r\n    List<PlanNode> worksetCandidates = this.nextWorkset.getAlternativePlans(estimator);\r\n    \/\/ 4) Throw away all that are not compatible with the properties currently requested to the\r\n    \/\/ initial partial solution\r\n    \/\/ Make sure that the workset candidates fulfill the input requirements\r\n    {\r\n        List<PlanNode> newCandidates = new ArrayList<PlanNode>();\r\n        for (Iterator<PlanNode> planDeleter = worksetCandidates.iterator(); planDeleter.hasNext(); ) {\r\n            PlanNode candidate = planDeleter.next();\r\n            GlobalProperties atEndGlobal = candidate.getGlobalProperties();\r\n            LocalProperties atEndLocal = candidate.getLocalProperties();\r\n            FeedbackPropertiesMeetRequirementsReport report = candidate.checkPartialSolutionPropertiesMet(wspn, atEndGlobal, atEndLocal);\r\n            if (report == FeedbackPropertiesMeetRequirementsReport.NO_PARTIAL_SOLUTION) {\r\n                \/\/ depends only through broadcast variable on the workset solution\r\n                ;\r\n            } else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {\r\n                \/\/ attach a no-op node through which we create the properties of the original input\r\n                Channel toNoOp = new Channel(candidate);\r\n                globPropsReqWorkset.parameterizeChannel(toNoOp, false, nextWorksetRootConnection.getDataExchangeMode(), false);\r\n                locPropsReqWorkset.parameterizeChannel(toNoOp);\r\n                UnaryOperatorNode rebuildWorksetPropertiesNode = new UnaryOperatorNode(\"Rebuild Workset Properties\", FieldList.EMPTY_LIST);\r\n                rebuildWorksetPropertiesNode.setParallelism(candidate.getParallelism());\r\n                SingleInputPlanNode rebuildWorksetPropertiesPlanNode = new SingleInputPlanNode(rebuildWorksetPropertiesNode, \"Rebuild Workset Properties\", toNoOp, DriverStrategy.UNARY_NO_OP);\r\n                rebuildWorksetPropertiesPlanNode.initProperties(toNoOp.getGlobalProperties(), toNoOp.getLocalProperties());\r\n                estimator.costOperator(rebuildWorksetPropertiesPlanNode);\r\n                GlobalProperties atEndGlobalModified = rebuildWorksetPropertiesPlanNode.getGlobalProperties();\r\n                LocalProperties atEndLocalModified = rebuildWorksetPropertiesPlanNode.getLocalProperties();\r\n                if (!(atEndGlobalModified.equals(atEndGlobal) && atEndLocalModified.equals(atEndLocal))) {\r\n                    FeedbackPropertiesMeetRequirementsReport report2 = candidate.checkPartialSolutionPropertiesMet(wspn, atEndGlobalModified, atEndLocalModified);\r\n                    if (report2 != FeedbackPropertiesMeetRequirementsReport.NOT_MET) {\r\n                        newCandidates.add(rebuildWorksetPropertiesPlanNode);\r\n                    }\r\n                }\r\n                \/\/ remove the original operator and add the modified candidate\r\n                planDeleter.remove();\r\n            }\r\n        }\r\n        worksetCandidates.addAll(newCandidates);\r\n    }\r\n    if (worksetCandidates.isEmpty()) {\r\n        return;\r\n    }\r\n    \/\/ sanity check the solution set delta\r\n    for (PlanNode solutionSetDeltaCandidate : solutionSetDeltaCandidates) {\r\n        SingleInputPlanNode candidate = (SingleInputPlanNode) solutionSetDeltaCandidate;\r\n        GlobalProperties gp = candidate.getGlobalProperties();\r\n        if (gp.getPartitioning() != PartitioningProperty.HASH_PARTITIONED || gp.getPartitioningFields() == null || !gp.getPartitioningFields().equals(this.solutionSetKeyFields)) {\r\n            throw new CompilerException(\"Bug: The solution set delta is not partitioned.\");\r\n        }\r\n    }\r\n    \/\/ 5) Create a candidate for the Iteration Node for every remaining plan of the step function.\r\n    final GlobalProperties gp = new GlobalProperties();\r\n    gp.setHashPartitioned(this.solutionSetKeyFields);\r\n    gp.addUniqueFieldCombination(this.solutionSetKeyFields);\r\n    LocalProperties lp = LocalProperties.EMPTY.addUniqueFields(this.solutionSetKeyFields);\r\n    \/\/ take all combinations of solution set delta and workset plans\r\n    for (PlanNode solutionSetCandidate : solutionSetDeltaCandidates) {\r\n        for (PlanNode worksetCandidate : worksetCandidates) {\r\n            \/\/ check whether they have the same operator at their latest branching point\r\n            if (this.singleRoot.areBranchCompatible(solutionSetCandidate, worksetCandidate)) {\r\n                SingleInputPlanNode siSolutionDeltaCandidate = (SingleInputPlanNode) solutionSetCandidate;\r\n                boolean immediateDeltaUpdate;\r\n                \/\/ check whether we need a dedicated solution set delta operator, or whether we can update on the fly\r\n                if (siSolutionDeltaCandidate.getInput().getShipStrategy() == ShipStrategyType.FORWARD && this.solutionDeltaImmediatelyAfterSolutionJoin) {\r\n                    \/\/ sanity check the node and connection\r\n                    if (siSolutionDeltaCandidate.getDriverStrategy() != DriverStrategy.UNARY_NO_OP || siSolutionDeltaCandidate.getInput().getLocalStrategy() != LocalStrategy.NONE) {\r\n                        throw new CompilerException(\"Invalid Solution set delta node.\");\r\n                    }\r\n                    solutionSetCandidate = siSolutionDeltaCandidate.getInput().getSource();\r\n                    immediateDeltaUpdate = true;\r\n                } else {\r\n                    \/\/ was not partitioned, we need to keep this node.\r\n                    \/\/ mark that we materialize the input\r\n                    siSolutionDeltaCandidate.getInput().setTempMode(TempMode.PIPELINE_BREAKER);\r\n                    immediateDeltaUpdate = false;\r\n                }\r\n                WorksetIterationPlanNode wsNode = new WorksetIterationPlanNode(this, this.getOperator().getName(), solutionSetIn, worksetIn, sspn, wspn, worksetCandidate, solutionSetCandidate);\r\n                wsNode.setImmediateSolutionSetUpdate(immediateDeltaUpdate);\r\n                wsNode.initProperties(gp, lp);\r\n                target.add(wsNode);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void instantiate(OperatorDescriptorDual operator, Channel solutionSetIn, Channel worksetIn, List<Set<? extends NamedChannel>> broadcastPlanChannels, List<PlanNode> target, CostEstimator estimator, RequestedGlobalProperties globPropsReqSolutionSet, RequestedGlobalProperties globPropsReqWorkset, RequestedLocalProperties locPropsReqSolutionSet, RequestedLocalProperties locPropsReqWorkset) {\r\n        placePipelineBreakersIfNecessary(DriverStrategy.HYBRIDHASH_BUILD_FIRST, solutionSetIn, worksetIn);\r\n                                        this.nextWorkset.accept(PlanCacheCleaner.INSTANCE);\r\n    this.solutionSetDelta.accept(PlanCacheCleaner.INSTANCE);\r\n            this.worksetNode.setCandidateProperties(worksetIn.getGlobalProperties(), worksetIn.getLocalProperties(), worksetIn);\r\n    this.solutionSetNode.setCandidateProperties(this.partitionedProperties, new LocalProperties(), solutionSetIn);\r\n    final SolutionSetPlanNode sspn = this.solutionSetNode.getCurrentSolutionSetPlanNode();\r\n    final WorksetPlanNode wspn = this.worksetNode.getCurrentWorksetPlanNode();\r\n        List<PlanNode> solutionSetDeltaCandidates = this.solutionSetDelta.getAlternativePlans(estimator);\r\n    List<PlanNode> worksetCandidates = this.nextWorkset.getAlternativePlans(estimator);\r\n                {\r\n        List<PlanNode> newCandidates = new ArrayList<PlanNode>();\r\n        for (Iterator<PlanNode> planDeleter = worksetCandidates.iterator(); planDeleter.hasNext(); ) {\r\n            PlanNode candidate = planDeleter.next();\r\n            GlobalProperties atEndGlobal = candidate.getGlobalProperties();\r\n            LocalProperties atEndLocal = candidate.getLocalProperties();\r\n            FeedbackPropertiesMeetRequirementsReport report = candidate.checkPartialSolutionPropertiesMet(wspn, atEndGlobal, atEndLocal);\r\n            if (report == FeedbackPropertiesMeetRequirementsReport.NO_PARTIAL_SOLUTION) {\r\n                                ;\r\n            } else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {\r\n                                Channel toNoOp = new Channel(candidate);\r\n                globPropsReqWorkset.parameterizeChannel(toNoOp, false, nextWorksetRootConnection.getDataExchangeMode(), false);\r\n                locPropsReqWorkset.parameterizeChannel(toNoOp);\r\n                UnaryOperatorNode rebuildWorksetPropertiesNode = new UnaryOperatorNode(\"Rebuild Workset Properties\", FieldList.EMPTY_LIST);\r\n                rebuildWorksetPropertiesNode.setParallelism(candidate.getParallelism());\r\n                SingleInputPlanNode rebuildWorksetPropertiesPlanNode = new SingleInputPlanNode(rebuildWorksetPropertiesNode, \"Rebuild Workset Properties\", toNoOp, DriverStrategy.UNARY_NO_OP);\r\n                rebuildWorksetPropertiesPlanNode.initProperties(toNoOp.getGlobalProperties(), toNoOp.getLocalProperties());\r\n                estimator.costOperator(rebuildWorksetPropertiesPlanNode);\r\n                GlobalProperties atEndGlobalModified = rebuildWorksetPropertiesPlanNode.getGlobalProperties();\r\n                LocalProperties atEndLocalModified = rebuildWorksetPropertiesPlanNode.getLocalProperties();\r\n                if (!(atEndGlobalModified.equals(atEndGlobal) && atEndLocalModified.equals(atEndLocal))) {\r\n                    FeedbackPropertiesMeetRequirementsReport report2 = candidate.checkPartialSolutionPropertiesMet(wspn, atEndGlobalModified, atEndLocalModified);\r\n                    if (report2 != FeedbackPropertiesMeetRequirementsReport.NOT_MET) {\r\n                        newCandidates.add(rebuildWorksetPropertiesPlanNode);\r\n                    }\r\n                }\r\n                                planDeleter.remove();\r\n            }\r\n        }\r\n        worksetCandidates.addAll(newCandidates);\r\n    }\r\n    if (worksetCandidates.isEmpty()) {\r\n        return;\r\n    }\r\n        for (PlanNode solutionSetDeltaCandidate : solutionSetDeltaCandidates) {\r\n        SingleInputPlanNode candidate = (SingleInputPlanNode) solutionSetDeltaCandidate;\r\n        GlobalProperties gp = candidate.getGlobalProperties();\r\n        if (gp.getPartitioning() != PartitioningProperty.HASH_PARTITIONED || gp.getPartitioningFields() == null || !gp.getPartitioningFields().equals(this.solutionSetKeyFields)) {\r\n            throw new CompilerException(\"Bug: The solution set delta is not partitioned.\");\r\n        }\r\n    }\r\n        final GlobalProperties gp = new GlobalProperties();\r\n    gp.setHashPartitioned(this.solutionSetKeyFields);\r\n    gp.addUniqueFieldCombination(this.solutionSetKeyFields);\r\n    LocalProperties lp = LocalProperties.EMPTY.addUniqueFields(this.solutionSetKeyFields);\r\n        for (PlanNode solutionSetCandidate : solutionSetDeltaCandidates) {\r\n        for (PlanNode worksetCandidate : worksetCandidates) {\r\n                        if (this.singleRoot.areBranchCompatible(solutionSetCandidate, worksetCandidate)) {\r\n                SingleInputPlanNode siSolutionDeltaCandidate = (SingleInputPlanNode) solutionSetCandidate;\r\n                boolean immediateDeltaUpdate;\r\n                                if (siSolutionDeltaCandidate.getInput().getShipStrategy() == ShipStrategyType.FORWARD && this.solutionDeltaImmediatelyAfterSolutionJoin) {\r\n                                        if (siSolutionDeltaCandidate.getDriverStrategy() != DriverStrategy.UNARY_NO_OP || siSolutionDeltaCandidate.getInput().getLocalStrategy() != LocalStrategy.NONE) {\r\n                        throw new CompilerException(\"Invalid Solution set delta node.\");\r\n                    }\r\n                    solutionSetCandidate = siSolutionDeltaCandidate.getInput().getSource();\r\n                    immediateDeltaUpdate = true;\r\n                } else {\r\n                                                            siSolutionDeltaCandidate.getInput().setTempMode(TempMode.PIPELINE_BREAKER);\r\n                    immediateDeltaUpdate = false;\r\n                }\r\n                WorksetIterationPlanNode wsNode = new WorksetIterationPlanNode(this, this.getOperator().getName(), solutionSetIn, worksetIn, sspn, wspn, worksetCandidate, solutionSetCandidate);\r\n                wsNode.setImmediateSolutionSetUpdate(immediateDeltaUpdate);\r\n                wsNode.initProperties(gp, lp);\r\n                target.add(wsNode);\r\n            }\r\n        }\r\n    }\r\n}","lc":2.9545454545,"pi":1.5837320574,"ma":2.4,"nbd":1.5,"ml":2.4166666667,"d":0.9742063492,"mi":-1.2573643411,"fo":4.3333333333,"r":-0.0263157895,"e":7.0497697712}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3011_5a86a0a1","label":0,"code":"public void restart() {\r\n    try {\r\n        synchronized (progressLock) {\r\n            if (state != JobStatus.RESTARTING) {\r\n                throw new IllegalStateException(\"Can only restart job from state restarting.\");\r\n            }\r\n            if (scheduler == null) {\r\n                throw new IllegalStateException(\"The execution graph has not been scheduled before - scheduler is null.\");\r\n            }\r\n            this.currentExecutions.clear();\r\n            for (ExecutionJobVertex jv : this.verticesInCreationOrder) {\r\n                jv.resetForNewExecution();\r\n            }\r\n            for (int i = 0; i < stateTimestamps.length; i++) {\r\n                stateTimestamps[i] = 0;\r\n            }\r\n            numFinishedJobVertices = 0;\r\n            transitionState(JobStatus.RESTARTING, JobStatus.CREATED);\r\n            \/\/ if we have checkpointed state, reload it into the executions\r\n            if (checkpointCoordinator != null) {\r\n                checkpointCoordinator.restoreLatestCheckpointedState(getAllVertices(), false, false);\r\n            }\r\n        }\r\n        scheduleForExecution(scheduler);\r\n    } catch (Throwable t) {\r\n        fail(t);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void restart() {\r\n    try {\r\n        synchronized (progressLock) {\r\n            if (state != JobStatus.RESTARTING) {\r\n                throw new IllegalStateException(\"Can only restart job from state restarting.\");\r\n            }\r\n            if (scheduler == null) {\r\n                throw new IllegalStateException(\"The execution graph has not been scheduled before - scheduler is null.\");\r\n            }\r\n            this.currentExecutions.clear();\r\n            for (ExecutionJobVertex jv : this.verticesInCreationOrder) {\r\n                jv.resetForNewExecution();\r\n            }\r\n            for (int i = 0; i < stateTimestamps.length; i++) {\r\n                stateTimestamps[i] = 0;\r\n            }\r\n            numFinishedJobVertices = 0;\r\n            transitionState(JobStatus.RESTARTING, JobStatus.CREATED);\r\n                        if (checkpointCoordinator != null) {\r\n                checkpointCoordinator.restoreLatestCheckpointedState(getAllVertices(), false, false);\r\n            }\r\n        }\r\n        scheduleForExecution(scheduler);\r\n    } catch (Throwable t) {\r\n        fail(t);\r\n    }\r\n}","lc":0.5909090909,"pi":0.7320574163,"ma":1.0,"nbd":0.5,"ml":0.3333333333,"d":0.2301587302,"mi":-0.4178999295,"fo":0.0833333333,"r":0.0,"e":0.2406989275}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3620_1a2bc1bc","label":1,"code":"@Override\r\nprotected void invoke(WebResponse response) {\r\n    AppendingStringBuffer responseBuffer = new AppendingStringBuffer(builder);\r\n    List<IResponseFilter> responseFilters = Application.get().getRequestCycleSettings().getResponseFilters();\r\n    if (responseFilters != null) {\r\n        for (IResponseFilter filter : responseFilters) {\r\n            filter.filter(responseBuffer);\r\n        }\r\n    }\r\n    response.write(builder);\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void invoke(WebResponse response) {\r\n    AppendingStringBuffer responseBuffer = new AppendingStringBuffer(builder);\r\n    List<IResponseFilter> responseFilters = Application.get().getRequestCycleSettings().getResponseFilters();\r\n    if (responseFilters != null) {\r\n        for (IResponseFilter filter : responseFilters) {\r\n            filter.filter(responseBuffer);\r\n        }\r\n    }\r\n    response.write(builder);\r\n}","lc":-0.1363636364,"pi":0.2918660287,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.0674603175,"mi":0.1501057082,"fo":-0.0833333333,"r":0.1052631579,"e":-0.0731269054}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2172_ea4a3f8a","label":3,"code":"\/**\r\n *  @see IValueMap#getAsEnum(String, Class<T>, T)\r\n *\/\r\npublic <T extends Enum<T>> T getAsEnum(String key, Class<T> eClass, T defaultValue) {\r\n    return getEnumImpl(key, eClass, defaultValue);\r\n}","code_comment":"\/**\r\n *  @see IValueMap#getAsEnum(String, Class<T>, T)\r\n *\/\r\n","code_no_comment":"public <T extends Enum<T>> T getAsEnum(String key, Class<T> eClass, T defaultValue) {\r\n    return getEnumImpl(key, eClass, defaultValue);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8782241015,"fo":-0.4166666667,"r":0.5263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4113_27300d81","label":0,"code":"public static Text toText(ByteBuffer bytes) {\r\n    if (bytes == null)\r\n        return null;\r\n    Text result = new Text();\r\n    result.set(bytes.array(), bytes.position(), bytes.remaining());\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"public static Text toText(ByteBuffer bytes) {\r\n    if (bytes == null)\r\n        return null;\r\n    Text result = new Text();\r\n    result.set(bytes.array(), bytes.position(), bytes.remaining());\r\n    return result;\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.003968254,"mi":0.4311486963,"fo":-0.1666666667,"r":0.0789473684,"e":-0.0945511546}
{"project_name":"Cli","project_version":"25","label":1,"code":"\/**\r\n * Render the specified text and return the rendered Options\r\n * in a StringBuffer.\r\n *\r\n * @param sb The StringBuffer to place the rendered text into.\r\n * @param width The number of characters to display per line\r\n * @param nextLineTabStop The position on the next line for the first tab.\r\n * @param text The text to be rendered.\r\n *\r\n * @return the StringBuffer with the rendered Options contents.\r\n *\/\r\nprotected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\r\n    int pos = findWrapPos(text, width, 0);\r\n    if (pos == -1) {\r\n        sb.append(rtrim(text));\r\n        return sb;\r\n    }\r\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\r\n    if (nextLineTabStop >= width) {\r\n        \/\/ stops infinite loop happening\r\n        nextLineTabStop = width - 1;\r\n    }\r\n    \/\/ all following lines must be padded with nextLineTabStop space\r\n    \/\/ characters\r\n    final String padding = createPadding(nextLineTabStop);\r\n    while (true) {\r\n        text = padding + text.substring(pos).trim();\r\n        pos = findWrapPos(text, width, 0);\r\n        if (pos == -1) {\r\n            sb.append(text);\r\n            return sb;\r\n        }\r\n        if ((text.length() > width) && (pos == nextLineTabStop - 1)) {\r\n            pos = width;\r\n        }\r\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\r\n    }\r\n}","code_comment":"\/**\r\n * Render the specified text and return the rendered Options\r\n * in a StringBuffer.\r\n *\r\n * @param sb The StringBuffer to place the rendered text into.\r\n * @param width The number of characters to display per line\r\n * @param nextLineTabStop The position on the next line for the first tab.\r\n * @param text The text to be rendered.\r\n *\r\n * @return the StringBuffer with the rendered Options contents.\r\n *\/\r\n","code_no_comment":"protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\r\n    int pos = findWrapPos(text, width, 0);\r\n    if (pos == -1) {\r\n        sb.append(rtrim(text));\r\n        return sb;\r\n    }\r\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\r\n    if (nextLineTabStop >= width) {\r\n                nextLineTabStop = width - 1;\r\n    }\r\n            final String padding = createPadding(nextLineTabStop);\r\n    while (true) {\r\n        text = padding + text.substring(pos).trim();\r\n        pos = findWrapPos(text, width, 0);\r\n        if (pos == -1) {\r\n            sb.append(text);\r\n            return sb;\r\n        }\r\n        if ((text.length() > width) && (pos == nextLineTabStop - 1)) {\r\n            pos = width;\r\n        }\r\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\r\n    }\r\n}","lc":0.4545454545,"pi":0.1244019139,"ma":0.4,"nbd":0.0,"ml":0.4166666667,"d":1.7321428571,"mi":-0.4040873855,"fo":0.9166666667,"r":-0.0263157895,"e":1.9693412401}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2487_f2920c26","label":0,"code":"\/**\r\n * @param b\r\n *          copy bytes\r\n *\/\r\npublic void copy(byte[] b) {\r\n    this.value = new byte[b.length];\r\n    System.arraycopy(b, 0, this.value, 0, b.length);\r\n}","code_comment":"\/**\r\n * @param b\r\n *          copy bytes\r\n *\/\r\n","code_no_comment":"public void copy(byte[] b) {\r\n    this.value = new byte[b.length];\r\n    System.arraycopy(b, 0, this.value, 0, b.length);\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7719520789,"fo":-0.4166666667,"r":2.2368421053,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1822_3e83a4c1","label":1,"code":"@Override\r\npublic <T extends Document> boolean create(Collection<T> collection, List<UpdateOp> updateOps) {\r\n    log(\"create\", updateOps);\r\n    List<T> docs = new ArrayList<T>();\r\n    DBObject[] inserts = new DBObject[updateOps.size()];\r\n    for (int i = 0; i < updateOps.size(); i++) {\r\n        inserts[i] = new BasicDBObject();\r\n        UpdateOp update = updateOps.get(i);\r\n        T target = collection.newDocument(this);\r\n        UpdateUtils.applyChanges(target, update, comparator);\r\n        docs.add(target);\r\n        for (Entry<Key, Operation> entry : update.getChanges().entrySet()) {\r\n            Key k = entry.getKey();\r\n            Operation op = entry.getValue();\r\n            switch(op.type) {\r\n                case SET:\r\n                case INCREMENT:\r\n                    {\r\n                        inserts[i].put(k.toString(), op.value);\r\n                        break;\r\n                    }\r\n                case SET_MAP_ENTRY:\r\n                    {\r\n                        Revision r = k.getRevision();\r\n                        if (r == null) {\r\n                            throw new IllegalStateException(\"SET_MAP_ENTRY must not have null revision\");\r\n                        }\r\n                        DBObject value = new RevisionEntry(r, op.value);\r\n                        inserts[i].put(k.getName(), value);\r\n                        break;\r\n                    }\r\n                case REMOVE_MAP_ENTRY:\r\n                    \/\/ nothing to do for new entries\r\n                    break;\r\n                case CONTAINS_MAP_ENTRY:\r\n                    \/\/ no effect\r\n                    break;\r\n            }\r\n        }\r\n        if (!inserts[i].containsField(Document.MOD_COUNT)) {\r\n            inserts[i].put(Document.MOD_COUNT, 1L);\r\n            target.put(Document.MOD_COUNT, 1L);\r\n        }\r\n    }\r\n    DBCollection dbCollection = getDBCollection(collection);\r\n    long start = start();\r\n    try {\r\n        try {\r\n            WriteResult writeResult = dbCollection.insert(inserts, WriteConcern.SAFE);\r\n            if (writeResult.getError() != null) {\r\n                return false;\r\n            }\r\n            if (collection == Collection.NODES) {\r\n                for (T doc : docs) {\r\n                    Lock lock = getAndLock(doc.getId());\r\n                    try {\r\n                        addToCache((NodeDocument) doc);\r\n                    } finally {\r\n                        lock.unlock();\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        } catch (MongoException e) {\r\n            return false;\r\n        }\r\n    } finally {\r\n        end(\"create\", start);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic <T extends Document> boolean create(Collection<T> collection, List<UpdateOp> updateOps) {\r\n    log(\"create\", updateOps);\r\n    List<T> docs = new ArrayList<T>();\r\n    DBObject[] inserts = new DBObject[updateOps.size()];\r\n    for (int i = 0; i < updateOps.size(); i++) {\r\n        inserts[i] = new BasicDBObject();\r\n        UpdateOp update = updateOps.get(i);\r\n        T target = collection.newDocument(this);\r\n        UpdateUtils.applyChanges(target, update, comparator);\r\n        docs.add(target);\r\n        for (Entry<Key, Operation> entry : update.getChanges().entrySet()) {\r\n            Key k = entry.getKey();\r\n            Operation op = entry.getValue();\r\n            switch(op.type) {\r\n                case SET:\r\n                case INCREMENT:\r\n                    {\r\n                        inserts[i].put(k.toString(), op.value);\r\n                        break;\r\n                    }\r\n                case SET_MAP_ENTRY:\r\n                    {\r\n                        Revision r = k.getRevision();\r\n                        if (r == null) {\r\n                            throw new IllegalStateException(\"SET_MAP_ENTRY must not have null revision\");\r\n                        }\r\n                        DBObject value = new RevisionEntry(r, op.value);\r\n                        inserts[i].put(k.getName(), value);\r\n                        break;\r\n                    }\r\n                case REMOVE_MAP_ENTRY:\r\n                                        break;\r\n                case CONTAINS_MAP_ENTRY:\r\n                                        break;\r\n            }\r\n        }\r\n        if (!inserts[i].containsField(Document.MOD_COUNT)) {\r\n            inserts[i].put(Document.MOD_COUNT, 1L);\r\n            target.put(Document.MOD_COUNT, 1L);\r\n        }\r\n    }\r\n    DBCollection dbCollection = getDBCollection(collection);\r\n    long start = start();\r\n    try {\r\n        try {\r\n            WriteResult writeResult = dbCollection.insert(inserts, WriteConcern.SAFE);\r\n            if (writeResult.getError() != null) {\r\n                return false;\r\n            }\r\n            if (collection == Collection.NODES) {\r\n                for (T doc : docs) {\r\n                    Lock lock = getAndLock(doc.getId());\r\n                    try {\r\n                        addToCache((NodeDocument) doc);\r\n                    } finally {\r\n                        lock.unlock();\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        } catch (MongoException e) {\r\n            return false;\r\n        }\r\n    } finally {\r\n        end(\"create\", start);\r\n    }\r\n}","lc":2.4545454545,"pi":2.0765550239,"ma":3.0,"nbd":1.5,"ml":1.0,"d":0.7738095238,"mi":-1.10260747,"fo":1.8333333333,"r":-0.0263157895,"e":2.8213735355}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2065_9da430fb","label":1,"code":"private void appendValue(AppendingStringBuffer url, String key, String value) {\r\n    String escapedValue = urlEncodePathComponent(value);\r\n    if (!Strings.isEmpty(escapedValue)) {\r\n        if (!url.endsWith(\"\/\")) {\r\n            url.append(\"\/\");\r\n        }\r\n        url.append(key).append(\"\/\").append(escapedValue).append(\"\/\");\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void appendValue(AppendingStringBuffer url, String key, String value) {\r\n    String escapedValue = urlEncodePathComponent(value);\r\n    if (!Strings.isEmpty(escapedValue)) {\r\n        if (!url.endsWith(\"\/\")) {\r\n            url.append(\"\/\");\r\n        }\r\n        url.append(key).append(\"\/\").append(escapedValue).append(\"\/\");\r\n    }\r\n}","lc":-0.2272727273,"pi":0.3732057416,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":0.0595238095,"mi":0.2389006342,"fo":0.1666666667,"r":0.0526315789,"e":-0.0323853322}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4509_b672cb2d","label":1,"code":"\/**\r\n *  for urls that point to local files (e.g. 'file:' or 'jar:file:') this methods returns a\r\n *  reference to the local file\r\n *\r\n *  @param url\r\n *             url of the resource\r\n *\r\n *  @return reference to a local file if url contains one, <code>null<\/code> otherwise\r\n *\r\n *  @see #getLocalFileFromUrl(String)\r\n *\/\r\npublic static File getLocalFileFromUrl(URL url) {\r\n    return getLocalFileFromUrl(Args.notNull(url, \"url\").toExternalForm());\r\n}","code_comment":"\/**\r\n *  for urls that point to local files (e.g. 'file:' or 'jar:file:') this methods returns a\r\n *  reference to the local file\r\n *\r\n *  @param url\r\n *             url of the resource\r\n *\r\n *  @return reference to a local file if url contains one, <code>null<\/code> otherwise\r\n *\r\n *  @see #getLocalFileFromUrl(String)\r\n *\/\r\n","code_no_comment":"public static File getLocalFileFromUrl(URL url) {\r\n    return getLocalFileFromUrl(Args.notNull(url, \"url\").toExternalForm());\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9568710359,"fo":-0.25,"r":2.5,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"private final Component children_remove(int index) {\r\n    if (children instanceof Component) {\r\n        if (index == 0) {\r\n            final Component removed = (Component) children;\r\n            this.children = null;\r\n            return removed;\r\n        } else {\r\n            throw new IndexOutOfBoundsException();\r\n        }\r\n    } else {\r\n        Component[] c = ((Component[]) children);\r\n        final Component removed = c[index];\r\n        if (c.length == 2) {\r\n            if (index == 0) {\r\n                this.children = c[1];\r\n            } else if (index == 1) {\r\n                this.children = c[0];\r\n            } else {\r\n                throw new IndexOutOfBoundsException();\r\n            }\r\n        } else {\r\n            Component[] newChildren = new Component[c.length - 1];\r\n            int j = 0;\r\n            for (int i = 0; i < c.length; i++) {\r\n                if (i != index) {\r\n                    newChildren[j++] = c[i];\r\n                }\r\n            }\r\n            this.children = newChildren;\r\n        }\r\n        return removed;\r\n    }\r\n}","code_comment":null,"code_no_comment":"private final Component children_remove(int index) {\r\n    if (children instanceof Component) {\r\n        if (index == 0) {\r\n            final Component removed = (Component) children;\r\n            this.children = null;\r\n            return removed;\r\n        } else {\r\n            throw new IndexOutOfBoundsException();\r\n        }\r\n    } else {\r\n        Component[] c = ((Component[]) children);\r\n        final Component removed = c[index];\r\n        if (c.length == 2) {\r\n            if (index == 0) {\r\n                this.children = c[1];\r\n            } else if (index == 1) {\r\n                this.children = c[0];\r\n            } else {\r\n                throw new IndexOutOfBoundsException();\r\n            }\r\n        } else {\r\n            Component[] newChildren = new Component[c.length - 1];\r\n            int j = 0;\r\n            for (int i = 0; i < c.length; i++) {\r\n                if (i != index) {\r\n                    newChildren[j++] = c[i];\r\n                }\r\n            }\r\n            this.children = newChildren;\r\n        }\r\n        return removed;\r\n    }\r\n}","lc":0.8636363636,"pi":0.7320574163,"ma":1.2,"nbd":1.0,"ml":0.5,"d":1.9047619048,"mi":-0.5472868217,"fo":-0.5,"r":0.0,"e":1.7419131758}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1044_9396979b","label":0,"code":"public List<Short> check(Environment env, Mutation mutation) {\r\n    ArrayList<Short> violations = null;\r\n    Collection<ColumnUpdate> colUpdates = mutation.getUpdates();\r\n    \/\/ check the row, it should contains at least one ; or end with <\r\n    boolean containsSemiC = false;\r\n    byte[] row = mutation.getRow();\r\n    \/\/ always allow rows that fall within reserved area\r\n    if (row.length > 0 && row[0] == '~')\r\n        return null;\r\n    for (byte b : row) {\r\n        if (b == ';') {\r\n            containsSemiC = true;\r\n        }\r\n        if (b == ';' || b == '<')\r\n            break;\r\n        if (!validTableNameChars[0xff & b]) {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            if (!violations.contains((short) 4))\r\n                violations.add((short) 4);\r\n        }\r\n    }\r\n    if (!containsSemiC) {\r\n        \/\/ see if last row char is <\r\n        if (row.length == 0 || row[row.length - 1] != '<') {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            if (!violations.contains((short) 4))\r\n                violations.add((short) 4);\r\n        }\r\n    } else {\r\n        if (row.length == 0) {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            if (!violations.contains((short) 4))\r\n                violations.add((short) 4);\r\n        }\r\n    }\r\n    if (row.length > 0 && row[0] == '!') {\r\n        if (row.length < 3 || row[1] != '0' || (row[2] != '<' && row[2] != ';')) {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            if (!violations.contains((short) 4))\r\n                violations.add((short) 4);\r\n        }\r\n    }\r\n    \/\/ ensure row is not less than Constants.METADATA_TABLE_ID\r\n    if (new Text(row).compareTo(new Text(Constants.METADATA_TABLE_ID)) < 0) {\r\n        if (violations == null)\r\n            violations = new ArrayList<Short>();\r\n        violations.add((short) 5);\r\n    }\r\n    for (ColumnUpdate columnUpdate : colUpdates) {\r\n        Text columnFamily = new Text(columnUpdate.getColumnFamily());\r\n        if (columnUpdate.isDeleted()) {\r\n            if (!isValidColumn(columnUpdate)) {\r\n                if (violations == null)\r\n                    violations = new ArrayList<Short>();\r\n                violations.add((short) 2);\r\n            }\r\n            continue;\r\n        }\r\n        if (columnUpdate.getValue().length == 0 && !columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            violations.add((short) 6);\r\n        }\r\n        if (columnFamily.equals(Constants.METADATA_DATAFILE_COLUMN_FAMILY)) {\r\n            try {\r\n                DataFileValue dfv = new DataFileValue(columnUpdate.getValue());\r\n                if (dfv.getSize() < 0 || dfv.getNumEntries() < 0) {\r\n                    if (violations == null)\r\n                        violations = new ArrayList<Short>();\r\n                    violations.add((short) 1);\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n                if (violations == null)\r\n                    violations = new ArrayList<Short>();\r\n                violations.add((short) 1);\r\n            } catch (ArrayIndexOutOfBoundsException aiooe) {\r\n                if (violations == null)\r\n                    violations = new ArrayList<Short>();\r\n                violations.add((short) 1);\r\n            }\r\n        } else if (columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\r\n        } else {\r\n            if (!isValidColumn(columnUpdate)) {\r\n                if (violations == null)\r\n                    violations = new ArrayList<Short>();\r\n                violations.add((short) 2);\r\n            } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_PREV_ROW_COLUMN) && columnUpdate.getValue().length > 0 && (violations == null || !violations.contains((short) 4))) {\r\n                KeyExtent ke = new KeyExtent(new Text(mutation.getRow()), (Text) null);\r\n                Text per = KeyExtent.decodePrevEndRow(new Value(columnUpdate.getValue()));\r\n                boolean prevEndRowLessThanEndRow = per == null || ke.getEndRow() == null || per.compareTo(ke.getEndRow()) < 0;\r\n                if (!prevEndRowLessThanEndRow) {\r\n                    if (violations == null)\r\n                        violations = new ArrayList<Short>();\r\n                    violations.add((short) 3);\r\n                }\r\n            } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_LOCK_COLUMN)) {\r\n                if (zooCache == null) {\r\n                    zooCache = new ZooCache();\r\n                }\r\n                if (zooRoot == null) {\r\n                    zooRoot = ZooUtil.getRoot(HdfsZooInstance.getInstance());\r\n                }\r\n                boolean lockHeld = false;\r\n                String lockId = new String(columnUpdate.getValue());\r\n                try {\r\n                    lockHeld = ZooLock.isLockHeld(zooCache, new ZooUtil.LockID(zooRoot, lockId));\r\n                } catch (Exception e) {\r\n                    log.debug(\"Failed to verify lock was held \" + lockId + \" \" + e.getMessage());\r\n                }\r\n                if (!lockHeld) {\r\n                    if (violations == null)\r\n                        violations = new ArrayList<Short>();\r\n                    violations.add((short) 7);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (violations != null) {\r\n        log.debug(\" violating metadata mutation : \" + mutation);\r\n    }\r\n    return violations;\r\n}","code_comment":null,"code_no_comment":"public List<Short> check(Environment env, Mutation mutation) {\r\n    ArrayList<Short> violations = null;\r\n    Collection<ColumnUpdate> colUpdates = mutation.getUpdates();\r\n        boolean containsSemiC = false;\r\n    byte[] row = mutation.getRow();\r\n        if (row.length > 0 && row[0] == '~')\r\n        return null;\r\n    for (byte b : row) {\r\n        if (b == ';') {\r\n            containsSemiC = true;\r\n        }\r\n        if (b == ';' || b == '<')\r\n            break;\r\n        if (!validTableNameChars[0xff & b]) {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            if (!violations.contains((short) 4))\r\n                violations.add((short) 4);\r\n        }\r\n    }\r\n    if (!containsSemiC) {\r\n                if (row.length == 0 || row[row.length - 1] != '<') {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            if (!violations.contains((short) 4))\r\n                violations.add((short) 4);\r\n        }\r\n    } else {\r\n        if (row.length == 0) {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            if (!violations.contains((short) 4))\r\n                violations.add((short) 4);\r\n        }\r\n    }\r\n    if (row.length > 0 && row[0] == '!') {\r\n        if (row.length < 3 || row[1] != '0' || (row[2] != '<' && row[2] != ';')) {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            if (!violations.contains((short) 4))\r\n                violations.add((short) 4);\r\n        }\r\n    }\r\n        if (new Text(row).compareTo(new Text(Constants.METADATA_TABLE_ID)) < 0) {\r\n        if (violations == null)\r\n            violations = new ArrayList<Short>();\r\n        violations.add((short) 5);\r\n    }\r\n    for (ColumnUpdate columnUpdate : colUpdates) {\r\n        Text columnFamily = new Text(columnUpdate.getColumnFamily());\r\n        if (columnUpdate.isDeleted()) {\r\n            if (!isValidColumn(columnUpdate)) {\r\n                if (violations == null)\r\n                    violations = new ArrayList<Short>();\r\n                violations.add((short) 2);\r\n            }\r\n            continue;\r\n        }\r\n        if (columnUpdate.getValue().length == 0 && !columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\r\n            if (violations == null)\r\n                violations = new ArrayList<Short>();\r\n            violations.add((short) 6);\r\n        }\r\n        if (columnFamily.equals(Constants.METADATA_DATAFILE_COLUMN_FAMILY)) {\r\n            try {\r\n                DataFileValue dfv = new DataFileValue(columnUpdate.getValue());\r\n                if (dfv.getSize() < 0 || dfv.getNumEntries() < 0) {\r\n                    if (violations == null)\r\n                        violations = new ArrayList<Short>();\r\n                    violations.add((short) 1);\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n                if (violations == null)\r\n                    violations = new ArrayList<Short>();\r\n                violations.add((short) 1);\r\n            } catch (ArrayIndexOutOfBoundsException aiooe) {\r\n                if (violations == null)\r\n                    violations = new ArrayList<Short>();\r\n                violations.add((short) 1);\r\n            }\r\n        } else if (columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\r\n        } else {\r\n            if (!isValidColumn(columnUpdate)) {\r\n                if (violations == null)\r\n                    violations = new ArrayList<Short>();\r\n                violations.add((short) 2);\r\n            } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_PREV_ROW_COLUMN) && columnUpdate.getValue().length > 0 && (violations == null || !violations.contains((short) 4))) {\r\n                KeyExtent ke = new KeyExtent(new Text(mutation.getRow()), (Text) null);\r\n                Text per = KeyExtent.decodePrevEndRow(new Value(columnUpdate.getValue()));\r\n                boolean prevEndRowLessThanEndRow = per == null || ke.getEndRow() == null || per.compareTo(ke.getEndRow()) < 0;\r\n                if (!prevEndRowLessThanEndRow) {\r\n                    if (violations == null)\r\n                        violations = new ArrayList<Short>();\r\n                    violations.add((short) 3);\r\n                }\r\n            } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_LOCK_COLUMN)) {\r\n                if (zooCache == null) {\r\n                    zooCache = new ZooCache();\r\n                }\r\n                if (zooRoot == null) {\r\n                    zooRoot = ZooUtil.getRoot(HdfsZooInstance.getInstance());\r\n                }\r\n                boolean lockHeld = false;\r\n                String lockId = new String(columnUpdate.getValue());\r\n                try {\r\n                    lockHeld = ZooLock.isLockHeld(zooCache, new ZooUtil.LockID(zooRoot, lockId));\r\n                } catch (Exception e) {\r\n                    log.debug(\"Failed to verify lock was held \" + lockId + \" \" + e.getMessage());\r\n                }\r\n                if (!lockHeld) {\r\n                    if (violations == null)\r\n                        violations = new ArrayList<Short>();\r\n                    violations.add((short) 7);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (violations != null) {\r\n        log.debug(\" violating metadata mutation : \" + mutation);\r\n    }\r\n    return violations;\r\n}","lc":4.9090909091,"pi":1.2344497608,"ma":9.0,"nbd":2.5,"ml":5.6666666667,"d":3.2619047619,"mi":-1.6993657505,"fo":3.5,"r":-0.0263157895,"e":23.7386144776}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-43_668f08f2","label":1,"code":"public void serialize(Binding binding) throws Exception {\r\n    binding.write(\"rootNodeId\", rootNodeId.getBytes());\r\n    binding.write(\"commitTS\", commitTS);\r\n    binding.write(\"msg\", msg == null ? \"\" : msg);\r\n    binding.write(\"parentId\", parentId == null ? \"\" : parentId.toString());\r\n}","code_comment":null,"code_no_comment":"public void serialize(Binding binding) throws Exception {\r\n    binding.write(\"rootNodeId\", rootNodeId.getBytes());\r\n    binding.write(\"commitTS\", commitTS);\r\n    binding.write(\"msg\", msg == null ? \"\" : msg);\r\n    binding.write(\"parentId\", parentId == null ? \"\" : parentId.toString());\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.2,"nbd":-1.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.4367864693,"fo":0.0,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"@Override\r\npublic Iterable<Tree> getChildren() {\r\n    return new Iterable<Tree>() {\r\n\r\n        @Override\r\n        public Iterator<Tree> iterator() {\r\n            Iterator<? extends ChildNodeEntry> childEntries = getNodeState().getChildNodeEntries().iterator();\r\n            return Iterators.map(childEntries, new Function1<ChildNodeEntry, Tree>() {\r\n\r\n                @Override\r\n                public Tree apply(ChildNodeEntry entry) {\r\n                    NodeStateBuilder childBuilder = builder.getChildBuilder(entry.getName());\r\n                    return new TreeImpl(store, childBuilder.getNodeState(), childBuilder, TreeImpl.this, entry.getName(), listener);\r\n                }\r\n            });\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Iterable<Tree> getChildren() {\r\n    return new Iterable<Tree>() {\r\n\r\n        @Override\r\n        public Iterator<Tree> iterator() {\r\n            Iterator<? extends ChildNodeEntry> childEntries = getNodeState().getChildNodeEntries().iterator();\r\n            return Iterators.map(childEntries, new Function1<ChildNodeEntry, Tree>() {\r\n\r\n                @Override\r\n                public Tree apply(ChildNodeEntry entry) {\r\n                    NodeStateBuilder childBuilder = builder.getChildBuilder(entry.getName());\r\n                    return new TreeImpl(store, childBuilder.getNodeState(), childBuilder, TreeImpl.this, entry.getName(), listener);\r\n                }\r\n            });\r\n        }\r\n    };\r\n}","lc":0.0909090909,"pi":1.7416267943,"ma":-0.6,"nbd":0.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.0782241015,"fo":0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Compress","project_version":"10","label":1,"code":"\/**\r\n * Walks through all recorded entries and adds the data available\r\n * from the local file header.\r\n *\r\n * <p>Also records the offsets for the data to read from the\r\n * entries.<\/p>\r\n *\/\r\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag) throws IOException {\r\n    \/\/ directory order\r\n    for (ZipArchiveEntry ze : entries.keySet()) {\r\n        OffsetEntry offsetEntry = entries.get(ze);\r\n        long offset = offsetEntry.headerOffset;\r\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\r\n        byte[] b = new byte[SHORT];\r\n        archive.readFully(b);\r\n        int fileNameLen = ZipShort.getValue(b);\r\n        archive.readFully(b);\r\n        int extraFieldLen = ZipShort.getValue(b);\r\n        int lenToSkip = fileNameLen;\r\n        while (lenToSkip > 0) {\r\n            int skipped = archive.skipBytes(lenToSkip);\r\n            if (skipped <= 0) {\r\n                throw new RuntimeException(\"failed to skip file name in\" + \" local file header\");\r\n            }\r\n            lenToSkip -= skipped;\r\n        }\r\n        byte[] localExtraData = new byte[extraFieldLen];\r\n        archive.readFully(localExtraData);\r\n        ze.setExtra(localExtraData);\r\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen;\r\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\r\n            String orig = ze.getName();\r\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\r\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name, nc.comment);\r\n            if (!orig.equals(ze.getName())) {\r\n                nameMap.remove(orig);\r\n                nameMap.put(ze.getName(), ze);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Walks through all recorded entries and adds the data available\r\n * from the local file header.\r\n *\r\n * <p>Also records the offsets for the data to read from the\r\n * entries.<\/p>\r\n *\/\r\n","code_no_comment":"private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag) throws IOException {\r\n        for (ZipArchiveEntry ze : entries.keySet()) {\r\n        OffsetEntry offsetEntry = entries.get(ze);\r\n        long offset = offsetEntry.headerOffset;\r\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\r\n        byte[] b = new byte[SHORT];\r\n        archive.readFully(b);\r\n        int fileNameLen = ZipShort.getValue(b);\r\n        archive.readFully(b);\r\n        int extraFieldLen = ZipShort.getValue(b);\r\n        int lenToSkip = fileNameLen;\r\n        while (lenToSkip > 0) {\r\n            int skipped = archive.skipBytes(lenToSkip);\r\n            if (skipped <= 0) {\r\n                throw new RuntimeException(\"failed to skip file name in\" + \" local file header\");\r\n            }\r\n            lenToSkip -= skipped;\r\n        }\r\n        byte[] localExtraData = new byte[extraFieldLen];\r\n        archive.readFully(localExtraData);\r\n        ze.setExtra(localExtraData);\r\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen;\r\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\r\n            String orig = ze.getName();\r\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\r\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name, nc.comment);\r\n            if (!orig.equals(ze.getName())) {\r\n                nameMap.remove(orig);\r\n                nameMap.put(ze.getName(), ze);\r\n            }\r\n        }\r\n    }\r\n}","lc":0.8636363636,"pi":0.3492822967,"ma":0.6,"nbd":0.5,"ml":0.4166666667,"d":0.8869047619,"mi":-0.6217054264,"fo":1.0833333333,"r":-0.0263157895,"e":1.8302565078}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1215_a9efe3c4","label":0,"code":"private boolean matchesPropertyType(PropertyValue value) {\r\n    if (value == null) {\r\n        return false;\r\n    }\r\n    if (propertyType == PropertyType.UNDEFINED) {\r\n        return true;\r\n    }\r\n    return value.getType().tag() == propertyType;\r\n}","code_comment":null,"code_no_comment":"private boolean matchesPropertyType(PropertyValue value) {\r\n    if (value == null) {\r\n        return false;\r\n    }\r\n    if (propertyType == PropertyType.UNDEFINED) {\r\n        return true;\r\n    }\r\n    return value.getType().tag() == propertyType;\r\n}","lc":-0.2272727273,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.3392529951,"fo":-0.3333333333,"r":1.0789473684,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5689_2ac29d30","label":3,"code":"\/**\r\n *  @param sessionId\r\n *  @param url\r\n *  @return buffered response\r\n *\/\r\npublic BufferedWebResponse getAndRemoveBufferedResponse(String sessionId, Url url) {\r\n    String key = sessionId + url.toString();\r\n    return storedResponses.remove(key);\r\n}","code_comment":"\/**\r\n *  @param sessionId\r\n *  @param url\r\n *  @return buffered response\r\n *\/\r\n","code_no_comment":"public BufferedWebResponse getAndRemoveBufferedResponse(String sessionId, Url url) {\r\n    String key = sessionId + url.toString();\r\n    return storedResponses.remove(key);\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.0952380952,"mi":0.7310782241,"fo":-0.3333333333,"r":2.5789473684,"e":-0.1232459098}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3719_5ad32df9","label":1,"code":"public final IMarkupFragment find(final String id) {\r\n    if (Strings.isEmpty(id)) {\r\n        throw new IllegalArgumentException(\"Parameter 'id' must not be null or empty\");\r\n    }\r\n    MarkupStream stream = new MarkupStream(this);\r\n    stream.setCurrentIndex(0);\r\n    while (stream.hasMore()) {\r\n        MarkupElement elem = stream.get();\r\n        if (elem instanceof ComponentTag) {\r\n            ComponentTag tag = stream.getTag();\r\n            if (tag.isOpen() || tag.isOpenClose()) {\r\n                if (tag.getId().equals(id)) {\r\n                    return stream.getMarkupFragment();\r\n                }\r\n                if (tag.isOpen() && !tag.hasNoCloseTag() && !(tag instanceof WicketTag) && !\"head\".equals(tag.getName()) && !tag.isAutoComponentTag()) {\r\n                    stream.skipToMatchingCloseTag(tag);\r\n                }\r\n            }\r\n        }\r\n        stream.next();\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"public final IMarkupFragment find(final String id) {\r\n    if (Strings.isEmpty(id)) {\r\n        throw new IllegalArgumentException(\"Parameter 'id' must not be null or empty\");\r\n    }\r\n    MarkupStream stream = new MarkupStream(this);\r\n    stream.setCurrentIndex(0);\r\n    while (stream.hasMore()) {\r\n        MarkupElement elem = stream.get();\r\n        if (elem instanceof ComponentTag) {\r\n            ComponentTag tag = stream.getTag();\r\n            if (tag.isOpen() || tag.isOpenClose()) {\r\n                if (tag.getId().equals(id)) {\r\n                    return stream.getMarkupFragment();\r\n                }\r\n                if (tag.isOpen() && !tag.hasNoCloseTag() && !(tag instanceof WicketTag) && !\"head\".equals(tag.getName()) && !tag.isAutoComponentTag()) {\r\n                    stream.skipToMatchingCloseTag(tag);\r\n                }\r\n            }\r\n        }\r\n        stream.next();\r\n    }\r\n    return null;\r\n}","lc":0.4090909091,"pi":1.4019138756,"ma":0.8,"nbd":1.0,"ml":1.5,"d":0.3075396825,"mi":-0.3598308668,"fo":0.9166666667,"r":-0.0263157895,"e":0.3670452908}
{"project_name":"Lang","project_version":"40","label":1,"code":"\/**\r\n * <p>Checks if String contains a search String irrespective of case,\r\n * handling <code>null<\/code>. Case-insensitivity is defined as by\r\n * {@link String#equalsIgnoreCase(String)}.\r\n *\r\n * <p>A <code>null<\/code> String will return <code>false<\/code>.<\/p>\r\n *\r\n * <pre>\r\n * StringUtils.contains(null, *) = false\r\n * StringUtils.contains(*, null) = false\r\n * StringUtils.contains(\"\", \"\") = true\r\n * StringUtils.contains(\"abc\", \"\") = true\r\n * StringUtils.contains(\"abc\", \"a\") = true\r\n * StringUtils.contains(\"abc\", \"z\") = false\r\n * StringUtils.contains(\"abc\", \"A\") = true\r\n * StringUtils.contains(\"abc\", \"Z\") = false\r\n * <\/pre>\r\n *\r\n * @param str  the String to check, may be null\r\n * @param searchStr  the String to find, may be null\r\n * @return true if the String contains the search String irrespective of\r\n * case or false if not or <code>null<\/code> string input\r\n *\/\r\npublic static boolean containsIgnoreCase(String str, String searchStr) {\r\n    if (str == null || searchStr == null) {\r\n        return false;\r\n    }\r\n    return contains(str.toUpperCase(), searchStr.toUpperCase());\r\n}","code_comment":"\/**\r\n * <p>Checks if String contains a search String irrespective of case,\r\n * handling <code>null<\/code>. Case-insensitivity is defined as by\r\n * {@link String#equalsIgnoreCase(String)}.\r\n *\r\n * <p>A <code>null<\/code> String will return <code>false<\/code>.<\/p>\r\n *\r\n * <pre>\r\n * StringUtils.contains(null, *) = false\r\n * StringUtils.contains(*, null) = false\r\n * StringUtils.contains(\"\", \"\") = true\r\n * StringUtils.contains(\"abc\", \"\") = true\r\n * StringUtils.contains(\"abc\", \"a\") = true\r\n * StringUtils.contains(\"abc\", \"z\") = false\r\n * StringUtils.contains(\"abc\", \"A\") = true\r\n * StringUtils.contains(\"abc\", \"Z\") = false\r\n * <\/pre>\r\n *\r\n * @param str  the String to check, may be null\r\n * @param searchStr  the String to find, may be null\r\n * @return true if the String contains the search String irrespective of\r\n * case or false if not or <code>null<\/code> string input\r\n *\/\r\n","code_no_comment":"public static boolean containsIgnoreCase(String str, String searchStr) {\r\n    if (str == null || searchStr == null) {\r\n        return false;\r\n    }\r\n    return contains(str.toUpperCase(), searchStr.toUpperCase());\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0119047619,"mi":0.5329105004,"fo":-0.25,"r":0.0526315789,"e":-0.1089215839}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2246_dcadb0e1","label":1,"code":"private void collectUUIDs(Tree tree) {\r\n    if (tree == null) {\r\n        return;\r\n    }\r\n    String uuid = TreeUtil.getString(tree, JcrConstants.JCR_UUID);\r\n    if (uuid != null) {\r\n        uuids.add(uuid);\r\n    }\r\n    for (Tree child : tree.getChildren()) {\r\n        collectUUIDs(child);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void collectUUIDs(Tree tree) {\r\n    if (tree == null) {\r\n        return;\r\n    }\r\n    String uuid = TreeUtil.getString(tree, JcrConstants.JCR_UUID);\r\n    if (uuid != null) {\r\n        uuids.add(uuid);\r\n    }\r\n    for (Tree child : tree.getChildren()) {\r\n        collectUUIDs(child);\r\n    }\r\n}","lc":-0.0909090909,"pi":-0.2057416268,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0476190476,"mi":0.1244538407,"fo":-0.1666666667,"r":0.4473684211,"e":-0.079742743}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-369_4e245a76","label":3,"code":"\/\/ -----------------------------------------------------------< private >---\r\nprivate TreeLocation getChildLocation(String relPath) throws InvalidItemStateException {\r\n    return getLocation().getChild(relPath);\r\n}","code_comment":null,"code_no_comment":"private TreeLocation getChildLocation(String relPath) throws InvalidItemStateException {\r\n    return getLocation().getChild(relPath);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.986187456,"fo":-0.3333333333,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6743_745a85ab","label":1,"code":"public Expression createExpression(CamelContext camelContext, Annotation annotation, LanguageAnnotation languageAnnotation, Class<?> expressionReturnType) {\r\n    String languageName = languageAnnotation.language();\r\n    if (languageName == null) {\r\n        throw new IllegalArgumentException(\"Cannot determine the language from the annotation: \" + annotation);\r\n    }\r\n    Language language = camelContext.resolveLanguage(languageName);\r\n    if (language == null) {\r\n        throw new IllegalArgumentException(\"Cannot find the language: \" + languageName + \" on the classpath\");\r\n    }\r\n    String expression = getExpressionFromAnnotation(annotation);\r\n    return language.createExpression(expression);\r\n}","code_comment":null,"code_no_comment":"public Expression createExpression(CamelContext camelContext, Annotation annotation, LanguageAnnotation languageAnnotation, Class<?> expressionReturnType) {\r\n    String languageName = languageAnnotation.language();\r\n    if (languageName == null) {\r\n        throw new IllegalArgumentException(\"Cannot determine the language from the annotation: \" + annotation);\r\n    }\r\n    Language language = camelContext.resolveLanguage(languageName);\r\n    if (language == null) {\r\n        throw new IllegalArgumentException(\"Cannot find the language: \" + languageName + \" on the classpath\");\r\n    }\r\n    String expression = getExpressionFromAnnotation(annotation);\r\n    return language.createExpression(expression);\r\n}","lc":-0.0909090909,"pi":-0.3253588517,"ma":0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0376984127,"mi":0.0255109232,"fo":-0.1666666667,"r":0.0526315789,"e":-0.0016758585}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-776_dc9f23d9","label":3,"code":"\/**\r\n * A convenience method for setting the start timestamp accepted by the timestamp filter.\r\n *\r\n * @param is\r\n *          the iterator setting object to configure\r\n * @param start\r\n *          the start timestamp\r\n * @param startInclusive\r\n *          boolean indicating whether the start is inclusive\r\n *\/\r\npublic static void setStart(IteratorSetting is, long start, boolean startInclusive) {\r\n    SimpleDateFormat dateParser = initDateParser();\r\n    is.addOption(START, dateParser.format(new Date(start)));\r\n    is.addOption(START_INCL, Boolean.toString(startInclusive));\r\n}","code_comment":"\/**\r\n * A convenience method for setting the start timestamp accepted by the timestamp filter.\r\n *\r\n * @param is\r\n *          the iterator setting object to configure\r\n * @param start\r\n *          the start timestamp\r\n * @param startInclusive\r\n *          boolean indicating whether the start is inclusive\r\n *\/\r\n","code_no_comment":"public static void setStart(IteratorSetting is, long start, boolean startInclusive) {\r\n    SimpleDateFormat dateParser = initDateParser();\r\n    is.addOption(START, dateParser.format(new Date(start)));\r\n    is.addOption(START_INCL, Boolean.toString(startInclusive));\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5701198027,"fo":-0.0833333333,"r":1.4736842105,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3684_e3759a5e","label":1,"code":"@Override\r\npublic void processWatermark(Watermark mark) throws Exception {\r\n    while (!priorityQueue.isEmpty() && priorityQueue.peek().getTimestamp() <= mark.getTimestamp()) {\r\n        StreamRecord<IN> streamRecord = priorityQueue.poll();\r\n        processEvent(nfa, streamRecord.getValue(), streamRecord.getTimestamp());\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void processWatermark(Watermark mark) throws Exception {\r\n    while (!priorityQueue.isEmpty() && priorityQueue.peek().getTimestamp() <= mark.getTimestamp()) {\r\n        StreamRecord<IN> streamRecord = priorityQueue.poll();\r\n        processEvent(nfa, streamRecord.getValue(), streamRecord.getTimestamp());\r\n    }\r\n}","lc":-0.3181818182,"pi":0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":0.0,"d":0.1944444444,"mi":0.3705426357,"fo":0.1666666667,"r":0.0,"e":-0.002699354}
{"project_name":"Lang","project_version":"59","label":1,"code":"\/**\r\n * Appends an object to the builder padding on the right to a fixed length.\r\n * The <code>toString<\/code> of the object is used.\r\n * If the object is larger than the length, the right hand side is lost.\r\n * If the object is null, null text value is used.\r\n *\r\n * @param obj  the object to append, null uses null text\r\n * @param width  the fixed field width, zero or negative has no effect\r\n * @param padChar  the pad character to use\r\n * @return this, to enable chaining\r\n *\/\r\npublic StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\r\n    if (width > 0) {\r\n        ensureCapacity(size + width);\r\n        String str = (obj == null ? getNullText() : obj.toString());\r\n        int strLen = str.length();\r\n        if (strLen >= width) {\r\n            str.getChars(0, strLen, buffer, size);\r\n        } else {\r\n            int padLen = width - strLen;\r\n            str.getChars(0, strLen, buffer, size);\r\n            for (int i = 0; i < padLen; i++) {\r\n                buffer[size + strLen + i] = padChar;\r\n            }\r\n        }\r\n        size += width;\r\n    }\r\n    return this;\r\n}","code_comment":"\/**\r\n * Appends an object to the builder padding on the right to a fixed length.\r\n * The <code>toString<\/code> of the object is used.\r\n * If the object is larger than the length, the right hand side is lost.\r\n * If the object is null, null text value is used.\r\n *\r\n * @param obj  the object to append, null uses null text\r\n * @param width  the fixed field width, zero or negative has no effect\r\n * @param padChar  the pad character to use\r\n * @return this, to enable chaining\r\n *\/\r\n","code_no_comment":"public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\r\n    if (width > 0) {\r\n        ensureCapacity(size + width);\r\n        String str = (obj == null ? getNullText() : obj.toString());\r\n        int strLen = str.length();\r\n        if (strLen >= width) {\r\n            str.getChars(0, strLen, buffer, size);\r\n        } else {\r\n            int padLen = width - strLen;\r\n            str.getChars(0, strLen, buffer, size);\r\n            for (int i = 0; i < padLen; i++) {\r\n                buffer[size + strLen + i] = padChar;\r\n            }\r\n        }\r\n        size += width;\r\n    }\r\n    return this;\r\n}","lc":0.1818181818,"pi":0.5885167464,"ma":0.2,"nbd":0.5,"ml":0.3333333333,"d":1.5615079365,"mi":-0.2197322058,"fo":0.0,"r":-0.0263157895,"e":1.2656512393}
{"project_name":"Csv","project_version":"1","label":1,"code":"@Override\r\npublic int read() throws IOException {\r\n    int current = super.read();\r\n    if (current == '\\n') {\r\n        lineCounter++;\r\n    }\r\n    lastChar = current;\r\n    return lastChar;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int read() throws IOException {\r\n    int current = super.read();\r\n    if (current == '\\n') {\r\n        lineCounter++;\r\n    }\r\n    lastChar = current;\r\n    return lastChar;\r\n}","lc":-0.2272727273,"pi":-0.2296650718,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0674603175,"mi":0.3727977449,"fo":-0.4166666667,"r":1.9210526316,"e":-0.1245137532}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1225_3535afe2","label":1,"code":"\/**\r\n * Returns the node at the specified absolute path in the workspace or\r\n * {@code null} if no such node exists.\r\n *\r\n * @param absPath An absolute path.\r\n * @return the specified {@code Node} or {@code null}.\r\n * @throws RepositoryException If another error occurs.\r\n *\/\r\n@CheckForNull\r\npublic Node getNodeOrNull(final String absPath) throws RepositoryException {\r\n    return perform(new ReadOperation<Node>() {\r\n\r\n        @Override\r\n        public Node perform() throws RepositoryException {\r\n            return NodeImpl.createNodeOrNull(sd.getNode(getOakPathOrThrow(absPath)), sessionContext);\r\n        }\r\n    });\r\n}","code_comment":"\/**\r\n * Returns the node at the specified absolute path in the workspace or\r\n * {@code null} if no such node exists.\r\n *\r\n * @param absPath An absolute path.\r\n * @return the specified {@code Node} or {@code null}.\r\n * @throws RepositoryException If another error occurs.\r\n *\/\r\n","code_no_comment":"@CheckForNull\r\npublic Node getNodeOrNull(final String absPath) throws RepositoryException {\r\n    return perform(new ReadOperation<Node>() {\r\n\r\n        @Override\r\n        public Node perform() throws RepositoryException {\r\n            return NodeImpl.createNodeOrNull(sd.getNode(getOakPathOrThrow(absPath)), sessionContext);\r\n        }\r\n    });\r\n}","lc":-0.2272727273,"pi":0.5406698565,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.318111346,"fo":-0.1666666667,"r":2.0,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3549_9772f5b2","label":1,"code":"\/**\r\n * Perform a background read and make external changes visible.\r\n *\r\n * @param dispatchChange whether to dispatch external changes\r\n *                       to {@link #dispatcher}.\r\n *\/\r\nBackgroundReadStats backgroundRead(boolean dispatchChange) {\r\n    BackgroundReadStats stats = new BackgroundReadStats();\r\n    long time = clock.getTime();\r\n    String id = Utils.getIdFromPath(\"\/\");\r\n    NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);\r\n    if (doc == null) {\r\n        return stats;\r\n    }\r\n    Map<Integer, Revision> lastRevMap = doc.getLastRev();\r\n    try {\r\n        long externalTime = Utils.getMaxExternalTimestamp(lastRevMap.values(), clusterId);\r\n        long localTime = clock.getTime();\r\n        if (localTime < externalTime) {\r\n            LOG.warn(\"Detected clock differences. Local time is '{}', \" + \"while most recent external time is '{}'. \" + \"Current _lastRev entries: {}\", new Date(localTime), new Date(externalTime), lastRevMap.values());\r\n            double delay = ((double) externalTime - localTime) \/ 1000d;\r\n            String msg = String.format(\"Background read will be delayed by %.1f seconds. \" + \"Please check system time on cluster nodes.\", delay);\r\n            LOG.warn(msg);\r\n            clock.waitUntil(externalTime + 1);\r\n        } else if (localTime == externalTime) {\r\n            \/\/ make sure local time is past external time\r\n            \/\/ but only log at debug\r\n            LOG.debug(\"Local and external time are equal. Waiting until local\" + \"time is more recent than external reported time.\");\r\n            clock.waitUntil(externalTime + 1);\r\n        }\r\n    } catch (InterruptedException e) {\r\n        throw new RuntimeException(\"Background read interrupted\", e);\r\n    }\r\n    Revision.RevisionComparator revisionComparator = getRevisionComparator();\r\n    \/\/ the (old) head occurred first\r\n    Revision headSeen = Revision.newRevision(0);\r\n    \/\/ then we saw this new revision (from another cluster node)\r\n    Revision otherSeen = Revision.newRevision(0);\r\n    StringSort externalSort = JournalEntry.newSorter();\r\n    try {\r\n        Map<Revision, Revision> externalChanges = Maps.newHashMap();\r\n        for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {\r\n            int machineId = e.getKey();\r\n            if (machineId == clusterId) {\r\n                \/\/ ignore own lastRev\r\n                continue;\r\n            }\r\n            Revision r = e.getValue();\r\n            Revision last = lastKnownRevision.get(machineId);\r\n            if (last == null || r.compareRevisionTime(last) > 0) {\r\n                lastKnownRevision.put(machineId, r);\r\n                \/\/ - the revision is within the time frame we remember revisions\r\n                if (last != null || r.getTimestamp() > revisionPurgeMillis()) {\r\n                    externalChanges.put(r, otherSeen);\r\n                }\r\n                \/\/ collect external changes\r\n                if (last != null && externalSort != null) {\r\n                    \/\/ add changes for this particular clusterId to the externalSort\r\n                    try {\r\n                        fillExternalChanges(externalSort, last, r, store);\r\n                    } catch (IOException e1) {\r\n                        LOG.error(\"backgroundRead: Exception while reading external changes from journal: \" + e1, e1);\r\n                        IOUtils.closeQuietly(externalSort);\r\n                        externalSort = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        stats.readHead = clock.getTime() - time;\r\n        time = clock.getTime();\r\n        if (!externalChanges.isEmpty()) {\r\n            \/\/ invalidate caches\r\n            if (externalSort == null) {\r\n                \/\/ if no externalSort available, then invalidate the classic way: everything\r\n                stats.cacheStats = store.invalidateCache();\r\n                docChildrenCache.invalidateAll();\r\n            } else {\r\n                try {\r\n                    externalSort.sort();\r\n                    stats.cacheStats = store.invalidateCache(pathToId(externalSort));\r\n                    \/\/ OAK-3002: only invalidate affected items (using journal)\r\n                    long origSize = docChildrenCache.size();\r\n                    if (origSize == 0) {\r\n                        \/\/ if docChildrenCache is empty, don't bother\r\n                        \/\/ calling invalidateAll either way\r\n                        \/\/ (esp calling invalidateAll(Iterable) will\r\n                        \/\/ potentially iterate over all keys even though\r\n                        \/\/ there's nothing to be deleted)\r\n                        LOG.trace(\"backgroundRead: docChildrenCache nothing to invalidate\");\r\n                    } else {\r\n                        \/\/ however, if the docChildrenCache is not empty,\r\n                        \/\/ use the invalidateAll(Iterable) variant,\r\n                        \/\/ passing it a Iterable<StringValue>, as that's\r\n                        \/\/ what is contained in the cache\r\n                        docChildrenCache.invalidateAll(asStringValueIterable(externalSort));\r\n                        long newSize = docChildrenCache.size();\r\n                        LOG.trace(\"backgroundRead: docChildrenCache invalidation result: orig: {}, new: {} \", origSize, newSize);\r\n                    }\r\n                } catch (Exception ioe) {\r\n                    LOG.error(\"backgroundRead: got IOException during external sorting\/cache invalidation (as a result, invalidating entire cache): \" + ioe, ioe);\r\n                    stats.cacheStats = store.invalidateCache();\r\n                    docChildrenCache.invalidateAll();\r\n                }\r\n            }\r\n            stats.cacheInvalidationTime = clock.getTime() - time;\r\n            time = clock.getTime();\r\n            \/\/ make sure update to revision comparator is atomic\r\n            \/\/ and no local commit is in progress\r\n            backgroundOperationLock.writeLock().lock();\r\n            try {\r\n                stats.lock = clock.getTime() - time;\r\n                \/\/ the latest revisions of the current cluster node\r\n                \/\/ happened before the latest revisions of other cluster nodes\r\n                revisionComparator.add(newRevision(), headSeen);\r\n                \/\/ then we saw other revisions\r\n                for (Map.Entry<Revision, Revision> e : externalChanges.entrySet()) {\r\n                    revisionComparator.add(e.getKey(), e.getValue());\r\n                }\r\n                Revision oldHead = headRevision;\r\n                \/\/ the new head revision is after other revisions\r\n                setHeadRevision(newRevision());\r\n                if (dispatchChange) {\r\n                    commitQueue.headRevisionChanged();\r\n                    time = clock.getTime();\r\n                    if (externalSort != null) {\r\n                        \/\/ was successful -> apply them to the diff cache\r\n                        try {\r\n                            JournalEntry.applyTo(externalSort, diffCache, oldHead, headRevision);\r\n                        } catch (Exception e1) {\r\n                            LOG.error(\"backgroundRead: Exception while processing external changes from journal: {}\", e1, e1);\r\n                        }\r\n                    }\r\n                    stats.populateDiffCache = clock.getTime() - time;\r\n                    time = clock.getTime();\r\n                    dispatcher.contentChanged(getRoot().fromExternalChange(), null);\r\n                }\r\n            } finally {\r\n                backgroundOperationLock.writeLock().unlock();\r\n            }\r\n            stats.dispatchChanges = clock.getTime() - time;\r\n            time = clock.getTime();\r\n        }\r\n    } finally {\r\n        IOUtils.closeQuietly(externalSort);\r\n    }\r\n    revisionComparator.purge(revisionPurgeMillis());\r\n    stats.purge = clock.getTime() - time;\r\n    return stats;\r\n}","code_comment":"\/**\r\n * Perform a background read and make external changes visible.\r\n *\r\n * @param dispatchChange whether to dispatch external changes\r\n *                       to {@link #dispatcher}.\r\n *\/\r\n","code_no_comment":"BackgroundReadStats backgroundRead(boolean dispatchChange) {\r\n    BackgroundReadStats stats = new BackgroundReadStats();\r\n    long time = clock.getTime();\r\n    String id = Utils.getIdFromPath(\"\/\");\r\n    NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);\r\n    if (doc == null) {\r\n        return stats;\r\n    }\r\n    Map<Integer, Revision> lastRevMap = doc.getLastRev();\r\n    try {\r\n        long externalTime = Utils.getMaxExternalTimestamp(lastRevMap.values(), clusterId);\r\n        long localTime = clock.getTime();\r\n        if (localTime < externalTime) {\r\n            LOG.warn(\"Detected clock differences. Local time is '{}', \" + \"while most recent external time is '{}'. \" + \"Current _lastRev entries: {}\", new Date(localTime), new Date(externalTime), lastRevMap.values());\r\n            double delay = ((double) externalTime - localTime) \/ 1000d;\r\n            String msg = String.format(\"Background read will be delayed by %.1f seconds. \" + \"Please check system time on cluster nodes.\", delay);\r\n            LOG.warn(msg);\r\n            clock.waitUntil(externalTime + 1);\r\n        } else if (localTime == externalTime) {\r\n                                    LOG.debug(\"Local and external time are equal. Waiting until local\" + \"time is more recent than external reported time.\");\r\n            clock.waitUntil(externalTime + 1);\r\n        }\r\n    } catch (InterruptedException e) {\r\n        throw new RuntimeException(\"Background read interrupted\", e);\r\n    }\r\n    Revision.RevisionComparator revisionComparator = getRevisionComparator();\r\n        Revision headSeen = Revision.newRevision(0);\r\n        Revision otherSeen = Revision.newRevision(0);\r\n    StringSort externalSort = JournalEntry.newSorter();\r\n    try {\r\n        Map<Revision, Revision> externalChanges = Maps.newHashMap();\r\n        for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {\r\n            int machineId = e.getKey();\r\n            if (machineId == clusterId) {\r\n                                continue;\r\n            }\r\n            Revision r = e.getValue();\r\n            Revision last = lastKnownRevision.get(machineId);\r\n            if (last == null || r.compareRevisionTime(last) > 0) {\r\n                lastKnownRevision.put(machineId, r);\r\n                                if (last != null || r.getTimestamp() > revisionPurgeMillis()) {\r\n                    externalChanges.put(r, otherSeen);\r\n                }\r\n                                if (last != null && externalSort != null) {\r\n                                        try {\r\n                        fillExternalChanges(externalSort, last, r, store);\r\n                    } catch (IOException e1) {\r\n                        LOG.error(\"backgroundRead: Exception while reading external changes from journal: \" + e1, e1);\r\n                        IOUtils.closeQuietly(externalSort);\r\n                        externalSort = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        stats.readHead = clock.getTime() - time;\r\n        time = clock.getTime();\r\n        if (!externalChanges.isEmpty()) {\r\n                        if (externalSort == null) {\r\n                                stats.cacheStats = store.invalidateCache();\r\n                docChildrenCache.invalidateAll();\r\n            } else {\r\n                try {\r\n                    externalSort.sort();\r\n                    stats.cacheStats = store.invalidateCache(pathToId(externalSort));\r\n                                        long origSize = docChildrenCache.size();\r\n                    if (origSize == 0) {\r\n                                                                                                                                                LOG.trace(\"backgroundRead: docChildrenCache nothing to invalidate\");\r\n                    } else {\r\n                                                                                                                        docChildrenCache.invalidateAll(asStringValueIterable(externalSort));\r\n                        long newSize = docChildrenCache.size();\r\n                        LOG.trace(\"backgroundRead: docChildrenCache invalidation result: orig: {}, new: {} \", origSize, newSize);\r\n                    }\r\n                } catch (Exception ioe) {\r\n                    LOG.error(\"backgroundRead: got IOException during external sorting\/cache invalidation (as a result, invalidating entire cache): \" + ioe, ioe);\r\n                    stats.cacheStats = store.invalidateCache();\r\n                    docChildrenCache.invalidateAll();\r\n                }\r\n            }\r\n            stats.cacheInvalidationTime = clock.getTime() - time;\r\n            time = clock.getTime();\r\n                                    backgroundOperationLock.writeLock().lock();\r\n            try {\r\n                stats.lock = clock.getTime() - time;\r\n                                                revisionComparator.add(newRevision(), headSeen);\r\n                                for (Map.Entry<Revision, Revision> e : externalChanges.entrySet()) {\r\n                    revisionComparator.add(e.getKey(), e.getValue());\r\n                }\r\n                Revision oldHead = headRevision;\r\n                                setHeadRevision(newRevision());\r\n                if (dispatchChange) {\r\n                    commitQueue.headRevisionChanged();\r\n                    time = clock.getTime();\r\n                    if (externalSort != null) {\r\n                                                try {\r\n                            JournalEntry.applyTo(externalSort, diffCache, oldHead, headRevision);\r\n                        } catch (Exception e1) {\r\n                            LOG.error(\"backgroundRead: Exception while processing external changes from journal: {}\", e1, e1);\r\n                        }\r\n                    }\r\n                    stats.populateDiffCache = clock.getTime() - time;\r\n                    time = clock.getTime();\r\n                    dispatcher.contentChanged(getRoot().fromExternalChange(), null);\r\n                }\r\n            } finally {\r\n                backgroundOperationLock.writeLock().unlock();\r\n            }\r\n            stats.dispatchChanges = clock.getTime() - time;\r\n            time = clock.getTime();\r\n        }\r\n    } finally {\r\n        IOUtils.closeQuietly(externalSort);\r\n    }\r\n    revisionComparator.purge(revisionPurgeMillis());\r\n    stats.purge = clock.getTime() - time;\r\n    return stats;\r\n}","lc":4.6363636364,"pi":1.8133971292,"ma":3.4,"nbd":2.0,"ml":1.9166666667,"d":2.2222222222,"mi":-1.4921775899,"fo":6.0,"r":-0.0263157895,"e":16.5825417956}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1505_994df698","label":1,"code":"synchronized void addMutation(Mutation m) {\r\n    long now = System.currentTimeMillis();\r\n    mutationCount++;\r\n    for (ColumnUpdate u : m.getUpdates()) {\r\n        Key key = new Key(m.getRow(), 0, m.getRow().length, u.getColumnFamily(), 0, u.getColumnFamily().length, u.getColumnQualifier(), 0, u.getColumnQualifier().length, u.getColumnVisibility(), 0, u.getColumnVisibility().length, u.getTimestamp());\r\n        if (u.isDeleted())\r\n            key.setDeleted(true);\r\n        if (!u.hasTimestamp())\r\n            if (timeType.equals(TimeType.LOGICAL))\r\n                key.setTimestamp(mutationCount);\r\n            else\r\n                key.setTimestamp(now);\r\n        table.put(new MockMemKey(key, mutationCount), new Value(u.getValue()));\r\n    }\r\n}","code_comment":null,"code_no_comment":"synchronized void addMutation(Mutation m) {\r\n    long now = System.currentTimeMillis();\r\n    mutationCount++;\r\n    for (ColumnUpdate u : m.getUpdates()) {\r\n        Key key = new Key(m.getRow(), 0, m.getRow().length, u.getColumnFamily(), 0, u.getColumnFamily().length, u.getColumnQualifier(), 0, u.getColumnQualifier().length, u.getColumnVisibility(), 0, u.getColumnVisibility().length, u.getTimestamp());\r\n        if (u.isDeleted())\r\n            key.setDeleted(true);\r\n        if (!u.hasTimestamp())\r\n            if (timeType.equals(TimeType.LOGICAL))\r\n                key.setTimestamp(mutationCount);\r\n            else\r\n                key.setTimestamp(now);\r\n        table.put(new MockMemKey(key, mutationCount), new Value(u.getValue()));\r\n    }\r\n}","lc":0.0454545455,"pi":0.9377990431,"ma":0.2,"nbd":-0.5,"ml":0.0833333333,"d":0.0198412698,"mi":-0.1563072586,"fo":1.0833333333,"r":-0.0263157895,"e":0.1635587213}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2649_72d24f4b","label":3,"code":"@Override\r\npublic void run() {\r\n    String name = reference.name;\r\n    try {\r\n        if (!local.fileExists(name)) {\r\n            long start = System.currentTimeMillis();\r\n            remote.copy(local, name, name, IOContext.READ);\r\n            reference.markValid();\r\n            downloadTime.addAndGet(System.currentTimeMillis() - start);\r\n            downloadSize.addAndGet(remote.fileLength(name));\r\n        } else {\r\n            long localLength = local.fileLength(name);\r\n            long remoteLength = remote.fileLength(name);\r\n            \/\/ updated but still do a check if the copy is consistent\r\n            if (localLength != remoteLength) {\r\n                log.warn(\"Found local copy for {} in {} but size of local {} differs from remote {}. \" + \"Content would be read from remote file only\", name, local, localLength, remoteLength);\r\n                invalidFileCount.incrementAndGet();\r\n            } else {\r\n                reference.markValid();\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        \/\/ TODO In case of exception there would not be any other attempt\r\n        \/\/ to download the file. Look into support for retry\r\n        log.warn(\"Error occurred while copying file [{}] \" + \"from {} to {}\", name, remote, local, e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void run() {\r\n    String name = reference.name;\r\n    try {\r\n        if (!local.fileExists(name)) {\r\n            long start = System.currentTimeMillis();\r\n            remote.copy(local, name, name, IOContext.READ);\r\n            reference.markValid();\r\n            downloadTime.addAndGet(System.currentTimeMillis() - start);\r\n            downloadSize.addAndGet(remote.fileLength(name));\r\n        } else {\r\n            long localLength = local.fileLength(name);\r\n            long remoteLength = remote.fileLength(name);\r\n                        if (localLength != remoteLength) {\r\n                log.warn(\"Found local copy for {} in {} but size of local {} differs from remote {}. \" + \"Content would be read from remote file only\", name, local, localLength, remoteLength);\r\n                invalidFileCount.incrementAndGet();\r\n            } else {\r\n                reference.markValid();\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n                        log.warn(\"Error occurred while copying file [{}] \" + \"from {} to {}\", name, remote, local, e);\r\n    }\r\n}","lc":0.4545454545,"pi":0.9282296651,"ma":0.0,"nbd":0.5,"ml":0.0833333333,"d":0.4285714286,"mi":-0.3705426357,"fo":0.6666666667,"r":-0.0263157895,"e":0.5385130501}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-370_495f04bc","label":3,"code":"\/**\r\n * Returns true iff both arguments are null or have same dimensions and all\r\n * their elements are equal as defined by\r\n * {@link #equals(double,double) this method}.\r\n *\r\n * @param x first array\r\n * @param y second array\r\n * @return true if the values are both null or have same dimension\r\n * and equal elements.\r\n * @deprecated This method considers that {@code NaN == NaN}. In release\r\n * 3.0, the semantics will change in order to comply with IEEE754 where it\r\n * is specified that {@code NaN != NaN}.\r\n * New methods have been added for those cases wher the old semantics is\r\n * useful (see e.g. {@link #equalsIncludingNaN(double[],double[])\r\n * equalsIncludingNaN}.\r\n *\/\r\npublic static boolean equals(double[] x, double[] y) {\r\n    if ((x == null) || (y == null)) {\r\n        return !((x == null) ^ (y == null));\r\n    }\r\n    if (x.length != y.length) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < x.length; ++i) {\r\n        if (!equals(x[i], y[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n * Returns true iff both arguments are null or have same dimensions and all\r\n * their elements are equal as defined by\r\n * {@link #equals(double,double) this method}.\r\n *\r\n * @param x first array\r\n * @param y second array\r\n * @return true if the values are both null or have same dimension\r\n * and equal elements.\r\n * @deprecated This method considers that {@code NaN == NaN}. In release\r\n * 3.0, the semantics will change in order to comply with IEEE754 where it\r\n * is specified that {@code NaN != NaN}.\r\n * New methods have been added for those cases wher the old semantics is\r\n * useful (see e.g. {@link #equalsIncludingNaN(double[],double[])\r\n * equalsIncludingNaN}.\r\n *\/\r\n","code_no_comment":"public static boolean equals(double[] x, double[] y) {\r\n    if ((x == null) || (y == null)) {\r\n        return !((x == null) ^ (y == null));\r\n    }\r\n    if (x.length != y.length) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < x.length; ++i) {\r\n        if (!equals(x[i], y[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}","lc":0.0,"pi":0.0909090909,"ma":0.2,"nbd":0.0,"ml":0.5,"d":2.0158730159,"mi":-0.0170542636,"fo":-0.4166666667,"r":0.3947368421,"e":0.8061340572}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"private final Component<?> children_get(int index) {\r\n    if (index == 0) {\r\n        if (children instanceof Component) {\r\n            return (Component) children;\r\n        } else {\r\n            return ((Component[]) children)[index];\r\n        }\r\n    } else {\r\n        return ((Component[]) children)[index];\r\n    }\r\n}","code_comment":null,"code_no_comment":"private final Component<?> children_get(int index) {\r\n    if (index == 0) {\r\n        if (children instanceof Component) {\r\n            return (Component) children;\r\n        } else {\r\n            return ((Component[]) children)[index];\r\n        }\r\n    } else {\r\n        return ((Component[]) children)[index];\r\n    }\r\n}","lc":-0.1363636364,"pi":0.4593301435,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.2964059197,"fo":-0.5,"r":0.6842105263,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-2174_778f044e","label":1,"code":"public List<ModelProperty> getModelProperties() throws IOException {\r\n    if (modelProperties == null) {\r\n        Set<String> s = new HashSet<String>();\r\n        \/\/ TODO: Should add all collections from ProjectUri\r\n        s.addAll(PomTransformer.URIS);\r\n        s.add(ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.xUri);\r\n        s.add(ProjectUri.DependencyManagement.Dependencies.Dependency.Exclusions.xUri);\r\n        s.add(ProjectUri.Dependencies.Dependency.Exclusions.xUri);\r\n        s.add(ProjectUri.Build.Plugins.Plugin.Executions.xUri);\r\n        s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.Goals.xURI);\r\n        s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.xUri);\r\n        s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.ReportSet.configuration);\r\n        s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.configuration);\r\n        modelProperties = ModelMarshaller.marshallXmlToModelProperties(getInputStream(), ProjectUri.baseUri, s);\r\n    }\r\n    return new ArrayList<ModelProperty>(modelProperties);\r\n}","code_comment":null,"code_no_comment":"public List<ModelProperty> getModelProperties() throws IOException {\r\n    if (modelProperties == null) {\r\n        Set<String> s = new HashSet<String>();\r\n                s.addAll(PomTransformer.URIS);\r\n        s.add(ProjectUri.Build.PluginManagement.Plugins.Plugin.Executions.xUri);\r\n        s.add(ProjectUri.DependencyManagement.Dependencies.Dependency.Exclusions.xUri);\r\n        s.add(ProjectUri.Dependencies.Dependency.Exclusions.xUri);\r\n        s.add(ProjectUri.Build.Plugins.Plugin.Executions.xUri);\r\n        s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.Goals.xURI);\r\n        s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.xUri);\r\n        s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.ReportSet.configuration);\r\n        s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.configuration);\r\n        modelProperties = ModelMarshaller.marshallXmlToModelProperties(getInputStream(), ProjectUri.baseUri, s);\r\n    }\r\n    return new ArrayList<ModelProperty>(modelProperties);\r\n}","lc":0.0909090909,"pi":-0.0813397129,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.125,"mi":-0.2171952079,"fo":0.4166666667,"r":-0.0263157895,"e":0.4259377719}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3718_73ce9cfb","label":0,"code":"public TMutation toThrift() {\r\n    serialize();\r\n    return new TMutation(java.nio.ByteBuffer.wrap(row), java.nio.ByteBuffer.wrap(data), ByteBufferUtil.toByteBuffers(values), entries);\r\n}","code_comment":null,"code_no_comment":"public TMutation toThrift() {\r\n    serialize();\r\n    return new TMutation(java.nio.ByteBuffer.wrap(row), java.nio.ByteBuffer.wrap(data), ByteBufferUtil.toByteBuffers(values), entries);\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7105003524,"fo":-0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Closure","project_version":"165","label":2,"code":"JSType getGreatestSubtypeHelper(JSType that) {\r\n    if (that.isRecordType()) {\r\n        RecordType thatRecord = that.toMaybeRecordType();\r\n        RecordTypeBuilder builder = new RecordTypeBuilder(registry);\r\n        \/\/ is returned.\r\n        for (String property : properties.keySet()) {\r\n            if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isEquivalentTo(getPropertyType(property))) {\r\n                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\r\n            }\r\n            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));\r\n        }\r\n        for (String property : thatRecord.properties.keySet()) {\r\n            if (!hasProperty(property)) {\r\n                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));\r\n            }\r\n        }\r\n        return builder.build();\r\n    }\r\n    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\r\n    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);\r\n    if (!thatRestrictedToObj.isEmptyType()) {\r\n        \/\/ 2) Take the intersection of all of these unions.\r\n        for (Map.Entry<String, JSType> entry : properties.entrySet()) {\r\n            String propName = entry.getKey();\r\n            JSType propType = entry.getValue();\r\n            UnionTypeBuilder builder = new UnionTypeBuilder(registry);\r\n            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {\r\n                JSType altPropType = alt.getPropertyType(propName);\r\n                if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {\r\n                    builder.addAlternate(alt);\r\n                }\r\n            }\r\n            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());\r\n        }\r\n    }\r\n    return greatestSubtype;\r\n}","code_comment":null,"code_no_comment":"JSType getGreatestSubtypeHelper(JSType that) {\r\n    if (that.isRecordType()) {\r\n        RecordType thatRecord = that.toMaybeRecordType();\r\n        RecordTypeBuilder builder = new RecordTypeBuilder(registry);\r\n                for (String property : properties.keySet()) {\r\n            if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isEquivalentTo(getPropertyType(property))) {\r\n                return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\r\n            }\r\n            builder.addProperty(property, getPropertyType(property), getPropertyNode(property));\r\n        }\r\n        for (String property : thatRecord.properties.keySet()) {\r\n            if (!hasProperty(property)) {\r\n                builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));\r\n            }\r\n        }\r\n        return builder.build();\r\n    }\r\n    JSType greatestSubtype = registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\r\n    JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);\r\n    if (!thatRestrictedToObj.isEmptyType()) {\r\n                for (Map.Entry<String, JSType> entry : properties.entrySet()) {\r\n            String propName = entry.getKey();\r\n            JSType propType = entry.getValue();\r\n            UnionTypeBuilder builder = new UnionTypeBuilder(registry);\r\n            for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {\r\n                JSType altPropType = alt.getPropertyType(propName);\r\n                if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {\r\n                    builder.addAlternate(alt);\r\n                }\r\n            }\r\n            greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());\r\n        }\r\n    }\r\n    return greatestSubtype;\r\n}","lc":0.9545454545,"pi":0.8612440191,"ma":1.2,"nbd":1.0,"ml":1.75,"d":0.6468253968,"mi":-0.6958421424,"fo":2.3333333333,"r":-0.0263157895,"e":1.786495162}
{"project_name":"Closure","project_version":"101","label":2,"code":"@Override\r\nprotected CompilerOptions createOptions() {\r\n    CompilerOptions options = new CompilerOptions();\r\n    options.setCodingConvention(new ClosureCodingConvention());\r\n    CompilationLevel level = flags.compilation_level;\r\n    level.setOptionsForCompilationLevel(options);\r\n    if (flags.debug) {\r\n        level.setDebugOptionsForCompilationLevel(options);\r\n    }\r\n    WarningLevel wLevel = flags.warning_level;\r\n    wLevel.setOptionsForWarningLevel(options);\r\n    for (FormattingOption formattingOption : flags.formatting) {\r\n        formattingOption.applyToOptions(options);\r\n    }\r\n    if (flags.process_closure_primitives) {\r\n        options.closurePass = true;\r\n    }\r\n    initOptionsFromFlags(options);\r\n    return options;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected CompilerOptions createOptions() {\r\n    CompilerOptions options = new CompilerOptions();\r\n    options.setCodingConvention(new ClosureCodingConvention());\r\n    CompilationLevel level = flags.compilation_level;\r\n    level.setOptionsForCompilationLevel(options);\r\n    if (flags.debug) {\r\n        level.setDebugOptionsForCompilationLevel(options);\r\n    }\r\n    WarningLevel wLevel = flags.warning_level;\r\n    wLevel.setOptionsForWarningLevel(options);\r\n    for (FormattingOption formattingOption : flags.formatting) {\r\n        formattingOption.applyToOptions(options);\r\n    }\r\n    if (flags.process_closure_primitives) {\r\n        options.closurePass = true;\r\n    }\r\n    initOptionsFromFlags(options);\r\n    return options;\r\n}","lc":0.2727272727,"pi":-0.3827751196,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":-0.2124031008,"fo":0.0,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-43_668f08f2","label":1,"code":"public void copyNode(String srcPath, String destPath) throws NotFoundException, Exception {\r\n    String srcParentPath = PathUtils.getParentPath(srcPath);\r\n    String srcNodeName = PathUtils.getName(srcPath);\r\n    String destParentPath = PathUtils.getParentPath(destPath);\r\n    String destNodeName = PathUtils.getName(destPath);\r\n    MutableNode srcParent = getOrCreateStagedNode(srcParentPath);\r\n    ChildNode srcCNE = srcParent.getChildNodeEntry(srcNodeName);\r\n    if (srcCNE == null) {\r\n        throw new NotFoundException(srcPath);\r\n    }\r\n    MutableNode destParent = getOrCreateStagedNode(destParentPath);\r\n    destParent.add(new ChildNode(destNodeName, srcCNE.getId()));\r\n    if (srcCNE.getId() == null) {\r\n        \/\/ a 'new' node is being copied\r\n        \/\/ update staging area\r\n        copyStagedNodes(srcPath, destPath);\r\n    }\r\n    \/\/ update change log\r\n    changeLog.add(new CopyNode(srcPath, destPath));\r\n}","code_comment":null,"code_no_comment":"public void copyNode(String srcPath, String destPath) throws NotFoundException, Exception {\r\n    String srcParentPath = PathUtils.getParentPath(srcPath);\r\n    String srcNodeName = PathUtils.getName(srcPath);\r\n    String destParentPath = PathUtils.getParentPath(destPath);\r\n    String destNodeName = PathUtils.getName(destPath);\r\n    MutableNode srcParent = getOrCreateStagedNode(srcParentPath);\r\n    ChildNode srcCNE = srcParent.getChildNodeEntry(srcNodeName);\r\n    if (srcCNE == null) {\r\n        throw new NotFoundException(srcPath);\r\n    }\r\n    MutableNode destParent = getOrCreateStagedNode(destParentPath);\r\n    destParent.add(new ChildNode(destNodeName, srcCNE.getId()));\r\n    if (srcCNE.getId() == null) {\r\n                        copyStagedNodes(srcPath, destPath);\r\n    }\r\n        changeLog.add(new CopyNode(srcPath, destPath));\r\n}","lc":0.1363636364,"pi":-0.5023923445,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":0.0912698413,"mi":-0.1985905567,"fo":0.5,"r":0.0263157895,"e":0.2023593414}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3514_2b6da516","label":1,"code":"private Url decryptUrl(final Request request, final Url encryptedUrl) {\r\n    if (encryptedUrl.getSegments().isEmpty() && encryptedUrl.getQueryParameters().isEmpty()) {\r\n        return encryptedUrl;\r\n    }\r\n    List<String> segments = encryptedUrl.getSegments();\r\n    if (segments.size() < 2) {\r\n        return null;\r\n    }\r\n    Url url = new Url(request.getCharset());\r\n    try {\r\n        String encryptedUrlString = segments.get(0);\r\n        if (Strings.isEmpty(encryptedUrlString)) {\r\n            return null;\r\n        }\r\n        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\r\n        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());\r\n        int originalNumberOfSegments = originalUrl.getSegments().size();\r\n        if (originalNumberOfSegments == 0 && originalUrl.getQueryParameters().isEmpty() == false) {\r\n            originalNumberOfSegments = 1;\r\n        }\r\n        int numberOfSegments = encryptedUrl.getSegments().size();\r\n        char[] encryptedChars = encryptedUrlString.toCharArray();\r\n        int hash = 0;\r\n        int segNo;\r\n        for (segNo = 1; segNo < numberOfSegments && segNo < originalNumberOfSegments + 1; segNo++) {\r\n            char a = encryptedChars[Math.abs(hash % encryptedChars.length)];\r\n            hash++;\r\n            char b = encryptedChars[Math.abs(hash % encryptedChars.length)];\r\n            hash++;\r\n            char c = encryptedChars[Math.abs(hash % encryptedChars.length)];\r\n            String segment = \"\" + a + b + c;\r\n            hash = hashString(segment);\r\n            segment += String.format(\"%02x\", Math.abs(hash % 256));\r\n            hash = hashString(segment);\r\n            if (segment.equals(segments.get(segNo)) && originalUrl.getSegments().size() >= segNo) {\r\n                url.getSegments().add(originalUrl.getSegments().get(segNo - 1));\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        url.getQueryParameters().addAll(originalUrl.getQueryParameters());\r\n    } catch (Exception e) {\r\n        log.error(\"Error decrypting URL\", e);\r\n        url = null;\r\n    }\r\n    return url;\r\n}","code_comment":null,"code_no_comment":"private Url decryptUrl(final Request request, final Url encryptedUrl) {\r\n    if (encryptedUrl.getSegments().isEmpty() && encryptedUrl.getQueryParameters().isEmpty()) {\r\n        return encryptedUrl;\r\n    }\r\n    List<String> segments = encryptedUrl.getSegments();\r\n    if (segments.size() < 2) {\r\n        return null;\r\n    }\r\n    Url url = new Url(request.getCharset());\r\n    try {\r\n        String encryptedUrlString = segments.get(0);\r\n        if (Strings.isEmpty(encryptedUrlString)) {\r\n            return null;\r\n        }\r\n        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\r\n        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());\r\n        int originalNumberOfSegments = originalUrl.getSegments().size();\r\n        if (originalNumberOfSegments == 0 && originalUrl.getQueryParameters().isEmpty() == false) {\r\n            originalNumberOfSegments = 1;\r\n        }\r\n        int numberOfSegments = encryptedUrl.getSegments().size();\r\n        char[] encryptedChars = encryptedUrlString.toCharArray();\r\n        int hash = 0;\r\n        int segNo;\r\n        for (segNo = 1; segNo < numberOfSegments && segNo < originalNumberOfSegments + 1; segNo++) {\r\n            char a = encryptedChars[Math.abs(hash % encryptedChars.length)];\r\n            hash++;\r\n            char b = encryptedChars[Math.abs(hash % encryptedChars.length)];\r\n            hash++;\r\n            char c = encryptedChars[Math.abs(hash % encryptedChars.length)];\r\n            String segment = \"\" + a + b + c;\r\n            hash = hashString(segment);\r\n            segment += String.format(\"%02x\", Math.abs(hash % 256));\r\n            hash = hashString(segment);\r\n            if (segment.equals(segments.get(segNo)) && originalUrl.getSegments().size() >= segNo) {\r\n                url.getSegments().add(originalUrl.getSegments().get(segNo - 1));\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        url.getQueryParameters().addAll(originalUrl.getQueryParameters());\r\n    } catch (Exception e) {\r\n        log.error(\"Error decrypting URL\", e);\r\n        url = null;\r\n    }\r\n    return url;\r\n}","lc":1.5,"pi":0.3253588517,"ma":1.0,"nbd":0.5,"ml":1.4166666667,"d":2.4464285714,"mi":-0.8723044397,"fo":2.75,"r":-0.0263157895,"e":7.3612812134}
{"project_name":"Lang","project_version":"41","label":3,"code":"\/**\r\n * <p>Gets the package name from a <code>String<\/code>.<\/p>\r\n *\r\n * <p>The string passed in is assumed to be a class name - it is not checked.<\/p>\r\n * <p>If the class is unpackaged, return an empty string.<\/p>\r\n *\r\n * @param className  the className to get the package name for, may be <code>null<\/code>\r\n * @return the package name or an empty string\r\n *\/\r\npublic static String getPackageName(String className) {\r\n    if (className == null) {\r\n        return StringUtils.EMPTY;\r\n    }\r\n    \/\/ Strip array encoding\r\n    \/\/ Strip Object type encoding\r\n    int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\r\n    if (i == -1) {\r\n        return StringUtils.EMPTY;\r\n    }\r\n    return className.substring(0, i);\r\n}","code_comment":"\/**\r\n * <p>Gets the package name from a <code>String<\/code>.<\/p>\r\n *\r\n * <p>The string passed in is assumed to be a class name - it is not checked.<\/p>\r\n * <p>If the class is unpackaged, return an empty string.<\/p>\r\n *\r\n * @param className  the className to get the package name for, may be <code>null<\/code>\r\n * @return the package name or an empty string\r\n *\/\r\n","code_no_comment":"public static String getPackageName(String className) {\r\n    if (className == null) {\r\n        return StringUtils.EMPTY;\r\n    }\r\n            int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\r\n    if (i == -1) {\r\n        return StringUtils.EMPTY;\r\n    }\r\n    return className.substring(0, i);\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0436507937,"mi":0.2315715292,"fo":-0.3333333333,"r":0.6578947368,"e":-0.0883179751}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2420_24cb1908","label":0,"code":"\/**\r\n * Returns the child documents at the given {@code path} and returns up to\r\n * {@code limit} documents. The returned child documents are sorted in\r\n * ascending child node name order. If a {@code name} is passed, the first\r\n * child document returned is after the given name. That is, the name is the\r\n * lower exclusive bound.\r\n *\r\n * @param path the path of the parent document.\r\n * @param name the lower exclusive bound or {@code null}.\r\n * @param limit the maximum number of child documents to return.\r\n * @return the child documents.\r\n *\/\r\n@Nonnull\r\nIterable<NodeDocument> readChildDocs(@Nonnull final String path, @Nullable String name, int limit) {\r\n    String to = Utils.getKeyUpperLimit(checkNotNull(path));\r\n    String from;\r\n    if (name != null) {\r\n        from = Utils.getIdFromPath(concat(path, name));\r\n    } else {\r\n        from = Utils.getKeyLowerLimit(path);\r\n    }\r\n    if (name != null || limit > NUM_CHILDREN_CACHE_LIMIT) {\r\n        \/\/ or more than 16k child docs are requested\r\n        return store.query(Collection.NODES, from, to, limit);\r\n    }\r\n    StringValue key = new StringValue(path);\r\n    \/\/ check cache\r\n    NodeDocument.Children c = docChildrenCache.getIfPresent(key);\r\n    if (c == null) {\r\n        c = new NodeDocument.Children();\r\n        List<NodeDocument> docs = store.query(Collection.NODES, from, to, limit);\r\n        for (NodeDocument doc : docs) {\r\n            String p = doc.getPath();\r\n            c.childNames.add(PathUtils.getName(p));\r\n        }\r\n        c.isComplete = docs.size() < limit;\r\n        docChildrenCache.put(key, c);\r\n        return docs;\r\n    } else if (c.childNames.size() < limit && !c.isComplete) {\r\n        \/\/ fetch more and update cache\r\n        String lastName = c.childNames.get(c.childNames.size() - 1);\r\n        String lastPath = concat(path, lastName);\r\n        from = Utils.getIdFromPath(lastPath);\r\n        int remainingLimit = limit - c.childNames.size();\r\n        List<NodeDocument> docs = store.query(Collection.NODES, from, to, remainingLimit);\r\n        NodeDocument.Children clone = c.clone();\r\n        for (NodeDocument doc : docs) {\r\n            String p = doc.getPath();\r\n            clone.childNames.add(PathUtils.getName(p));\r\n        }\r\n        clone.isComplete = docs.size() < remainingLimit;\r\n        docChildrenCache.put(key, clone);\r\n        c = clone;\r\n    }\r\n    Iterable<NodeDocument> it = transform(c.childNames, new Function<String, NodeDocument>() {\r\n\r\n        @Override\r\n        public NodeDocument apply(String name) {\r\n            String p = concat(path, name);\r\n            NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath(p));\r\n            if (doc == null) {\r\n                docChildrenCache.invalidateAll();\r\n                throw new NullPointerException(\"Document \" + p + \" not found\");\r\n            }\r\n            return doc;\r\n        }\r\n    });\r\n    if (c.childNames.size() > limit * 2) {\r\n        it = Iterables.limit(it, limit * 2);\r\n    }\r\n    return it;\r\n}","code_comment":"\/**\r\n * Returns the child documents at the given {@code path} and returns up to\r\n * {@code limit} documents. The returned child documents are sorted in\r\n * ascending child node name order. If a {@code name} is passed, the first\r\n * child document returned is after the given name. That is, the name is the\r\n * lower exclusive bound.\r\n *\r\n * @param path the path of the parent document.\r\n * @param name the lower exclusive bound or {@code null}.\r\n * @param limit the maximum number of child documents to return.\r\n * @return the child documents.\r\n *\/\r\n","code_no_comment":"@Nonnull\r\nIterable<NodeDocument> readChildDocs(@Nonnull final String path, @Nullable String name, int limit) {\r\n    String to = Utils.getKeyUpperLimit(checkNotNull(path));\r\n    String from;\r\n    if (name != null) {\r\n        from = Utils.getIdFromPath(concat(path, name));\r\n    } else {\r\n        from = Utils.getKeyLowerLimit(path);\r\n    }\r\n    if (name != null || limit > NUM_CHILDREN_CACHE_LIMIT) {\r\n                return store.query(Collection.NODES, from, to, limit);\r\n    }\r\n    StringValue key = new StringValue(path);\r\n        NodeDocument.Children c = docChildrenCache.getIfPresent(key);\r\n    if (c == null) {\r\n        c = new NodeDocument.Children();\r\n        List<NodeDocument> docs = store.query(Collection.NODES, from, to, limit);\r\n        for (NodeDocument doc : docs) {\r\n            String p = doc.getPath();\r\n            c.childNames.add(PathUtils.getName(p));\r\n        }\r\n        c.isComplete = docs.size() < limit;\r\n        docChildrenCache.put(key, c);\r\n        return docs;\r\n    } else if (c.childNames.size() < limit && !c.isComplete) {\r\n                String lastName = c.childNames.get(c.childNames.size() - 1);\r\n        String lastPath = concat(path, lastName);\r\n        from = Utils.getIdFromPath(lastPath);\r\n        int remainingLimit = limit - c.childNames.size();\r\n        List<NodeDocument> docs = store.query(Collection.NODES, from, to, remainingLimit);\r\n        NodeDocument.Children clone = c.clone();\r\n        for (NodeDocument doc : docs) {\r\n            String p = doc.getPath();\r\n            clone.childNames.add(PathUtils.getName(p));\r\n        }\r\n        clone.isComplete = docs.size() < remainingLimit;\r\n        docChildrenCache.put(key, clone);\r\n        c = clone;\r\n    }\r\n    Iterable<NodeDocument> it = transform(c.childNames, new Function<String, NodeDocument>() {\r\n\r\n        @Override\r\n        public NodeDocument apply(String name) {\r\n            String p = concat(path, name);\r\n            NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath(p));\r\n            if (doc == null) {\r\n                docChildrenCache.invalidateAll();\r\n                throw new NullPointerException(\"Document \" + p + \" not found\");\r\n            }\r\n            return doc;\r\n        }\r\n    });\r\n    if (c.childNames.size() > limit * 2) {\r\n        it = Iterables.limit(it, limit * 2);\r\n    }\r\n    return it;\r\n}","lc":1.9090909091,"pi":0.2679425837,"ma":1.2,"nbd":0.5,"ml":0.75,"d":3.0734126984,"mi":-0.999154334,"fo":2.25,"r":-0.0263157895,"e":11.9758256831}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"@Override\r\npublic PropertyState setProperty(String name, CoreValue value) {\r\n    PropertyState property = builder.setProperty(name, value);\r\n    if (listener != null) {\r\n        listener.setProperty(this, name, value);\r\n    }\r\n    return property;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic PropertyState setProperty(String name, CoreValue value) {\r\n    PropertyState property = builder.setProperty(name, value);\r\n    if (listener != null) {\r\n        listener.setProperty(this, name, value);\r\n    }\r\n    return property;\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0178571429,"mi":0.3595489782,"fo":-0.3333333333,"r":0.1052631579,"e":-0.0921399469}
{"project_name":"Closure","project_version":"148","label":2,"code":"\/**\r\n * Appends the source map in LavaBug format to the given buffer.\r\n *\r\n * @param out The stream to which the map will be appended.\r\n * @param name The name of the generated source file that this source map\r\n *   represents.\r\n *\/\r\npublic void appendTo(Appendable out, String name) throws IOException {\r\n    \/\/ Write the mappings out to the file. The format of the generated\r\n    \/\/ source map is three sections, each deliminated by a magic comment.\r\n    \/\/ \r\n    \/\/ The first section contains an array for each line of the generated\r\n    \/\/ code, where each element in the array is the ID of the mapping which\r\n    \/\/ best represents the index-th character found on that line of the\r\n    \/\/ generated source code.\r\n    \/\/ \r\n    \/\/ The second section contains an array per generated line. Unused.\r\n    \/\/ \r\n    \/\/ The third and final section contains an array per line, each of which\r\n    \/\/ represents a mapping with a unique ID. The mappings are added in order.\r\n    \/\/ The array itself contains a tuple representing\r\n    \/\/ ['source file', line, col (, 'original name')]\r\n    \/\/ \r\n    \/\/ Example for 2 lines of generated code (with line numbers added for\r\n    \/\/ readability):\r\n    \/\/ \r\n    \/\/ 1)  \/** Begin line maps. **\/{ \"count\": 2 }\r\n    \/\/ 2)  [0,0,0,0,0,0,1,1,1,1,2]\r\n    \/\/ 3)  [2,2,2,2,2,2,3,4,4,4,4,4]\r\n    \/\/ 4)  \/** Begin file information. **\/\r\n    \/\/ 5)  []\r\n    \/\/ 6)  []\r\n    \/\/ 7)  \/** Begin mapping definitions. **\/\r\n    \/\/ 8)  [\"a.js\", 1, 34]\r\n    \/\/ 9)  [\"a.js\", 5, 2]\r\n    \/\/ 10) [\"b.js\", 1, 3, \"event\"]\r\n    \/\/ 11) [\"c.js\", 1, 4]\r\n    \/\/ 12) [\"d.js\", 3, 78, \"foo\"]\r\n    int maxLine = findLastLine();\r\n    \/\/ Add the line character maps.\r\n    out.append(\"\/** Begin line maps. **\/{ \\\"file\\\" : \");\r\n    out.append(escapeString(name));\r\n    out.append(\", \\\"count\\\": \");\r\n    out.append(String.valueOf(maxLine + 1));\r\n    out.append(\" }\\n\");\r\n    (new LineMapper(out)).appendLineMappings();\r\n    \/\/ Add the source file maps.\r\n    out.append(\"\/** Begin file information. **\/\\n\");\r\n    \/\/ prevent changing the format.\r\n    for (int i = 0; i <= maxLine; ++i) {\r\n        out.append(\"[]\\n\");\r\n    }\r\n    \/\/ Add the mappings themselves.\r\n    out.append(\"\/** Begin mapping definitions. **\/\\n\");\r\n    for (Mapping mapping : mappings) {\r\n        mapping.appendTo(out);\r\n        out.append(\"\\n\");\r\n    }\r\n}","code_comment":"\/**\r\n * Appends the source map in LavaBug format to the given buffer.\r\n *\r\n * @param out The stream to which the map will be appended.\r\n * @param name The name of the generated source file that this source map\r\n *   represents.\r\n *\/\r\n","code_no_comment":"public void appendTo(Appendable out, String name) throws IOException {\r\n                                                                                                                            int maxLine = findLastLine();\r\n        out.append(\"\/** Begin line maps. **\/{ \\\"file\\\" : \");\r\n    out.append(escapeString(name));\r\n    out.append(\", \\\"count\\\": \");\r\n    out.append(String.valueOf(maxLine + 1));\r\n    out.append(\" }\\n\");\r\n    (new LineMapper(out)).appendLineMappings();\r\n        out.append(\"\/** Begin file information. **\/\\n\");\r\n        for (int i = 0; i <= maxLine; ++i) {\r\n        out.append(\"[]\\n\");\r\n    }\r\n        out.append(\"\/** Begin mapping definitions. **\/\\n\");\r\n    for (Mapping mapping : mappings) {\r\n        mapping.appendTo(out);\r\n        out.append(\"\\n\");\r\n    }\r\n}","lc":0.1818181818,"pi":-0.4258373206,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":0.4285714286,"mi":-0.1940803383,"fo":0.6666666667,"r":-0.0263157895,"e":0.3762429188}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1822_016df669","label":1,"code":"\/**\r\n * Checks if the named key exists or is absent in the MongoDB document. This\r\n * method can be used to make a conditional update.\r\n *\r\n * @param property the property name\r\n * @param revision the revision\r\n *\/\r\nvoid containsMapEntry(@Nonnull String property, @Nonnull Revision revision, boolean exists) {\r\n    if (isNew) {\r\n        throw new IllegalStateException(\"Cannot use containsMapEntry() on new document\");\r\n    }\r\n    Operation op = new Operation();\r\n    op.type = Operation.Type.CONTAINS_MAP_ENTRY;\r\n    op.value = exists;\r\n    changes.put(new Key(property, checkNotNull(revision)), op);\r\n}","code_comment":"\/**\r\n * Checks if the named key exists or is absent in the MongoDB document. This\r\n * method can be used to make a conditional update.\r\n *\r\n * @param property the property name\r\n * @param revision the revision\r\n *\/\r\n","code_no_comment":"void containsMapEntry(@Nonnull String property, @Nonnull Revision revision, boolean exists) {\r\n    if (isNew) {\r\n        throw new IllegalStateException(\"Cannot use containsMapEntry() on new document\");\r\n    }\r\n    Operation op = new Operation();\r\n    op.type = Operation.Type.CONTAINS_MAP_ENTRY;\r\n    op.value = exists;\r\n    changes.put(new Key(property, checkNotNull(revision)), op);\r\n}","lc":-0.2272727273,"pi":-0.3444976077,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.2231148696,"fo":-0.3333333333,"r":1.6052631579,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2494_0dc92ca1","label":1,"code":"public double getStdDev() {\r\n    return Math.sqrt(partialStdDev \/ count - getAverage() * getAverage());\r\n}","code_comment":null,"code_no_comment":"public double getStdDev() {\r\n    return Math.sqrt(partialStdDev \/ count - getAverage() * getAverage());\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.1388888889,"mi":0.9419309373,"fo":-0.25,"r":2.2368421053,"e":-0.1435406257}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"@Override\r\npublic PropertyState setProperty(String name, List<CoreValue> values) {\r\n    PropertyState property = builder.setProperty(name, values);\r\n    if (listener != null) {\r\n        listener.setProperty(this, name, values);\r\n    }\r\n    return property;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic PropertyState setProperty(String name, List<CoreValue> values) {\r\n    PropertyState property = builder.setProperty(name, values);\r\n    if (listener != null) {\r\n        listener.setProperty(this, name, values);\r\n    }\r\n    return property;\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0297619048,"mi":0.3494009866,"fo":-0.3333333333,"r":0.0789473684,"e":-0.0896365323}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2359_b3071839","label":0,"code":"\/**\r\n * Get the latest property value that is larger or equal the min revision,\r\n * and smaller or equal the readRevision revision. A {@code null} return\r\n * value indicates that the property was not set or removed within the given\r\n * range. A non-null value means the the property was either set or removed\r\n * depending on {@link Value#value}.\r\n *\r\n * @param valueMap the sorted revision-value map\r\n * @param min the minimum revision (null meaning unlimited)\r\n * @param readRevision the maximum revision\r\n * @param validRevisions map of revision to commit value considered valid\r\n *                       against the given readRevision.\r\n * @param lastRevs to keep track of the most recent modification.\r\n * @return the value, or null if not found\r\n *\/\r\n@CheckForNull\r\nprivate Value getLatestValue(@Nonnull RevisionContext context, @Nonnull Map<Revision, String> valueMap, @Nullable Revision min, @Nonnull Revision readRevision, @Nonnull Map<Revision, String> validRevisions, @Nonnull LastRevs lastRevs) {\r\n    for (Map.Entry<Revision, String> entry : valueMap.entrySet()) {\r\n        Revision propRev = entry.getKey();\r\n        String commitValue = validRevisions.get(propRev);\r\n        if (commitValue == null) {\r\n            \/\/ resolve revision\r\n            NodeDocument commitRoot = getCommitRoot(propRev);\r\n            if (commitRoot == null) {\r\n                continue;\r\n            }\r\n            commitValue = commitRoot.getCommitValue(propRev);\r\n            if (commitValue == null) {\r\n                continue;\r\n            }\r\n        }\r\n        Revision commitRev = resolveCommitRevision(propRev, commitValue);\r\n        if (Utils.isCommitted(commitValue)) {\r\n            lastRevs.update(commitRev);\r\n        } else {\r\n            \/\/ branch commit\r\n            lastRevs.updateBranch(commitRev.asBranchRevision());\r\n        }\r\n        if (min != null && isRevisionNewer(context, min, commitRev)) {\r\n            continue;\r\n        }\r\n        if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {\r\n            \/\/ TODO: need to check older revisions as well?\r\n            return new Value(commitRev, entry.getValue());\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":"\/**\r\n * Get the latest property value that is larger or equal the min revision,\r\n * and smaller or equal the readRevision revision. A {@code null} return\r\n * value indicates that the property was not set or removed within the given\r\n * range. A non-null value means the the property was either set or removed\r\n * depending on {@link Value#value}.\r\n *\r\n * @param valueMap the sorted revision-value map\r\n * @param min the minimum revision (null meaning unlimited)\r\n * @param readRevision the maximum revision\r\n * @param validRevisions map of revision to commit value considered valid\r\n *                       against the given readRevision.\r\n * @param lastRevs to keep track of the most recent modification.\r\n * @return the value, or null if not found\r\n *\/\r\n","code_no_comment":"@CheckForNull\r\nprivate Value getLatestValue(@Nonnull RevisionContext context, @Nonnull Map<Revision, String> valueMap, @Nullable Revision min, @Nonnull Revision readRevision, @Nonnull Map<Revision, String> validRevisions, @Nonnull LastRevs lastRevs) {\r\n    for (Map.Entry<Revision, String> entry : valueMap.entrySet()) {\r\n        Revision propRev = entry.getKey();\r\n        String commitValue = validRevisions.get(propRev);\r\n        if (commitValue == null) {\r\n                        NodeDocument commitRoot = getCommitRoot(propRev);\r\n            if (commitRoot == null) {\r\n                continue;\r\n            }\r\n            commitValue = commitRoot.getCommitValue(propRev);\r\n            if (commitValue == null) {\r\n                continue;\r\n            }\r\n        }\r\n        Revision commitRev = resolveCommitRevision(propRev, commitValue);\r\n        if (Utils.isCommitted(commitValue)) {\r\n            lastRevs.update(commitRev);\r\n        } else {\r\n                        lastRevs.updateBranch(commitRev.asBranchRevision());\r\n        }\r\n        if (min != null && isRevisionNewer(context, min, commitRev)) {\r\n            continue;\r\n        }\r\n        if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {\r\n                        return new Value(commitRev, entry.getValue());\r\n        }\r\n    }\r\n    return null;\r\n}","lc":0.7272727273,"pi":0.5502392344,"ma":1.4,"nbd":0.5,"ml":1.0833333333,"d":0.5297619048,"mi":-0.5670190275,"fo":0.5833333333,"r":-0.0263157895,"e":0.9435959498}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6604_55751402","label":1,"code":"protected Exchange prepareExchangeForRoutingSlip(Exchange current, Endpoint endpoint) {\r\n    Exchange copy = new DefaultExchange(current);\r\n    \/\/ we must use the same id as this is a snapshot strategy where Camel copies a snapshot\r\n    \/\/ before processing the next step in the pipeline, so we have a snapshot of the exchange\r\n    \/\/ just before. This snapshot is used if Camel should do redeliveries (re try) using\r\n    \/\/ DeadLetterChannel. That is why it's important the id is the same, as it is the *same*\r\n    \/\/ exchange being routed.\r\n    copy.setExchangeId(current.getExchangeId());\r\n    copyOutToIn(copy, current);\r\n    return copy;\r\n}","code_comment":null,"code_no_comment":"protected Exchange prepareExchangeForRoutingSlip(Exchange current, Endpoint endpoint) {\r\n    Exchange copy = new DefaultExchange(current);\r\n                        copy.setExchangeId(current.getExchangeId());\r\n    copyOutToIn(copy, current);\r\n    return copy;\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.52670895,"fo":-0.25,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-3616_912a565f","label":1,"code":"public void validate(Settings settings, SettingsProblemCollector problems) {\r\n    List<Profile> profiles = settings.getProfiles();\r\n    if (profiles != null) {\r\n        for (Profile prof : profiles) {\r\n            validateRepositories(problems, prof.getRepositories(), \"repositories.repository\");\r\n            validateRepositories(problems, prof.getPluginRepositories(), \"pluginRepositories.pluginRepository\");\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void validate(Settings settings, SettingsProblemCollector problems) {\r\n    List<Profile> profiles = settings.getProfiles();\r\n    if (profiles != null) {\r\n        for (Profile prof : profiles) {\r\n            validateRepositories(problems, prof.getRepositories(), \"repositories.repository\");\r\n            validateRepositories(problems, prof.getPluginRepositories(), \"pluginRepositories.pluginRepository\");\r\n        }\r\n    }\r\n}","lc":-0.2272727273,"pi":0.6076555024,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.0615079365,"mi":0.2544045102,"fo":-0.0833333333,"r":0.0,"e":-0.0789267129}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"\/**\r\n *  @param child\r\n *             Child to add\r\n *\/\r\nprivate final void children_add(final Component child) {\r\n    if (this.children == null) {\r\n        this.children = child;\r\n    } else {\r\n        \/\/ Get current list size\r\n        final int size = children_size();\r\n        \/\/ Create array that holds size + 1 elements\r\n        final Component[] children = new Component[size + 1];\r\n        \/\/ Loop through existing children copying them\r\n        for (int i = 0; i < size; i++) {\r\n            children[i] = children_get(i);\r\n        }\r\n        \/\/ Add new child to the end\r\n        children[size] = child;\r\n        \/\/ Save new children\r\n        this.children = children;\r\n    }\r\n}","code_comment":"\/**\r\n *  @param child\r\n *             Child to add\r\n *\/\r\n","code_no_comment":"private final void children_add(final Component child) {\r\n    if (this.children == null) {\r\n        this.children = child;\r\n    } else {\r\n                final int size = children_size();\r\n                final Component[] children = new Component[size + 1];\r\n                for (int i = 0; i < size; i++) {\r\n            children[i] = children_get(i);\r\n        }\r\n                children[size] = child;\r\n                this.children = children;\r\n    }\r\n}","lc":-0.0454545455,"pi":0.1818181818,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":0.5932539683,"mi":0.0396053559,"fo":-0.3333333333,"r":0.3421052632,"e":0.2015340906}
{"project_name":"Math","project_version":"100","label":0,"code":"\/**\r\n * Get the covariance matrix of unbound estimated parameters.\r\n * @param problem estimation problem\r\n * @return covariance matrix\r\n * @exception EstimationException if the covariance matrix\r\n * cannot be computed (singular problem)\r\n *\/\r\npublic double[][] getCovariances(EstimationProblem problem) throws EstimationException {\r\n    \/\/ set up the jacobian\r\n    updateJacobian();\r\n    \/\/ compute transpose(J).J, avoiding building big intermediate matrices\r\n    final int rows = problem.getMeasurements().length;\r\n    final int cols = problem.getAllParameters().length;\r\n    final int max = cols * rows;\r\n    double[][] jTj = new double[cols][cols];\r\n    for (int i = 0; i < cols; ++i) {\r\n        for (int j = i; j < cols; ++j) {\r\n            double sum = 0;\r\n            for (int k = 0; k < max; k += cols) {\r\n                sum += jacobian[k + i] * jacobian[k + j];\r\n            }\r\n            jTj[i][j] = sum;\r\n            jTj[j][i] = sum;\r\n        }\r\n    }\r\n    try {\r\n        \/\/ compute the covariances matrix\r\n        return new RealMatrixImpl(jTj).inverse().getData();\r\n    } catch (InvalidMatrixException ime) {\r\n        throw new EstimationException(\"unable to compute covariances: singular problem\", new Object[0]);\r\n    }\r\n}","code_comment":"\/**\r\n * Get the covariance matrix of unbound estimated parameters.\r\n * @param problem estimation problem\r\n * @return covariance matrix\r\n * @exception EstimationException if the covariance matrix\r\n * cannot be computed (singular problem)\r\n *\/\r\n","code_no_comment":"public double[][] getCovariances(EstimationProblem problem) throws EstimationException {\r\n        updateJacobian();\r\n        final int rows = problem.getMeasurements().length;\r\n    final int cols = problem.getAllParameters().length;\r\n    final int max = cols * rows;\r\n    double[][] jTj = new double[cols][cols];\r\n    for (int i = 0; i < cols; ++i) {\r\n        for (int j = i; j < cols; ++j) {\r\n            double sum = 0;\r\n            for (int k = 0; k < max; k += cols) {\r\n                sum += jacobian[k + i] * jacobian[k + j];\r\n            }\r\n            jTj[i][j] = sum;\r\n            jTj[j][i] = sum;\r\n        }\r\n    }\r\n    try {\r\n                return new RealMatrixImpl(jTj).inverse().getData();\r\n    } catch (InvalidMatrixException ime) {\r\n        throw new EstimationException(\"unable to compute covariances: singular problem\", new Object[0]);\r\n    }\r\n}","lc":0.3636363636,"pi":0.5980861244,"ma":0.4,"nbd":0.5,"ml":0.25,"d":1.0773809524,"mi":-0.3581395349,"fo":-0.0833333333,"r":0.2894736842,"e":1.2447802309}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-286_dbdff075","label":1,"code":"\/**\r\n * Get the current solution.\r\n *\r\n * @return current solution\r\n *\/\r\nprotected RealPointValuePair getSolution() {\r\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\r\n    Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\r\n    double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\r\n    Set<Integer> basicRows = new HashSet<Integer>();\r\n    for (int i = 0; i < coefficients.length; i++) {\r\n        basicRow = getBasicRow(getNumObjectiveFunctions() + i);\r\n        if (basicRows.contains(basicRow)) {\r\n            \/\/ if multiple variables can take a given value\r\n            \/\/ then we choose the first and set the rest equal to 0\r\n            coefficients[i] = 0;\r\n        } else {\r\n            basicRows.add(basicRow);\r\n            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\r\n        }\r\n    }\r\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\r\n}","code_comment":"\/**\r\n * Get the current solution.\r\n *\r\n * @return current solution\r\n *\/\r\n","code_no_comment":"protected RealPointValuePair getSolution() {\r\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\r\n    Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\r\n    double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\r\n    Set<Integer> basicRows = new HashSet<Integer>();\r\n    for (int i = 0; i < coefficients.length; i++) {\r\n        basicRow = getBasicRow(getNumObjectiveFunctions() + i);\r\n        if (basicRows.contains(basicRow)) {\r\n                                    coefficients[i] = 0;\r\n        } else {\r\n            basicRows.add(basicRow);\r\n            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\r\n        }\r\n    }\r\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\r\n}","lc":0.0909090909,"pi":0.3588516746,"ma":0.4,"nbd":0.0,"ml":0.4166666667,"d":1.0476190476,"mi":-0.1875968992,"fo":0.5833333333,"r":0.0789473684,"e":0.9977351706}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-855_ac597cc1","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected UnivariatePointValuePair doOptimize() {\r\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\r\n    final double lo = getMin();\r\n    final double mid = getStartValue();\r\n    final double hi = getMax();\r\n    \/\/ Optional additional convergence criteria.\r\n    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\r\n    double a;\r\n    double b;\r\n    if (lo < hi) {\r\n        a = lo;\r\n        b = hi;\r\n    } else {\r\n        a = hi;\r\n        b = lo;\r\n    }\r\n    double x = mid;\r\n    double v = x;\r\n    double w = x;\r\n    double d = 0;\r\n    double e = 0;\r\n    double fx = computeObjectiveValue(x);\r\n    if (!isMinim) {\r\n        fx = -fx;\r\n    }\r\n    double fv = fx;\r\n    double fw = fx;\r\n    UnivariatePointValuePair previous = null;\r\n    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\r\n    int iter = 0;\r\n    while (true) {\r\n        final double m = 0.5 * (a + b);\r\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\r\n        final double tol2 = 2 * tol1;\r\n        \/\/ Default stopping criterion.\r\n        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\r\n        if (!stop) {\r\n            double p = 0;\r\n            double q = 0;\r\n            double r = 0;\r\n            double u = 0;\r\n            if (FastMath.abs(e) > tol1) {\r\n                \/\/ Fit parabola.\r\n                r = (x - w) * (fx - fv);\r\n                q = (x - v) * (fx - fw);\r\n                p = (x - v) * q - (x - w) * r;\r\n                q = 2 * (q - r);\r\n                if (q > 0) {\r\n                    p = -p;\r\n                } else {\r\n                    q = -q;\r\n                }\r\n                r = e;\r\n                e = d;\r\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\r\n                    \/\/ Parabolic interpolation step.\r\n                    d = p \/ q;\r\n                    u = x + d;\r\n                    \/\/ f must not be evaluated too close to a or b.\r\n                    if (u - a < tol2 || b - u < tol2) {\r\n                        if (x <= m) {\r\n                            d = tol1;\r\n                        } else {\r\n                            d = -tol1;\r\n                        }\r\n                    }\r\n                } else {\r\n                    \/\/ Golden section step.\r\n                    if (x < m) {\r\n                        e = b - x;\r\n                    } else {\r\n                        e = a - x;\r\n                    }\r\n                    d = GOLDEN_SECTION * e;\r\n                }\r\n            } else {\r\n                \/\/ Golden section step.\r\n                if (x < m) {\r\n                    e = b - x;\r\n                } else {\r\n                    e = a - x;\r\n                }\r\n                d = GOLDEN_SECTION * e;\r\n            }\r\n            \/\/ Update by at least \"tol1\".\r\n            if (FastMath.abs(d) < tol1) {\r\n                if (d >= 0) {\r\n                    u = x + tol1;\r\n                } else {\r\n                    u = x - tol1;\r\n                }\r\n            } else {\r\n                u = x + d;\r\n            }\r\n            double fu = computeObjectiveValue(u);\r\n            if (!isMinim) {\r\n                fu = -fu;\r\n            }\r\n            \/\/ User-defined convergence checker.\r\n            previous = current;\r\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\r\n            if (checker != null) {\r\n                if (checker.converged(iter, previous, current)) {\r\n                    return best(current, previous, isMinim);\r\n                }\r\n            }\r\n            \/\/ Update a, b, v, w and x.\r\n            if (fu <= fx) {\r\n                if (u < x) {\r\n                    b = x;\r\n                } else {\r\n                    a = x;\r\n                }\r\n                v = w;\r\n                fv = fw;\r\n                w = x;\r\n                fw = fx;\r\n                x = u;\r\n                fx = fu;\r\n            } else {\r\n                if (u < x) {\r\n                    a = u;\r\n                } else {\r\n                    b = u;\r\n                }\r\n                if (fu <= fw || Precision.equals(w, x)) {\r\n                    v = w;\r\n                    fv = fw;\r\n                    w = u;\r\n                    fw = fu;\r\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\r\n                    v = u;\r\n                    fv = fu;\r\n                }\r\n            }\r\n        } else {\r\n            \/\/ Default termination (Brent's criterion).\r\n            return best(current, previous, isMinim);\r\n        }\r\n        ++iter;\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected UnivariatePointValuePair doOptimize() {\r\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\r\n    final double lo = getMin();\r\n    final double mid = getStartValue();\r\n    final double hi = getMax();\r\n        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\r\n    double a;\r\n    double b;\r\n    if (lo < hi) {\r\n        a = lo;\r\n        b = hi;\r\n    } else {\r\n        a = hi;\r\n        b = lo;\r\n    }\r\n    double x = mid;\r\n    double v = x;\r\n    double w = x;\r\n    double d = 0;\r\n    double e = 0;\r\n    double fx = computeObjectiveValue(x);\r\n    if (!isMinim) {\r\n        fx = -fx;\r\n    }\r\n    double fv = fx;\r\n    double fw = fx;\r\n    UnivariatePointValuePair previous = null;\r\n    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\r\n    int iter = 0;\r\n    while (true) {\r\n        final double m = 0.5 * (a + b);\r\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\r\n        final double tol2 = 2 * tol1;\r\n                final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\r\n        if (!stop) {\r\n            double p = 0;\r\n            double q = 0;\r\n            double r = 0;\r\n            double u = 0;\r\n            if (FastMath.abs(e) > tol1) {\r\n                                r = (x - w) * (fx - fv);\r\n                q = (x - v) * (fx - fw);\r\n                p = (x - v) * q - (x - w) * r;\r\n                q = 2 * (q - r);\r\n                if (q > 0) {\r\n                    p = -p;\r\n                } else {\r\n                    q = -q;\r\n                }\r\n                r = e;\r\n                e = d;\r\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\r\n                                        d = p \/ q;\r\n                    u = x + d;\r\n                                        if (u - a < tol2 || b - u < tol2) {\r\n                        if (x <= m) {\r\n                            d = tol1;\r\n                        } else {\r\n                            d = -tol1;\r\n                        }\r\n                    }\r\n                } else {\r\n                                        if (x < m) {\r\n                        e = b - x;\r\n                    } else {\r\n                        e = a - x;\r\n                    }\r\n                    d = GOLDEN_SECTION * e;\r\n                }\r\n            } else {\r\n                                if (x < m) {\r\n                    e = b - x;\r\n                } else {\r\n                    e = a - x;\r\n                }\r\n                d = GOLDEN_SECTION * e;\r\n            }\r\n                        if (FastMath.abs(d) < tol1) {\r\n                if (d >= 0) {\r\n                    u = x + tol1;\r\n                } else {\r\n                    u = x - tol1;\r\n                }\r\n            } else {\r\n                u = x + d;\r\n            }\r\n            double fu = computeObjectiveValue(u);\r\n            if (!isMinim) {\r\n                fu = -fu;\r\n            }\r\n                        previous = current;\r\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\r\n            if (checker != null) {\r\n                if (checker.converged(iter, previous, current)) {\r\n                    return best(current, previous, isMinim);\r\n                }\r\n            }\r\n                        if (fu <= fx) {\r\n                if (u < x) {\r\n                    b = x;\r\n                } else {\r\n                    a = x;\r\n                }\r\n                v = w;\r\n                fv = fw;\r\n                w = x;\r\n                fw = fx;\r\n                x = u;\r\n                fx = fu;\r\n            } else {\r\n                if (u < x) {\r\n                    a = u;\r\n                } else {\r\n                    b = u;\r\n                }\r\n                if (fu <= fw || Precision.equals(w, x)) {\r\n                    v = w;\r\n                    fv = fw;\r\n                    w = u;\r\n                    fw = fu;\r\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\r\n                    v = u;\r\n                    fv = fu;\r\n                }\r\n            }\r\n        } else {\r\n                        return best(current, previous, isMinim);\r\n        }\r\n        ++iter;\r\n    }\r\n}","lc":5.3636363636,"pi":1.6555023923,"ma":4.0,"nbd":2.0,"ml":4.8333333333,"d":6.9384920635,"mi":-1.5626497533,"fo":1.0833333333,"r":-0.0263157895,"e":44.6266443065}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-740_35a7f014","label":1,"code":"private void deleteSubtreeWriter(SolrServer solrServer, String path) throws IOException, SolrServerException {\r\n    \/\/ TODO verify the removal of the entire sub-hierarchy\r\n    if (!path.startsWith(\"\/\")) {\r\n        path = \"\/\" + path;\r\n    }\r\n    solrServer.deleteByQuery(new StringBuilder(configuration.getPathField()).append(':').append(path).append(\"*\").toString());\r\n}","code_comment":null,"code_no_comment":"private void deleteSubtreeWriter(SolrServer solrServer, String path) throws IOException, SolrServerException {\r\n        if (!path.startsWith(\"\/\")) {\r\n        path = \"\/\" + path;\r\n    }\r\n    solrServer.deleteByQuery(new StringBuilder(configuration.getPathField()).append(':').append(path).append(\"*\").toString());\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0793650794,"mi":0.4359408034,"fo":0.0833333333,"r":0.1315789474,"e":-0.0779677622}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3408_81d25bc2","label":3,"code":"public static String bigNumber(long big, String[] SUFFIXES, long base) {\r\n    return String.format(\"%,d\", big);\r\n}","code_comment":null,"code_no_comment":"public static String bigNumber(long big, String[] SUFFIXES, long base) {\r\n    return String.format(\"%,d\", big);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9568710359,"fo":-0.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"JxPath","project_version":"4","label":1,"code":"protected String getLanguage() {\r\n    Node n = node;\r\n    while (n != null) {\r\n        if (n.getNodeType() == Node.ELEMENT_NODE) {\r\n            Element e = (Element) n;\r\n            String attr = e.getAttribute(\"xml:lang\");\r\n            if (attr != null && !attr.equals(\"\")) {\r\n                return attr;\r\n            }\r\n        }\r\n        n = n.getParentNode();\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"protected String getLanguage() {\r\n    Node n = node;\r\n    while (n != null) {\r\n        if (n.getNodeType() == Node.ELEMENT_NODE) {\r\n            Element e = (Element) n;\r\n            String attr = e.getAttribute(\"xml:lang\");\r\n            if (attr != null && !attr.equals(\"\")) {\r\n                return attr;\r\n            }\r\n        }\r\n        n = n.getParentNode();\r\n    }\r\n    return null;\r\n}","lc":0.0,"pi":0.8421052632,"ma":0.0,"nbd":0.5,"ml":0.25,"d":0.3591269841,"mi":-0.0133897111,"fo":-0.1666666667,"r":1.0263157895,"e":0.1371322534}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1094_2e20589f","label":1,"code":"synchronized void refresh(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {\r\n    V value;\r\n    V old = get(key, hash);\r\n    long start = System.nanoTime();\r\n    try {\r\n        ListenableFuture<V> future = loader.reload(key, old);\r\n        value = future.get();\r\n        loadSuccessCount++;\r\n    } catch (Exception e) {\r\n        loadExceptionCount++;\r\n        throw new ExecutionException(e);\r\n    } finally {\r\n        long time = System.nanoTime() - start;\r\n        totalLoadTime += time;\r\n    }\r\n    put(key, hash, value, cache.sizeOf(key, value));\r\n}","code_comment":null,"code_no_comment":"synchronized void refresh(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {\r\n    V value;\r\n    V old = get(key, hash);\r\n    long start = System.nanoTime();\r\n    try {\r\n        ListenableFuture<V> future = loader.reload(key, old);\r\n        value = future.get();\r\n        loadSuccessCount++;\r\n    } catch (Exception e) {\r\n        loadExceptionCount++;\r\n        throw new ExecutionException(e);\r\n    } finally {\r\n        long time = System.nanoTime() - start;\r\n        totalLoadTime += time;\r\n    }\r\n    put(key, hash, value, cache.sizeOf(key, value));\r\n}","lc":0.1363636364,"pi":-0.1578947368,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":0.369047619,"mi":-0.1678646934,"fo":0.0833333333,"r":0.0,"e":0.3363127655}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3077_17654199","label":0,"code":"protected static void initMetadataConfig() throws IOException {\r\n    initMetadataConfig(RootTable.ID);\r\n    initMetadataConfig(MetadataTable.ID);\r\n}","code_comment":null,"code_no_comment":"protected static void initMetadataConfig() throws IOException {\r\n    initMetadataConfig(RootTable.ID);\r\n    initMetadataConfig(MetadataTable.ID);\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8768146582,"fo":-0.3333333333,"r":0.7631578947,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3137_c65b07c3","label":1,"code":"private boolean canEvalPathRestrictions(IndexingRule rule) {\r\n    if (filter.getPathRestriction() == Filter.PathRestriction.NO_RESTRICTION) {\r\n        return false;\r\n    }\r\n    \/\/ allows indexing all the path for given nodeType\r\n    return definition.evaluatePathRestrictions() && rule.indexesAllNodesOfMatchingType();\r\n}","code_comment":null,"code_no_comment":"private boolean canEvalPathRestrictions(IndexingRule rule) {\r\n    if (filter.getPathRestriction() == Filter.PathRestriction.NO_RESTRICTION) {\r\n        return false;\r\n    }\r\n        return definition.evaluatePathRestrictions() && rule.indexesAllNodesOfMatchingType();\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1507936508,"mi":0.5402396054,"fo":-0.25,"r":1.4210526316,"e":-0.1317565971}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1269_b8fe2ded","label":1,"code":"\/**\r\n * Returns <code>true<\/code> if a node type index lookup exists at the given\r\n * <code>path<\/code> or further up the tree.\r\n *\r\n * @param path the path to check.\r\n * @return <code>true<\/code> if a node type index exists; <code>false<\/code>\r\n *         otherwise.\r\n *\/\r\npublic boolean isIndexed(String path) {\r\n    PropertyIndexLookup lookup = new PropertyIndexLookup(root);\r\n    if (lookup.isIndexed(JCR_PRIMARYTYPE, path, null) && lookup.isIndexed(JCR_MIXINTYPES, path, null)) {\r\n        return true;\r\n    }\r\n    if (path.startsWith(\"\/\")) {\r\n        path = path.substring(1);\r\n    }\r\n    int slash = path.indexOf('\/');\r\n    if (slash == -1) {\r\n        return false;\r\n    }\r\n    NodeState child = root.getChildNode(path.substring(0, slash));\r\n    return new NodeTypeIndexLookup(child).isIndexed(path.substring(slash));\r\n}","code_comment":"\/**\r\n * Returns <code>true<\/code> if a node type index lookup exists at the given\r\n * <code>path<\/code> or further up the tree.\r\n *\r\n * @param path the path to check.\r\n * @return <code>true<\/code> if a node type index exists; <code>false<\/code>\r\n *         otherwise.\r\n *\/\r\n","code_no_comment":"public boolean isIndexed(String path) {\r\n    PropertyIndexLookup lookup = new PropertyIndexLookup(root);\r\n    if (lookup.isIndexed(JCR_PRIMARYTYPE, path, null) && lookup.isIndexed(JCR_MIXINTYPES, path, null)) {\r\n        return true;\r\n    }\r\n    if (path.startsWith(\"\/\")) {\r\n        path = path.substring(1);\r\n    }\r\n    int slash = path.indexOf('\/');\r\n    if (slash == -1) {\r\n        return false;\r\n    }\r\n    NodeState child = root.getChildNode(path.substring(0, slash));\r\n    return new NodeTypeIndexLookup(child).isIndexed(path.substring(slash));\r\n}","lc":0.0454545455,"pi":-0.3349282297,"ma":0.0,"nbd":-0.5,"ml":0.3333333333,"d":0.4464285714,"mi":-0.0982381959,"fo":0.25,"r":-0.0263157895,"e":0.3210064372}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1129_2f95b81f","label":3,"code":"@Nonnull\r\nRevision rebase(@Nonnull Revision branchHead, @Nonnull Revision base) {\r\n    checkNotNull(branchHead);\r\n    checkNotNull(base);\r\n    \/\/ TODO conflict handling\r\n    Branch b = getBranches().getBranch(branchHead);\r\n    if (b == null) {\r\n        \/\/ empty branch\r\n        return base.asBranchRevision();\r\n    }\r\n    if (b.getBase().equals(base)) {\r\n        return branchHead;\r\n    }\r\n    \/\/ add a pseudo commit to make sure current head of branch\r\n    \/\/ has a higher revision than base of branch\r\n    Revision head = newRevision().asBranchRevision();\r\n    b.rebase(head, base);\r\n    return head;\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\nRevision rebase(@Nonnull Revision branchHead, @Nonnull Revision base) {\r\n    checkNotNull(branchHead);\r\n    checkNotNull(base);\r\n        Branch b = getBranches().getBranch(branchHead);\r\n    if (b == null) {\r\n                return base.asBranchRevision();\r\n    }\r\n    if (b.getBase().equals(base)) {\r\n        return branchHead;\r\n    }\r\n            Revision head = newRevision().asBranchRevision();\r\n    b.rebase(head, base);\r\n    return head;\r\n}","lc":0.0454545455,"pi":-0.3349282297,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":0.0674603175,"mi":-0.0311486963,"fo":0.3333333333,"r":0.4736842105,"e":0.007706183}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1369_ce0b0955","label":1,"code":"@Override\r\npublic String toString() {\r\n    String leftExpr;\r\n    boolean leftExprIsName;\r\n    if (left == null) {\r\n        leftExprIsName = false;\r\n        leftExpr = \"\";\r\n    } else {\r\n        leftExprIsName = left.isName();\r\n        leftExpr = left.toString();\r\n        if (left.getPrecedence() < precedence) {\r\n            leftExpr = \"(\" + leftExpr + \")\";\r\n        }\r\n    }\r\n    boolean impossible = false;\r\n    String rightExpr;\r\n    if (right == null) {\r\n        rightExpr = \"\";\r\n    } else {\r\n        if (left != null && left instanceof Property && ((Property) left).implicitAsterisk) {\r\n            throw new IllegalArgumentException(\"Missing @ in front of the property name: \" + left);\r\n        }\r\n        if (leftExprIsName && !\"like\".equals(operator)) {\r\n            \/\/ need to de-escape _x0020_ and so on\r\n            if (!(right instanceof Literal)) {\r\n                throw new IllegalArgumentException(\"Can only compare a name against a string literal, not \" + right);\r\n            }\r\n            Literal l = (Literal) right;\r\n            String raw = l.rawText;\r\n            String decoded = ISO9075.decode(raw);\r\n            String encoded = ISO9075.encode(decoded);\r\n            rightExpr = SQL2Parser.escapeStringLiteral(decoded);\r\n            if (!encoded.equalsIgnoreCase(raw)) {\r\n                \/\/ nothing can potentially match\r\n                impossible = true;\r\n            }\r\n        } else {\r\n            rightExpr = right.toString();\r\n        }\r\n        if (right.getPrecedence() < precedence) {\r\n            rightExpr = \"(\" + right + \")\";\r\n        }\r\n    }\r\n    if (impossible) {\r\n        \/\/ a condition that can not possibly be true\r\n        return \"upper(\" + leftExpr + \") = 'never matches'\";\r\n    }\r\n    return (leftExpr + \" \" + operator + \" \" + rightExpr).trim();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String toString() {\r\n    String leftExpr;\r\n    boolean leftExprIsName;\r\n    if (left == null) {\r\n        leftExprIsName = false;\r\n        leftExpr = \"\";\r\n    } else {\r\n        leftExprIsName = left.isName();\r\n        leftExpr = left.toString();\r\n        if (left.getPrecedence() < precedence) {\r\n            leftExpr = \"(\" + leftExpr + \")\";\r\n        }\r\n    }\r\n    boolean impossible = false;\r\n    String rightExpr;\r\n    if (right == null) {\r\n        rightExpr = \"\";\r\n    } else {\r\n        if (left != null && left instanceof Property && ((Property) left).implicitAsterisk) {\r\n            throw new IllegalArgumentException(\"Missing @ in front of the property name: \" + left);\r\n        }\r\n        if (leftExprIsName && !\"like\".equals(operator)) {\r\n                        if (!(right instanceof Literal)) {\r\n                throw new IllegalArgumentException(\"Can only compare a name against a string literal, not \" + right);\r\n            }\r\n            Literal l = (Literal) right;\r\n            String raw = l.rawText;\r\n            String decoded = ISO9075.decode(raw);\r\n            String encoded = ISO9075.encode(decoded);\r\n            rightExpr = SQL2Parser.escapeStringLiteral(decoded);\r\n            if (!encoded.equalsIgnoreCase(raw)) {\r\n                                impossible = true;\r\n            }\r\n        } else {\r\n            rightExpr = right.toString();\r\n        }\r\n        if (right.getPrecedence() < precedence) {\r\n            rightExpr = \"(\" + right + \")\";\r\n        }\r\n    }\r\n    if (impossible) {\r\n                return \"upper(\" + leftExpr + \") = 'never matches'\";\r\n    }\r\n    return (leftExpr + \" \" + operator + \" \" + rightExpr).trim();\r\n}","lc":1.4545454545,"pi":0.4832535885,"ma":1.6,"nbd":0.5,"ml":1.5833333333,"d":1.0198412698,"mi":-0.8178999295,"fo":0.4166666667,"r":-0.0263157895,"e":2.2334768302}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_add180fb","label":1,"code":"@Override\r\npublic void clearLocatorCache(String tableName) throws TableNotFoundException {\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void clearLocatorCache(String tableName) throws TableNotFoundException {\r\n}","lc":-0.5,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.067653277,"fo":-0.5,"r":2.2631578947,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"@Nonnull\r\nNodeState getNodeState() {\r\n    return getNodeBuilder().getNodeState();\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\nNodeState getNodeState() {\r\n    return getNodeBuilder().getNodeState();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9517970402,"fo":-0.3333333333,"r":1.2105263158,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1800_3143b9c5","label":0,"code":"private void addCellsToWriter(Map<ByteBuffer, List<ColumnUpdate>> cells, BatchWriterPlusException bwpe) {\r\n    if (bwpe.exception != null)\r\n        return;\r\n    HashMap<Text, ColumnVisibility> vizMap = new HashMap<Text, ColumnVisibility>();\r\n    for (Map.Entry<ByteBuffer, List<ColumnUpdate>> entry : cells.entrySet()) {\r\n        Mutation m = new Mutation(ByteBufferUtil.toBytes(entry.getKey()));\r\n        for (ColumnUpdate update : entry.getValue()) {\r\n            ColumnVisibility viz = EMPTY_VIS;\r\n            if (update.isSetColVisibility()) {\r\n                Text vizText = new Text(update.getColVisibility());\r\n                viz = vizMap.get(vizText);\r\n                if (viz == null) {\r\n                    vizMap.put(vizText, viz = new ColumnVisibility(vizText));\r\n                }\r\n            }\r\n            byte[] value = new byte[0];\r\n            if (update.isSetValue())\r\n                value = update.getValue();\r\n            if (update.isSetTimestamp()) {\r\n                if (update.isSetDeleteCell()) {\r\n                    m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\r\n                } else {\r\n                    if (update.isSetDeleteCell()) {\r\n                        m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\r\n                    } else {\r\n                        m.put(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp(), value);\r\n                    }\r\n                }\r\n            } else {\r\n                m.put(update.getColFamily(), update.getColQualifier(), viz, value);\r\n            }\r\n        }\r\n        try {\r\n            bwpe.writer.addMutation(m);\r\n        } catch (MutationsRejectedException mre) {\r\n            bwpe.exception = mre;\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void addCellsToWriter(Map<ByteBuffer, List<ColumnUpdate>> cells, BatchWriterPlusException bwpe) {\r\n    if (bwpe.exception != null)\r\n        return;\r\n    HashMap<Text, ColumnVisibility> vizMap = new HashMap<Text, ColumnVisibility>();\r\n    for (Map.Entry<ByteBuffer, List<ColumnUpdate>> entry : cells.entrySet()) {\r\n        Mutation m = new Mutation(ByteBufferUtil.toBytes(entry.getKey()));\r\n        for (ColumnUpdate update : entry.getValue()) {\r\n            ColumnVisibility viz = EMPTY_VIS;\r\n            if (update.isSetColVisibility()) {\r\n                Text vizText = new Text(update.getColVisibility());\r\n                viz = vizMap.get(vizText);\r\n                if (viz == null) {\r\n                    vizMap.put(vizText, viz = new ColumnVisibility(vizText));\r\n                }\r\n            }\r\n            byte[] value = new byte[0];\r\n            if (update.isSetValue())\r\n                value = update.getValue();\r\n            if (update.isSetTimestamp()) {\r\n                if (update.isSetDeleteCell()) {\r\n                    m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\r\n                } else {\r\n                    if (update.isSetDeleteCell()) {\r\n                        m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\r\n                    } else {\r\n                        m.put(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp(), value);\r\n                    }\r\n                }\r\n            } else {\r\n                m.put(update.getColFamily(), update.getColQualifier(), viz, value);\r\n            }\r\n        }\r\n        try {\r\n            bwpe.writer.addMutation(m);\r\n        } catch (MutationsRejectedException mre) {\r\n            bwpe.exception = mre;\r\n        }\r\n    }\r\n}","lc":1.1363636364,"pi":1.4354066986,"ma":1.4,"nbd":1.5,"ml":0.6666666667,"d":0.1547619048,"mi":-0.7313601128,"fo":1.9166666667,"r":-0.0263157895,"e":0.7081966079}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5565_204849bc","label":1,"code":"@Override\r\npublic int getCompatibilityScore(Request request) {\r\n    if (urlStartsWith(request.getUrl(), mountSegments)) {\r\n        return mountSegments.length;\r\n    } else {\r\n        return 0;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int getCompatibilityScore(Request request) {\r\n    if (urlStartsWith(request.getUrl(), mountSegments)) {\r\n        return mountSegments.length;\r\n    } else {\r\n        return 0;\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.4748414376,"fo":-0.3333333333,"r":0.5526315789,"e":-0.1627934049}
{"project_name":"JxPath","project_version":"18","label":3,"code":"public boolean nextNode() {\r\n    super.setPosition(getCurrentPosition() + 1);\r\n    if (!setStarted) {\r\n        setStarted = true;\r\n        if (!(nodeTest instanceof NodeNameTest)) {\r\n            return false;\r\n        }\r\n        QName name = ((NodeNameTest) nodeTest).getNodeName();\r\n        iterator = parentContext.getCurrentNodePointer().attributeIterator(name);\r\n    }\r\n    if (iterator == null) {\r\n        return false;\r\n    }\r\n    if (!iterator.setPosition(iterator.getPosition() + 1)) {\r\n        return false;\r\n    }\r\n    currentNodePointer = iterator.getNodePointer();\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"public boolean nextNode() {\r\n    super.setPosition(getCurrentPosition() + 1);\r\n    if (!setStarted) {\r\n        setStarted = true;\r\n        if (!(nodeTest instanceof NodeNameTest)) {\r\n            return false;\r\n        }\r\n        QName name = ((NodeNameTest) nodeTest).getNodeName();\r\n        iterator = parentContext.getCurrentNodePointer().attributeIterator(name);\r\n    }\r\n    if (iterator == null) {\r\n        return false;\r\n    }\r\n    if (!iterator.setPosition(iterator.getPosition() + 1)) {\r\n        return false;\r\n    }\r\n    currentNodePointer = iterator.getNodePointer();\r\n    return true;\r\n}","lc":0.2272727273,"pi":-0.014354067,"ma":0.2,"nbd":0.0,"ml":0.3333333333,"d":0.2777777778,"mi":-0.1791402396,"fo":0.1666666667,"r":0.0263157895,"e":0.1422451202}
{"project_name":"Closure","project_version":"83","label":2,"code":"@Override\r\npublic int parseArguments(Parameters params) throws CmdLineException {\r\n    String param = params.getParameter(0);\r\n    if (param == null) {\r\n        setter.addValue(true);\r\n        return 0;\r\n    } else {\r\n        String lowerParam = param.toLowerCase();\r\n        if (TRUES.contains(lowerParam)) {\r\n            setter.addValue(true);\r\n        } else if (FALSES.contains(lowerParam)) {\r\n            setter.addValue(false);\r\n        } else {\r\n            setter.addValue(true);\r\n            return 0;\r\n        }\r\n        return 1;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int parseArguments(Parameters params) throws CmdLineException {\r\n    String param = params.getParameter(0);\r\n    if (param == null) {\r\n        setter.addValue(true);\r\n        return 0;\r\n    } else {\r\n        String lowerParam = param.toLowerCase();\r\n        if (TRUES.contains(lowerParam)) {\r\n            setter.addValue(true);\r\n        } else if (FALSES.contains(lowerParam)) {\r\n            setter.addValue(false);\r\n        } else {\r\n            setter.addValue(true);\r\n            return 0;\r\n        }\r\n        return 1;\r\n    }\r\n}","lc":0.2272727273,"pi":0.4354066986,"ma":0.0,"nbd":0.5,"ml":0.1666666667,"d":-0.005952381,"mi":-0.1585623679,"fo":0.1666666667,"r":0.1052631579,"e":-0.0080657895}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7275_44cad623","label":1,"code":"protected Processor createErrorHandler(RouteContext routeContext, Exchange exchange, Processor processor) {\r\n    Processor answer;\r\n    if (routeContext != null) {\r\n        \/\/ wrap the producer in error handler so we have fine grained error handling on\r\n        \/\/ the output side instead of the input side\r\n        \/\/ this is needed to support redelivery on that output alone and not doing redelivery\r\n        \/\/ for the entire multicast block again which will start from scratch again\r\n        \/\/ create key for cache\r\n        final PreparedErrorHandler key = new PreparedErrorHandler(routeContext, processor);\r\n        \/\/ lookup cached first to reuse and preserve memory\r\n        answer = errorHandlers.get(key);\r\n        if (answer != null) {\r\n            LOG.trace(\"Using existing error handler for: {}\", processor);\r\n            return answer;\r\n        }\r\n        LOG.trace(\"Creating error handler for: {}\", processor);\r\n        ErrorHandlerFactory builder = routeContext.getRoute().getErrorHandlerBuilder();\r\n        \/\/ instead of using ProcessorDefinition.wrapInErrorHandler)\r\n        try {\r\n            processor = builder.createErrorHandler(routeContext, processor);\r\n            \/\/ and wrap in unit of work processor so the copy exchange also can run under UoW\r\n            answer = createUnitOfWorkProcessor(routeContext, processor, exchange);\r\n            boolean child = exchange.getProperty(Exchange.PARENT_UNIT_OF_WORK, UnitOfWork.class) != null;\r\n            \/\/ must start the error handler\r\n            ServiceHelper.startServices(answer);\r\n            \/\/ here we don't cache the child unit of work\r\n            if (!child) {\r\n                \/\/ add to cache\r\n                errorHandlers.putIfAbsent(key, answer);\r\n            }\r\n        } catch (Exception e) {\r\n            throw ObjectHelper.wrapRuntimeCamelException(e);\r\n        }\r\n    } else {\r\n        \/\/ and wrap in unit of work processor so the copy exchange also can run under UoW\r\n        answer = createUnitOfWorkProcessor(routeContext, processor, exchange);\r\n    }\r\n    return answer;\r\n}","code_comment":null,"code_no_comment":"protected Processor createErrorHandler(RouteContext routeContext, Exchange exchange, Processor processor) {\r\n    Processor answer;\r\n    if (routeContext != null) {\r\n                                                final PreparedErrorHandler key = new PreparedErrorHandler(routeContext, processor);\r\n                answer = errorHandlers.get(key);\r\n        if (answer != null) {\r\n            LOG.trace(\"Using existing error handler for: {}\", processor);\r\n            return answer;\r\n        }\r\n        LOG.trace(\"Creating error handler for: {}\", processor);\r\n        ErrorHandlerFactory builder = routeContext.getRoute().getErrorHandlerBuilder();\r\n                try {\r\n            processor = builder.createErrorHandler(routeContext, processor);\r\n                        answer = createUnitOfWorkProcessor(routeContext, processor, exchange);\r\n            boolean child = exchange.getProperty(Exchange.PARENT_UNIT_OF_WORK, UnitOfWork.class) != null;\r\n                        ServiceHelper.startServices(answer);\r\n                        if (!child) {\r\n                                errorHandlers.putIfAbsent(key, answer);\r\n            }\r\n        } catch (Exception e) {\r\n            throw ObjectHelper.wrapRuntimeCamelException(e);\r\n        }\r\n    } else {\r\n                answer = createUnitOfWorkProcessor(routeContext, processor, exchange);\r\n    }\r\n    return answer;\r\n}","lc":0.5909090909,"pi":0.4401913876,"ma":0.4,"nbd":0.5,"ml":0.0833333333,"d":0.0674603175,"mi":-0.4596194503,"fo":0.5,"r":-0.0263157895,"e":0.2815280971}
{"project_name":"Closure","project_version":"68","label":2,"code":"\/**\r\n * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\r\n *     | FunctionType | UnionType | RecordType | ArrayType\r\n *\/\r\nprivate Node parseBasicTypeExpression(JsDocToken token) {\r\n    if (token == JsDocToken.STAR) {\r\n        return newNode(Token.STAR);\r\n    } else if (token == JsDocToken.LB) {\r\n        skipEOLs();\r\n        return parseArrayType(next());\r\n    } else if (token == JsDocToken.LC) {\r\n        skipEOLs();\r\n        return parseRecordType(next());\r\n    } else if (token == JsDocToken.LP) {\r\n        skipEOLs();\r\n        return parseUnionType(next());\r\n    } else if (token == JsDocToken.STRING) {\r\n        String string = stream.getString();\r\n        if (\"function\".equals(string)) {\r\n            skipEOLs();\r\n            return parseFunctionType(next());\r\n        } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\r\n            return newStringNode(string);\r\n        } else {\r\n            return parseTypeName(token);\r\n        }\r\n    }\r\n    return reportGenericTypeSyntaxWarning();\r\n}","code_comment":"\/**\r\n * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\r\n *     | FunctionType | UnionType | RecordType | ArrayType\r\n *\/\r\n","code_no_comment":"private Node parseBasicTypeExpression(JsDocToken token) {\r\n    if (token == JsDocToken.STAR) {\r\n        return newNode(Token.STAR);\r\n    } else if (token == JsDocToken.LB) {\r\n        skipEOLs();\r\n        return parseArrayType(next());\r\n    } else if (token == JsDocToken.LC) {\r\n        skipEOLs();\r\n        return parseRecordType(next());\r\n    } else if (token == JsDocToken.LP) {\r\n        skipEOLs();\r\n        return parseUnionType(next());\r\n    } else if (token == JsDocToken.STRING) {\r\n        String string = stream.getString();\r\n        if (\"function\".equals(string)) {\r\n            skipEOLs();\r\n            return parseFunctionType(next());\r\n        } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\r\n            return newStringNode(string);\r\n        } else {\r\n            return parseTypeName(token);\r\n        }\r\n    }\r\n    return reportGenericTypeSyntaxWarning();\r\n}","lc":0.5,"pi":0.1483253589,"ma":0.8,"nbd":2.5,"ml":0.6666666667,"d":-0.001984127,"mi":-0.3804087385,"fo":1.1666666667,"r":0.0,"e":0.0899823078}
{"project_name":"Closure","project_version":"8","label":2,"code":"private boolean canBeRedeclared(Node n, Scope s) {\r\n    if (!NodeUtil.isExprAssign(n)) {\r\n        return false;\r\n    }\r\n    Node assign = n.getFirstChild();\r\n    Node lhs = assign.getFirstChild();\r\n    if (!lhs.isName()) {\r\n        return false;\r\n    }\r\n    Var var = s.getVar(lhs.getString());\r\n    return var != null && var.getScope() == s && !blacklistedVars.contains(var);\r\n}","code_comment":null,"code_no_comment":"private boolean canBeRedeclared(Node n, Scope s) {\r\n    if (!NodeUtil.isExprAssign(n)) {\r\n        return false;\r\n    }\r\n    Node assign = n.getFirstChild();\r\n    Node lhs = assign.getFirstChild();\r\n    if (!lhs.isName()) {\r\n        return false;\r\n    }\r\n    Var var = s.getVar(lhs.getString());\r\n    return var != null && var.getScope() == s && !blacklistedVars.contains(var);\r\n}","lc":-0.0909090909,"pi":-0.3253588517,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":0.2956349206,"mi":0.0384778013,"fo":0.1666666667,"r":0.4473684211,"e":0.1622678262}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4121_8967eb2b","label":1,"code":"\/**\r\n *  Initialize this wizard with a transition model.\r\n *  <p>\r\n *  If you constructed this wizard using a constructor without the transitions model argument,\r\n *  <strong>you must<\/strong> call this method prior to actually using it.\r\n *  <\/p>\r\n *\r\n *  @param wizardModel\r\n *\/\r\nprotected void init(final IWizardModel wizardModel) {\r\n    if (wizardModel == null) {\r\n        throw new IllegalArgumentException(\"argument wizardModel must be not null\");\r\n    }\r\n    this.wizardModel = wizardModel;\r\n    form = newForm(FORM_ID);\r\n    addOrReplace(form);\r\n    \/\/ dummy view to be replaced\r\n    form.addOrReplace(new WebMarkupContainer(HEADER_ID));\r\n    form.addOrReplace(newFeedbackPanel(FEEDBACK_ID));\r\n    \/\/ add dummy view; will be replaced on initialization\r\n    form.addOrReplace(new WebMarkupContainer(VIEW_ID));\r\n    form.addOrReplace(newButtonBar(BUTTONS_ID));\r\n    form.addOrReplace(newOverviewBar(OVERVIEW_ID));\r\n    wizardModel.addListener(this);\r\n    Iterator<IWizardStep> stepsIterator = wizardModel.stepIterator();\r\n    if (stepsIterator != null) {\r\n        while (stepsIterator.hasNext()) {\r\n            (stepsIterator.next()).init(wizardModel);\r\n        }\r\n    }\r\n    \/\/ reset model to prepare for action\r\n    wizardModel.reset();\r\n}","code_comment":"\/**\r\n *  Initialize this wizard with a transition model.\r\n *  <p>\r\n *  If you constructed this wizard using a constructor without the transitions model argument,\r\n *  <strong>you must<\/strong> call this method prior to actually using it.\r\n *  <\/p>\r\n *\r\n *  @param wizardModel\r\n *\/\r\n","code_no_comment":"protected void init(final IWizardModel wizardModel) {\r\n    if (wizardModel == null) {\r\n        throw new IllegalArgumentException(\"argument wizardModel must be not null\");\r\n    }\r\n    this.wizardModel = wizardModel;\r\n    form = newForm(FORM_ID);\r\n    addOrReplace(form);\r\n        form.addOrReplace(new WebMarkupContainer(HEADER_ID));\r\n    form.addOrReplace(newFeedbackPanel(FEEDBACK_ID));\r\n        form.addOrReplace(new WebMarkupContainer(VIEW_ID));\r\n    form.addOrReplace(newButtonBar(BUTTONS_ID));\r\n    form.addOrReplace(newOverviewBar(OVERVIEW_ID));\r\n    wizardModel.addListener(this);\r\n    Iterator<IWizardStep> stepsIterator = wizardModel.stepIterator();\r\n    if (stepsIterator != null) {\r\n        while (stepsIterator.hasNext()) {\r\n            (stepsIterator.next()).init(wizardModel);\r\n        }\r\n    }\r\n        wizardModel.reset();\r\n}","lc":0.3181818182,"pi":-0.2057416268,"ma":0.2,"nbd":0.0,"ml":0.0833333333,"d":0.003968254,"mi":-0.2724453841,"fo":0.8333333333,"r":-0.0263157895,"e":0.0789912576}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4072_7d5b8645","label":1,"code":"\/**\r\n *  get default port number for protocol\r\n *\r\n *  @param protocol\r\n *            name of protocol\r\n *  @return default port for protocol or <code>null<\/code> if unknown\r\n *\/\r\nprivate static Integer getDefaultPortForProtocol(String protocol) {\r\n    if (\"http\".equals(protocol)) {\r\n        return 80;\r\n    } else if (\"https\".equals(protocol)) {\r\n        return 443;\r\n    } else if (\"ftp\".equals(protocol)) {\r\n        return 21;\r\n    } else {\r\n        return null;\r\n    }\r\n}","code_comment":"\/**\r\n *  get default port number for protocol\r\n *\r\n *  @param protocol\r\n *            name of protocol\r\n *  @return default port for protocol or <code>null<\/code> if unknown\r\n *\/\r\n","code_no_comment":"private static Integer getDefaultPortForProtocol(String protocol) {\r\n    if (\"http\".equals(protocol)) {\r\n        return 80;\r\n    } else if (\"https\".equals(protocol)) {\r\n        return 443;\r\n    } else if (\"ftp\".equals(protocol)) {\r\n        return 21;\r\n    } else {\r\n        return null;\r\n    }\r\n}","lc":-0.1363636364,"pi":-0.0622009569,"ma":0.0,"nbd":0.5,"ml":0.1666666667,"d":-0.3650793651,"mi":0.2411557435,"fo":-0.25,"r":0.7368421053,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3789_9319e139","label":1,"code":"private void keepLastModified(Exchange exchange, File file) {\r\n    if (endpoint.isKeepLastModified()) {\r\n        Long last;\r\n        Date date = exchange.getIn().getHeader(Exchange.FILE_LAST_MODIFIED, Date.class);\r\n        if (date != null) {\r\n            last = date.getTime();\r\n        } else {\r\n            \/\/ fallback and try a long\r\n            last = exchange.getIn().getHeader(Exchange.FILE_LAST_MODIFIED, Long.class);\r\n        }\r\n        if (last != null) {\r\n            boolean result = file.setLastModified(last);\r\n            LOG.trace(\"Keeping last modified timestamp: {} on file: {} with result: {}\", new Object[] { last, file, result });\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void keepLastModified(Exchange exchange, File file) {\r\n    if (endpoint.isKeepLastModified()) {\r\n        Long last;\r\n        Date date = exchange.getIn().getHeader(Exchange.FILE_LAST_MODIFIED, Date.class);\r\n        if (date != null) {\r\n            last = date.getTime();\r\n        } else {\r\n                        last = exchange.getIn().getHeader(Exchange.FILE_LAST_MODIFIED, Long.class);\r\n        }\r\n        if (last != null) {\r\n            boolean result = file.setLastModified(last);\r\n            LOG.trace(\"Keeping last modified timestamp: {} on file: {} with result: {}\", new Object[] { last, file, result });\r\n        }\r\n    }\r\n}","lc":0.0454545455,"pi":0.4019138756,"ma":0.0,"nbd":0.0,"ml":0.0833333333,"d":0.005952381,"mi":-0.0804792107,"fo":0.1666666667,"r":-0.0263157895,"e":0.0333396726}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3647_1b57b51c","label":1,"code":"\/**\r\n *  Get the markupId\r\n *\r\n *  @return MarkupId\r\n *\/\r\npublic final Object getMarkupIdImpl() {\r\n    String id = getMarkupIdFromMarkup();\r\n    if (id != null) {\r\n        return id;\r\n    }\r\n    if (generatedMarkupId != -1) {\r\n        return generatedMarkupId;\r\n    }\r\n    return getMetaData(MARKUP_ID_KEY);\r\n}","code_comment":"\/**\r\n *  Get the markupId\r\n *\r\n *  @return MarkupId\r\n *\/\r\n","code_no_comment":"public final Object getMarkupIdImpl() {\r\n    String id = getMarkupIdFromMarkup();\r\n    if (id != null) {\r\n        return id;\r\n    }\r\n    if (generatedMarkupId != -1) {\r\n        return generatedMarkupId;\r\n    }\r\n    return getMetaData(MARKUP_ID_KEY);\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.1130952381,"mi":0.2871035941,"fo":-0.3333333333,"r":2.5263157895,"e":-0.1225820208}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4420_d645112f","label":1,"code":"private void removeCheckpointReferences(NodeBuilder builder) throws CommitFailedException {\r\n    \/\/ removing references to the checkpoints,\r\n    \/\/ which don't exist in the new repository\r\n    builder.setChildNode(\":async\");\r\n}","code_comment":null,"code_no_comment":"private void removeCheckpointReferences(NodeBuilder builder) throws CommitFailedException {\r\n            builder.setChildNode(\":async\");\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0132487667,"fo":-0.4166666667,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3021_494da6de","label":1,"code":"@Override\r\npublic Validator childNodeDeleted(String name, NodeState before) throws CommitFailedException {\r\n    Tree tree = parentBefore.getChild(name);\r\n    AuthorizableType type = UserUtil.getType(tree);\r\n    if (type == AuthorizableType.USER || type == AuthorizableType.GROUP) {\r\n        if (isAdminUser(tree)) {\r\n            String msg = \"The admin user cannot be removed.\";\r\n            throw constraintViolation(27, msg);\r\n        }\r\n        return null;\r\n    } else {\r\n        return new VisibleValidator(new UserValidator(tree, null, provider), true, true);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Validator childNodeDeleted(String name, NodeState before) throws CommitFailedException {\r\n    Tree tree = parentBefore.getChild(name);\r\n    AuthorizableType type = UserUtil.getType(tree);\r\n    if (type == AuthorizableType.USER || type == AuthorizableType.GROUP) {\r\n        if (isAdminUser(tree)) {\r\n            String msg = \"The admin user cannot be removed.\";\r\n            throw constraintViolation(27, msg);\r\n        }\r\n        return null;\r\n    } else {\r\n        return new VisibleValidator(new UserValidator(tree, null, provider), true, true);\r\n    }\r\n}","lc":0.0,"pi":0.4306220096,"ma":0.0,"nbd":0.0,"ml":0.0833333333,"d":-0.0853174603,"mi":-0.0536997886,"fo":-0.1666666667,"r":-0.0263157895,"e":-0.0096194741}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5138_e8dab4a0","label":1,"code":"\/**\r\n *  Process the request cycle\r\n *\r\n *  @param requestCycle\r\n *  @param webResponse\r\n *  @param httpServletRequest\r\n *  @param httpServletResponse\r\n *  @param chain\r\n *  @return false, if the request could not be processed\r\n *  @throws IOException\r\n *  @throws ServletException\r\n *\/\r\nprotected boolean processRequestCycle(RequestCycle requestCycle, WebResponse webResponse, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, final FilterChain chain) throws IOException, ServletException {\r\n    \/\/ Assume we are able to handle the request\r\n    boolean res = true;\r\n    if (!requestCycle.processRequestAndDetach()) {\r\n        if (chain != null) {\r\n            chain.doFilter(httpServletRequest, httpServletResponse);\r\n        }\r\n        res = false;\r\n    } else {\r\n        webResponse.flush();\r\n    }\r\n    return res;\r\n}","code_comment":"\/**\r\n *  Process the request cycle\r\n *\r\n *  @param requestCycle\r\n *  @param webResponse\r\n *  @param httpServletRequest\r\n *  @param httpServletResponse\r\n *  @param chain\r\n *  @return false, if the request could not be processed\r\n *  @throws IOException\r\n *  @throws ServletException\r\n *\/\r\n","code_no_comment":"protected boolean processRequestCycle(RequestCycle requestCycle, WebResponse webResponse, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, final FilterChain chain) throws IOException, ServletException {\r\n        boolean res = true;\r\n    if (!requestCycle.processRequestAndDetach()) {\r\n        if (chain != null) {\r\n            chain.doFilter(httpServletRequest, httpServletResponse);\r\n        }\r\n        res = false;\r\n    } else {\r\n        webResponse.flush();\r\n    }\r\n    return res;\r\n}","lc":-0.0909090909,"pi":0.1961722488,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0912698413,"mi":0.0875264271,"fo":-0.25,"r":0.2894736842,"e":-0.0664649643}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3845_afc7034d","label":1,"code":"\/**\r\n *  add header value\r\n *\r\n *  @param name\r\n *           header name\r\n *  @param value\r\n *           header value\r\n *\/\r\npublic void addHeader(String name, String value) {\r\n    \/\/ be lenient and strip leading \/ trailing blanks\r\n    value = Args.notEmpty(value, \"value\").trim();\r\n    internalAdd(name, value);\r\n}","code_comment":"\/**\r\n *  add header value\r\n *\r\n *  @param name\r\n *           header name\r\n *  @param value\r\n *           header value\r\n *\/\r\n","code_no_comment":"public void addHeader(String name, String value) {\r\n        value = Args.notEmpty(value, \"value\").trim();\r\n    internalAdd(name, value);\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.755602537,"fo":-0.25,"r":2.4473684211,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1358_6c565dfb","label":1,"code":"private static String setUpOptions(ClassLoader classloader, final ConsoleReader reader, final String className, final Map<String, String> options) throws IOException, ShellCommandException {\r\n    String input;\r\n    OptionDescriber skvi;\r\n    Class<? extends OptionDescriber> clazz;\r\n    try {\r\n        clazz = classloader.loadClass(className).asSubclass(OptionDescriber.class);\r\n        skvi = clazz.newInstance();\r\n    } catch (ClassNotFoundException e) {\r\n        throw new IllegalArgumentException(e.getMessage());\r\n    } catch (InstantiationException e) {\r\n        throw new IllegalArgumentException(e.getMessage());\r\n    } catch (IllegalAccessException e) {\r\n        throw new IllegalArgumentException(e.getMessage());\r\n    } catch (ClassCastException e) {\r\n        throw new ShellCommandException(ErrorCode.INITIALIZATION_FAILURE, \"Unable to load \" + className + \" as type \" + OptionDescriber.class.getName() + \"; configure with 'config' instead\");\r\n    }\r\n    final IteratorOptions itopts = skvi.describeOptions();\r\n    if (itopts.getName() == null) {\r\n        throw new IllegalArgumentException(className + \" described its default distinguishing name as null\");\r\n    }\r\n    String shortClassName = className;\r\n    if (className.contains(\".\")) {\r\n        shortClassName = className.substring(className.lastIndexOf('.') + 1);\r\n    }\r\n    final Map<String, String> localOptions = new HashMap<String, String>();\r\n    do {\r\n        \/\/ clean up the overall options that caused things to fail\r\n        for (String key : localOptions.keySet()) {\r\n            options.remove(key);\r\n        }\r\n        localOptions.clear();\r\n        reader.printString(itopts.getDescription());\r\n        reader.printNewline();\r\n        String prompt;\r\n        if (itopts.getNamedOptions() != null) {\r\n            for (Entry<String, String> e : itopts.getNamedOptions().entrySet()) {\r\n                prompt = Shell.repeat(\"-\", 10) + \"> set \" + shortClassName + \" parameter \" + e.getKey() + \", \" + e.getValue() + \": \";\r\n                reader.flushConsole();\r\n                input = reader.readLine(prompt);\r\n                if (input == null) {\r\n                    reader.printNewline();\r\n                    throw new IOException(\"Input stream closed\");\r\n                } else {\r\n                    input = new String(input);\r\n                }\r\n                \/\/ Places all Parameters and Values into the LocalOptions, even if the value is \"\".\r\n                \/\/ This allows us to check for \"\" values when setting the iterators and allows us to remove\r\n                \/\/ the parameter and value from the table property.\r\n                localOptions.put(e.getKey(), input);\r\n            }\r\n        }\r\n        if (itopts.getUnnamedOptionDescriptions() != null) {\r\n            for (String desc : itopts.getUnnamedOptionDescriptions()) {\r\n                reader.printString(Shell.repeat(\"-\", 10) + \"> entering options: \" + desc + \"\\n\");\r\n                input = \"start\";\r\n                while (true) {\r\n                    prompt = Shell.repeat(\"-\", 10) + \"> set \" + shortClassName + \" option (<name> <value>, hit enter to skip): \";\r\n                    reader.flushConsole();\r\n                    input = reader.readLine(prompt);\r\n                    if (input == null) {\r\n                        reader.printNewline();\r\n                        throw new IOException(\"Input stream closed\");\r\n                    } else {\r\n                        input = new String(input);\r\n                    }\r\n                    if (input.length() == 0)\r\n                        break;\r\n                    String[] sa = input.split(\" \", 2);\r\n                    localOptions.put(sa[0], sa[1]);\r\n                }\r\n            }\r\n        }\r\n        options.putAll(localOptions);\r\n        if (!skvi.validateOptions(options))\r\n            reader.printString(\"invalid options for \" + clazz.getName() + \"\\n\");\r\n    } while (!skvi.validateOptions(options));\r\n    return itopts.getName();\r\n}","code_comment":null,"code_no_comment":"private static String setUpOptions(ClassLoader classloader, final ConsoleReader reader, final String className, final Map<String, String> options) throws IOException, ShellCommandException {\r\n    String input;\r\n    OptionDescriber skvi;\r\n    Class<? extends OptionDescriber> clazz;\r\n    try {\r\n        clazz = classloader.loadClass(className).asSubclass(OptionDescriber.class);\r\n        skvi = clazz.newInstance();\r\n    } catch (ClassNotFoundException e) {\r\n        throw new IllegalArgumentException(e.getMessage());\r\n    } catch (InstantiationException e) {\r\n        throw new IllegalArgumentException(e.getMessage());\r\n    } catch (IllegalAccessException e) {\r\n        throw new IllegalArgumentException(e.getMessage());\r\n    } catch (ClassCastException e) {\r\n        throw new ShellCommandException(ErrorCode.INITIALIZATION_FAILURE, \"Unable to load \" + className + \" as type \" + OptionDescriber.class.getName() + \"; configure with 'config' instead\");\r\n    }\r\n    final IteratorOptions itopts = skvi.describeOptions();\r\n    if (itopts.getName() == null) {\r\n        throw new IllegalArgumentException(className + \" described its default distinguishing name as null\");\r\n    }\r\n    String shortClassName = className;\r\n    if (className.contains(\".\")) {\r\n        shortClassName = className.substring(className.lastIndexOf('.') + 1);\r\n    }\r\n    final Map<String, String> localOptions = new HashMap<String, String>();\r\n    do {\r\n                for (String key : localOptions.keySet()) {\r\n            options.remove(key);\r\n        }\r\n        localOptions.clear();\r\n        reader.printString(itopts.getDescription());\r\n        reader.printNewline();\r\n        String prompt;\r\n        if (itopts.getNamedOptions() != null) {\r\n            for (Entry<String, String> e : itopts.getNamedOptions().entrySet()) {\r\n                prompt = Shell.repeat(\"-\", 10) + \"> set \" + shortClassName + \" parameter \" + e.getKey() + \", \" + e.getValue() + \": \";\r\n                reader.flushConsole();\r\n                input = reader.readLine(prompt);\r\n                if (input == null) {\r\n                    reader.printNewline();\r\n                    throw new IOException(\"Input stream closed\");\r\n                } else {\r\n                    input = new String(input);\r\n                }\r\n                                                                localOptions.put(e.getKey(), input);\r\n            }\r\n        }\r\n        if (itopts.getUnnamedOptionDescriptions() != null) {\r\n            for (String desc : itopts.getUnnamedOptionDescriptions()) {\r\n                reader.printString(Shell.repeat(\"-\", 10) + \"> entering options: \" + desc + \"\\n\");\r\n                input = \"start\";\r\n                while (true) {\r\n                    prompt = Shell.repeat(\"-\", 10) + \"> set \" + shortClassName + \" option (<name> <value>, hit enter to skip): \";\r\n                    reader.flushConsole();\r\n                    input = reader.readLine(prompt);\r\n                    if (input == null) {\r\n                        reader.printNewline();\r\n                        throw new IOException(\"Input stream closed\");\r\n                    } else {\r\n                        input = new String(input);\r\n                    }\r\n                    if (input.length() == 0)\r\n                        break;\r\n                    String[] sa = input.split(\" \", 2);\r\n                    localOptions.put(sa[0], sa[1]);\r\n                }\r\n            }\r\n        }\r\n        options.putAll(localOptions);\r\n        if (!skvi.validateOptions(options))\r\n            reader.printString(\"invalid options for \" + clazz.getName() + \"\\n\");\r\n    } while (!skvi.validateOptions(options));\r\n    return itopts.getName();\r\n}","lc":2.7272727273,"pi":1.7559808612,"ma":4.4,"nbd":1.5,"ml":1.0833333333,"d":0.6468253968,"mi":-1.2412966878,"fo":3.3333333333,"r":-0.0263157895,"e":3.6898186408}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4927_8c827e33","label":1,"code":"@Override\r\npublic void addCookie(Cookie cookie) {\r\n    checkHeader();\r\n    bufferedResponse.addCookie(cookie);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void addCookie(Cookie cookie) {\r\n    checkHeader();\r\n    bufferedResponse.addCookie(cookie);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7626497533,"fo":-0.3333333333,"r":1.5789473684,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2334_96330447","label":1,"code":"@Override\r\nprotected void populateItem(ListItem<IDebugBarContributor> item) {\r\n    IDebugBarContributor contrib = item.getModelObject();\r\n    Component comp = contrib.createComponent(\"contrib\", DebugBar.this);\r\n    if (comp == null) {\r\n        \/\/ some contributors only add information to the debug bar\r\n        \/\/ and don't actually create a contributed component\r\n        item.setVisibilityAllowed(false);\r\n    } else {\r\n        item.add(comp);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void populateItem(ListItem<IDebugBarContributor> item) {\r\n    IDebugBarContributor contrib = item.getModelObject();\r\n    Component comp = contrib.createComponent(\"contrib\", DebugBar.this);\r\n    if (comp == null) {\r\n                        item.setVisibilityAllowed(false);\r\n    } else {\r\n        item.add(comp);\r\n    }\r\n}","lc":-0.1818181818,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0674603175,"mi":0.2205778717,"fo":-0.1666666667,"r":0.7894736842,"e":-0.0849339857}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1932_c215b267","label":1,"code":"public SegmentNodeState compact(NodeState before, NodeState after) {\r\n    after.compareAgainstBaseState(before, new CompactDiff(builder));\r\n    return builder.getNodeState();\r\n}","code_comment":null,"code_no_comment":"public SegmentNodeState compact(NodeState before, NodeState after) {\r\n    after.compareAgainstBaseState(before, new CompactDiff(builder));\r\n    return builder.getNodeState();\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7753347428,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-338_8dd22390","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\r\n    sanityChecks(equations, t0, y0, t, y);\r\n    setEquations(equations);\r\n    resetEvaluations();\r\n    final boolean forward = t > t0;\r\n    \/\/ create some internal working arrays\r\n    final int stages = c.length + 1;\r\n    if (y != y0) {\r\n        System.arraycopy(y0, 0, y, 0, y0.length);\r\n    }\r\n    final double[][] yDotK = new double[stages][y0.length];\r\n    final double[] yTmp = new double[y0.length];\r\n    \/\/ set up an interpolator sharing the integrator arrays\r\n    AbstractStepInterpolator interpolator;\r\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\r\n        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\r\n        rki.reinitialize(this, yTmp, yDotK, forward);\r\n        interpolator = rki;\r\n    } else {\r\n        interpolator = new DummyStepInterpolator(yTmp, forward);\r\n    }\r\n    interpolator.storeTime(t0);\r\n    \/\/ set up integration control objects\r\n    stepStart = t0;\r\n    double hNew = 0;\r\n    boolean firstTime = true;\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.reset();\r\n    }\r\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\r\n    boolean lastStep = false;\r\n    \/\/ main integration loop\r\n    while (!lastStep) {\r\n        interpolator.shift();\r\n        double error = 0;\r\n        for (boolean loop = true; loop; ) {\r\n            if (firstTime || !fsal) {\r\n                \/\/ first stage\r\n                computeDerivatives(stepStart, y, yDotK[0]);\r\n            }\r\n            if (firstTime) {\r\n                final double[] scale;\r\n                if (vecAbsoluteTolerance != null) {\r\n                    scale = vecAbsoluteTolerance;\r\n                } else {\r\n                    scale = new double[y0.length];\r\n                    Arrays.fill(scale, scalAbsoluteTolerance);\r\n                }\r\n                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\r\n                firstTime = false;\r\n            }\r\n            stepSize = hNew;\r\n            \/\/ next stages\r\n            for (int k = 1; k < stages; ++k) {\r\n                for (int j = 0; j < y0.length; ++j) {\r\n                    double sum = a[k - 1][0] * yDotK[0][j];\r\n                    for (int l = 1; l < k; ++l) {\r\n                        sum += a[k - 1][l] * yDotK[l][j];\r\n                    }\r\n                    yTmp[j] = y[j] + stepSize * sum;\r\n                }\r\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\r\n            }\r\n            \/\/ estimate the state at the end of the step\r\n            for (int j = 0; j < y0.length; ++j) {\r\n                double sum = b[0] * yDotK[0][j];\r\n                for (int l = 1; l < stages; ++l) {\r\n                    sum += b[l] * yDotK[l][j];\r\n                }\r\n                yTmp[j] = y[j] + stepSize * sum;\r\n            }\r\n            \/\/ estimate the error at the end of the step\r\n            error = estimateError(yDotK, y, yTmp, stepSize);\r\n            if (error <= 1.0) {\r\n                \/\/ discrete events handling\r\n                interpolator.storeTime(stepStart + stepSize);\r\n                if (manager.evaluateStep(interpolator)) {\r\n                    final double dt = manager.getEventTime() - stepStart;\r\n                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\r\n                        \/\/ rejecting the step would lead to a too small next step, we accept it\r\n                        loop = false;\r\n                    } else {\r\n                        \/\/ reject the step to match exactly the next switch time\r\n                        hNew = dt;\r\n                    }\r\n                } else {\r\n                    \/\/ accept the step\r\n                    loop = false;\r\n                }\r\n            } else {\r\n                \/\/ reject the step and attempt to reduce error by stepsize control\r\n                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\r\n                hNew = filterStep(stepSize * factor, forward, false);\r\n            }\r\n        }\r\n        \/\/ the step has been accepted\r\n        final double nextStep = stepStart + stepSize;\r\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\r\n        manager.stepAccepted(nextStep, y);\r\n        lastStep = manager.stop();\r\n        \/\/ provide the step data to the step handler\r\n        interpolator.storeTime(nextStep);\r\n        for (StepHandler handler : stepHandlers) {\r\n            handler.handleStep(interpolator, lastStep);\r\n        }\r\n        stepStart = nextStep;\r\n        if (fsal) {\r\n            \/\/ save the last evaluation for the next step\r\n            System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\r\n        }\r\n        if (manager.reset(stepStart, y) && !lastStep) {\r\n            \/\/ some event handler has triggered changes that\r\n            \/\/ invalidate the derivatives, we need to recompute them\r\n            computeDerivatives(stepStart, y, yDotK[0]);\r\n        }\r\n        if (!lastStep) {\r\n            \/\/ in some rare cases we may get here with stepSize = 0, for example\r\n            \/\/ when an event occurs at integration start, reducing the first step\r\n            \/\/ to zero; we have to reset the step to some safe non zero value\r\n            stepSize = filterStep(stepSize, forward, true);\r\n            \/\/ stepsize control for next step\r\n            final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\r\n            final double scaledH = stepSize * factor;\r\n            final double nextT = stepStart + scaledH;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            hNew = filterStep(scaledH, forward, nextIsLast);\r\n        }\r\n    }\r\n    final double stopTime = stepStart;\r\n    resetInternalState();\r\n    return stopTime;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\r\n    sanityChecks(equations, t0, y0, t, y);\r\n    setEquations(equations);\r\n    resetEvaluations();\r\n    final boolean forward = t > t0;\r\n        final int stages = c.length + 1;\r\n    if (y != y0) {\r\n        System.arraycopy(y0, 0, y, 0, y0.length);\r\n    }\r\n    final double[][] yDotK = new double[stages][y0.length];\r\n    final double[] yTmp = new double[y0.length];\r\n        AbstractStepInterpolator interpolator;\r\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\r\n        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\r\n        rki.reinitialize(this, yTmp, yDotK, forward);\r\n        interpolator = rki;\r\n    } else {\r\n        interpolator = new DummyStepInterpolator(yTmp, forward);\r\n    }\r\n    interpolator.storeTime(t0);\r\n        stepStart = t0;\r\n    double hNew = 0;\r\n    boolean firstTime = true;\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.reset();\r\n    }\r\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\r\n    boolean lastStep = false;\r\n        while (!lastStep) {\r\n        interpolator.shift();\r\n        double error = 0;\r\n        for (boolean loop = true; loop; ) {\r\n            if (firstTime || !fsal) {\r\n                                computeDerivatives(stepStart, y, yDotK[0]);\r\n            }\r\n            if (firstTime) {\r\n                final double[] scale;\r\n                if (vecAbsoluteTolerance != null) {\r\n                    scale = vecAbsoluteTolerance;\r\n                } else {\r\n                    scale = new double[y0.length];\r\n                    Arrays.fill(scale, scalAbsoluteTolerance);\r\n                }\r\n                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\r\n                firstTime = false;\r\n            }\r\n            stepSize = hNew;\r\n                        for (int k = 1; k < stages; ++k) {\r\n                for (int j = 0; j < y0.length; ++j) {\r\n                    double sum = a[k - 1][0] * yDotK[0][j];\r\n                    for (int l = 1; l < k; ++l) {\r\n                        sum += a[k - 1][l] * yDotK[l][j];\r\n                    }\r\n                    yTmp[j] = y[j] + stepSize * sum;\r\n                }\r\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\r\n            }\r\n                        for (int j = 0; j < y0.length; ++j) {\r\n                double sum = b[0] * yDotK[0][j];\r\n                for (int l = 1; l < stages; ++l) {\r\n                    sum += b[l] * yDotK[l][j];\r\n                }\r\n                yTmp[j] = y[j] + stepSize * sum;\r\n            }\r\n                        error = estimateError(yDotK, y, yTmp, stepSize);\r\n            if (error <= 1.0) {\r\n                                interpolator.storeTime(stepStart + stepSize);\r\n                if (manager.evaluateStep(interpolator)) {\r\n                    final double dt = manager.getEventTime() - stepStart;\r\n                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\r\n                                                loop = false;\r\n                    } else {\r\n                                                hNew = dt;\r\n                    }\r\n                } else {\r\n                                        loop = false;\r\n                }\r\n            } else {\r\n                                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\r\n                hNew = filterStep(stepSize * factor, forward, false);\r\n            }\r\n        }\r\n                final double nextStep = stepStart + stepSize;\r\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\r\n        manager.stepAccepted(nextStep, y);\r\n        lastStep = manager.stop();\r\n                interpolator.storeTime(nextStep);\r\n        for (StepHandler handler : stepHandlers) {\r\n            handler.handleStep(interpolator, lastStep);\r\n        }\r\n        stepStart = nextStep;\r\n        if (fsal) {\r\n                        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\r\n        }\r\n        if (manager.reset(stepStart, y) && !lastStep) {\r\n                                    computeDerivatives(stepStart, y, yDotK[0]);\r\n        }\r\n        if (!lastStep) {\r\n                                                stepSize = filterStep(stepSize, forward, true);\r\n                        final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\r\n            final double scaledH = stepSize * factor;\r\n            final double nextT = stepStart + scaledH;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            hNew = filterStep(scaledH, forward, nextIsLast);\r\n        }\r\n    }\r\n    final double stopTime = stepStart;\r\n    resetInternalState();\r\n    return stopTime;\r\n}","lc":4.4090909091,"pi":1.4162679426,"ma":3.6,"nbd":1.5,"ml":3.3333333333,"d":4.7222222222,"mi":-1.4890768147,"fo":2.9166666667,"r":-0.0263157895,"e":35.28282245}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2181_d79d0192","label":1,"code":"\/**\r\n *  Gets the index of the current page being displayed by this list view.\r\n *\r\n *  @return Returns the currentPage.\r\n *\/\r\npublic final int getCurrentPage() {\r\n    \/\/ If first cell is out of range, bring page back into range\r\n    while ((currentPage * rowsPerPage) >= getList().size()) {\r\n        currentPage--;\r\n    }\r\n    return currentPage;\r\n}","code_comment":"\/**\r\n *  Gets the index of the current page being displayed by this list view.\r\n *\r\n *  @return Returns the currentPage.\r\n *\/\r\n","code_no_comment":"public final int getCurrentPage() {\r\n        while ((currentPage * rowsPerPage) >= getList().size()) {\r\n        currentPage--;\r\n    }\r\n    return currentPage;\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":-0.1011904762,"mi":0.6259337562,"fo":-0.3333333333,"r":2.4473684211,"e":-0.141359935}
{"project_name":"Cli","project_version":"18","label":1,"code":"\/**\r\n * <p>An implementation of {@link Parser}'s abstract\r\n * {@link Parser#flatten(Options,String[],boolean) flatten} method.<\/p>\r\n *\r\n * <p>The following are the rules used by this flatten method.\r\n * <ol>\r\n *  <li>if <code>stopAtNonOption<\/code> is <b>true<\/b> then do not\r\n *  burst anymore of <code>arguments<\/code> entries, just add each\r\n *  successive entry without further processing.  Otherwise, ignore\r\n *  <code>stopAtNonOption<\/code>.<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is \"<b>--<\/b>\"\r\n *  just add the entry to the list of processed tokens<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is \"<b>-<\/b>\"\r\n *  just add the entry to the list of processed tokens<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is two characters\r\n *  in length and the first character is \"<b>-<\/b>\" then check if this\r\n *  is a valid {@link Option} id.  If it is a valid id, then add the\r\n *  entry to the list of processed tokens and set the current {@link Option}\r\n *  member.  If it is not a valid id and <code>stopAtNonOption<\/code>\r\n *  is true, then the remaining entries are copied to the list of\r\n *  processed tokens.  Otherwise, the current entry is ignored.<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is more than two\r\n *  characters in length and the first character is \"<b>-<\/b>\" then\r\n *  we need to burst the entry to determine its constituents.  For more\r\n *  information on the bursting algorithm see\r\n *  {@link PosixParser#burstToken(String, boolean) burstToken}.<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is not handled\r\n *  by any of the previous rules, then the entry is added to the list\r\n *  of processed tokens.<\/li>\r\n * <\/ol>\r\n * <\/p>\r\n *\r\n * @param options The command line {@link Options}\r\n * @param arguments The command line arguments to be parsed\r\n * @param stopAtNonOption Specifies whether to stop flattening\r\n * when an non option is found.\r\n * @return The flattened <code>arguments<\/code> String array.\r\n *\/\r\nprotected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {\r\n    init();\r\n    this.options = options;\r\n    \/\/ an iterator for the command line tokens\r\n    Iterator iter = Arrays.asList(arguments).iterator();\r\n    \/\/ process each command line token\r\n    while (iter.hasNext()) {\r\n        \/\/ get the next command line token\r\n        String token = (String) iter.next();\r\n        \/\/ handle SPECIAL TOKEN\r\n        if (token.startsWith(\"--\")) {\r\n            if (token.indexOf('=') != -1) {\r\n                tokens.add(token.substring(0, token.indexOf('=')));\r\n                tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\r\n            } else {\r\n                tokens.add(token);\r\n            }\r\n        } else \/\/ single hyphen\r\n        if (\"-\".equals(token)) {\r\n            processSingleHyphen(token);\r\n        } else if (token.startsWith(\"-\")) {\r\n            if (token.length() == 2) {\r\n                processOptionToken(token, stopAtNonOption);\r\n            } else if (options.hasOption(token)) {\r\n                tokens.add(token);\r\n            } else \/\/ requires bursting\r\n            {\r\n                burstToken(token, stopAtNonOption);\r\n            }\r\n        } else if (stopAtNonOption) {\r\n            process(token);\r\n        } else {\r\n            tokens.add(token);\r\n        }\r\n        gobble(iter);\r\n    }\r\n    return (String[]) tokens.toArray(new String[tokens.size()]);\r\n}","code_comment":"\/**\r\n * <p>An implementation of {@link Parser}'s abstract\r\n * {@link Parser#flatten(Options,String[],boolean) flatten} method.<\/p>\r\n *\r\n * <p>The following are the rules used by this flatten method.\r\n * <ol>\r\n *  <li>if <code>stopAtNonOption<\/code> is <b>true<\/b> then do not\r\n *  burst anymore of <code>arguments<\/code> entries, just add each\r\n *  successive entry without further processing.  Otherwise, ignore\r\n *  <code>stopAtNonOption<\/code>.<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is \"<b>--<\/b>\"\r\n *  just add the entry to the list of processed tokens<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is \"<b>-<\/b>\"\r\n *  just add the entry to the list of processed tokens<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is two characters\r\n *  in length and the first character is \"<b>-<\/b>\" then check if this\r\n *  is a valid {@link Option} id.  If it is a valid id, then add the\r\n *  entry to the list of processed tokens and set the current {@link Option}\r\n *  member.  If it is not a valid id and <code>stopAtNonOption<\/code>\r\n *  is true, then the remaining entries are copied to the list of\r\n *  processed tokens.  Otherwise, the current entry is ignored.<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is more than two\r\n *  characters in length and the first character is \"<b>-<\/b>\" then\r\n *  we need to burst the entry to determine its constituents.  For more\r\n *  information on the bursting algorithm see\r\n *  {@link PosixParser#burstToken(String, boolean) burstToken}.<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is not handled\r\n *  by any of the previous rules, then the entry is added to the list\r\n *  of processed tokens.<\/li>\r\n * <\/ol>\r\n * <\/p>\r\n *\r\n * @param options The command line {@link Options}\r\n * @param arguments The command line arguments to be parsed\r\n * @param stopAtNonOption Specifies whether to stop flattening\r\n * when an non option is found.\r\n * @return The flattened <code>arguments<\/code> String array.\r\n *\/\r\n","code_no_comment":"protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {\r\n    init();\r\n    this.options = options;\r\n        Iterator iter = Arrays.asList(arguments).iterator();\r\n        while (iter.hasNext()) {\r\n                String token = (String) iter.next();\r\n                if (token.startsWith(\"--\")) {\r\n            if (token.indexOf('=') != -1) {\r\n                tokens.add(token.substring(0, token.indexOf('=')));\r\n                tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\r\n            } else {\r\n                tokens.add(token);\r\n            }\r\n        } else         if (\"-\".equals(token)) {\r\n            processSingleHyphen(token);\r\n        } else if (token.startsWith(\"-\")) {\r\n            if (token.length() == 2) {\r\n                processOptionToken(token, stopAtNonOption);\r\n            } else if (options.hasOption(token)) {\r\n                tokens.add(token);\r\n            } else             {\r\n                burstToken(token, stopAtNonOption);\r\n            }\r\n        } else if (stopAtNonOption) {\r\n            process(token);\r\n        } else {\r\n            tokens.add(token);\r\n        }\r\n        gobble(iter);\r\n    }\r\n    return (String[]) tokens.toArray(new String[tokens.size()]);\r\n}","lc":0.9090909091,"pi":0.7464114833,"ma":1.0,"nbd":2.0,"ml":1.0,"d":0.5892857143,"mi":-0.6070472163,"fo":1.8333333333,"r":-0.0263157895,"e":0.9853564081}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4420_d645112f","label":1,"code":"@Override\r\npublic NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\r\n    Builder builder = FileStore.builder(new File(dir, \"segmentstore\"));\r\n    if (blobStore != null) {\r\n        builder.withBlobStore(blobStore);\r\n    }\r\n    builder.withMaxFileSize(256).withMemoryMapping(mmap);\r\n    FileStore fs = builder.build();\r\n    closer.register(asCloseable(fs));\r\n    return SegmentNodeStore.builder(fs).build();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\r\n    Builder builder = FileStore.builder(new File(dir, \"segmentstore\"));\r\n    if (blobStore != null) {\r\n        builder.withBlobStore(blobStore);\r\n    }\r\n    builder.withMaxFileSize(256).withMemoryMapping(mmap);\r\n    FileStore fs = builder.build();\r\n    closer.register(asCloseable(fs));\r\n    return SegmentNodeStore.builder(fs).build();\r\n}","lc":-0.1363636364,"pi":-0.3301435407,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0753968254,"mi":0.0951374207,"fo":0.25,"r":0.0,"e":-0.0299833451}
{"project_name":"Math","project_version":"66","label":1,"code":"\/**\r\n * Perform the optimization.\r\n *\r\n * @return the optimum.\r\n *\/\r\nprotected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    throw new UnsupportedOperationException();\r\n}","code_comment":"\/**\r\n * Perform the optimization.\r\n *\r\n * @return the optimum.\r\n *\/\r\n","code_no_comment":"protected double doOptimize() throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    throw new UnsupportedOperationException();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.103453136,"fo":-0.5,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-3616_912a565f","label":1,"code":"private void validateRepositories(SettingsProblemCollector problems, List<Repository> repositories, String prefix) {\r\n    for (Repository repository : repositories) {\r\n        validateStringNotEmpty(problems, prefix + \".id\", repository.getId());\r\n        validateStringNotEmpty(problems, prefix + \".url\", repository.getUrl());\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void validateRepositories(SettingsProblemCollector problems, List<Repository> repositories, String prefix) {\r\n    for (Repository repository : repositories) {\r\n        validateStringNotEmpty(problems, prefix + \".id\", repository.getId());\r\n        validateStringNotEmpty(problems, prefix + \".url\", repository.getUrl());\r\n    }\r\n}","lc":-0.3636363636,"pi":0.1339712919,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4655391121,"fo":-0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"public update_resultTupleScheme getScheme() {\r\n    return new update_resultTupleScheme();\r\n}","code_comment":null,"code_no_comment":"public update_resultTupleScheme getScheme() {\r\n    return new update_resultTupleScheme();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1987315011,"fo":-0.5,"r":1.9736842105,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4398_f88721fd","label":1,"code":"\/**\r\n *  Parses the given URL string.\r\n *\r\n *  @param url\r\n *             absolute or relative url with query string\r\n *  @param charset\r\n *  @return Url object\r\n *\/\r\npublic static Url parse(String url, Charset charset) {\r\n    Args.notNull(url, \"url\");\r\n    final Url result = new Url(charset);\r\n    \/\/ the url object resolved the charset, use that\r\n    charset = result.getCharset();\r\n    \/\/ extract query string part\r\n    final String queryString;\r\n    final String absoluteUrl;\r\n    final int queryAt = url.indexOf('?');\r\n    if (queryAt == -1) {\r\n        queryString = \"\";\r\n        absoluteUrl = url;\r\n    } else {\r\n        absoluteUrl = url.substring(0, queryAt);\r\n        queryString = url.substring(queryAt + 1);\r\n    }\r\n    \/\/ get absolute \/ relative part of url\r\n    String relativeUrl;\r\n    \/\/ absolute urls contain a scheme:\/\/\r\n    final int protocolAt = absoluteUrl.indexOf(\":\/\/\");\r\n    if (protocolAt != -1) {\r\n        result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\r\n        final String afterProto = absoluteUrl.substring(protocolAt + 3);\r\n        final String hostAndPort;\r\n        final int relativeAt = afterProto.indexOf('\/');\r\n        if (relativeAt == -1) {\r\n            relativeUrl = \"\";\r\n            hostAndPort = afterProto;\r\n        } else {\r\n            relativeUrl = afterProto.substring(relativeAt);\r\n            hostAndPort = afterProto.substring(0, relativeAt);\r\n        }\r\n        final int portAt = hostAndPort.lastIndexOf(':');\r\n        if (portAt == -1) {\r\n            result.host = hostAndPort;\r\n            result.port = getDefaultPortForProtocol(result.protocol);\r\n        } else {\r\n            result.host = hostAndPort.substring(0, portAt);\r\n            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\r\n        }\r\n        if (relativeAt < 0) {\r\n            relativeUrl = \"\/\";\r\n        }\r\n    } else {\r\n        relativeUrl = absoluteUrl;\r\n    }\r\n    if (relativeUrl.length() > 0) {\r\n        boolean removeLast = false;\r\n        if (relativeUrl.endsWith(\"\/\")) {\r\n            \/\/ we need to append something and remove it after splitting\r\n            \/\/ because otherwise the\r\n            \/\/ trailing slashes will be lost\r\n            relativeUrl += \"\/x\";\r\n            removeLast = true;\r\n        }\r\n        String[] segmentArray = Strings.split(relativeUrl, '\/');\r\n        if (removeLast) {\r\n            segmentArray[segmentArray.length - 1] = null;\r\n        }\r\n        for (String s : segmentArray) {\r\n            if (s != null) {\r\n                result.segments.add(decodeSegment(s, charset));\r\n            }\r\n        }\r\n    }\r\n    if (queryString.length() > 0) {\r\n        String[] queryArray = Strings.split(queryString, '&');\r\n        for (String s : queryArray) {\r\n            result.parameters.add(parseQueryParameter(s, charset));\r\n        }\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n *  Parses the given URL string.\r\n *\r\n *  @param url\r\n *             absolute or relative url with query string\r\n *  @param charset\r\n *  @return Url object\r\n *\/\r\n","code_no_comment":"public static Url parse(String url, Charset charset) {\r\n    Args.notNull(url, \"url\");\r\n    final Url result = new Url(charset);\r\n        charset = result.getCharset();\r\n        final String queryString;\r\n    final String absoluteUrl;\r\n    final int queryAt = url.indexOf('?');\r\n    if (queryAt == -1) {\r\n        queryString = \"\";\r\n        absoluteUrl = url;\r\n    } else {\r\n        absoluteUrl = url.substring(0, queryAt);\r\n        queryString = url.substring(queryAt + 1);\r\n    }\r\n        String relativeUrl;\r\n        final int protocolAt = absoluteUrl.indexOf(\":\/\/\");\r\n    if (protocolAt != -1) {\r\n        result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\r\n        final String afterProto = absoluteUrl.substring(protocolAt + 3);\r\n        final String hostAndPort;\r\n        final int relativeAt = afterProto.indexOf('\/');\r\n        if (relativeAt == -1) {\r\n            relativeUrl = \"\";\r\n            hostAndPort = afterProto;\r\n        } else {\r\n            relativeUrl = afterProto.substring(relativeAt);\r\n            hostAndPort = afterProto.substring(0, relativeAt);\r\n        }\r\n        final int portAt = hostAndPort.lastIndexOf(':');\r\n        if (portAt == -1) {\r\n            result.host = hostAndPort;\r\n            result.port = getDefaultPortForProtocol(result.protocol);\r\n        } else {\r\n            result.host = hostAndPort.substring(0, portAt);\r\n            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\r\n        }\r\n        if (relativeAt < 0) {\r\n            relativeUrl = \"\/\";\r\n        }\r\n    } else {\r\n        relativeUrl = absoluteUrl;\r\n    }\r\n    if (relativeUrl.length() > 0) {\r\n        boolean removeLast = false;\r\n        if (relativeUrl.endsWith(\"\/\")) {\r\n                                                relativeUrl += \"\/x\";\r\n            removeLast = true;\r\n        }\r\n        String[] segmentArray = Strings.split(relativeUrl, '\/');\r\n        if (removeLast) {\r\n            segmentArray[segmentArray.length - 1] = null;\r\n        }\r\n        for (String s : segmentArray) {\r\n            if (s != null) {\r\n                result.segments.add(decodeSegment(s, charset));\r\n            }\r\n        }\r\n    }\r\n    if (queryString.length() > 0) {\r\n        String[] queryArray = Strings.split(queryString, '&');\r\n        for (String s : queryArray) {\r\n            result.parameters.add(parseQueryParameter(s, charset));\r\n        }\r\n    }\r\n    return result;\r\n}","lc":2.3636363636,"pi":0.1578947368,"ma":1.8,"nbd":0.5,"ml":1.1666666667,"d":2.0158730159,"mi":-1.0730091614,"fo":1.6666666667,"r":-0.0263157895,"e":7.1271404943}
{"project_name":"Closure","project_version":"169","label":2,"code":"\/**\r\n * Try to get the sup\/inf of two functions by looking at the\r\n * piecewise components.\r\n *\/\r\nprivate FunctionType tryMergeFunctionPiecewise(FunctionType other, boolean leastSuper) {\r\n    Node newParamsNode = null;\r\n    if (call.hasEqualParameters(other.call, false)) {\r\n        newParamsNode = call.parameters;\r\n    } else {\r\n        \/\/ Someday, we should try to merge the individual params.\r\n        return null;\r\n    }\r\n    JSType newReturnType = leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType);\r\n    ObjectType newTypeOfThis = null;\r\n    if (isEquivalent(typeOfThis, other.typeOfThis)) {\r\n        newTypeOfThis = typeOfThis;\r\n    } else {\r\n        JSType maybeNewTypeOfThis = leastSuper ? typeOfThis.getLeastSupertype(other.typeOfThis) : typeOfThis.getGreatestSubtype(other.typeOfThis);\r\n        if (maybeNewTypeOfThis instanceof ObjectType) {\r\n            newTypeOfThis = (ObjectType) maybeNewTypeOfThis;\r\n        } else {\r\n            newTypeOfThis = leastSuper ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);\r\n        }\r\n    }\r\n    boolean newReturnTypeInferred = call.returnTypeInferred || other.call.returnTypeInferred;\r\n    return new FunctionType(registry, null, null, new ArrowType(registry, newParamsNode, newReturnType, newReturnTypeInferred), newTypeOfThis, null, false, false);\r\n}","code_comment":"\/**\r\n * Try to get the sup\/inf of two functions by looking at the\r\n * piecewise components.\r\n *\/\r\n","code_no_comment":"private FunctionType tryMergeFunctionPiecewise(FunctionType other, boolean leastSuper) {\r\n    Node newParamsNode = null;\r\n    if (call.hasEqualParameters(other.call, false)) {\r\n        newParamsNode = call.parameters;\r\n    } else {\r\n                return null;\r\n    }\r\n    JSType newReturnType = leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType);\r\n    ObjectType newTypeOfThis = null;\r\n    if (isEquivalent(typeOfThis, other.typeOfThis)) {\r\n        newTypeOfThis = typeOfThis;\r\n    } else {\r\n        JSType maybeNewTypeOfThis = leastSuper ? typeOfThis.getLeastSupertype(other.typeOfThis) : typeOfThis.getGreatestSubtype(other.typeOfThis);\r\n        if (maybeNewTypeOfThis instanceof ObjectType) {\r\n            newTypeOfThis = (ObjectType) maybeNewTypeOfThis;\r\n        } else {\r\n            newTypeOfThis = leastSuper ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);\r\n        }\r\n    }\r\n    boolean newReturnTypeInferred = call.returnTypeInferred || other.call.returnTypeInferred;\r\n    return new FunctionType(registry, null, null, new ArrowType(registry, newParamsNode, newReturnType, newReturnTypeInferred), newTypeOfThis, null, false, false);\r\n}","lc":0.3636363636,"pi":0.0574162679,"ma":0.6,"nbd":0.0,"ml":0.6666666667,"d":0.2103174603,"mi":-0.385764623,"fo":0.1666666667,"r":-0.0263157895,"e":0.4856508935}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2082_0cfa43d7","label":3,"code":"\/**\r\n *  This method builds up a nested output which encapsulates all the\r\n *  chained operators and their network output. The result of this recursive\r\n *  call will be passed as output to the first operator in the chain.\r\n *\r\n *  @param chainedTaskConfig\r\n *  \t\tThe configuration of the starting operator of the chain, we\r\n *  \t\tuse this paramater to recursively build the whole chain\r\n *  @return Returns the output for the chain starting from the given\r\n *  config\r\n *\/\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nprivate <X> Output<X> createChainedCollector(StreamConfig chainedTaskConfig) {\r\n    \/\/ We create a wrapper that will encapsulate the chained operators and\r\n    \/\/ network outputs\r\n    OutputSelectorWrapper<?> outputSelectorWrapper = chainedTaskConfig.getOutputSelectorWrapper(cl);\r\n    CollectorWrapper wrapper = new CollectorWrapper(outputSelectorWrapper);\r\n    \/\/ Create collectors for the network outputs\r\n    for (StreamEdge outputEdge : chainedTaskConfig.getNonChainedOutputs(cl)) {\r\n        Collector<?> outCollector = outputMap.get(outputEdge);\r\n        wrapper.addCollector(outCollector, outputEdge);\r\n    }\r\n    \/\/ Create collectors for the chained outputs\r\n    for (StreamEdge outputEdge : chainedTaskConfig.getChainedOutputs(cl)) {\r\n        Integer output = outputEdge.getTargetID();\r\n        Collector<?> outCollector = createChainedCollector(chainedConfigs.get(output));\r\n        wrapper.addCollector(outCollector, outputEdge);\r\n    }\r\n    if (chainedTaskConfig.isChainStart()) {\r\n        \/\/ return the wrapper\r\n        return (Output<X>) wrapper;\r\n    } else {\r\n        \/\/ The current task is a part of the chain so we get the chainable\r\n        \/\/ operator which will be returned and set it up using the wrapper\r\n        OneInputStreamOperator chainableOperator = chainedTaskConfig.getStreamOperator(vertex.getUserCodeClassLoader());\r\n        chainableOperator.setup(wrapper, vertex.context);\r\n        chainedOperators.add(chainableOperator);\r\n        return new OperatorCollector<X>(chainableOperator);\r\n    }\r\n}","code_comment":"\/**\r\n *  This method builds up a nested output which encapsulates all the\r\n *  chained operators and their network output. The result of this recursive\r\n *  call will be passed as output to the first operator in the chain.\r\n *\r\n *  @param chainedTaskConfig\r\n *  \t\tThe configuration of the starting operator of the chain, we\r\n *  \t\tuse this paramater to recursively build the whole chain\r\n *  @return Returns the output for the chain starting from the given\r\n *  config\r\n *\/\r\n","code_no_comment":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nprivate <X> Output<X> createChainedCollector(StreamConfig chainedTaskConfig) {\r\n            OutputSelectorWrapper<?> outputSelectorWrapper = chainedTaskConfig.getOutputSelectorWrapper(cl);\r\n    CollectorWrapper wrapper = new CollectorWrapper(outputSelectorWrapper);\r\n        for (StreamEdge outputEdge : chainedTaskConfig.getNonChainedOutputs(cl)) {\r\n        Collector<?> outCollector = outputMap.get(outputEdge);\r\n        wrapper.addCollector(outCollector, outputEdge);\r\n    }\r\n        for (StreamEdge outputEdge : chainedTaskConfig.getChainedOutputs(cl)) {\r\n        Integer output = outputEdge.getTargetID();\r\n        Collector<?> outCollector = createChainedCollector(chainedConfigs.get(output));\r\n        wrapper.addCollector(outCollector, outputEdge);\r\n    }\r\n    if (chainedTaskConfig.isChainStart()) {\r\n                return (Output<X>) wrapper;\r\n    } else {\r\n                        OneInputStreamOperator chainableOperator = chainedTaskConfig.getStreamOperator(vertex.getUserCodeClassLoader());\r\n        chainableOperator.setup(wrapper, vertex.context);\r\n        chainedOperators.add(chainableOperator);\r\n        return new OperatorCollector<X>(chainableOperator);\r\n    }\r\n}","lc":0.3636363636,"pi":-0.0909090909,"ma":0.0,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":-0.3471458774,"fo":0.6666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2520_a64151e6","label":0,"code":"private String makeRelative(String path, int expectedLen) {\r\n    String relPath = path;\r\n    if (relPath.startsWith(\"..\/\"))\r\n        relPath = relPath.substring(3);\r\n    while (relPath.endsWith(\"\/\")) relPath = relPath.substring(0, relPath.length() - 1);\r\n    while (relPath.startsWith(\"\/\")) relPath = relPath.substring(1);\r\n    String[] tokens = relPath.split(\"\/\");\r\n    \/\/ handle paths like a\/\/b\/\/\/c\r\n    boolean containsEmpty = false;\r\n    for (String token : tokens) {\r\n        if (token.equals(\"\")) {\r\n            containsEmpty = true;\r\n            break;\r\n        }\r\n    }\r\n    if (containsEmpty) {\r\n        ArrayList<String> tmp = new ArrayList<String>();\r\n        for (String token : tokens) {\r\n            if (!token.equals(\"\")) {\r\n                tmp.add(token);\r\n            }\r\n        }\r\n        tokens = tmp.toArray(new String[tmp.size()]);\r\n    }\r\n    if (tokens.length > 3) {\r\n        if (!path.contains(\":\"))\r\n            throw new IllegalArgumentException(path);\r\n        if (tokens[tokens.length - 4].equals(ServerConstants.TABLE_DIR) && (expectedLen == 0 || expectedLen == 3)) {\r\n            relPath = tokens[tokens.length - 3] + \"\/\" + tokens[tokens.length - 2] + \"\/\" + tokens[tokens.length - 1];\r\n        } else if (tokens[tokens.length - 3].equals(ServerConstants.TABLE_DIR) && (expectedLen == 0 || expectedLen == 2)) {\r\n            relPath = tokens[tokens.length - 2] + \"\/\" + tokens[tokens.length - 1];\r\n        } else {\r\n            throw new IllegalArgumentException(path);\r\n        }\r\n    } else if (tokens.length == 3 && (expectedLen == 0 || expectedLen == 3)) {\r\n        relPath = tokens[0] + \"\/\" + tokens[1] + \"\/\" + tokens[2];\r\n    } else if (tokens.length == 2 && (expectedLen == 0 || expectedLen == 2)) {\r\n        relPath = tokens[0] + \"\/\" + tokens[1];\r\n    } else {\r\n        throw new IllegalArgumentException(path);\r\n    }\r\n    return relPath;\r\n}","code_comment":null,"code_no_comment":"private String makeRelative(String path, int expectedLen) {\r\n    String relPath = path;\r\n    if (relPath.startsWith(\"..\/\"))\r\n        relPath = relPath.substring(3);\r\n    while (relPath.endsWith(\"\/\")) relPath = relPath.substring(0, relPath.length() - 1);\r\n    while (relPath.startsWith(\"\/\")) relPath = relPath.substring(1);\r\n    String[] tokens = relPath.split(\"\/\");\r\n        boolean containsEmpty = false;\r\n    for (String token : tokens) {\r\n        if (token.equals(\"\")) {\r\n            containsEmpty = true;\r\n            break;\r\n        }\r\n    }\r\n    if (containsEmpty) {\r\n        ArrayList<String> tmp = new ArrayList<String>();\r\n        for (String token : tokens) {\r\n            if (!token.equals(\"\")) {\r\n                tmp.add(token);\r\n            }\r\n        }\r\n        tokens = tmp.toArray(new String[tmp.size()]);\r\n    }\r\n    if (tokens.length > 3) {\r\n        if (!path.contains(\":\"))\r\n            throw new IllegalArgumentException(path);\r\n        if (tokens[tokens.length - 4].equals(ServerConstants.TABLE_DIR) && (expectedLen == 0 || expectedLen == 3)) {\r\n            relPath = tokens[tokens.length - 3] + \"\/\" + tokens[tokens.length - 2] + \"\/\" + tokens[tokens.length - 1];\r\n        } else if (tokens[tokens.length - 3].equals(ServerConstants.TABLE_DIR) && (expectedLen == 0 || expectedLen == 2)) {\r\n            relPath = tokens[tokens.length - 2] + \"\/\" + tokens[tokens.length - 1];\r\n        } else {\r\n            throw new IllegalArgumentException(path);\r\n        }\r\n    } else if (tokens.length == 3 && (expectedLen == 0 || expectedLen == 3)) {\r\n        relPath = tokens[0] + \"\/\" + tokens[1] + \"\/\" + tokens[2];\r\n    } else if (tokens.length == 2 && (expectedLen == 0 || expectedLen == 2)) {\r\n        relPath = tokens[0] + \"\/\" + tokens[1];\r\n    } else {\r\n        throw new IllegalArgumentException(path);\r\n    }\r\n    return relPath;\r\n}","lc":1.2727272727,"pi":0.2822966507,"ma":3.0,"nbd":0.5,"ml":2.0833333333,"d":3.2182539683,"mi":-0.8799154334,"fo":0.8333333333,"r":-0.0263157895,"e":9.0525843836}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4383_0f3d4d24","label":1,"code":"private boolean validateEnum(String fieldName, ModelProblemCollector problems, boolean warning, String string, String sourceHint, String... validValues) {\r\n    if (string == null || string.length() <= 0) {\r\n        return true;\r\n    }\r\n    List<String> values = Arrays.asList(validValues);\r\n    if (values.contains(string)) {\r\n        return true;\r\n    }\r\n    if (sourceHint != null) {\r\n        addViolation(problems, warning, \"'\" + fieldName + \"' must be one of \" + values + \" for \" + sourceHint);\r\n    } else {\r\n        addViolation(problems, warning, \"'\" + fieldName + \"' must be one of \" + values);\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"private boolean validateEnum(String fieldName, ModelProblemCollector problems, boolean warning, String string, String sourceHint, String... validValues) {\r\n    if (string == null || string.length() <= 0) {\r\n        return true;\r\n    }\r\n    List<String> values = Arrays.asList(validValues);\r\n    if (values.contains(string)) {\r\n        return true;\r\n    }\r\n    if (sourceHint != null) {\r\n        addViolation(problems, warning, \"'\" + fieldName + \"' must be one of \" + values + \" for \" + sourceHint);\r\n    } else {\r\n        addViolation(problems, warning, \"'\" + fieldName + \"' must be one of \" + values);\r\n    }\r\n    return false;\r\n}","lc":0.0454545455,"pi":-0.2488038278,"ma":0.0,"nbd":-0.5,"ml":0.25,"d":0.8253968254,"mi":-0.1055673009,"fo":-0.0833333333,"r":0.0,"e":0.5837450943}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4173_84bbbf68","label":1,"code":"\/**\r\n *  Convenience method for setting next page to be rendered.\r\n *\r\n *  @param pageClass\r\n *  @param parameters\r\n *\/\r\npublic void setResponsePage(Class<? extends IRequestablePage> pageClass, PageParameters parameters) {\r\n    IPageProvider provider = new PageProvider(pageClass, parameters);\r\n    scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(provider, RenderPageRequestHandler.RedirectPolicy.AUTO_REDIRECT));\r\n}","code_comment":"\/**\r\n *  Convenience method for setting next page to be rendered.\r\n *\r\n *  @param pageClass\r\n *  @param parameters\r\n *\/\r\n","code_no_comment":"public void setResponsePage(Class<? extends IRequestablePage> pageClass, PageParameters parameters) {\r\n    IPageProvider provider = new PageProvider(pageClass, parameters);\r\n    scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(provider, RenderPageRequestHandler.RedirectPolicy.AUTO_REDIRECT));\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7065539112,"fo":-0.4166666667,"r":2.1578947368,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5418_e350f19e","label":1,"code":"@Override\r\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\npublic void onComponentTag(Component component, ComponentTag tag) {\r\n    super.onComponentTag(component, tag);\r\n    BeanValidationContext config = BeanValidationConfiguration.get();\r\n    Validator validator = config.getValidator();\r\n    Property property = getProperty();\r\n    \/\/ find any tag modifiers that apply to the constraints of the property being validated\r\n    \/\/ and allow them to modify the component tag\r\n    Iterator<ConstraintDescriptor<?>> it = new ConstraintIterator(validator, property, getGroups());\r\n    while (it.hasNext()) {\r\n        ConstraintDescriptor<?> desc = it.next();\r\n        ITagModifier modifier = config.getTagModifier(desc.getAnnotation().annotationType());\r\n        if (modifier != null) {\r\n            modifier.modify((FormComponent<?>) component, tag, desc.getAnnotation());\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\npublic void onComponentTag(Component component, ComponentTag tag) {\r\n    super.onComponentTag(component, tag);\r\n    BeanValidationContext config = BeanValidationConfiguration.get();\r\n    Validator validator = config.getValidator();\r\n    Property property = getProperty();\r\n            Iterator<ConstraintDescriptor<?>> it = new ConstraintIterator(validator, property, getGroups());\r\n    while (it.hasNext()) {\r\n        ConstraintDescriptor<?> desc = it.next();\r\n        ITagModifier modifier = config.getTagModifier(desc.getAnnotation().annotationType());\r\n        if (modifier != null) {\r\n            modifier.modify((FormComponent<?>) component, tag, desc.getAnnotation());\r\n        }\r\n    }\r\n}","lc":0.0909090909,"pi":0.2105263158,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0734126984,"mi":-0.1512332629,"fo":0.5,"r":-0.0263157895,"e":0.050928119}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"\/**\r\n * Search for a given set of values.\r\n *\r\n * @param filter the filter (used for logging)\r\n * @param indexName the name of the index (for logging)\r\n * @param indexMeta the index metadata node (may not be null)\r\n * @param values values to look for (null to check for property existence)\r\n * @return an iterator of paths\r\n *\/\r\nIterable<String> query(Filter filter, String indexName, NodeState indexMeta, Iterable<String> values);","code_comment":"\/**\r\n * Search for a given set of values.\r\n *\r\n * @param filter the filter (used for logging)\r\n * @param indexName the name of the index (for logging)\r\n * @param indexMeta the index metadata node (may not be null)\r\n * @param values values to look for (null to check for property existence)\r\n * @return an iterator of paths\r\n *\/\r\n","code_no_comment":"Iterable<String> query(Filter filter, String indexName, NodeState indexMeta, Iterable<String> values);","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.4191684285,"fo":-0.5,"r":1.8157894737,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3511_5138a1e2","label":1,"code":"private void compress(@Nonnull Set<UUID> removed) {\r\n    if (recent.isEmpty() && removed.isEmpty()) {\r\n        return;\r\n    }\r\n    SegmentWriter writer = null;\r\n    Map<String, RecordId> segmentIdMap = newHashMap();\r\n    for (Entry<UUID, RecordIdMap> recentEntry : recent.entrySet()) {\r\n        UUID uuid = recentEntry.getKey();\r\n        RecordIdMap newSegment = recentEntry.getValue();\r\n        if (removed.contains(uuid)) {\r\n            continue;\r\n        }\r\n        MapRecord base;\r\n        MapEntry baseEntry = entries == null ? null : entries.getEntry(uuid.toString());\r\n        base = baseEntry == null ? null : new MapRecord(baseEntry.getValue());\r\n        if (writer == null) {\r\n            writer = store.createSegmentWriter();\r\n        }\r\n        Map<String, RecordId> offsetMap = newHashMap();\r\n        for (int k = 0; k < newSegment.size(); k++) {\r\n            offsetMap.put(String.valueOf(newSegment.getKey(k)), writer.writeString(newSegment.getRecordId(k).toString10()));\r\n        }\r\n        RecordId newEntryId = writer.writeMap(base, offsetMap).getRecordId();\r\n        segmentIdMap.put(uuid.toString(), newEntryId);\r\n        recordCount += offsetMap.size();\r\n    }\r\n    if (entries != null) {\r\n        for (UUID uuid : removed) {\r\n            MapEntry toRemove = entries.getEntry(uuid.toString());\r\n            if (toRemove != null) {\r\n                segmentIdMap.put(uuid.toString(), null);\r\n                recordCount -= new MapRecord(toRemove.getValue()).size();\r\n            }\r\n        }\r\n    }\r\n    if (!segmentIdMap.isEmpty()) {\r\n        if (writer == null) {\r\n            writer = store.createSegmentWriter();\r\n        }\r\n        RecordId previousBaseId = entries == null ? null : entries.getRecordId();\r\n        entries = writer.writeMap(entries, segmentIdMap);\r\n        entries.getSegment().getSegmentId().pin();\r\n        String mapInfo = PERSISTED_COMPACTION_MAP + '{' + \"id=\" + entries.getRecordId() + \", baseId=\" + previousBaseId + '}';\r\n        writer.writeString(mapInfo);\r\n        writer.flush();\r\n        recent.clear();\r\n    }\r\n    if (recordCount == 0) {\r\n        entries = null;\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void compress(@Nonnull Set<UUID> removed) {\r\n    if (recent.isEmpty() && removed.isEmpty()) {\r\n        return;\r\n    }\r\n    SegmentWriter writer = null;\r\n    Map<String, RecordId> segmentIdMap = newHashMap();\r\n    for (Entry<UUID, RecordIdMap> recentEntry : recent.entrySet()) {\r\n        UUID uuid = recentEntry.getKey();\r\n        RecordIdMap newSegment = recentEntry.getValue();\r\n        if (removed.contains(uuid)) {\r\n            continue;\r\n        }\r\n        MapRecord base;\r\n        MapEntry baseEntry = entries == null ? null : entries.getEntry(uuid.toString());\r\n        base = baseEntry == null ? null : new MapRecord(baseEntry.getValue());\r\n        if (writer == null) {\r\n            writer = store.createSegmentWriter();\r\n        }\r\n        Map<String, RecordId> offsetMap = newHashMap();\r\n        for (int k = 0; k < newSegment.size(); k++) {\r\n            offsetMap.put(String.valueOf(newSegment.getKey(k)), writer.writeString(newSegment.getRecordId(k).toString10()));\r\n        }\r\n        RecordId newEntryId = writer.writeMap(base, offsetMap).getRecordId();\r\n        segmentIdMap.put(uuid.toString(), newEntryId);\r\n        recordCount += offsetMap.size();\r\n    }\r\n    if (entries != null) {\r\n        for (UUID uuid : removed) {\r\n            MapEntry toRemove = entries.getEntry(uuid.toString());\r\n            if (toRemove != null) {\r\n                segmentIdMap.put(uuid.toString(), null);\r\n                recordCount -= new MapRecord(toRemove.getValue()).size();\r\n            }\r\n        }\r\n    }\r\n    if (!segmentIdMap.isEmpty()) {\r\n        if (writer == null) {\r\n            writer = store.createSegmentWriter();\r\n        }\r\n        RecordId previousBaseId = entries == null ? null : entries.getRecordId();\r\n        entries = writer.writeMap(entries, segmentIdMap);\r\n        entries.getSegment().getSegmentId().pin();\r\n        String mapInfo = PERSISTED_COMPACTION_MAP + '{' + \"id=\" + entries.getRecordId() + \", baseId=\" + previousBaseId + '}';\r\n        writer.writeString(mapInfo);\r\n        writer.flush();\r\n        recent.clear();\r\n    }\r\n    if (recordCount == 0) {\r\n        entries = null;\r\n    }\r\n}","lc":1.6818181818,"pi":0.1435406699,"ma":2.4,"nbd":0.5,"ml":1.6666666667,"d":2.3928571429,"mi":-0.9599718111,"fo":2.9166666667,"r":-0.0263157895,"e":7.4696887444}
{"project_name":"Time","project_version":"13","label":3,"code":"public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\r\n    long valueLong = getFieldValue(period);\r\n    if (valueLong == Long.MAX_VALUE) {\r\n        return 0;\r\n    }\r\n    int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);\r\n    if (iFieldType >= SECONDS_MILLIS) {\r\n        \/\/ valueLong contains the seconds and millis fields\r\n        \/\/ the minimum output is 0.000, which is 4 or 5 digits with a negative\r\n        sum = Math.max(sum, 4);\r\n        \/\/ plus one for the decimal point\r\n        sum++;\r\n        if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {\r\n            \/\/ remove three digits and decimal point\r\n            sum -= 4;\r\n        }\r\n        \/\/ reset valueLong to refer to the seconds part for the prefic\/suffix calculation\r\n        valueLong = valueLong \/ DateTimeConstants.MILLIS_PER_SECOND;\r\n    }\r\n    int value = (int) valueLong;\r\n    if (iPrefix != null) {\r\n        sum += iPrefix.calculatePrintedLength(value);\r\n    }\r\n    if (iSuffix != null) {\r\n        sum += iSuffix.calculatePrintedLength(value);\r\n    }\r\n    return sum;\r\n}","code_comment":null,"code_no_comment":"public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\r\n    long valueLong = getFieldValue(period);\r\n    if (valueLong == Long.MAX_VALUE) {\r\n        return 0;\r\n    }\r\n    int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);\r\n    if (iFieldType >= SECONDS_MILLIS) {\r\n                        sum = Math.max(sum, 4);\r\n                sum++;\r\n        if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {\r\n                        sum -= 4;\r\n        }\r\n                valueLong = valueLong \/ DateTimeConstants.MILLIS_PER_SECOND;\r\n    }\r\n    int value = (int) valueLong;\r\n    if (iPrefix != null) {\r\n        sum += iPrefix.calculatePrintedLength(value);\r\n    }\r\n    if (iSuffix != null) {\r\n        sum += iSuffix.calculatePrintedLength(value);\r\n    }\r\n    return sum;\r\n}","lc":0.4090909091,"pi":-0.0956937799,"ma":0.4,"nbd":0.0,"ml":0.5,"d":1.6547619048,"mi":-0.3691331924,"fo":0.0833333333,"r":0.0,"e":1.6842147727}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5783_7b8b6767","label":1,"code":"@Override\r\nprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {\r\n    super.updateAjaxAttributes(attributes);\r\n    attributes.setEventNames(event);\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {\r\n    super.updateAjaxAttributes(attributes);\r\n    attributes.setEventNames(event);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.747427766,"fo":-0.3333333333,"r":0.4473684211,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1269_a94ff90a","label":1,"code":"\/**\r\n * Internal helper method for exponential function.\r\n * @param x original argument of the exponential function\r\n * @param extra extra bits of precision on input (To Be Confirmed)\r\n * @param hiPrec extra bits of precision on output (To Be Confirmed)\r\n * @return exp(x)\r\n *\/\r\nprivate static double exp(double x, double extra, double[] hiPrec) {\r\n    double intPartA;\r\n    double intPartB;\r\n    int intVal = (int) x;\r\n    \/* Lookup exp(floor(x)).\r\n         * intPartA will have the upper 22 bits, intPartB will have the lower\r\n         * 52 bits.\r\n         *\/\r\n    if (x < 0.0) {\r\n        \/\/ may be affected by a JIT bug. Subsequent comparisons can safely use intVal\r\n        if (x < -746d) {\r\n            if (hiPrec != null) {\r\n                hiPrec[0] = 0.0;\r\n                hiPrec[1] = 0.0;\r\n            }\r\n            return 0.0;\r\n        }\r\n        if (intVal < -709) {\r\n            \/* This will produce a subnormal output *\/\r\n            final double result = exp(x + 40.19140625, extra, hiPrec) \/ 285040095144011776.0;\r\n            if (hiPrec != null) {\r\n                hiPrec[0] \/= 285040095144011776.0;\r\n                hiPrec[1] \/= 285040095144011776.0;\r\n            }\r\n            return result;\r\n        }\r\n        if (intVal == -709) {\r\n            \/* exp(1.494140625) is nearly a machine number... *\/\r\n            final double result = exp(x + 1.494140625, extra, hiPrec) \/ 4.455505956692756620;\r\n            if (hiPrec != null) {\r\n                hiPrec[0] \/= 4.455505956692756620;\r\n                hiPrec[1] \/= 4.455505956692756620;\r\n            }\r\n            return result;\r\n        }\r\n        intVal--;\r\n    } else {\r\n        if (intVal > 709) {\r\n            if (hiPrec != null) {\r\n                hiPrec[0] = Double.POSITIVE_INFINITY;\r\n                hiPrec[1] = 0.0;\r\n            }\r\n            return Double.POSITIVE_INFINITY;\r\n        }\r\n    }\r\n    intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX + intVal];\r\n    intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX + intVal];\r\n    \/* Get the fractional part of x, find the greatest multiple of 2^-10 less than\r\n         * x and look up the exp function of it.\r\n         * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\r\n         *\/\r\n    final int intFrac = (int) ((x - intVal) * 1024.0);\r\n    final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\r\n    final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\r\n    \/* epsilon is the difference in x from the nearest multiple of 2^-10.  It\r\n         * has a value in the range 0 <= epsilon < 2^-10.\r\n         * Do the subtraction from x as the last step to avoid possible loss of precision.\r\n         *\/\r\n    final double epsilon = x - (intVal + intFrac \/ 1024.0);\r\n    \/* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\r\n       full double precision (52 bits).  Since z < 2^-10, we will have\r\n       62 bits of precision when combined with the constant 1.  This will be\r\n       used in the last addition below to get proper rounding. *\/\r\n    \/* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\r\n       is less than 0.5 ULP *\/\r\n    double z = 0.04168701738764507;\r\n    z = z * epsilon + 0.1666666505023083;\r\n    z = z * epsilon + 0.5000000000042687;\r\n    z = z * epsilon + 1.0;\r\n    z = z * epsilon + -3.940510424527919E-20;\r\n    \/* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\r\n       expansion.\r\n       tempA is exact since intPartA and intPartB only have 22 bits each.\r\n       tempB will have 52 bits of precision.\r\n         *\/\r\n    double tempA = intPartA * fracPartA;\r\n    double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\r\n    \/* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\r\n       important.  For accuracy add by increasing size.  tempA is exact and\r\n       much larger than the others.  If there are extra bits specified from the\r\n       pow() function, use them. *\/\r\n    final double tempC = tempB + tempA;\r\n    final double result;\r\n    if (extra != 0.0) {\r\n        result = tempC * extra * z + tempC * extra + tempC * z + tempB + tempA;\r\n    } else {\r\n        result = tempC * z + tempB + tempA;\r\n    }\r\n    if (hiPrec != null) {\r\n        \/\/ If requesting high precision\r\n        hiPrec[0] = tempA;\r\n        hiPrec[1] = tempC * extra * z + tempC * extra + tempC * z + tempB;\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n * Internal helper method for exponential function.\r\n * @param x original argument of the exponential function\r\n * @param extra extra bits of precision on input (To Be Confirmed)\r\n * @param hiPrec extra bits of precision on output (To Be Confirmed)\r\n * @return exp(x)\r\n *\/\r\n","code_no_comment":"private static double exp(double x, double extra, double[] hiPrec) {\r\n    double intPartA;\r\n    double intPartB;\r\n    int intVal = (int) x;\r\n        if (x < 0.0) {\r\n                if (x < -746d) {\r\n            if (hiPrec != null) {\r\n                hiPrec[0] = 0.0;\r\n                hiPrec[1] = 0.0;\r\n            }\r\n            return 0.0;\r\n        }\r\n        if (intVal < -709) {\r\n                        final double result = exp(x + 40.19140625, extra, hiPrec) \/ 285040095144011776.0;\r\n            if (hiPrec != null) {\r\n                hiPrec[0] \/= 285040095144011776.0;\r\n                hiPrec[1] \/= 285040095144011776.0;\r\n            }\r\n            return result;\r\n        }\r\n        if (intVal == -709) {\r\n                        final double result = exp(x + 1.494140625, extra, hiPrec) \/ 4.455505956692756620;\r\n            if (hiPrec != null) {\r\n                hiPrec[0] \/= 4.455505956692756620;\r\n                hiPrec[1] \/= 4.455505956692756620;\r\n            }\r\n            return result;\r\n        }\r\n        intVal--;\r\n    } else {\r\n        if (intVal > 709) {\r\n            if (hiPrec != null) {\r\n                hiPrec[0] = Double.POSITIVE_INFINITY;\r\n                hiPrec[1] = 0.0;\r\n            }\r\n            return Double.POSITIVE_INFINITY;\r\n        }\r\n    }\r\n    intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX + intVal];\r\n    intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX + intVal];\r\n        final int intFrac = (int) ((x - intVal) * 1024.0);\r\n    final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\r\n    final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\r\n        final double epsilon = x - (intVal + intFrac \/ 1024.0);\r\n            double z = 0.04168701738764507;\r\n    z = z * epsilon + 0.1666666505023083;\r\n    z = z * epsilon + 0.5000000000042687;\r\n    z = z * epsilon + 1.0;\r\n    z = z * epsilon + -3.940510424527919E-20;\r\n        double tempA = intPartA * fracPartA;\r\n    double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\r\n        final double tempC = tempB + tempA;\r\n    final double result;\r\n    if (extra != 0.0) {\r\n        result = tempC * extra * z + tempC * extra + tempC * z + tempB + tempA;\r\n    } else {\r\n        result = tempC * z + tempB + tempA;\r\n    }\r\n    if (hiPrec != null) {\r\n                hiPrec[0] = tempA;\r\n        hiPrec[1] = tempC * extra * z + tempC * extra + tempC * z + tempB;\r\n    }\r\n    return result;\r\n}","lc":2.2727272727,"pi":0.7224880383,"ma":1.6,"nbd":0.5,"ml":0.8333333333,"d":3.5079365079,"mi":-1.0651162791,"fo":-0.3333333333,"r":-0.0263157895,"e":12.7782184494}
{"project_name":"Closure","project_version":"169","label":2,"code":"\/**\r\n * Two union types are equal if they have the same number of alternates\r\n * and all alternates are equal.\r\n *\/\r\nboolean checkUnionEquivalenceHelper(UnionType that, boolean tolerateUnknowns) {\r\n    if (!tolerateUnknowns && alternates.size() != that.alternates.size()) {\r\n        return false;\r\n    }\r\n    for (JSType alternate : that.alternates) {\r\n        if (!hasAlternate(alternate, tolerateUnknowns)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n * Two union types are equal if they have the same number of alternates\r\n * and all alternates are equal.\r\n *\/\r\n","code_no_comment":"boolean checkUnionEquivalenceHelper(UnionType that, boolean tolerateUnknowns) {\r\n    if (!tolerateUnknowns && alternates.size() != that.alternates.size()) {\r\n        return false;\r\n    }\r\n    for (JSType alternate : that.alternates) {\r\n        if (!hasAlternate(alternate, tolerateUnknowns)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}","lc":-0.1363636364,"pi":0.2200956938,"ma":0.0,"nbd":0.0,"ml":0.25,"d":-0.0178571429,"mi":0.1850599013,"fo":-0.25,"r":0.5526315789,"e":-0.083988866}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-9217_e7ac45b6","label":3,"code":"\/**\r\n * Strategy for validation of the uri when creating the endpoint.\r\n *\r\n * @param uri        the uri\r\n * @param path       the path - part after the scheme\r\n * @param parameters the parameters, an empty map if no parameters given\r\n * @throws ResolveEndpointFailedException should be thrown if the URI validation failed\r\n *\/\r\nprotected void validateURI(String uri, String path, Map<String, Object> parameters) {\r\n    \/\/ check for uri containing & but no ? marker\r\n    if (uri.contains(\"&\") && !uri.contains(\"?\")) {\r\n        throw new ResolveEndpointFailedException(uri, \"Invalid uri syntax: no ? marker however the uri \" + \"has & parameter separators. Check the uri if its missing a ? marker.\");\r\n    }\r\n    \/\/ check for uri containing double && markers without include by RAW\r\n    if (uri.contains(\"&&\")) {\r\n        Pattern pattern = Pattern.compile(\"RAW(.*&&.*)\");\r\n        Matcher m = pattern.matcher(uri);\r\n        \/\/ we should skip the RAW part\r\n        if (!m.find()) {\r\n            throw new ResolveEndpointFailedException(uri, \"Invalid uri syntax: Double && marker found. \" + \"Check the uri and remove the duplicate & marker.\");\r\n        }\r\n    }\r\n    \/\/ if we have a trailing & then that is invalid as well\r\n    if (uri.endsWith(\"&\")) {\r\n        throw new ResolveEndpointFailedException(uri, \"Invalid uri syntax: Trailing & marker found. \" + \"Check the uri and remove the trailing & marker.\");\r\n    }\r\n}","code_comment":"\/**\r\n * Strategy for validation of the uri when creating the endpoint.\r\n *\r\n * @param uri        the uri\r\n * @param path       the path - part after the scheme\r\n * @param parameters the parameters, an empty map if no parameters given\r\n * @throws ResolveEndpointFailedException should be thrown if the URI validation failed\r\n *\/\r\n","code_no_comment":"protected void validateURI(String uri, String path, Map<String, Object> parameters) {\r\n        if (uri.contains(\"&\") && !uri.contains(\"?\")) {\r\n        throw new ResolveEndpointFailedException(uri, \"Invalid uri syntax: no ? marker however the uri \" + \"has & parameter separators. Check the uri if its missing a ? marker.\");\r\n    }\r\n        if (uri.contains(\"&&\")) {\r\n        Pattern pattern = Pattern.compile(\"RAW(.*&&.*)\");\r\n        Matcher m = pattern.matcher(uri);\r\n                if (!m.find()) {\r\n            throw new ResolveEndpointFailedException(uri, \"Invalid uri syntax: Double && marker found. \" + \"Check the uri and remove the duplicate & marker.\");\r\n        }\r\n    }\r\n        if (uri.endsWith(\"&\")) {\r\n        throw new ResolveEndpointFailedException(uri, \"Invalid uri syntax: Trailing & marker found. \" + \"Check the uri and remove the trailing & marker.\");\r\n    }\r\n}","lc":0.0454545455,"pi":0.1004784689,"ma":0.8,"nbd":0.0,"ml":0.5,"d":0.2876984127,"mi":-0.1315010571,"fo":0.0833333333,"r":-0.0263157895,"e":0.2462082836}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-310_3f1e0fdc","label":1,"code":"\/**\r\n * Send the contents of the cyclic buffer as an e-mail message.\r\n * @param layout The layout for formatting the events.\r\n * @param appendEvent The event that triggered the send.\r\n *\/\r\npublic void sendEvents(final Layout<?> layout, final LogEvent appendEvent) {\r\n    if (message == null) {\r\n        connect();\r\n    }\r\n    try {\r\n        final LogEvent[] priorEvents = buffer.removeAll();\r\n        if (priorEvents == null || priorEvents.length == 0) {\r\n            \/\/ nothing to do, another thread already took all events\r\n            return;\r\n        }\r\n        final byte[] rawBytes = formatContentToBytes(priorEvents, appendEvent, layout);\r\n        final String contentType = layout.getContentType();\r\n        final String encoding = getEncoding(rawBytes, contentType);\r\n        final byte[] encodedBytes = encodeContentToBytes(rawBytes, encoding);\r\n        final InternetHeaders headers = getHeaders(contentType, encoding);\r\n        final MimeMultipart mp = getMimeMultipart(encodedBytes, headers);\r\n        sendMultipartMessage(message, mp);\r\n    } catch (final MessagingException e) {\r\n        LOGGER.error(\"Error occurred while sending e-mail notification.\", e);\r\n        throw new LoggingException(\"Error occurred while sending email\", e);\r\n    } catch (final IOException e) {\r\n        LOGGER.error(\"Error occurred while sending e-mail notification.\", e);\r\n        throw new LoggingException(\"Error occurred while sending email\", e);\r\n    } catch (final RuntimeException e) {\r\n        LOGGER.error(\"Error occurred while sending e-mail notification.\", e);\r\n        throw new LoggingException(\"Error occurred while sending email\", e);\r\n    }\r\n}","code_comment":"\/**\r\n * Send the contents of the cyclic buffer as an e-mail message.\r\n * @param layout The layout for formatting the events.\r\n * @param appendEvent The event that triggered the send.\r\n *\/\r\n","code_no_comment":"public void sendEvents(final Layout<?> layout, final LogEvent appendEvent) {\r\n    if (message == null) {\r\n        connect();\r\n    }\r\n    try {\r\n        final LogEvent[] priorEvents = buffer.removeAll();\r\n        if (priorEvents == null || priorEvents.length == 0) {\r\n                        return;\r\n        }\r\n        final byte[] rawBytes = formatContentToBytes(priorEvents, appendEvent, layout);\r\n        final String contentType = layout.getContentType();\r\n        final String encoding = getEncoding(rawBytes, contentType);\r\n        final byte[] encodedBytes = encodeContentToBytes(rawBytes, encoding);\r\n        final InternetHeaders headers = getHeaders(contentType, encoding);\r\n        final MimeMultipart mp = getMimeMultipart(encodedBytes, headers);\r\n        sendMultipartMessage(message, mp);\r\n    } catch (final MessagingException e) {\r\n        LOGGER.error(\"Error occurred while sending e-mail notification.\", e);\r\n        throw new LoggingException(\"Error occurred while sending email\", e);\r\n    } catch (final IOException e) {\r\n        LOGGER.error(\"Error occurred while sending e-mail notification.\", e);\r\n        throw new LoggingException(\"Error occurred while sending email\", e);\r\n    } catch (final RuntimeException e) {\r\n        LOGGER.error(\"Error occurred while sending e-mail notification.\", e);\r\n        throw new LoggingException(\"Error occurred while sending email\", e);\r\n    }\r\n}","lc":0.5909090909,"pi":-0.1387559809,"ma":1.0,"nbd":0.0,"ml":0.0833333333,"d":0.0218253968,"mi":-0.4875264271,"fo":0.5,"r":-0.0263157895,"e":0.2586884736}
{"project_name":"Closure","project_version":"41","label":2,"code":"\/**\r\n * Infer the parameter types from the list of argument names and\r\n * the doc info.\r\n *\/\r\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\r\n    if (argsParent == null) {\r\n        if (info == null) {\r\n            return this;\r\n        } else {\r\n            return inferParameterTypes(info);\r\n        }\r\n    }\r\n    \/\/ arguments\r\n    Node oldParameterType = null;\r\n    if (parametersNode != null) {\r\n        oldParameterType = parametersNode.getFirstChild();\r\n    }\r\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\r\n    boolean warnedAboutArgList = false;\r\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\r\n    boolean foundTemplateType = false;\r\n    boolean isVarArgs = false;\r\n    for (Node arg : argsParent.children()) {\r\n        String argumentName = arg.getString();\r\n        allJsDocParams.remove(argumentName);\r\n        \/\/ type from JSDocInfo\r\n        JSType parameterType = null;\r\n        boolean isOptionalParam = isOptionalParameter(arg, info);\r\n        isVarArgs = isVarArgsParameter(arg, info);\r\n        if (info != null && info.hasParameterType(argumentName)) {\r\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\r\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\r\n            parameterType = oldParameterType.getJSType();\r\n            isOptionalParam = oldParameterType.isOptionalArg();\r\n            isVarArgs = oldParameterType.isVarArgs();\r\n        } else {\r\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\r\n        }\r\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\r\n            if (foundTemplateType) {\r\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\r\n            }\r\n            foundTemplateType = true;\r\n        }\r\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\r\n        if (oldParameterType != null) {\r\n            oldParameterType = oldParameterType.getNext();\r\n        }\r\n    }\r\n    if (templateTypeName != null && !foundTemplateType) {\r\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\r\n    }\r\n    for (String inexistentName : allJsDocParams) {\r\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\r\n    }\r\n    parametersNode = builder.build();\r\n    return this;\r\n}","code_comment":"\/**\r\n * Infer the parameter types from the list of argument names and\r\n * the doc info.\r\n *\/\r\n","code_no_comment":"FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\r\n    if (argsParent == null) {\r\n        if (info == null) {\r\n            return this;\r\n        } else {\r\n            return inferParameterTypes(info);\r\n        }\r\n    }\r\n        Node oldParameterType = null;\r\n    if (parametersNode != null) {\r\n        oldParameterType = parametersNode.getFirstChild();\r\n    }\r\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\r\n    boolean warnedAboutArgList = false;\r\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\r\n    boolean foundTemplateType = false;\r\n    boolean isVarArgs = false;\r\n    for (Node arg : argsParent.children()) {\r\n        String argumentName = arg.getString();\r\n        allJsDocParams.remove(argumentName);\r\n                JSType parameterType = null;\r\n        boolean isOptionalParam = isOptionalParameter(arg, info);\r\n        isVarArgs = isVarArgsParameter(arg, info);\r\n        if (info != null && info.hasParameterType(argumentName)) {\r\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\r\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\r\n            parameterType = oldParameterType.getJSType();\r\n            isOptionalParam = oldParameterType.isOptionalArg();\r\n            isVarArgs = oldParameterType.isVarArgs();\r\n        } else {\r\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\r\n        }\r\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\r\n            if (foundTemplateType) {\r\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\r\n            }\r\n            foundTemplateType = true;\r\n        }\r\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\r\n        if (oldParameterType != null) {\r\n            oldParameterType = oldParameterType.getNext();\r\n        }\r\n    }\r\n    if (templateTypeName != null && !foundTemplateType) {\r\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\r\n    }\r\n    for (String inexistentName : allJsDocParams) {\r\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\r\n    }\r\n    parametersNode = builder.build();\r\n    return this;\r\n}","lc":1.7272727273,"pi":0.2344497608,"ma":1.8,"nbd":0.5,"ml":1.5833333333,"d":1.0555555556,"mi":-0.92670895,"fo":1.6666666667,"r":-0.0263157895,"e":3.2102188183}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Sets the <code>expansionMode<\/code>. The specified value must be one of\r\n * ADDITIVE_MODE, MULTIPLICATIVE_MODE.\r\n *\r\n * @param expansionMode The expansionMode to set.\r\n * @throws MathIllegalArgumentException if the specified mode value is not valid.\r\n * @deprecated As of 3.1. Please use {@link #setExpansionMode(ExpansionMode)} instead.\r\n *\/\r\n@Deprecated\r\npublic void setExpansionMode(int expansionMode) throws MathIllegalArgumentException {\r\n    if (expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE) {\r\n        throw new MathIllegalArgumentException(LocalizedFormats.UNSUPPORTED_EXPANSION_MODE, expansionMode, MULTIPLICATIVE_MODE, \"MULTIPLICATIVE_MODE\", ADDITIVE_MODE, \"ADDITIVE_MODE\");\r\n    }\r\n    synchronized (this) {\r\n        if (expansionMode == MULTIPLICATIVE_MODE) {\r\n            setExpansionMode(ExpansionMode.MULTIPLICATIVE);\r\n        } else if (expansionMode == ADDITIVE_MODE) {\r\n            setExpansionMode(ExpansionMode.ADDITIVE);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Sets the <code>expansionMode<\/code>. The specified value must be one of\r\n * ADDITIVE_MODE, MULTIPLICATIVE_MODE.\r\n *\r\n * @param expansionMode The expansionMode to set.\r\n * @throws MathIllegalArgumentException if the specified mode value is not valid.\r\n * @deprecated As of 3.1. Please use {@link #setExpansionMode(ExpansionMode)} instead.\r\n *\/\r\n","code_no_comment":"@Deprecated\r\npublic void setExpansionMode(int expansionMode) throws MathIllegalArgumentException {\r\n    if (expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE) {\r\n        throw new MathIllegalArgumentException(LocalizedFormats.UNSUPPORTED_EXPANSION_MODE, expansionMode, MULTIPLICATIVE_MODE, \"MULTIPLICATIVE_MODE\", ADDITIVE_MODE, \"ADDITIVE_MODE\");\r\n    }\r\n    synchronized (this) {\r\n        if (expansionMode == MULTIPLICATIVE_MODE) {\r\n            setExpansionMode(ExpansionMode.MULTIPLICATIVE);\r\n        } else if (expansionMode == ADDITIVE_MODE) {\r\n            setExpansionMode(ExpansionMode.ADDITIVE);\r\n        }\r\n    }\r\n}","lc":-0.0454545455,"pi":0.4880382775,"ma":0.2,"nbd":0.5,"ml":0.0,"d":0.0813492063,"mi":0.0661028894,"fo":-0.3333333333,"r":0.0,"e":-0.0331045452}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Performs an operation on the addressable elements of the array.\r\n *\r\n * @param f Function to be applied on this array.\r\n * @return the result.\r\n * @since 3.1\r\n *\/\r\npublic double compute(MathArrays.Function f) {\r\n    final double[] array;\r\n    final int start;\r\n    final int num;\r\n    synchronized (this) {\r\n        array = internalArray;\r\n        start = startIndex;\r\n        num = numElements;\r\n    }\r\n    return f.evaluate(array, start, num);\r\n}","code_comment":"\/**\r\n * Performs an operation on the addressable elements of the array.\r\n *\r\n * @param f Function to be applied on this array.\r\n * @return the result.\r\n * @since 3.1\r\n *\/\r\n","code_no_comment":"public double compute(MathArrays.Function f) {\r\n    final double[] array;\r\n    final int start;\r\n    final int num;\r\n    synchronized (this) {\r\n        array = internalArray;\r\n        start = startIndex;\r\n        num = numElements;\r\n    }\r\n    return f.evaluate(array, start, num);\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.2312896406,"fo":-0.4166666667,"r":1.8684210526,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5981_eb125865","label":1,"code":"\/**\r\n *  Returns child component at the specified index. Note that this method has O(n) complexity on\r\n *  the number of children.\r\n *\r\n *  @param index\r\n *             the index of the child in this container\r\n *  @throws ArrayIndexOutOfBoundsException\r\n *              when {@code index} exceeds {@code size()}\r\n *  @return child component at the specified index\r\n *  @deprecated this method is marked for deletion for WICKET8\r\n *\/\r\n@Deprecated\r\npublic final Component get(int index) {\r\n    Component childAtIndex = null;\r\n    Iterator<Component> childIterator = iterator();\r\n    while (index-- >= 0 && childIterator.hasNext()) {\r\n        childAtIndex = childIterator.next();\r\n    }\r\n    if (childAtIndex == null) {\r\n        throw new ArrayIndexOutOfBoundsException(Integer.toString(index));\r\n    }\r\n    return childAtIndex;\r\n}","code_comment":"\/**\r\n *  Returns child component at the specified index. Note that this method has O(n) complexity on\r\n *  the number of children.\r\n *\r\n *  @param index\r\n *             the index of the child in this container\r\n *  @throws ArrayIndexOutOfBoundsException\r\n *              when {@code index} exceeds {@code size()}\r\n *  @return child component at the specified index\r\n *  @deprecated this method is marked for deletion for WICKET8\r\n *\/\r\n","code_no_comment":"@Deprecated\r\npublic final Component get(int index) {\r\n    Component childAtIndex = null;\r\n    Iterator<Component> childIterator = iterator();\r\n    while (index-- >= 0 && childIterator.hasNext()) {\r\n        childAtIndex = childIterator.next();\r\n    }\r\n    if (childAtIndex == null) {\r\n        throw new ArrayIndexOutOfBoundsException(Integer.toString(index));\r\n    }\r\n    return childAtIndex;\r\n}","lc":-0.0909090909,"pi":-0.2057416268,"ma":0.0,"nbd":-0.5,"ml":0.0833333333,"d":0.2797619048,"mi":0.0875264271,"fo":-0.1666666667,"r":0.7631578947,"e":0.0543904843}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5728_3cc3fe95","label":1,"code":"\/**\r\n *  Dequeues components. The default implementation iterates direct children of this container\r\n *  found in its markup and tries to find matching\r\n *  components in queues filled by a call to {@link #queue(Component...)}. It then delegates the\r\n *  dequeueing to these children.\r\n *\r\n *  The provided {@link DequeueContext} is used to maintain the place in markup as well as the\r\n *  stack of components whose queues will be searched. For example, before delegating the call to\r\n *  a child the container will push the child onto the stack of components.\r\n *\r\n *  Certain components that implement custom markup behaviors (such as repeaters and borders)\r\n *  override this method to bring dequeueing in line with their custom markup handling.\r\n *\r\n *  @param dequeue\r\n *\/\r\npublic void dequeue(DequeueContext dequeue) {\r\n    while (dequeue.isAtOpenOrOpenCloseTag()) {\r\n        ComponentTag tag = dequeue.takeTag();\r\n        \/\/ see if child is already added to parent\r\n        Component child = get(tag.getId());\r\n        if (child == null) {\r\n            \/\/ the container does not yet have a child with this id, see if we can\r\n            \/\/ dequeue\r\n            child = dequeue.findComponentToDequeue(tag);\r\n            if (child != null) {\r\n                addDequeuedComponent(child, tag);\r\n                if (child instanceof IQueueRegion) {\r\n                    ((MarkupContainer) child).dequeue();\r\n                }\r\n            }\r\n        }\r\n        if (child == null || !(child instanceof MarkupContainer)) {\r\n            if (tag.isOpen()) {\r\n                dequeue.skipToCloseTag();\r\n            }\r\n        } else {\r\n            MarkupContainer container = (MarkupContainer) child;\r\n            if (container instanceof IQueueRegion) {\r\n                \/\/ itself when it is dequeued for the first time\r\n                if (tag.isOpen()) {\r\n                    dequeue.skipToCloseTag();\r\n                }\r\n            } else if (tag.isOpen()) {\r\n                \/\/ this component has more markup and possibly more children to dequeue\r\n                dequeue.pushContainer(container);\r\n                container.dequeue(dequeue);\r\n                dequeue.popContainer();\r\n            }\r\n        }\r\n        if (tag.isOpen() && !tag.hasNoCloseTag()) {\r\n            \/\/ pull the close tag off\r\n            ComponentTag close = dequeue.takeTag();\r\n            if (!close.closes(tag)) {\r\n                \/\/ sanity check\r\n                throw new IllegalStateException(String.format(\"Tag '%s' should be the closing one for '%s'\", close, tag));\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  Dequeues components. The default implementation iterates direct children of this container\r\n *  found in its markup and tries to find matching\r\n *  components in queues filled by a call to {@link #queue(Component...)}. It then delegates the\r\n *  dequeueing to these children.\r\n *\r\n *  The provided {@link DequeueContext} is used to maintain the place in markup as well as the\r\n *  stack of components whose queues will be searched. For example, before delegating the call to\r\n *  a child the container will push the child onto the stack of components.\r\n *\r\n *  Certain components that implement custom markup behaviors (such as repeaters and borders)\r\n *  override this method to bring dequeueing in line with their custom markup handling.\r\n *\r\n *  @param dequeue\r\n *\/\r\n","code_no_comment":"public void dequeue(DequeueContext dequeue) {\r\n    while (dequeue.isAtOpenOrOpenCloseTag()) {\r\n        ComponentTag tag = dequeue.takeTag();\r\n                Component child = get(tag.getId());\r\n        if (child == null) {\r\n                                    child = dequeue.findComponentToDequeue(tag);\r\n            if (child != null) {\r\n                addDequeuedComponent(child, tag);\r\n                if (child instanceof IQueueRegion) {\r\n                    ((MarkupContainer) child).dequeue();\r\n                }\r\n            }\r\n        }\r\n        if (child == null || !(child instanceof MarkupContainer)) {\r\n            if (tag.isOpen()) {\r\n                dequeue.skipToCloseTag();\r\n            }\r\n        } else {\r\n            MarkupContainer container = (MarkupContainer) child;\r\n            if (container instanceof IQueueRegion) {\r\n                                if (tag.isOpen()) {\r\n                    dequeue.skipToCloseTag();\r\n                }\r\n            } else if (tag.isOpen()) {\r\n                                dequeue.pushContainer(container);\r\n                container.dequeue(dequeue);\r\n                dequeue.popContainer();\r\n            }\r\n        }\r\n        if (tag.isOpen() && !tag.hasNoCloseTag()) {\r\n                        ComponentTag close = dequeue.takeTag();\r\n            if (!close.closes(tag)) {\r\n                                throw new IllegalStateException(String.format(\"Tag '%s' should be the closing one for '%s'\", close, tag));\r\n            }\r\n        }\r\n    }\r\n}","lc":1.0454545455,"pi":0.8468899522,"ma":1.8,"nbd":1.0,"ml":1.25,"d":1.25,"mi":-0.652149401,"fo":1.1666666667,"r":-0.0263157895,"e":1.5370204526}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4923_d78132be","label":1,"code":"private Url decryptUrl(final Request request, final Url encryptedUrl) {\r\n    \/*\r\n\t\t * If the encrypted URL has no segments it is the home page URL,\r\n\t\t * and does not need decrypting.\r\n\t\t *\/\r\n    if (encryptedUrl.getSegments().isEmpty()) {\r\n        return encryptedUrl;\r\n    }\r\n    List<String> encryptedSegments = encryptedUrl.getSegments();\r\n    Url url = new Url(request.getCharset());\r\n    try {\r\n        \/*\r\n\t\t\t * The first encrypted segment contains an encrypted version of the\r\n\t\t\t * entire plain text url.\r\n\t\t\t *\/\r\n        String encryptedUrlString = encryptedSegments.get(0);\r\n        if (Strings.isEmpty(encryptedUrlString)) {\r\n            return null;\r\n        }\r\n        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\r\n        if (decryptedUrl == null) {\r\n            return null;\r\n        }\r\n        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());\r\n        int originalNumberOfSegments = originalUrl.getSegments().size();\r\n        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();\r\n        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\r\n        int segNo = 1;\r\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\r\n            if (segNo > originalNumberOfSegments) {\r\n                break;\r\n            }\r\n            String next = generator.next();\r\n            String encryptedSegment = encryptedSegments.get(segNo);\r\n            if (!next.equals(encryptedSegment)) {\r\n                \/*\r\n\t\t\t\t\t * This segment received from the browser is not the same as the\r\n\t\t\t\t\t * expected segment generated by the HashSegmentGenerator. Hence it,\r\n\t\t\t\t\t * and all subsequent segments are considered plain text siblings of the\r\n\t\t\t\t\t * original encrypted url.\r\n\t\t\t\t\t *\/\r\n                break;\r\n            }\r\n            \/*\r\n\t\t\t\t * This segments matches the expected checksum, so we add the corresponding\r\n\t\t\t\t * segment from the original URL.\r\n\t\t\t\t *\/\r\n            url.getSegments().add(originalUrl.getSegments().get(segNo - 1));\r\n        }\r\n        \/*\r\n\t\t\t * Add all remaining segments from the encrypted url as plain text segments.\r\n\t\t\t *\/\r\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\r\n            \/\/ modified or additional segment\r\n            url.getSegments().add(encryptedUrl.getSegments().get(segNo));\r\n        }\r\n        url.getQueryParameters().addAll(originalUrl.getQueryParameters());\r\n    } catch (Exception e) {\r\n        log.error(\"Error decrypting URL\", e);\r\n        url = null;\r\n    }\r\n    return url;\r\n}","code_comment":null,"code_no_comment":"private Url decryptUrl(final Request request, final Url encryptedUrl) {\r\n        if (encryptedUrl.getSegments().isEmpty()) {\r\n        return encryptedUrl;\r\n    }\r\n    List<String> encryptedSegments = encryptedUrl.getSegments();\r\n    Url url = new Url(request.getCharset());\r\n    try {\r\n                String encryptedUrlString = encryptedSegments.get(0);\r\n        if (Strings.isEmpty(encryptedUrlString)) {\r\n            return null;\r\n        }\r\n        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\r\n        if (decryptedUrl == null) {\r\n            return null;\r\n        }\r\n        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());\r\n        int originalNumberOfSegments = originalUrl.getSegments().size();\r\n        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();\r\n        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\r\n        int segNo = 1;\r\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\r\n            if (segNo > originalNumberOfSegments) {\r\n                break;\r\n            }\r\n            String next = generator.next();\r\n            String encryptedSegment = encryptedSegments.get(segNo);\r\n            if (!next.equals(encryptedSegment)) {\r\n                                break;\r\n            }\r\n                        url.getSegments().add(originalUrl.getSegments().get(segNo - 1));\r\n        }\r\n                for (; segNo < encryptedNumberOfSegments; segNo++) {\r\n                        url.getSegments().add(encryptedUrl.getSegments().get(segNo));\r\n        }\r\n        url.getQueryParameters().addAll(originalUrl.getQueryParameters());\r\n    } catch (Exception e) {\r\n        log.error(\"Error decrypting URL\", e);\r\n        url = null;\r\n    }\r\n    return url;\r\n}","lc":1.2272727273,"pi":0.3110047847,"ma":1.4,"nbd":0.5,"ml":0.9166666667,"d":1.2023809524,"mi":-0.7527836505,"fo":1.9166666667,"r":-0.0263157895,"e":2.4417074394}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1429_c2f5ca6c","label":1,"code":"\/\/ ------------------------------< internal >--------------------------------\r\nprivate boolean dispatch(@Nonnull String jsonDiff, @Nonnull DocumentNodeState base, @Nonnull NodeStateDiff diff) {\r\n    if (!AbstractNodeState.comparePropertiesAgainstBaseState(this, base, diff)) {\r\n        return false;\r\n    }\r\n    if (jsonDiff.trim().isEmpty()) {\r\n        return true;\r\n    }\r\n    JsopTokenizer t = new JsopTokenizer(jsonDiff);\r\n    boolean continueComparison = true;\r\n    while (continueComparison) {\r\n        int r = t.read();\r\n        if (r == JsopReader.END) {\r\n            break;\r\n        }\r\n        switch(r) {\r\n            case '+':\r\n                {\r\n                    String path = t.readString();\r\n                    t.read(':');\r\n                    t.read('{');\r\n                    while (t.read() != '}') {\r\n                    \/\/ skip properties\r\n                    }\r\n                    String name = PathUtils.getName(path);\r\n                    continueComparison = diff.childNodeAdded(name, getChildNode(name));\r\n                    break;\r\n                }\r\n            case '-':\r\n                {\r\n                    String path = t.readString();\r\n                    String name = PathUtils.getName(path);\r\n                    continueComparison = diff.childNodeDeleted(name, base.getChildNode(name));\r\n                    break;\r\n                }\r\n            case '^':\r\n                {\r\n                    String path = t.readString();\r\n                    t.read(':');\r\n                    if (t.matches('{')) {\r\n                        t.read('}');\r\n                        String name = PathUtils.getName(path);\r\n                        continueComparison = diff.childNodeChanged(name, base.getChildNode(name), getChildNode(name));\r\n                    } else if (t.matches('[')) {\r\n                        \/\/ ignore multi valued property\r\n                        while (t.read() != ']') {\r\n                        \/\/ skip values\r\n                        }\r\n                    } else {\r\n                        \/\/ ignore single valued property\r\n                        t.read();\r\n                    }\r\n                    break;\r\n                }\r\n            case '>':\r\n                {\r\n                    String from = t.readString();\r\n                    t.read(':');\r\n                    String to = t.readString();\r\n                    String fromName = PathUtils.getName(from);\r\n                    continueComparison = diff.childNodeDeleted(fromName, base.getChildNode(fromName));\r\n                    if (!continueComparison) {\r\n                        break;\r\n                    }\r\n                    String toName = PathUtils.getName(to);\r\n                    continueComparison = diff.childNodeAdded(toName, getChildNode(toName));\r\n                    break;\r\n                }\r\n            default:\r\n                throw new IllegalArgumentException(\"jsonDiff: illegal token '\" + t.getToken() + \"' at pos: \" + t.getLastPos() + ' ' + jsonDiff);\r\n        }\r\n    }\r\n    return continueComparison;\r\n}","code_comment":null,"code_no_comment":"private boolean dispatch(@Nonnull String jsonDiff, @Nonnull DocumentNodeState base, @Nonnull NodeStateDiff diff) {\r\n    if (!AbstractNodeState.comparePropertiesAgainstBaseState(this, base, diff)) {\r\n        return false;\r\n    }\r\n    if (jsonDiff.trim().isEmpty()) {\r\n        return true;\r\n    }\r\n    JsopTokenizer t = new JsopTokenizer(jsonDiff);\r\n    boolean continueComparison = true;\r\n    while (continueComparison) {\r\n        int r = t.read();\r\n        if (r == JsopReader.END) {\r\n            break;\r\n        }\r\n        switch(r) {\r\n            case '+':\r\n                {\r\n                    String path = t.readString();\r\n                    t.read(':');\r\n                    t.read('{');\r\n                    while (t.read() != '}') {\r\n                                        }\r\n                    String name = PathUtils.getName(path);\r\n                    continueComparison = diff.childNodeAdded(name, getChildNode(name));\r\n                    break;\r\n                }\r\n            case '-':\r\n                {\r\n                    String path = t.readString();\r\n                    String name = PathUtils.getName(path);\r\n                    continueComparison = diff.childNodeDeleted(name, base.getChildNode(name));\r\n                    break;\r\n                }\r\n            case '^':\r\n                {\r\n                    String path = t.readString();\r\n                    t.read(':');\r\n                    if (t.matches('{')) {\r\n                        t.read('}');\r\n                        String name = PathUtils.getName(path);\r\n                        continueComparison = diff.childNodeChanged(name, base.getChildNode(name), getChildNode(name));\r\n                    } else if (t.matches('[')) {\r\n                                                while (t.read() != ']') {\r\n                                                }\r\n                    } else {\r\n                                                t.read();\r\n                    }\r\n                    break;\r\n                }\r\n            case '>':\r\n                {\r\n                    String from = t.readString();\r\n                    t.read(':');\r\n                    String to = t.readString();\r\n                    String fromName = PathUtils.getName(from);\r\n                    continueComparison = diff.childNodeDeleted(fromName, base.getChildNode(fromName));\r\n                    if (!continueComparison) {\r\n                        break;\r\n                    }\r\n                    String toName = PathUtils.getName(to);\r\n                    continueComparison = diff.childNodeAdded(toName, getChildNode(toName));\r\n                    break;\r\n                }\r\n            default:\r\n                throw new IllegalArgumentException(\"jsonDiff: illegal token '\" + t.getToken() + \"' at pos: \" + t.getLastPos() + ' ' + jsonDiff);\r\n        }\r\n    }\r\n    return continueComparison;\r\n}","lc":2.5,"pi":1.8421052632,"ma":3.6,"nbd":2.0,"ml":1.4166666667,"d":0.8650793651,"mi":-1.1192389006,"fo":2.5833333333,"r":-0.0263157895,"e":2.8564582217}
{"project_name":"Closure","project_version":"99","label":2,"code":"\/**\r\n * Since this pass reports errors only when a global {@code this} keyword\r\n * is encountered, there is no reason to traverse non global contexts.\r\n *\/\r\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\r\n    if (n.getType() == Token.FUNCTION) {\r\n        \/\/ Don't traverse functions that are constructors or have the @this\r\n        \/\/ or @override annotation.\r\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\r\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType() || jsDoc.isOverride())) {\r\n            return false;\r\n        }\r\n        \/\/ Don't traverse functions unless they would normally\r\n        \/\/ be able to have a @this annotation associated with them. e.g.,\r\n        \/\/ var a = function() { }; \/\/ or\r\n        \/\/ function a() {} \/\/ or\r\n        \/\/ a.x = function() {};\r\n        int pType = parent.getType();\r\n        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (parent != null && parent.getType() == Token.ASSIGN) {\r\n        Node lhs = parent.getFirstChild();\r\n        Node rhs = lhs.getNext();\r\n        if (n == lhs) {\r\n            \/\/ assignLhsChild should not be overridden.\r\n            if (assignLhsChild == null) {\r\n                assignLhsChild = lhs;\r\n            }\r\n        } else {\r\n            \/\/ property or subproperty.\r\n            if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\r\n                return false;\r\n            }\r\n            if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n * Since this pass reports errors only when a global {@code this} keyword\r\n * is encountered, there is no reason to traverse non global contexts.\r\n *\/\r\n","code_no_comment":"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\r\n    if (n.getType() == Token.FUNCTION) {\r\n                        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\r\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType() || jsDoc.isOverride())) {\r\n            return false;\r\n        }\r\n                                                int pType = parent.getType();\r\n        if (!(pType == Token.BLOCK || pType == Token.SCRIPT || pType == Token.NAME || pType == Token.ASSIGN)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (parent != null && parent.getType() == Token.ASSIGN) {\r\n        Node lhs = parent.getFirstChild();\r\n        Node rhs = lhs.getNext();\r\n        if (n == lhs) {\r\n                        if (assignLhsChild == null) {\r\n                assignLhsChild = lhs;\r\n            }\r\n        } else {\r\n                        if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\r\n                return false;\r\n            }\r\n            if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}","lc":0.6818181818,"pi":0.5837320574,"ma":1.0,"nbd":0.5,"ml":2.25,"d":0.9226190476,"mi":-0.5498238196,"fo":0.8333333333,"r":0.0,"e":1.5572875066}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-393_d4b02f6a","label":3,"code":"\/**\r\n * Find an optimum in the given interval, start at startValue.\r\n * <p>\r\n * An optimizer may require that the interval brackets a single optimum.\r\n * <\/p>\r\n * @param f the function to optimize.\r\n * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\r\n * or {@link GoalType#MINIMIZE}\r\n * @param min the lower bound for the interval.\r\n * @param max the upper bound for the interval.\r\n * @param startValue the start value to use\r\n * @return a value where the function is optimum\r\n * @throws ConvergenceException if the maximum iteration count is exceeded\r\n * or the optimizer detects convergence problems otherwise.\r\n * @throws FunctionEvaluationException if an error occurs evaluating the\r\n * function\r\n * @throws IllegalArgumentException if min > max or the arguments do not\r\n * satisfy the requirements specified by the optimizer\r\n *\/\r\ndouble optimize(UnivariateRealFunction f, GoalType goalType, double min, double max, double startValue) throws ConvergenceException, FunctionEvaluationException;","code_comment":"\/**\r\n * Find an optimum in the given interval, start at startValue.\r\n * <p>\r\n * An optimizer may require that the interval brackets a single optimum.\r\n * <\/p>\r\n * @param f the function to optimize.\r\n * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\r\n * or {@link GoalType#MINIMIZE}\r\n * @param min the lower bound for the interval.\r\n * @param max the upper bound for the interval.\r\n * @param startValue the start value to use\r\n * @return a value where the function is optimum\r\n * @throws ConvergenceException if the maximum iteration count is exceeded\r\n * or the optimizer detects convergence problems otherwise.\r\n * @throws FunctionEvaluationException if an error occurs evaluating the\r\n * function\r\n * @throws IllegalArgumentException if min > max or the arguments do not\r\n * satisfy the requirements specified by the optimizer\r\n *\/\r\n","code_no_comment":"double optimize(UnivariateRealFunction f, GoalType goalType, double min, double max, double startValue) throws ConvergenceException, FunctionEvaluationException;","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.4377730796,"fo":-0.5,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1121_5a6ccd58","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected UnivariatePointValuePair doOptimize() {\r\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\r\n    final double lo = getMin();\r\n    final double mid = getStartValue();\r\n    final double hi = getMax();\r\n    \/\/ Optional additional convergence criteria.\r\n    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\r\n    double a;\r\n    double b;\r\n    if (lo < hi) {\r\n        a = lo;\r\n        b = hi;\r\n    } else {\r\n        a = hi;\r\n        b = lo;\r\n    }\r\n    double x = mid;\r\n    double v = x;\r\n    double w = x;\r\n    double d = 0;\r\n    double e = 0;\r\n    double fx = computeObjectiveValue(x);\r\n    if (!isMinim) {\r\n        fx = -fx;\r\n    }\r\n    double fv = fx;\r\n    double fw = fx;\r\n    UnivariatePointValuePair previous = null;\r\n    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\r\n    \/\/ Best point encountered so far (which is the initial guess).\r\n    UnivariatePointValuePair best = current;\r\n    int iter = 0;\r\n    while (true) {\r\n        final double m = 0.5 * (a + b);\r\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\r\n        final double tol2 = 2 * tol1;\r\n        \/\/ Default stopping criterion.\r\n        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\r\n        if (!stop) {\r\n            double p = 0;\r\n            double q = 0;\r\n            double r = 0;\r\n            double u = 0;\r\n            if (FastMath.abs(e) > tol1) {\r\n                \/\/ Fit parabola.\r\n                r = (x - w) * (fx - fv);\r\n                q = (x - v) * (fx - fw);\r\n                p = (x - v) * q - (x - w) * r;\r\n                q = 2 * (q - r);\r\n                if (q > 0) {\r\n                    p = -p;\r\n                } else {\r\n                    q = -q;\r\n                }\r\n                r = e;\r\n                e = d;\r\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\r\n                    \/\/ Parabolic interpolation step.\r\n                    d = p \/ q;\r\n                    u = x + d;\r\n                    \/\/ f must not be evaluated too close to a or b.\r\n                    if (u - a < tol2 || b - u < tol2) {\r\n                        if (x <= m) {\r\n                            d = tol1;\r\n                        } else {\r\n                            d = -tol1;\r\n                        }\r\n                    }\r\n                } else {\r\n                    \/\/ Golden section step.\r\n                    if (x < m) {\r\n                        e = b - x;\r\n                    } else {\r\n                        e = a - x;\r\n                    }\r\n                    d = GOLDEN_SECTION * e;\r\n                }\r\n            } else {\r\n                \/\/ Golden section step.\r\n                if (x < m) {\r\n                    e = b - x;\r\n                } else {\r\n                    e = a - x;\r\n                }\r\n                d = GOLDEN_SECTION * e;\r\n            }\r\n            \/\/ Update by at least \"tol1\".\r\n            if (FastMath.abs(d) < tol1) {\r\n                if (d >= 0) {\r\n                    u = x + tol1;\r\n                } else {\r\n                    u = x - tol1;\r\n                }\r\n            } else {\r\n                u = x + d;\r\n            }\r\n            double fu = computeObjectiveValue(u);\r\n            if (!isMinim) {\r\n                fu = -fu;\r\n            }\r\n            \/\/ User-defined convergence checker.\r\n            previous = current;\r\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\r\n            best = best(best, best(previous, current, isMinim), isMinim);\r\n            if (checker != null && checker.converged(iter, previous, current)) {\r\n                return best;\r\n            }\r\n            \/\/ Update a, b, v, w and x.\r\n            if (fu <= fx) {\r\n                if (u < x) {\r\n                    b = x;\r\n                } else {\r\n                    a = x;\r\n                }\r\n                v = w;\r\n                fv = fw;\r\n                w = x;\r\n                fw = fx;\r\n                x = u;\r\n                fx = fu;\r\n            } else {\r\n                if (u < x) {\r\n                    a = u;\r\n                } else {\r\n                    b = u;\r\n                }\r\n                if (fu <= fw || Precision.equals(w, x)) {\r\n                    v = w;\r\n                    fv = fw;\r\n                    w = u;\r\n                    fw = fu;\r\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\r\n                    v = u;\r\n                    fv = fu;\r\n                }\r\n            }\r\n        } else {\r\n            \/\/ Default termination (Brent's criterion).\r\n            return best(best, best(previous, current, isMinim), isMinim);\r\n        }\r\n        ++iter;\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected UnivariatePointValuePair doOptimize() {\r\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\r\n    final double lo = getMin();\r\n    final double mid = getStartValue();\r\n    final double hi = getMax();\r\n        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\r\n    double a;\r\n    double b;\r\n    if (lo < hi) {\r\n        a = lo;\r\n        b = hi;\r\n    } else {\r\n        a = hi;\r\n        b = lo;\r\n    }\r\n    double x = mid;\r\n    double v = x;\r\n    double w = x;\r\n    double d = 0;\r\n    double e = 0;\r\n    double fx = computeObjectiveValue(x);\r\n    if (!isMinim) {\r\n        fx = -fx;\r\n    }\r\n    double fv = fx;\r\n    double fw = fx;\r\n    UnivariatePointValuePair previous = null;\r\n    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\r\n        UnivariatePointValuePair best = current;\r\n    int iter = 0;\r\n    while (true) {\r\n        final double m = 0.5 * (a + b);\r\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\r\n        final double tol2 = 2 * tol1;\r\n                final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\r\n        if (!stop) {\r\n            double p = 0;\r\n            double q = 0;\r\n            double r = 0;\r\n            double u = 0;\r\n            if (FastMath.abs(e) > tol1) {\r\n                                r = (x - w) * (fx - fv);\r\n                q = (x - v) * (fx - fw);\r\n                p = (x - v) * q - (x - w) * r;\r\n                q = 2 * (q - r);\r\n                if (q > 0) {\r\n                    p = -p;\r\n                } else {\r\n                    q = -q;\r\n                }\r\n                r = e;\r\n                e = d;\r\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\r\n                                        d = p \/ q;\r\n                    u = x + d;\r\n                                        if (u - a < tol2 || b - u < tol2) {\r\n                        if (x <= m) {\r\n                            d = tol1;\r\n                        } else {\r\n                            d = -tol1;\r\n                        }\r\n                    }\r\n                } else {\r\n                                        if (x < m) {\r\n                        e = b - x;\r\n                    } else {\r\n                        e = a - x;\r\n                    }\r\n                    d = GOLDEN_SECTION * e;\r\n                }\r\n            } else {\r\n                                if (x < m) {\r\n                    e = b - x;\r\n                } else {\r\n                    e = a - x;\r\n                }\r\n                d = GOLDEN_SECTION * e;\r\n            }\r\n                        if (FastMath.abs(d) < tol1) {\r\n                if (d >= 0) {\r\n                    u = x + tol1;\r\n                } else {\r\n                    u = x - tol1;\r\n                }\r\n            } else {\r\n                u = x + d;\r\n            }\r\n            double fu = computeObjectiveValue(u);\r\n            if (!isMinim) {\r\n                fu = -fu;\r\n            }\r\n                        previous = current;\r\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\r\n            best = best(best, best(previous, current, isMinim), isMinim);\r\n            if (checker != null && checker.converged(iter, previous, current)) {\r\n                return best;\r\n            }\r\n                        if (fu <= fx) {\r\n                if (u < x) {\r\n                    b = x;\r\n                } else {\r\n                    a = x;\r\n                }\r\n                v = w;\r\n                fv = fw;\r\n                w = x;\r\n                fw = fx;\r\n                x = u;\r\n                fx = fu;\r\n            } else {\r\n                if (u < x) {\r\n                    a = u;\r\n                } else {\r\n                    b = u;\r\n                }\r\n                if (fu <= fw || Precision.equals(w, x)) {\r\n                    v = w;\r\n                    fv = fw;\r\n                    w = u;\r\n                    fw = fu;\r\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\r\n                    v = u;\r\n                    fv = fu;\r\n                }\r\n            }\r\n        } else {\r\n                        return best(best, best(previous, current, isMinim), isMinim);\r\n        }\r\n        ++iter;\r\n    }\r\n}","lc":5.3636363636,"pi":1.6650717703,"ma":3.8,"nbd":2.0,"ml":4.8333333333,"d":7.2222222222,"mi":-1.5606765328,"fo":1.25,"r":-0.0263157895,"e":47.8691793019}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5400_6cefb9f8","label":3,"code":"private void internalAdd(final Behavior behavior) {\r\n    component.data_add(behavior);\r\n    if (behavior.getStatelessHint(component)) {\r\n        getBehaviorId(behavior);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void internalAdd(final Behavior behavior) {\r\n    component.data_add(behavior);\r\n    if (behavior.getStatelessHint(component)) {\r\n        getBehaviorId(behavior);\r\n    }\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.621141649,"fo":-0.25,"r":0.7894736842,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-581_bb02fa15","label":1,"code":"\/**\r\n * Default hook to write footer during close.\r\n *\/\r\n@Override\r\npublic void releaseSub() {\r\n    byte[] footer = layout.getFooter();\r\n    if (footer != null) {\r\n        write(footer);\r\n    }\r\n    close();\r\n}","code_comment":"\/**\r\n * Default hook to write footer during close.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void releaseSub() {\r\n    byte[] footer = layout.getFooter();\r\n    if (footer != null) {\r\n        write(footer);\r\n    }\r\n    close();\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.123015873,"mi":0.4570824524,"fo":-0.25,"r":2.4210526316,"e":-0.1374503668}
{"project_name":"Closure","project_version":"79","label":1,"code":"@Override\r\npublic void process(Node externs, Node root) {\r\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\r\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\r\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\r\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\r\n        t.traverseRoots(externs, root);\r\n    }\r\n    \/\/ It is important that removeDuplicateDeclarations runs after\r\n    \/\/ MakeDeclaredNamesUnique in order for catch block exception names to be\r\n    \/\/ handled properly. Specifically, catch block exception names are\r\n    \/\/ only valid within the catch block, but our currect Scope logic\r\n    \/\/ has no concept of this and includes it in the containing function\r\n    \/\/ (or global scope). MakeDeclaredNamesUnique makes the catch exception\r\n    \/\/ names unique so that removeDuplicateDeclarations() will properly handle\r\n    \/\/ cases where a function scope variable conflict with a exception name:\r\n    \/\/ function f() {\r\n    \/\/ try {throw 0;} catch(e) {e; \/* catch scope 'e'*\/}\r\n    \/\/ var e = 1; \/\/ f scope 'e'\r\n    \/\/ }\r\n    \/\/ otherwise 'var e = 1' would be rewritten as 'e = 1'.\r\n    \/\/ TODO(johnlenz): Introduce a seperate scope for catch nodes.\r\n    removeDuplicateDeclarations(externs, root);\r\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\r\n    if (!compiler.getLifeCycleStage().isNormalized()) {\r\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void process(Node externs, Node root) {\r\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\r\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\r\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\r\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\r\n        t.traverseRoots(externs, root);\r\n    }\r\n                                                            removeDuplicateDeclarations(externs, root);\r\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\r\n    if (!compiler.getLifeCycleStage().isNormalized()) {\r\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\r\n    }\r\n}","lc":0.0,"pi":-0.0861244019,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":0.005952381,"mi":-0.0334038055,"fo":0.0833333333,"r":-0.0263157895,"e":0.0213297373}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5724_b92591f6","label":1,"code":"@Override\r\npublic Component newComponent(ComponentTag tag) {\r\n    return new Enclosure(tag.getId(), tag.getAttribute(EnclosureHandler.CHILD_ATTRIBUTE));\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Component newComponent(ComponentTag tag) {\r\n    return new Enclosure(tag.getId(), tag.getAttribute(EnclosureHandler.CHILD_ATTRIBUTE));\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7801268499,"fo":-0.3333333333,"r":0.2105263158,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6667_1fc7bd7a","label":1,"code":"public void done(boolean doneSync) {\r\n    \/\/ we only have to handle async completion of the routing slip\r\n    if (doneSync) {\r\n        return;\r\n    }\r\n    Exchange target = exchange;\r\n    \/\/ increment index as we have just processed once\r\n    index.getAndIncrement();\r\n    \/\/ continue looping asynchronously\r\n    while (index.get() < count.get()) {\r\n        \/\/ and prepare for next iteration\r\n        target = prepareExchange(exchange, index.get());\r\n        \/\/ process again\r\n        boolean sync = process(target, callback, index, count);\r\n        if (!sync) {\r\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", target.getExchangeId());\r\n            \/\/ so we break out now, then the callback will be invoked which then continue routing from where we left here\r\n            return;\r\n        }\r\n        \/\/ increment counter before next loop\r\n        index.getAndIncrement();\r\n    }\r\n    \/\/ we are done so prepare the result\r\n    ExchangeHelper.copyResults(exchange, target);\r\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n    callback.done(false);\r\n}","code_comment":null,"code_no_comment":"public void done(boolean doneSync) {\r\n        if (doneSync) {\r\n        return;\r\n    }\r\n    Exchange target = exchange;\r\n        index.getAndIncrement();\r\n        while (index.get() < count.get()) {\r\n                target = prepareExchange(exchange, index.get());\r\n                boolean sync = process(target, callback, index, count);\r\n        if (!sync) {\r\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", target.getExchangeId());\r\n                        return;\r\n        }\r\n                index.getAndIncrement();\r\n    }\r\n        ExchangeHelper.copyResults(exchange, target);\r\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n    callback.done(false);\r\n}","lc":0.2272727273,"pi":0.1291866029,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":0.0416666667,"mi":-0.1915433404,"fo":0.5833333333,"r":-0.0263157895,"e":0.0561700754}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5724_b92591f6","label":1,"code":"@Override\r\nprotected final MarkupElement onComponentTag(ComponentTag tag) throws ParseException {\r\n    if (tag.isClose()) {\r\n        return tag;\r\n    }\r\n    String wicketIdAttr = getWicketNamespace() + \":\" + \"id\";\r\n    \/\/ Don't touch any wicket:id component and any auto-components\r\n    if ((tag instanceof WicketTag) || (tag.isAutolinkEnabled() == true) || (tag.getAttributes().get(wicketIdAttr) != null)) {\r\n        return tag;\r\n    }\r\n    \/\/ behavior that prepends the relative path.\r\n    for (String attrName : attributeNames) {\r\n        String attrValue = tag.getAttributes().getString(attrName);\r\n        if ((attrValue != null) && (attrValue.startsWith(\"\/\") == false) && (!attrValue.contains(\":\")) && !(attrValue.startsWith(\"#\"))) {\r\n            if (tag.getId() == null) {\r\n                tag.setId(getWicketRelativePathPrefix(null));\r\n                tag.setAutoComponentTag(true);\r\n            }\r\n            tag.addBehavior(RELATIVE_PATH_BEHAVIOR);\r\n            tag.setModified(true);\r\n            break;\r\n        }\r\n    }\r\n    return tag;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected final MarkupElement onComponentTag(ComponentTag tag) throws ParseException {\r\n    if (tag.isClose()) {\r\n        return tag;\r\n    }\r\n    String wicketIdAttr = getWicketNamespace() + \":\" + \"id\";\r\n        if ((tag instanceof WicketTag) || (tag.isAutolinkEnabled() == true) || (tag.getAttributes().get(wicketIdAttr) != null)) {\r\n        return tag;\r\n    }\r\n        for (String attrName : attributeNames) {\r\n        String attrValue = tag.getAttributes().getString(attrName);\r\n        if ((attrValue != null) && (attrValue.startsWith(\"\/\") == false) && (!attrValue.contains(\":\")) && !(attrValue.startsWith(\"#\"))) {\r\n            if (tag.getId() == null) {\r\n                tag.setId(getWicketRelativePathPrefix(null));\r\n                tag.setAutoComponentTag(true);\r\n            }\r\n            tag.addBehavior(RELATIVE_PATH_BEHAVIOR);\r\n            tag.setModified(true);\r\n            break;\r\n        }\r\n    }\r\n    return tag;\r\n}","lc":0.4090909091,"pi":0.8229665072,"ma":0.6,"nbd":0.5,"ml":1.1666666667,"d":0.7242063492,"mi":-0.3815362932,"fo":0.8333333333,"r":-0.0263157895,"e":0.8736709255}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-43_668f08f2","label":1,"code":"public void removeNode(String nodePath) throws NotFoundException, Exception {\r\n    String parentPath = PathUtils.getParentPath(nodePath);\r\n    String nodeName = PathUtils.getName(nodePath);\r\n    MutableNode parent = getOrCreateStagedNode(parentPath);\r\n    if (parent.remove(nodeName) == null) {\r\n        throw new NotFoundException(nodePath);\r\n    }\r\n    \/\/ update staging area\r\n    removeStagedNodes(nodePath);\r\n    \/\/ update change log\r\n    changeLog.add(new RemoveNode(nodePath));\r\n}","code_comment":null,"code_no_comment":"public void removeNode(String nodePath) throws NotFoundException, Exception {\r\n    String parentPath = PathUtils.getParentPath(nodePath);\r\n    String nodeName = PathUtils.getName(nodePath);\r\n    MutableNode parent = getOrCreateStagedNode(parentPath);\r\n    if (parent.remove(nodeName) == null) {\r\n        throw new NotFoundException(nodePath);\r\n    }\r\n        removeStagedNodes(nodePath);\r\n        changeLog.add(new RemoveNode(nodePath));\r\n}","lc":-0.1818181818,"pi":-0.4019138756,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0476190476,"mi":0.1622269204,"fo":0.0,"r":0.5526315789,"e":-0.0443722158}
{"project_name":"Closure","project_version":"96","label":2,"code":"\/**\r\n * Visits the parameters of a CALL or a NEW node.\r\n *\/\r\nprivate void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) {\r\n    Iterator<Node> arguments = call.children().iterator();\r\n    \/\/ skip the function name\r\n    arguments.next();\r\n    Iterator<Node> parameters = functionType.getParameters().iterator();\r\n    int ordinal = 0;\r\n    Node parameter = null;\r\n    Node argument = null;\r\n    while (arguments.hasNext() && parameters.hasNext()) {\r\n        \/\/ If there are no parameters left in the list, then the while loop\r\n        \/\/ above implies that this must be a var_args function.\r\n        parameter = parameters.next();\r\n        argument = arguments.next();\r\n        ordinal++;\r\n        validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal);\r\n    }\r\n    int numArgs = call.getChildCount() - 1;\r\n    int minArgs = functionType.getMinArguments();\r\n    int maxArgs = functionType.getMaxArguments();\r\n    if (minArgs > numArgs || maxArgs < numArgs) {\r\n        report(t, call, WRONG_ARGUMENT_COUNT, validator.getReadableJSTypeName(call.getFirstChild(), false), String.valueOf(numArgs), String.valueOf(minArgs), maxArgs != Integer.MAX_VALUE ? \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\r\n    }\r\n}","code_comment":"\/**\r\n * Visits the parameters of a CALL or a NEW node.\r\n *\/\r\n","code_no_comment":"private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) {\r\n    Iterator<Node> arguments = call.children().iterator();\r\n        arguments.next();\r\n    Iterator<Node> parameters = functionType.getParameters().iterator();\r\n    int ordinal = 0;\r\n    Node parameter = null;\r\n    Node argument = null;\r\n    while (arguments.hasNext() && parameters.hasNext()) {\r\n                        parameter = parameters.next();\r\n        argument = arguments.next();\r\n        ordinal++;\r\n        validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal);\r\n    }\r\n    int numArgs = call.getChildCount() - 1;\r\n    int minArgs = functionType.getMinArguments();\r\n    int maxArgs = functionType.getMaxArguments();\r\n    if (minArgs > numArgs || maxArgs < numArgs) {\r\n        report(t, call, WRONG_ARGUMENT_COUNT, validator.getReadableJSTypeName(call.getFirstChild(), false), String.valueOf(numArgs), String.valueOf(minArgs), maxArgs != Integer.MAX_VALUE ? \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\r\n    }\r\n}","lc":0.2727272727,"pi":-0.3349282297,"ma":0.0,"nbd":-0.5,"ml":0.4166666667,"d":1.2400793651,"mi":-0.3536293164,"fo":1.1666666667,"r":-0.0263157895,"e":2.0704782651}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1496_0a4c7694","label":1,"code":"public void setInputChannel(IntermediateResultPartitionID partitionId, InputChannel inputChannel) {\r\n    synchronized (requestLock) {\r\n        inputChannels.put(checkNotNull(partitionId), checkNotNull(inputChannel));\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void setInputChannel(IntermediateResultPartitionID partitionId, InputChannel inputChannel) {\r\n    synchronized (requestLock) {\r\n        inputChannels.put(checkNotNull(partitionId), checkNotNull(inputChannel));\r\n    }\r\n}","lc":-0.4090909091,"pi":0.0,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6842847075,"fo":-0.25,"r":0.6842105263,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4658_ef3adb12","label":3,"code":"@Override\r\nprotected void onBeforeRender() {\r\n    int index = getSelectedTab();\r\n    if ((index == -1) || (isTabVisible(index) == false)) {\r\n        \/\/ find first visible tab\r\n        index = -1;\r\n        for (int i = 0; i < tabs.size(); i++) {\r\n            if (isTabVisible(i)) {\r\n                index = i;\r\n                break;\r\n            }\r\n        }\r\n        if (index != -1) {\r\n            \/*\r\n\t\t\t\t * found a visible tab, so select it\r\n\t\t\t\t *\/\r\n            setSelectedTab(index);\r\n        }\r\n    }\r\n    setCurrentTab(index);\r\n    super.onBeforeRender();\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void onBeforeRender() {\r\n    int index = getSelectedTab();\r\n    if ((index == -1) || (isTabVisible(index) == false)) {\r\n                index = -1;\r\n        for (int i = 0; i < tabs.size(); i++) {\r\n            if (isTabVisible(i)) {\r\n                index = i;\r\n                break;\r\n            }\r\n        }\r\n        if (index != -1) {\r\n                        setSelectedTab(index);\r\n        }\r\n    }\r\n    setCurrentTab(index);\r\n    super.onBeforeRender();\r\n}","lc":0.1818181818,"pi":0.9186602871,"ma":0.4,"nbd":0.5,"ml":0.4166666667,"d":0.8670634921,"mi":-0.1461592671,"fo":0.0833333333,"r":0.2105263158,"e":0.365731344}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1732_941e3cb1","label":3,"code":"\/**\r\n * Read the metadata table to get tablets and match up ranges to them.\r\n *\/\r\n@Override\r\npublic InputSplit[] getSplits(JobConf job, int numSplits) throws IOException {\r\n    log.setLevel(getLogLevel(job));\r\n    validateOptions(job);\r\n    LinkedList<InputSplit> splits = new LinkedList<InputSplit>();\r\n    Map<String, BatchScanConfig> tableConfigs = getBatchScanConfigs(job);\r\n    for (Map.Entry<String, BatchScanConfig> tableConfigEntry : tableConfigs.entrySet()) {\r\n        String tableName = tableConfigEntry.getKey();\r\n        BatchScanConfig tableConfig = tableConfigEntry.getValue();\r\n        boolean autoAdjust = tableConfig.shouldAutoAdjustRanges();\r\n        String tableId = null;\r\n        List<Range> ranges = autoAdjust ? Range.mergeOverlapping(tableConfig.getRanges()) : tableConfig.getRanges();\r\n        if (ranges.isEmpty()) {\r\n            ranges = new ArrayList<Range>(1);\r\n            ranges.add(new Range());\r\n        }\r\n        \/\/ get the metadata information for these ranges\r\n        Map<String, Map<KeyExtent, List<Range>>> binnedRanges = new HashMap<String, Map<KeyExtent, List<Range>>>();\r\n        TabletLocator tl;\r\n        try {\r\n            \/\/ resolve table name to id once, and use id from this point forward\r\n            tableId = Tables.getTableId(getInstance(job), tableName);\r\n            if (tableConfig.isOfflineScan()) {\r\n                binnedRanges = binOfflineTable(job, tableId, ranges);\r\n                while (binnedRanges == null) {\r\n                    \/\/ Some tablets were still online, try again\r\n                    \/\/ sleep randomly between 100 and 200 ms\r\n                    UtilWaitThread.sleep(100 + (int) (Math.random() * 100));\r\n                    binnedRanges = binOfflineTable(job, tableId, ranges);\r\n                }\r\n            } else {\r\n                Instance instance = getInstance(job);\r\n                tl = getTabletLocator(job, tableId);\r\n                \/\/ its possible that the cache could contain complete, but old information about a tables tablets... so clear it\r\n                tl.invalidateCache();\r\n                Credentials creds = new Credentials(getPrincipal(job), getAuthenticationToken(job));\r\n                while (!tl.binRanges(creds, ranges, binnedRanges).isEmpty()) {\r\n                    if (!(instance instanceof MockInstance)) {\r\n                        if (!Tables.exists(instance, tableId))\r\n                            throw new TableDeletedException(tableId);\r\n                        if (Tables.getTableState(instance, tableId) == TableState.OFFLINE)\r\n                            throw new TableOfflineException(instance, tableId);\r\n                    }\r\n                    binnedRanges.clear();\r\n                    log.warn(\"Unable to locate bins for specified ranges. Retrying.\");\r\n                    \/\/ sleep randomly between 100 and 200 ms\r\n                    UtilWaitThread.sleep(100 + (int) (Math.random() * 100));\r\n                    tl.invalidateCache();\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            throw new IOException(e);\r\n        }\r\n        HashMap<Range, ArrayList<String>> splitsToAdd = null;\r\n        if (!autoAdjust)\r\n            splitsToAdd = new HashMap<Range, ArrayList<String>>();\r\n        HashMap<String, String> hostNameCache = new HashMap<String, String>();\r\n        for (Map.Entry<String, Map<KeyExtent, List<Range>>> tserverBin : binnedRanges.entrySet()) {\r\n            String ip = tserverBin.getKey().split(\":\", 2)[0];\r\n            String location = hostNameCache.get(ip);\r\n            if (location == null) {\r\n                InetAddress inetAddress = InetAddress.getByName(ip);\r\n                location = inetAddress.getHostName();\r\n                hostNameCache.put(ip, location);\r\n            }\r\n            for (Map.Entry<KeyExtent, List<Range>> extentRanges : tserverBin.getValue().entrySet()) {\r\n                Range ke = extentRanges.getKey().toDataRange();\r\n                for (Range r : extentRanges.getValue()) {\r\n                    if (autoAdjust) {\r\n                        \/\/ divide ranges into smaller ranges, based on the tablets\r\n                        splits.add(new RangeInputSplit(tableName, tableId, ke.clip(r), new String[] { location }));\r\n                    } else {\r\n                        \/\/ don't divide ranges\r\n                        ArrayList<String> locations = splitsToAdd.get(r);\r\n                        if (locations == null)\r\n                            locations = new ArrayList<String>(1);\r\n                        locations.add(location);\r\n                        splitsToAdd.put(r, locations);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!autoAdjust)\r\n            for (Map.Entry<Range, ArrayList<String>> entry : splitsToAdd.entrySet()) splits.add(new RangeInputSplit(tableName, tableId, entry.getKey(), entry.getValue().toArray(new String[0])));\r\n    }\r\n    return splits.toArray(new InputSplit[splits.size()]);\r\n}","code_comment":"\/**\r\n * Read the metadata table to get tablets and match up ranges to them.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic InputSplit[] getSplits(JobConf job, int numSplits) throws IOException {\r\n    log.setLevel(getLogLevel(job));\r\n    validateOptions(job);\r\n    LinkedList<InputSplit> splits = new LinkedList<InputSplit>();\r\n    Map<String, BatchScanConfig> tableConfigs = getBatchScanConfigs(job);\r\n    for (Map.Entry<String, BatchScanConfig> tableConfigEntry : tableConfigs.entrySet()) {\r\n        String tableName = tableConfigEntry.getKey();\r\n        BatchScanConfig tableConfig = tableConfigEntry.getValue();\r\n        boolean autoAdjust = tableConfig.shouldAutoAdjustRanges();\r\n        String tableId = null;\r\n        List<Range> ranges = autoAdjust ? Range.mergeOverlapping(tableConfig.getRanges()) : tableConfig.getRanges();\r\n        if (ranges.isEmpty()) {\r\n            ranges = new ArrayList<Range>(1);\r\n            ranges.add(new Range());\r\n        }\r\n                Map<String, Map<KeyExtent, List<Range>>> binnedRanges = new HashMap<String, Map<KeyExtent, List<Range>>>();\r\n        TabletLocator tl;\r\n        try {\r\n                        tableId = Tables.getTableId(getInstance(job), tableName);\r\n            if (tableConfig.isOfflineScan()) {\r\n                binnedRanges = binOfflineTable(job, tableId, ranges);\r\n                while (binnedRanges == null) {\r\n                                                            UtilWaitThread.sleep(100 + (int) (Math.random() * 100));\r\n                    binnedRanges = binOfflineTable(job, tableId, ranges);\r\n                }\r\n            } else {\r\n                Instance instance = getInstance(job);\r\n                tl = getTabletLocator(job, tableId);\r\n                                tl.invalidateCache();\r\n                Credentials creds = new Credentials(getPrincipal(job), getAuthenticationToken(job));\r\n                while (!tl.binRanges(creds, ranges, binnedRanges).isEmpty()) {\r\n                    if (!(instance instanceof MockInstance)) {\r\n                        if (!Tables.exists(instance, tableId))\r\n                            throw new TableDeletedException(tableId);\r\n                        if (Tables.getTableState(instance, tableId) == TableState.OFFLINE)\r\n                            throw new TableOfflineException(instance, tableId);\r\n                    }\r\n                    binnedRanges.clear();\r\n                    log.warn(\"Unable to locate bins for specified ranges. Retrying.\");\r\n                                        UtilWaitThread.sleep(100 + (int) (Math.random() * 100));\r\n                    tl.invalidateCache();\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            throw new IOException(e);\r\n        }\r\n        HashMap<Range, ArrayList<String>> splitsToAdd = null;\r\n        if (!autoAdjust)\r\n            splitsToAdd = new HashMap<Range, ArrayList<String>>();\r\n        HashMap<String, String> hostNameCache = new HashMap<String, String>();\r\n        for (Map.Entry<String, Map<KeyExtent, List<Range>>> tserverBin : binnedRanges.entrySet()) {\r\n            String ip = tserverBin.getKey().split(\":\", 2)[0];\r\n            String location = hostNameCache.get(ip);\r\n            if (location == null) {\r\n                InetAddress inetAddress = InetAddress.getByName(ip);\r\n                location = inetAddress.getHostName();\r\n                hostNameCache.put(ip, location);\r\n            }\r\n            for (Map.Entry<KeyExtent, List<Range>> extentRanges : tserverBin.getValue().entrySet()) {\r\n                Range ke = extentRanges.getKey().toDataRange();\r\n                for (Range r : extentRanges.getValue()) {\r\n                    if (autoAdjust) {\r\n                                                splits.add(new RangeInputSplit(tableName, tableId, ke.clip(r), new String[] { location }));\r\n                    } else {\r\n                                                ArrayList<String> locations = splitsToAdd.get(r);\r\n                        if (locations == null)\r\n                            locations = new ArrayList<String>(1);\r\n                        locations.add(location);\r\n                        splitsToAdd.put(r, locations);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!autoAdjust)\r\n            for (Map.Entry<Range, ArrayList<String>> entry : splitsToAdd.entrySet()) splits.add(new RangeInputSplit(tableName, tableId, entry.getKey(), entry.getValue().toArray(new String[0])));\r\n    }\r\n    return splits.toArray(new InputSplit[splits.size()]);\r\n}","lc":2.9545454545,"pi":1.8516746411,"ma":3.8,"nbd":1.5,"ml":1.5833333333,"d":0.7976190476,"mi":-1.296546864,"fo":4.3333333333,"r":-0.0263157895,"e":5.8414135302}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4345_4f08e6f2","label":1,"code":"private Url decryptUrl(final Request request, final Url encryptedUrl) {\r\n    if (encryptedUrl.getSegments().isEmpty() && encryptedUrl.getQueryParameters().isEmpty()) {\r\n        return encryptedUrl;\r\n    }\r\n    List<String> encryptedSegments = encryptedUrl.getSegments();\r\n    if (encryptedSegments.size() < 1) {\r\n        return null;\r\n    }\r\n    Url url = new Url(request.getCharset());\r\n    try {\r\n        String encryptedUrlString = encryptedSegments.get(0);\r\n        if (Strings.isEmpty(encryptedUrlString)) {\r\n            return null;\r\n        }\r\n        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\r\n        if (decryptedUrl == null) {\r\n            return null;\r\n        }\r\n        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());\r\n        int originalNumberOfSegments = originalUrl.getSegments().size();\r\n        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();\r\n        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\r\n        int segNo = 1;\r\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\r\n            if (segNo > originalNumberOfSegments || !generator.next().equals(encryptedSegments.get(segNo))) {\r\n                break;\r\n            }\r\n            \/\/ unmodified segment\r\n            url.getSegments().add(originalUrl.getSegments().get(segNo - 1));\r\n        }\r\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\r\n            \/\/ modified or additional segment\r\n            url.getSegments().add(encryptedUrl.getSegments().get(segNo));\r\n        }\r\n        url.getQueryParameters().addAll(originalUrl.getQueryParameters());\r\n    } catch (Exception e) {\r\n        log.error(\"Error decrypting URL\", e);\r\n        url = null;\r\n    }\r\n    return url;\r\n}","code_comment":null,"code_no_comment":"private Url decryptUrl(final Request request, final Url encryptedUrl) {\r\n    if (encryptedUrl.getSegments().isEmpty() && encryptedUrl.getQueryParameters().isEmpty()) {\r\n        return encryptedUrl;\r\n    }\r\n    List<String> encryptedSegments = encryptedUrl.getSegments();\r\n    if (encryptedSegments.size() < 1) {\r\n        return null;\r\n    }\r\n    Url url = new Url(request.getCharset());\r\n    try {\r\n        String encryptedUrlString = encryptedSegments.get(0);\r\n        if (Strings.isEmpty(encryptedUrlString)) {\r\n            return null;\r\n        }\r\n        String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\r\n        if (decryptedUrl == null) {\r\n            return null;\r\n        }\r\n        Url originalUrl = Url.parse(decryptedUrl, request.getCharset());\r\n        int originalNumberOfSegments = originalUrl.getSegments().size();\r\n        int encryptedNumberOfSegments = encryptedUrl.getSegments().size();\r\n        HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\r\n        int segNo = 1;\r\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\r\n            if (segNo > originalNumberOfSegments || !generator.next().equals(encryptedSegments.get(segNo))) {\r\n                break;\r\n            }\r\n                        url.getSegments().add(originalUrl.getSegments().get(segNo - 1));\r\n        }\r\n        for (; segNo < encryptedNumberOfSegments; segNo++) {\r\n                        url.getSegments().add(encryptedUrl.getSegments().get(segNo));\r\n        }\r\n        url.getQueryParameters().addAll(originalUrl.getQueryParameters());\r\n    } catch (Exception e) {\r\n        log.error(\"Error decrypting URL\", e);\r\n        url = null;\r\n    }\r\n    return url;\r\n}","lc":1.1363636364,"pi":0.1626794258,"ma":1.2,"nbd":0.5,"ml":1.25,"d":1.7976190476,"mi":-0.7265680056,"fo":2.1666666667,"r":-0.0263157895,"e":3.5052114129}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-519_26a61077","label":1,"code":"\/**\r\n * Fits Gaussian function to the observed points.\r\n * It will call the base class\r\n * {@link CurveFitter#fit(\r\n * org.apache.commons.math.analysis.ParametricUnivariateRealFunction,\r\n * double[]) fit} method.\r\n *\r\n * @return the Gaussian function that best fits the observed points.\r\n *\/\r\npublic double[] fit() {\r\n    return fit(new Gaussian.Parametric(), (new ParameterGuesser(getObservations())).guess());\r\n}","code_comment":"\/**\r\n * Fits Gaussian function to the observed points.\r\n * It will call the base class\r\n * {@link CurveFitter#fit(\r\n * org.apache.commons.math.analysis.ParametricUnivariateRealFunction,\r\n * double[]) fit} method.\r\n *\r\n * @return the Gaussian function that best fits the observed points.\r\n *\/\r\n","code_no_comment":"public double[] fit() {\r\n    return fit(new Gaussian.Parametric(), (new ParameterGuesser(getObservations())).guess());\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0132487667,"fo":-0.25,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-1677_01a3dd66","label":1,"code":"\/**\r\n *  @see Component#onComponentTag(ComponentTag)\r\n *  @param tag\r\n *             the abstraction representing html tag of this component\r\n *\/\r\n@Override\r\nprotected void onComponentTag(final ComponentTag tag) {\r\n    \/\/ Default handling for component tag\r\n    super.onComponentTag(tag);\r\n    \/\/ must be attached to <input type=\"radio\" ...\/> tag\r\n    checkComponentTag(tag, \"input\");\r\n    checkComponentTagAttribute(tag, \"type\", \"radio\");\r\n    final String value = getValue();\r\n    RadioGroup<?> group = this.group;\r\n    if (group == null) {\r\n        group = findParent(RadioGroup.class);\r\n        if (group == null) {\r\n            throw new WicketRuntimeException(\"Radio component [\" + getPath() + \"] cannot find its parent RadioGroup. All Radio components must be a child of or below in the hierarchy of a RadioGroup component.\");\r\n        }\r\n    }\r\n    \/\/ assign name and value\r\n    tag.put(\"name\", group.getInputName());\r\n    tag.put(\"value\", value);\r\n    \/\/ checked attribute, first check if there was a raw input on the group.\r\n    if (group.hasRawInput()) {\r\n        String rawInput = group.getRawInput();\r\n        if (rawInput != null && rawInput.equals(value)) {\r\n            tag.put(\"checked\", \"checked\");\r\n        }\r\n    } else if (Objects.equal(group.getDefaultModelObject(), getDefaultModelObject())) {\r\n        tag.put(\"checked\", \"checked\");\r\n    }\r\n    if (group.wantOnSelectionChangedNotifications()) {\r\n        \/\/ url that points to this components IOnChangeListener method\r\n        CharSequence url = group.urlFor(IOnChangeListener.INTERFACE);\r\n        Form<?> form = group.findParent(Form.class);\r\n        if (form != null) {\r\n            RequestContext rc = RequestContext.get();\r\n            if (rc.isPortletRequest()) {\r\n                \/\/ restore url back to real wicket path as its going to be interpreted by the\r\n                \/\/ form itself\r\n                url = ((PortletRequestContext) rc).getLastEncodedPath();\r\n            }\r\n            tag.put(\"onclick\", form.getJsForInterfaceUrl(url));\r\n        } else {\r\n            \/\/ TODO: following doesn't work with portlets, should be posted to a dynamic hidden\r\n            \/\/ form\r\n            \/\/ with an ActionURL or something\r\n            \/\/ NOTE: do not encode the url as that would give invalid\r\n            \/\/ JavaScript\r\n            tag.put(\"onclick\", \"window.location.href='\" + url + (url.toString().indexOf('?') > -1 ? \"&amp;\" : \"?\") + group.getInputName() + \"=' + this.value;\");\r\n        }\r\n    }\r\n    if (!isEnabledInHierarchy()) {\r\n        tag.put(ATTR_DISABLED, ATTR_DISABLED);\r\n    }\r\n}","code_comment":"\/**\r\n *  @see Component#onComponentTag(ComponentTag)\r\n *  @param tag\r\n *             the abstraction representing html tag of this component\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void onComponentTag(final ComponentTag tag) {\r\n        super.onComponentTag(tag);\r\n        checkComponentTag(tag, \"input\");\r\n    checkComponentTagAttribute(tag, \"type\", \"radio\");\r\n    final String value = getValue();\r\n    RadioGroup<?> group = this.group;\r\n    if (group == null) {\r\n        group = findParent(RadioGroup.class);\r\n        if (group == null) {\r\n            throw new WicketRuntimeException(\"Radio component [\" + getPath() + \"] cannot find its parent RadioGroup. All Radio components must be a child of or below in the hierarchy of a RadioGroup component.\");\r\n        }\r\n    }\r\n        tag.put(\"name\", group.getInputName());\r\n    tag.put(\"value\", value);\r\n        if (group.hasRawInput()) {\r\n        String rawInput = group.getRawInput();\r\n        if (rawInput != null && rawInput.equals(value)) {\r\n            tag.put(\"checked\", \"checked\");\r\n        }\r\n    } else if (Objects.equal(group.getDefaultModelObject(), getDefaultModelObject())) {\r\n        tag.put(\"checked\", \"checked\");\r\n    }\r\n    if (group.wantOnSelectionChangedNotifications()) {\r\n                CharSequence url = group.urlFor(IOnChangeListener.INTERFACE);\r\n        Form<?> form = group.findParent(Form.class);\r\n        if (form != null) {\r\n            RequestContext rc = RequestContext.get();\r\n            if (rc.isPortletRequest()) {\r\n                                                url = ((PortletRequestContext) rc).getLastEncodedPath();\r\n            }\r\n            tag.put(\"onclick\", form.getJsForInterfaceUrl(url));\r\n        } else {\r\n                                                                        tag.put(\"onclick\", \"window.location.href='\" + url + (url.toString().indexOf('?') > -1 ? \"&amp;\" : \"?\") + group.getInputName() + \"=' + this.value;\");\r\n        }\r\n    }\r\n    if (!isEnabledInHierarchy()) {\r\n        tag.put(ATTR_DISABLED, ATTR_DISABLED);\r\n    }\r\n}","lc":1.1818181818,"pi":0.3540669856,"ma":1.6,"nbd":0.5,"ml":1.5833333333,"d":1.2361111111,"mi":-0.7649048626,"fo":2.0833333333,"r":-0.0263157895,"e":2.8173348778}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-43_668f08f2","label":1,"code":"public Id doCommit() throws Exception {\r\n    if (staged.isEmpty()) {\r\n        \/\/ nothing to commit\r\n        return baseRevId;\r\n    }\r\n    Id currentHead = store.getHeadCommitId();\r\n    if (!currentHead.equals(baseRevId)) {\r\n        \/\/ todo gracefully handle certain conflicts (e.g. changes on moved sub-trees, competing deletes etc)\r\n        \/\/ update base revision to new head\r\n        baseRevId = currentHead;\r\n        \/\/ clear staging area\r\n        staged.clear();\r\n        \/\/ replay change log on new base revision\r\n        \/\/ copy log in order to avoid concurrent modifications\r\n        List<Change> log = new ArrayList<Change>(changeLog);\r\n        for (Change change : log) {\r\n            change.apply();\r\n        }\r\n    }\r\n    Id rootNodeId = persistStagedNodes();\r\n    Id newRevId;\r\n    store.lockHead();\r\n    try {\r\n        currentHead = store.getHeadCommitId();\r\n        if (!currentHead.equals(baseRevId)) {\r\n            StoredNode baseRoot = store.getRootNode(baseRevId);\r\n            StoredNode theirRoot = store.getRootNode(currentHead);\r\n            StoredNode ourRoot = store.getNode(rootNodeId);\r\n            rootNodeId = mergeTree(baseRoot, ourRoot, theirRoot);\r\n            baseRevId = currentHead;\r\n        }\r\n        if (store.getCommit(currentHead).getRootNodeId().equals(rootNodeId)) {\r\n            \/\/ no need to create new commit object\/update head revision\r\n            return currentHead;\r\n        }\r\n        MutableCommit newCommit = new MutableCommit();\r\n        newCommit.setParentId(baseRevId);\r\n        newCommit.setCommitTS(System.currentTimeMillis());\r\n        newCommit.setMsg(msg);\r\n        newCommit.setRootNodeId(rootNodeId);\r\n        newRevId = store.putHeadCommit(newCommit);\r\n    } finally {\r\n        store.unlockHead();\r\n    }\r\n    \/\/ reset instance in order to be reusable\r\n    staged.clear();\r\n    changeLog.clear();\r\n    return newRevId;\r\n}","code_comment":null,"code_no_comment":"public Id doCommit() throws Exception {\r\n    if (staged.isEmpty()) {\r\n                return baseRevId;\r\n    }\r\n    Id currentHead = store.getHeadCommitId();\r\n    if (!currentHead.equals(baseRevId)) {\r\n                        baseRevId = currentHead;\r\n                staged.clear();\r\n                        List<Change> log = new ArrayList<Change>(changeLog);\r\n        for (Change change : log) {\r\n            change.apply();\r\n        }\r\n    }\r\n    Id rootNodeId = persistStagedNodes();\r\n    Id newRevId;\r\n    store.lockHead();\r\n    try {\r\n        currentHead = store.getHeadCommitId();\r\n        if (!currentHead.equals(baseRevId)) {\r\n            StoredNode baseRoot = store.getRootNode(baseRevId);\r\n            StoredNode theirRoot = store.getRootNode(currentHead);\r\n            StoredNode ourRoot = store.getNode(rootNodeId);\r\n            rootNodeId = mergeTree(baseRoot, ourRoot, theirRoot);\r\n            baseRevId = currentHead;\r\n        }\r\n        if (store.getCommit(currentHead).getRootNodeId().equals(rootNodeId)) {\r\n                        return currentHead;\r\n        }\r\n        MutableCommit newCommit = new MutableCommit();\r\n        newCommit.setParentId(baseRevId);\r\n        newCommit.setCommitTS(System.currentTimeMillis());\r\n        newCommit.setMsg(msg);\r\n        newCommit.setRootNodeId(rootNodeId);\r\n        newRevId = store.putHeadCommit(newCommit);\r\n    } finally {\r\n        store.unlockHead();\r\n    }\r\n        staged.clear();\r\n    changeLog.clear();\r\n    return newRevId;\r\n}","lc":1.2272727273,"pi":0.0956937799,"ma":0.4,"nbd":0.0,"ml":0.3333333333,"d":0.0873015873,"mi":-0.6983791402,"fo":1.5833333333,"r":-0.0263157895,"e":0.4834978648}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1822_3e83a4c1","label":1,"code":"\/**\r\n * Increment the value.\r\n *\r\n * @param property the key\r\n * @param value the increment\r\n *\/\r\npublic void increment(@Nonnull String property, long value) {\r\n    Operation op = new Operation();\r\n    op.type = Operation.Type.INCREMENT;\r\n    op.value = value;\r\n    changes.put(new Key(property, null), op);\r\n}","code_comment":"\/**\r\n * Increment the value.\r\n *\r\n * @param property the key\r\n * @param value the increment\r\n *\/\r\n","code_no_comment":"public void increment(@Nonnull String property, long value) {\r\n    Operation op = new Operation();\r\n    op.type = Operation.Type.INCREMENT;\r\n    op.value = value;\r\n    changes.put(new Key(property, null), op);\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4720225511,"fo":-0.4166666667,"r":2.0526315789,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5187_8cadc344","label":3,"code":"protected void doStop() throws Exception {\r\n    \/\/ close JMX Connector\r\n    if (cs != null) {\r\n        try {\r\n            cs.stop();\r\n        } catch (IOException e) {\r\n            LOG.debug(\"Error occurred during stopping JMXConnectorService: \" + cs + \". This exception will be ignored.\");\r\n        }\r\n        cs = null;\r\n    }\r\n    if (mbeansRegistered.isEmpty()) {\r\n        return;\r\n    }\r\n    \/\/ Using the array to hold the busMBeans to avoid the CurrentModificationException\r\n    ObjectName[] mBeans = mbeansRegistered.toArray(new ObjectName[mbeansRegistered.size()]);\r\n    int caught = 0;\r\n    for (ObjectName name : mBeans) {\r\n        try {\r\n            mbeansRegistered.remove(name);\r\n            unregister(name);\r\n        } catch (Exception e) {\r\n            LOG.info(\"Exception unregistering MBean with name \" + name, e);\r\n            caught++;\r\n        }\r\n    }\r\n    if (caught > 0) {\r\n        LOG.warn(\"A number of \" + caught + \" exceptions caught while unregistering MBeans during stop operation.\" + \" See INFO log for details.\");\r\n    }\r\n}","code_comment":null,"code_no_comment":"protected void doStop() throws Exception {\r\n        if (cs != null) {\r\n        try {\r\n            cs.stop();\r\n        } catch (IOException e) {\r\n            LOG.debug(\"Error occurred during stopping JMXConnectorService: \" + cs + \". This exception will be ignored.\");\r\n        }\r\n        cs = null;\r\n    }\r\n    if (mbeansRegistered.isEmpty()) {\r\n        return;\r\n    }\r\n        ObjectName[] mBeans = mbeansRegistered.toArray(new ObjectName[mbeansRegistered.size()]);\r\n    int caught = 0;\r\n    for (ObjectName name : mBeans) {\r\n        try {\r\n            mbeansRegistered.remove(name);\r\n            unregister(name);\r\n        } catch (Exception e) {\r\n            LOG.info(\"Exception unregistering MBean with name \" + name, e);\r\n            caught++;\r\n        }\r\n    }\r\n    if (caught > 0) {\r\n        LOG.warn(\"A number of \" + caught + \" exceptions caught while unregistering MBeans during stop operation.\" + \" See INFO log for details.\");\r\n    }\r\n}","lc":0.5909090909,"pi":0.2822966507,"ma":0.6,"nbd":0.0,"ml":0.0833333333,"d":0.3333333333,"mi":-0.4114164905,"fo":0.25,"r":0.0,"e":0.3321865113}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1081_4ce4e3c9","label":3,"code":"@Override\r\npublic boolean apply(Tree tree) {\r\n    return !tree.getName().startsWith(\":\");\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean apply(Tree tree) {\r\n    return !tree.getName().startsWith(\":\");\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8314305849,"fo":-0.3333333333,"r":1.5,"e":-0.1627934049}
{"project_name":"Closure","project_version":"13","label":2,"code":"private void traverse(Node node) {\r\n    \/\/ and revisit immediately.\r\n    if (!shouldVisit(node)) {\r\n        return;\r\n    }\r\n    int visits = 0;\r\n    do {\r\n        Node c = node.getFirstChild();\r\n        while (c != null) {\r\n            traverse(c);\r\n            Node next = c.getNext();\r\n            c = next;\r\n        }\r\n        visit(node);\r\n        visits++;\r\n        Preconditions.checkState(visits < 10000, \"too many interations\");\r\n    } while (shouldRetraverse(node));\r\n    exitNode(node);\r\n}","code_comment":null,"code_no_comment":"private void traverse(Node node) {\r\n        if (!shouldVisit(node)) {\r\n        return;\r\n    }\r\n    int visits = 0;\r\n    do {\r\n        Node c = node.getFirstChild();\r\n        while (c != null) {\r\n            traverse(c);\r\n            Node next = c.getNext();\r\n            c = next;\r\n        }\r\n        visit(node);\r\n        visits++;\r\n        Preconditions.checkState(visits < 10000, \"too many interations\");\r\n    } while (shouldRetraverse(node));\r\n    exitNode(node);\r\n}","lc":0.1818181818,"pi":0.2727272727,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":0.3452380952,"mi":-0.1393939394,"fo":0.1666666667,"r":0.1842105263,"e":0.1549466065}
{"project_name":"Cli","project_version":"40","label":3,"code":"\/**\r\n * Returns the <code>Object<\/code> of type <code>clazz<\/code>\r\n * with the value of <code>str<\/code>.\r\n *\r\n * @param str the command line value\r\n * @param clazz the type of argument\r\n * @return The instance of <code>clazz<\/code> initialised with\r\n * the value of <code>str<\/code>.\r\n * @throws ParseException if the value creation for the given class failed\r\n *\/\r\n\/\/ returned value will have type T because it is fixed by clazz\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException {\r\n    if (PatternOptionBuilder.STRING_VALUE == clazz) {\r\n        return (T) str;\r\n    } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) {\r\n        return (T) createObject(str);\r\n    } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) {\r\n        return (T) createNumber(str);\r\n    } else if (PatternOptionBuilder.DATE_VALUE == clazz) {\r\n        return (T) createDate(str);\r\n    } else if (PatternOptionBuilder.CLASS_VALUE == clazz) {\r\n        return (T) createClass(str);\r\n    } else if (PatternOptionBuilder.FILE_VALUE == clazz) {\r\n        return (T) createFile(str);\r\n    } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) {\r\n        return (T) openFile(str);\r\n    } else if (PatternOptionBuilder.FILES_VALUE == clazz) {\r\n        return (T) createFiles(str);\r\n    } else if (PatternOptionBuilder.URL_VALUE == clazz) {\r\n        return (T) createURL(str);\r\n    } else {\r\n        return null;\r\n    }\r\n}","code_comment":"\/**\r\n * Returns the <code>Object<\/code> of type <code>clazz<\/code>\r\n * with the value of <code>str<\/code>.\r\n *\r\n * @param str the command line value\r\n * @param clazz the type of argument\r\n * @return The instance of <code>clazz<\/code> initialised with\r\n * the value of <code>str<\/code>.\r\n * @throws ParseException if the value creation for the given class failed\r\n *\/\r\n","code_no_comment":"@SuppressWarnings(\"unchecked\")\r\npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException {\r\n    if (PatternOptionBuilder.STRING_VALUE == clazz) {\r\n        return (T) str;\r\n    } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) {\r\n        return (T) createObject(str);\r\n    } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) {\r\n        return (T) createNumber(str);\r\n    } else if (PatternOptionBuilder.DATE_VALUE == clazz) {\r\n        return (T) createDate(str);\r\n    } else if (PatternOptionBuilder.CLASS_VALUE == clazz) {\r\n        return (T) createClass(str);\r\n    } else if (PatternOptionBuilder.FILE_VALUE == clazz) {\r\n        return (T) createFile(str);\r\n    } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) {\r\n        return (T) openFile(str);\r\n    } else if (PatternOptionBuilder.FILES_VALUE == clazz) {\r\n        return (T) createFiles(str);\r\n    } else if (PatternOptionBuilder.URL_VALUE == clazz) {\r\n        return (T) createURL(str);\r\n    } else {\r\n        return null;\r\n    }\r\n}","lc":0.4545454545,"pi":-0.1387559809,"ma":1.2,"nbd":3.5,"ml":0.4166666667,"d":-0.3650793651,"mi":-0.4046511628,"fo":0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-349_4cc9a49d","label":3,"code":"\/**\r\n * Set the Poisson mean for the distribution. The mean value must be\r\n * positive; otherwise an <code>IllegalArgument<\/code> is thrown.\r\n *\r\n * @param p the Poisson mean value\r\n * @throws IllegalArgumentException if p &le; 0\r\n * @deprecated as of 2.1 (class will become immutable in 3.0)\r\n *\/\r\n@Deprecated\r\npublic void setMean(double p) {\r\n    setNormalAndMeanInternal(normal, p);\r\n}","code_comment":"\/**\r\n * Set the Poisson mean for the distribution. The mean value must be\r\n * positive; otherwise an <code>IllegalArgument<\/code> is thrown.\r\n *\r\n * @param p the Poisson mean value\r\n * @throws IllegalArgumentException if p &le; 0\r\n * @deprecated as of 2.1 (class will become immutable in 3.0)\r\n *\/\r\n","code_no_comment":"@Deprecated\r\npublic void setMean(double p) {\r\n    setNormalAndMeanInternal(normal, p);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9134601832,"fo":-0.4166666667,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"Compress","project_version":"22","label":3,"code":"private int setupRandPartA() throws IOException {\r\n    if (this.su_i2 <= this.last) {\r\n        this.su_chPrev = this.su_ch2;\r\n        int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\r\n        this.su_tPos = this.data.tt[this.su_tPos];\r\n        if (this.su_rNToGo == 0) {\r\n            this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1;\r\n            if (++this.su_rTPos == 512) {\r\n                this.su_rTPos = 0;\r\n            }\r\n        } else {\r\n            this.su_rNToGo--;\r\n        }\r\n        this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0;\r\n        this.su_i2++;\r\n        this.currentChar = su_ch2Shadow;\r\n        this.currentState = RAND_PART_B_STATE;\r\n        this.crc.updateCRC(su_ch2Shadow);\r\n        return su_ch2Shadow;\r\n    } else {\r\n        endBlock();\r\n        initBlock();\r\n        return setupBlock();\r\n    }\r\n}","code_comment":null,"code_no_comment":"private int setupRandPartA() throws IOException {\r\n    if (this.su_i2 <= this.last) {\r\n        this.su_chPrev = this.su_ch2;\r\n        int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\r\n        this.su_tPos = this.data.tt[this.su_tPos];\r\n        if (this.su_rNToGo == 0) {\r\n            this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1;\r\n            if (++this.su_rTPos == 512) {\r\n                this.su_rTPos = 0;\r\n            }\r\n        } else {\r\n            this.su_rNToGo--;\r\n        }\r\n        this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0;\r\n        this.su_i2++;\r\n        this.currentChar = su_ch2Shadow;\r\n        this.currentState = RAND_PART_B_STATE;\r\n        this.crc.updateCRC(su_ch2Shadow);\r\n        return su_ch2Shadow;\r\n    } else {\r\n        endBlock();\r\n        initBlock();\r\n        return setupBlock();\r\n    }\r\n}","lc":0.5,"pi":0.2344497608,"ma":0.2,"nbd":0.5,"ml":0.25,"d":0.9384920635,"mi":-0.3750528541,"fo":-0.0833333333,"r":-0.0263157895,"e":0.8396420071}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1807_077efee5","label":3,"code":"\/**\r\n * Create a simple revision id. The format is similar to MongoDB ObjectId.\r\n *\r\n * @param clusterId the unique machineId + processId\r\n * @return the unique revision id\r\n *\/\r\nstatic Revision newRevision(int clusterId) {\r\n    long timestamp = getCurrentTimestamp();\r\n    int c;\r\n    synchronized (Revision.class) {\r\n        if (timestamp == lastRevisionTimestamp) {\r\n            c = ++lastRevisionCount;\r\n        } else {\r\n            lastRevisionTimestamp = timestamp;\r\n            lastRevisionCount = c = 0;\r\n        }\r\n    }\r\n    return new Revision(timestamp, c, clusterId);\r\n}","code_comment":"\/**\r\n * Create a simple revision id. The format is similar to MongoDB ObjectId.\r\n *\r\n * @param clusterId the unique machineId + processId\r\n * @return the unique revision id\r\n *\/\r\n","code_no_comment":"static Revision newRevision(int clusterId) {\r\n    long timestamp = getCurrentTimestamp();\r\n    int c;\r\n    synchronized (Revision.class) {\r\n        if (timestamp == lastRevisionTimestamp) {\r\n            c = ++lastRevisionCount;\r\n        } else {\r\n            lastRevisionTimestamp = timestamp;\r\n            lastRevisionCount = c = 0;\r\n        }\r\n    }\r\n    return new Revision(timestamp, c, clusterId);\r\n}","lc":-0.0454545455,"pi":0.5023923445,"ma":-0.4,"nbd":0.0,"ml":-0.1666666667,"d":0.0515873016,"mi":0.1131782946,"fo":-0.4166666667,"r":2.0789473684,"e":-0.0624770203}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4020_081cdeb2","label":1,"code":"protected void removeCachingDecoration(Url url, PageParameters parameters) {\r\n    final List<String> segments = url.getSegments();\r\n    if (segments.isEmpty() == false) {\r\n        final int lastSegmentAt = segments.size() - 1;\r\n        final ResourceUrl resourceUrl = new ResourceUrl(segments.get(lastSegmentAt), parameters);\r\n        getCachingStrategy().undecorateUrl(resourceUrl);\r\n        if (Strings.isEmpty(resourceUrl.getFileName())) {\r\n            throw new IllegalStateException(\"caching strategy returned empty name for \" + resourceUrl);\r\n        }\r\n        segments.set(lastSegmentAt, resourceUrl.getFileName());\r\n    }\r\n}","code_comment":null,"code_no_comment":"protected void removeCachingDecoration(Url url, PageParameters parameters) {\r\n    final List<String> segments = url.getSegments();\r\n    if (segments.isEmpty() == false) {\r\n        final int lastSegmentAt = segments.size() - 1;\r\n        final ResourceUrl resourceUrl = new ResourceUrl(segments.get(lastSegmentAt), parameters);\r\n        getCachingStrategy().undecorateUrl(resourceUrl);\r\n        if (Strings.isEmpty(resourceUrl.getFileName())) {\r\n            throw new IllegalStateException(\"caching strategy returned empty name for \" + resourceUrl);\r\n        }\r\n        segments.set(lastSegmentAt, resourceUrl.getFileName());\r\n    }\r\n}","lc":-0.0909090909,"pi":0.2248803828,"ma":0.0,"nbd":0.0,"ml":0.0,"d":0.2698412698,"mi":0.0241014799,"fo":0.3333333333,"r":-0.0263157895,"e":0.1668873867}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1705_5308ac83","label":1,"code":"@Override\r\npublic void write(final DataOutputView out) throws IOException {\r\n    out.writeInt(this.inetAddress.getAddress().length);\r\n    out.write(this.inetAddress.getAddress());\r\n    out.writeInt(this.dataPort);\r\n    StringUtils.writeNullableString(fqdnHostName, out);\r\n    StringUtils.writeNullableString(hostName, out);\r\n    out.writeBoolean(fqdnHostNameIsIP);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void write(final DataOutputView out) throws IOException {\r\n    out.writeInt(this.inetAddress.getAddress().length);\r\n    out.write(this.inetAddress.getAddress());\r\n    out.writeInt(this.dataPort);\r\n    StringUtils.writeNullableString(fqdnHostName, out);\r\n    StringUtils.writeNullableString(hostName, out);\r\n    out.writeBoolean(fqdnHostNameIsIP);\r\n}","lc":-0.2272727273,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.267653277,"fo":0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1985_f620b79b","label":1,"code":"@Nonnull\r\nprivate static String getKeyValue(String key, String userId) {\r\n    return key + userId;\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\nprivate static String getKeyValue(String key, String userId) {\r\n    return key + userId;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8353770261,"fo":-0.5,"r":1.4473684211,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"public update_result getResult(I iface, update_args args) throws org.apache.thrift.TException {\r\n    update_result result = new update_result();\r\n    try {\r\n        iface.update(args.writer, args.cells);\r\n    } catch (UnknownWriter ouch1) {\r\n        result.ouch1 = ouch1;\r\n    } catch (MutationsRejectedException ouch2) {\r\n        result.ouch2 = ouch2;\r\n    }\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"public update_result getResult(I iface, update_args args) throws org.apache.thrift.TException {\r\n    update_result result = new update_result();\r\n    try {\r\n        iface.update(args.writer, args.cells);\r\n    } catch (UnknownWriter ouch1) {\r\n        result.ouch1 = ouch1;\r\n    } catch (MutationsRejectedException ouch2) {\r\n        result.ouch2 = ouch2;\r\n    }\r\n    return result;\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.1317829457,"fo":-0.4166666667,"r":0.0,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-343_f6dd42b4","label":0,"code":"\/**\r\n * Find a zero in the given interval.\r\n * <p>\r\n * Requires that the values of the function at the endpoints have opposite\r\n * signs. An <code>IllegalArgumentException<\/code> is thrown if this is not\r\n * the case.<\/p>\r\n *\r\n * @param f the function to solve\r\n * @param min the lower bound for the interval.\r\n * @param max the upper bound for the interval.\r\n * @return the value where the function is zero\r\n * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\r\n * @throws FunctionEvaluationException if an error occurs evaluating the\r\n * function\r\n * @throws IllegalArgumentException if min is not less than max or the\r\n * signs of the values of the function at the endpoints are not opposites\r\n *\/\r\npublic double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    clearResult();\r\n    verifyInterval(min, max);\r\n    double ret = Double.NaN;\r\n    double yMin = f.value(min);\r\n    double yMax = f.value(max);\r\n    \/\/ Verify bracketing\r\n    double sign = yMin * yMax;\r\n    if (sign > 0) {\r\n        \/\/ check if either value is close to a zero\r\n        if (Math.abs(yMin) <= functionValueAccuracy) {\r\n            setResult(min, 0);\r\n            ret = min;\r\n        } else if (Math.abs(yMax) <= functionValueAccuracy) {\r\n            setResult(max, 0);\r\n            ret = max;\r\n        } else {\r\n            \/\/ neither value is close to zero and min and max do not bracket root.\r\n            throw MathRuntimeException.createIllegalArgumentException(\"function values at endpoints do not have different signs.  \" + \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\", min, max, yMin, yMax);\r\n        }\r\n    } else if (sign < 0) {\r\n        \/\/ solve using only the first endpoint as initial guess\r\n        ret = solve(f, min, yMin, max, yMax, min, yMin);\r\n    } else {\r\n        \/\/ either min or max is a root\r\n        if (yMin == 0.0) {\r\n            ret = min;\r\n        } else {\r\n            ret = max;\r\n        }\r\n    }\r\n    return ret;\r\n}","code_comment":"\/**\r\n * Find a zero in the given interval.\r\n * <p>\r\n * Requires that the values of the function at the endpoints have opposite\r\n * signs. An <code>IllegalArgumentException<\/code> is thrown if this is not\r\n * the case.<\/p>\r\n *\r\n * @param f the function to solve\r\n * @param min the lower bound for the interval.\r\n * @param max the upper bound for the interval.\r\n * @return the value where the function is zero\r\n * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\r\n * @throws FunctionEvaluationException if an error occurs evaluating the\r\n * function\r\n * @throws IllegalArgumentException if min is not less than max or the\r\n * signs of the values of the function at the endpoints are not opposites\r\n *\/\r\n","code_no_comment":"public double solve(final UnivariateRealFunction f, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    clearResult();\r\n    verifyInterval(min, max);\r\n    double ret = Double.NaN;\r\n    double yMin = f.value(min);\r\n    double yMax = f.value(max);\r\n        double sign = yMin * yMax;\r\n    if (sign > 0) {\r\n                if (Math.abs(yMin) <= functionValueAccuracy) {\r\n            setResult(min, 0);\r\n            ret = min;\r\n        } else if (Math.abs(yMax) <= functionValueAccuracy) {\r\n            setResult(max, 0);\r\n            ret = max;\r\n        } else {\r\n                        throw MathRuntimeException.createIllegalArgumentException(\"function values at endpoints do not have different signs.  \" + \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\", min, max, yMin, yMax);\r\n        }\r\n    } else if (sign < 0) {\r\n                ret = solve(f, min, yMin, max, yMax, min, yMin);\r\n    } else {\r\n                if (yMin == 0.0) {\r\n            ret = min;\r\n        } else {\r\n            ret = max;\r\n        }\r\n    }\r\n    return ret;\r\n}","lc":0.6363636364,"pi":0.3301435407,"ma":0.6,"nbd":0.5,"ml":0.5,"d":1.2222222222,"mi":-0.4841437632,"fo":0.3333333333,"r":-0.0263157895,"e":1.488432081}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-412_be2fdba7","label":1,"code":"\/**\r\n * Advances to the next K,V pair.\r\n *\r\n * @throws IOException\r\n *           if an I\/O error occurs.\r\n * @exception IllegalStateException\r\n *              if called before seek.\r\n * @exception NoSuchElementException\r\n *              if next element doesn't exist.\r\n *\/\r\nvoid next() throws IOException;","code_comment":"\/**\r\n * Advances to the next K,V pair.\r\n *\r\n * @throws IOException\r\n *           if an I\/O error occurs.\r\n * @exception IllegalStateException\r\n *              if called before seek.\r\n * @exception NoSuchElementException\r\n *              if next element doesn't exist.\r\n *\/\r\n","code_no_comment":"void next() throws IOException;","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.7424947146,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2559_dfa87520","label":1,"code":"\/**\r\n * @param propertyName name of a property.\r\n * @return the property configuration or <code>null<\/code> if this\r\n *         indexing rule does not contain a configuration for the given\r\n *         property.\r\n *\/\r\n@CheckForNull\r\npublic PropertyDefinition getConfig(String propertyName) {\r\n    PropertyDefinition config = propConfigs.get(propertyName);\r\n    if (config != null) {\r\n        return config;\r\n    } else if (namePatterns.size() > 0) {\r\n        \/\/ check patterns\r\n        for (NamePattern np : namePatterns) {\r\n            if (np.matches(propertyName)) {\r\n                return np.getConfig();\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":"\/**\r\n * @param propertyName name of a property.\r\n * @return the property configuration or <code>null<\/code> if this\r\n *         indexing rule does not contain a configuration for the given\r\n *         property.\r\n *\/\r\n","code_no_comment":"@CheckForNull\r\npublic PropertyDefinition getConfig(String propertyName) {\r\n    PropertyDefinition config = propConfigs.get(propertyName);\r\n    if (config != null) {\r\n        return config;\r\n    } else if (namePatterns.size() > 0) {\r\n                for (NamePattern np : namePatterns) {\r\n            if (np.matches(propertyName)) {\r\n                return np.getConfig();\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}","lc":0.0,"pi":0.8277511962,"ma":0.2,"nbd":1.0,"ml":0.1666666667,"d":-0.0436507937,"mi":0.0345313601,"fo":-0.1666666667,"r":1.5,"e":-0.070503622}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2882_ebe56869","label":1,"code":"\/**\r\n *  Get the real parent container\r\n *\r\n *  @return enclosure's parent markup container\r\n *\/\r\nprivate MarkupContainer getEnclosureParent() {\r\n    MarkupContainer parent = getParent();\r\n    while (parent.isAuto()) {\r\n        parent = parent.getParent();\r\n    }\r\n    if (parent == null) {\r\n        throw new WicketRuntimeException(\"Unable to find parent component which is not a transparent resolver\");\r\n    }\r\n    return parent;\r\n}","code_comment":"\/**\r\n *  Get the real parent container\r\n *\r\n *  @return enclosure's parent markup container\r\n *\/\r\n","code_no_comment":"private MarkupContainer getEnclosureParent() {\r\n    MarkupContainer parent = getParent();\r\n    while (parent.isAuto()) {\r\n        parent = parent.getParent();\r\n    }\r\n    if (parent == null) {\r\n        throw new WicketRuntimeException(\"Unable to find parent component which is not a transparent resolver\");\r\n    }\r\n    return parent;\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0119047619,"mi":0.2865398168,"fo":-0.25,"r":0.9210526316,"e":-0.1089215839}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2065_9da430fb","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected void appendParameters(AppendingStringBuffer url, Map parameters) {\r\n    if (!url.endsWith(\"\/\")) {\r\n        url.append(\"\/\");\r\n    }\r\n    Set parameterNamesToAdd = new HashSet(parameters.keySet());\r\n    \/\/ Find index of last specified parameter\r\n    boolean foundParameter = false;\r\n    int lastSpecifiedParameter = parameterNames.length;\r\n    while (lastSpecifiedParameter != 0 && !foundParameter) {\r\n        foundParameter = parameters.containsKey(parameterNames[--lastSpecifiedParameter]);\r\n    }\r\n    if (foundParameter) {\r\n        for (int i = 0; i <= lastSpecifiedParameter; i++) {\r\n            String parameterName = parameterNames[i];\r\n            final Object param = parameters.get(parameterName);\r\n            String value = param instanceof String[] ? ((String[]) param)[0] : (String) param;\r\n            if (value == null) {\r\n                value = \"\";\r\n            }\r\n            url.append(urlEncodePathComponent(value)).append(\"\/\");\r\n            parameterNamesToAdd.remove(parameterName);\r\n        }\r\n    }\r\n    if (!parameterNamesToAdd.isEmpty()) {\r\n        boolean first = true;\r\n        final Iterator iterator = parameterNamesToAdd.iterator();\r\n        while (iterator.hasNext()) {\r\n            url.append(first ? '?' : '&');\r\n            String parameterName = (String) iterator.next();\r\n            final Object param = parameters.get(parameterName);\r\n            String value = param instanceof String[] ? ((String[]) param)[0] : (String) param;\r\n            url.append(urlEncodeQueryComponent(parameterName)).append(\"=\").append(urlEncodeQueryComponent(value));\r\n            first = false;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void appendParameters(AppendingStringBuffer url, Map parameters) {\r\n    if (!url.endsWith(\"\/\")) {\r\n        url.append(\"\/\");\r\n    }\r\n    Set parameterNamesToAdd = new HashSet(parameters.keySet());\r\n        boolean foundParameter = false;\r\n    int lastSpecifiedParameter = parameterNames.length;\r\n    while (lastSpecifiedParameter != 0 && !foundParameter) {\r\n        foundParameter = parameters.containsKey(parameterNames[--lastSpecifiedParameter]);\r\n    }\r\n    if (foundParameter) {\r\n        for (int i = 0; i <= lastSpecifiedParameter; i++) {\r\n            String parameterName = parameterNames[i];\r\n            final Object param = parameters.get(parameterName);\r\n            String value = param instanceof String[] ? ((String[]) param)[0] : (String) param;\r\n            if (value == null) {\r\n                value = \"\";\r\n            }\r\n            url.append(urlEncodePathComponent(value)).append(\"\/\");\r\n            parameterNamesToAdd.remove(parameterName);\r\n        }\r\n    }\r\n    if (!parameterNamesToAdd.isEmpty()) {\r\n        boolean first = true;\r\n        final Iterator iterator = parameterNamesToAdd.iterator();\r\n        while (iterator.hasNext()) {\r\n            url.append(first ? '?' : '&');\r\n            String parameterName = (String) iterator.next();\r\n            final Object param = parameters.get(parameterName);\r\n            String value = param instanceof String[] ? ((String[]) param)[0] : (String) param;\r\n            url.append(urlEncodeQueryComponent(parameterName)).append(\"=\").append(urlEncodeQueryComponent(value));\r\n            first = false;\r\n        }\r\n    }\r\n}","lc":1.0,"pi":0.5837320574,"ma":1.4,"nbd":0.5,"ml":1.25,"d":1.7202380952,"mi":-0.7057082452,"fo":1.1666666667,"r":-0.0263157895,"e":3.603310224}
