{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-349_4cc9a49d","label":3,"code":"\/**\r\n * Set the Poisson mean for the distribution. The mean value must be\r\n * positive; otherwise an <code>IllegalArgument<\/code> is thrown.\r\n *\r\n * @param z the new distribution\r\n * @param p the Poisson mean value\r\n * @throws IllegalArgumentException if p &le; 0\r\n *\/\r\nprivate void setNormalAndMeanInternal(NormalDistribution z, double p) {\r\n    if (p <= 0) {\r\n        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\r\n    }\r\n    mean = p;\r\n    normal = z;\r\n    normal.setMean(p);\r\n    normal.setStandardDeviation(FastMath.sqrt(p));\r\n}","code_comment":"\/**\r\n * Set the Poisson mean for the distribution. The mean value must be\r\n * positive; otherwise an <code>IllegalArgument<\/code> is thrown.\r\n *\r\n * @param z the new distribution\r\n * @param p the Poisson mean value\r\n * @throws IllegalArgumentException if p &le; 0\r\n *\/\r\n","code_no_comment":"private void setNormalAndMeanInternal(NormalDistribution z, double p) {\r\n    if (p <= 0) {\r\n        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\r\n    }\r\n    mean = p;\r\n    normal = z;\r\n    normal.setMean(p);\r\n    normal.setStandardDeviation(FastMath.sqrt(p));\r\n}","lc":-0.2272727273,"pi":-0.3444976077,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0674603175,"mi":0.2622973925,"fo":-0.1666666667,"r":1.9473684211,"e":-0.0849339857}
{"project_name":"Closure","project_version":"27","label":2,"code":"public static Node tryCatch(Node tryBody, Node catchNode) {\r\n    Preconditions.checkState(tryBody.isBlock());\r\n    Preconditions.checkState(catchNode.isCatch());\r\n    Node catchBody = block(catchNode).copyInformationFrom(catchNode);\r\n    return new Node(Token.TRY, tryBody, catchBody);\r\n}","code_comment":null,"code_no_comment":"public static Node tryCatch(Node tryBody, Node catchNode) {\r\n    Preconditions.checkState(tryBody.isBlock());\r\n    Preconditions.checkState(catchNode.isCatch());\r\n    Node catchBody = block(catchNode).copyInformationFrom(catchNode);\r\n    return new Node(Token.TRY, tryBody, catchBody);\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4700493305,"fo":0.0,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1051_25cf3ccd","label":3,"code":"@Override\r\npublic boolean equals(Object o) {\r\n    if (o == null) {\r\n        return false;\r\n    }\r\n    if (o instanceof Authorizations) {\r\n        Authorizations ao = (Authorizations) o;\r\n        return auths.equals(ao.auths);\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean equals(Object o) {\r\n    if (o == null) {\r\n        return false;\r\n    }\r\n    if (o instanceof Authorizations) {\r\n        Authorizations ao = (Authorizations) o;\r\n        return auths.equals(ao.auths);\r\n    }\r\n    return false;\r\n}","lc":-0.1363636364,"pi":-0.019138756,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":0.0119047619,"mi":0.2295983087,"fo":-0.4166666667,"r":1.8421052632,"e":-0.0968471038}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-9672_84922699","label":3,"code":"@Override\r\npublic FilterDefinition getDefinition() {\r\n    return (FilterDefinition) super.getDefinition();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic FilterDefinition getDefinition() {\r\n    return (FilterDefinition) super.getDefinition();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9737843552,"fo":-0.4166666667,"r":0.8947368421,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-614_6feacf6b","label":1,"code":"@Override\r\n@Nonnull\r\npublic NodeBuilder setNode(String name, NodeState state) {\r\n    write();\r\n    MutableNodeState childState = getWriteState(name);\r\n    if (childState == null) {\r\n        writeState.nodes.remove(name);\r\n        childState = createChildBuilder(name).write();\r\n    }\r\n    childState.reset(state);\r\n    updated();\r\n    return this;\r\n}","code_comment":null,"code_no_comment":"@Override\r\n@Nonnull\r\npublic NodeBuilder setNode(String name, NodeState state) {\r\n    write();\r\n    MutableNodeState childState = getWriteState(name);\r\n    if (childState == null) {\r\n        writeState.nodes.remove(name);\r\n        childState = createChildBuilder(name).write();\r\n    }\r\n    childState.reset(state);\r\n    updated();\r\n    return this;\r\n}","lc":-0.0454545455,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0873015873,"mi":0.0708949965,"fo":0.0833333333,"r":0.2894736842,"e":-0.0735648877}
{"project_name":"JxPath","project_version":"16","label":3,"code":"\/**\r\n * Test a Node.\r\n * @param node to test\r\n * @param test to execute\r\n * @return true if node passes test\r\n *\/\r\npublic static boolean testNode(Node node, NodeTest test) {\r\n    if (test == null) {\r\n        return true;\r\n    }\r\n    if (test instanceof NodeNameTest) {\r\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\r\n            return false;\r\n        }\r\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\r\n        QName testName = nodeNameTest.getNodeName();\r\n        String namespaceURI = nodeNameTest.getNamespaceURI();\r\n        boolean wildcard = nodeNameTest.isWildcard();\r\n        String testPrefix = testName.getPrefix();\r\n        if (wildcard && testPrefix == null) {\r\n            return true;\r\n        }\r\n        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {\r\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\r\n            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));\r\n        }\r\n        return false;\r\n    }\r\n    if (test instanceof NodeTypeTest) {\r\n        int nodeType = node.getNodeType();\r\n        switch(((NodeTypeTest) test).getNodeType()) {\r\n            case Compiler.NODE_TYPE_NODE:\r\n                return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;\r\n            case Compiler.NODE_TYPE_TEXT:\r\n                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;\r\n            case Compiler.NODE_TYPE_COMMENT:\r\n                return nodeType == Node.COMMENT_NODE;\r\n            case Compiler.NODE_TYPE_PI:\r\n                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\r\n        }\r\n        return false;\r\n    }\r\n    if (test instanceof ProcessingInstructionTest) {\r\n        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\r\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\r\n            String nodePI = ((ProcessingInstruction) node).getTarget();\r\n            return testPI.equals(nodePI);\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":"\/**\r\n * Test a Node.\r\n * @param node to test\r\n * @param test to execute\r\n * @return true if node passes test\r\n *\/\r\n","code_no_comment":"public static boolean testNode(Node node, NodeTest test) {\r\n    if (test == null) {\r\n        return true;\r\n    }\r\n    if (test instanceof NodeNameTest) {\r\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\r\n            return false;\r\n        }\r\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\r\n        QName testName = nodeNameTest.getNodeName();\r\n        String namespaceURI = nodeNameTest.getNamespaceURI();\r\n        boolean wildcard = nodeNameTest.isWildcard();\r\n        String testPrefix = testName.getPrefix();\r\n        if (wildcard && testPrefix == null) {\r\n            return true;\r\n        }\r\n        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {\r\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\r\n            return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));\r\n        }\r\n        return false;\r\n    }\r\n    if (test instanceof NodeTypeTest) {\r\n        int nodeType = node.getNodeType();\r\n        switch(((NodeTypeTest) test).getNodeType()) {\r\n            case Compiler.NODE_TYPE_NODE:\r\n                return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;\r\n            case Compiler.NODE_TYPE_TEXT:\r\n                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;\r\n            case Compiler.NODE_TYPE_COMMENT:\r\n                return nodeType == Node.COMMENT_NODE;\r\n            case Compiler.NODE_TYPE_PI:\r\n                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\r\n        }\r\n        return false;\r\n    }\r\n    if (test instanceof ProcessingInstructionTest) {\r\n        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\r\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\r\n            String nodePI = ((ProcessingInstruction) node).getTarget();\r\n            return testPI.equals(nodePI);\r\n        }\r\n    }\r\n    return false;\r\n}","lc":1.4090909091,"pi":0.4449760766,"ma":1.8,"nbd":0.5,"ml":1.4166666667,"d":0.6349206349,"mi":-0.8257928118,"fo":1.0,"r":-0.0263157895,"e":1.7101294929}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_add180fb","label":1,"code":"@Override\r\npublic Iterable<Entry<String, String>> getProperties(String tableName) throws TableNotFoundException {\r\n    return acu.tables.get(tableName).settings.entrySet();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Iterable<Entry<String, String>> getProperties(String tableName) throws TableNotFoundException {\r\n    return acu.tables.get(tableName).settings.entrySet();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7398167724,"fo":-0.3333333333,"r":0.0,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5759_0374c040","label":1,"code":"\/**\r\n *  Generates the body the {@linkplain #getCallbackFunction(CallbackParameter...) callback\r\n *  function}. To embed this code directly into a piece of javascript, make sure any context\r\n *  parameters are available as local variables, global variables or within the closure.\r\n *\r\n *  @param extraParameters\r\n *  @return The body of the {@linkplain #getCallbackFunction(CallbackParameter...) callback\r\n *          function}.\r\n *\/\r\npublic CharSequence getCallbackFunctionBody(CallbackParameter... extraParameters) {\r\n    AjaxRequestAttributes attributes = getAttributes();\r\n    attributes.setEventNames();\r\n    CharSequence attrsJson = renderAjaxAttributes(getComponent(), attributes);\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"var attrs = \");\r\n    sb.append(attrsJson);\r\n    sb.append(\";\\n\");\r\n    sb.append(\"var params = {\");\r\n    boolean first = true;\r\n    for (CallbackParameter curExtraParameter : extraParameters) {\r\n        if (curExtraParameter.getAjaxParameterName() != null) {\r\n            if (!first)\r\n                sb.append(',');\r\n            else\r\n                first = false;\r\n            sb.append('\\'').append(curExtraParameter.getAjaxParameterName()).append(\"': \").append(curExtraParameter.getAjaxParameterCode());\r\n        }\r\n    }\r\n    sb.append(\"};\\n\");\r\n    if (attributes.getExtraParameters().isEmpty()) {\r\n        sb.append(\"attrs.\").append(AjaxAttributeName.EXTRA_PARAMETERS).append(\" = params;\\n\");\r\n    } else {\r\n        sb.append(\"attrs.\").append(AjaxAttributeName.EXTRA_PARAMETERS).append(\" = Wicket.merge(attrs.\").append(AjaxAttributeName.EXTRA_PARAMETERS).append(\", params);\\n\");\r\n    }\r\n    sb.append(\"Wicket.Ajax.ajax(attrs);\\n\");\r\n    return sb;\r\n}","code_comment":"\/**\r\n *  Generates the body the {@linkplain #getCallbackFunction(CallbackParameter...) callback\r\n *  function}. To embed this code directly into a piece of javascript, make sure any context\r\n *  parameters are available as local variables, global variables or within the closure.\r\n *\r\n *  @param extraParameters\r\n *  @return The body of the {@linkplain #getCallbackFunction(CallbackParameter...) callback\r\n *          function}.\r\n *\/\r\n","code_no_comment":"public CharSequence getCallbackFunctionBody(CallbackParameter... extraParameters) {\r\n    AjaxRequestAttributes attributes = getAttributes();\r\n    attributes.setEventNames();\r\n    CharSequence attrsJson = renderAjaxAttributes(getComponent(), attributes);\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"var attrs = \");\r\n    sb.append(attrsJson);\r\n    sb.append(\";\\n\");\r\n    sb.append(\"var params = {\");\r\n    boolean first = true;\r\n    for (CallbackParameter curExtraParameter : extraParameters) {\r\n        if (curExtraParameter.getAjaxParameterName() != null) {\r\n            if (!first)\r\n                sb.append(',');\r\n            else\r\n                first = false;\r\n            sb.append('\\'').append(curExtraParameter.getAjaxParameterName()).append(\"': \").append(curExtraParameter.getAjaxParameterCode());\r\n        }\r\n    }\r\n    sb.append(\"};\\n\");\r\n    if (attributes.getExtraParameters().isEmpty()) {\r\n        sb.append(\"attrs.\").append(AjaxAttributeName.EXTRA_PARAMETERS).append(\" = params;\\n\");\r\n    } else {\r\n        sb.append(\"attrs.\").append(AjaxAttributeName.EXTRA_PARAMETERS).append(\" = Wicket.merge(attrs.\").append(AjaxAttributeName.EXTRA_PARAMETERS).append(\", params);\\n\");\r\n    }\r\n    sb.append(\"Wicket.Ajax.ajax(attrs);\\n\");\r\n    return sb;\r\n}","lc":0.6363636364,"pi":0.5167464115,"ma":0.2,"nbd":0.0,"ml":0.0833333333,"d":0.0833333333,"mi":-0.4869626498,"fo":1.8333333333,"r":-0.0263157895,"e":0.3570777361}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-519_26a61077","label":1,"code":"\/**\r\n * Gets the two bounding interpolation points from the specified points\r\n * suitable for determining X at the specified Y.\r\n *\r\n * @param points points to use for interpolation\r\n * @param startIdx index within points from which to start search for\r\n *        interpolation bounds points\r\n * @param idxStep index step for search for interpolation bounds points\r\n * @param y Y value for which X should be determined\r\n *\r\n * @return array containing two points suitable for determining X at the\r\n *         specified Y\r\n *\r\n * @throws IllegalArgumentException if idxStep is 0\r\n * @throws OutOfRangeException if specified <code>y<\/code> is not within the\r\n *         range of the specified <code>points<\/code>\r\n *\/\r\nprivate WeightedObservedPoint[] getInterpolationPointsForY(WeightedObservedPoint[] points, int startIdx, int idxStep, double y) throws OutOfRangeException {\r\n    if (idxStep == 0) {\r\n        throw new ZeroException();\r\n    }\r\n    for (int i = startIdx; (idxStep < 0) ? (i + idxStep >= 0) : (i + idxStep < points.length); i += idxStep) {\r\n        if (isBetween(y, points[i].getY(), points[i + idxStep].getY())) {\r\n            return (idxStep < 0) ? new WeightedObservedPoint[] { points[i + idxStep], points[i] } : new WeightedObservedPoint[] { points[i], points[i + idxStep] };\r\n        }\r\n    }\r\n    double minY = Double.POSITIVE_INFINITY;\r\n    double maxY = Double.NEGATIVE_INFINITY;\r\n    for (final WeightedObservedPoint point : points) {\r\n        minY = Math.min(minY, point.getY());\r\n        maxY = Math.max(maxY, point.getY());\r\n    }\r\n    throw new OutOfRangeException(y, minY, maxY);\r\n}","code_comment":"\/**\r\n * Gets the two bounding interpolation points from the specified points\r\n * suitable for determining X at the specified Y.\r\n *\r\n * @param points points to use for interpolation\r\n * @param startIdx index within points from which to start search for\r\n *        interpolation bounds points\r\n * @param idxStep index step for search for interpolation bounds points\r\n * @param y Y value for which X should be determined\r\n *\r\n * @return array containing two points suitable for determining X at the\r\n *         specified Y\r\n *\r\n * @throws IllegalArgumentException if idxStep is 0\r\n * @throws OutOfRangeException if specified <code>y<\/code> is not within the\r\n *         range of the specified <code>points<\/code>\r\n *\/\r\n","code_no_comment":"private WeightedObservedPoint[] getInterpolationPointsForY(WeightedObservedPoint[] points, int startIdx, int idxStep, double y) throws OutOfRangeException {\r\n    if (idxStep == 0) {\r\n        throw new ZeroException();\r\n    }\r\n    for (int i = startIdx; (idxStep < 0) ? (i + idxStep >= 0) : (i + idxStep < points.length); i += idxStep) {\r\n        if (isBetween(y, points[i].getY(), points[i + idxStep].getY())) {\r\n            return (idxStep < 0) ? new WeightedObservedPoint[] { points[i + idxStep], points[i] } : new WeightedObservedPoint[] { points[i], points[i + idxStep] };\r\n        }\r\n    }\r\n    double minY = Double.POSITIVE_INFINITY;\r\n    double maxY = Double.NEGATIVE_INFINITY;\r\n    for (final WeightedObservedPoint point : points) {\r\n        minY = Math.min(minY, point.getY());\r\n        maxY = Math.max(maxY, point.getY());\r\n    }\r\n    throw new OutOfRangeException(y, minY, maxY);\r\n}","lc":0.1363636364,"pi":0.0,"ma":1.0,"nbd":0.0,"ml":0.4166666667,"d":1.5238095238,"mi":-0.2642706131,"fo":0.0833333333,"r":-0.0263157895,"e":1.735200521}
{"project_name":"JxPath","project_version":"12","label":1,"code":"public static boolean testNode(Node node, NodeTest test) {\r\n    if (test == null) {\r\n        return true;\r\n    }\r\n    if (test instanceof NodeNameTest) {\r\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\r\n            return false;\r\n        }\r\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\r\n        QName testName = nodeNameTest.getNodeName();\r\n        String namespaceURI = nodeNameTest.getNamespaceURI();\r\n        boolean wildcard = nodeNameTest.isWildcard();\r\n        String testPrefix = testName.getPrefix();\r\n        if (wildcard && testPrefix == null) {\r\n            return true;\r\n        }\r\n        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {\r\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\r\n            return equalStrings(namespaceURI, nodeNS);\r\n        }\r\n        return false;\r\n    }\r\n    if (test instanceof NodeTypeTest) {\r\n        int nodeType = node.getNodeType();\r\n        switch(((NodeTypeTest) test).getNodeType()) {\r\n            case Compiler.NODE_TYPE_NODE:\r\n                return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;\r\n            case Compiler.NODE_TYPE_TEXT:\r\n                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;\r\n            case Compiler.NODE_TYPE_COMMENT:\r\n                return nodeType == Node.COMMENT_NODE;\r\n            case Compiler.NODE_TYPE_PI:\r\n                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\r\n        }\r\n        return false;\r\n    }\r\n    if (test instanceof ProcessingInstructionTest) {\r\n        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\r\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\r\n            String nodePI = ((ProcessingInstruction) node).getTarget();\r\n            return testPI.equals(nodePI);\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"public static boolean testNode(Node node, NodeTest test) {\r\n    if (test == null) {\r\n        return true;\r\n    }\r\n    if (test instanceof NodeNameTest) {\r\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\r\n            return false;\r\n        }\r\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\r\n        QName testName = nodeNameTest.getNodeName();\r\n        String namespaceURI = nodeNameTest.getNamespaceURI();\r\n        boolean wildcard = nodeNameTest.isWildcard();\r\n        String testPrefix = testName.getPrefix();\r\n        if (wildcard && testPrefix == null) {\r\n            return true;\r\n        }\r\n        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {\r\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\r\n            return equalStrings(namespaceURI, nodeNS);\r\n        }\r\n        return false;\r\n    }\r\n    if (test instanceof NodeTypeTest) {\r\n        int nodeType = node.getNodeType();\r\n        switch(((NodeTypeTest) test).getNodeType()) {\r\n            case Compiler.NODE_TYPE_NODE:\r\n                return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;\r\n            case Compiler.NODE_TYPE_TEXT:\r\n                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;\r\n            case Compiler.NODE_TYPE_COMMENT:\r\n                return nodeType == Node.COMMENT_NODE;\r\n            case Compiler.NODE_TYPE_PI:\r\n                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\r\n        }\r\n        return false;\r\n    }\r\n    if (test instanceof ProcessingInstructionTest) {\r\n        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\r\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\r\n            String nodePI = ((ProcessingInstruction) node).getTarget();\r\n            return testPI.equals(nodePI);\r\n        }\r\n    }\r\n    return false;\r\n}","lc":1.4090909091,"pi":0.4449760766,"ma":1.8,"nbd":0.5,"ml":1.4166666667,"d":0.5833333333,"mi":-0.8162085976,"fo":0.8333333333,"r":-0.0263157895,"e":1.5006909747}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3015_f848178e","label":1,"code":"@Override\r\npublic void write(DataOutput out) throws IOException {\r\n    range.write(out);\r\n    out.writeInt(locations.length);\r\n    for (int i = 0; i < locations.length; ++i) out.writeUTF(locations[i]);\r\n    out.writeBoolean(null != isolatedScan);\r\n    if (null != isolatedScan) {\r\n        out.writeBoolean(isolatedScan);\r\n    }\r\n    out.writeBoolean(null != offline);\r\n    if (null != offline) {\r\n        out.writeBoolean(offline);\r\n    }\r\n    out.writeBoolean(null != localIterators);\r\n    if (null != localIterators) {\r\n        out.writeBoolean(localIterators);\r\n    }\r\n    out.writeBoolean(null != mockInstance);\r\n    if (null != mockInstance) {\r\n        out.writeBoolean(mockInstance);\r\n    }\r\n    out.writeBoolean(null != fetchedColumns);\r\n    if (null != fetchedColumns) {\r\n        String[] cols = InputConfigurator.serializeColumns(fetchedColumns);\r\n        out.writeInt(cols.length);\r\n        for (String col : cols) {\r\n            out.writeUTF(col);\r\n        }\r\n    }\r\n    out.writeBoolean(null != auths);\r\n    if (null != auths) {\r\n        out.writeUTF(auths.serialize());\r\n    }\r\n    out.writeBoolean(null != principal);\r\n    if (null != principal) {\r\n        out.writeUTF(principal);\r\n    }\r\n    out.writeBoolean(null != token);\r\n    if (null != token) {\r\n        out.writeUTF(token.getClass().getCanonicalName());\r\n        try {\r\n            out.writeUTF(CredentialHelper.tokenAsBase64(token));\r\n        } catch (AccumuloSecurityException e) {\r\n            throw new IOException(e);\r\n        }\r\n    }\r\n    out.writeBoolean(null != instanceName);\r\n    if (null != instanceName) {\r\n        out.writeUTF(instanceName);\r\n    }\r\n    out.writeBoolean(null != zooKeepers);\r\n    if (null != zooKeepers) {\r\n        out.writeUTF(zooKeepers);\r\n    }\r\n    out.writeBoolean(null != iterators);\r\n    if (null != iterators) {\r\n        out.writeInt(iterators.size());\r\n        for (IteratorSetting iterator : iterators) {\r\n            iterator.write(out);\r\n        }\r\n    }\r\n    out.writeBoolean(null != level);\r\n    if (null != level) {\r\n        out.writeInt(level.toInt());\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void write(DataOutput out) throws IOException {\r\n    range.write(out);\r\n    out.writeInt(locations.length);\r\n    for (int i = 0; i < locations.length; ++i) out.writeUTF(locations[i]);\r\n    out.writeBoolean(null != isolatedScan);\r\n    if (null != isolatedScan) {\r\n        out.writeBoolean(isolatedScan);\r\n    }\r\n    out.writeBoolean(null != offline);\r\n    if (null != offline) {\r\n        out.writeBoolean(offline);\r\n    }\r\n    out.writeBoolean(null != localIterators);\r\n    if (null != localIterators) {\r\n        out.writeBoolean(localIterators);\r\n    }\r\n    out.writeBoolean(null != mockInstance);\r\n    if (null != mockInstance) {\r\n        out.writeBoolean(mockInstance);\r\n    }\r\n    out.writeBoolean(null != fetchedColumns);\r\n    if (null != fetchedColumns) {\r\n        String[] cols = InputConfigurator.serializeColumns(fetchedColumns);\r\n        out.writeInt(cols.length);\r\n        for (String col : cols) {\r\n            out.writeUTF(col);\r\n        }\r\n    }\r\n    out.writeBoolean(null != auths);\r\n    if (null != auths) {\r\n        out.writeUTF(auths.serialize());\r\n    }\r\n    out.writeBoolean(null != principal);\r\n    if (null != principal) {\r\n        out.writeUTF(principal);\r\n    }\r\n    out.writeBoolean(null != token);\r\n    if (null != token) {\r\n        out.writeUTF(token.getClass().getCanonicalName());\r\n        try {\r\n            out.writeUTF(CredentialHelper.tokenAsBase64(token));\r\n        } catch (AccumuloSecurityException e) {\r\n            throw new IOException(e);\r\n        }\r\n    }\r\n    out.writeBoolean(null != instanceName);\r\n    if (null != instanceName) {\r\n        out.writeUTF(instanceName);\r\n    }\r\n    out.writeBoolean(null != zooKeepers);\r\n    if (null != zooKeepers) {\r\n        out.writeUTF(zooKeepers);\r\n    }\r\n    out.writeBoolean(null != iterators);\r\n    if (null != iterators) {\r\n        out.writeInt(iterators.size());\r\n        for (IteratorSetting iterator : iterators) {\r\n            iterator.write(out);\r\n        }\r\n    }\r\n    out.writeBoolean(null != level);\r\n    if (null != level) {\r\n        out.writeInt(level.toInt());\r\n    }\r\n}","lc":2.3636363636,"pi":-0.1483253589,"ma":2.8,"nbd":0.0,"ml":1.8333333333,"d":1.1388888889,"mi":-1.0735729387,"fo":2.5833333333,"r":-0.0263157895,"e":3.5454412383}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3394_18e1a142","label":3,"code":"private boolean doProcessSequential(final Exchange original, final AtomicExchange result, final Iterable<ProcessorExchangePair> pairs, final Iterator<ProcessorExchangePair> it, final ProcessorExchangePair pair, final AsyncCallback callback, final AtomicInteger total) {\r\n    boolean sync = true;\r\n    final Exchange exchange = pair.getExchange();\r\n    Processor processor = pair.getProcessor();\r\n    Producer producer = pair.getProducer();\r\n    TracedRouteNodes traced = exchange.getUnitOfWork() != null ? exchange.getUnitOfWork().getTracedRouteNodes() : null;\r\n    \/\/ compute time taken if sending to another endpoint\r\n    StopWatch watch = null;\r\n    if (producer != null) {\r\n        watch = new StopWatch();\r\n    }\r\n    try {\r\n        \/\/ prepare tracing starting from a new block\r\n        if (traced != null) {\r\n            traced.pushBlock();\r\n        }\r\n        \/\/ let the prepared process it, remember to begin the exchange pair\r\n        AsyncProcessor async = AsyncProcessorTypeConverter.convert(processor);\r\n        pair.begin();\r\n        sync = AsyncProcessorHelper.process(async, exchange, new AsyncCallback() {\r\n\r\n            public void done(boolean doneSync) {\r\n                \/\/ we are done with the exchange pair\r\n                pair.done();\r\n                \/\/ we only have to handle async completion of the routing slip\r\n                if (doneSync) {\r\n                    return;\r\n                }\r\n                \/\/ continue processing the multicast asynchronously\r\n                Exchange subExchange = exchange;\r\n                \/\/ Decide whether to continue with the multicast or not; similar logic to the Pipeline\r\n                \/\/ remember to test for stop on exception and aggregate before copying back results\r\n                boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Sequential processing failed for number \" + total.get(), LOG);\r\n                if (stopOnException && !continueProcessing) {\r\n                    if (subExchange.getException() != null) {\r\n                        \/\/ wrap in exception to explain where it failed\r\n                        subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, subExchange.getException()));\r\n                    } else {\r\n                        \/\/ we want to stop on exception, and the exception was handled by the error handler\r\n                        \/\/ this is similar to what the pipeline does, so we should do the same to not surprise end users\r\n                        \/\/ so we should set the failed exchange as the result and be done\r\n                        result.set(subExchange);\r\n                    }\r\n                    \/\/ and do the done work\r\n                    doDone(original, subExchange, callback, false);\r\n                    return;\r\n                }\r\n                try {\r\n                    doAggregate(getAggregationStrategy(subExchange), result, subExchange);\r\n                } catch (Throwable e) {\r\n                    \/\/ wrap in exception to explain where it failed\r\n                    subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\r\n                    \/\/ and do the done work\r\n                    doDone(original, subExchange, callback, false);\r\n                    return;\r\n                }\r\n                total.incrementAndGet();\r\n                \/\/ maybe there are more processors to multicast\r\n                while (it.hasNext()) {\r\n                    \/\/ prepare and run the next\r\n                    ProcessorExchangePair pair = it.next();\r\n                    subExchange = pair.getExchange();\r\n                    updateNewExchange(subExchange, total.get(), pairs, it);\r\n                    boolean sync = doProcessSequential(original, result, pairs, it, pair, callback, total);\r\n                    if (!sync) {\r\n                        if (LOG.isTraceEnabled()) {\r\n                            LOG.trace(\"Processing exchangeId: \" + original.getExchangeId() + \" is continued being processed asynchronously\");\r\n                        }\r\n                        return;\r\n                    }\r\n                    \/\/ Decide whether to continue with the multicast or not; similar logic to the Pipeline\r\n                    \/\/ remember to test for stop on exception and aggregate before copying back results\r\n                    continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Sequential processing failed for number \" + total.get(), LOG);\r\n                    if (stopOnException && !continueProcessing) {\r\n                        if (subExchange.getException() != null) {\r\n                            \/\/ wrap in exception to explain where it failed\r\n                            subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, subExchange.getException()));\r\n                        } else {\r\n                            \/\/ we want to stop on exception, and the exception was handled by the error handler\r\n                            \/\/ this is similar to what the pipeline does, so we should do the same to not surprise end users\r\n                            \/\/ so we should set the failed exchange as the result and be done\r\n                            result.set(subExchange);\r\n                        }\r\n                        \/\/ and do the done work\r\n                        doDone(original, subExchange, callback, false);\r\n                        return;\r\n                    }\r\n                    try {\r\n                        doAggregate(getAggregationStrategy(subExchange), result, subExchange);\r\n                    } catch (Throwable e) {\r\n                        \/\/ wrap in exception to explain where it failed\r\n                        subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\r\n                        \/\/ and do the done work\r\n                        doDone(original, subExchange, callback, false);\r\n                        return;\r\n                    }\r\n                    total.incrementAndGet();\r\n                }\r\n                \/\/ do the done work\r\n                subExchange = result.get() != null ? result.get() : null;\r\n                doDone(original, subExchange, callback, false);\r\n            }\r\n        });\r\n    } finally {\r\n        \/\/ pop the block so by next round we have the same staring point and thus the tracing looks accurate\r\n        if (traced != null) {\r\n            traced.popBlock();\r\n        }\r\n        if (producer != null) {\r\n            long timeTaken = watch.stop();\r\n            Endpoint endpoint = producer.getEndpoint();\r\n            \/\/ emit event that the exchange was sent to the endpoint\r\n            EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken);\r\n        }\r\n    }\r\n    return sync;\r\n}","code_comment":null,"code_no_comment":"private boolean doProcessSequential(final Exchange original, final AtomicExchange result, final Iterable<ProcessorExchangePair> pairs, final Iterator<ProcessorExchangePair> it, final ProcessorExchangePair pair, final AsyncCallback callback, final AtomicInteger total) {\r\n    boolean sync = true;\r\n    final Exchange exchange = pair.getExchange();\r\n    Processor processor = pair.getProcessor();\r\n    Producer producer = pair.getProducer();\r\n    TracedRouteNodes traced = exchange.getUnitOfWork() != null ? exchange.getUnitOfWork().getTracedRouteNodes() : null;\r\n        StopWatch watch = null;\r\n    if (producer != null) {\r\n        watch = new StopWatch();\r\n    }\r\n    try {\r\n                if (traced != null) {\r\n            traced.pushBlock();\r\n        }\r\n                AsyncProcessor async = AsyncProcessorTypeConverter.convert(processor);\r\n        pair.begin();\r\n        sync = AsyncProcessorHelper.process(async, exchange, new AsyncCallback() {\r\n\r\n            public void done(boolean doneSync) {\r\n                                pair.done();\r\n                                if (doneSync) {\r\n                    return;\r\n                }\r\n                                Exchange subExchange = exchange;\r\n                                                boolean continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Sequential processing failed for number \" + total.get(), LOG);\r\n                if (stopOnException && !continueProcessing) {\r\n                    if (subExchange.getException() != null) {\r\n                                                subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, subExchange.getException()));\r\n                    } else {\r\n                                                                                                result.set(subExchange);\r\n                    }\r\n                                        doDone(original, subExchange, callback, false);\r\n                    return;\r\n                }\r\n                try {\r\n                    doAggregate(getAggregationStrategy(subExchange), result, subExchange);\r\n                } catch (Throwable e) {\r\n                                        subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\r\n                                        doDone(original, subExchange, callback, false);\r\n                    return;\r\n                }\r\n                total.incrementAndGet();\r\n                                while (it.hasNext()) {\r\n                                        ProcessorExchangePair pair = it.next();\r\n                    subExchange = pair.getExchange();\r\n                    updateNewExchange(subExchange, total.get(), pairs, it);\r\n                    boolean sync = doProcessSequential(original, result, pairs, it, pair, callback, total);\r\n                    if (!sync) {\r\n                        if (LOG.isTraceEnabled()) {\r\n                            LOG.trace(\"Processing exchangeId: \" + original.getExchangeId() + \" is continued being processed asynchronously\");\r\n                        }\r\n                        return;\r\n                    }\r\n                                                            continueProcessing = PipelineHelper.continueProcessing(subExchange, \"Sequential processing failed for number \" + total.get(), LOG);\r\n                    if (stopOnException && !continueProcessing) {\r\n                        if (subExchange.getException() != null) {\r\n                                                        subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, subExchange.getException()));\r\n                        } else {\r\n                                                                                                                result.set(subExchange);\r\n                        }\r\n                                                doDone(original, subExchange, callback, false);\r\n                        return;\r\n                    }\r\n                    try {\r\n                        doAggregate(getAggregationStrategy(subExchange), result, subExchange);\r\n                    } catch (Throwable e) {\r\n                                                subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\r\n                                                doDone(original, subExchange, callback, false);\r\n                        return;\r\n                    }\r\n                    total.incrementAndGet();\r\n                }\r\n                                subExchange = result.get() != null ? result.get() : null;\r\n                doDone(original, subExchange, callback, false);\r\n            }\r\n        });\r\n    } finally {\r\n                if (traced != null) {\r\n            traced.popBlock();\r\n        }\r\n        if (producer != null) {\r\n            long timeTaken = watch.stop();\r\n            Endpoint endpoint = producer.getEndpoint();\r\n                        EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken);\r\n        }\r\n    }\r\n    return sync;\r\n}","lc":3.3181818182,"pi":2.0956937799,"ma":2.6,"nbd":1.5,"ml":1.8333333333,"d":0.8511904762,"mi":-1.2680761099,"fo":3.8333333333,"r":-0.0263157895,"e":4.8263826697}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-395_e6c31270","label":1,"code":"private Property internalSetProperty(final String jcrName, final Value value, final int type, final boolean exactTypeMatch) throws RepositoryException {\r\n    checkStatus();\r\n    checkProtected();\r\n    return sessionDelegate.perform(new SessionOperation<Property>() {\r\n\r\n        @Override\r\n        public Property perform() throws RepositoryException {\r\n            if (value == null) {\r\n                Property property = getProperty(jcrName);\r\n                property.remove();\r\n                return property;\r\n            } else {\r\n                String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\r\n                PropertyDefinition definition;\r\n                if (hasProperty(jcrName)) {\r\n                    definition = getProperty(jcrName).getDefinition();\r\n                } else {\r\n                    definition = dlg.sessionDelegate.getDefinitionProvider().getDefinition(NodeImpl.this, oakName, false, type, exactTypeMatch);\r\n                }\r\n                checkProtected(definition);\r\n                if (definition.isMultiple()) {\r\n                    throw new ValueFormatException(\"Cannot set single value to multivalued property\");\r\n                }\r\n                int targetType = getTargetType(value, definition);\r\n                Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\r\n                return new PropertyImpl(dlg.setProperty(oakName, targetValue));\r\n            }\r\n        }\r\n    });\r\n}","code_comment":null,"code_no_comment":"private Property internalSetProperty(final String jcrName, final Value value, final int type, final boolean exactTypeMatch) throws RepositoryException {\r\n    checkStatus();\r\n    checkProtected();\r\n    return sessionDelegate.perform(new SessionOperation<Property>() {\r\n\r\n        @Override\r\n        public Property perform() throws RepositoryException {\r\n            if (value == null) {\r\n                Property property = getProperty(jcrName);\r\n                property.remove();\r\n                return property;\r\n            } else {\r\n                String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\r\n                PropertyDefinition definition;\r\n                if (hasProperty(jcrName)) {\r\n                    definition = getProperty(jcrName).getDefinition();\r\n                } else {\r\n                    definition = dlg.sessionDelegate.getDefinitionProvider().getDefinition(NodeImpl.this, oakName, false, type, exactTypeMatch);\r\n                }\r\n                checkProtected(definition);\r\n                if (definition.isMultiple()) {\r\n                    throw new ValueFormatException(\"Cannot set single value to multivalued property\");\r\n                }\r\n                int targetType = getTargetType(value, definition);\r\n                Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\r\n                return new PropertyImpl(dlg.setProperty(oakName, targetValue));\r\n            }\r\n        }\r\n    });\r\n}","lc":0.6818181818,"pi":1.3827751196,"ma":0.2,"nbd":0.5,"ml":0.1666666667,"d":-0.0079365079,"mi":-0.4847075405,"fo":0.9166666667,"r":-0.0263157895,"e":0.2029402442}
{"project_name":"Closure","project_version":"119","label":3,"code":"public void collect(JSModule module, Scope scope, Node n) {\r\n    Node parent = n.getParent();\r\n    String name;\r\n    boolean isSet = false;\r\n    Name.Type type = Name.Type.OTHER;\r\n    boolean isPropAssign = false;\r\n    switch(n.getType()) {\r\n        case Token.GETTER_DEF:\r\n        case Token.SETTER_DEF:\r\n        case Token.STRING_KEY:\r\n            \/\/ This may be a key in an object literal declaration.\r\n            name = null;\r\n            if (parent != null && parent.isObjectLit()) {\r\n                name = getNameForObjLitKey(n);\r\n            }\r\n            if (name == null) {\r\n                return;\r\n            }\r\n            isSet = true;\r\n            switch(n.getType()) {\r\n                case Token.STRING_KEY:\r\n                    type = getValueType(n.getFirstChild());\r\n                    break;\r\n                case Token.GETTER_DEF:\r\n                    type = Name.Type.GET;\r\n                    break;\r\n                case Token.SETTER_DEF:\r\n                    type = Name.Type.SET;\r\n                    break;\r\n                default:\r\n                    throw new IllegalStateException(\"unexpected:\" + n);\r\n            }\r\n            break;\r\n        case Token.NAME:\r\n            \/\/ This may be a variable get or set.\r\n            if (parent != null) {\r\n                switch(parent.getType()) {\r\n                    case Token.VAR:\r\n                        isSet = true;\r\n                        Node rvalue = n.getFirstChild();\r\n                        type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\r\n                        break;\r\n                    case Token.ASSIGN:\r\n                        if (parent.getFirstChild() == n) {\r\n                            isSet = true;\r\n                            type = getValueType(n.getNext());\r\n                        }\r\n                        break;\r\n                    case Token.GETPROP:\r\n                        return;\r\n                    case Token.FUNCTION:\r\n                        Node gramps = parent.getParent();\r\n                        if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\r\n                            return;\r\n                        }\r\n                        isSet = true;\r\n                        type = Name.Type.FUNCTION;\r\n                        break;\r\n                    case Token.INC:\r\n                    case Token.DEC:\r\n                        isSet = true;\r\n                        type = Name.Type.OTHER;\r\n                        break;\r\n                    default:\r\n                        if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {\r\n                            isSet = true;\r\n                            type = Name.Type.OTHER;\r\n                        }\r\n                }\r\n            }\r\n            name = n.getString();\r\n            break;\r\n        case Token.GETPROP:\r\n            \/\/ This may be a namespaced name get or set.\r\n            if (parent != null) {\r\n                switch(parent.getType()) {\r\n                    case Token.ASSIGN:\r\n                        if (parent.getFirstChild() == n) {\r\n                            isSet = true;\r\n                            type = getValueType(n.getNext());\r\n                            isPropAssign = true;\r\n                        }\r\n                        break;\r\n                    case Token.INC:\r\n                    case Token.DEC:\r\n                        isSet = true;\r\n                        type = Name.Type.OTHER;\r\n                        break;\r\n                    case Token.GETPROP:\r\n                        return;\r\n                    default:\r\n                        if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {\r\n                            isSet = true;\r\n                            type = Name.Type.OTHER;\r\n                        }\r\n                }\r\n            }\r\n            name = n.getQualifiedName();\r\n            if (name == null) {\r\n                return;\r\n            }\r\n            break;\r\n        default:\r\n            return;\r\n    }\r\n    \/\/ We are only interested in global names.\r\n    if (!isGlobalNameReference(name, scope)) {\r\n        return;\r\n    }\r\n    if (isSet) {\r\n        if (isGlobalScope(scope)) {\r\n            handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\r\n        } else {\r\n            handleSetFromLocal(module, scope, n, parent, name);\r\n        }\r\n    } else {\r\n        handleGet(module, scope, n, parent, name);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void collect(JSModule module, Scope scope, Node n) {\r\n    Node parent = n.getParent();\r\n    String name;\r\n    boolean isSet = false;\r\n    Name.Type type = Name.Type.OTHER;\r\n    boolean isPropAssign = false;\r\n    switch(n.getType()) {\r\n        case Token.GETTER_DEF:\r\n        case Token.SETTER_DEF:\r\n        case Token.STRING_KEY:\r\n                        name = null;\r\n            if (parent != null && parent.isObjectLit()) {\r\n                name = getNameForObjLitKey(n);\r\n            }\r\n            if (name == null) {\r\n                return;\r\n            }\r\n            isSet = true;\r\n            switch(n.getType()) {\r\n                case Token.STRING_KEY:\r\n                    type = getValueType(n.getFirstChild());\r\n                    break;\r\n                case Token.GETTER_DEF:\r\n                    type = Name.Type.GET;\r\n                    break;\r\n                case Token.SETTER_DEF:\r\n                    type = Name.Type.SET;\r\n                    break;\r\n                default:\r\n                    throw new IllegalStateException(\"unexpected:\" + n);\r\n            }\r\n            break;\r\n        case Token.NAME:\r\n                        if (parent != null) {\r\n                switch(parent.getType()) {\r\n                    case Token.VAR:\r\n                        isSet = true;\r\n                        Node rvalue = n.getFirstChild();\r\n                        type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\r\n                        break;\r\n                    case Token.ASSIGN:\r\n                        if (parent.getFirstChild() == n) {\r\n                            isSet = true;\r\n                            type = getValueType(n.getNext());\r\n                        }\r\n                        break;\r\n                    case Token.GETPROP:\r\n                        return;\r\n                    case Token.FUNCTION:\r\n                        Node gramps = parent.getParent();\r\n                        if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\r\n                            return;\r\n                        }\r\n                        isSet = true;\r\n                        type = Name.Type.FUNCTION;\r\n                        break;\r\n                    case Token.INC:\r\n                    case Token.DEC:\r\n                        isSet = true;\r\n                        type = Name.Type.OTHER;\r\n                        break;\r\n                    default:\r\n                        if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {\r\n                            isSet = true;\r\n                            type = Name.Type.OTHER;\r\n                        }\r\n                }\r\n            }\r\n            name = n.getString();\r\n            break;\r\n        case Token.GETPROP:\r\n                        if (parent != null) {\r\n                switch(parent.getType()) {\r\n                    case Token.ASSIGN:\r\n                        if (parent.getFirstChild() == n) {\r\n                            isSet = true;\r\n                            type = getValueType(n.getNext());\r\n                            isPropAssign = true;\r\n                        }\r\n                        break;\r\n                    case Token.INC:\r\n                    case Token.DEC:\r\n                        isSet = true;\r\n                        type = Name.Type.OTHER;\r\n                        break;\r\n                    case Token.GETPROP:\r\n                        return;\r\n                    default:\r\n                        if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {\r\n                            isSet = true;\r\n                            type = Name.Type.OTHER;\r\n                        }\r\n                }\r\n            }\r\n            name = n.getQualifiedName();\r\n            if (name == null) {\r\n                return;\r\n            }\r\n            break;\r\n        default:\r\n            return;\r\n    }\r\n        if (!isGlobalNameReference(name, scope)) {\r\n        return;\r\n    }\r\n    if (isSet) {\r\n        if (isGlobalScope(scope)) {\r\n            handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\r\n        } else {\r\n            handleSetFromLocal(module, scope, n, parent, name);\r\n        }\r\n    } else {\r\n        handleGet(module, scope, n, parent, name);\r\n    }\r\n}","lc":4.5909090909,"pi":2.2440191388,"ma":9.2,"nbd":2.0,"ml":3.8333333333,"d":2.0496031746,"mi":-1.5933756166,"fo":2.0,"r":-0.0263157895,"e":8.7194873302}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2460_a17d4e82","label":1,"code":"@Override\r\npublic boolean isReleased() {\r\n    return isReleased.get();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean isReleased() {\r\n    return isReleased.get();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0005637773,"fo":-0.4166666667,"r":1.6315789474,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2528_239de7b8","label":1,"code":"private List<UpdateOp> create() {\r\n    if (!considerSplit()) {\r\n        return Collections.emptyList();\r\n    }\r\n    splitOps = Lists.newArrayList();\r\n    mostRecentRevs = Sets.newHashSet();\r\n    splitRevs = Sets.newHashSet();\r\n    garbage = Maps.newHashMap();\r\n    committedChanges = getCommittedLocalChanges();\r\n    \/\/ revisions of the most recent committed changes on this document\r\n    \/\/ these are kept in the main document. _revisions and _commitRoot\r\n    \/\/ entries with these revisions are retained in the main document\r\n    populateSplitRevs();\r\n    \/\/ collect _revisions and _commitRoot entries for split document\r\n    collectRevisionsAndCommitRoot();\r\n    \/\/ create split ops out of the split values\r\n    main = createSplitOps();\r\n    \/\/ create intermediate docs if needed\r\n    createIntermediateDocs();\r\n    \/\/ remove stale references to previous docs\r\n    disconnectStalePrevDocs();\r\n    \/\/ remove garbage\r\n    removeGarbage();\r\n    \/\/ main document must be updated last\r\n    if (main != null) {\r\n        splitOps.add(main);\r\n    }\r\n    return splitOps;\r\n}","code_comment":null,"code_no_comment":"private List<UpdateOp> create() {\r\n    if (!considerSplit()) {\r\n        return Collections.emptyList();\r\n    }\r\n    splitOps = Lists.newArrayList();\r\n    mostRecentRevs = Sets.newHashSet();\r\n    splitRevs = Sets.newHashSet();\r\n    garbage = Maps.newHashMap();\r\n    committedChanges = getCommittedLocalChanges();\r\n                populateSplitRevs();\r\n        collectRevisionsAndCommitRoot();\r\n        main = createSplitOps();\r\n        createIntermediateDocs();\r\n        disconnectStalePrevDocs();\r\n        removeGarbage();\r\n        if (main != null) {\r\n        splitOps.add(main);\r\n    }\r\n    return splitOps;\r\n}","lc":0.2727272727,"pi":-0.5741626794,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.125,"mi":-0.1923890063,"fo":0.6666666667,"r":0.1842105263,"e":-0.0463085585}
{"project_name":"Codec","project_version":"5","label":0,"code":"\/**\r\n * <p>\r\n * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\r\n * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\r\n * call is not necessary when decoding, but it doesn't hurt, either.\r\n * <\/p>\r\n * <p>\r\n * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\r\n * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\r\n * garbage-out philosophy: it will not check the provided data for validity.\r\n * <\/p>\r\n * <p>\r\n * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\r\n * http:\/\/svn.apache.org\/repos\/asf\/webservices\/commons\/trunk\/modules\/util\/\r\n * <\/p>\r\n *\r\n * @param in\r\n *            byte[] array of ascii data to base64 decode.\r\n * @param inPos\r\n *            Position to start reading data from.\r\n * @param inAvail\r\n *            Amount of bytes available from input for encoding.\r\n *\/\r\nvoid decode(byte[] in, int inPos, int inAvail) {\r\n    if (eof) {\r\n        return;\r\n    }\r\n    if (inAvail < 0) {\r\n        eof = true;\r\n    }\r\n    for (int i = 0; i < inAvail; i++) {\r\n        if (buffer == null || buffer.length - pos < decodeSize) {\r\n            resizeBuffer();\r\n        }\r\n        byte b = in[inPos++];\r\n        if (b == PAD) {\r\n            \/\/ We're done.\r\n            eof = true;\r\n            break;\r\n        } else {\r\n            if (b >= 0 && b < DECODE_TABLE.length) {\r\n                int result = DECODE_TABLE[b];\r\n                if (result >= 0) {\r\n                    modulus = (++modulus) % 4;\r\n                    x = (x << 6) + result;\r\n                    if (modulus == 0) {\r\n                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\r\n                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\r\n                        buffer[pos++] = (byte) (x & MASK_8BITS);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \/\/ This approach makes the '=' padding characters completely optional.\r\n    if (eof && modulus != 0) {\r\n        x = x << 6;\r\n        switch(modulus) {\r\n            case 2:\r\n                x = x << 6;\r\n                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\r\n                break;\r\n            case 3:\r\n                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\r\n                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\r\n                break;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * <p>\r\n * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\r\n * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\r\n * call is not necessary when decoding, but it doesn't hurt, either.\r\n * <\/p>\r\n * <p>\r\n * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\r\n * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\r\n * garbage-out philosophy: it will not check the provided data for validity.\r\n * <\/p>\r\n * <p>\r\n * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\r\n * http:\/\/svn.apache.org\/repos\/asf\/webservices\/commons\/trunk\/modules\/util\/\r\n * <\/p>\r\n *\r\n * @param in\r\n *            byte[] array of ascii data to base64 decode.\r\n * @param inPos\r\n *            Position to start reading data from.\r\n * @param inAvail\r\n *            Amount of bytes available from input for encoding.\r\n *\/\r\n","code_no_comment":"void decode(byte[] in, int inPos, int inAvail) {\r\n    if (eof) {\r\n        return;\r\n    }\r\n    if (inAvail < 0) {\r\n        eof = true;\r\n    }\r\n    for (int i = 0; i < inAvail; i++) {\r\n        if (buffer == null || buffer.length - pos < decodeSize) {\r\n            resizeBuffer();\r\n        }\r\n        byte b = in[inPos++];\r\n        if (b == PAD) {\r\n                        eof = true;\r\n            break;\r\n        } else {\r\n            if (b >= 0 && b < DECODE_TABLE.length) {\r\n                int result = DECODE_TABLE[b];\r\n                if (result >= 0) {\r\n                    modulus = (++modulus) % 4;\r\n                    x = (x << 6) + result;\r\n                    if (modulus == 0) {\r\n                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\r\n                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\r\n                        buffer[pos++] = (byte) (x & MASK_8BITS);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n        if (eof && modulus != 0) {\r\n        x = x << 6;\r\n        switch(modulus) {\r\n            case 2:\r\n                x = x << 6;\r\n                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\r\n                break;\r\n            case 3:\r\n                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\r\n                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\r\n                break;\r\n        }\r\n    }\r\n}","lc":1.3636363636,"pi":1.6220095694,"ma":2.2,"nbd":1.5,"ml":1.6666666667,"d":4.0496031746,"mi":-0.8221282593,"fo":-0.4166666667,"r":-0.0263157895,"e":7.7471712684}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-776_dc9f23d9","label":3,"code":"@Override\r\npublic boolean validateOptions(Map<String, String> options) {\r\n    super.validateOptions(options);\r\n    try {\r\n        if (options.containsKey(START))\r\n            dateParser.parse(options.get(START));\r\n        if (options.containsKey(END))\r\n            dateParser.parse(options.get(END));\r\n        if (options.get(START_INCL) != null)\r\n            Boolean.parseBoolean(options.get(START_INCL));\r\n        if (options.get(END_INCL) != null)\r\n            Boolean.parseBoolean(options.get(END_INCL));\r\n    } catch (Exception e) {\r\n        return false;\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean validateOptions(Map<String, String> options) {\r\n    super.validateOptions(options);\r\n    try {\r\n        if (options.containsKey(START))\r\n            dateParser.parse(options.get(START));\r\n        if (options.containsKey(END))\r\n            dateParser.parse(options.get(END));\r\n        if (options.get(START_INCL) != null)\r\n            Boolean.parseBoolean(options.get(START_INCL));\r\n        if (options.get(END_INCL) != null)\r\n            Boolean.parseBoolean(options.get(END_INCL));\r\n    } catch (Exception e) {\r\n        return false;\r\n    }\r\n    return true;\r\n}","lc":0.1363636364,"pi":0.5454545455,"ma":0.4,"nbd":-0.5,"ml":0.25,"d":-0.3650793651,"mi":-0.1447498238,"fo":0.5833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5783_7b8b6767","label":1,"code":"\/**\r\n *  @return event\r\n *       the event this behavior is attached to\r\n *\/\r\npublic final String getEvent() {\r\n    return event;\r\n}","code_comment":"\/**\r\n *  @return event\r\n *       the event this behavior is attached to\r\n *\/\r\n","code_no_comment":"public final String getEvent() {\r\n    return event;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1646229739,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  Registers an informational feedback message for this component\r\n *\r\n *  @param message\r\n *             The feedback message\r\n *\/\r\npublic final void info(final String message) {\r\n    getPage().getFeedbackMessages().info(this, message);\r\n}","code_comment":"\/**\r\n *  Registers an informational feedback message for this component\r\n *\r\n *  @param message\r\n *             The feedback message\r\n *\/\r\n","code_no_comment":"public final void info(final String message) {\r\n    getPage().getFeedbackMessages().info(this, message);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0253699789,"fo":-0.25,"r":2.5,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3510_01f5a26f","label":1,"code":"\/**\r\n * Tests if the given object is an external identity reference and if it's getString() is equal to this.\r\n *\/\r\n@Override\r\npublic boolean equals(Object o) {\r\n    try {\r\n        \/\/ assuming that we never compare other types of classes\r\n        return this == o || string.equals(((ExternalIdentityRef) o).string);\r\n    } catch (Exception e) {\r\n        return false;\r\n    }\r\n}","code_comment":"\/**\r\n * Tests if the given object is an external identity reference and if it's getString() is equal to this.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic boolean equals(Object o) {\r\n    try {\r\n                return this == o || string.equals(((ExternalIdentityRef) o).string);\r\n    } catch (Exception e) {\r\n        return false;\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.0873015873,"mi":0.421564482,"fo":-0.4166666667,"r":2.5,"e":-0.125772376}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-1619_b154d12f","label":1,"code":"@Override\r\npublic boolean isEnabled() {\r\n    return PagingNavigation.this.isEnabled() && PagingNavigation.this.isEnableAllowed();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean isEnabled() {\r\n    return PagingNavigation.this.isEnabled() && PagingNavigation.this.isEnableAllowed();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8940098661,"fo":-0.3333333333,"r":0.2368421053,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3304_7e7ab76c","label":3,"code":"\/**\r\n *  @see org.apache.wicket.markup.html.form.FormComponent#convertInput()\r\n *\/\r\n@Override\r\nprotected void convertInput() {\r\n    \/\/ Stateless forms don't have to be rendered first, convertInput could be called before\r\n    \/\/ onBeforeRender calling resolve type here again to check if the type is correctly set.\r\n    resolveType();\r\n    super.convertInput();\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.markup.html.form.FormComponent#convertInput()\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void convertInput() {\r\n            resolveType();\r\n    super.convertInput();\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8985200846,"fo":-0.3333333333,"r":0.3684210526,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, ShortValue reusable) {\r\n    int val = 0;\r\n    boolean neg = false;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    this.result = reusable;\r\n    if (bytes[startPos] == '-') {\r\n        neg = true;\r\n        startPos++;\r\n        \/\/ check for empty field with only the sign\r\n        if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\r\n            return -1;\r\n        }\r\n    }\r\n    for (int i = startPos; i < limit; i++) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            reusable.setValue((short) (neg ? -val : val));\r\n            return i + delimiter.length;\r\n        }\r\n        if (bytes[i] < 48 || bytes[i] > 57) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\r\n            return -1;\r\n        }\r\n        val *= 10;\r\n        val += bytes[i] - 48;\r\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\r\n            return -1;\r\n        }\r\n    }\r\n    reusable.setValue((short) (neg ? -val : val));\r\n    return limit;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, ShortValue reusable) {\r\n    int val = 0;\r\n    boolean neg = false;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    this.result = reusable;\r\n    if (bytes[startPos] == '-') {\r\n        neg = true;\r\n        startPos++;\r\n                if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\r\n            return -1;\r\n        }\r\n    }\r\n    for (int i = startPos; i < limit; i++) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            reusable.setValue((short) (neg ? -val : val));\r\n            return i + delimiter.length;\r\n        }\r\n        if (bytes[i] < 48 || bytes[i] > 57) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);\r\n            return -1;\r\n        }\r\n        val *= 10;\r\n        val += bytes[i] - 48;\r\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\r\n            setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);\r\n            return -1;\r\n        }\r\n    }\r\n    reusable.setValue((short) (neg ? -val : val));\r\n    return limit;\r\n}","lc":0.8636363636,"pi":0.3349282297,"ma":1.0,"nbd":0.0,"ml":1.5833333333,"d":2.9087301587,"mi":-0.6315715292,"fo":0.0833333333,"r":-0.0263157895,"e":4.9454262547}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-996_32a003d5","label":1,"code":"@Override\r\npublic void postVisit(PlanNode visitable) {\r\n    if (visitable instanceof BinaryUnionPlanNode) {\r\n        final BinaryUnionPlanNode unionNode = (BinaryUnionPlanNode) visitable;\r\n        final Channel in1 = unionNode.getInput1();\r\n        final Channel in2 = unionNode.getInput2();\r\n        PlanNode newUnionNode;\r\n        \/\/ if any input is cached, we keep this as a binary union and do not collapse it into a\r\n        \/\/ n-ary union\r\n        \/\/ if (in1.getTempMode().isCached() || in2.getTempMode().isCached()) {\r\n        \/\/ \/\/ replace this node by an explicit operator\r\n        \/\/ Channel cached, pipelined;\r\n        \/\/ if (in1.getTempMode().isCached()) {\r\n        \/\/ cached = in1;\r\n        \/\/ pipelined = in2;\r\n        \/\/ } else {\r\n        \/\/ cached = in2;\r\n        \/\/ pipelined = in1;\r\n        \/\/ }\r\n        \/\/ \r\n        \/\/ newUnionNode = new DualInputPlanNode(unionNode.getOriginalOptimizerNode(), cached, pipelined,\r\n        \/\/ DriverStrategy.UNION_WITH_CACHED);\r\n        \/\/ newUnionNode.initProperties(unionNode.getGlobalProperties(), new LocalProperties());\r\n        \/\/ \r\n        \/\/ in1.setTarget(newUnionNode);\r\n        \/\/ in2.setTarget(newUnionNode);\r\n        \/\/ } else {\r\n        \/\/ collect the union inputs to collapse this operator with\r\n        \/\/ its collapsed predecessors. check whether an input is materialized to prevent\r\n        \/\/ collapsing\r\n        List<Channel> inputs = new ArrayList<Channel>();\r\n        collect(in1, inputs);\r\n        collect(in2, inputs);\r\n        newUnionNode = new NAryUnionPlanNode(unionNode.getOptimizerNode(), inputs, unionNode.getGlobalProperties());\r\n        \/\/ adjust the input channels to have their target point to the new union node\r\n        for (Channel c : inputs) {\r\n            c.setTarget(newUnionNode);\r\n        }\r\n        \/\/ }\r\n        unionNode.getOutgoingChannels().get(0).swapUnionNodes(newUnionNode);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void postVisit(PlanNode visitable) {\r\n    if (visitable instanceof BinaryUnionPlanNode) {\r\n        final BinaryUnionPlanNode unionNode = (BinaryUnionPlanNode) visitable;\r\n        final Channel in1 = unionNode.getInput1();\r\n        final Channel in2 = unionNode.getInput2();\r\n        PlanNode newUnionNode;\r\n                                                                                                                                                                                                List<Channel> inputs = new ArrayList<Channel>();\r\n        collect(in1, inputs);\r\n        collect(in2, inputs);\r\n        newUnionNode = new NAryUnionPlanNode(unionNode.getOptimizerNode(), inputs, unionNode.getGlobalProperties());\r\n                for (Channel c : inputs) {\r\n            c.setTarget(newUnionNode);\r\n        }\r\n                unionNode.getOutgoingChannels().get(0).swapUnionNodes(newUnionNode);\r\n    }\r\n}","lc":0.1363636364,"pi":0.1866028708,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.3650793651,"mi":-0.1543340381,"fo":0.3333333333,"r":0.0,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-642_7a84b3a8","label":3,"code":"@Override\r\n@Nonnull\r\npublic Node addNode(final String relPath, final String primaryNodeTypeName) throws RepositoryException {\r\n    checkStatus();\r\n    checkProtected();\r\n    return sessionDelegate.perform(new SessionOperation<Node>() {\r\n\r\n        @Override\r\n        public Node perform() throws RepositoryException {\r\n            String oakPath = sessionDelegate.getOakPathKeepIndexOrThrowNotFound(relPath);\r\n            String oakName = PathUtils.getName(oakPath);\r\n            String parentPath = sessionDelegate.getOakPath(PathUtils.getParentPath(oakPath));\r\n            \/\/ handle index\r\n            if (oakName.contains(\"[\")) {\r\n                throw new RepositoryException(\"Cannot create a new node using a name including an index\");\r\n            }\r\n            NodeDelegate parent = dlg.getChild(parentPath);\r\n            if (parent == null) {\r\n                \/\/ is it a property?\r\n                String grandParentPath = PathUtils.getParentPath(parentPath);\r\n                NodeDelegate grandParent = dlg.getChild(grandParentPath);\r\n                if (grandParent != null) {\r\n                    String propName = PathUtils.getName(parentPath);\r\n                    if (grandParent.getProperty(propName) != null) {\r\n                        throw new ConstraintViolationException(\"Can't add new node to property.\");\r\n                    }\r\n                }\r\n                throw new PathNotFoundException(relPath);\r\n            }\r\n            if (parent.getChild(oakName) != null) {\r\n                throw new ItemExistsException(relPath);\r\n            }\r\n            String ntName = primaryNodeTypeName;\r\n            if (ntName == null) {\r\n                DefinitionProvider dp = sessionDelegate.getDefinitionProvider();\r\n                try {\r\n                    String childName = sessionDelegate.getOakName(PathUtils.getName(relPath));\r\n                    NodeDefinition def = dp.getDefinition(new NodeImpl<NodeDelegate>(parent), childName);\r\n                    ntName = def.getDefaultPrimaryTypeName();\r\n                } catch (RepositoryException e) {\r\n                    throw new ConstraintViolationException(\"no matching child node definition found for \" + relPath);\r\n                }\r\n            }\r\n            \/\/ TODO: figure out the right place for this check\r\n            NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();\r\n            \/\/ throws on not found\r\n            NodeType nt = ntm.getNodeType(ntName);\r\n            if (nt.isAbstract() || nt.isMixin()) {\r\n                throw new ConstraintViolationException();\r\n            }\r\n            \/\/ TODO: END\r\n            NodeDelegate added = parent.addChild(oakName);\r\n            if (added == null) {\r\n                throw new ItemExistsException();\r\n            }\r\n            if (getPrimaryNodeType().hasOrderableChildNodes()) {\r\n                dlg.setOrderableChildren(true);\r\n            }\r\n            NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added);\r\n            childNode.internalSetPrimaryType(ntName);\r\n            childNode.autoCreateItems();\r\n            return childNode;\r\n        }\r\n    });\r\n}","code_comment":null,"code_no_comment":"@Override\r\n@Nonnull\r\npublic Node addNode(final String relPath, final String primaryNodeTypeName) throws RepositoryException {\r\n    checkStatus();\r\n    checkProtected();\r\n    return sessionDelegate.perform(new SessionOperation<Node>() {\r\n\r\n        @Override\r\n        public Node perform() throws RepositoryException {\r\n            String oakPath = sessionDelegate.getOakPathKeepIndexOrThrowNotFound(relPath);\r\n            String oakName = PathUtils.getName(oakPath);\r\n            String parentPath = sessionDelegate.getOakPath(PathUtils.getParentPath(oakPath));\r\n                        if (oakName.contains(\"[\")) {\r\n                throw new RepositoryException(\"Cannot create a new node using a name including an index\");\r\n            }\r\n            NodeDelegate parent = dlg.getChild(parentPath);\r\n            if (parent == null) {\r\n                                String grandParentPath = PathUtils.getParentPath(parentPath);\r\n                NodeDelegate grandParent = dlg.getChild(grandParentPath);\r\n                if (grandParent != null) {\r\n                    String propName = PathUtils.getName(parentPath);\r\n                    if (grandParent.getProperty(propName) != null) {\r\n                        throw new ConstraintViolationException(\"Can't add new node to property.\");\r\n                    }\r\n                }\r\n                throw new PathNotFoundException(relPath);\r\n            }\r\n            if (parent.getChild(oakName) != null) {\r\n                throw new ItemExistsException(relPath);\r\n            }\r\n            String ntName = primaryNodeTypeName;\r\n            if (ntName == null) {\r\n                DefinitionProvider dp = sessionDelegate.getDefinitionProvider();\r\n                try {\r\n                    String childName = sessionDelegate.getOakName(PathUtils.getName(relPath));\r\n                    NodeDefinition def = dp.getDefinition(new NodeImpl<NodeDelegate>(parent), childName);\r\n                    ntName = def.getDefaultPrimaryTypeName();\r\n                } catch (RepositoryException e) {\r\n                    throw new ConstraintViolationException(\"no matching child node definition found for \" + relPath);\r\n                }\r\n            }\r\n                        NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();\r\n                        NodeType nt = ntm.getNodeType(ntName);\r\n            if (nt.isAbstract() || nt.isMixin()) {\r\n                throw new ConstraintViolationException();\r\n            }\r\n                        NodeDelegate added = parent.addChild(oakName);\r\n            if (added == null) {\r\n                throw new ItemExistsException();\r\n            }\r\n            if (getPrimaryNodeType().hasOrderableChildNodes()) {\r\n                dlg.setOrderableChildren(true);\r\n            }\r\n            NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added);\r\n            childNode.internalSetPrimaryType(ntName);\r\n            childNode.autoCreateItems();\r\n            return childNode;\r\n        }\r\n    });\r\n}","lc":2.0454545455,"pi":1.1196172249,"ma":2.8,"nbd":1.0,"ml":1.4166666667,"d":0.5099206349,"mi":-1.0245243129,"fo":1.9166666667,"r":-0.0263157895,"e":2.0278556733}
{"project_name":"JxPath","project_version":"3","label":1,"code":"public NodePointer createPath(JXPathContext context) {\r\n    NodePointer newParent = parent.createPath(context);\r\n    if (isAttribute()) {\r\n        return newParent.createAttribute(context, getName());\r\n    } else {\r\n        \/\/ non-property pointer expand the collection by itself.\r\n        if (newParent instanceof PropertyOwnerPointer) {\r\n            PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\r\n            newParent = pop.getPropertyPointer();\r\n        }\r\n        return newParent.createChild(context, getName(), getIndex());\r\n    }\r\n}","code_comment":null,"code_no_comment":"public NodePointer createPath(JXPathContext context) {\r\n    NodePointer newParent = parent.createPath(context);\r\n    if (isAttribute()) {\r\n        return newParent.createAttribute(context, getName());\r\n    } else {\r\n                if (newParent instanceof PropertyOwnerPointer) {\r\n            PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\r\n            newParent = pop.getPropertyPointer();\r\n        }\r\n        return newParent.createChild(context, getName(), getIndex());\r\n    }\r\n}","lc":-0.0909090909,"pi":0.4019138756,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.11205074,"fo":0.1666666667,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3498_b4606700","label":1,"code":"public Iterator iterator() {\r\n    return new Iterator() {\r\n\r\n        private int index;\r\n\r\n        private boolean closed;\r\n\r\n        public boolean hasNext() {\r\n            if (closed) {\r\n                return false;\r\n            }\r\n            boolean answer = iterator.hasNext();\r\n            if (!answer) {\r\n                \/\/ we are now closed\r\n                closed = true;\r\n                \/\/ nothing more so we need to close the expression value in case it needs to be\r\n                if (value instanceof Closeable) {\r\n                    IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\r\n                } else if (value instanceof Scanner) {\r\n                    \/\/ special for Scanner as it does not implement Closeable\r\n                    ((Scanner) value).close();\r\n                }\r\n            }\r\n            return answer;\r\n        }\r\n\r\n        public Object next() {\r\n            Object part = iterator.next();\r\n            Exchange newExchange = ExchangeHelper.createCopy(exchange, true);\r\n            if (part instanceof Message) {\r\n                newExchange.setIn((Message) part);\r\n            } else {\r\n                Message in = newExchange.getIn();\r\n                in.setBody(part);\r\n            }\r\n            return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\r\n        }\r\n\r\n        public void remove() {\r\n            throw new UnsupportedOperationException(\"Remove is not supported by this iterator\");\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"public Iterator iterator() {\r\n    return new Iterator() {\r\n\r\n        private int index;\r\n\r\n        private boolean closed;\r\n\r\n        public boolean hasNext() {\r\n            if (closed) {\r\n                return false;\r\n            }\r\n            boolean answer = iterator.hasNext();\r\n            if (!answer) {\r\n                                closed = true;\r\n                                if (value instanceof Closeable) {\r\n                    IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\r\n                } else if (value instanceof Scanner) {\r\n                                        ((Scanner) value).close();\r\n                }\r\n            }\r\n            return answer;\r\n        }\r\n\r\n        public Object next() {\r\n            Object part = iterator.next();\r\n            Exchange newExchange = ExchangeHelper.createCopy(exchange, true);\r\n            if (part instanceof Message) {\r\n                newExchange.setIn((Message) part);\r\n            } else {\r\n                Message in = newExchange.getIn();\r\n                in.setBody(part);\r\n            }\r\n            return createProcessorExchangePair(index++, getProcessors().iterator().next(), newExchange);\r\n        }\r\n\r\n        public void remove() {\r\n            throw new UnsupportedOperationException(\"Remove is not supported by this iterator\");\r\n        }\r\n    };\r\n}","lc":0.9545454545,"pi":0.8325358852,"ma":0.6,"nbd":1.0,"ml":0.3333333333,"d":0.003968254,"mi":-0.5613812544,"fo":0.6666666667,"r":-0.0263157895,"e":0.1607233623}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3420_be97d017","label":3,"code":"\/**\r\n *  @see org.apache.wicket.pageStore.IPageStore#restoreAfterSerialization(java.io.Serializable)\r\n *\/\r\npublic Object restoreAfterSerialization(final Serializable serializable) {\r\n    if (serializable == null) {\r\n        return null;\r\n    } else if (!storeAfterSessionReplication() || serializable instanceof Page) {\r\n        return serializable;\r\n    } else if (serializable instanceof SerializedPage) {\r\n        SerializedPage page = (SerializedPage) serializable;\r\n        if (page.getData() != null) {\r\n            storePageData(page.getSessionId(), page.getPageId(), page.getData());\r\n            return new SerializedPage(page.getSessionId(), page.getPageId(), null);\r\n        }\r\n        return page;\r\n    }\r\n    String type = serializable.getClass().getName();\r\n    throw new IllegalArgumentException(\"Unknown object type \" + type);\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.pageStore.IPageStore#restoreAfterSerialization(java.io.Serializable)\r\n *\/\r\n","code_no_comment":"public Object restoreAfterSerialization(final Serializable serializable) {\r\n    if (serializable == null) {\r\n        return null;\r\n    } else if (!storeAfterSessionReplication() || serializable instanceof Page) {\r\n        return serializable;\r\n    } else if (serializable instanceof SerializedPage) {\r\n        SerializedPage page = (SerializedPage) serializable;\r\n        if (page.getData() != null) {\r\n            storePageData(page.getSessionId(), page.getPageId(), page.getData());\r\n            return new SerializedPage(page.getSessionId(), page.getPageId(), null);\r\n        }\r\n        return page;\r\n    }\r\n    String type = serializable.getClass().getName();\r\n    throw new IllegalArgumentException(\"Unknown object type \" + type);\r\n}","lc":0.0909090909,"pi":0.2248803828,"ma":0.4,"nbd":1.0,"ml":0.25,"d":0.9146825397,"mi":-0.1278365046,"fo":0.3333333333,"r":-0.0263157895,"e":0.536083401}
{"project_name":"Lang","project_version":"65","label":1,"code":"\/\/ -----------------------------------------------------------------------\r\n\/**\r\n * <p>Internal calculation method.<\/p>\r\n *\r\n * @param val  the calendar\r\n * @param field  the field constant\r\n * @param round  true to round, false to truncate\r\n * @throws ArithmeticException if the year is over 280 million\r\n *\/\r\nprivate static void modify(Calendar val, int field, boolean round) {\r\n    if (val.get(Calendar.YEAR) > 280000000) {\r\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\r\n    }\r\n    \/\/ ----------------- Fix for LANG-59 ---------------------- START ---------------\r\n    \/\/ see http:\/\/issues.apache.org\/jira\/browse\/LANG-59\r\n    \/\/ \r\n    \/\/ Manually truncate milliseconds, seconds and minutes, rather than using\r\n    \/\/ Calendar methods.\r\n    \/\/ truncate milliseconds\r\n    \/\/ truncate seconds\r\n    \/\/ truncate minutes\r\n    \/\/ reset time\r\n    \/\/ ----------------- Fix for LANG-59 ----------------------- END ----------------\r\n    boolean roundUp = false;\r\n    for (int i = 0; i < fields.length; i++) {\r\n        for (int j = 0; j < fields[i].length; j++) {\r\n            if (fields[i][j] == field) {\r\n                \/\/ This is our field... we stop looping\r\n                if (round && roundUp) {\r\n                    if (field == DateUtils.SEMI_MONTH) {\r\n                        \/\/ we subtract 15 days and add 1 month\r\n                        if (val.get(Calendar.DATE) == 1) {\r\n                            val.add(Calendar.DATE, 15);\r\n                        } else {\r\n                            val.add(Calendar.DATE, -15);\r\n                            val.add(Calendar.MONTH, 1);\r\n                        }\r\n                    } else {\r\n                        \/\/ We need at add one to this field since the\r\n                        \/\/ last number causes us to round up\r\n                        val.add(fields[i][0], 1);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        \/\/ We have various fields that are not easy roundings\r\n        int offset = 0;\r\n        boolean offsetSet = false;\r\n        \/\/ These are special types of fields that require different rounding rules\r\n        switch(field) {\r\n            case DateUtils.SEMI_MONTH:\r\n                if (fields[i][0] == Calendar.DATE) {\r\n                    \/\/ If we're going to drop the DATE field's value,\r\n                    \/\/ we want to do this our own way.\r\n                    \/\/ We need to subtrace 1 since the date has a minimum of 1\r\n                    offset = val.get(Calendar.DATE) - 1;\r\n                    \/\/ bottom half of the month and should stay accordingly.\r\n                    if (offset >= 15) {\r\n                        offset -= 15;\r\n                    }\r\n                    \/\/ Record whether we're in the top or bottom half of that range\r\n                    roundUp = offset > 7;\r\n                    offsetSet = true;\r\n                }\r\n                break;\r\n            case Calendar.AM_PM:\r\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\r\n                    \/\/ If we're going to drop the HOUR field's value,\r\n                    \/\/ we want to do this our own way.\r\n                    offset = val.get(Calendar.HOUR_OF_DAY);\r\n                    if (offset >= 12) {\r\n                        offset -= 12;\r\n                    }\r\n                    roundUp = offset > 6;\r\n                    offsetSet = true;\r\n                }\r\n                break;\r\n        }\r\n        if (!offsetSet) {\r\n            int min = val.getActualMinimum(fields[i][0]);\r\n            int max = val.getActualMaximum(fields[i][0]);\r\n            \/\/ Calculate the offset from the minimum allowed value\r\n            offset = val.get(fields[i][0]) - min;\r\n            \/\/ Set roundUp if this is more than half way between the minimum and maximum\r\n            roundUp = offset > ((max - min) \/ 2);\r\n        }\r\n        \/\/ We need to remove this field\r\n        val.set(fields[i][0], val.get(fields[i][0]) - offset);\r\n    }\r\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\r\n}","code_comment":"\/**\r\n * <p>Internal calculation method.<\/p>\r\n *\r\n * @param val  the calendar\r\n * @param field  the field constant\r\n * @param round  true to round, false to truncate\r\n * @throws ArithmeticException if the year is over 280 million\r\n *\/\r\n","code_no_comment":"private static void modify(Calendar val, int field, boolean round) {\r\n    if (val.get(Calendar.YEAR) > 280000000) {\r\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\r\n    }\r\n                                            boolean roundUp = false;\r\n    for (int i = 0; i < fields.length; i++) {\r\n        for (int j = 0; j < fields[i].length; j++) {\r\n            if (fields[i][j] == field) {\r\n                                if (round && roundUp) {\r\n                    if (field == DateUtils.SEMI_MONTH) {\r\n                                                if (val.get(Calendar.DATE) == 1) {\r\n                            val.add(Calendar.DATE, 15);\r\n                        } else {\r\n                            val.add(Calendar.DATE, -15);\r\n                            val.add(Calendar.MONTH, 1);\r\n                        }\r\n                    } else {\r\n                                                                        val.add(fields[i][0], 1);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n        }\r\n                int offset = 0;\r\n        boolean offsetSet = false;\r\n                switch(field) {\r\n            case DateUtils.SEMI_MONTH:\r\n                if (fields[i][0] == Calendar.DATE) {\r\n                                                                                offset = val.get(Calendar.DATE) - 1;\r\n                                        if (offset >= 15) {\r\n                        offset -= 15;\r\n                    }\r\n                                        roundUp = offset > 7;\r\n                    offsetSet = true;\r\n                }\r\n                break;\r\n            case Calendar.AM_PM:\r\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\r\n                                                            offset = val.get(Calendar.HOUR_OF_DAY);\r\n                    if (offset >= 12) {\r\n                        offset -= 12;\r\n                    }\r\n                    roundUp = offset > 6;\r\n                    offsetSet = true;\r\n                }\r\n                break;\r\n        }\r\n        if (!offsetSet) {\r\n            int min = val.getActualMinimum(fields[i][0]);\r\n            int max = val.getActualMaximum(fields[i][0]);\r\n                        offset = val.get(fields[i][0]) - min;\r\n                        roundUp = offset > ((max - min) \/ 2);\r\n        }\r\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\r\n    }\r\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\r\n}","lc":1.9545454545,"pi":2.0717703349,"ma":3.0,"nbd":2.0,"ml":1.75,"d":3.9146825397,"mi":-1.0191684285,"fo":0.5833333333,"r":-0.0263157895,"e":10.8259977064}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5486_a79ed51e","label":3,"code":"\/**\r\n *  Should the page be rendered immediately.\r\n *\/\r\nprotected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url currentUrl, Url targetUrl) {\r\n    \/\/ WICKET-5484 never render and write for Ajax requests\r\n    if (isAjax(cycle)) {\r\n        return false;\r\n    }\r\n    return neverRedirect(getRedirectPolicy()) || ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(), isPageStateless()))) || (targetUrl.equals(currentUrl) && isRedirectToRender()) || shouldPreserveClientUrl(cycle);\r\n}","code_comment":"\/**\r\n *  Should the page be rendered immediately.\r\n *\/\r\n","code_no_comment":"protected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url currentUrl, Url targetUrl) {\r\n        if (isAjax(cycle)) {\r\n        return false;\r\n    }\r\n    return neverRedirect(getRedirectPolicy()) || ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(), isPageStateless()))) || (targetUrl.equals(currentUrl) && isRedirectToRender()) || shouldPreserveClientUrl(cycle);\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0734126984,"mi":0.4170542636,"fo":0.5833333333,"r":1.5526315789,"e":-0.0643119356}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public boolean equals(setTableProperty_result that) {\r\n    if (that == null)\r\n        return false;\r\n    boolean this_present_ouch1 = true && this.isSetOuch1();\r\n    boolean that_present_ouch1 = true && that.isSetOuch1();\r\n    if (this_present_ouch1 || that_present_ouch1) {\r\n        if (!(this_present_ouch1 && that_present_ouch1))\r\n            return false;\r\n        if (!this.ouch1.equals(that.ouch1))\r\n            return false;\r\n    }\r\n    boolean this_present_ouch2 = true && this.isSetOuch2();\r\n    boolean that_present_ouch2 = true && that.isSetOuch2();\r\n    if (this_present_ouch2 || that_present_ouch2) {\r\n        if (!(this_present_ouch2 && that_present_ouch2))\r\n            return false;\r\n        if (!this.ouch2.equals(that.ouch2))\r\n            return false;\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"public boolean equals(setTableProperty_result that) {\r\n    if (that == null)\r\n        return false;\r\n    boolean this_present_ouch1 = true && this.isSetOuch1();\r\n    boolean that_present_ouch1 = true && that.isSetOuch1();\r\n    if (this_present_ouch1 || that_present_ouch1) {\r\n        if (!(this_present_ouch1 && that_present_ouch1))\r\n            return false;\r\n        if (!this.ouch1.equals(that.ouch1))\r\n            return false;\r\n    }\r\n    boolean this_present_ouch2 = true && this.isSetOuch2();\r\n    boolean that_present_ouch2 = true && that.isSetOuch2();\r\n    if (this_present_ouch2 || that_present_ouch2) {\r\n        if (!(this_present_ouch2 && that_present_ouch2))\r\n            return false;\r\n        if (!this.ouch2.equals(that.ouch2))\r\n            return false;\r\n    }\r\n    return true;\r\n}","lc":0.3181818182,"pi":0.3014354067,"ma":0.8,"nbd":-0.5,"ml":1.25,"d":0.746031746,"mi":-0.2769556025,"fo":0.0,"r":-0.0263157895,"e":0.4955492932}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-939_49444ee6","label":1,"code":"\/**\r\n * Throws MathIllegalArgumentException if the matrix does not have at least\r\n * two columns and two rows.\r\n * @param matrix matrix to check\r\n * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\r\n * to compute covariance\r\n *\/\r\nprivate void checkSufficientData(final RealMatrix matrix) throws MathIllegalArgumentException {\r\n    int nRows = matrix.getRowDimension();\r\n    int nCols = matrix.getColumnDimension();\r\n    if (nRows < 2 || nCols < 2) {\r\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS, nRows, nCols);\r\n    }\r\n}","code_comment":"\/**\r\n * Throws MathIllegalArgumentException if the matrix does not have at least\r\n * two columns and two rows.\r\n * @param matrix matrix to check\r\n * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\r\n * to compute covariance\r\n *\/\r\n","code_no_comment":"private void checkSufficientData(final RealMatrix matrix) throws MathIllegalArgumentException {\r\n    int nRows = matrix.getRowDimension();\r\n    int nCols = matrix.getColumnDimension();\r\n    if (nRows < 2 || nCols < 2) {\r\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS, nRows, nCols);\r\n    }\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0337301587,"mi":0.3978858351,"fo":-0.3333333333,"r":1.7105263158,"e":-0.0877416827}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-367_3a15d8ce","label":3,"code":"\/**\r\n * Advance an entry up to the next non null one.\r\n * @param e entry to advance\r\n *\/\r\nprotected void advance(EntryImpl e) {\r\n    if (e == null) {\r\n        return;\r\n    }\r\n    do {\r\n        e.setIndex(e.getIndex() + 1);\r\n    } while (e.getIndex() < dim && e.getValue() == 0);\r\n    if (e.getIndex() >= dim) {\r\n        e.setIndex(-1);\r\n    }\r\n}","code_comment":"\/**\r\n * Advance an entry up to the next non null one.\r\n * @param e entry to advance\r\n *\/\r\n","code_no_comment":"protected void advance(EntryImpl e) {\r\n    if (e == null) {\r\n        return;\r\n    }\r\n    do {\r\n        e.setIndex(e.getIndex() + 1);\r\n    } while (e.getIndex() < dim && e.getValue() == 0);\r\n    if (e.getIndex() >= dim) {\r\n        e.setIndex(-1);\r\n    }\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":0.0,"nbd":-0.5,"ml":0.25,"d":0.878968254,"mi":0.1517970402,"fo":0.0,"r":1.6315789474,"e":0.1918293252}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-414_5fe9b36c","label":3,"code":"\/**\r\n * For this distribution, {@code X}, this method returns {@code P(X < x)}.\r\n *\r\n * @param x Value at which the CDF is evaluated.\r\n * @return CDF evaluated at {@code x}.\r\n * @throws MathException if the algorithm fails to converge; unless\r\n * {@code x} is more than 20 standard deviations from the mean, in which\r\n * case the convergence exception is caught and 0 or 1 is returned.\r\n *\/\r\npublic double cumulativeProbability(double x) throws MathException {\r\n    try {\r\n        return 0.5 * (1.0 + Erf.erf((x - mean) \/ (standardDeviation * FastMath.sqrt(2.0))));\r\n    } catch (MaxIterationsExceededException ex) {\r\n        if (x < (mean - 20 * standardDeviation)) {\r\n            \/\/ JDK 1.5 blows at 38\r\n            return 0;\r\n        } else if (x > (mean + 20 * standardDeviation)) {\r\n            return 1;\r\n        } else {\r\n            throw ex;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * For this distribution, {@code X}, this method returns {@code P(X < x)}.\r\n *\r\n * @param x Value at which the CDF is evaluated.\r\n * @return CDF evaluated at {@code x}.\r\n * @throws MathException if the algorithm fails to converge; unless\r\n * {@code x} is more than 20 standard deviations from the mean, in which\r\n * case the convergence exception is caught and 0 or 1 is returned.\r\n *\/\r\n","code_no_comment":"public double cumulativeProbability(double x) throws MathException {\r\n    try {\r\n        return 0.5 * (1.0 + Erf.erf((x - mean) \/ (standardDeviation * FastMath.sqrt(2.0))));\r\n    } catch (MaxIterationsExceededException ex) {\r\n        if (x < (mean - 20 * standardDeviation)) {\r\n                        return 0;\r\n        } else if (x > (mean + 20 * standardDeviation)) {\r\n            return 1;\r\n        } else {\r\n            throw ex;\r\n        }\r\n    }\r\n}","lc":-0.0454545455,"pi":0.4641148325,"ma":0.2,"nbd":0.5,"ml":0.0,"d":0.5277777778,"mi":0.0173361522,"fo":-0.3333333333,"r":0.8684210526,"e":0.1986710695}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1429_c2f5ca6c","label":1,"code":"private String diffImpl(DocumentNodeState from, DocumentNodeState to) throws MicroKernelException {\r\n    JsopWriter w = new JsopStream();\r\n    diffProperties(from, to, w);\r\n    \/\/ TODO this does not work well for large child node lists\r\n    \/\/ use a document store index instead\r\n    int max = MANY_CHILDREN_THRESHOLD;\r\n    DocumentNodeState.Children fromChildren, toChildren;\r\n    fromChildren = getChildren(from, null, max);\r\n    toChildren = getChildren(to, null, max);\r\n    if (!fromChildren.hasMore && !toChildren.hasMore) {\r\n        diffFewChildren(w, fromChildren, from.getLastRevision(), toChildren, to.getLastRevision());\r\n    } else {\r\n        if (FAST_DIFF) {\r\n            diffManyChildren(w, from.getPath(), from.getLastRevision(), to.getLastRevision());\r\n        } else {\r\n            max = Integer.MAX_VALUE;\r\n            fromChildren = getChildren(from, null, max);\r\n            toChildren = getChildren(to, null, max);\r\n            diffFewChildren(w, fromChildren, from.getLastRevision(), toChildren, to.getLastRevision());\r\n        }\r\n    }\r\n    return w.toString();\r\n}","code_comment":null,"code_no_comment":"private String diffImpl(DocumentNodeState from, DocumentNodeState to) throws MicroKernelException {\r\n    JsopWriter w = new JsopStream();\r\n    diffProperties(from, to, w);\r\n            int max = MANY_CHILDREN_THRESHOLD;\r\n    DocumentNodeState.Children fromChildren, toChildren;\r\n    fromChildren = getChildren(from, null, max);\r\n    toChildren = getChildren(to, null, max);\r\n    if (!fromChildren.hasMore && !toChildren.hasMore) {\r\n        diffFewChildren(w, fromChildren, from.getLastRevision(), toChildren, to.getLastRevision());\r\n    } else {\r\n        if (FAST_DIFF) {\r\n            diffManyChildren(w, from.getPath(), from.getLastRevision(), to.getLastRevision());\r\n        } else {\r\n            max = Integer.MAX_VALUE;\r\n            fromChildren = getChildren(from, null, max);\r\n            toChildren = getChildren(to, null, max);\r\n            diffFewChildren(w, fromChildren, from.getLastRevision(), toChildren, to.getLastRevision());\r\n        }\r\n    }\r\n    return w.toString();\r\n}","lc":0.3181818182,"pi":0.3971291866,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":0.1865079365,"mi":-0.3164200141,"fo":0.8333333333,"r":-0.0263157895,"e":0.3713467379}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-832_411dad65","label":0,"code":"\/**\r\n * Loads classes not located via Reflection.getCallerClass.\r\n *\r\n * @param lastLoader\r\n *        The ClassLoader that loaded the Class that called this Class.\r\n * @param className\r\n *        The name of the Class.\r\n * @return The Class object for the Class or null if it could not be located.\r\n *\/\r\nprivate Class<?> loadClass(final ClassLoader lastLoader, final String className) {\r\n    \/\/ XXX: this is overly complicated\r\n    Class<?> clazz;\r\n    if (lastLoader != null) {\r\n        try {\r\n            clazz = Loader.initializeClass(className, lastLoader);\r\n            if (clazz != null) {\r\n                return clazz;\r\n            }\r\n        } catch (final Exception ignore) {\r\n        \/\/ Ignore exception.\r\n        }\r\n    }\r\n    try {\r\n        clazz = Loader.loadClass(className);\r\n    } catch (final ClassNotFoundException ignored) {\r\n        try {\r\n            clazz = Loader.initializeClass(className, this.getClass().getClassLoader());\r\n        } catch (final ClassNotFoundException ignore) {\r\n            return null;\r\n        }\r\n    }\r\n    return clazz;\r\n}","code_comment":"\/**\r\n * Loads classes not located via Reflection.getCallerClass.\r\n *\r\n * @param lastLoader\r\n *        The ClassLoader that loaded the Class that called this Class.\r\n * @param className\r\n *        The name of the Class.\r\n * @return The Class object for the Class or null if it could not be located.\r\n *\/\r\n","code_no_comment":"private Class<?> loadClass(final ClassLoader lastLoader, final String className) {\r\n        Class<?> clazz;\r\n    if (lastLoader != null) {\r\n        try {\r\n            clazz = Loader.initializeClass(className, lastLoader);\r\n            if (clazz != null) {\r\n                return clazz;\r\n            }\r\n        } catch (final Exception ignore) {\r\n                }\r\n    }\r\n    try {\r\n        clazz = Loader.loadClass(className);\r\n    } catch (final ClassNotFoundException ignored) {\r\n        try {\r\n            clazz = Loader.initializeClass(className, this.getClass().getClassLoader());\r\n        } catch (final ClassNotFoundException ignore) {\r\n            return null;\r\n        }\r\n    }\r\n    return clazz;\r\n}","lc":0.3636363636,"pi":0.5358851675,"ma":0.4,"nbd":0.5,"ml":-0.0833333333,"d":0.0674603175,"mi":-0.2326990839,"fo":-0.0833333333,"r":0.1052631579,"e":0.0162307014}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-9672_84922699","label":3,"code":"@SuppressWarnings({ \"deprecation\", \"unchecked\" })\r\npublic Object getManagedObjectForProcessor(CamelContext context, Processor processor, ProcessorDefinition<?> definition, Route route) {\r\n    ManagedProcessor answer = null;\r\n    if (definition instanceof RecipientListDefinition) {\r\n        \/\/ special for RecipientListDefinition, as the processor is wrapped in a pipeline as last\r\n        Pipeline pipeline = (Pipeline) processor;\r\n        Iterator<Processor> it = pipeline.getProcessors().iterator();\r\n        while (it.hasNext()) {\r\n            processor = it.next();\r\n        }\r\n    } else if (definition instanceof ThreadsDefinition) {\r\n        \/\/ special for ThreadsDefinition, as the processor is wrapped in a pipeline as first\r\n        Pipeline pipeline = (Pipeline) processor;\r\n        Iterator<Processor> it = pipeline.getProcessors().iterator();\r\n        processor = it.next();\r\n    }\r\n    \/\/ unwrap delegates as we want the real target processor\r\n    Processor target = processor;\r\n    while (target != null) {\r\n        \/\/ skip error handlers\r\n        if (target instanceof ErrorHandler) {\r\n            return false;\r\n        }\r\n        if (target instanceof ConvertBodyProcessor) {\r\n            answer = new ManagedConvertBody(context, (ConvertBodyProcessor) target, definition);\r\n        } else if (target instanceof ChoiceProcessor) {\r\n            answer = new ManagedChoice(context, (ChoiceProcessor) target, definition);\r\n        } else if (target instanceof Delayer) {\r\n            answer = new ManagedDelayer(context, (Delayer) target, definition);\r\n        } else if (target instanceof Throttler) {\r\n            answer = new ManagedThrottler(context, (Throttler) target, definition);\r\n        } else if (target instanceof DynamicRouter) {\r\n            answer = new ManagedDynamicRouter(context, (DynamicRouter) target, (org.apache.camel.model.DynamicRouterDefinition) definition);\r\n        } else if (target instanceof RoutingSlip) {\r\n            answer = new ManagedRoutingSlip(context, (RoutingSlip) target, (org.apache.camel.model.RoutingSlipDefinition) definition);\r\n        } else if (target instanceof FilterProcessor) {\r\n            answer = new ManagedFilter(context, (FilterProcessor) target, (org.apache.camel.model.FilterDefinition) definition);\r\n        } else if (target instanceof LogProcessor) {\r\n            answer = new ManagedLog(context, (LogProcessor) target, definition);\r\n        } else if (target instanceof LoopProcessor) {\r\n            answer = new ManagedLoop(context, (LoopProcessor) target, (org.apache.camel.model.LoopDefinition) definition);\r\n        } else if (target instanceof MarshalProcessor) {\r\n            answer = new ManagedMarshal(context, (MarshalProcessor) target, (org.apache.camel.model.MarshalDefinition) definition);\r\n        } else if (target instanceof UnmarshalProcessor) {\r\n            answer = new ManagedUnmarshal(context, (UnmarshalProcessor) target, (org.apache.camel.model.UnmarshalDefinition) definition);\r\n        } else if (target instanceof CircuitBreakerLoadBalancer) {\r\n            answer = new ManagedCircuitBreakerLoadBalancer(context, (CircuitBreakerLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\r\n        } else if (target instanceof FailOverLoadBalancer) {\r\n            answer = new ManagedFailoverLoadBalancer(context, (FailOverLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\r\n        } else if (target instanceof RandomLoadBalancer) {\r\n            answer = new ManagedRandomLoadBalancer(context, (RandomLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\r\n        } else if (target instanceof RoundRobinLoadBalancer) {\r\n            answer = new ManagedRoundRobinLoadBalancer(context, (RoundRobinLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\r\n        } else if (target instanceof StickyLoadBalancer) {\r\n            answer = new ManagedStickyLoadBalancer(context, (StickyLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\r\n        } else if (target instanceof TopicLoadBalancer) {\r\n            answer = new ManagedTopicLoadBalancer(context, (TopicLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\r\n        } else if (target instanceof WeightedLoadBalancer) {\r\n            answer = new ManagedWeightedLoadBalancer(context, (WeightedLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\r\n        } else if (target instanceof RecipientList) {\r\n            answer = new ManagedRecipientList(context, (RecipientList) target, (RecipientListDefinition) definition);\r\n        } else if (target instanceof Splitter) {\r\n            answer = new ManagedSplitter(context, (Splitter) target, (org.apache.camel.model.SplitDefinition) definition);\r\n        } else if (target instanceof MulticastProcessor) {\r\n            answer = new ManagedMulticast(context, (MulticastProcessor) target, definition);\r\n        } else if (target instanceof SamplingThrottler) {\r\n            answer = new ManagedSamplingThrottler(context, (SamplingThrottler) target, definition);\r\n        } else if (target instanceof Resequencer) {\r\n            answer = new ManagedResequencer(context, (Resequencer) target, definition);\r\n        } else if (target instanceof RollbackProcessor) {\r\n            answer = new ManagedRollback(context, (RollbackProcessor) target, definition);\r\n        } else if (target instanceof StreamResequencer) {\r\n            answer = new ManagedResequencer(context, (StreamResequencer) target, definition);\r\n        } else if (target instanceof SetBodyProcessor) {\r\n            answer = new ManagedSetBody(context, (SetBodyProcessor) target, (org.apache.camel.model.SetBodyDefinition) definition);\r\n        } else if (target instanceof RemoveHeaderProcessor) {\r\n            answer = new ManagedRemoveHeader(context, (RemoveHeaderProcessor) target, definition);\r\n        } else if (target instanceof RemoveHeadersProcessor) {\r\n            answer = new ManagedRemoveHeaders(context, (RemoveHeadersProcessor) target, definition);\r\n        } else if (target instanceof SetHeaderProcessor) {\r\n            answer = new ManagedSetHeader(context, (SetHeaderProcessor) target, (org.apache.camel.model.SetHeaderDefinition) definition);\r\n        } else if (target instanceof RemovePropertyProcessor) {\r\n            answer = new ManagedRemoveProperty(context, (RemovePropertyProcessor) target, definition);\r\n        } else if (target instanceof RemovePropertiesProcessor) {\r\n            answer = new ManagedRemoveProperties(context, (RemovePropertiesProcessor) target, definition);\r\n        } else if (target instanceof SetPropertyProcessor) {\r\n            answer = new ManagedSetProperty(context, (SetPropertyProcessor) target, (org.apache.camel.model.SetPropertyDefinition) definition);\r\n        } else if (target instanceof ExchangePatternProcessor) {\r\n            answer = new ManagedSetExchangePattern(context, (ExchangePatternProcessor) target, definition);\r\n        } else if (target instanceof ScriptProcessor) {\r\n            answer = new ManagedScript(context, (ScriptProcessor) target, (org.apache.camel.model.ScriptDefinition) definition);\r\n        } else if (target instanceof StopProcessor) {\r\n            answer = new ManagedStop(context, (StopProcessor) target, definition);\r\n        } else if (target instanceof ThreadsProcessor) {\r\n            answer = new ManagedThreads(context, (ThreadsProcessor) target, definition);\r\n        } else if (target instanceof ThrowExceptionProcessor) {\r\n            answer = new ManagedThrowException(context, (ThrowExceptionProcessor) target, definition);\r\n        } else if (target instanceof TransformProcessor) {\r\n            answer = new ManagedTransformer(context, (TransformProcessor) target, (org.apache.camel.model.TransformDefinition) definition);\r\n        } else if (target instanceof PredicateValidatingProcessor) {\r\n            answer = new ManagedValidate(context, (PredicateValidatingProcessor) target, (org.apache.camel.model.ValidateDefinition) definition);\r\n        } else if (target instanceof WireTapProcessor) {\r\n            answer = new ManagedWireTapProcessor(context, (WireTapProcessor) target, definition);\r\n        } else if (target instanceof SendDynamicProcessor) {\r\n            answer = new ManagedSendDynamicProcessor(context, (SendDynamicProcessor) target, definition);\r\n        } else if (target instanceof SendProcessor) {\r\n            SendProcessor sp = (SendProcessor) target;\r\n            \/\/ special for sending to throughput logger\r\n            if (sp.getDestination() instanceof LogEndpoint) {\r\n                LogEndpoint le = (LogEndpoint) sp.getDestination();\r\n                if (le.getLogger() instanceof ThroughputLogger) {\r\n                    ThroughputLogger tl = (ThroughputLogger) le.getLogger();\r\n                    answer = new ManagedThroughputLogger(context, tl, definition);\r\n                }\r\n            }\r\n            \/\/ regular send processor\r\n            if (answer == null) {\r\n                answer = new ManagedSendProcessor(context, (SendProcessor) target, definition);\r\n            }\r\n        } else if (target instanceof BeanProcessor) {\r\n            answer = new ManagedBeanProcessor(context, (BeanProcessor) target, definition);\r\n        } else if (target instanceof IdempotentConsumer) {\r\n            answer = new ManagedIdempotentConsumer(context, (IdempotentConsumer) target, (org.apache.camel.model.IdempotentConsumerDefinition) definition);\r\n        } else if (target instanceof AggregateProcessor) {\r\n            answer = new ManagedAggregateProcessor(context, (AggregateProcessor) target, (org.apache.camel.model.AggregateDefinition) definition);\r\n        } else if (target instanceof Enricher) {\r\n            answer = new ManagedEnricher(context, (Enricher) target, (org.apache.camel.model.EnrichDefinition) definition);\r\n        } else if (target instanceof PollEnricher) {\r\n            answer = new ManagedPollEnricher(context, (PollEnricher) target, (org.apache.camel.model.PollEnrichDefinition) definition);\r\n        } else if (target instanceof org.apache.camel.spi.ManagementAware) {\r\n            return ((org.apache.camel.spi.ManagementAware<Processor>) target).getManagedObject(processor);\r\n        }\r\n        \/\/ special for custom load balancer\r\n        if (definition instanceof LoadBalanceDefinition) {\r\n            LoadBalanceDefinition lb = (LoadBalanceDefinition) definition;\r\n            if (lb.getLoadBalancerType() instanceof CustomLoadBalancerDefinition) {\r\n                answer = new ManagedCustomLoadBalancer(context, (LoadBalancer) target, (LoadBalanceDefinition) definition);\r\n            }\r\n        }\r\n        if (answer != null) {\r\n            \/\/ break out as we found an answer\r\n            break;\r\n        }\r\n        \/\/ no answer yet, so unwrap any delegates and try again\r\n        if (target instanceof DelegateProcessor) {\r\n            target = ((DelegateProcessor) target).getProcessor();\r\n        } else {\r\n            \/\/ no delegate so we dont have any target to try next\r\n            break;\r\n        }\r\n    }\r\n    if (answer == null && definition instanceof ProcessDefinition) {\r\n        answer = new ManagedProcess(context, target, (ProcessDefinition) definition);\r\n    } else if (answer == null) {\r\n        \/\/ fallback to a generic processor\r\n        answer = new ManagedProcessor(context, target, definition);\r\n    }\r\n    answer.setRoute(route);\r\n    answer.init(context.getManagementStrategy());\r\n    return answer;\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings({ \"deprecation\", \"unchecked\" })\r\npublic Object getManagedObjectForProcessor(CamelContext context, Processor processor, ProcessorDefinition<?> definition, Route route) {\r\n    ManagedProcessor answer = null;\r\n    if (definition instanceof RecipientListDefinition) {\r\n                Pipeline pipeline = (Pipeline) processor;\r\n        Iterator<Processor> it = pipeline.getProcessors().iterator();\r\n        while (it.hasNext()) {\r\n            processor = it.next();\r\n        }\r\n    } else if (definition instanceof ThreadsDefinition) {\r\n                Pipeline pipeline = (Pipeline) processor;\r\n        Iterator<Processor> it = pipeline.getProcessors().iterator();\r\n        processor = it.next();\r\n    }\r\n        Processor target = processor;\r\n    while (target != null) {\r\n                if (target instanceof ErrorHandler) {\r\n            return false;\r\n        }\r\n        if (target instanceof ConvertBodyProcessor) {\r\n            answer = new ManagedConvertBody(context, (ConvertBodyProcessor) target, definition);\r\n        } else if (target instanceof ChoiceProcessor) {\r\n            answer = new ManagedChoice(context, (ChoiceProcessor) target, definition);\r\n        } else if (target instanceof Delayer) {\r\n            answer = new ManagedDelayer(context, (Delayer) target, definition);\r\n        } else if (target instanceof Throttler) {\r\n            answer = new ManagedThrottler(context, (Throttler) target, definition);\r\n        } else if (target instanceof DynamicRouter) {\r\n            answer = new ManagedDynamicRouter(context, (DynamicRouter) target, (org.apache.camel.model.DynamicRouterDefinition) definition);\r\n        } else if (target instanceof RoutingSlip) {\r\n            answer = new ManagedRoutingSlip(context, (RoutingSlip) target, (org.apache.camel.model.RoutingSlipDefinition) definition);\r\n        } else if (target instanceof FilterProcessor) {\r\n            answer = new ManagedFilter(context, (FilterProcessor) target, (org.apache.camel.model.FilterDefinition) definition);\r\n        } else if (target instanceof LogProcessor) {\r\n            answer = new ManagedLog(context, (LogProcessor) target, definition);\r\n        } else if (target instanceof LoopProcessor) {\r\n            answer = new ManagedLoop(context, (LoopProcessor) target, (org.apache.camel.model.LoopDefinition) definition);\r\n        } else if (target instanceof MarshalProcessor) {\r\n            answer = new ManagedMarshal(context, (MarshalProcessor) target, (org.apache.camel.model.MarshalDefinition) definition);\r\n        } else if (target instanceof UnmarshalProcessor) {\r\n            answer = new ManagedUnmarshal(context, (UnmarshalProcessor) target, (org.apache.camel.model.UnmarshalDefinition) definition);\r\n        } else if (target instanceof CircuitBreakerLoadBalancer) {\r\n            answer = new ManagedCircuitBreakerLoadBalancer(context, (CircuitBreakerLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\r\n        } else if (target instanceof FailOverLoadBalancer) {\r\n            answer = new ManagedFailoverLoadBalancer(context, (FailOverLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\r\n        } else if (target instanceof RandomLoadBalancer) {\r\n            answer = new ManagedRandomLoadBalancer(context, (RandomLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\r\n        } else if (target instanceof RoundRobinLoadBalancer) {\r\n            answer = new ManagedRoundRobinLoadBalancer(context, (RoundRobinLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\r\n        } else if (target instanceof StickyLoadBalancer) {\r\n            answer = new ManagedStickyLoadBalancer(context, (StickyLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\r\n        } else if (target instanceof TopicLoadBalancer) {\r\n            answer = new ManagedTopicLoadBalancer(context, (TopicLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\r\n        } else if (target instanceof WeightedLoadBalancer) {\r\n            answer = new ManagedWeightedLoadBalancer(context, (WeightedLoadBalancer) target, (org.apache.camel.model.LoadBalanceDefinition) definition);\r\n        } else if (target instanceof RecipientList) {\r\n            answer = new ManagedRecipientList(context, (RecipientList) target, (RecipientListDefinition) definition);\r\n        } else if (target instanceof Splitter) {\r\n            answer = new ManagedSplitter(context, (Splitter) target, (org.apache.camel.model.SplitDefinition) definition);\r\n        } else if (target instanceof MulticastProcessor) {\r\n            answer = new ManagedMulticast(context, (MulticastProcessor) target, definition);\r\n        } else if (target instanceof SamplingThrottler) {\r\n            answer = new ManagedSamplingThrottler(context, (SamplingThrottler) target, definition);\r\n        } else if (target instanceof Resequencer) {\r\n            answer = new ManagedResequencer(context, (Resequencer) target, definition);\r\n        } else if (target instanceof RollbackProcessor) {\r\n            answer = new ManagedRollback(context, (RollbackProcessor) target, definition);\r\n        } else if (target instanceof StreamResequencer) {\r\n            answer = new ManagedResequencer(context, (StreamResequencer) target, definition);\r\n        } else if (target instanceof SetBodyProcessor) {\r\n            answer = new ManagedSetBody(context, (SetBodyProcessor) target, (org.apache.camel.model.SetBodyDefinition) definition);\r\n        } else if (target instanceof RemoveHeaderProcessor) {\r\n            answer = new ManagedRemoveHeader(context, (RemoveHeaderProcessor) target, definition);\r\n        } else if (target instanceof RemoveHeadersProcessor) {\r\n            answer = new ManagedRemoveHeaders(context, (RemoveHeadersProcessor) target, definition);\r\n        } else if (target instanceof SetHeaderProcessor) {\r\n            answer = new ManagedSetHeader(context, (SetHeaderProcessor) target, (org.apache.camel.model.SetHeaderDefinition) definition);\r\n        } else if (target instanceof RemovePropertyProcessor) {\r\n            answer = new ManagedRemoveProperty(context, (RemovePropertyProcessor) target, definition);\r\n        } else if (target instanceof RemovePropertiesProcessor) {\r\n            answer = new ManagedRemoveProperties(context, (RemovePropertiesProcessor) target, definition);\r\n        } else if (target instanceof SetPropertyProcessor) {\r\n            answer = new ManagedSetProperty(context, (SetPropertyProcessor) target, (org.apache.camel.model.SetPropertyDefinition) definition);\r\n        } else if (target instanceof ExchangePatternProcessor) {\r\n            answer = new ManagedSetExchangePattern(context, (ExchangePatternProcessor) target, definition);\r\n        } else if (target instanceof ScriptProcessor) {\r\n            answer = new ManagedScript(context, (ScriptProcessor) target, (org.apache.camel.model.ScriptDefinition) definition);\r\n        } else if (target instanceof StopProcessor) {\r\n            answer = new ManagedStop(context, (StopProcessor) target, definition);\r\n        } else if (target instanceof ThreadsProcessor) {\r\n            answer = new ManagedThreads(context, (ThreadsProcessor) target, definition);\r\n        } else if (target instanceof ThrowExceptionProcessor) {\r\n            answer = new ManagedThrowException(context, (ThrowExceptionProcessor) target, definition);\r\n        } else if (target instanceof TransformProcessor) {\r\n            answer = new ManagedTransformer(context, (TransformProcessor) target, (org.apache.camel.model.TransformDefinition) definition);\r\n        } else if (target instanceof PredicateValidatingProcessor) {\r\n            answer = new ManagedValidate(context, (PredicateValidatingProcessor) target, (org.apache.camel.model.ValidateDefinition) definition);\r\n        } else if (target instanceof WireTapProcessor) {\r\n            answer = new ManagedWireTapProcessor(context, (WireTapProcessor) target, definition);\r\n        } else if (target instanceof SendDynamicProcessor) {\r\n            answer = new ManagedSendDynamicProcessor(context, (SendDynamicProcessor) target, definition);\r\n        } else if (target instanceof SendProcessor) {\r\n            SendProcessor sp = (SendProcessor) target;\r\n                        if (sp.getDestination() instanceof LogEndpoint) {\r\n                LogEndpoint le = (LogEndpoint) sp.getDestination();\r\n                if (le.getLogger() instanceof ThroughputLogger) {\r\n                    ThroughputLogger tl = (ThroughputLogger) le.getLogger();\r\n                    answer = new ManagedThroughputLogger(context, tl, definition);\r\n                }\r\n            }\r\n                        if (answer == null) {\r\n                answer = new ManagedSendProcessor(context, (SendProcessor) target, definition);\r\n            }\r\n        } else if (target instanceof BeanProcessor) {\r\n            answer = new ManagedBeanProcessor(context, (BeanProcessor) target, definition);\r\n        } else if (target instanceof IdempotentConsumer) {\r\n            answer = new ManagedIdempotentConsumer(context, (IdempotentConsumer) target, (org.apache.camel.model.IdempotentConsumerDefinition) definition);\r\n        } else if (target instanceof AggregateProcessor) {\r\n            answer = new ManagedAggregateProcessor(context, (AggregateProcessor) target, (org.apache.camel.model.AggregateDefinition) definition);\r\n        } else if (target instanceof Enricher) {\r\n            answer = new ManagedEnricher(context, (Enricher) target, (org.apache.camel.model.EnrichDefinition) definition);\r\n        } else if (target instanceof PollEnricher) {\r\n            answer = new ManagedPollEnricher(context, (PollEnricher) target, (org.apache.camel.model.PollEnrichDefinition) definition);\r\n        } else if (target instanceof org.apache.camel.spi.ManagementAware) {\r\n            return ((org.apache.camel.spi.ManagementAware<Processor>) target).getManagedObject(processor);\r\n        }\r\n                if (definition instanceof LoadBalanceDefinition) {\r\n            LoadBalanceDefinition lb = (LoadBalanceDefinition) definition;\r\n            if (lb.getLoadBalancerType() instanceof CustomLoadBalancerDefinition) {\r\n                answer = new ManagedCustomLoadBalancer(context, (LoadBalancer) target, (LoadBalanceDefinition) definition);\r\n            }\r\n        }\r\n        if (answer != null) {\r\n                        break;\r\n        }\r\n                if (target instanceof DelegateProcessor) {\r\n            target = ((DelegateProcessor) target).getProcessor();\r\n        } else {\r\n                        break;\r\n        }\r\n    }\r\n    if (answer == null && definition instanceof ProcessDefinition) {\r\n        answer = new ManagedProcess(context, target, (ProcessDefinition) definition);\r\n    } else if (answer == null) {\r\n                answer = new ManagedProcessor(context, target, definition);\r\n    }\r\n    answer.setRoute(route);\r\n    answer.init(context.getManagementStrategy());\r\n    return answer;\r\n}","lc":6.1818181818,"pi":0.1435406699,"ma":12.2,"nbd":23.5,"ml":5.4166666667,"d":1.1587301587,"mi":-1.9891472868,"fo":0.9166666667,"r":-0.0263157895,"e":18.6342628931}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5215_033eb6fe","label":3,"code":"public boolean storeFile(String fileName, Exchange exchange) throws GenericFileOperationFailedException {\r\n    ObjectHelper.notNull(endpoint, \"endpoint\");\r\n    File file = new File(fileName);\r\n    \/\/ if an existing file already exists what should we do?\r\n    if (file.exists()) {\r\n        if (endpoint.getFileExist() == GenericFileExist.Ignore) {\r\n            \/\/ ignore but indicate that the file was written\r\n            LOG.trace(\"An existing file already exists: {}. Ignore and do not override it.\", file);\r\n            return true;\r\n        } else if (endpoint.getFileExist() == GenericFileExist.Fail) {\r\n            throw new GenericFileOperationFailedException(\"File already exist: \" + file + \". Cannot write new file.\");\r\n        }\r\n    }\r\n    \/\/ 3. write stream to file\r\n    try {\r\n        \/\/ is the body file based\r\n        File source = null;\r\n        \/\/ get the File Object from in message\r\n        source = exchange.getIn().getBody(File.class);\r\n        if (source != null) {\r\n            \/\/ okay we know the body is a file type\r\n            \/\/ so try to see if we can optimize by renaming the local work path file instead of doing\r\n            \/\/ a full file to file copy, as the local work copy is to be deleted afterwards anyway\r\n            \/\/ local work path\r\n            File local = exchange.getIn().getHeader(Exchange.FILE_LOCAL_WORK_PATH, File.class);\r\n            if (local != null && local.exists()) {\r\n                boolean renamed = writeFileByLocalWorkPath(local, file);\r\n                if (renamed) {\r\n                    \/\/ try to keep last modified timestamp if configured to do so\r\n                    keepLastModified(exchange, file);\r\n                    \/\/ clear header as we have renamed the file\r\n                    exchange.getIn().setHeader(Exchange.FILE_LOCAL_WORK_PATH, null);\r\n                    \/\/ to the target.\r\n                    return true;\r\n                }\r\n            } else if (source.exists()) {\r\n                \/\/ no there is no local work file so use file to file copy if the source exists\r\n                writeFileByFile(source, file);\r\n                \/\/ try to keep last modified timestamp if configured to do so\r\n                keepLastModified(exchange, file);\r\n                return true;\r\n            }\r\n        }\r\n        \/\/ fallback and use stream based\r\n        InputStream in = exchange.getIn().getMandatoryBody(InputStream.class);\r\n        writeFileByStream(in, file);\r\n        \/\/ try to keep last modified timestamp if configured to do so\r\n        keepLastModified(exchange, file);\r\n        return true;\r\n    } catch (IOException e) {\r\n        throw new GenericFileOperationFailedException(\"Cannot store file: \" + file, e);\r\n    } catch (InvalidPayloadException e) {\r\n        throw new GenericFileOperationFailedException(\"Cannot store file: \" + file, e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public boolean storeFile(String fileName, Exchange exchange) throws GenericFileOperationFailedException {\r\n    ObjectHelper.notNull(endpoint, \"endpoint\");\r\n    File file = new File(fileName);\r\n        if (file.exists()) {\r\n        if (endpoint.getFileExist() == GenericFileExist.Ignore) {\r\n                        LOG.trace(\"An existing file already exists: {}. Ignore and do not override it.\", file);\r\n            return true;\r\n        } else if (endpoint.getFileExist() == GenericFileExist.Fail) {\r\n            throw new GenericFileOperationFailedException(\"File already exist: \" + file + \". Cannot write new file.\");\r\n        }\r\n    }\r\n        try {\r\n                File source = null;\r\n                source = exchange.getIn().getBody(File.class);\r\n        if (source != null) {\r\n                                                            File local = exchange.getIn().getHeader(Exchange.FILE_LOCAL_WORK_PATH, File.class);\r\n            if (local != null && local.exists()) {\r\n                boolean renamed = writeFileByLocalWorkPath(local, file);\r\n                if (renamed) {\r\n                                        keepLastModified(exchange, file);\r\n                                        exchange.getIn().setHeader(Exchange.FILE_LOCAL_WORK_PATH, null);\r\n                                        return true;\r\n                }\r\n            } else if (source.exists()) {\r\n                                writeFileByFile(source, file);\r\n                                keepLastModified(exchange, file);\r\n                return true;\r\n            }\r\n        }\r\n                InputStream in = exchange.getIn().getMandatoryBody(InputStream.class);\r\n        writeFileByStream(in, file);\r\n                keepLastModified(exchange, file);\r\n        return true;\r\n    } catch (IOException e) {\r\n        throw new GenericFileOperationFailedException(\"Cannot store file: \" + file, e);\r\n    } catch (InvalidPayloadException e) {\r\n        throw new GenericFileOperationFailedException(\"Cannot store file: \" + file, e);\r\n    }\r\n}","lc":1.1363636364,"pi":1.0861244019,"ma":1.8,"nbd":1.0,"ml":1.0,"d":0.6031746032,"mi":-0.7324876674,"fo":1.25,"r":-0.0263157895,"e":1.3336168692}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4594_5e1bf8d8","label":1,"code":"\/**\r\n *  Creates a {@code IRequestHandler} that processes a listener request.\r\n *\r\n *  @param pageComponentInfo\r\n *  @param pageClass\r\n *  @param pageParameters\r\n *  @return a {@code IRequestHandler} that invokes the listener interface\r\n *\/\r\nprotected IRequestHandler processListener(PageComponentInfo pageComponentInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters) {\r\n    PageInfo pageInfo = pageComponentInfo.getPageInfo();\r\n    ComponentInfo componentInfo = pageComponentInfo.getComponentInfo();\r\n    Integer renderCount = null;\r\n    RequestListenerInterface listenerInterface = null;\r\n    if (componentInfo != null) {\r\n        renderCount = componentInfo.getRenderCount();\r\n        listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());\r\n    }\r\n    if (listenerInterface != null) {\r\n        \/\/ WICKET-4594 - ignore the parsed parameters as they have nothing to do with the page\r\n        PageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(), pageClass, null, renderCount, componentInfo.getComponentPath());\r\n        provider.setPageSource(getContext());\r\n        return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());\r\n    } else {\r\n        if (logger.isWarnEnabled()) {\r\n            if (componentInfo != null) {\r\n                logger.warn(\"Unknown listener interface '{}'\", componentInfo.getListenerInterface());\r\n            } else {\r\n                logger.warn(\"Cannot extract the listener interface for PageComponentInfo: '{}'\" + pageComponentInfo);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}","code_comment":"\/**\r\n *  Creates a {@code IRequestHandler} that processes a listener request.\r\n *\r\n *  @param pageComponentInfo\r\n *  @param pageClass\r\n *  @param pageParameters\r\n *  @return a {@code IRequestHandler} that invokes the listener interface\r\n *\/\r\n","code_no_comment":"protected IRequestHandler processListener(PageComponentInfo pageComponentInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters) {\r\n    PageInfo pageInfo = pageComponentInfo.getPageInfo();\r\n    ComponentInfo componentInfo = pageComponentInfo.getComponentInfo();\r\n    Integer renderCount = null;\r\n    RequestListenerInterface listenerInterface = null;\r\n    if (componentInfo != null) {\r\n        renderCount = componentInfo.getRenderCount();\r\n        listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());\r\n    }\r\n    if (listenerInterface != null) {\r\n                PageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(), pageClass, null, renderCount, componentInfo.getComponentPath());\r\n        provider.setPageSource(getContext());\r\n        return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());\r\n    } else {\r\n        if (logger.isWarnEnabled()) {\r\n            if (componentInfo != null) {\r\n                logger.warn(\"Unknown listener interface '{}'\", componentInfo.getListenerInterface());\r\n            } else {\r\n                logger.warn(\"Cannot extract the listener interface for PageComponentInfo: '{}'\" + pageComponentInfo);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}","lc":0.4545454545,"pi":0.5789473684,"ma":0.2,"nbd":0.5,"ml":0.1666666667,"d":-0.005952381,"mi":-0.3897110641,"fo":0.6666666667,"r":-0.0263157895,"e":0.1837612305}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1178_f2bb1a17","label":1,"code":"@Override\r\nprotected boolean isNew() {\r\n    return !getBase().exists();\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected boolean isNew() {\r\n    return !getBase().exists();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9362931642,"fo":-0.3333333333,"r":2.1842105263,"e":-0.1627934049}
{"project_name":"Closure","project_version":"77","label":1,"code":"\/**\r\n * Helper to escape javascript string as well as regular expression\r\n *\/\r\nstatic String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {\r\n    StringBuilder sb = new StringBuilder(s.length() + 2);\r\n    sb.append(quote);\r\n    for (int i = 0; i < s.length(); i++) {\r\n        char c = s.charAt(i);\r\n        switch(c) {\r\n            case '\\n':\r\n                sb.append(\"\\\\n\");\r\n                break;\r\n            case '\\r':\r\n                sb.append(\"\\\\r\");\r\n                break;\r\n            case '\\t':\r\n                sb.append(\"\\\\t\");\r\n                break;\r\n            case '\\\\':\r\n                sb.append(backslashEscape);\r\n                break;\r\n            case '\\\"':\r\n                sb.append(doublequoteEscape);\r\n                break;\r\n            case '\\'':\r\n                sb.append(singlequoteEscape);\r\n                break;\r\n            case \/\/ Break --> into --\\> or ]]> into ]]\\>\r\n            '>':\r\n                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\r\n                    sb.append(\"\\\\>\");\r\n                } else {\r\n                    sb.append(c);\r\n                }\r\n                break;\r\n            case '<':\r\n                \/\/ Break <\/script into <\\\/script\r\n                final String END_SCRIPT = \"\/script\";\r\n                \/\/ Break <!-- into <\\!--\r\n                final String START_COMMENT = \"!--\";\r\n                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {\r\n                    sb.append(\"<\\\\\");\r\n                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {\r\n                    sb.append(\"<\\\\\");\r\n                } else {\r\n                    sb.append(c);\r\n                }\r\n                break;\r\n            default:\r\n                \/\/ character can be represented in this character set.\r\n                if (outputCharsetEncoder != null) {\r\n                    if (outputCharsetEncoder.canEncode(c)) {\r\n                        sb.append(c);\r\n                    } else {\r\n                        \/\/ Unicode-escape the character.\r\n                        appendHexJavaScriptRepresentation(sb, c);\r\n                    }\r\n                } else {\r\n                    \/\/ check is measurably faster than using the CharsetEncoder.\r\n                    if (c > 0x1f && c <= 0x7f) {\r\n                        sb.append(c);\r\n                    } else {\r\n                        \/\/ Other characters can be misinterpreted by some js parsers,\r\n                        \/\/ or perhaps mangled by proxies along the way,\r\n                        \/\/ so we play it safe and unicode escape them.\r\n                        appendHexJavaScriptRepresentation(sb, c);\r\n                    }\r\n                }\r\n        }\r\n    }\r\n    sb.append(quote);\r\n    return sb.toString();\r\n}","code_comment":"\/**\r\n * Helper to escape javascript string as well as regular expression\r\n *\/\r\n","code_no_comment":"static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {\r\n    StringBuilder sb = new StringBuilder(s.length() + 2);\r\n    sb.append(quote);\r\n    for (int i = 0; i < s.length(); i++) {\r\n        char c = s.charAt(i);\r\n        switch(c) {\r\n            case '\\n':\r\n                sb.append(\"\\\\n\");\r\n                break;\r\n            case '\\r':\r\n                sb.append(\"\\\\r\");\r\n                break;\r\n            case '\\t':\r\n                sb.append(\"\\\\t\");\r\n                break;\r\n            case '\\\\':\r\n                sb.append(backslashEscape);\r\n                break;\r\n            case '\\\"':\r\n                sb.append(doublequoteEscape);\r\n                break;\r\n            case '\\'':\r\n                sb.append(singlequoteEscape);\r\n                break;\r\n            case             '>':\r\n                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\r\n                    sb.append(\"\\\\>\");\r\n                } else {\r\n                    sb.append(c);\r\n                }\r\n                break;\r\n            case '<':\r\n                                final String END_SCRIPT = \"\/script\";\r\n                                final String START_COMMENT = \"!--\";\r\n                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {\r\n                    sb.append(\"<\\\\\");\r\n                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {\r\n                    sb.append(\"<\\\\\");\r\n                } else {\r\n                    sb.append(c);\r\n                }\r\n                break;\r\n            default:\r\n                                if (outputCharsetEncoder != null) {\r\n                    if (outputCharsetEncoder.canEncode(c)) {\r\n                        sb.append(c);\r\n                    } else {\r\n                                                appendHexJavaScriptRepresentation(sb, c);\r\n                    }\r\n                } else {\r\n                                        if (c > 0x1f && c <= 0x7f) {\r\n                        sb.append(c);\r\n                    } else {\r\n                                                                                                appendHexJavaScriptRepresentation(sb, c);\r\n                    }\r\n                }\r\n        }\r\n    }\r\n    sb.append(quote);\r\n    return sb.toString();\r\n}","lc":2.1818181818,"pi":1.3014354067,"ma":4.2,"nbd":1.5,"ml":2.1666666667,"d":3.2817460317,"mi":-1.0856941508,"fo":2.0,"r":-0.0263157895,"e":8.5442068198}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1103_a6f96306","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic Optimum optimize(final LeastSquaresProblem lsp) {\r\n    \/\/ create local evaluation and iteration counts\r\n    final Incrementor evaluationCounter = lsp.getEvaluationCounter();\r\n    final Incrementor iterationCounter = lsp.getIterationCounter();\r\n    final ConvergenceChecker<Evaluation> checker = lsp.getConvergenceChecker();\r\n    \/\/ Computation will be useless without a checker (see \"for-loop\").\r\n    if (checker == null) {\r\n        throw new NullArgumentException();\r\n    }\r\n    final int nC = lsp.getParameterSize();\r\n    final RealVector currentPoint = lsp.getStart();\r\n    \/\/ iterate until convergence is reached\r\n    Evaluation current = null;\r\n    while (true) {\r\n        iterationCounter.incrementCount();\r\n        \/\/ evaluate the objective function and its jacobian\r\n        Evaluation previous = current;\r\n        \/\/ Value of the objective function at \"currentPoint\".\r\n        evaluationCounter.incrementCount();\r\n        current = lsp.evaluate(currentPoint);\r\n        final RealVector currentResiduals = current.getResiduals();\r\n        final RealMatrix weightedJacobian = current.getJacobian();\r\n        \/\/ Check convergence.\r\n        if (previous != null) {\r\n            if (checker.converged(iterationCounter.getCount(), previous, current)) {\r\n                return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());\r\n            }\r\n        }\r\n        \/\/ solve the linearized least squares problem\r\n        final RealVector dX = this.decomposition.solve(weightedJacobian, currentResiduals);\r\n        \/\/ update the estimated parameters\r\n        for (int i = 0; i < nC; ++i) {\r\n            currentPoint.setEntry(i, currentPoint.getEntry(i) + dX.getEntry(i));\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public Optimum optimize(final LeastSquaresProblem lsp) {\r\n        final Incrementor evaluationCounter = lsp.getEvaluationCounter();\r\n    final Incrementor iterationCounter = lsp.getIterationCounter();\r\n    final ConvergenceChecker<Evaluation> checker = lsp.getConvergenceChecker();\r\n        if (checker == null) {\r\n        throw new NullArgumentException();\r\n    }\r\n    final int nC = lsp.getParameterSize();\r\n    final RealVector currentPoint = lsp.getStart();\r\n        Evaluation current = null;\r\n    while (true) {\r\n        iterationCounter.incrementCount();\r\n                Evaluation previous = current;\r\n                evaluationCounter.incrementCount();\r\n        current = lsp.evaluate(currentPoint);\r\n        final RealVector currentResiduals = current.getResiduals();\r\n        final RealMatrix weightedJacobian = current.getJacobian();\r\n                if (previous != null) {\r\n            if (checker.converged(iterationCounter.getCount(), previous, current)) {\r\n                return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());\r\n            }\r\n        }\r\n                final RealVector dX = this.decomposition.solve(weightedJacobian, currentResiduals);\r\n                for (int i = 0; i < nC; ++i) {\r\n            currentPoint.setEntry(i, currentPoint.getEntry(i) + dX.getEntry(i));\r\n        }\r\n    }\r\n}","lc":0.6363636364,"pi":0.2679425837,"ma":0.6,"nbd":0.5,"ml":0.5833333333,"d":0.869047619,"mi":-0.5188160677,"fo":1.0,"r":-0.0263157895,"e":1.4617889271}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3834_30255f11","label":1,"code":"\/**\r\n *  Parses the given URL string.\r\n *\r\n *  @param url\r\n *  @param charset\r\n *  @return Url object\r\n *\/\r\npublic static Url parse(final String url, Charset charset) {\r\n    Args.notNull(url, \"url\");\r\n    Url result = new Url(charset);\r\n    \/\/ the url object resolved the charset, use that\r\n    charset = result.getCharset();\r\n    String segments;\r\n    String query;\r\n    int qIndex = url.indexOf('?');\r\n    if (qIndex == -1) {\r\n        segments = url;\r\n        query = \"\";\r\n    } else {\r\n        segments = url.substring(0, qIndex);\r\n        query = url.substring(qIndex + 1);\r\n    }\r\n    if (segments.length() > 0) {\r\n        boolean removeLast = false;\r\n        if (segments.endsWith(\"\/\")) {\r\n            \/\/ we need to append something and remove it after splitting\r\n            \/\/ because otherwise the\r\n            \/\/ trailing slashes will be lost\r\n            segments += \"\/x\";\r\n            removeLast = true;\r\n        }\r\n        String[] segmentArray = Strings.split(segments, '\/');\r\n        if (removeLast) {\r\n            segmentArray[segmentArray.length - 1] = null;\r\n        }\r\n        for (String s : segmentArray) {\r\n            if (s != null) {\r\n                result.segments.add(decodeSegment(s, charset));\r\n            }\r\n        }\r\n    }\r\n    if (query.length() > 0) {\r\n        String[] queryArray = Strings.split(query, '&');\r\n        for (String s : queryArray) {\r\n            result.parameters.add(parseQueryParameter(s, charset));\r\n        }\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n *  Parses the given URL string.\r\n *\r\n *  @param url\r\n *  @param charset\r\n *  @return Url object\r\n *\/\r\n","code_no_comment":"public static Url parse(final String url, Charset charset) {\r\n    Args.notNull(url, \"url\");\r\n    Url result = new Url(charset);\r\n        charset = result.getCharset();\r\n    String segments;\r\n    String query;\r\n    int qIndex = url.indexOf('?');\r\n    if (qIndex == -1) {\r\n        segments = url;\r\n        query = \"\";\r\n    } else {\r\n        segments = url.substring(0, qIndex);\r\n        query = url.substring(qIndex + 1);\r\n    }\r\n    if (segments.length() > 0) {\r\n        boolean removeLast = false;\r\n        if (segments.endsWith(\"\/\")) {\r\n                                                segments += \"\/x\";\r\n            removeLast = true;\r\n        }\r\n        String[] segmentArray = Strings.split(segments, '\/');\r\n        if (removeLast) {\r\n            segmentArray[segmentArray.length - 1] = null;\r\n        }\r\n        for (String s : segmentArray) {\r\n            if (s != null) {\r\n                result.segments.add(decodeSegment(s, charset));\r\n            }\r\n        }\r\n    }\r\n    if (query.length() > 0) {\r\n        String[] queryArray = Strings.split(query, '&');\r\n        for (String s : queryArray) {\r\n            result.parameters.add(parseQueryParameter(s, charset));\r\n        }\r\n    }\r\n    return result;\r\n}","lc":1.0909090909,"pi":0.2535885167,"ma":1.0,"nbd":0.5,"ml":0.5833333333,"d":1.1388888889,"mi":-0.6882311487,"fo":0.6666666667,"r":-0.0263157895,"e":2.0631754868}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1127_ba62c59d","label":1,"code":"\/**\r\n * Returns true if both arguments are equal or within the range of allowed\r\n * error (inclusive).\r\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\r\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\r\n * point numbers are considered equal.\r\n * Adapted from <a\r\n * href=\"http:\/\/www.cygnus-software.com\/papers\/comparingfloats\/comparingfloats.htm\">\r\n * Bruce Dawson<\/a>\r\n *\r\n * @param x first value\r\n * @param y second value\r\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\r\n * values between {@code x} and {@code y}.\r\n * @return {@code true} if there are fewer than {@code maxUlps} floating\r\n * point values between {@code x} and {@code y}.\r\n * @since 2.2\r\n *\/\r\npublic static boolean equals(float x, float y, int maxUlps) {\r\n    int xInt = Float.floatToIntBits(x);\r\n    int yInt = Float.floatToIntBits(y);\r\n    \/\/ Make lexicographically ordered as a two's-complement integer.\r\n    if (xInt < 0) {\r\n        xInt = SGN_MASK_FLOAT - xInt;\r\n    }\r\n    if (yInt < 0) {\r\n        yInt = SGN_MASK_FLOAT - yInt;\r\n    }\r\n    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\r\n    return isEqual && !Float.isNaN(x) && !Float.isNaN(y);\r\n}","code_comment":"\/**\r\n * Returns true if both arguments are equal or within the range of allowed\r\n * error (inclusive).\r\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\r\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\r\n * point numbers are considered equal.\r\n * Adapted from <a\r\n * href=\"http:\/\/www.cygnus-software.com\/papers\/comparingfloats\/comparingfloats.htm\">\r\n * Bruce Dawson<\/a>\r\n *\r\n * @param x first value\r\n * @param y second value\r\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\r\n * values between {@code x} and {@code y}.\r\n * @return {@code true} if there are fewer than {@code maxUlps} floating\r\n * point values between {@code x} and {@code y}.\r\n * @since 2.2\r\n *\/\r\n","code_no_comment":"public static boolean equals(float x, float y, int maxUlps) {\r\n    int xInt = Float.floatToIntBits(x);\r\n    int yInt = Float.floatToIntBits(y);\r\n        if (xInt < 0) {\r\n        xInt = SGN_MASK_FLOAT - xInt;\r\n    }\r\n    if (yInt < 0) {\r\n        yInt = SGN_MASK_FLOAT - yInt;\r\n    }\r\n    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\r\n    return isEqual && !Float.isNaN(x) && !Float.isNaN(y);\r\n}","lc":-0.0909090909,"pi":-0.3253588517,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":1.0634920635,"mi":0.0331219168,"fo":-0.0833333333,"r":0.3157894737,"e":0.5662073616}
{"project_name":"Closure","project_version":"165","label":2,"code":"\/**\r\n * Creates a record.\r\n * @return The record type.\r\n *\/\r\npublic JSType build() {\r\n    \/\/ If we have an empty record, simply return the object type.\r\n    if (isEmpty) {\r\n        return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\r\n    }\r\n    return new RecordType(registry, Collections.unmodifiableMap(properties));\r\n}","code_comment":"\/**\r\n * Creates a record.\r\n * @return The record type.\r\n *\/\r\n","code_no_comment":"public JSType build() {\r\n        if (isEmpty) {\r\n        return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\r\n    }\r\n    return new RecordType(registry, Collections.unmodifiableMap(properties));\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.5833685694,"fo":-0.3333333333,"r":1.9736842105,"e":-0.1627934049}
{"project_name":"Math","project_version":"42","label":1,"code":"\/**\r\n * Get the current solution.\r\n *\r\n * @return current solution\r\n *\/\r\nprotected RealPointValuePair getSolution() {\r\n    int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\r\n    Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\r\n    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\r\n    Set<Integer> basicRows = new HashSet<Integer>();\r\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\r\n    for (int i = 0; i < coefficients.length; i++) {\r\n        int colIndex = columnLabels.indexOf(\"x\" + i);\r\n        if (colIndex < 0) {\r\n            coefficients[i] = 0;\r\n            continue;\r\n        }\r\n        Integer basicRow = getBasicRow(colIndex);\r\n        \/\/ variables that are still part of the objective function\r\n        if (basicRows.contains(basicRow)) {\r\n            \/\/ if multiple variables can take a given value\r\n            \/\/ then we choose the first and set the rest equal to 0\r\n            coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\r\n        } else {\r\n            basicRows.add(basicRow);\r\n            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\r\n        }\r\n    }\r\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\r\n}","code_comment":"\/**\r\n * Get the current solution.\r\n *\r\n * @return current solution\r\n *\/\r\n","code_no_comment":"protected RealPointValuePair getSolution() {\r\n    int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\r\n    Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\r\n    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\r\n    Set<Integer> basicRows = new HashSet<Integer>();\r\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\r\n    for (int i = 0; i < coefficients.length; i++) {\r\n        int colIndex = columnLabels.indexOf(\"x\" + i);\r\n        if (colIndex < 0) {\r\n            coefficients[i] = 0;\r\n            continue;\r\n        }\r\n        Integer basicRow = getBasicRow(colIndex);\r\n                if (basicRows.contains(basicRow)) {\r\n                                    coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\r\n        } else {\r\n            basicRows.add(basicRow);\r\n            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\r\n        }\r\n    }\r\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\r\n}","lc":0.3636363636,"pi":0.3349282297,"ma":1.2,"nbd":0.0,"ml":0.9166666667,"d":1.1428571429,"mi":-0.4097251586,"fo":0.5,"r":0.0,"e":1.589513782}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1429_c2f5ca6c","label":1,"code":"\/**\r\n * Apply the changes of a node to the cache.\r\n *\r\n * @param rev the commit revision\r\n * @param before the revision right before the commit.\r\n * @param path the path\r\n * @param isNew whether this is a new node\r\n * @param isDelete whether the node is deleted\r\n * @param pendingLastRev whether the node has a pending _lastRev to write\r\n * @param isBranchCommit whether this is from a branch commit\r\n * @param added the list of added child nodes\r\n * @param removed the list of removed child nodes\r\n * @param changed the list of changed child nodes.\r\n *\/\r\npublic void applyChanges(Revision rev, Revision before, String path, boolean isNew, boolean isDelete, boolean pendingLastRev, boolean isBranchCommit, List<String> added, List<String> removed, List<String> changed) {\r\n    UnsavedModifications unsaved = unsavedLastRevisions;\r\n    if (isBranchCommit) {\r\n        Revision branchRev = rev.asBranchRevision();\r\n        unsaved = branches.getBranch(branchRev).getModifications(branchRev);\r\n    }\r\n    if (isBranchCommit || pendingLastRev) {\r\n        \/\/ write back _lastRev with background thread\r\n        unsaved.put(path, rev);\r\n    }\r\n    if (isNew) {\r\n        CacheValue key = childNodeCacheKey(path, rev, null);\r\n        DocumentNodeState.Children c = new DocumentNodeState.Children();\r\n        Set<String> set = Sets.newTreeSet(added);\r\n        set.removeAll(removed);\r\n        for (String p : added) {\r\n            set.add(Utils.unshareString(p));\r\n        }\r\n        c.children.addAll(set);\r\n        nodeChildrenCache.put(key, c);\r\n    } else if (!isDelete) {\r\n        \/\/ update diff cache for modified nodes\r\n        PathRev key = diffCacheKey(path, before, rev);\r\n        JsopWriter w = new JsopStream();\r\n        for (String p : added) {\r\n            w.tag('+').key(p).object().endObject().newline();\r\n        }\r\n        for (String p : removed) {\r\n            w.tag('-').value(p).newline();\r\n        }\r\n        for (String p : changed) {\r\n            w.tag('^').key(p).object().endObject().newline();\r\n        }\r\n        diffCache.put(key, new StringValue(w.toString()));\r\n    }\r\n    \/\/ update docChildrenCache\r\n    if (!added.isEmpty()) {\r\n        CacheValue docChildrenKey = new StringValue(path);\r\n        NodeDocument.Children docChildren = docChildrenCache.getIfPresent(docChildrenKey);\r\n        if (docChildren != null) {\r\n            int currentSize = docChildren.childNames.size();\r\n            NavigableSet<String> names = Sets.newTreeSet(docChildren.childNames);\r\n            \/\/ a next name in DocumentStore smaller than the one added\r\n            if (!docChildren.isComplete) {\r\n                for (String childPath : added) {\r\n                    String name = PathUtils.getName(childPath);\r\n                    if (names.higher(name) != null) {\r\n                        names.add(Utils.unshareString(name));\r\n                    }\r\n                }\r\n            } else {\r\n                \/\/ add all\r\n                for (String childPath : added) {\r\n                    names.add(Utils.unshareString(PathUtils.getName(childPath)));\r\n                }\r\n            }\r\n            \/\/ any changes?\r\n            if (names.size() != currentSize) {\r\n                \/\/ create new cache entry with updated names\r\n                boolean complete = docChildren.isComplete;\r\n                docChildren = new NodeDocument.Children();\r\n                docChildren.isComplete = complete;\r\n                docChildren.childNames.addAll(names);\r\n                docChildrenCache.put(docChildrenKey, docChildren);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Apply the changes of a node to the cache.\r\n *\r\n * @param rev the commit revision\r\n * @param before the revision right before the commit.\r\n * @param path the path\r\n * @param isNew whether this is a new node\r\n * @param isDelete whether the node is deleted\r\n * @param pendingLastRev whether the node has a pending _lastRev to write\r\n * @param isBranchCommit whether this is from a branch commit\r\n * @param added the list of added child nodes\r\n * @param removed the list of removed child nodes\r\n * @param changed the list of changed child nodes.\r\n *\/\r\n","code_no_comment":"public void applyChanges(Revision rev, Revision before, String path, boolean isNew, boolean isDelete, boolean pendingLastRev, boolean isBranchCommit, List<String> added, List<String> removed, List<String> changed) {\r\n    UnsavedModifications unsaved = unsavedLastRevisions;\r\n    if (isBranchCommit) {\r\n        Revision branchRev = rev.asBranchRevision();\r\n        unsaved = branches.getBranch(branchRev).getModifications(branchRev);\r\n    }\r\n    if (isBranchCommit || pendingLastRev) {\r\n                unsaved.put(path, rev);\r\n    }\r\n    if (isNew) {\r\n        CacheValue key = childNodeCacheKey(path, rev, null);\r\n        DocumentNodeState.Children c = new DocumentNodeState.Children();\r\n        Set<String> set = Sets.newTreeSet(added);\r\n        set.removeAll(removed);\r\n        for (String p : added) {\r\n            set.add(Utils.unshareString(p));\r\n        }\r\n        c.children.addAll(set);\r\n        nodeChildrenCache.put(key, c);\r\n    } else if (!isDelete) {\r\n                PathRev key = diffCacheKey(path, before, rev);\r\n        JsopWriter w = new JsopStream();\r\n        for (String p : added) {\r\n            w.tag('+').key(p).object().endObject().newline();\r\n        }\r\n        for (String p : removed) {\r\n            w.tag('-').value(p).newline();\r\n        }\r\n        for (String p : changed) {\r\n            w.tag('^').key(p).object().endObject().newline();\r\n        }\r\n        diffCache.put(key, new StringValue(w.toString()));\r\n    }\r\n        if (!added.isEmpty()) {\r\n        CacheValue docChildrenKey = new StringValue(path);\r\n        NodeDocument.Children docChildren = docChildrenCache.getIfPresent(docChildrenKey);\r\n        if (docChildren != null) {\r\n            int currentSize = docChildren.childNames.size();\r\n            NavigableSet<String> names = Sets.newTreeSet(docChildren.childNames);\r\n                        if (!docChildren.isComplete) {\r\n                for (String childPath : added) {\r\n                    String name = PathUtils.getName(childPath);\r\n                    if (names.higher(name) != null) {\r\n                        names.add(Utils.unshareString(name));\r\n                    }\r\n                }\r\n            } else {\r\n                                for (String childPath : added) {\r\n                    names.add(Utils.unshareString(PathUtils.getName(childPath)));\r\n                }\r\n            }\r\n                        if (names.size() != currentSize) {\r\n                                boolean complete = docChildren.isComplete;\r\n                docChildren = new NodeDocument.Children();\r\n                docChildren.isComplete = complete;\r\n                docChildren.childNames.addAll(names);\r\n                docChildrenCache.put(docChildrenKey, docChildren);\r\n            }\r\n        }\r\n    }\r\n}","lc":2.1363636364,"pi":1.033492823,"ma":2.4,"nbd":1.5,"ml":1.3333333333,"d":0.6607142857,"mi":-1.065961945,"fo":2.9166666667,"r":-0.0263157895,"e":3.1911596734}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4384_614e3b50","label":1,"code":"\/**\r\n *  Cleans the original parameters from entries used by Wicket internals.\r\n *\r\n *  @param originalParameters\r\n *             the current request's non-modified parameters\r\n *  @return all parameters but Wicket internal ones\r\n *\/\r\nprivate PageParameters cleanPageParameters(final PageParameters originalParameters) {\r\n    PageParameters cleanParameters = null;\r\n    if (originalParameters != null) {\r\n        cleanParameters = new PageParameters(originalParameters);\r\n        \/\/ WICKET-4038: Ajax related parameters are set by wicket-ajax.js when needed.\r\n        \/\/ They shouldn't be propagated to the next requests\r\n        cleanParameters.remove(WebRequest.PARAM_AJAX);\r\n        cleanParameters.remove(WebRequest.PARAM_AJAX_BASE_URL);\r\n        cleanParameters.remove(WebRequest.PARAM_AJAX_REQUEST_ANTI_CACHE);\r\n    }\r\n    return cleanParameters;\r\n}","code_comment":"\/**\r\n *  Cleans the original parameters from entries used by Wicket internals.\r\n *\r\n *  @param originalParameters\r\n *             the current request's non-modified parameters\r\n *  @return all parameters but Wicket internal ones\r\n *\/\r\n","code_no_comment":"private PageParameters cleanPageParameters(final PageParameters originalParameters) {\r\n    PageParameters cleanParameters = null;\r\n    if (originalParameters != null) {\r\n        cleanParameters = new PageParameters(originalParameters);\r\n                        cleanParameters.remove(WebRequest.PARAM_AJAX);\r\n        cleanParameters.remove(WebRequest.PARAM_AJAX_BASE_URL);\r\n        cleanParameters.remove(WebRequest.PARAM_AJAX_REQUEST_ANTI_CACHE);\r\n    }\r\n    return cleanParameters;\r\n}","lc":-0.1818181818,"pi":0.0,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.1031746032,"mi":0.2276250881,"fo":-0.25,"r":0.4473684211,"e":-0.0458521349}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-843_65390f8c","label":3,"code":"@Override\r\npublic void deleteRows(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n    throw new NotImplementedException();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void deleteRows(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\r\n    throw new NotImplementedException();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.4,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7685694151,"fo":-0.5,"r":0.0789473684,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3424_f4349a96","label":1,"code":"\/**\r\n * Create a cluster node info instance for the store.\r\n *\r\n * @param store the document store (for the lease)\r\n * @param machineId the machine id (null for MAC address)\r\n * @param instanceId the instance id (null for current working directory)\r\n * @param configuredClusterId the configured cluster id (or 0 for dynamic assignment)\r\n * @param updateLease whether to update the lease\r\n * @return the cluster node info\r\n *\/\r\npublic static ClusterNodeInfo getInstance(DocumentStore store, String machineId, String instanceId, int configuredClusterId, boolean updateLease) {\r\n    \/\/ defaults for machineId and instanceID\r\n    if (machineId == null) {\r\n        machineId = MACHINE_ID;\r\n    }\r\n    if (instanceId == null) {\r\n        instanceId = WORKING_DIR;\r\n    }\r\n    int retries = 10;\r\n    for (int i = 0; i < retries; i++) {\r\n        ClusterNodeInfo clusterNode = createInstance(store, machineId, instanceId, configuredClusterId);\r\n        String key = String.valueOf(clusterNode.id);\r\n        UpdateOp update = new UpdateOp(key, true);\r\n        update.set(ID, key);\r\n        update.set(MACHINE_ID_KEY, clusterNode.machineId);\r\n        update.set(INSTANCE_ID_KEY, clusterNode.instanceId);\r\n        if (updateLease) {\r\n            update.set(LEASE_END_KEY, getCurrentTime() + clusterNode.leaseTime);\r\n        } else {\r\n            update.set(LEASE_END_KEY, clusterNode.leaseEndTime);\r\n        }\r\n        update.set(INFO_KEY, clusterNode.toString());\r\n        update.set(STATE, clusterNode.state.name());\r\n        update.set(REV_RECOVERY_LOCK, clusterNode.revRecoveryLock.name());\r\n        update.set(OAK_VERSION_KEY, OAK_VERSION);\r\n        final boolean success;\r\n        if (clusterNode.newEntry) {\r\n            \/\/ For new entry do a create. This ensures that if two nodes\r\n            \/\/ create entry with same id then only one would succeed\r\n            success = store.create(Collection.CLUSTER_NODES, Collections.singletonList(update));\r\n        } else {\r\n            \/\/ No expiration of earlier cluster info, so update\r\n            store.createOrUpdate(Collection.CLUSTER_NODES, update);\r\n            success = true;\r\n        }\r\n        if (success) {\r\n            return clusterNode;\r\n        }\r\n    }\r\n    throw new DocumentStoreException(\"Could not get cluster node info (retried \" + retries + \" times)\");\r\n}","code_comment":"\/**\r\n * Create a cluster node info instance for the store.\r\n *\r\n * @param store the document store (for the lease)\r\n * @param machineId the machine id (null for MAC address)\r\n * @param instanceId the instance id (null for current working directory)\r\n * @param configuredClusterId the configured cluster id (or 0 for dynamic assignment)\r\n * @param updateLease whether to update the lease\r\n * @return the cluster node info\r\n *\/\r\n","code_no_comment":"public static ClusterNodeInfo getInstance(DocumentStore store, String machineId, String instanceId, int configuredClusterId, boolean updateLease) {\r\n        if (machineId == null) {\r\n        machineId = MACHINE_ID;\r\n    }\r\n    if (instanceId == null) {\r\n        instanceId = WORKING_DIR;\r\n    }\r\n    int retries = 10;\r\n    for (int i = 0; i < retries; i++) {\r\n        ClusterNodeInfo clusterNode = createInstance(store, machineId, instanceId, configuredClusterId);\r\n        String key = String.valueOf(clusterNode.id);\r\n        UpdateOp update = new UpdateOp(key, true);\r\n        update.set(ID, key);\r\n        update.set(MACHINE_ID_KEY, clusterNode.machineId);\r\n        update.set(INSTANCE_ID_KEY, clusterNode.instanceId);\r\n        if (updateLease) {\r\n            update.set(LEASE_END_KEY, getCurrentTime() + clusterNode.leaseTime);\r\n        } else {\r\n            update.set(LEASE_END_KEY, clusterNode.leaseEndTime);\r\n        }\r\n        update.set(INFO_KEY, clusterNode.toString());\r\n        update.set(STATE, clusterNode.state.name());\r\n        update.set(REV_RECOVERY_LOCK, clusterNode.revRecoveryLock.name());\r\n        update.set(OAK_VERSION_KEY, OAK_VERSION);\r\n        final boolean success;\r\n        if (clusterNode.newEntry) {\r\n                                    success = store.create(Collection.CLUSTER_NODES, Collections.singletonList(update));\r\n        } else {\r\n                        store.createOrUpdate(Collection.CLUSTER_NODES, update);\r\n            success = true;\r\n        }\r\n        if (success) {\r\n            return clusterNode;\r\n        }\r\n    }\r\n    throw new DocumentStoreException(\"Could not get cluster node info (retried \" + retries + \" times)\");\r\n}","lc":1.0454545455,"pi":0.014354067,"ma":0.8,"nbd":0.0,"ml":0.6666666667,"d":0.496031746,"mi":-0.6958421424,"fo":1.0,"r":-0.0263157895,"e":1.360827095}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3965_6051019b","label":1,"code":"public void touchPage(IManageablePage page) {\r\n    pages.put(page.getPageId(), page);\r\n}","code_comment":null,"code_no_comment":"public void touchPage(IManageablePage page) {\r\n    pages.put(page.getPageId(), page);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9960535588,"fo":-0.3333333333,"r":0.1578947368,"e":-0.1627934049}
{"project_name":"Closure","project_version":"136","label":2,"code":"\/**\r\n * Adds a node that may represent a function signature (if it's a function\r\n * itself or the name of a function).\r\n *\/\r\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\r\n    boolean signatureAdded = false;\r\n    if (node.getType() == Token.FUNCTION) {\r\n        \/\/ The node we're looking at is a function, so we can add it directly\r\n        addSignature(name, node, t.getSourceName());\r\n        signatureAdded = true;\r\n    } else if (node.getType() == Token.NAME) {\r\n        String functionName = node.getString();\r\n        Scope.Var v = t.getScope().getVar(functionName);\r\n        if (v == null) {\r\n            if (compiler.isIdeMode()) {\r\n                return;\r\n            } else {\r\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\r\n            }\r\n        }\r\n        Node function = v.getInitialValue();\r\n        if (function != null && function.getType() == Token.FUNCTION) {\r\n            addSignature(name, function, v.getInputName());\r\n            signatureAdded = true;\r\n        }\r\n    }\r\n    if (!signatureAdded) {\r\n        nonMethodProperties.add(name);\r\n    }\r\n}","code_comment":"\/**\r\n * Adds a node that may represent a function signature (if it's a function\r\n * itself or the name of a function).\r\n *\/\r\n","code_no_comment":"private void addPossibleSignature(String name, Node node, NodeTraversal t) {\r\n    boolean signatureAdded = false;\r\n    if (node.getType() == Token.FUNCTION) {\r\n                addSignature(name, node, t.getSourceName());\r\n        signatureAdded = true;\r\n    } else if (node.getType() == Token.NAME) {\r\n        String functionName = node.getString();\r\n        Scope.Var v = t.getScope().getVar(functionName);\r\n        if (v == null) {\r\n            if (compiler.isIdeMode()) {\r\n                return;\r\n            } else {\r\n                throw new IllegalStateException(\"VarCheck should have caught this undefined function\");\r\n            }\r\n        }\r\n        Node function = v.getInitialValue();\r\n        if (function != null && function.getType() == Token.FUNCTION) {\r\n            addSignature(name, function, v.getInputName());\r\n            signatureAdded = true;\r\n        }\r\n    }\r\n    if (!signatureAdded) {\r\n        nonMethodProperties.add(name);\r\n    }\r\n}","lc":0.5,"pi":0.5550239234,"ma":0.8,"nbd":1.0,"ml":0.6666666667,"d":0.371031746,"mi":-0.4229739253,"fo":0.5833333333,"r":-0.0263157895,"e":0.5235110043}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  @return True if this component has some kind of feedback message\r\n *\/\r\npublic final boolean hasFeedbackMessage() {\r\n    return getPage().getFeedbackMessages().hasMessageFor(this);\r\n}","code_comment":"\/**\r\n *  @return True if this component has some kind of feedback message\r\n *\/\r\n","code_no_comment":"public final boolean hasFeedbackMessage() {\r\n    return getPage().getFeedbackMessages().hasMessageFor(this);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.25,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3077_17654199","label":0,"code":"void bringMinorCompactionOnline(FileRef tmpDatafile, FileRef newDatafile, FileRef absMergeFile, DataFileValue dfv, CommitSession commitSession, long flushId) throws IOException {\r\n    IZooReaderWriter zoo = ZooReaderWriter.getRetryingInstance();\r\n    if (tablet.getExtent().isRootTablet()) {\r\n        try {\r\n            if (!zoo.isLockHeld(tablet.getTabletServer().getLock().getLockID())) {\r\n                throw new IllegalStateException();\r\n            }\r\n        } catch (Exception e) {\r\n            throw new IllegalStateException(\"Can not bring major compaction online, lock not held\", e);\r\n        }\r\n    }\r\n    \/\/ always exist\r\n    do {\r\n        try {\r\n            if (dfv.getNumEntries() == 0) {\r\n                tablet.getTabletServer().getFileSystem().deleteRecursively(tmpDatafile.path());\r\n            } else {\r\n                if (tablet.getTabletServer().getFileSystem().exists(newDatafile.path())) {\r\n                    log.warn(\"Target map file already exist \" + newDatafile);\r\n                    tablet.getTabletServer().getFileSystem().deleteRecursively(newDatafile.path());\r\n                }\r\n                rename(tablet.getTabletServer().getFileSystem(), tmpDatafile.path(), newDatafile.path());\r\n            }\r\n            break;\r\n        } catch (IOException ioe) {\r\n            log.warn(\"Tablet \" + tablet.getExtent() + \" failed to rename \" + newDatafile + \" after MinC, will retry in 60 secs...\", ioe);\r\n            UtilWaitThread.sleep(60 * 1000);\r\n        }\r\n    } while (true);\r\n    long t1, t2;\r\n    \/\/ the code below always assumes merged files are in use by scans... this must be done\r\n    \/\/ because the in memory list of files is not updated until after the metadata table\r\n    \/\/ therefore the file is available to scans until memory is updated, but want to ensure\r\n    \/\/ the file is not available for garbage collection... if memory were updated\r\n    \/\/ before this point (like major compactions do), then the following code could wait\r\n    \/\/ for scans to finish like major compactions do.... used to wait for scans to finish\r\n    \/\/ here, but that was incorrect because a scan could start after waiting but before\r\n    \/\/ memory was updated... assuming the file is always in use by scans leads to\r\n    \/\/ one uneeded metadata update when it was not actually in use\r\n    Set<FileRef> filesInUseByScans = Collections.emptySet();\r\n    if (absMergeFile != null)\r\n        filesInUseByScans = Collections.singleton(absMergeFile);\r\n    \/\/ this metadata write does not go up... it goes sideways or to itself\r\n    if (absMergeFile != null)\r\n        MetadataTableUtil.addDeleteEntries(tablet.getExtent(), Collections.singleton(absMergeFile), SystemCredentials.get());\r\n    Set<String> unusedWalLogs = tablet.beginClearingUnusedLogs();\r\n    boolean replicate = ReplicationConfigurationUtil.isEnabled(tablet.getExtent(), tablet.getTableConfiguration());\r\n    Set<String> logFileOnly = null;\r\n    if (replicate) {\r\n        \/\/ unusedWalLogs is of the form host\/fileURI, need to strip off the host portion\r\n        logFileOnly = new HashSet<>();\r\n        for (String unusedWalLog : unusedWalLogs) {\r\n            int index = unusedWalLog.indexOf('\/');\r\n            if (-1 == index) {\r\n                log.warn(\"Could not find host component to strip from DFSLogger representation of WAL\");\r\n            } else {\r\n                unusedWalLog = unusedWalLog.substring(index + 1);\r\n            }\r\n            logFileOnly.add(unusedWalLog);\r\n        }\r\n    }\r\n    try {\r\n        \/\/ the order of writing to metadata and walog is important in the face of machine\/process failures\r\n        \/\/ need to write to metadata before writing to walog, when things are done in the reverse order\r\n        \/\/ data could be lost... the minor compaction start even should be written before the following metadata\r\n        \/\/ write is made\r\n        tablet.updateTabletDataFile(commitSession.getMaxCommittedTime(), newDatafile, absMergeFile, dfv, unusedWalLogs, filesInUseByScans, flushId);\r\n        \/\/ but it is *not* closed\r\n        if (replicate) {\r\n            ReplicationTableUtil.updateFiles(SystemCredentials.get(), tablet.getExtent(), logFileOnly, StatusUtil.openWithUnknownLength());\r\n        }\r\n    } finally {\r\n        tablet.finishClearingUnusedLogs();\r\n    }\r\n    do {\r\n        try {\r\n            \/\/ the purpose of making this update use the new commit session, instead of the old one passed in,\r\n            \/\/ is because the new one will reference the logs used by current memory...\r\n            tablet.getTabletServer().minorCompactionFinished(tablet.getTabletMemory().getCommitSession(), newDatafile.toString(), commitSession.getWALogSeq() + 2);\r\n            break;\r\n        } catch (IOException e) {\r\n            log.error(\"Failed to write to write-ahead log \" + e.getMessage() + \" will retry\", e);\r\n            UtilWaitThread.sleep(1 * 1000);\r\n        }\r\n    } while (true);\r\n    synchronized (tablet) {\r\n        t1 = System.currentTimeMillis();\r\n        if (datafileSizes.containsKey(newDatafile)) {\r\n            log.error(\"Adding file that is already in set \" + newDatafile);\r\n        }\r\n        if (dfv.getNumEntries() > 0) {\r\n            datafileSizes.put(newDatafile, dfv);\r\n        }\r\n        if (absMergeFile != null) {\r\n            datafileSizes.remove(absMergeFile);\r\n        }\r\n        unreserveMergingMinorCompactionFile(absMergeFile);\r\n        tablet.flushComplete(flushId);\r\n        t2 = System.currentTimeMillis();\r\n    }\r\n    \/\/ must do this after list of files in memory is updated above\r\n    removeFilesAfterScan(filesInUseByScans);\r\n    if (absMergeFile != null)\r\n        log.log(TLevel.TABLET_HIST, tablet.getExtent() + \" MinC [\" + absMergeFile + \",memory] -> \" + newDatafile);\r\n    else\r\n        log.log(TLevel.TABLET_HIST, tablet.getExtent() + \" MinC [memory] -> \" + newDatafile);\r\n    log.debug(String.format(\"MinC finish lock %.2f secs %s\", (t2 - t1) \/ 1000.0, tablet.getExtent().toString()));\r\n    long splitSize = tablet.getTableConfiguration().getMemoryInBytes(Property.TABLE_SPLIT_THRESHOLD);\r\n    if (dfv.getSize() > splitSize) {\r\n        log.debug(String.format(\"Minor Compaction wrote out file larger than split threshold.  split threshold = %,d  file size = %,d\", splitSize, dfv.getSize()));\r\n    }\r\n}","code_comment":null,"code_no_comment":"void bringMinorCompactionOnline(FileRef tmpDatafile, FileRef newDatafile, FileRef absMergeFile, DataFileValue dfv, CommitSession commitSession, long flushId) throws IOException {\r\n    IZooReaderWriter zoo = ZooReaderWriter.getRetryingInstance();\r\n    if (tablet.getExtent().isRootTablet()) {\r\n        try {\r\n            if (!zoo.isLockHeld(tablet.getTabletServer().getLock().getLockID())) {\r\n                throw new IllegalStateException();\r\n            }\r\n        } catch (Exception e) {\r\n            throw new IllegalStateException(\"Can not bring major compaction online, lock not held\", e);\r\n        }\r\n    }\r\n        do {\r\n        try {\r\n            if (dfv.getNumEntries() == 0) {\r\n                tablet.getTabletServer().getFileSystem().deleteRecursively(tmpDatafile.path());\r\n            } else {\r\n                if (tablet.getTabletServer().getFileSystem().exists(newDatafile.path())) {\r\n                    log.warn(\"Target map file already exist \" + newDatafile);\r\n                    tablet.getTabletServer().getFileSystem().deleteRecursively(newDatafile.path());\r\n                }\r\n                rename(tablet.getTabletServer().getFileSystem(), tmpDatafile.path(), newDatafile.path());\r\n            }\r\n            break;\r\n        } catch (IOException ioe) {\r\n            log.warn(\"Tablet \" + tablet.getExtent() + \" failed to rename \" + newDatafile + \" after MinC, will retry in 60 secs...\", ioe);\r\n            UtilWaitThread.sleep(60 * 1000);\r\n        }\r\n    } while (true);\r\n    long t1, t2;\r\n                                        Set<FileRef> filesInUseByScans = Collections.emptySet();\r\n    if (absMergeFile != null)\r\n        filesInUseByScans = Collections.singleton(absMergeFile);\r\n        if (absMergeFile != null)\r\n        MetadataTableUtil.addDeleteEntries(tablet.getExtent(), Collections.singleton(absMergeFile), SystemCredentials.get());\r\n    Set<String> unusedWalLogs = tablet.beginClearingUnusedLogs();\r\n    boolean replicate = ReplicationConfigurationUtil.isEnabled(tablet.getExtent(), tablet.getTableConfiguration());\r\n    Set<String> logFileOnly = null;\r\n    if (replicate) {\r\n                logFileOnly = new HashSet<>();\r\n        for (String unusedWalLog : unusedWalLogs) {\r\n            int index = unusedWalLog.indexOf('\/');\r\n            if (-1 == index) {\r\n                log.warn(\"Could not find host component to strip from DFSLogger representation of WAL\");\r\n            } else {\r\n                unusedWalLog = unusedWalLog.substring(index + 1);\r\n            }\r\n            logFileOnly.add(unusedWalLog);\r\n        }\r\n    }\r\n    try {\r\n                                        tablet.updateTabletDataFile(commitSession.getMaxCommittedTime(), newDatafile, absMergeFile, dfv, unusedWalLogs, filesInUseByScans, flushId);\r\n                if (replicate) {\r\n            ReplicationTableUtil.updateFiles(SystemCredentials.get(), tablet.getExtent(), logFileOnly, StatusUtil.openWithUnknownLength());\r\n        }\r\n    } finally {\r\n        tablet.finishClearingUnusedLogs();\r\n    }\r\n    do {\r\n        try {\r\n                                    tablet.getTabletServer().minorCompactionFinished(tablet.getTabletMemory().getCommitSession(), newDatafile.toString(), commitSession.getWALogSeq() + 2);\r\n            break;\r\n        } catch (IOException e) {\r\n            log.error(\"Failed to write to write-ahead log \" + e.getMessage() + \" will retry\", e);\r\n            UtilWaitThread.sleep(1 * 1000);\r\n        }\r\n    } while (true);\r\n    synchronized (tablet) {\r\n        t1 = System.currentTimeMillis();\r\n        if (datafileSizes.containsKey(newDatafile)) {\r\n            log.error(\"Adding file that is already in set \" + newDatafile);\r\n        }\r\n        if (dfv.getNumEntries() > 0) {\r\n            datafileSizes.put(newDatafile, dfv);\r\n        }\r\n        if (absMergeFile != null) {\r\n            datafileSizes.remove(absMergeFile);\r\n        }\r\n        unreserveMergingMinorCompactionFile(absMergeFile);\r\n        tablet.flushComplete(flushId);\r\n        t2 = System.currentTimeMillis();\r\n    }\r\n        removeFilesAfterScan(filesInUseByScans);\r\n    if (absMergeFile != null)\r\n        log.log(TLevel.TABLET_HIST, tablet.getExtent() + \" MinC [\" + absMergeFile + \",memory] -> \" + newDatafile);\r\n    else\r\n        log.log(TLevel.TABLET_HIST, tablet.getExtent() + \" MinC [memory] -> \" + newDatafile);\r\n    log.debug(String.format(\"MinC finish lock %.2f secs %s\", (t2 - t1) \/ 1000.0, tablet.getExtent().toString()));\r\n    long splitSize = tablet.getTableConfiguration().getMemoryInBytes(Property.TABLE_SPLIT_THRESHOLD);\r\n    if (dfv.getSize() > splitSize) {\r\n        log.debug(String.format(\"Minor Compaction wrote out file larger than split threshold.  split threshold = %,d  file size = %,d\", splitSize, dfv.getSize()));\r\n    }\r\n}","lc":3.5454545455,"pi":0.5933014354,"ma":4.2,"nbd":1.0,"ml":2.0,"d":1.4861111111,"mi":-1.3735024665,"fo":6.4166666667,"r":-0.0263157895,"e":9.0543040404}
{"project_name":"Math","project_version":"19","label":1,"code":"\/**\r\n * Checks dimensions and values of boundaries and inputSigma if defined.\r\n *\/\r\nprivate void checkParameters() {\r\n    final double[] init = getStartPoint();\r\n    final double[] lB = getLowerBound();\r\n    final double[] uB = getUpperBound();\r\n    \/\/ Checks whether there is at least one finite bound value.\r\n    boolean hasFiniteBounds = false;\r\n    for (int i = 0; i < lB.length; i++) {\r\n        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\r\n            hasFiniteBounds = true;\r\n            break;\r\n        }\r\n    }\r\n    \/\/ Checks whether there is at least one infinite bound value.\r\n    boolean hasInfiniteBounds = false;\r\n    if (hasFiniteBounds) {\r\n        for (int i = 0; i < lB.length; i++) {\r\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\r\n                hasInfiniteBounds = true;\r\n                break;\r\n            }\r\n        }\r\n        if (hasInfiniteBounds) {\r\n            \/\/ because mixed cases are not supported by the current code.\r\n            throw new MathUnsupportedOperationException();\r\n        } else {\r\n            \/\/ Convert API to internal handling of boundaries.\r\n            boundaries = new double[2][];\r\n            boundaries[0] = lB;\r\n            boundaries[1] = uB;\r\n        \/\/ Abort early if the normalization will overflow (cf. \"encode\" method).\r\n        }\r\n    } else {\r\n        \/\/ Convert API to internal handling of boundaries.\r\n        boundaries = null;\r\n    }\r\n    if (inputSigma != null) {\r\n        if (inputSigma.length != init.length) {\r\n            throw new DimensionMismatchException(inputSigma.length, init.length);\r\n        }\r\n        for (int i = 0; i < init.length; i++) {\r\n            if (inputSigma[i] < 0) {\r\n                throw new NotPositiveException(inputSigma[i]);\r\n            }\r\n            if (boundaries != null) {\r\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\r\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Checks dimensions and values of boundaries and inputSigma if defined.\r\n *\/\r\n","code_no_comment":"private void checkParameters() {\r\n    final double[] init = getStartPoint();\r\n    final double[] lB = getLowerBound();\r\n    final double[] uB = getUpperBound();\r\n        boolean hasFiniteBounds = false;\r\n    for (int i = 0; i < lB.length; i++) {\r\n        if (!Double.isInfinite(lB[i]) || !Double.isInfinite(uB[i])) {\r\n            hasFiniteBounds = true;\r\n            break;\r\n        }\r\n    }\r\n        boolean hasInfiniteBounds = false;\r\n    if (hasFiniteBounds) {\r\n        for (int i = 0; i < lB.length; i++) {\r\n            if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\r\n                hasInfiniteBounds = true;\r\n                break;\r\n            }\r\n        }\r\n        if (hasInfiniteBounds) {\r\n                        throw new MathUnsupportedOperationException();\r\n        } else {\r\n                        boundaries = new double[2][];\r\n            boundaries[0] = lB;\r\n            boundaries[1] = uB;\r\n                }\r\n    } else {\r\n                boundaries = null;\r\n    }\r\n    if (inputSigma != null) {\r\n        if (inputSigma.length != init.length) {\r\n            throw new DimensionMismatchException(inputSigma.length, init.length);\r\n        }\r\n        for (int i = 0; i < init.length; i++) {\r\n            if (inputSigma[i] < 0) {\r\n                throw new NotPositiveException(inputSigma[i]);\r\n            }\r\n            if (boundaries != null) {\r\n                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\r\n                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","lc":1.4090909091,"pi":0.7751196172,"ma":3.0,"nbd":1.0,"ml":1.5833333333,"d":2.6865079365,"mi":-0.837068358,"fo":0.0833333333,"r":-0.0263157895,"e":4.5642756292}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1372_1d12bf0e","label":3,"code":"@Override\r\nprotected PrettyPrinter newPrettyPrinter() {\r\n    return new DefaultXmlPrettyPrinter();\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected PrettyPrinter newPrettyPrinter() {\r\n    return new DefaultXmlPrettyPrinter();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9785764623,"fo":-0.5,"r":1.4473684211,"e":-0.1627934049}
{"project_name":"Closure","project_version":"7","label":2,"code":"@Override\r\npublic JSType caseObjectType(ObjectType type) {\r\n    if (value.equals(\"function\")) {\r\n        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\r\n        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\r\n    \/\/ Objects are restricted to \"Function\", subtypes are left\r\n    \/\/ Only filter out subtypes of \"function\"\r\n    }\r\n    return matchesExpectation(\"object\") ? type : null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic JSType caseObjectType(ObjectType type) {\r\n    if (value.equals(\"function\")) {\r\n        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\r\n        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\r\n            }\r\n    return matchesExpectation(\"object\") ? type : null;\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":0.0,"nbd":-0.5,"ml":0.3333333333,"d":-0.0972222222,"mi":0.318111346,"fo":-0.1666666667,"r":2.1052631579,"e":-0.0965520421}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3897_94c6c575","label":1,"code":"@Override\r\npublic boolean childNodeAdded(String name, NodeState after) {\r\n    String p = PathUtils.concat(path, name);\r\n    ResetDiff diff = new ResetDiff(revision, p, operations);\r\n    UpdateOp op = diff.getUpdateOp();\r\n    NodeDocument.removeDeleted(op, revision);\r\n    return after.compareAgainstBaseState(EMPTY_NODE, diff);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean childNodeAdded(String name, NodeState after) {\r\n    String p = PathUtils.concat(path, name);\r\n    ResetDiff diff = new ResetDiff(revision, p, operations);\r\n    UpdateOp op = diff.getUpdateOp();\r\n    NodeDocument.removeDeleted(op, revision);\r\n    return after.compareAgainstBaseState(EMPTY_NODE, diff);\r\n}","lc":-0.2727272727,"pi":-0.5023923445,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.2834390416,"fo":-0.1666666667,"r":0.0,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5706_0f8a6d75","label":1,"code":"\/**\r\n *  Extract the locale from the filename\r\n *\r\n *  @param path\r\n *             The file path\r\n *  @return The updated path, without the locale\r\n *\/\r\npublic static PathLocale getLocaleFromFilename(String path) {\r\n    String extension = \"\";\r\n    int pos = path.indexOf('.');\r\n    if (pos != -1) {\r\n        extension = path.substring(pos);\r\n        path = path.substring(0, pos);\r\n    }\r\n    String filename = Strings.lastPathComponent(path, '\/');\r\n    Matcher matcher = LOCALE_PATTERN.matcher(filename);\r\n    if (matcher.find()) {\r\n        String language = matcher.group(1);\r\n        String country = matcher.group(3);\r\n        String variant = matcher.group(5);\r\n        \/\/ did we find a language?\r\n        if (language != null) {\r\n            if (isoLanguages.contains(language) == false) {\r\n                language = null;\r\n                country = null;\r\n                variant = null;\r\n            }\r\n        }\r\n        \/\/ did we find a country?\r\n        if ((language != null) && (country != null)) {\r\n            if (isoCountries.contains(country) == false) {\r\n                country = null;\r\n                variant = null;\r\n            }\r\n        }\r\n        if (language != null) {\r\n            pos = path.length() - filename.length() + matcher.start();\r\n            String basePath = path.substring(0, pos) + extension;\r\n            Locale locale = new Locale(language, country != null ? country : \"\", variant != null ? variant : \"\");\r\n            return new PathLocale(basePath, locale);\r\n        }\r\n    }\r\n    return new PathLocale(path, null);\r\n}","code_comment":"\/**\r\n *  Extract the locale from the filename\r\n *\r\n *  @param path\r\n *             The file path\r\n *  @return The updated path, without the locale\r\n *\/\r\n","code_no_comment":"public static PathLocale getLocaleFromFilename(String path) {\r\n    String extension = \"\";\r\n    int pos = path.indexOf('.');\r\n    if (pos != -1) {\r\n        extension = path.substring(pos);\r\n        path = path.substring(0, pos);\r\n    }\r\n    String filename = Strings.lastPathComponent(path, '\/');\r\n    Matcher matcher = LOCALE_PATTERN.matcher(filename);\r\n    if (matcher.find()) {\r\n        String language = matcher.group(1);\r\n        String country = matcher.group(3);\r\n        String variant = matcher.group(5);\r\n                if (language != null) {\r\n            if (isoLanguages.contains(language) == false) {\r\n                language = null;\r\n                country = null;\r\n                variant = null;\r\n            }\r\n        }\r\n                if ((language != null) && (country != null)) {\r\n            if (isoCountries.contains(country) == false) {\r\n                country = null;\r\n                variant = null;\r\n            }\r\n        }\r\n        if (language != null) {\r\n            pos = path.length() - filename.length() + matcher.start();\r\n            String basePath = path.substring(0, pos) + extension;\r\n            Locale locale = new Locale(language, country != null ? country : \"\", variant != null ? variant : \"\");\r\n            return new PathLocale(basePath, locale);\r\n        }\r\n    }\r\n    return new PathLocale(path, null);\r\n}","lc":0.9545454545,"pi":0.7224880383,"ma":1.2,"nbd":0.5,"ml":1.0,"d":1.3888888889,"mi":-0.6831571529,"fo":0.75,"r":-0.0263157895,"e":2.9325426601}
{"project_name":"Compress","project_version":"6","label":1,"code":"\/* (non-Javadoc)\r\n     * @see java.lang.Object#equals(java.lang.Object)\r\n     *\/\r\npublic boolean equals(Object obj) {\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj == null || getClass() != obj.getClass()) {\r\n        return false;\r\n    }\r\n    ZipArchiveEntry other = (ZipArchiveEntry) obj;\r\n    if (name == null) {\r\n        if (other.name != null) {\r\n            return false;\r\n        }\r\n    } else if (!name.equals(other.name)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"public boolean equals(Object obj) {\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj == null || getClass() != obj.getClass()) {\r\n        return false;\r\n    }\r\n    ZipArchiveEntry other = (ZipArchiveEntry) obj;\r\n    if (name == null) {\r\n        if (other.name != null) {\r\n            return false;\r\n        }\r\n    } else if (!name.equals(other.name)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}","lc":0.1363636364,"pi":0.0,"ma":0.4,"nbd":0.0,"ml":0.5833333333,"d":0.6448412698,"mi":-0.0835799859,"fo":-0.25,"r":1.2105263158,"e":0.1751859984}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2021_004db804","label":1,"code":"@Override\r\npublic String toString() {\r\n    return s1 + \" union \" + s2;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String toString() {\r\n    return s1 + \" union \" + s2;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8723044397,"fo":-0.5,"r":2.5,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-537_a8493efc","label":3,"code":"public double getCost(String name, PropertyValue value) {\r\n    double cost = 0.0;\r\n    \/\/ TODO the cost method is currently reading all the data -\r\n    \/\/ is not supposed to do that, it is only supposed to estimate\r\n    NodeState state = getIndexDefinitionNode(name);\r\n    if (state != null && state.getChildNode(\":index\") != null) {\r\n        state = state.getChildNode(\":index\");\r\n        if (value == null) {\r\n            cost += store.count(state, null);\r\n        } else {\r\n            cost += store.count(state, Property2Index.encode(value));\r\n        }\r\n    } else {\r\n        cost = Double.POSITIVE_INFINITY;\r\n    }\r\n    return cost;\r\n}","code_comment":null,"code_no_comment":"public double getCost(String name, PropertyValue value) {\r\n    double cost = 0.0;\r\n            NodeState state = getIndexDefinitionNode(name);\r\n    if (state != null && state.getChildNode(\":index\") != null) {\r\n        state = state.getChildNode(\":index\");\r\n        if (value == null) {\r\n            cost += store.count(state, null);\r\n        } else {\r\n            cost += store.count(state, Property2Index.encode(value));\r\n        }\r\n    } else {\r\n        cost = Double.POSITIVE_INFINITY;\r\n    }\r\n    return cost;\r\n}","lc":0.0454545455,"pi":0.2631578947,"ma":-0.2,"nbd":0.0,"ml":0.0833333333,"d":0.4285714286,"mi":-0.0770965469,"fo":0.0,"r":0.0526315789,"e":0.2654011284}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3028_89317b28","label":0,"code":"@Override\r\npublic String toString() {\r\n    return \"key: \" + id + \" \" + (isNew ? \"new\" : \"update\") + \" \" + changes;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String toString() {\r\n    return \"key: \" + id + \" \" + (isNew ? \"new\" : \"update\") + \" \" + changes;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.3650793651,"mi":0.7685694151,"fo":-0.5,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"Codec","project_version":"1","label":1,"code":"\/**\r\n * Find the caverphone value of a String.\r\n *\r\n * @param txt String to find the caverphone code for\r\n * @return A caverphone code corresponding to the String supplied\r\n *\/\r\npublic String caverphone(String txt) {\r\n    if (txt == null || txt.length() == 0) {\r\n        return \"1111111111\";\r\n    }\r\n    \/\/ 1. Convert to lowercase\r\n    txt = txt.toLowerCase();\r\n    \/\/ 2. Remove anything not A-Z\r\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\r\n    \/\/ 2.5. Remove final e\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"e$\", \"\");\r\n    \/\/ 3. Handle various start options\r\n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\r\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\r\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\r\n    \/\/ 2.0 only - note the spec says ^enough here again, c+p error I assume\r\n    txt = txt.replaceAll(\"^trough\", \"trou2f\");\r\n    txt = txt.replaceAll(\"^gn\", \"2n\");\r\n    txt = txt.replaceAll(\"^mb\", \"m2\");\r\n    \/\/ 4. Handle replacements\r\n    txt = txt.replaceAll(\"cq\", \"2q\");\r\n    txt = txt.replaceAll(\"ci\", \"si\");\r\n    txt = txt.replaceAll(\"ce\", \"se\");\r\n    txt = txt.replaceAll(\"cy\", \"sy\");\r\n    txt = txt.replaceAll(\"tch\", \"2ch\");\r\n    txt = txt.replaceAll(\"c\", \"k\");\r\n    txt = txt.replaceAll(\"q\", \"k\");\r\n    txt = txt.replaceAll(\"x\", \"k\");\r\n    txt = txt.replaceAll(\"v\", \"f\");\r\n    txt = txt.replaceAll(\"dg\", \"2g\");\r\n    txt = txt.replaceAll(\"tio\", \"sio\");\r\n    txt = txt.replaceAll(\"tia\", \"sia\");\r\n    txt = txt.replaceAll(\"d\", \"t\");\r\n    txt = txt.replaceAll(\"ph\", \"fh\");\r\n    txt = txt.replaceAll(\"b\", \"p\");\r\n    txt = txt.replaceAll(\"sh\", \"s2\");\r\n    txt = txt.replaceAll(\"z\", \"s\");\r\n    txt = txt.replaceAll(\"^[aeiou]\", \"A\");\r\n    txt = txt.replaceAll(\"[aeiou]\", \"3\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"j\", \"y\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"^y3\", \"Y3\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"^y\", \"A\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"y\", \"3\");\r\n    txt = txt.replaceAll(\"3gh3\", \"3kh3\");\r\n    txt = txt.replaceAll(\"gh\", \"22\");\r\n    txt = txt.replaceAll(\"g\", \"k\");\r\n    txt = txt.replaceAll(\"s+\", \"S\");\r\n    txt = txt.replaceAll(\"t+\", \"T\");\r\n    txt = txt.replaceAll(\"p+\", \"P\");\r\n    txt = txt.replaceAll(\"k+\", \"K\");\r\n    txt = txt.replaceAll(\"f+\", \"F\");\r\n    txt = txt.replaceAll(\"m+\", \"M\");\r\n    txt = txt.replaceAll(\"n+\", \"N\");\r\n    txt = txt.replaceAll(\"w3\", \"W3\");\r\n    \/\/ txt = txt.replaceAll(\"wy\", \"Wy\");    \/\/ 1.0 only\r\n    txt = txt.replaceAll(\"wh3\", \"Wh3\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"w$\", \"3\");\r\n    \/\/ txt = txt.replaceAll(\"why\", \"Why\");  \/\/ 1.0 only\r\n    txt = txt.replaceAll(\"w\", \"2\");\r\n    txt = txt.replaceAll(\"^h\", \"A\");\r\n    txt = txt.replaceAll(\"h\", \"2\");\r\n    txt = txt.replaceAll(\"r3\", \"R3\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"r$\", \"3\");\r\n    \/\/ txt = txt.replaceAll(\"ry\", \"Ry\");    \/\/ 1.0 only\r\n    txt = txt.replaceAll(\"r\", \"2\");\r\n    txt = txt.replaceAll(\"l3\", \"L3\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"l$\", \"3\");\r\n    \/\/ txt = txt.replaceAll(\"ly\", \"Ly\");    \/\/ 1.0 only\r\n    txt = txt.replaceAll(\"l\", \"2\");\r\n    \/\/ txt = txt.replaceAll(\"j\", \"y\");      \/\/ 1.0 only\r\n    \/\/ txt = txt.replaceAll(\"y3\", \"Y3\");    \/\/ 1.0 only\r\n    \/\/ txt = txt.replaceAll(\"y\", \"2\");      \/\/ 1.0 only\r\n    \/\/ 5. Handle removals\r\n    txt = txt.replaceAll(\"2\", \"\");\r\n    \/\/ 2.0 only\r\n    txt = txt.replaceAll(\"3$\", \"A\");\r\n    txt = txt.replaceAll(\"3\", \"\");\r\n    \/\/ 6. put ten 1s on the end\r\n    \/\/ 1.0 only has 6 1s\r\n    txt = txt + \"111111\" + \"1111\";\r\n    \/\/ 1.0 truncates to 6\r\n    return txt.substring(0, 10);\r\n}","code_comment":"\/**\r\n * Find the caverphone value of a String.\r\n *\r\n * @param txt String to find the caverphone code for\r\n * @return A caverphone code corresponding to the String supplied\r\n *\/\r\n","code_no_comment":"public String caverphone(String txt) {\r\n    if (txt == null || txt.length() == 0) {\r\n        return \"1111111111\";\r\n    }\r\n        txt = txt.toLowerCase();\r\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\r\n            txt = txt.replaceAll(\"e$\", \"\");\r\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\r\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\r\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\r\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");\r\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");\r\n    txt = txt.replaceAll(\"^gn\", \"2n\");\r\n    txt = txt.replaceAll(\"^mb\", \"m2\");\r\n        txt = txt.replaceAll(\"cq\", \"2q\");\r\n    txt = txt.replaceAll(\"ci\", \"si\");\r\n    txt = txt.replaceAll(\"ce\", \"se\");\r\n    txt = txt.replaceAll(\"cy\", \"sy\");\r\n    txt = txt.replaceAll(\"tch\", \"2ch\");\r\n    txt = txt.replaceAll(\"c\", \"k\");\r\n    txt = txt.replaceAll(\"q\", \"k\");\r\n    txt = txt.replaceAll(\"x\", \"k\");\r\n    txt = txt.replaceAll(\"v\", \"f\");\r\n    txt = txt.replaceAll(\"dg\", \"2g\");\r\n    txt = txt.replaceAll(\"tio\", \"sio\");\r\n    txt = txt.replaceAll(\"tia\", \"sia\");\r\n    txt = txt.replaceAll(\"d\", \"t\");\r\n    txt = txt.replaceAll(\"ph\", \"fh\");\r\n    txt = txt.replaceAll(\"b\", \"p\");\r\n    txt = txt.replaceAll(\"sh\", \"s2\");\r\n    txt = txt.replaceAll(\"z\", \"s\");\r\n    txt = txt.replaceAll(\"^[aeiou]\", \"A\");\r\n    txt = txt.replaceAll(\"[aeiou]\", \"3\");\r\n        txt = txt.replaceAll(\"j\", \"y\");\r\n        txt = txt.replaceAll(\"^y3\", \"Y3\");\r\n        txt = txt.replaceAll(\"^y\", \"A\");\r\n        txt = txt.replaceAll(\"y\", \"3\");\r\n    txt = txt.replaceAll(\"3gh3\", \"3kh3\");\r\n    txt = txt.replaceAll(\"gh\", \"22\");\r\n    txt = txt.replaceAll(\"g\", \"k\");\r\n    txt = txt.replaceAll(\"s+\", \"S\");\r\n    txt = txt.replaceAll(\"t+\", \"T\");\r\n    txt = txt.replaceAll(\"p+\", \"P\");\r\n    txt = txt.replaceAll(\"k+\", \"K\");\r\n    txt = txt.replaceAll(\"f+\", \"F\");\r\n    txt = txt.replaceAll(\"m+\", \"M\");\r\n    txt = txt.replaceAll(\"n+\", \"N\");\r\n    txt = txt.replaceAll(\"w3\", \"W3\");\r\n        txt = txt.replaceAll(\"wh3\", \"Wh3\");\r\n        txt = txt.replaceAll(\"w$\", \"3\");\r\n        txt = txt.replaceAll(\"w\", \"2\");\r\n    txt = txt.replaceAll(\"^h\", \"A\");\r\n    txt = txt.replaceAll(\"h\", \"2\");\r\n    txt = txt.replaceAll(\"r3\", \"R3\");\r\n        txt = txt.replaceAll(\"r$\", \"3\");\r\n        txt = txt.replaceAll(\"r\", \"2\");\r\n    txt = txt.replaceAll(\"l3\", \"L3\");\r\n        txt = txt.replaceAll(\"l$\", \"3\");\r\n        txt = txt.replaceAll(\"l\", \"2\");\r\n                    txt = txt.replaceAll(\"2\", \"\");\r\n        txt = txt.replaceAll(\"3$\", \"A\");\r\n    txt = txt.replaceAll(\"3\", \"\");\r\n            txt = txt + \"111111\" + \"1111\";\r\n        return txt.substring(0, 10);\r\n}","lc":2.3181818182,"pi":-1.019138756,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":0.751984127,"mi":-1.0899224806,"fo":4.5,"r":-0.0263157895,"e":6.3906894187}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-358_061f5017","label":0,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\r\n    final int n = y0.length;\r\n    sanityChecks(equations, t0, y0, t, y);\r\n    setEquations(equations);\r\n    resetEvaluations();\r\n    final boolean forward = t > t0;\r\n    \/\/ initialize working arrays\r\n    if (y != y0) {\r\n        System.arraycopy(y0, 0, y, 0, n);\r\n    }\r\n    final double[] yDot = new double[y0.length];\r\n    final double[] yTmp = new double[y0.length];\r\n    \/\/ set up two interpolators sharing the integrator arrays\r\n    final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\r\n    interpolator.reinitialize(y, forward);\r\n    final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\r\n    interpolatorTmp.reinitialize(yTmp, forward);\r\n    \/\/ set up integration control objects\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.reset();\r\n    }\r\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\r\n    \/\/ compute the initial Nordsieck vector using the configured starter integrator\r\n    start(t0, y, t);\r\n    interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\r\n    interpolator.storeTime(stepStart);\r\n    double hNew = stepSize;\r\n    interpolator.rescale(hNew);\r\n    boolean lastStep = false;\r\n    while (!lastStep) {\r\n        \/\/ shift all data\r\n        interpolator.shift();\r\n        double error = 0;\r\n        for (boolean loop = true; loop; ) {\r\n            stepSize = hNew;\r\n            \/\/ predict a first estimate of the state at step end (P in the PECE sequence)\r\n            final double stepEnd = stepStart + stepSize;\r\n            interpolator.setInterpolatedTime(stepEnd);\r\n            System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\r\n            \/\/ evaluate a first estimate of the derivative (first E in the PECE sequence)\r\n            computeDerivatives(stepEnd, yTmp, yDot);\r\n            \/\/ update Nordsieck vector\r\n            final double[] predictedScaled = new double[y0.length];\r\n            for (int j = 0; j < y0.length; ++j) {\r\n                predictedScaled[j] = stepSize * yDot[j];\r\n            }\r\n            final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\r\n            updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\r\n            \/\/ apply correction (C in the PECE sequence)\r\n            error = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));\r\n            if (error <= 1.0) {\r\n                \/\/ evaluate a final estimate of the derivative (second E in the PECE sequence)\r\n                computeDerivatives(stepEnd, yTmp, yDot);\r\n                \/\/ update Nordsieck vector\r\n                final double[] correctedScaled = new double[y0.length];\r\n                for (int j = 0; j < y0.length; ++j) {\r\n                    correctedScaled[j] = stepSize * yDot[j];\r\n                }\r\n                updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);\r\n                \/\/ discrete events handling\r\n                interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\r\n                interpolatorTmp.storeTime(stepStart);\r\n                interpolatorTmp.shift();\r\n                interpolatorTmp.storeTime(stepEnd);\r\n                if (manager.evaluateStep(interpolatorTmp)) {\r\n                    final double dt = manager.getEventTime() - stepStart;\r\n                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\r\n                        \/\/ rejecting the step would lead to a too small next step, we accept it\r\n                        loop = false;\r\n                    } else {\r\n                        \/\/ reject the step to match exactly the next switch time\r\n                        hNew = dt;\r\n                        interpolator.rescale(hNew);\r\n                    }\r\n                } else {\r\n                    \/\/ accept the step\r\n                    scaled = correctedScaled;\r\n                    nordsieck = nordsieckTmp;\r\n                    interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\r\n                    loop = false;\r\n                }\r\n            } else {\r\n                \/\/ reject the step and attempt to reduce error by stepsize control\r\n                final double factor = computeStepGrowShrinkFactor(error);\r\n                hNew = filterStep(stepSize * factor, forward, false);\r\n                interpolator.rescale(hNew);\r\n            }\r\n        }\r\n        \/\/ the step has been accepted (may have been truncated)\r\n        final double nextStep = stepStart + stepSize;\r\n        System.arraycopy(yTmp, 0, y, 0, n);\r\n        interpolator.storeTime(nextStep);\r\n        manager.stepAccepted(nextStep, y);\r\n        lastStep = manager.stop();\r\n        \/\/ provide the step data to the step handler\r\n        for (StepHandler handler : stepHandlers) {\r\n            interpolator.setInterpolatedTime(nextStep);\r\n            handler.handleStep(interpolator, lastStep);\r\n        }\r\n        stepStart = nextStep;\r\n        if (!lastStep && manager.reset(stepStart, y)) {\r\n            \/\/ some events handler has triggered changes that\r\n            \/\/ invalidate the derivatives, we need to restart from scratch\r\n            start(stepStart, y, t);\r\n            interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\r\n        }\r\n        if (!lastStep) {\r\n            \/\/ in some rare cases we may get here with stepSize = 0, for example\r\n            \/\/ when an event occurs at integration start, reducing the first step\r\n            \/\/ to zero; we have to reset the step to some safe non zero value\r\n            stepSize = filterStep(stepSize, forward, true);\r\n            \/\/ stepsize control for next step\r\n            final double factor = computeStepGrowShrinkFactor(error);\r\n            final double scaledH = stepSize * factor;\r\n            final double nextT = stepStart + scaledH;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            hNew = filterStep(scaledH, forward, nextIsLast);\r\n            interpolator.rescale(hNew);\r\n        }\r\n    }\r\n    final double stopTime = stepStart;\r\n    stepStart = Double.NaN;\r\n    stepSize = Double.NaN;\r\n    return stopTime;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\r\n    final int n = y0.length;\r\n    sanityChecks(equations, t0, y0, t, y);\r\n    setEquations(equations);\r\n    resetEvaluations();\r\n    final boolean forward = t > t0;\r\n        if (y != y0) {\r\n        System.arraycopy(y0, 0, y, 0, n);\r\n    }\r\n    final double[] yDot = new double[y0.length];\r\n    final double[] yTmp = new double[y0.length];\r\n        final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\r\n    interpolator.reinitialize(y, forward);\r\n    final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\r\n    interpolatorTmp.reinitialize(yTmp, forward);\r\n        for (StepHandler handler : stepHandlers) {\r\n        handler.reset();\r\n    }\r\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\r\n        start(t0, y, t);\r\n    interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\r\n    interpolator.storeTime(stepStart);\r\n    double hNew = stepSize;\r\n    interpolator.rescale(hNew);\r\n    boolean lastStep = false;\r\n    while (!lastStep) {\r\n                interpolator.shift();\r\n        double error = 0;\r\n        for (boolean loop = true; loop; ) {\r\n            stepSize = hNew;\r\n                        final double stepEnd = stepStart + stepSize;\r\n            interpolator.setInterpolatedTime(stepEnd);\r\n            System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\r\n                        computeDerivatives(stepEnd, yTmp, yDot);\r\n                        final double[] predictedScaled = new double[y0.length];\r\n            for (int j = 0; j < y0.length; ++j) {\r\n                predictedScaled[j] = stepSize * yDot[j];\r\n            }\r\n            final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\r\n            updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\r\n                        error = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));\r\n            if (error <= 1.0) {\r\n                                computeDerivatives(stepEnd, yTmp, yDot);\r\n                                final double[] correctedScaled = new double[y0.length];\r\n                for (int j = 0; j < y0.length; ++j) {\r\n                    correctedScaled[j] = stepSize * yDot[j];\r\n                }\r\n                updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);\r\n                                interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\r\n                interpolatorTmp.storeTime(stepStart);\r\n                interpolatorTmp.shift();\r\n                interpolatorTmp.storeTime(stepEnd);\r\n                if (manager.evaluateStep(interpolatorTmp)) {\r\n                    final double dt = manager.getEventTime() - stepStart;\r\n                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\r\n                                                loop = false;\r\n                    } else {\r\n                                                hNew = dt;\r\n                        interpolator.rescale(hNew);\r\n                    }\r\n                } else {\r\n                                        scaled = correctedScaled;\r\n                    nordsieck = nordsieckTmp;\r\n                    interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\r\n                    loop = false;\r\n                }\r\n            } else {\r\n                                final double factor = computeStepGrowShrinkFactor(error);\r\n                hNew = filterStep(stepSize * factor, forward, false);\r\n                interpolator.rescale(hNew);\r\n            }\r\n        }\r\n                final double nextStep = stepStart + stepSize;\r\n        System.arraycopy(yTmp, 0, y, 0, n);\r\n        interpolator.storeTime(nextStep);\r\n        manager.stepAccepted(nextStep, y);\r\n        lastStep = manager.stop();\r\n                for (StepHandler handler : stepHandlers) {\r\n            interpolator.setInterpolatedTime(nextStep);\r\n            handler.handleStep(interpolator, lastStep);\r\n        }\r\n        stepStart = nextStep;\r\n        if (!lastStep && manager.reset(stepStart, y)) {\r\n                                    start(stepStart, y, t);\r\n            interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\r\n        }\r\n        if (!lastStep) {\r\n                                                stepSize = filterStep(stepSize, forward, true);\r\n                        final double factor = computeStepGrowShrinkFactor(error);\r\n            final double scaledH = stepSize * factor;\r\n            final double nextT = stepStart + scaledH;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            hNew = filterStep(scaledH, forward, nextIsLast);\r\n            interpolator.rescale(hNew);\r\n        }\r\n    }\r\n    final double stopTime = stepStart;\r\n    stepStart = Double.NaN;\r\n    stepSize = Double.NaN;\r\n    return stopTime;\r\n}","lc":4.0,"pi":1.3827751196,"ma":2.0,"nbd":1.5,"ml":1.8333333333,"d":4.2063492063,"mi":-1.3689922481,"fo":3.5,"r":-0.0263157895,"e":25.8120548861}
{"project_name":"Compress","project_version":"31","label":1,"code":"\/**\r\n * Parse an octal string from a buffer.\r\n *\r\n * <p>Leading spaces are ignored.\r\n * The buffer must contain a trailing space or NUL,\r\n * and may contain an additional trailing space or NUL.<\/p>\r\n *\r\n * <p>The input buffer is allowed to contain all NULs,\r\n * in which case the method returns 0L\r\n * (this allows for missing fields).<\/p>\r\n *\r\n * <p>To work-around some tar implementations that insert a\r\n * leading NUL this method returns 0 if it detects a leading NUL\r\n * since Commons Compress 1.4.<\/p>\r\n *\r\n * @param buffer The buffer from which to parse.\r\n * @param offset The offset into the buffer from which to parse.\r\n * @param length The maximum number of bytes to parse - must be at least 2 bytes.\r\n * @return The long value of the octal string.\r\n * @throws IllegalArgumentException if the trailing space\/NUL is missing or if a invalid byte is detected.\r\n *\/\r\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\r\n    long result = 0;\r\n    int end = offset + length;\r\n    int start = offset;\r\n    if (length < 2) {\r\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\r\n    }\r\n    if (buffer[start] == 0) {\r\n        return 0L;\r\n    }\r\n    \/\/ Skip leading spaces\r\n    while (start < end) {\r\n        if (buffer[start] == ' ') {\r\n            start++;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    \/\/ Trim all trailing NULs and spaces.\r\n    \/\/ The ustar and POSIX tar specs require a trailing NUL or\r\n    \/\/ space but some implementations use the extra digit for big\r\n    \/\/ sizes\/uids\/gids ...\r\n    byte trailer = buffer[end - 1];\r\n    while (start < end && (trailer == 0 || trailer == ' ')) {\r\n        end--;\r\n        trailer = buffer[end - 1];\r\n    }\r\n    for (; start < end; start++) {\r\n        final byte currentByte = buffer[start];\r\n        if (currentByte == 0) {\r\n            break;\r\n        }\r\n        \/\/ CheckStyle:MagicNumber OFF\r\n        if (currentByte < '0' || currentByte > '7') {\r\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\r\n        }\r\n        \/\/ convert from ASCII\r\n        result = (result << 3) + (currentByte - '0');\r\n    \/\/ CheckStyle:MagicNumber ON\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n * Parse an octal string from a buffer.\r\n *\r\n * <p>Leading spaces are ignored.\r\n * The buffer must contain a trailing space or NUL,\r\n * and may contain an additional trailing space or NUL.<\/p>\r\n *\r\n * <p>The input buffer is allowed to contain all NULs,\r\n * in which case the method returns 0L\r\n * (this allows for missing fields).<\/p>\r\n *\r\n * <p>To work-around some tar implementations that insert a\r\n * leading NUL this method returns 0 if it detects a leading NUL\r\n * since Commons Compress 1.4.<\/p>\r\n *\r\n * @param buffer The buffer from which to parse.\r\n * @param offset The offset into the buffer from which to parse.\r\n * @param length The maximum number of bytes to parse - must be at least 2 bytes.\r\n * @return The long value of the octal string.\r\n * @throws IllegalArgumentException if the trailing space\/NUL is missing or if a invalid byte is detected.\r\n *\/\r\n","code_no_comment":"public static long parseOctal(final byte[] buffer, final int offset, final int length) {\r\n    long result = 0;\r\n    int end = offset + length;\r\n    int start = offset;\r\n    if (length < 2) {\r\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\r\n    }\r\n    if (buffer[start] == 0) {\r\n        return 0L;\r\n    }\r\n        while (start < end) {\r\n        if (buffer[start] == ' ') {\r\n            start++;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n                    byte trailer = buffer[end - 1];\r\n    while (start < end && (trailer == 0 || trailer == ' ')) {\r\n        end--;\r\n        trailer = buffer[end - 1];\r\n    }\r\n    for (; start < end; start++) {\r\n        final byte currentByte = buffer[start];\r\n        if (currentByte == 0) {\r\n            break;\r\n        }\r\n                if (currentByte < '0' || currentByte > '7') {\r\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\r\n        }\r\n                result = (result << 3) + (currentByte - '0');\r\n        }\r\n    return result;\r\n}","lc":0.9090909091,"pi":0.0526315789,"ma":1.8,"nbd":0.0,"ml":0.9166666667,"d":2.8472222222,"mi":-0.6264975335,"fo":-0.4166666667,"r":-0.0263157895,"e":3.5320666425}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_46f62443","label":1,"code":"@Override\r\npublic IteratorSetting getIteratorSetting(String tableName, String name, IteratorScope scope) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\r\n    int priority = -1;\r\n    String classname = null;\r\n    Map<String, String> settings = new HashMap<String, String>();\r\n    String root = String.format(\"%s%s.%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), name);\r\n    String opt = root + \".opt.\";\r\n    for (Entry<String, String> property : this.getProperties(tableName)) {\r\n        if (property.getKey().equals(root)) {\r\n            String[] parts = property.getValue().split(\",\");\r\n            if (parts.length != 2) {\r\n                throw new AccumuloException(\"Bad value for iterator setting: \" + property.getValue());\r\n            }\r\n            priority = Integer.parseInt(parts[0]);\r\n            classname = parts[1];\r\n        } else if (property.getKey().startsWith(opt)) {\r\n            settings.put(property.getKey().substring(opt.length()), property.getValue());\r\n        }\r\n    }\r\n    if (priority <= 0 || classname == null) {\r\n        return null;\r\n    }\r\n    return new IteratorSetting(priority, name, classname, EnumSet.of(scope), settings);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic IteratorSetting getIteratorSetting(String tableName, String name, IteratorScope scope) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\r\n    int priority = -1;\r\n    String classname = null;\r\n    Map<String, String> settings = new HashMap<String, String>();\r\n    String root = String.format(\"%s%s.%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), name);\r\n    String opt = root + \".opt.\";\r\n    for (Entry<String, String> property : this.getProperties(tableName)) {\r\n        if (property.getKey().equals(root)) {\r\n            String[] parts = property.getValue().split(\",\");\r\n            if (parts.length != 2) {\r\n                throw new AccumuloException(\"Bad value for iterator setting: \" + property.getValue());\r\n            }\r\n            priority = Integer.parseInt(parts[0]);\r\n            classname = parts[1];\r\n        } else if (property.getKey().startsWith(opt)) {\r\n            settings.put(property.getKey().substring(opt.length()), property.getValue());\r\n        }\r\n    }\r\n    if (priority <= 0 || classname == null) {\r\n        return null;\r\n    }\r\n    return new IteratorSetting(priority, name, classname, EnumSet.of(scope), settings);\r\n}","lc":0.4545454545,"pi":0.6842105263,"ma":0.6,"nbd":0.5,"ml":0.5833333333,"d":0.8630952381,"mi":-0.467230444,"fo":1.0,"r":-0.0263157895,"e":1.6770595253}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5432_93935780","label":1,"code":"@Override\r\npublic boolean process(final Exchange exchange, final AsyncCallback callback) {\r\n    WaitForTaskToComplete wait = waitForTaskToComplete;\r\n    if (exchange.getProperty(Exchange.ASYNC_WAIT) != null) {\r\n        wait = exchange.getProperty(Exchange.ASYNC_WAIT, WaitForTaskToComplete.class);\r\n    }\r\n    if (wait == WaitForTaskToComplete.Always || (wait == WaitForTaskToComplete.IfReplyExpected && ExchangeHelper.isOutCapable(exchange))) {\r\n        \/\/ do not handover the completion as we wait for the copy to complete, and copy its result back when it done\r\n        Exchange copy = prepareCopy(exchange, false);\r\n        \/\/ latch that waits until we are complete\r\n        final CountDownLatch latch = new CountDownLatch(1);\r\n        \/\/ we should wait for the reply so install a on completion so we know when its complete\r\n        copy.addOnCompletion(new SynchronizationAdapter() {\r\n\r\n            @Override\r\n            public void onDone(Exchange response) {\r\n                \/\/ check for timeout, which then already would have invoked the latch\r\n                if (latch.getCount() == 0) {\r\n                    if (log.isTraceEnabled()) {\r\n                        log.trace(\"{}. Timeout occurred so response will be ignored: {}\", this, response.hasOut() ? response.getOut() : response.getIn());\r\n                    }\r\n                    return;\r\n                } else {\r\n                    if (log.isTraceEnabled()) {\r\n                        log.trace(\"{} with response: {}\", this, response.hasOut() ? response.getOut() : response.getIn());\r\n                    }\r\n                    try {\r\n                        ExchangeHelper.copyResults(exchange, response);\r\n                    } finally {\r\n                        \/\/ always ensure latch is triggered\r\n                        latch.countDown();\r\n                    }\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public boolean allowHandover() {\r\n                \/\/ at this point in the routing (at this leg), instead of at the very last (this ensure timeout is honored)\r\n                return false;\r\n            }\r\n\r\n            @Override\r\n            public String toString() {\r\n                return \"onDone at endpoint: \" + endpoint;\r\n            }\r\n        });\r\n        log.trace(\"Adding Exchange to queue: {}\", copy);\r\n        addToQueue(copy);\r\n        if (timeout > 0) {\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"Waiting for task to complete using timeout (ms): {} at [{}]\", timeout, endpoint.getEndpointUri());\r\n            }\r\n            \/\/ lets see if we can get the task done before the timeout\r\n            boolean done = false;\r\n            try {\r\n                done = latch.await(timeout, TimeUnit.MILLISECONDS);\r\n            } catch (InterruptedException e) {\r\n            \/\/ ignore\r\n            }\r\n            if (!done) {\r\n                exchange.setException(new ExchangeTimedOutException(exchange, timeout));\r\n                \/\/ remove timed out Exchange from queue\r\n                queue.remove(copy);\r\n                \/\/ count down to indicate timeout\r\n                latch.countDown();\r\n            }\r\n        } else {\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"Waiting for task to complete (blocking) at [{}]\", endpoint.getEndpointUri());\r\n            }\r\n            \/\/ no timeout then wait until its done\r\n            try {\r\n                latch.await();\r\n            } catch (InterruptedException e) {\r\n            \/\/ ignore\r\n            }\r\n        }\r\n    } else {\r\n        \/\/ no wait, eg its a InOnly then just add to queue and return\r\n        \/\/ handover the completion so its the copy which performs that, as we do not wait\r\n        Exchange copy = prepareCopy(exchange, true);\r\n        log.trace(\"Adding Exchange to queue: {}\", copy);\r\n        addToQueue(copy);\r\n    }\r\n    \/\/ we use OnCompletion on the Exchange to callback and wait for the Exchange to be done\r\n    \/\/ so we should just signal the callback we are done synchronously\r\n    callback.done(true);\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean process(final Exchange exchange, final AsyncCallback callback) {\r\n    WaitForTaskToComplete wait = waitForTaskToComplete;\r\n    if (exchange.getProperty(Exchange.ASYNC_WAIT) != null) {\r\n        wait = exchange.getProperty(Exchange.ASYNC_WAIT, WaitForTaskToComplete.class);\r\n    }\r\n    if (wait == WaitForTaskToComplete.Always || (wait == WaitForTaskToComplete.IfReplyExpected && ExchangeHelper.isOutCapable(exchange))) {\r\n                Exchange copy = prepareCopy(exchange, false);\r\n                final CountDownLatch latch = new CountDownLatch(1);\r\n                copy.addOnCompletion(new SynchronizationAdapter() {\r\n\r\n            @Override\r\n            public void onDone(Exchange response) {\r\n                                if (latch.getCount() == 0) {\r\n                    if (log.isTraceEnabled()) {\r\n                        log.trace(\"{}. Timeout occurred so response will be ignored: {}\", this, response.hasOut() ? response.getOut() : response.getIn());\r\n                    }\r\n                    return;\r\n                } else {\r\n                    if (log.isTraceEnabled()) {\r\n                        log.trace(\"{} with response: {}\", this, response.hasOut() ? response.getOut() : response.getIn());\r\n                    }\r\n                    try {\r\n                        ExchangeHelper.copyResults(exchange, response);\r\n                    } finally {\r\n                                                latch.countDown();\r\n                    }\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public boolean allowHandover() {\r\n                                return false;\r\n            }\r\n\r\n            @Override\r\n            public String toString() {\r\n                return \"onDone at endpoint: \" + endpoint;\r\n            }\r\n        });\r\n        log.trace(\"Adding Exchange to queue: {}\", copy);\r\n        addToQueue(copy);\r\n        if (timeout > 0) {\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"Waiting for task to complete using timeout (ms): {} at [{}]\", timeout, endpoint.getEndpointUri());\r\n            }\r\n                        boolean done = false;\r\n            try {\r\n                done = latch.await(timeout, TimeUnit.MILLISECONDS);\r\n            } catch (InterruptedException e) {\r\n                        }\r\n            if (!done) {\r\n                exchange.setException(new ExchangeTimedOutException(exchange, timeout));\r\n                                queue.remove(copy);\r\n                                latch.countDown();\r\n            }\r\n        } else {\r\n            if (log.isTraceEnabled()) {\r\n                log.trace(\"Waiting for task to complete (blocking) at [{}]\", endpoint.getEndpointUri());\r\n            }\r\n                        try {\r\n                latch.await();\r\n            } catch (InterruptedException e) {\r\n                        }\r\n        }\r\n    } else {\r\n                        Exchange copy = prepareCopy(exchange, true);\r\n        log.trace(\"Adding Exchange to queue: {}\", copy);\r\n        addToQueue(copy);\r\n    }\r\n            callback.done(true);\r\n    return true;\r\n}","lc":2.5454545455,"pi":1.3875598086,"ma":2.0,"nbd":1.0,"ml":1.5833333333,"d":1.5595238095,"mi":-1.0662438337,"fo":2.4166666667,"r":-0.0263157895,"e":4.3195495698}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3620_1a2bc1bc","label":1,"code":"\/**\r\n *  Runs the configured {@link IResponseFilter}s over the constructed Ajax response\r\n *\r\n *  @param contentResponse\r\n *             the Ajax {@link Response} body\r\n *\/\r\nprivate void invokeResponseFilters(final StringResponse contentResponse) {\r\n    AppendingStringBuffer responseBuffer = new AppendingStringBuffer(contentResponse.getBuffer());\r\n    List<IResponseFilter> responseFilters = Application.get().getRequestCycleSettings().getResponseFilters();\r\n    if (responseFilters != null) {\r\n        for (IResponseFilter filter : responseFilters) {\r\n            filter.filter(responseBuffer);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  Runs the configured {@link IResponseFilter}s over the constructed Ajax response\r\n *\r\n *  @param contentResponse\r\n *             the Ajax {@link Response} body\r\n *\/\r\n","code_no_comment":"private void invokeResponseFilters(final StringResponse contentResponse) {\r\n    AppendingStringBuffer responseBuffer = new AppendingStringBuffer(contentResponse.getBuffer());\r\n    List<IResponseFilter> responseFilters = Application.get().getRequestCycleSettings().getResponseFilters();\r\n    if (responseFilters != null) {\r\n        for (IResponseFilter filter : responseFilters) {\r\n            filter.filter(responseBuffer);\r\n        }\r\n    }\r\n}","lc":-0.2272727273,"pi":0.3205741627,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":-0.0674603175,"mi":0.2622973925,"fo":-0.0833333333,"r":1.8684210526,"e":-0.0849339857}
{"project_name":"Compress","project_version":"30","label":1,"code":"\/*\r\n     * (non-Javadoc)\r\n     * \r\n     * @see java.io.InputStream#read(byte[], int, int)\r\n     *\/\r\n@Override\r\npublic int read(final byte[] dest, final int offs, final int len) throws IOException {\r\n    if (offs < 0) {\r\n        throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\r\n    }\r\n    if (len < 0) {\r\n        throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\r\n    }\r\n    if (offs + len > dest.length) {\r\n        throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") > dest.length(\" + dest.length + \").\");\r\n    }\r\n    if (this.in == null) {\r\n        throw new IOException(\"stream closed\");\r\n    }\r\n    final int hi = offs + len;\r\n    int destOffs = offs;\r\n    int b;\r\n    while (destOffs < hi && ((b = read0()) >= 0)) {\r\n        dest[destOffs++] = (byte) b;\r\n        count(1);\r\n    }\r\n    int c = (destOffs == offs) ? -1 : (destOffs - offs);\r\n    return c;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int read(final byte[] dest, final int offs, final int len) throws IOException {\r\n    if (offs < 0) {\r\n        throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\r\n    }\r\n    if (len < 0) {\r\n        throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\r\n    }\r\n    if (offs + len > dest.length) {\r\n        throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\" + len + \") > dest.length(\" + dest.length + \").\");\r\n    }\r\n    if (this.in == null) {\r\n        throw new IOException(\"stream closed\");\r\n    }\r\n    final int hi = offs + len;\r\n    int destOffs = offs;\r\n    int b;\r\n    while (destOffs < hi && ((b = read0()) >= 0)) {\r\n        dest[destOffs++] = (byte) b;\r\n        count(1);\r\n    }\r\n    int c = (destOffs == offs) ? -1 : (destOffs - offs);\r\n    return c;\r\n}","lc":0.4545454545,"pi":-0.2822966507,"ma":1.4,"nbd":-0.5,"ml":0.6666666667,"d":1.4365079365,"mi":-0.4269203665,"fo":-0.3333333333,"r":0.0,"e":1.5543968235}
{"project_name":"Cli","project_version":"5","label":3,"code":"\/**\r\n * <p>Remove the hyphens from the begining of <code>str<\/code> and\r\n * return the new String.<\/p>\r\n *\r\n * @param str The string from which the hyphens should be removed.\r\n *\r\n * @return the new String.\r\n *\/\r\nstatic String stripLeadingHyphens(String str) {\r\n    if (str.startsWith(\"--\")) {\r\n        return str.substring(2, str.length());\r\n    } else if (str.startsWith(\"-\")) {\r\n        return str.substring(1, str.length());\r\n    }\r\n    return str;\r\n}","code_comment":"\/**\r\n * <p>Remove the hyphens from the begining of <code>str<\/code> and\r\n * return the new String.<\/p>\r\n *\r\n * @param str The string from which the hyphens should be removed.\r\n *\r\n * @return the new String.\r\n *\/\r\n","code_no_comment":"static String stripLeadingHyphens(String str) {\r\n    if (str.startsWith(\"--\")) {\r\n        return str.substring(2, str.length());\r\n    } else if (str.startsWith(\"-\")) {\r\n        return str.substring(1, str.length());\r\n    }\r\n    return str;\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.3736434109,"fo":0.0,"r":0.1315789474,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6779_f412d744","label":1,"code":"@Converter\r\npublic XMLEventReader createXMLEventReader(InputStream in, Exchange exchange) throws XMLStreamException {\r\n    XMLInputFactory factory = getInputFactory();\r\n    try {\r\n        return factory.createXMLEventReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange));\r\n    } finally {\r\n        returnXMLInputFactory(factory);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Converter\r\npublic XMLEventReader createXMLEventReader(InputStream in, Exchange exchange) throws XMLStreamException {\r\n    XMLInputFactory factory = getInputFactory();\r\n    try {\r\n        return factory.createXMLEventReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange));\r\n    } finally {\r\n        returnXMLInputFactory(factory);\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.3017618041,"fo":-0.0833333333,"r":0.2894736842,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-848_ad252a8c","label":1,"code":"\/**\r\n * Find the first small sub-diagonal element and returns its index.\r\n *\r\n * @param startIdx the starting index for the search\r\n * @param norm the L1 norm of the matrix\r\n * @return the index of the first small sub-diagonal element\r\n *\/\r\nprivate int findSmallSubDiagonalElement(final int startIdx, final double norm) {\r\n    int l = startIdx;\r\n    while (l > 0) {\r\n        double s = FastMath.abs(matrixT[l - 1][l - 1]) + FastMath.abs(matrixT[l][l]);\r\n        if (Precision.equals(s, 0.0, epsilon)) {\r\n            s = norm;\r\n        }\r\n        if (FastMath.abs(matrixT[l][l - 1]) < epsilon * s) {\r\n            break;\r\n        }\r\n        l--;\r\n    }\r\n    return l;\r\n}","code_comment":"\/**\r\n * Find the first small sub-diagonal element and returns its index.\r\n *\r\n * @param startIdx the starting index for the search\r\n * @param norm the L1 norm of the matrix\r\n * @return the index of the first small sub-diagonal element\r\n *\/\r\n","code_no_comment":"private int findSmallSubDiagonalElement(final int startIdx, final double norm) {\r\n    int l = startIdx;\r\n    while (l > 0) {\r\n        double s = FastMath.abs(matrixT[l - 1][l - 1]) + FastMath.abs(matrixT[l][l]);\r\n        if (Precision.equals(s, 0.0, epsilon)) {\r\n            s = norm;\r\n        }\r\n        if (FastMath.abs(matrixT[l][l - 1]) < epsilon * s) {\r\n            break;\r\n        }\r\n        l--;\r\n    }\r\n    return l;\r\n}","lc":0.0,"pi":0.2966507177,"ma":0.2,"nbd":0.0,"ml":0.25,"d":1.1428571429,"mi":-0.0494714588,"fo":-0.1666666667,"r":0.4210526316,"e":0.6028411219}
{"project_name":"Closure","project_version":"31","label":2,"code":"\/\/ ------------------------------------------------------------------------\r\n\/\/ Parsing\r\n\/\/ ------------------------------------------------------------------------\r\n\/**\r\n * Parses the externs and main inputs.\r\n *\r\n * @return A synthetic root node whose two children are the externs root\r\n *     and the main root\r\n *\/\r\nNode parseInputs() {\r\n    boolean devMode = options.devMode != DevMode.OFF;\r\n    \/\/ individual file parse trees.\r\n    if (externsRoot != null) {\r\n        externsRoot.detachChildren();\r\n    }\r\n    if (jsRoot != null) {\r\n        jsRoot.detachChildren();\r\n    }\r\n    \/\/ Parse main js sources.\r\n    jsRoot = IR.block();\r\n    jsRoot.setIsSyntheticBlock(true);\r\n    externsRoot = IR.block();\r\n    externsRoot.setIsSyntheticBlock(true);\r\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\r\n    externAndJsRoot.setIsSyntheticBlock(true);\r\n    if (options.tracer.isOn()) {\r\n        tracker = new PerformanceTracker(jsRoot, options.tracer);\r\n        addChangeHandler(tracker.getCodeChangeHandler());\r\n    }\r\n    Tracer tracer = newTracer(\"parseInputs\");\r\n    try {\r\n        \/\/ Parse externs sources.\r\n        for (CompilerInput input : externs) {\r\n            Node n = input.getAstRoot(this);\r\n            if (hasErrors()) {\r\n                return null;\r\n            }\r\n            externsRoot.addChildToBack(n);\r\n        }\r\n        \/\/ Modules inferred in ProcessCommonJS pass.\r\n        if (options.transformAMDToCJSModules || options.processCommonJSModules) {\r\n            processAMDAndCommonJSModules();\r\n        }\r\n        \/\/ Check if inputs need to be rebuilt from modules.\r\n        boolean staleInputs = false;\r\n        \/\/ Check if the sources need to be re-ordered.\r\n        if (options.dependencyOptions.needsManagement() && !options.skipAllPasses && options.closurePass) {\r\n            for (CompilerInput input : inputs) {\r\n                \/\/ are not flagged even if they are dropped from the process.\r\n                for (String provide : input.getProvides()) {\r\n                    getTypeRegistry().forwardDeclareType(provide);\r\n                }\r\n            }\r\n            try {\r\n                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs);\r\n                staleInputs = true;\r\n            } catch (CircularDependencyException e) {\r\n                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\r\n                \/\/ If in IDE mode, we ignore the error and keep going.\r\n                if (hasErrors()) {\r\n                    return null;\r\n                }\r\n            } catch (MissingProvideException e) {\r\n                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));\r\n                \/\/ If in IDE mode, we ignore the error and keep going.\r\n                if (hasErrors()) {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n        for (CompilerInput input : inputs) {\r\n            Node n = input.getAstRoot(this);\r\n            \/\/ Inputs can have a null AST during initial parse.\r\n            if (n == null) {\r\n                continue;\r\n            }\r\n            if (n.getJSDocInfo() != null) {\r\n                JSDocInfo info = n.getJSDocInfo();\r\n                if (info.isExterns()) {\r\n                    \/\/ If the input file is explicitly marked as an externs file, then\r\n                    \/\/ assume the programmer made a mistake and throw it into\r\n                    \/\/ the externs pile anyways.\r\n                    externsRoot.addChildToBack(n);\r\n                    input.setIsExtern(true);\r\n                    input.getModule().remove(input);\r\n                    externs.add(input);\r\n                    staleInputs = true;\r\n                } else if (info.isNoCompile()) {\r\n                    input.getModule().remove(input);\r\n                    staleInputs = true;\r\n                }\r\n            }\r\n        }\r\n        if (staleInputs) {\r\n            fillEmptyModules(modules);\r\n            rebuildInputsFromModules();\r\n        }\r\n        \/\/ Build the AST.\r\n        for (CompilerInput input : inputs) {\r\n            Node n = input.getAstRoot(this);\r\n            if (n == null) {\r\n                continue;\r\n            }\r\n            if (devMode) {\r\n                runSanityCheck();\r\n                if (hasErrors()) {\r\n                    return null;\r\n                }\r\n            }\r\n            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {\r\n                \/\/ Annotate the nodes in the tree with information from the\r\n                \/\/ input file. This information is used to construct the SourceMap.\r\n                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);\r\n                NodeTraversal.traverse(this, n, sia);\r\n            }\r\n            jsRoot.addChildToBack(n);\r\n        }\r\n        if (hasErrors()) {\r\n            return null;\r\n        }\r\n        return externAndJsRoot;\r\n    } finally {\r\n        stopTracer(tracer, \"parseInputs\");\r\n    }\r\n}","code_comment":"\/**\r\n * Parses the externs and main inputs.\r\n *\r\n * @return A synthetic root node whose two children are the externs root\r\n *     and the main root\r\n *\/\r\n","code_no_comment":"Node parseInputs() {\r\n    boolean devMode = options.devMode != DevMode.OFF;\r\n        if (externsRoot != null) {\r\n        externsRoot.detachChildren();\r\n    }\r\n    if (jsRoot != null) {\r\n        jsRoot.detachChildren();\r\n    }\r\n        jsRoot = IR.block();\r\n    jsRoot.setIsSyntheticBlock(true);\r\n    externsRoot = IR.block();\r\n    externsRoot.setIsSyntheticBlock(true);\r\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\r\n    externAndJsRoot.setIsSyntheticBlock(true);\r\n    if (options.tracer.isOn()) {\r\n        tracker = new PerformanceTracker(jsRoot, options.tracer);\r\n        addChangeHandler(tracker.getCodeChangeHandler());\r\n    }\r\n    Tracer tracer = newTracer(\"parseInputs\");\r\n    try {\r\n                for (CompilerInput input : externs) {\r\n            Node n = input.getAstRoot(this);\r\n            if (hasErrors()) {\r\n                return null;\r\n            }\r\n            externsRoot.addChildToBack(n);\r\n        }\r\n                if (options.transformAMDToCJSModules || options.processCommonJSModules) {\r\n            processAMDAndCommonJSModules();\r\n        }\r\n                boolean staleInputs = false;\r\n                if (options.dependencyOptions.needsManagement() && !options.skipAllPasses && options.closurePass) {\r\n            for (CompilerInput input : inputs) {\r\n                                for (String provide : input.getProvides()) {\r\n                    getTypeRegistry().forwardDeclareType(provide);\r\n                }\r\n            }\r\n            try {\r\n                inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs);\r\n                staleInputs = true;\r\n            } catch (CircularDependencyException e) {\r\n                report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\r\n                                if (hasErrors()) {\r\n                    return null;\r\n                }\r\n            } catch (MissingProvideException e) {\r\n                report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage()));\r\n                                if (hasErrors()) {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n        for (CompilerInput input : inputs) {\r\n            Node n = input.getAstRoot(this);\r\n                        if (n == null) {\r\n                continue;\r\n            }\r\n            if (n.getJSDocInfo() != null) {\r\n                JSDocInfo info = n.getJSDocInfo();\r\n                if (info.isExterns()) {\r\n                                                                                externsRoot.addChildToBack(n);\r\n                    input.setIsExtern(true);\r\n                    input.getModule().remove(input);\r\n                    externs.add(input);\r\n                    staleInputs = true;\r\n                } else if (info.isNoCompile()) {\r\n                    input.getModule().remove(input);\r\n                    staleInputs = true;\r\n                }\r\n            }\r\n        }\r\n        if (staleInputs) {\r\n            fillEmptyModules(modules);\r\n            rebuildInputsFromModules();\r\n        }\r\n                for (CompilerInput input : inputs) {\r\n            Node n = input.getAstRoot(this);\r\n            if (n == null) {\r\n                continue;\r\n            }\r\n            if (devMode) {\r\n                runSanityCheck();\r\n                if (hasErrors()) {\r\n                    return null;\r\n                }\r\n            }\r\n            if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {\r\n                                                SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF);\r\n                NodeTraversal.traverse(this, n, sia);\r\n            }\r\n            jsRoot.addChildToBack(n);\r\n        }\r\n        if (hasErrors()) {\r\n            return null;\r\n        }\r\n        return externAndJsRoot;\r\n    } finally {\r\n        stopTracer(tracer, \"parseInputs\");\r\n    }\r\n}","lc":3.9090909091,"pi":1.0669856459,"ma":5.0,"nbd":1.5,"ml":3.0,"d":1.1686507937,"mi":-1.3870331219,"fo":3.75,"r":-0.0263157895,"e":5.2385516617}
{"project_name":"Closure","project_version":"169","label":2,"code":"\/**\r\n * An equivalence visitor.\r\n *\/\r\nboolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {\r\n    if (this == that) {\r\n        return true;\r\n    }\r\n    boolean thisUnknown = isUnknownType();\r\n    boolean thatUnknown = that.isUnknownType();\r\n    if (thisUnknown || thatUnknown) {\r\n        if (tolerateUnknowns) {\r\n            \/\/ both unknown.\r\n            return thisUnknown && thatUnknown;\r\n        } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) {\r\n            \/\/ we won't unbox the unknowns further down.\r\n            return false;\r\n        }\r\n    }\r\n    if (isUnionType() && that.isUnionType()) {\r\n        return this.toMaybeUnionType().checkUnionEquivalenceHelper(that.toMaybeUnionType(), tolerateUnknowns);\r\n    }\r\n    if (isFunctionType() && that.isFunctionType()) {\r\n        return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(that.toMaybeFunctionType(), tolerateUnknowns);\r\n    }\r\n    if (isRecordType() && that.isRecordType()) {\r\n        return this.toMaybeRecordType().checkRecordEquivalenceHelper(that.toMaybeRecordType(), tolerateUnknowns);\r\n    }\r\n    ParameterizedType thisParamType = toMaybeParameterizedType();\r\n    ParameterizedType thatParamType = that.toMaybeParameterizedType();\r\n    if (thisParamType != null || thatParamType != null) {\r\n        \/\/ Check if one type is parameterized, but the other is not.\r\n        boolean paramsMatch = false;\r\n        if (thisParamType != null && thatParamType != null) {\r\n            paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(thatParamType.getParameterType(), tolerateUnknowns);\r\n        } else if (tolerateUnknowns) {\r\n            \/\/ If one of the type parameters is unknown, but the other is not,\r\n            \/\/ then we consider these the same for the purposes of data flow\r\n            \/\/ and invariance.\r\n            paramsMatch = true;\r\n        } else {\r\n            paramsMatch = false;\r\n        }\r\n        JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal();\r\n        JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal();\r\n        return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);\r\n    }\r\n    if (isNominalType() && that.isNominalType()) {\r\n        return toObjectType().getReferenceName().equals(that.toObjectType().getReferenceName());\r\n    }\r\n    \/\/ Unbox other proxies.\r\n    if (this instanceof ProxyObjectType) {\r\n        return ((ProxyObjectType) this).getReferencedTypeInternal().checkEquivalenceHelper(that, tolerateUnknowns);\r\n    }\r\n    if (that instanceof ProxyObjectType) {\r\n        return checkEquivalenceHelper(((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns);\r\n    }\r\n    \/\/ identical, then the type member must be different.\r\n    return this == that;\r\n}","code_comment":"\/**\r\n * An equivalence visitor.\r\n *\/\r\n","code_no_comment":"boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {\r\n    if (this == that) {\r\n        return true;\r\n    }\r\n    boolean thisUnknown = isUnknownType();\r\n    boolean thatUnknown = that.isUnknownType();\r\n    if (thisUnknown || thatUnknown) {\r\n        if (tolerateUnknowns) {\r\n                        return thisUnknown && thatUnknown;\r\n        } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) {\r\n                        return false;\r\n        }\r\n    }\r\n    if (isUnionType() && that.isUnionType()) {\r\n        return this.toMaybeUnionType().checkUnionEquivalenceHelper(that.toMaybeUnionType(), tolerateUnknowns);\r\n    }\r\n    if (isFunctionType() && that.isFunctionType()) {\r\n        return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(that.toMaybeFunctionType(), tolerateUnknowns);\r\n    }\r\n    if (isRecordType() && that.isRecordType()) {\r\n        return this.toMaybeRecordType().checkRecordEquivalenceHelper(that.toMaybeRecordType(), tolerateUnknowns);\r\n    }\r\n    ParameterizedType thisParamType = toMaybeParameterizedType();\r\n    ParameterizedType thatParamType = that.toMaybeParameterizedType();\r\n    if (thisParamType != null || thatParamType != null) {\r\n                boolean paramsMatch = false;\r\n        if (thisParamType != null && thatParamType != null) {\r\n            paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(thatParamType.getParameterType(), tolerateUnknowns);\r\n        } else if (tolerateUnknowns) {\r\n                                                paramsMatch = true;\r\n        } else {\r\n            paramsMatch = false;\r\n        }\r\n        JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal();\r\n        JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal();\r\n        return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);\r\n    }\r\n    if (isNominalType() && that.isNominalType()) {\r\n        return toObjectType().getReferenceName().equals(that.toObjectType().getReferenceName());\r\n    }\r\n        if (this instanceof ProxyObjectType) {\r\n        return ((ProxyObjectType) this).getReferencedTypeInternal().checkEquivalenceHelper(that, tolerateUnknowns);\r\n    }\r\n    if (that instanceof ProxyObjectType) {\r\n        return checkEquivalenceHelper(((ProxyObjectType) that).getReferencedTypeInternal(), tolerateUnknowns);\r\n    }\r\n        return this == that;\r\n}","lc":1.5454545455,"pi":-0.023923445,"ma":2.4,"nbd":0.5,"ml":2.75,"d":1.6825396825,"mi":-0.8694855532,"fo":2.6666666667,"r":-0.0263157895,"e":3.5353445941}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-293_25cb587a","label":1,"code":"\/**\r\n * Default Factory Constructor.\r\n * @param name The configuration name.\r\n * @param configLocation The configuration location.\r\n * @return The Configuration.\r\n *\/\r\n@Override\r\npublic Configuration getConfiguration(final String name, final URI configLocation) {\r\n    if (configLocation == null) {\r\n        final String config = PropertiesUtil.getProperties().getStringProperty(CONFIGURATION_FILE_PROPERTY);\r\n        if (config != null) {\r\n            final ClassLoader loader = this.getClass().getClassLoader();\r\n            final ConfigurationSource source = getInputFromString(config, loader);\r\n            if (source != null) {\r\n                for (final ConfigurationFactory factory : factories) {\r\n                    final String[] types = factory.getSupportedTypes();\r\n                    if (types != null) {\r\n                        for (final String type : types) {\r\n                            if (type.equals(\"*\") || config.endsWith(type)) {\r\n                                final Configuration c = factory.getConfiguration(source);\r\n                                if (c != null) {\r\n                                    return c;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        for (final ConfigurationFactory factory : factories) {\r\n            final String[] types = factory.getSupportedTypes();\r\n            if (types != null) {\r\n                for (final String type : types) {\r\n                    if (type.equals(\"*\") || configLocation.getPath().endsWith(type)) {\r\n                        final Configuration config = factory.getConfiguration(name, configLocation);\r\n                        if (config != null) {\r\n                            return config;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Configuration config = getConfiguration(true, name);\r\n    if (config == null) {\r\n        config = getConfiguration(true, null);\r\n        if (config == null) {\r\n            config = getConfiguration(false, name);\r\n            if (config == null) {\r\n                config = getConfiguration(false, null);\r\n            }\r\n        }\r\n    }\r\n    return config != null ? config : new DefaultConfiguration();\r\n}","code_comment":"\/**\r\n * Default Factory Constructor.\r\n * @param name The configuration name.\r\n * @param configLocation The configuration location.\r\n * @return The Configuration.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic Configuration getConfiguration(final String name, final URI configLocation) {\r\n    if (configLocation == null) {\r\n        final String config = PropertiesUtil.getProperties().getStringProperty(CONFIGURATION_FILE_PROPERTY);\r\n        if (config != null) {\r\n            final ClassLoader loader = this.getClass().getClassLoader();\r\n            final ConfigurationSource source = getInputFromString(config, loader);\r\n            if (source != null) {\r\n                for (final ConfigurationFactory factory : factories) {\r\n                    final String[] types = factory.getSupportedTypes();\r\n                    if (types != null) {\r\n                        for (final String type : types) {\r\n                            if (type.equals(\"*\") || config.endsWith(type)) {\r\n                                final Configuration c = factory.getConfiguration(source);\r\n                                if (c != null) {\r\n                                    return c;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        for (final ConfigurationFactory factory : factories) {\r\n            final String[] types = factory.getSupportedTypes();\r\n            if (types != null) {\r\n                for (final String type : types) {\r\n                    if (type.equals(\"*\") || configLocation.getPath().endsWith(type)) {\r\n                        final Configuration config = factory.getConfiguration(name, configLocation);\r\n                        if (config != null) {\r\n                            return config;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Configuration config = getConfiguration(true, name);\r\n    if (config == null) {\r\n        config = getConfiguration(true, null);\r\n        if (config == null) {\r\n            config = getConfiguration(false, name);\r\n            if (config == null) {\r\n                config = getConfiguration(false, null);\r\n            }\r\n        }\r\n    }\r\n    return config != null ? config : new DefaultConfiguration();\r\n}","lc":1.6363636364,"pi":3.028708134,"ma":2.8,"nbd":3.0,"ml":1.5833333333,"d":0.8829365079,"mi":-0.8875264271,"fo":1.0,"r":-0.0263157895,"e":1.8896469056}
{"project_name":"Math","project_version":"99","label":3,"code":"\/**\r\n * <p>\r\n * Gets the greatest common divisor of the absolute value of two numbers,\r\n * using the \"binary gcd\" method which avoids division and modulo\r\n * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\r\n * Stein (1961).\r\n * <\/p>\r\n * Special cases:\r\n * <ul>\r\n * <li>The invocations\r\n * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)<\/code>,\r\n * <code>gcd(Integer.MIN_VALUE, 0)<\/code> and\r\n * <code>gcd(0, Integer.MIN_VALUE)<\/code> throw an\r\n * <code>ArithmeticException<\/code>, because the result would be 2^31, which\r\n * is too large for an int value.<\/li>\r\n * <li>The result of <code>gcd(x, x)<\/code>, <code>gcd(0, x)<\/code> and\r\n * <code>gcd(x, 0)<\/code> is the absolute value of <code>x<\/code>, except\r\n * for the special cases above.\r\n * <li>The invocation <code>gcd(0, 0)<\/code> is the only one which returns\r\n * <code>0<\/code>.<\/li>\r\n * <\/ul>\r\n *\r\n * @param u any number\r\n * @param v any number\r\n * @return the greatest common divisor, never negative\r\n * @throws ArithmeticException\r\n *             if the result cannot be represented as a nonnegative int\r\n *             value\r\n * @since 1.1\r\n *\/\r\npublic static int gcd(final int p, final int q) {\r\n    int u = p;\r\n    int v = q;\r\n    if ((u == 0) || (v == 0)) {\r\n        return (Math.abs(u) + Math.abs(v));\r\n    }\r\n    \/* assert u!=0 && v!=0; *\/\r\n    if (u > 0) {\r\n        u = -u;\r\n    }\r\n    \/\/ make u negative\r\n    if (v > 0) {\r\n        v = -v;\r\n    }\r\n    \/\/ make v negative\r\n    \/\/ B1. [Find power of 2]\r\n    int k = 0;\r\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\r\n        \/\/ while u and v are\r\n        \/\/ both even...\r\n        u \/= 2;\r\n        v \/= 2;\r\n        \/\/ cast out twos.\r\n        k++;\r\n    }\r\n    if (k == 31) {\r\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\r\n    }\r\n    \/\/ B2. Initialize: u and v have been divided by 2^k and at least\r\n    \/\/ one is odd.\r\n    int t = ((u & 1) == 1) ? v : -(u \/ 2);\r\n    \/\/ t positive: u was even, v is odd (t replaces u)\r\n    do {\r\n        \/\/ B4\/B3: cast out twos from t.\r\n        while ((t & 1) == 0) {\r\n            \/\/ while t is even..\r\n            \/\/ cast out twos\r\n            t \/= 2;\r\n        }\r\n        \/\/ B5 [reset max(u,v)]\r\n        if (t > 0) {\r\n            u = -t;\r\n        } else {\r\n            v = t;\r\n        }\r\n        \/\/ B6\/B3. at this point both u and v should be odd.\r\n        t = (v - u) \/ 2;\r\n    \/\/ |u| larger: t positive (replace u)\r\n    \/\/ |v| larger: t negative (replace v)\r\n    } while (t != 0);\r\n    \/\/ gcd is u*2^k\r\n    return -u * (1 << k);\r\n}","code_comment":"\/**\r\n * <p>\r\n * Gets the greatest common divisor of the absolute value of two numbers,\r\n * using the \"binary gcd\" method which avoids division and modulo\r\n * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\r\n * Stein (1961).\r\n * <\/p>\r\n * Special cases:\r\n * <ul>\r\n * <li>The invocations\r\n * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)<\/code>,\r\n * <code>gcd(Integer.MIN_VALUE, 0)<\/code> and\r\n * <code>gcd(0, Integer.MIN_VALUE)<\/code> throw an\r\n * <code>ArithmeticException<\/code>, because the result would be 2^31, which\r\n * is too large for an int value.<\/li>\r\n * <li>The result of <code>gcd(x, x)<\/code>, <code>gcd(0, x)<\/code> and\r\n * <code>gcd(x, 0)<\/code> is the absolute value of <code>x<\/code>, except\r\n * for the special cases above.\r\n * <li>The invocation <code>gcd(0, 0)<\/code> is the only one which returns\r\n * <code>0<\/code>.<\/li>\r\n * <\/ul>\r\n *\r\n * @param u any number\r\n * @param v any number\r\n * @return the greatest common divisor, never negative\r\n * @throws ArithmeticException\r\n *             if the result cannot be represented as a nonnegative int\r\n *             value\r\n * @since 1.1\r\n *\/\r\n","code_no_comment":"public static int gcd(final int p, final int q) {\r\n    int u = p;\r\n    int v = q;\r\n    if ((u == 0) || (v == 0)) {\r\n        return (Math.abs(u) + Math.abs(v));\r\n    }\r\n        if (u > 0) {\r\n        u = -u;\r\n    }\r\n        if (v > 0) {\r\n        v = -v;\r\n    }\r\n            int k = 0;\r\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\r\n                        u \/= 2;\r\n        v \/= 2;\r\n                k++;\r\n    }\r\n    if (k == 31) {\r\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\r\n    }\r\n            int t = ((u & 1) == 1) ? v : -(u \/ 2);\r\n        do {\r\n                while ((t & 1) == 0) {\r\n                                    t \/= 2;\r\n        }\r\n                if (t > 0) {\r\n            u = -t;\r\n        } else {\r\n            v = t;\r\n        }\r\n                t = (v - u) \/ 2;\r\n            } while (t != 0);\r\n        return -u * (1 << k);\r\n}","lc":0.9545454545,"pi":-0.028708134,"ma":1.4,"nbd":0.0,"ml":0.9166666667,"d":5.5,"mi":-0.6549682875,"fo":-0.25,"r":-0.0263157895,"e":8.0167286181}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2439_beaca1a4","label":1,"code":"private IndexPlan.Builder getPlanBuilder() {\r\n    log.trace(\"Evaluating plan with index definition {}\", defn);\r\n    FullTextExpression ft = filter.getFullTextConstraint();\r\n    if (!defn.getVersion().isAtLeast(IndexFormatVersion.V2)) {\r\n        log.trace(\"Index is old format. Not supported\");\r\n        return null;\r\n    }\r\n    \/\/ Query Fulltext and Index does not support fulltext\r\n    if (ft != null && !defn.isFullTextEnabled()) {\r\n        return null;\r\n    }\r\n    IndexingRule indexingRule = getApplicableRule();\r\n    if (indexingRule == null) {\r\n        return null;\r\n    }\r\n    \/\/ Query Fulltext and indexing rule does not support fulltext\r\n    if (ft != null && !indexingRule.isFulltextEnabled()) {\r\n        return null;\r\n    }\r\n    result = new PlanResult(indexPath, defn, indexingRule);\r\n    if (defn.hasFunctionDefined() && filter.getPropertyRestriction(defn.getFunctionName()) != null) {\r\n        \/\/ that lowest cost if returned\r\n        return defaultPlan().setEstimatedEntryCount(1);\r\n    }\r\n    List<String> indexedProps = newArrayListWithCapacity(filter.getPropertyRestrictions().size());\r\n    \/\/ for property index\r\n    if (indexingRule.propertyIndexEnabled) {\r\n        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\r\n            PropertyDefinition pd = indexingRule.getConfig(pr.propertyName);\r\n            if (pd != null && pd.propertyIndexEnabled()) {\r\n                indexedProps.add(pr.propertyName);\r\n                result.propDefns.put(pr.propertyName, pd);\r\n            }\r\n        }\r\n    }\r\n    boolean evalPathRestrictions = canEvalPathRestrictions(indexingRule);\r\n    boolean canEvalAlFullText = canEvalAllFullText(indexingRule, ft);\r\n    if (ft != null && !canEvalAlFullText) {\r\n        return null;\r\n    }\r\n    \/\/ Fulltext expression can also be like jcr:contains(jcr:content\/metadata\/@format, 'image')\r\n    List<OrderEntry> sortOrder = createSortOrder(indexingRule);\r\n    if (!indexedProps.isEmpty() || !sortOrder.isEmpty() || ft != null || evalPathRestrictions) {\r\n        \/\/ TODO Need a way to have better cost estimate to indicate that\r\n        \/\/ this index can evaluate more propertyRestrictions natively (if more props are indexed)\r\n        \/\/ For now we reduce cost per entry\r\n        int costPerEntryFactor = indexedProps.size();\r\n        costPerEntryFactor += sortOrder.size();\r\n        \/\/ this index can evaluate more propertyRestrictions natively (if more props are indexed)\r\n        \/\/ For now we reduce cost per entry\r\n        IndexPlan.Builder plan = defaultPlan();\r\n        if (!sortOrder.isEmpty()) {\r\n            plan.setSortOrder(sortOrder);\r\n        }\r\n        if (costPerEntryFactor == 0) {\r\n            costPerEntryFactor = 1;\r\n        }\r\n        if (ft == null) {\r\n            result.enableNonFullTextConstraints();\r\n        }\r\n        return plan.setCostPerEntry(defn.getCostPerEntry() \/ costPerEntryFactor);\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"private IndexPlan.Builder getPlanBuilder() {\r\n    log.trace(\"Evaluating plan with index definition {}\", defn);\r\n    FullTextExpression ft = filter.getFullTextConstraint();\r\n    if (!defn.getVersion().isAtLeast(IndexFormatVersion.V2)) {\r\n        log.trace(\"Index is old format. Not supported\");\r\n        return null;\r\n    }\r\n        if (ft != null && !defn.isFullTextEnabled()) {\r\n        return null;\r\n    }\r\n    IndexingRule indexingRule = getApplicableRule();\r\n    if (indexingRule == null) {\r\n        return null;\r\n    }\r\n        if (ft != null && !indexingRule.isFulltextEnabled()) {\r\n        return null;\r\n    }\r\n    result = new PlanResult(indexPath, defn, indexingRule);\r\n    if (defn.hasFunctionDefined() && filter.getPropertyRestriction(defn.getFunctionName()) != null) {\r\n                return defaultPlan().setEstimatedEntryCount(1);\r\n    }\r\n    List<String> indexedProps = newArrayListWithCapacity(filter.getPropertyRestrictions().size());\r\n        if (indexingRule.propertyIndexEnabled) {\r\n        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\r\n            PropertyDefinition pd = indexingRule.getConfig(pr.propertyName);\r\n            if (pd != null && pd.propertyIndexEnabled()) {\r\n                indexedProps.add(pr.propertyName);\r\n                result.propDefns.put(pr.propertyName, pd);\r\n            }\r\n        }\r\n    }\r\n    boolean evalPathRestrictions = canEvalPathRestrictions(indexingRule);\r\n    boolean canEvalAlFullText = canEvalAllFullText(indexingRule, ft);\r\n    if (ft != null && !canEvalAlFullText) {\r\n        return null;\r\n    }\r\n        List<OrderEntry> sortOrder = createSortOrder(indexingRule);\r\n    if (!indexedProps.isEmpty() || !sortOrder.isEmpty() || ft != null || evalPathRestrictions) {\r\n                                int costPerEntryFactor = indexedProps.size();\r\n        costPerEntryFactor += sortOrder.size();\r\n                        IndexPlan.Builder plan = defaultPlan();\r\n        if (!sortOrder.isEmpty()) {\r\n            plan.setSortOrder(sortOrder);\r\n        }\r\n        if (costPerEntryFactor == 0) {\r\n            costPerEntryFactor = 1;\r\n        }\r\n        if (ft == null) {\r\n            result.enableNonFullTextConstraints();\r\n        }\r\n        return plan.setCostPerEntry(defn.getCostPerEntry() \/ costPerEntryFactor);\r\n    }\r\n    return null;\r\n}","lc":1.8181818182,"pi":0.2248803828,"ma":2.0,"nbd":0.5,"ml":2.5833333333,"d":1.3611111111,"mi":-0.9563072586,"fo":2.3333333333,"r":-0.0263157895,"e":4.1037533929}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4072_7d5b8645","label":1,"code":"\/**\r\n *  Parses the given URL string.\r\n *\r\n *  @param url\r\n *            absolute or relative url with query string\r\n *  @param charset\r\n *  @return Url object\r\n *\/\r\npublic static Url parse(String url, Charset charset) {\r\n    Args.notNull(url, \"url\");\r\n    final Url result = new Url(charset);\r\n    \/\/ the url object resolved the charset, use that\r\n    charset = result.getCharset();\r\n    \/\/ extract query string part\r\n    final String queryString;\r\n    final String absoluteUrl;\r\n    final int queryAt = url.indexOf('?');\r\n    if (queryAt == -1) {\r\n        queryString = \"\";\r\n        absoluteUrl = url;\r\n    } else {\r\n        absoluteUrl = url.substring(0, queryAt);\r\n        queryString = url.substring(queryAt + 1);\r\n    }\r\n    \/\/ get absolute \/ relative part of url\r\n    String relativeUrl;\r\n    \/\/ absolute urls contain a scheme:\/\/\r\n    final int protocolAt = absoluteUrl.indexOf(\":\/\/\");\r\n    if (protocolAt != -1) {\r\n        result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\r\n        final String afterProto = absoluteUrl.substring(protocolAt + 3);\r\n        final String hostAndPort;\r\n        final int relativeAt = afterProto.indexOf('\/');\r\n        if (relativeAt == -1) {\r\n            relativeUrl = \"\";\r\n            hostAndPort = afterProto;\r\n        } else {\r\n            relativeUrl = afterProto.substring(relativeAt);\r\n            hostAndPort = afterProto.substring(0, relativeAt);\r\n        }\r\n        final int portAt = hostAndPort.lastIndexOf(':');\r\n        if (portAt == -1) {\r\n            result.host = hostAndPort;\r\n            result.port = getDefaultPortForProtocol(result.protocol);\r\n        } else {\r\n            result.host = hostAndPort.substring(0, portAt);\r\n            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\r\n        }\r\n    } else {\r\n        relativeUrl = absoluteUrl;\r\n    }\r\n    if (relativeUrl.length() > 0) {\r\n        boolean removeLast = false;\r\n        if (relativeUrl.endsWith(\"\/\")) {\r\n            \/\/ we need to append something and remove it after splitting\r\n            \/\/ because otherwise the\r\n            \/\/ trailing slashes will be lost\r\n            relativeUrl += \"\/x\";\r\n            removeLast = true;\r\n        }\r\n        String[] segmentArray = Strings.split(relativeUrl, '\/');\r\n        if (removeLast) {\r\n            segmentArray[segmentArray.length - 1] = null;\r\n        }\r\n        for (String s : segmentArray) {\r\n            if (s != null) {\r\n                result.segments.add(decodeSegment(s, charset));\r\n            }\r\n        }\r\n    }\r\n    if (queryString.length() > 0) {\r\n        String[] queryArray = Strings.split(queryString, '&');\r\n        for (String s : queryArray) {\r\n            result.parameters.add(parseQueryParameter(s, charset));\r\n        }\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n *  Parses the given URL string.\r\n *\r\n *  @param url\r\n *            absolute or relative url with query string\r\n *  @param charset\r\n *  @return Url object\r\n *\/\r\n","code_no_comment":"public static Url parse(String url, Charset charset) {\r\n    Args.notNull(url, \"url\");\r\n    final Url result = new Url(charset);\r\n        charset = result.getCharset();\r\n        final String queryString;\r\n    final String absoluteUrl;\r\n    final int queryAt = url.indexOf('?');\r\n    if (queryAt == -1) {\r\n        queryString = \"\";\r\n        absoluteUrl = url;\r\n    } else {\r\n        absoluteUrl = url.substring(0, queryAt);\r\n        queryString = url.substring(queryAt + 1);\r\n    }\r\n        String relativeUrl;\r\n        final int protocolAt = absoluteUrl.indexOf(\":\/\/\");\r\n    if (protocolAt != -1) {\r\n        result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\r\n        final String afterProto = absoluteUrl.substring(protocolAt + 3);\r\n        final String hostAndPort;\r\n        final int relativeAt = afterProto.indexOf('\/');\r\n        if (relativeAt == -1) {\r\n            relativeUrl = \"\";\r\n            hostAndPort = afterProto;\r\n        } else {\r\n            relativeUrl = afterProto.substring(relativeAt);\r\n            hostAndPort = afterProto.substring(0, relativeAt);\r\n        }\r\n        final int portAt = hostAndPort.lastIndexOf(':');\r\n        if (portAt == -1) {\r\n            result.host = hostAndPort;\r\n            result.port = getDefaultPortForProtocol(result.protocol);\r\n        } else {\r\n            result.host = hostAndPort.substring(0, portAt);\r\n            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\r\n        }\r\n    } else {\r\n        relativeUrl = absoluteUrl;\r\n    }\r\n    if (relativeUrl.length() > 0) {\r\n        boolean removeLast = false;\r\n        if (relativeUrl.endsWith(\"\/\")) {\r\n                                                relativeUrl += \"\/x\";\r\n            removeLast = true;\r\n        }\r\n        String[] segmentArray = Strings.split(relativeUrl, '\/');\r\n        if (removeLast) {\r\n            segmentArray[segmentArray.length - 1] = null;\r\n        }\r\n        for (String s : segmentArray) {\r\n            if (s != null) {\r\n                result.segments.add(decodeSegment(s, charset));\r\n            }\r\n        }\r\n    }\r\n    if (queryString.length() > 0) {\r\n        String[] queryArray = Strings.split(queryString, '&');\r\n        for (String s : queryArray) {\r\n            result.parameters.add(parseQueryParameter(s, charset));\r\n        }\r\n    }\r\n    return result;\r\n}","lc":2.2272727273,"pi":0.1722488038,"ma":1.6,"nbd":0.5,"ml":1.0833333333,"d":1.378968254,"mi":-1.0405919662,"fo":1.6666666667,"r":-0.0263157895,"e":5.0130138368}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"@Nonnull\r\nstatic TreeImpl createRoot(final RootImpl root) {\r\n    return new TreeImpl(root, null, \"\") {\r\n\r\n        @Override\r\n        protected NodeState getBaseState() {\r\n            return root.getBaseState();\r\n        }\r\n\r\n        @Override\r\n        protected synchronized NodeBuilder getNodeBuilder() {\r\n            if (nodeBuilder == null) {\r\n                nodeBuilder = root.createRootBuilder();\r\n            }\r\n            return nodeBuilder;\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\nstatic TreeImpl createRoot(final RootImpl root) {\r\n    return new TreeImpl(root, null, \"\") {\r\n\r\n        @Override\r\n        protected NodeState getBaseState() {\r\n            return root.getBaseState();\r\n        }\r\n\r\n        @Override\r\n        protected synchronized NodeBuilder getNodeBuilder() {\r\n            if (nodeBuilder == null) {\r\n                nodeBuilder = root.createRootBuilder();\r\n            }\r\n            return nodeBuilder;\r\n        }\r\n    };\r\n}","lc":0.0909090909,"pi":0.7990430622,"ma":-0.4,"nbd":0.0,"ml":-0.25,"d":-0.0476190476,"mi":0.0145172657,"fo":-0.3333333333,"r":0.6578947368,"e":-0.0843991863}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-47_b62f1c26","label":1,"code":"private String doCommit(String rootPath, JsopReader t, String revisionId, String message) {\r\n    long oldRevision = headRevId, rev = headRevId + 1;\r\n    NodeImpl root = nodeMap.getRootId().getNode(nodeMap);\r\n    NodeImpl head = root.getNode(\"head\"), oldHead = head;\r\n    NodeImpl data = head.getNode(\"data\");\r\n    JsopWriter diff = new JsopStream();\r\n    while (true) {\r\n        int r = t.read();\r\n        if (r == JsopTokenizer.END) {\r\n            break;\r\n        }\r\n        String path = PathUtils.concat(rootPath, t.readString());\r\n        String from = PathUtils.relativize(\"\/\", path);\r\n        switch(r) {\r\n            case '+':\r\n                t.read(':');\r\n                diff.tag('+').key(path);\r\n                if (t.matches('{')) {\r\n                    NodeImpl n = NodeImpl.parse(nodeMap, t, rev);\r\n                    data = data.cloneAndAddChildNode(from, false, null, n, rev);\r\n                    n.append(diff, Integer.MAX_VALUE, 0, Integer.MAX_VALUE, false);\r\n                } else {\r\n                    String value = t.readRawValue().trim();\r\n                    String nodeName = PathUtils.getParentPath(from);\r\n                    String propertyName = PathUtils.getName(from);\r\n                    if (data.getNode(nodeName).hasProperty(propertyName)) {\r\n                        throw ExceptionFactory.get(\"Property already exists: \" + propertyName);\r\n                    }\r\n                    data = data.cloneAndSetProperty(from, value, rev);\r\n                    diff.encodedValue(value);\r\n                }\r\n                diff.newline();\r\n                break;\r\n            case '-':\r\n                diff.tag('-').value(path).newline();\r\n                if (data.exists(from) || !getRevisionDataRoot(revisionId).exists(from)) {\r\n                    \/\/ this will fail if the node didn't exist\r\n                    data = data.cloneAndRemoveChildNode(from, rev);\r\n                }\r\n                break;\r\n            case '^':\r\n                t.read(':');\r\n                boolean isConfigChange = from.startsWith(\":root\/head\/config\/\");\r\n                String value;\r\n                if (t.matches(JsopTokenizer.NULL)) {\r\n                    value = null;\r\n                    diff.tag('^').key(path).value(null);\r\n                } else {\r\n                    value = t.readRawValue().trim();\r\n                    String nodeName = PathUtils.getParentPath(from);\r\n                    String propertyName = PathUtils.getName(from);\r\n                    if (isConfigChange || data.getNode(nodeName).hasProperty(propertyName)) {\r\n                        diff.tag('^');\r\n                    } else {\r\n                        diff.tag('+');\r\n                    }\r\n                    diff.key(path).encodedValue(value);\r\n                }\r\n                if (isConfigChange) {\r\n                    String p = PathUtils.relativize(\":root\/head\", from);\r\n                    if (!head.exists(\"config\")) {\r\n                        head = head.setChild(\"config\", new NodeImpl(nodeMap, rev), rev);\r\n                    }\r\n                    head = head.cloneAndSetProperty(p, value, rev);\r\n                    applyConfig(head);\r\n                } else {\r\n                    data = data.cloneAndSetProperty(from, value, rev);\r\n                }\r\n                diff.newline();\r\n                break;\r\n            case '>':\r\n                {\r\n                    t.read(':');\r\n                    diff.tag('>').key(path);\r\n                    String name = PathUtils.getName(from);\r\n                    String position, target, to;\r\n                    boolean rename;\r\n                    if (t.matches('{')) {\r\n                        rename = false;\r\n                        position = t.readString();\r\n                        t.read(':');\r\n                        target = t.readString();\r\n                        t.read('}');\r\n                        diff.object().key(position);\r\n                        if (!PathUtils.isAbsolute(target)) {\r\n                            target = PathUtils.concat(rootPath, target);\r\n                        }\r\n                        diff.value(target).endObject();\r\n                    } else {\r\n                        rename = true;\r\n                        position = null;\r\n                        target = t.readString();\r\n                        if (!PathUtils.isAbsolute(target)) {\r\n                            target = PathUtils.concat(rootPath, target);\r\n                        }\r\n                        diff.value(target);\r\n                    }\r\n                    diff.newline();\r\n                    boolean before = false;\r\n                    if (\"last\".equals(position)) {\r\n                        target = PathUtils.concat(target, name);\r\n                        position = null;\r\n                    } else if (\"first\".equals(position)) {\r\n                        target = PathUtils.concat(target, name);\r\n                        position = null;\r\n                        before = true;\r\n                    } else if (\"before\".equals(position)) {\r\n                        position = PathUtils.getName(target);\r\n                        target = PathUtils.getParentPath(target);\r\n                        target = PathUtils.concat(target, name);\r\n                        before = true;\r\n                    } else if (\"after\".equals(position)) {\r\n                        position = PathUtils.getName(target);\r\n                        target = PathUtils.getParentPath(target);\r\n                        target = PathUtils.concat(target, name);\r\n                    } else if (position == null) {\r\n                    \/\/ move\r\n                    } else {\r\n                        throw ExceptionFactory.get(\"position: \" + position);\r\n                    }\r\n                    to = PathUtils.relativize(\"\/\", target);\r\n                    boolean inPlaceRename = false;\r\n                    if (rename) {\r\n                        if (PathUtils.getParentPath(from).equals(PathUtils.getParentPath(to))) {\r\n                            inPlaceRename = true;\r\n                            position = PathUtils.getName(from);\r\n                        }\r\n                    }\r\n                    NodeImpl node = data.getNode(from);\r\n                    if (!inPlaceRename) {\r\n                        data = data.cloneAndRemoveChildNode(from, rev);\r\n                    }\r\n                    data = data.cloneAndAddChildNode(to, before, position, node, rev);\r\n                    if (inPlaceRename) {\r\n                        data = data.cloneAndRemoveChildNode(from, rev);\r\n                    }\r\n                    break;\r\n                }\r\n            case '*':\r\n                {\r\n                    \/\/ TODO is it really required?\r\n                    \/\/ TODO possibly support target position notation\r\n                    \/\/ TODO support copy in wrappers, index,...\r\n                    t.read(':');\r\n                    String target = t.readString();\r\n                    diff.tag('*').key(path).value(target);\r\n                    if (!PathUtils.isAbsolute(target)) {\r\n                        target = PathUtils.concat(rootPath, target);\r\n                    }\r\n                    NodeImpl node = data.getNode(from);\r\n                    String to = PathUtils.relativize(\"\/\", target);\r\n                    data = data.cloneAndAddChildNode(to, false, null, node, rev);\r\n                    break;\r\n                }\r\n            default:\r\n                throw ExceptionFactory.get(\"token: \" + (char) t.getTokenType());\r\n        }\r\n    }\r\n    head = head.setChild(\"data\", data, rev);\r\n    Revision revNode = new Revision(rev, clock.nanoTime(), diff.toString(), message);\r\n    revisionCache.put(rev, revNode);\r\n    head = revNode.store(head, new NodeImpl(nodeMap, rev));\r\n    root = root.setChild(\"head\", head, rev);\r\n    String old = Revision.formatId(oldRevision);\r\n    NodeImpl oldRev = new NodeImpl(nodeMap, rev);\r\n    oldRev.addChildNode(\"head\", oldHead);\r\n    String lastRev = Revision.formatId(oldRevision - 1);\r\n    if (root.exists(lastRev)) {\r\n        NodeImpl lastRevNode = root.getNode(lastRev);\r\n        root = root.cloneAndRemoveChildNode(lastRev, rev);\r\n        oldRev.setChild(lastRev, lastRevNode, rev);\r\n        if (oldRevision % REV_SKIP_OFFSET == 0) {\r\n            long skip = oldRevision - REV_SKIP_OFFSET;\r\n            NodeImpl n = getRevisionNode(getRoot(), skip, skip);\r\n            if (n != null) {\r\n                oldRev.setChild(Revision.formatId(skip), n, rev);\r\n            \/\/ TODO remove old link to reduce descendant count\r\n            }\r\n        }\r\n    }\r\n    root = root.setChild(old, oldRev, rev);\r\n    nodeMap.commit(root);\r\n    headRevId = rev;\r\n    headRevision = Revision.formatId(rev);\r\n    gate.commit(headRevision);\r\n    return headRevision;\r\n}","code_comment":null,"code_no_comment":"private String doCommit(String rootPath, JsopReader t, String revisionId, String message) {\r\n    long oldRevision = headRevId, rev = headRevId + 1;\r\n    NodeImpl root = nodeMap.getRootId().getNode(nodeMap);\r\n    NodeImpl head = root.getNode(\"head\"), oldHead = head;\r\n    NodeImpl data = head.getNode(\"data\");\r\n    JsopWriter diff = new JsopStream();\r\n    while (true) {\r\n        int r = t.read();\r\n        if (r == JsopTokenizer.END) {\r\n            break;\r\n        }\r\n        String path = PathUtils.concat(rootPath, t.readString());\r\n        String from = PathUtils.relativize(\"\/\", path);\r\n        switch(r) {\r\n            case '+':\r\n                t.read(':');\r\n                diff.tag('+').key(path);\r\n                if (t.matches('{')) {\r\n                    NodeImpl n = NodeImpl.parse(nodeMap, t, rev);\r\n                    data = data.cloneAndAddChildNode(from, false, null, n, rev);\r\n                    n.append(diff, Integer.MAX_VALUE, 0, Integer.MAX_VALUE, false);\r\n                } else {\r\n                    String value = t.readRawValue().trim();\r\n                    String nodeName = PathUtils.getParentPath(from);\r\n                    String propertyName = PathUtils.getName(from);\r\n                    if (data.getNode(nodeName).hasProperty(propertyName)) {\r\n                        throw ExceptionFactory.get(\"Property already exists: \" + propertyName);\r\n                    }\r\n                    data = data.cloneAndSetProperty(from, value, rev);\r\n                    diff.encodedValue(value);\r\n                }\r\n                diff.newline();\r\n                break;\r\n            case '-':\r\n                diff.tag('-').value(path).newline();\r\n                if (data.exists(from) || !getRevisionDataRoot(revisionId).exists(from)) {\r\n                                        data = data.cloneAndRemoveChildNode(from, rev);\r\n                }\r\n                break;\r\n            case '^':\r\n                t.read(':');\r\n                boolean isConfigChange = from.startsWith(\":root\/head\/config\/\");\r\n                String value;\r\n                if (t.matches(JsopTokenizer.NULL)) {\r\n                    value = null;\r\n                    diff.tag('^').key(path).value(null);\r\n                } else {\r\n                    value = t.readRawValue().trim();\r\n                    String nodeName = PathUtils.getParentPath(from);\r\n                    String propertyName = PathUtils.getName(from);\r\n                    if (isConfigChange || data.getNode(nodeName).hasProperty(propertyName)) {\r\n                        diff.tag('^');\r\n                    } else {\r\n                        diff.tag('+');\r\n                    }\r\n                    diff.key(path).encodedValue(value);\r\n                }\r\n                if (isConfigChange) {\r\n                    String p = PathUtils.relativize(\":root\/head\", from);\r\n                    if (!head.exists(\"config\")) {\r\n                        head = head.setChild(\"config\", new NodeImpl(nodeMap, rev), rev);\r\n                    }\r\n                    head = head.cloneAndSetProperty(p, value, rev);\r\n                    applyConfig(head);\r\n                } else {\r\n                    data = data.cloneAndSetProperty(from, value, rev);\r\n                }\r\n                diff.newline();\r\n                break;\r\n            case '>':\r\n                {\r\n                    t.read(':');\r\n                    diff.tag('>').key(path);\r\n                    String name = PathUtils.getName(from);\r\n                    String position, target, to;\r\n                    boolean rename;\r\n                    if (t.matches('{')) {\r\n                        rename = false;\r\n                        position = t.readString();\r\n                        t.read(':');\r\n                        target = t.readString();\r\n                        t.read('}');\r\n                        diff.object().key(position);\r\n                        if (!PathUtils.isAbsolute(target)) {\r\n                            target = PathUtils.concat(rootPath, target);\r\n                        }\r\n                        diff.value(target).endObject();\r\n                    } else {\r\n                        rename = true;\r\n                        position = null;\r\n                        target = t.readString();\r\n                        if (!PathUtils.isAbsolute(target)) {\r\n                            target = PathUtils.concat(rootPath, target);\r\n                        }\r\n                        diff.value(target);\r\n                    }\r\n                    diff.newline();\r\n                    boolean before = false;\r\n                    if (\"last\".equals(position)) {\r\n                        target = PathUtils.concat(target, name);\r\n                        position = null;\r\n                    } else if (\"first\".equals(position)) {\r\n                        target = PathUtils.concat(target, name);\r\n                        position = null;\r\n                        before = true;\r\n                    } else if (\"before\".equals(position)) {\r\n                        position = PathUtils.getName(target);\r\n                        target = PathUtils.getParentPath(target);\r\n                        target = PathUtils.concat(target, name);\r\n                        before = true;\r\n                    } else if (\"after\".equals(position)) {\r\n                        position = PathUtils.getName(target);\r\n                        target = PathUtils.getParentPath(target);\r\n                        target = PathUtils.concat(target, name);\r\n                    } else if (position == null) {\r\n                                        } else {\r\n                        throw ExceptionFactory.get(\"position: \" + position);\r\n                    }\r\n                    to = PathUtils.relativize(\"\/\", target);\r\n                    boolean inPlaceRename = false;\r\n                    if (rename) {\r\n                        if (PathUtils.getParentPath(from).equals(PathUtils.getParentPath(to))) {\r\n                            inPlaceRename = true;\r\n                            position = PathUtils.getName(from);\r\n                        }\r\n                    }\r\n                    NodeImpl node = data.getNode(from);\r\n                    if (!inPlaceRename) {\r\n                        data = data.cloneAndRemoveChildNode(from, rev);\r\n                    }\r\n                    data = data.cloneAndAddChildNode(to, before, position, node, rev);\r\n                    if (inPlaceRename) {\r\n                        data = data.cloneAndRemoveChildNode(from, rev);\r\n                    }\r\n                    break;\r\n                }\r\n            case '*':\r\n                {\r\n                                                                                t.read(':');\r\n                    String target = t.readString();\r\n                    diff.tag('*').key(path).value(target);\r\n                    if (!PathUtils.isAbsolute(target)) {\r\n                        target = PathUtils.concat(rootPath, target);\r\n                    }\r\n                    NodeImpl node = data.getNode(from);\r\n                    String to = PathUtils.relativize(\"\/\", target);\r\n                    data = data.cloneAndAddChildNode(to, false, null, node, rev);\r\n                    break;\r\n                }\r\n            default:\r\n                throw ExceptionFactory.get(\"token: \" + (char) t.getTokenType());\r\n        }\r\n    }\r\n    head = head.setChild(\"data\", data, rev);\r\n    Revision revNode = new Revision(rev, clock.nanoTime(), diff.toString(), message);\r\n    revisionCache.put(rev, revNode);\r\n    head = revNode.store(head, new NodeImpl(nodeMap, rev));\r\n    root = root.setChild(\"head\", head, rev);\r\n    String old = Revision.formatId(oldRevision);\r\n    NodeImpl oldRev = new NodeImpl(nodeMap, rev);\r\n    oldRev.addChildNode(\"head\", oldHead);\r\n    String lastRev = Revision.formatId(oldRevision - 1);\r\n    if (root.exists(lastRev)) {\r\n        NodeImpl lastRevNode = root.getNode(lastRev);\r\n        root = root.cloneAndRemoveChildNode(lastRev, rev);\r\n        oldRev.setChild(lastRev, lastRevNode, rev);\r\n        if (oldRevision % REV_SKIP_OFFSET == 0) {\r\n            long skip = oldRevision - REV_SKIP_OFFSET;\r\n            NodeImpl n = getRevisionNode(getRoot(), skip, skip);\r\n            if (n != null) {\r\n                oldRev.setChild(Revision.formatId(skip), n, rev);\r\n                        }\r\n        }\r\n    }\r\n    root = root.setChild(old, oldRev, rev);\r\n    nodeMap.commit(root);\r\n    headRevId = rev;\r\n    headRevision = Revision.formatId(rev);\r\n    gate.commit(headRevision);\r\n    return headRevision;\r\n}","lc":7.5909090909,"pi":1.8995215311,"ma":7.4,"nbd":3.0,"ml":4.4166666667,"d":3.4384920635,"mi":-1.9009161381,"fo":10.3333333333,"r":-0.0263157895,"e":41.2184644111}
{"project_name":"Closure","project_version":"60","label":2,"code":"\/**\r\n * Gets the boolean value of a node that represents a literal. This method\r\n * effectively emulates the <code>Boolean()<\/code> JavaScript cast function\r\n * except it return UNKNOWN for known values with side-effects, use\r\n * getExpressionBooleanValue if you don't care about side-effects.\r\n *\/\r\nstatic TernaryValue getPureBooleanValue(Node n) {\r\n    switch(n.getType()) {\r\n        case Token.STRING:\r\n            return TernaryValue.forBoolean(n.getString().length() > 0);\r\n        case Token.NUMBER:\r\n            return TernaryValue.forBoolean(n.getDouble() != 0);\r\n        case Token.NOT:\r\n            return getPureBooleanValue(n.getLastChild()).not();\r\n        case Token.NULL:\r\n        case Token.FALSE:\r\n            return TernaryValue.FALSE;\r\n        case Token.VOID:\r\n            return TernaryValue.FALSE;\r\n        case Token.NAME:\r\n            String name = n.getString();\r\n            if (\"undefined\".equals(name) || \"NaN\".equals(name)) {\r\n                \/\/ undefined to something other than the value undefined.\r\n                return TernaryValue.FALSE;\r\n            } else if (\"Infinity\".equals(name)) {\r\n                return TernaryValue.TRUE;\r\n            }\r\n            break;\r\n        case Token.TRUE:\r\n        case Token.REGEXP:\r\n            return TernaryValue.TRUE;\r\n        case Token.ARRAYLIT:\r\n        case Token.OBJECTLIT:\r\n            if (!mayHaveSideEffects(n)) {\r\n                return TernaryValue.TRUE;\r\n            }\r\n            break;\r\n    }\r\n    return TernaryValue.UNKNOWN;\r\n}","code_comment":"\/**\r\n * Gets the boolean value of a node that represents a literal. This method\r\n * effectively emulates the <code>Boolean()<\/code> JavaScript cast function\r\n * except it return UNKNOWN for known values with side-effects, use\r\n * getExpressionBooleanValue if you don't care about side-effects.\r\n *\/\r\n","code_no_comment":"static TernaryValue getPureBooleanValue(Node n) {\r\n    switch(n.getType()) {\r\n        case Token.STRING:\r\n            return TernaryValue.forBoolean(n.getString().length() > 0);\r\n        case Token.NUMBER:\r\n            return TernaryValue.forBoolean(n.getDouble() != 0);\r\n        case Token.NOT:\r\n            return getPureBooleanValue(n.getLastChild()).not();\r\n        case Token.NULL:\r\n        case Token.FALSE:\r\n            return TernaryValue.FALSE;\r\n        case Token.VOID:\r\n            return TernaryValue.FALSE;\r\n        case Token.NAME:\r\n            String name = n.getString();\r\n            if (\"undefined\".equals(name) || \"NaN\".equals(name)) {\r\n                                return TernaryValue.FALSE;\r\n            } else if (\"Infinity\".equals(name)) {\r\n                return TernaryValue.TRUE;\r\n            }\r\n            break;\r\n        case Token.TRUE:\r\n        case Token.REGEXP:\r\n            return TernaryValue.TRUE;\r\n        case Token.ARRAYLIT:\r\n        case Token.OBJECTLIT:\r\n            if (!mayHaveSideEffects(n)) {\r\n                return TernaryValue.TRUE;\r\n            }\r\n            break;\r\n    }\r\n    return TernaryValue.UNKNOWN;\r\n}","lc":0.8636363636,"pi":0.4497607656,"ma":2.6,"nbd":1.0,"ml":1.4166666667,"d":0.5119047619,"mi":-0.6109936575,"fo":0.6666666667,"r":-0.0263157895,"e":0.6721437504}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1261_4c4b3e2e","label":3,"code":"\/**\r\n * Divide the fraction by an integer.\r\n * @param i the {@code integer} to divide by.\r\n * @return this * i\r\n *\/\r\npublic Fraction divide(final int i) {\r\n    return new Fraction(numerator, denominator * i);\r\n}","code_comment":"\/**\r\n * Divide the fraction by an integer.\r\n * @param i the {@code integer} to divide by.\r\n * @return this * i\r\n *\/\r\n","code_no_comment":"public Fraction divide(final int i) {\r\n    return new Fraction(numerator, denominator * i);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9960535588,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4353_b0014b7d","label":1,"code":"\/**\r\n * Regenerates a tar file from a list of entries.\r\n *\r\n * @param entries\r\n * @param file\r\n * @throws IOException\r\n *\/\r\nprivate static void generateTarFile(LinkedHashMap<UUID, byte[]> entries, File file) throws IOException {\r\n    log.info(\"Regenerating tar file {}\", file);\r\n    TarWriter writer = new TarWriter(file);\r\n    for (Map.Entry<UUID, byte[]> entry : entries.entrySet()) {\r\n        UUID uuid = entry.getKey();\r\n        byte[] data = entry.getValue();\r\n        int generation = getGcGen(wrap(data));\r\n        writer.writeEntry(uuid.getMostSignificantBits(), uuid.getLeastSignificantBits(), data, 0, data.length, generation);\r\n    }\r\n    writer.close();\r\n}","code_comment":"\/**\r\n * Regenerates a tar file from a list of entries.\r\n *\r\n * @param entries\r\n * @param file\r\n * @throws IOException\r\n *\/\r\n","code_no_comment":"private static void generateTarFile(LinkedHashMap<UUID, byte[]> entries, File file) throws IOException {\r\n    log.info(\"Regenerating tar file {}\", file);\r\n    TarWriter writer = new TarWriter(file);\r\n    for (Map.Entry<UUID, byte[]> entry : entries.entrySet()) {\r\n        UUID uuid = entry.getKey();\r\n        byte[] data = entry.getValue();\r\n        int generation = getGcGen(wrap(data));\r\n        writer.writeEntry(uuid.getMostSignificantBits(), uuid.getLeastSignificantBits(), data, 0, data.length, generation);\r\n    }\r\n    writer.close();\r\n}","lc":-0.1363636364,"pi":-0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.0615926709,"fo":0.3333333333,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6723_b92d6237","label":1,"code":"private static Map<String, Object> safeCopy(Map<String, Object> properties) {\r\n    if (properties == null) {\r\n        return null;\r\n    }\r\n    return new ConcurrentHashMap<String, Object>(properties);\r\n}","code_comment":null,"code_no_comment":"private static Map<String, Object> safeCopy(Map<String, Object> properties) {\r\n    if (properties == null) {\r\n        return null;\r\n    }\r\n    return new ConcurrentHashMap<String, Object>(properties);\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.5619450317,"fo":-0.5,"r":0.1052631579,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4572_dfc56674","label":0,"code":"\/**\r\n *  Merges the window with given index with the next window. The resulting window will have size\r\n *  of the two windows summed together.\r\n *\r\n *  @param index\r\n *\/\r\nprivate void mergeWindowWithNext(int index) {\r\n    if (index < windows.size() - 1) {\r\n        PageWindowInternal window = windows.get(index);\r\n        PageWindowInternal next = windows.get(index + 1);\r\n        window.filePartSize += next.filePartSize;\r\n        windows.remove(index + 1);\r\n        \/\/ reset index\r\n        idToWindowIndex = null;\r\n    }\r\n}","code_comment":"\/**\r\n *  Merges the window with given index with the next window. The resulting window will have size\r\n *  of the two windows summed together.\r\n *\r\n *  @param index\r\n *\/\r\n","code_no_comment":"private void mergeWindowWithNext(int index) {\r\n    if (index < windows.size() - 1) {\r\n        PageWindowInternal window = windows.get(index);\r\n        PageWindowInternal next = windows.get(index + 1);\r\n        window.filePartSize += next.filePartSize;\r\n        windows.remove(index + 1);\r\n                idToWindowIndex = null;\r\n    }\r\n}","lc":-0.2272727273,"pi":0.1339712919,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":0.4285714286,"mi":0.2239605356,"fo":-0.1666666667,"r":0.9736842105,"e":0.1192210831}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4789_6f0863f4","label":0,"code":"\/**\r\n *  Makes this url the result of resolving the {@code relative} url against this url.\r\n *  <p>\r\n *  Segments will be properly resolved, handling any {@code ..} references, while the query\r\n *  parameters will be completely replaced with {@code relative}'s query parameters.\r\n *  <\/p>\r\n *  <p>\r\n *  For example:\r\n *\r\n *  <pre>\r\n *  wicket\/page\/render?foo=bar\r\n *  <\/pre>\r\n *\r\n *  resolved with\r\n *\r\n *  <pre>\r\n *  ..\/component\/render?a=b\r\n *  <\/pre>\r\n *\r\n *  will become\r\n *\r\n *  <pre>\r\n *  wicket\/component\/render?a=b\r\n *  <\/pre>\r\n *\r\n *  <\/p>\r\n *\r\n *  @param relative\r\n *             relative url\r\n *\/\r\npublic void resolveRelative(final Url relative) {\r\n    if (getSegments().size() > 0) {\r\n        \/\/ strip the first non-folder segment\r\n        getSegments().remove(getSegments().size() - 1);\r\n    }\r\n    \/\/ relative url\r\n    while (!relative.getSegments().isEmpty()) {\r\n        if (\".\".equals(relative.getSegments().get(0))) {\r\n            relative.getSegments().remove(0);\r\n        } else if (\"\".equals(relative.getSegments().get(0))) {\r\n            relative.getSegments().remove(0);\r\n        } else if (\"..\".equals(relative.getSegments().get(0))) {\r\n            relative.getSegments().remove(0);\r\n            if (getSegments().isEmpty() == false) {\r\n                getSegments().remove(getSegments().size() - 1);\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    \/\/ append the remaining relative segments\r\n    getSegments().addAll(relative.getSegments());\r\n    \/\/ replace query params with the ones from relative\r\n    parameters.clear();\r\n    parameters.addAll(relative.getQueryParameters());\r\n}","code_comment":"\/**\r\n *  Makes this url the result of resolving the {@code relative} url against this url.\r\n *  <p>\r\n *  Segments will be properly resolved, handling any {@code ..} references, while the query\r\n *  parameters will be completely replaced with {@code relative}'s query parameters.\r\n *  <\/p>\r\n *  <p>\r\n *  For example:\r\n *\r\n *  <pre>\r\n *  wicket\/page\/render?foo=bar\r\n *  <\/pre>\r\n *\r\n *  resolved with\r\n *\r\n *  <pre>\r\n *  ..\/component\/render?a=b\r\n *  <\/pre>\r\n *\r\n *  will become\r\n *\r\n *  <pre>\r\n *  wicket\/component\/render?a=b\r\n *  <\/pre>\r\n *\r\n *  <\/p>\r\n *\r\n *  @param relative\r\n *             relative url\r\n *\/\r\n","code_no_comment":"public void resolveRelative(final Url relative) {\r\n    if (getSegments().size() > 0) {\r\n                getSegments().remove(getSegments().size() - 1);\r\n    }\r\n        while (!relative.getSegments().isEmpty()) {\r\n        if (\".\".equals(relative.getSegments().get(0))) {\r\n            relative.getSegments().remove(0);\r\n        } else if (\"\".equals(relative.getSegments().get(0))) {\r\n            relative.getSegments().remove(0);\r\n        } else if (\"..\".equals(relative.getSegments().get(0))) {\r\n            relative.getSegments().remove(0);\r\n            if (getSegments().isEmpty() == false) {\r\n                getSegments().remove(getSegments().size() - 1);\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n        getSegments().addAll(relative.getSegments());\r\n        parameters.clear();\r\n    parameters.addAll(relative.getQueryParameters());\r\n}","lc":0.3636363636,"pi":0.5933014354,"ma":0.8,"nbd":1.5,"ml":0.6666666667,"d":0.8849206349,"mi":-0.3274136716,"fo":2.4166666667,"r":-0.0263157895,"e":0.7427695464}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"\/**\r\n * search the index for the provided PropertyRestriction\r\n *\r\n * @param filter\r\n * @param indexName\r\n * @param indexMeta\r\n * @param pr\r\n * @return the iterable\r\n *\/\r\npublic Iterable<String> query(final Filter filter, final String indexName, final NodeState indexMeta, final PropertyRestriction pr) {\r\n    return query(filter, indexName, indexMeta, INDEX_CONTENT_NODE_NAME, pr);\r\n}","code_comment":"\/**\r\n * search the index for the provided PropertyRestriction\r\n *\r\n * @param filter\r\n * @param indexName\r\n * @param indexMeta\r\n * @param pr\r\n * @return the iterable\r\n *\/\r\n","code_no_comment":"public Iterable<String> query(final Filter filter, final String indexName, final NodeState indexMeta, final PropertyRestriction pr) {\r\n    return query(filter, indexName, indexMeta, INDEX_CONTENT_NODE_NAME, pr);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8584918957,"fo":-0.4166666667,"r":2.4210526316,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5215_033eb6fe","label":3,"code":"\/**\r\n * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\r\n *\/\r\n@Deprecated\r\npublic static BufferedWriter toWriter(File file) throws IOException {\r\n    return toWriter(file, null);\r\n}","code_comment":"\/**\r\n * @deprecated will be removed in Camel 3.0. Use the method which has 2 parameters.\r\n *\/\r\n","code_no_comment":"@Deprecated\r\npublic static BufferedWriter toWriter(File file) throws IOException {\r\n    return toWriter(file, null);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8396053559,"fo":-0.4166666667,"r":2.3684210526,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3433_e76d23b0","label":3,"code":"public Object evaluate(Exchange exchange) {\r\n    return expression.evaluate(exchange, type);\r\n}","code_comment":null,"code_no_comment":"public Object evaluate(Exchange exchange) {\r\n    return expression.evaluate(exchange, type);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9960535588,"fo":-0.4166666667,"r":0.5789473684,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4423_275eca83","label":3,"code":"@Override\r\npublic Boolean call() {\r\n    long now = System.currentTimeMillis();\r\n    refreshHead();\r\n    SegmentNodeState state = head.get();\r\n    SegmentNodeBuilder builder = state.builder();\r\n    NodeBuilder checkpoints = builder.child(\"checkpoints\");\r\n    for (String n : checkpoints.getChildNodeNames()) {\r\n        NodeBuilder cp = checkpoints.getChildNode(n);\r\n        PropertyState ts = cp.getProperty(\"timestamp\");\r\n        if (ts == null || ts.getType() != LONG || now > ts.getValue(LONG)) {\r\n            cp.remove();\r\n        }\r\n    }\r\n    NodeBuilder cp = checkpoints.child(name);\r\n    cp.setProperty(\"timestamp\", now + lifetime);\r\n    cp.setProperty(\"created\", now);\r\n    NodeBuilder props = cp.setChildNode(\"properties\");\r\n    for (Entry<String, String> p : properties.entrySet()) {\r\n        props.setProperty(p.getKey(), p.getValue());\r\n    }\r\n    cp.setChildNode(ROOT, state.getChildNode(ROOT));\r\n    SegmentNodeState newState = builder.getNodeState();\r\n    if (store.setHead(state, newState)) {\r\n        refreshHead();\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Boolean call() {\r\n    long now = System.currentTimeMillis();\r\n    refreshHead();\r\n    SegmentNodeState state = head.get();\r\n    SegmentNodeBuilder builder = state.builder();\r\n    NodeBuilder checkpoints = builder.child(\"checkpoints\");\r\n    for (String n : checkpoints.getChildNodeNames()) {\r\n        NodeBuilder cp = checkpoints.getChildNode(n);\r\n        PropertyState ts = cp.getProperty(\"timestamp\");\r\n        if (ts == null || ts.getType() != LONG || now > ts.getValue(LONG)) {\r\n            cp.remove();\r\n        }\r\n    }\r\n    NodeBuilder cp = checkpoints.child(name);\r\n    cp.setProperty(\"timestamp\", now + lifetime);\r\n    cp.setProperty(\"created\", now);\r\n    NodeBuilder props = cp.setChildNode(\"properties\");\r\n    for (Entry<String, String> p : properties.entrySet()) {\r\n        props.setProperty(p.getKey(), p.getValue());\r\n    }\r\n    cp.setChildNode(ROOT, state.getChildNode(ROOT));\r\n    SegmentNodeState newState = builder.getNodeState();\r\n    if (store.setHead(state, newState)) {\r\n        refreshHead();\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}","lc":0.7272727273,"pi":-0.1531100478,"ma":0.2,"nbd":0.0,"ml":0.5,"d":0.7777777778,"mi":-0.5529245948,"fo":1.5,"r":-0.0263157895,"e":1.5092293241}
{"project_name":"JxPath","project_version":"7","label":1,"code":"public Object computeValue(EvalContext context) {\r\n    double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\r\n    double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\r\n    return l <= r ? Boolean.TRUE : Boolean.FALSE;\r\n}","code_comment":null,"code_no_comment":"public Object computeValue(EvalContext context) {\r\n    double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\r\n    double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\r\n    return l <= r ? Boolean.TRUE : Boolean.FALSE;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.4,"nbd":-1.0,"ml":-0.1666666667,"d":-0.0337301587,"mi":0.5348837209,"fo":-0.1666666667,"r":0.1842105263,"e":-0.0748511725}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2952_11d11e0d","label":1,"code":"\/**\r\n * Select a tablet based on differences between table loads; if the loads are even, use the busiest table\r\n *\/\r\nList<TabletMigration> move(ServerCounts tooMuch, ServerCounts tooLittle, int count, Map<String, Map<KeyExtent, TabletStats>> donerTabletStats) {\r\n    List<TabletMigration> result = new ArrayList<TabletMigration>();\r\n    if (count == 0)\r\n        return result;\r\n    \/\/ Copy counts so we can update them as we propose migrations\r\n    Map<String, Integer> tooMuchMap = tabletCountsPerTable(tooMuch.status);\r\n    Map<String, Integer> tooLittleMap = tabletCountsPerTable(tooLittle.status);\r\n    for (int i = 0; i < count; i++) {\r\n        String table;\r\n        Integer tooLittleCount;\r\n        if (tableToBalance == null) {\r\n            \/\/ find a table to migrate\r\n            \/\/ look for an uneven table count\r\n            int biggestDifference = 0;\r\n            String biggestDifferenceTable = null;\r\n            for (Entry<String, Integer> tableEntry : tooMuchMap.entrySet()) {\r\n                String tableID = tableEntry.getKey();\r\n                if (tooLittleMap.get(tableID) == null)\r\n                    tooLittleMap.put(tableID, 0);\r\n                int diff = tableEntry.getValue() - tooLittleMap.get(tableID);\r\n                if (diff > biggestDifference) {\r\n                    biggestDifference = diff;\r\n                    biggestDifferenceTable = tableID;\r\n                }\r\n            }\r\n            if (biggestDifference < 2) {\r\n                table = busiest(tooMuch.status.tableMap);\r\n            } else {\r\n                table = biggestDifferenceTable;\r\n            }\r\n        } else {\r\n            \/\/ just balance the given table\r\n            table = tableToBalance;\r\n        }\r\n        Map<KeyExtent, TabletStats> onlineTabletsForTable = donerTabletStats.get(table);\r\n        try {\r\n            if (onlineTabletsForTable == null) {\r\n                onlineTabletsForTable = new HashMap<KeyExtent, TabletStats>();\r\n                for (TabletStats stat : getOnlineTabletsForTable(tooMuch.server, table)) onlineTabletsForTable.put(new KeyExtent(stat.extent), stat);\r\n                donerTabletStats.put(table, onlineTabletsForTable);\r\n            }\r\n        } catch (Exception ex) {\r\n            log.error(\"Unable to select a tablet to move\", ex);\r\n            return result;\r\n        }\r\n        KeyExtent extent = selectTablet(tooMuch.server, onlineTabletsForTable);\r\n        onlineTabletsForTable.remove(extent);\r\n        if (extent == null)\r\n            return result;\r\n        tooMuchMap.put(table, tooMuchMap.get(table) - 1);\r\n        \/**\r\n         * If a table grows from 1 tablet then tooLittleMap.get(table) can return a null, since there is only one tabletserver that holds all of the tablets. Here\r\n         * we check to see if in fact that is the case and if so set the value to 0.\r\n         *\/\r\n        tooLittleCount = tooLittleMap.get(table);\r\n        if (tooLittleCount == null) {\r\n            tooLittleCount = 0;\r\n        }\r\n        tooLittleMap.put(table, tooLittleCount + 1);\r\n        result.add(new TabletMigration(extent, tooMuch.server, tooLittle.server));\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n * Select a tablet based on differences between table loads; if the loads are even, use the busiest table\r\n *\/\r\n\/**\r\n * If a table grows from 1 tablet then tooLittleMap.get(table) can return a null, since there is only one tabletserver that holds all of the tablets. Here\r\n * we check to see if in fact that is the case and if so set the value to 0.\r\n *\/\r\n","code_no_comment":"List<TabletMigration> move(ServerCounts tooMuch, ServerCounts tooLittle, int count, Map<String, Map<KeyExtent, TabletStats>> donerTabletStats) {\r\n    List<TabletMigration> result = new ArrayList<TabletMigration>();\r\n    if (count == 0)\r\n        return result;\r\n        Map<String, Integer> tooMuchMap = tabletCountsPerTable(tooMuch.status);\r\n    Map<String, Integer> tooLittleMap = tabletCountsPerTable(tooLittle.status);\r\n    for (int i = 0; i < count; i++) {\r\n        String table;\r\n        Integer tooLittleCount;\r\n        if (tableToBalance == null) {\r\n                                    int biggestDifference = 0;\r\n            String biggestDifferenceTable = null;\r\n            for (Entry<String, Integer> tableEntry : tooMuchMap.entrySet()) {\r\n                String tableID = tableEntry.getKey();\r\n                if (tooLittleMap.get(tableID) == null)\r\n                    tooLittleMap.put(tableID, 0);\r\n                int diff = tableEntry.getValue() - tooLittleMap.get(tableID);\r\n                if (diff > biggestDifference) {\r\n                    biggestDifference = diff;\r\n                    biggestDifferenceTable = tableID;\r\n                }\r\n            }\r\n            if (biggestDifference < 2) {\r\n                table = busiest(tooMuch.status.tableMap);\r\n            } else {\r\n                table = biggestDifferenceTable;\r\n            }\r\n        } else {\r\n                        table = tableToBalance;\r\n        }\r\n        Map<KeyExtent, TabletStats> onlineTabletsForTable = donerTabletStats.get(table);\r\n        try {\r\n            if (onlineTabletsForTable == null) {\r\n                onlineTabletsForTable = new HashMap<KeyExtent, TabletStats>();\r\n                for (TabletStats stat : getOnlineTabletsForTable(tooMuch.server, table)) onlineTabletsForTable.put(new KeyExtent(stat.extent), stat);\r\n                donerTabletStats.put(table, onlineTabletsForTable);\r\n            }\r\n        } catch (Exception ex) {\r\n            log.error(\"Unable to select a tablet to move\", ex);\r\n            return result;\r\n        }\r\n        KeyExtent extent = selectTablet(tooMuch.server, onlineTabletsForTable);\r\n        onlineTabletsForTable.remove(extent);\r\n        if (extent == null)\r\n            return result;\r\n        tooMuchMap.put(table, tooMuchMap.get(table) - 1);\r\n        \/**\r\n         * If a table grows from 1 tablet then tooLittleMap.get(table) can return a null, since there is only one tabletserver that holds all of the tablets. Here\r\n         * we check to see if in fact that is the case and if so set the value to 0.\r\n         *\/\r\n        tooLittleCount = tooLittleMap.get(table);\r\n        if (tooLittleCount == null) {\r\n            tooLittleCount = 0;\r\n        }\r\n        tooLittleMap.put(table, tooLittleCount + 1);\r\n        result.add(new TabletMigration(extent, tooMuch.server, tooLittle.server));\r\n    }\r\n    return result;\r\n}","lc":2.0454545455,"pi":0.7703349282,"ma":1.8,"nbd":1.0,"ml":1.1666666667,"d":1.4861111111,"mi":-1.0084566596,"fo":1.25,"r":-0.0263157895,"e":5.0092517995}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2065_9da430fb","label":1,"code":"protected ValueMap decodeParameters(String urlFragment, Map urlParameters) {\r\n    PageParameters params = new PageParameters();\r\n    if (urlFragment == null) {\r\n        return params;\r\n    }\r\n    if (urlFragment.startsWith(\"\/\")) {\r\n        urlFragment = urlFragment.substring(1);\r\n    }\r\n    if (urlFragment.length() > 0 && urlFragment.endsWith(\"\/\")) {\r\n        urlFragment = urlFragment.substring(0, urlFragment.length() - 1);\r\n    }\r\n    String[] parts = urlFragment.split(\"\/\");\r\n    for (int i = 0; i < parts.length; i++) {\r\n        if (WebRequestCodingStrategy.PAGEMAP.equals(parts[i])) {\r\n            i++;\r\n            params.put(WebRequestCodingStrategy.PAGEMAP, WebRequestCodingStrategy.decodePageMapName(urlDecodePathComponent(parts[i])));\r\n        } else {\r\n            params.put(String.valueOf(i), urlDecodePathComponent(parts[i]));\r\n        }\r\n    }\r\n    return params;\r\n}","code_comment":null,"code_no_comment":"protected ValueMap decodeParameters(String urlFragment, Map urlParameters) {\r\n    PageParameters params = new PageParameters();\r\n    if (urlFragment == null) {\r\n        return params;\r\n    }\r\n    if (urlFragment.startsWith(\"\/\")) {\r\n        urlFragment = urlFragment.substring(1);\r\n    }\r\n    if (urlFragment.length() > 0 && urlFragment.endsWith(\"\/\")) {\r\n        urlFragment = urlFragment.substring(0, urlFragment.length() - 1);\r\n    }\r\n    String[] parts = urlFragment.split(\"\/\");\r\n    for (int i = 0; i < parts.length; i++) {\r\n        if (WebRequestCodingStrategy.PAGEMAP.equals(parts[i])) {\r\n            i++;\r\n            params.put(WebRequestCodingStrategy.PAGEMAP, WebRequestCodingStrategy.decodePageMapName(urlDecodePathComponent(parts[i])));\r\n        } else {\r\n            params.put(String.valueOf(i), urlDecodePathComponent(parts[i]));\r\n        }\r\n    }\r\n    return params;\r\n}","lc":0.3636363636,"pi":0.1722488038,"ma":0.4,"nbd":0.0,"ml":0.6666666667,"d":1.1349206349,"mi":-0.3536293164,"fo":0.6666666667,"r":-0.0263157895,"e":1.2549275888}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1269_b8fe2ded","label":1,"code":"@Override\r\npublic double getCost(Filter filter, NodeState root) {\r\n    \/\/ TODO don't call getCost for such queries\r\n    if (filter.getFullTextConstraint() != null) {\r\n        \/\/ not an appropriate index for full-text search\r\n        return Double.POSITIVE_INFINITY;\r\n    }\r\n    if (!hasNodeTypeRestriction(filter)) {\r\n        \/\/ doesn't have a node type restriction\r\n        return Double.POSITIVE_INFINITY;\r\n    }\r\n    NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);\r\n    if (lookup.isIndexed(filter.getPath())) {\r\n        return lookup.getCost(filter);\r\n    } else {\r\n        return Double.POSITIVE_INFINITY;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic double getCost(Filter filter, NodeState root) {\r\n        if (filter.getFullTextConstraint() != null) {\r\n                return Double.POSITIVE_INFINITY;\r\n    }\r\n    if (!hasNodeTypeRestriction(filter)) {\r\n                return Double.POSITIVE_INFINITY;\r\n    }\r\n    NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);\r\n    if (lookup.isIndexed(filter.getPath())) {\r\n        return lookup.getCost(filter);\r\n    } else {\r\n        return Double.POSITIVE_INFINITY;\r\n    }\r\n}","lc":0.0454545455,"pi":-0.1291866029,"ma":0.0,"nbd":-0.5,"ml":0.25,"d":-0.005952381,"mi":-0.0049330514,"fo":-0.0833333333,"r":0.2368421053,"e":-0.0492038519}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4927_8c827e33","label":1,"code":"@Override\r\npublic void setContentLength(long length) {\r\n    checkHeader();\r\n    bufferedResponse.setContentLength(length);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void setContentLength(long length) {\r\n    checkHeader();\r\n    bufferedResponse.setContentLength(length);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.792248062,"fo":-0.3333333333,"r":1.1315789474,"e":-0.1627934049}
{"project_name":"Math","project_version":"22","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic boolean isSupportLowerBoundInclusive() {\r\n    return true;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public boolean isSupportLowerBoundInclusive() {\r\n    return true;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.2407329105,"fo":-0.5,"r":2.5,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8053_cac72b14","label":1,"code":"public synchronized boolean removeRoute(String routeId) throws Exception {\r\n    RouteService routeService = routeServices.get(routeId);\r\n    if (routeService != null) {\r\n        if (getRouteStatus(routeId).isStopped()) {\r\n            routeService.setRemovingRoutes(true);\r\n            shutdownRouteService(routeService);\r\n            removeRouteDefinition(routeId);\r\n            routeServices.remove(routeId);\r\n            \/\/ remove route from startup order as well, as it was removed\r\n            Iterator<RouteStartupOrder> it = routeStartupOrder.iterator();\r\n            while (it.hasNext()) {\r\n                RouteStartupOrder order = it.next();\r\n                if (order.getRoute().getId().equals(routeId)) {\r\n                    it.remove();\r\n                }\r\n            }\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"public synchronized boolean removeRoute(String routeId) throws Exception {\r\n    RouteService routeService = routeServices.get(routeId);\r\n    if (routeService != null) {\r\n        if (getRouteStatus(routeId).isStopped()) {\r\n            routeService.setRemovingRoutes(true);\r\n            shutdownRouteService(routeService);\r\n            removeRouteDefinition(routeId);\r\n            routeServices.remove(routeId);\r\n                        Iterator<RouteStartupOrder> it = routeStartupOrder.iterator();\r\n            while (it.hasNext()) {\r\n                RouteStartupOrder order = it.next();\r\n                if (order.getRoute().getId().equals(routeId)) {\r\n                    it.remove();\r\n                }\r\n            }\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}","lc":0.3636363636,"pi":1.0669856459,"ma":0.2,"nbd":1.0,"ml":0.3333333333,"d":-0.0496031746,"mi":-0.2744186047,"fo":0.6666666667,"r":-0.0263157895,"e":0.0183560681}
{"project_name":"JxPath","project_version":"13","label":1,"code":"\/**\r\n * Given a prefix, returns a registered namespace URI. If the requested\r\n * prefix was not defined explicitly using the registerNamespace method,\r\n * JXPathContext will then check the context node to see if the prefix is\r\n * defined there. See\r\n * {@link #setNamespaceContextPointer(NodePointer) setNamespaceContextPointer}.\r\n *\r\n * @param prefix The namespace prefix to look up\r\n * @return namespace URI or null if the prefix is undefined.\r\n *\/\r\npublic synchronized String getNamespaceURI(String prefix) {\r\n    \/**\r\n     * Given a prefix, returns an externally registered namespace URI.\r\n     *\r\n     * @param prefix The namespace prefix to look up\r\n     * @return namespace URI or null if the prefix is undefined.\r\n     * @since JXPath 1.3\r\n     *\/\r\n    String uri = (String) namespaceMap.get(prefix);\r\n    if (uri == null && pointer != null) {\r\n        uri = pointer.getNamespaceURI(prefix);\r\n    }\r\n    if (uri == null && parent != null) {\r\n        return parent.getNamespaceURI(prefix);\r\n    }\r\n    return uri;\r\n}","code_comment":"\/**\r\n * Given a prefix, returns a registered namespace URI. If the requested\r\n * prefix was not defined explicitly using the registerNamespace method,\r\n * JXPathContext will then check the context node to see if the prefix is\r\n * defined there. See\r\n * {@link #setNamespaceContextPointer(NodePointer) setNamespaceContextPointer}.\r\n *\r\n * @param prefix The namespace prefix to look up\r\n * @return namespace URI or null if the prefix is undefined.\r\n *\/\r\n\/**\r\n * Given a prefix, returns an externally registered namespace URI.\r\n *\r\n * @param prefix The namespace prefix to look up\r\n * @return namespace URI or null if the prefix is undefined.\r\n * @since JXPath 1.3\r\n *\/\r\n","code_no_comment":"public synchronized String getNamespaceURI(String prefix) {\r\n    \/**\r\n     * Given a prefix, returns an externally registered namespace URI.\r\n     *\r\n     * @param prefix The namespace prefix to look up\r\n     * @return namespace URI or null if the prefix is undefined.\r\n     * @since JXPath 1.3\r\n     *\/\r\n    String uri = (String) namespaceMap.get(prefix);\r\n    if (uri == null && pointer != null) {\r\n        uri = pointer.getNamespaceURI(prefix);\r\n    }\r\n    if (uri == null && parent != null) {\r\n        return parent.getNamespaceURI(prefix);\r\n    }\r\n    return uri;\r\n}","lc":0.1363636364,"pi":-0.4736842105,"ma":-0.2,"nbd":-0.5,"ml":0.1666666667,"d":0.7063492063,"mi":-0.0528541226,"fo":-0.25,"r":-0.0263157895,"e":0.1689620396}
{"project_name":"Closure","project_version":"106","label":2,"code":"boolean canCollapseUnannotatedChildNames() {\r\n    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\r\n        return false;\r\n    }\r\n    if (isClassOrEnum) {\r\n        return true;\r\n    }\r\n    return (type == Type.FUNCTION || aliasingGets == 0) && (parent == null || parent.canCollapseUnannotatedChildNames());\r\n}","code_comment":null,"code_no_comment":"boolean canCollapseUnannotatedChildNames() {\r\n    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\r\n        return false;\r\n    }\r\n    if (isClassOrEnum) {\r\n        return true;\r\n    }\r\n    return (type == Type.FUNCTION || aliasingGets == 0) && (parent == null || parent.canCollapseUnannotatedChildNames());\r\n}","lc":-0.2272727273,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":0.25,"d":0.1547619048,"mi":0.2321353066,"fo":-0.4166666667,"r":1.6052631579,"e":0.0045803726}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Returns true iff object is a ResizableDoubleArray with the same properties\r\n * as this and an identical internal storage array.\r\n *\r\n * @param object object to be compared for equality with this\r\n * @return true iff object is a ResizableDoubleArray with the same data and\r\n * properties as this\r\n * @since 2.0\r\n *\/\r\n@Override\r\npublic boolean equals(Object object) {\r\n    if (object == this) {\r\n        return true;\r\n    }\r\n    if (object instanceof ResizableDoubleArray == false) {\r\n        return false;\r\n    }\r\n    synchronized (this) {\r\n        synchronized (object) {\r\n            boolean result = true;\r\n            final ResizableDoubleArray other = (ResizableDoubleArray) object;\r\n            result = result && (other.contractionCriterion == contractionCriterion);\r\n            result = result && (other.expansionFactor == expansionFactor);\r\n            result = result && (other.expansionMode == expansionMode);\r\n            result = result && (other.numElements == numElements);\r\n            result = result && (other.startIndex == startIndex);\r\n            if (!result) {\r\n                return false;\r\n            } else {\r\n                return Arrays.equals(internalArray, other.internalArray);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Returns true iff object is a ResizableDoubleArray with the same properties\r\n * as this and an identical internal storage array.\r\n *\r\n * @param object object to be compared for equality with this\r\n * @return true iff object is a ResizableDoubleArray with the same data and\r\n * properties as this\r\n * @since 2.0\r\n *\/\r\n","code_no_comment":"@Override\r\npublic boolean equals(Object object) {\r\n    if (object == this) {\r\n        return true;\r\n    }\r\n    if (object instanceof ResizableDoubleArray == false) {\r\n        return false;\r\n    }\r\n    synchronized (this) {\r\n        synchronized (object) {\r\n            boolean result = true;\r\n            final ResizableDoubleArray other = (ResizableDoubleArray) object;\r\n            result = result && (other.contractionCriterion == contractionCriterion);\r\n            result = result && (other.expansionFactor == expansionFactor);\r\n            result = result && (other.expansionMode == expansionMode);\r\n            result = result && (other.numElements == numElements);\r\n            result = result && (other.startIndex == startIndex);\r\n            if (!result) {\r\n                return false;\r\n            } else {\r\n                return Arrays.equals(internalArray, other.internalArray);\r\n            }\r\n        }\r\n    }\r\n}","lc":0.5,"pi":0.8612440191,"ma":0.0,"nbd":0.5,"ml":0.0,"d":0.8015873016,"mi":-0.3578576462,"fo":-0.4166666667,"r":-0.0263157895,"e":0.6710326585}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5980_294b0b2f","label":3,"code":"\/**\r\n *  Stub method that lets subclasses configure filter path from annotations.\r\n *\r\n *  @param isServlet\r\n *  @return Filter path from annotation\r\n *\/\r\nprotected String getFilterPathFromAnnotation(boolean isServlet) {\r\n    String[] patterns = null;\r\n    if (isServlet) {\r\n        WebServlet servlet = getClass().getAnnotation(WebServlet.class);\r\n        if (servlet != null) {\r\n            if (servlet.urlPatterns().length > 0) {\r\n                patterns = servlet.urlPatterns();\r\n            } else {\r\n                patterns = servlet.value();\r\n            }\r\n        }\r\n    } else {\r\n        WebFilter filter = getClass().getAnnotation(WebFilter.class);\r\n        if (filter != null) {\r\n            if (filter.urlPatterns().length > 0) {\r\n                patterns = filter.urlPatterns();\r\n            } else {\r\n                patterns = filter.value();\r\n            }\r\n        }\r\n    }\r\n    if (patterns != null && patterns.length > 0) {\r\n        String pattern = patterns[0];\r\n        if (patterns.length > 1) {\r\n            log.warn(\"Multiple url patterns defined for Wicket filter\/servlet, using the first: {}\", pattern);\r\n        }\r\n        if (\"\/*\".equals(pattern)) {\r\n            pattern = \"\";\r\n        }\r\n        return pattern;\r\n    }\r\n    return null;\r\n}","code_comment":"\/**\r\n *  Stub method that lets subclasses configure filter path from annotations.\r\n *\r\n *  @param isServlet\r\n *  @return Filter path from annotation\r\n *\/\r\n","code_no_comment":"protected String getFilterPathFromAnnotation(boolean isServlet) {\r\n    String[] patterns = null;\r\n    if (isServlet) {\r\n        WebServlet servlet = getClass().getAnnotation(WebServlet.class);\r\n        if (servlet != null) {\r\n            if (servlet.urlPatterns().length > 0) {\r\n                patterns = servlet.urlPatterns();\r\n            } else {\r\n                patterns = servlet.value();\r\n            }\r\n        }\r\n    } else {\r\n        WebFilter filter = getClass().getAnnotation(WebFilter.class);\r\n        if (filter != null) {\r\n            if (filter.urlPatterns().length > 0) {\r\n                patterns = filter.urlPatterns();\r\n            } else {\r\n                patterns = filter.value();\r\n            }\r\n        }\r\n    }\r\n    if (patterns != null && patterns.length > 0) {\r\n        String pattern = patterns[0];\r\n        if (patterns.length > 1) {\r\n            log.warn(\"Multiple url patterns defined for Wicket filter\/servlet, using the first: {}\", pattern);\r\n        }\r\n        if (\"\/*\".equals(pattern)) {\r\n            pattern = \"\";\r\n        }\r\n        return pattern;\r\n    }\r\n    return null;\r\n}","lc":0.8636363636,"pi":0.6315789474,"ma":1.0,"nbd":0.5,"ml":1.0833333333,"d":0.7103174603,"mi":-0.5534883721,"fo":0.5,"r":-0.0263157895,"e":0.82163863}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3834_747bccb5","label":1,"code":"\/**\r\n *  Parses the given URL string.\r\n *\r\n *  @param url\r\n *  @return Url object\r\n *\/\r\npublic static Url parse(final String url) {\r\n    return parse(url, null);\r\n}","code_comment":"\/**\r\n *  Parses the given URL string.\r\n *\r\n *  @param url\r\n *  @return Url object\r\n *\/\r\n","code_no_comment":"public static Url parse(final String url) {\r\n    return parse(url, null);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0253699789,"fo":-0.4166666667,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-358_061f5017","label":0,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\r\n    sanityChecks(equations, t0, y0, t, y);\r\n    setEquations(equations);\r\n    resetEvaluations();\r\n    final boolean forward = t > t0;\r\n    \/\/ create some internal working arrays\r\n    final int stages = c.length + 1;\r\n    if (y != y0) {\r\n        System.arraycopy(y0, 0, y, 0, y0.length);\r\n    }\r\n    final double[][] yDotK = new double[stages][];\r\n    for (int i = 0; i < stages; ++i) {\r\n        yDotK[i] = new double[y0.length];\r\n    }\r\n    final double[] yTmp = new double[y0.length];\r\n    \/\/ set up an interpolator sharing the integrator arrays\r\n    AbstractStepInterpolator interpolator;\r\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\r\n        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\r\n        rki.reinitialize(this, yTmp, yDotK, forward);\r\n        interpolator = rki;\r\n    } else {\r\n        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\r\n    }\r\n    interpolator.storeTime(t0);\r\n    \/\/ set up integration control objects\r\n    stepStart = t0;\r\n    stepSize = forward ? step : -step;\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.reset();\r\n    }\r\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\r\n    boolean lastStep = false;\r\n    \/\/ main integration loop\r\n    while (!lastStep) {\r\n        interpolator.shift();\r\n        for (boolean loop = true; loop; ) {\r\n            \/\/ first stage\r\n            computeDerivatives(stepStart, y, yDotK[0]);\r\n            \/\/ next stages\r\n            for (int k = 1; k < stages; ++k) {\r\n                for (int j = 0; j < y0.length; ++j) {\r\n                    double sum = a[k - 1][0] * yDotK[0][j];\r\n                    for (int l = 1; l < k; ++l) {\r\n                        sum += a[k - 1][l] * yDotK[l][j];\r\n                    }\r\n                    yTmp[j] = y[j] + stepSize * sum;\r\n                }\r\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\r\n            }\r\n            \/\/ estimate the state at the end of the step\r\n            for (int j = 0; j < y0.length; ++j) {\r\n                double sum = b[0] * yDotK[0][j];\r\n                for (int l = 1; l < stages; ++l) {\r\n                    sum += b[l] * yDotK[l][j];\r\n                }\r\n                yTmp[j] = y[j] + stepSize * sum;\r\n            }\r\n            \/\/ discrete events handling\r\n            interpolator.storeTime(stepStart + stepSize);\r\n            if (manager.evaluateStep(interpolator)) {\r\n                final double dt = manager.getEventTime() - stepStart;\r\n                if (Math.abs(dt) <= Math.ulp(stepStart)) {\r\n                    \/\/ rejecting the step would lead to a too small next step, we accept it\r\n                    loop = false;\r\n                } else {\r\n                    \/\/ reject the step to match exactly the next switch time\r\n                    stepSize = dt;\r\n                }\r\n            } else {\r\n                loop = false;\r\n            }\r\n        }\r\n        \/\/ the step has been accepted\r\n        final double nextStep = stepStart + stepSize;\r\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\r\n        manager.stepAccepted(nextStep, y);\r\n        lastStep = manager.stop();\r\n        \/\/ provide the step data to the step handler\r\n        interpolator.storeTime(nextStep);\r\n        for (StepHandler handler : stepHandlers) {\r\n            handler.handleStep(interpolator, lastStep);\r\n        }\r\n        stepStart = nextStep;\r\n        if (manager.reset(stepStart, y) && !lastStep) {\r\n            \/\/ some events handler has triggered changes that\r\n            \/\/ invalidate the derivatives, we need to recompute them\r\n            computeDerivatives(stepStart, y, yDotK[0]);\r\n        }\r\n        \/\/ make sure step size is set to default before next step\r\n        stepSize = forward ? step : -step;\r\n    }\r\n    final double stopTime = stepStart;\r\n    stepStart = Double.NaN;\r\n    stepSize = Double.NaN;\r\n    return stopTime;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\r\n    sanityChecks(equations, t0, y0, t, y);\r\n    setEquations(equations);\r\n    resetEvaluations();\r\n    final boolean forward = t > t0;\r\n        final int stages = c.length + 1;\r\n    if (y != y0) {\r\n        System.arraycopy(y0, 0, y, 0, y0.length);\r\n    }\r\n    final double[][] yDotK = new double[stages][];\r\n    for (int i = 0; i < stages; ++i) {\r\n        yDotK[i] = new double[y0.length];\r\n    }\r\n    final double[] yTmp = new double[y0.length];\r\n        AbstractStepInterpolator interpolator;\r\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\r\n        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\r\n        rki.reinitialize(this, yTmp, yDotK, forward);\r\n        interpolator = rki;\r\n    } else {\r\n        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\r\n    }\r\n    interpolator.storeTime(t0);\r\n        stepStart = t0;\r\n    stepSize = forward ? step : -step;\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.reset();\r\n    }\r\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\r\n    boolean lastStep = false;\r\n        while (!lastStep) {\r\n        interpolator.shift();\r\n        for (boolean loop = true; loop; ) {\r\n                        computeDerivatives(stepStart, y, yDotK[0]);\r\n                        for (int k = 1; k < stages; ++k) {\r\n                for (int j = 0; j < y0.length; ++j) {\r\n                    double sum = a[k - 1][0] * yDotK[0][j];\r\n                    for (int l = 1; l < k; ++l) {\r\n                        sum += a[k - 1][l] * yDotK[l][j];\r\n                    }\r\n                    yTmp[j] = y[j] + stepSize * sum;\r\n                }\r\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\r\n            }\r\n                        for (int j = 0; j < y0.length; ++j) {\r\n                double sum = b[0] * yDotK[0][j];\r\n                for (int l = 1; l < stages; ++l) {\r\n                    sum += b[l] * yDotK[l][j];\r\n                }\r\n                yTmp[j] = y[j] + stepSize * sum;\r\n            }\r\n                        interpolator.storeTime(stepStart + stepSize);\r\n            if (manager.evaluateStep(interpolator)) {\r\n                final double dt = manager.getEventTime() - stepStart;\r\n                if (Math.abs(dt) <= Math.ulp(stepStart)) {\r\n                                        loop = false;\r\n                } else {\r\n                                        stepSize = dt;\r\n                }\r\n            } else {\r\n                loop = false;\r\n            }\r\n        }\r\n                final double nextStep = stepStart + stepSize;\r\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\r\n        manager.stepAccepted(nextStep, y);\r\n        lastStep = manager.stop();\r\n                interpolator.storeTime(nextStep);\r\n        for (StepHandler handler : stepHandlers) {\r\n            handler.handleStep(interpolator, lastStep);\r\n        }\r\n        stepStart = nextStep;\r\n        if (manager.reset(stepStart, y) && !lastStep) {\r\n                                    computeDerivatives(stepStart, y, yDotK[0]);\r\n        }\r\n                stepSize = forward ? step : -step;\r\n    }\r\n    final double stopTime = stepStart;\r\n    stepStart = Double.NaN;\r\n    stepSize = Double.NaN;\r\n    return stopTime;\r\n}","lc":3.0909090909,"pi":1.2775119617,"ma":2.8,"nbd":1.5,"ml":2.6666666667,"d":3.9781746032,"mi":-1.2756871036,"fo":1.6666666667,"r":-0.0263157895,"e":21.4459109167}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3878_b9094cb5","label":1,"code":"@Override\r\nprotected void doStop() throws Exception {\r\n    ServiceHelper.stopServices(deadLetter, output, outputAsync);\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void doStop() throws Exception {\r\n    ServiceHelper.stopServices(deadLetter, output, outputAsync);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8469344609,"fo":-0.4166666667,"r":0.4473684211,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7213_336663c9","label":1,"code":"@Converter\r\npublic static ByteBuffer toByteBuffer(Double value) {\r\n    ByteBuffer buf = ByteBuffer.allocate(8);\r\n    buf.putDouble(value);\r\n    return buf;\r\n}","code_comment":null,"code_no_comment":"@Converter\r\npublic static ByteBuffer toByteBuffer(Double value) {\r\n    ByteBuffer buf = ByteBuffer.allocate(8);\r\n    buf.putDouble(value);\r\n    return buf;\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5644820296,"fo":-0.3333333333,"r":1.1315789474,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-744_8a83581e","label":1,"code":"\/**\r\n * <p>\r\n * Gets the fraction as a <tt>double<\/tt>. This calculates the fraction as\r\n * the numerator divided by denominator.\r\n * <\/p>\r\n *\r\n * @return the fraction as a <tt>double<\/tt>\r\n * @see java.lang.Number#doubleValue()\r\n *\/\r\n@Override\r\npublic double doubleValue() {\r\n    return numerator.doubleValue() \/ denominator.doubleValue();\r\n}","code_comment":"\/**\r\n * <p>\r\n * Gets the fraction as a <tt>double<\/tt>. This calculates the fraction as\r\n * the numerator divided by denominator.\r\n * <\/p>\r\n *\r\n * @return the fraction as a <tt>double<\/tt>\r\n * @see java.lang.Number#doubleValue()\r\n *\/\r\n","code_no_comment":"@Override\r\npublic double doubleValue() {\r\n    return numerator.doubleValue() \/ denominator.doubleValue();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8940098661,"fo":-0.3333333333,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1544_0cf2ff72","label":1,"code":"\/**\r\n * Starts Accumulo and Zookeeper processes. Can only be called once.\r\n *\r\n * @throws IllegalStateException\r\n *           if already started\r\n *\/\r\npublic void start() throws IOException, InterruptedException {\r\n    if (!initialized) {\r\n        Runtime.getRuntime().addShutdownHook(new Thread() {\r\n\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    MiniAccumuloCluster.this.stop();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    if (zooKeeperProcess == null) {\r\n        zooKeeperProcess = exec(Main.class, ServerType.ZOOKEEPER, ZooKeeperServerMain.class.getName(), zooCfgFile.getAbsolutePath());\r\n    }\r\n    if (!initialized) {\r\n        \/\/ sleep a little bit to let zookeeper come up before calling init, seems to work better\r\n        UtilWaitThread.sleep(250);\r\n        Process initProcess = exec(Initialize.class, \"--instance-name\", config.getInstanceName(), \"--password\", config.getRootPassword(), \"--username\", \"root\");\r\n        int ret = initProcess.waitFor();\r\n        if (ret != 0) {\r\n            throw new RuntimeException(\"Initialize process returned \" + ret);\r\n        }\r\n        initialized = true;\r\n    }\r\n    for (int i = tabletServerProcesses.size(); i < config.getNumTservers(); i++) {\r\n        tabletServerProcesses.add(exec(TabletServer.class, ServerType.TABLET_SERVER));\r\n    }\r\n    int ret = 0;\r\n    for (int i = 0; i < 5; i++) {\r\n        ret = exec(Main.class, SetGoalState.class.getName(), MasterGoalState.NORMAL.toString()).waitFor();\r\n        if (ret == 0)\r\n            break;\r\n        UtilWaitThread.sleep(1000);\r\n    }\r\n    if (ret != 0) {\r\n        throw new RuntimeException(\"Could not set master goal state, process returned \" + ret);\r\n    }\r\n    if (masterProcess == null) {\r\n        masterProcess = exec(Master.class, ServerType.MASTER);\r\n    }\r\n}","code_comment":"\/**\r\n * Starts Accumulo and Zookeeper processes. Can only be called once.\r\n *\r\n * @throws IllegalStateException\r\n *           if already started\r\n *\/\r\n","code_no_comment":"public void start() throws IOException, InterruptedException {\r\n    if (!initialized) {\r\n        Runtime.getRuntime().addShutdownHook(new Thread() {\r\n\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    MiniAccumuloCluster.this.stop();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    if (zooKeeperProcess == null) {\r\n        zooKeeperProcess = exec(Main.class, ServerType.ZOOKEEPER, ZooKeeperServerMain.class.getName(), zooCfgFile.getAbsolutePath());\r\n    }\r\n    if (!initialized) {\r\n                UtilWaitThread.sleep(250);\r\n        Process initProcess = exec(Initialize.class, \"--instance-name\", config.getInstanceName(), \"--password\", config.getRootPassword(), \"--username\", \"root\");\r\n        int ret = initProcess.waitFor();\r\n        if (ret != 0) {\r\n            throw new RuntimeException(\"Initialize process returned \" + ret);\r\n        }\r\n        initialized = true;\r\n    }\r\n    for (int i = tabletServerProcesses.size(); i < config.getNumTservers(); i++) {\r\n        tabletServerProcesses.add(exec(TabletServer.class, ServerType.TABLET_SERVER));\r\n    }\r\n    int ret = 0;\r\n    for (int i = 0; i < 5; i++) {\r\n        ret = exec(Main.class, SetGoalState.class.getName(), MasterGoalState.NORMAL.toString()).waitFor();\r\n        if (ret == 0)\r\n            break;\r\n        UtilWaitThread.sleep(1000);\r\n    }\r\n    if (ret != 0) {\r\n        throw new RuntimeException(\"Could not set master goal state, process returned \" + ret);\r\n    }\r\n    if (masterProcess == null) {\r\n        masterProcess = exec(Master.class, ServerType.MASTER);\r\n    }\r\n}","lc":1.3636363636,"pi":0.995215311,"ma":2.2,"nbd":0.5,"ml":0.8333333333,"d":0.6488095238,"mi":-0.8212825934,"fo":1.4166666667,"r":-0.0263157895,"e":1.6458982383}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5853_b80f6640","label":3,"code":"\/**\r\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)\r\n *\/\r\n@Override\r\npublic Byte convertToObject(final String value, final Locale locale) {\r\n    final Number number = parse(value, Byte.MIN_VALUE, Byte.MAX_VALUE, locale);\r\n    if (number == null) {\r\n        return null;\r\n    }\r\n    return number.byteValue();\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)\r\n *\/\r\n","code_no_comment":"@Override\r\npublic Byte convertToObject(final String value, final Locale locale) {\r\n    final Number number = parse(value, Byte.MIN_VALUE, Byte.MAX_VALUE, locale);\r\n    if (number == null) {\r\n        return null;\r\n    }\r\n    return number.byteValue();\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0734126984,"mi":0.3429175476,"fo":-0.3333333333,"r":0.2105263158,"e":-0.0964598353}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5662_9aec4f33","label":1,"code":"\/**\r\n *  @see org.apache.wicket.proxy.IProxyTargetLocator#locateProxyTarget()\r\n *\/\r\n@Override\r\npublic Object locateProxyTarget() {\r\n    final ApplicationContext context = getSpringContext();\r\n    return lookupSpringBean(context, beanName, getBeanType());\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.proxy.IProxyTargetLocator#locateProxyTarget()\r\n *\/\r\n","code_no_comment":"@Override\r\npublic Object locateProxyTarget() {\r\n    final ApplicationContext context = getSpringContext();\r\n    return lookupSpringBean(context, beanName, getBeanType());\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6899224806,"fo":-0.25,"r":2.2631578947,"e":-0.1627934049}
{"project_name":"Closure","project_version":"175","label":2,"code":"\/**\r\n * @param t  The traversal use to reach the call site.\r\n * @param callNode The CALL node.\r\n * @param fnNode The function to evaluate for inlining.\r\n * @param needAliases A set of function parameter names that can not be\r\n *     used without aliasing. Returned by getUnsafeParameterNames().\r\n * @param mode Inlining mode to be used.\r\n * @param referencesThis Whether fnNode contains references to its this\r\n *     object.\r\n * @param containsFunctions Whether fnNode contains inner functions.\r\n * @return Whether the inlining can occur.\r\n *\/\r\nCanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set<String> needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\r\n    \/\/ Allow direct function calls or \"fn.call\" style calls.\r\n    if (!isSupportedCallType(callNode)) {\r\n        return CanInlineResult.NO;\r\n    }\r\n    \/\/ last until explicitly cleared.\r\n    if (containsFunctions) {\r\n        if (!assumeMinimumCapture && !t.inGlobalScope()) {\r\n            \/\/ inner functions.\r\n            return CanInlineResult.NO;\r\n        } else if (NodeUtil.isWithinLoop(callNode)) {\r\n            \/\/ single iteration through a loop.\r\n            return CanInlineResult.NO;\r\n        }\r\n    }\r\n    \/\/ TODO(johnlenz): Add support for 'apply'\r\n    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\r\n        \/\/ global 'this' object.\r\n        return CanInlineResult.NO;\r\n    }\r\n    if (mode == InliningMode.DIRECT) {\r\n        return canInlineReferenceDirectly(callNode, fnNode);\r\n    } else {\r\n        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\r\n    }\r\n}","code_comment":"\/**\r\n * @param t  The traversal use to reach the call site.\r\n * @param callNode The CALL node.\r\n * @param fnNode The function to evaluate for inlining.\r\n * @param needAliases A set of function parameter names that can not be\r\n *     used without aliasing. Returned by getUnsafeParameterNames().\r\n * @param mode Inlining mode to be used.\r\n * @param referencesThis Whether fnNode contains references to its this\r\n *     object.\r\n * @param containsFunctions Whether fnNode contains inner functions.\r\n * @return Whether the inlining can occur.\r\n *\/\r\n","code_no_comment":"CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set<String> needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) {\r\n        if (!isSupportedCallType(callNode)) {\r\n        return CanInlineResult.NO;\r\n    }\r\n        if (containsFunctions) {\r\n        if (!assumeMinimumCapture && !t.inGlobalScope()) {\r\n                        return CanInlineResult.NO;\r\n        } else if (NodeUtil.isWithinLoop(callNode)) {\r\n                        return CanInlineResult.NO;\r\n        }\r\n    }\r\n        if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\r\n                return CanInlineResult.NO;\r\n    }\r\n    if (mode == InliningMode.DIRECT) {\r\n        return canInlineReferenceDirectly(callNode, fnNode);\r\n    } else {\r\n        return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases);\r\n    }\r\n}","lc":0.2727272727,"pi":0.1100478469,"ma":0.6,"nbd":0.5,"ml":1.0,"d":0.0158730159,"mi":-0.2532769556,"fo":0.0,"r":-0.0263157895,"e":0.0712551074}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1668_63070cf9","label":1,"code":"@Override\r\npublic String getPlan(Filter filter, NodeState root) {\r\n    FullTextExpression ft = filter.getFullTextConstraint();\r\n    Set<String> relPaths = getRelativePaths(ft);\r\n    if (relPaths.size() > 1) {\r\n        return new MultiLuceneIndex(filter, root, relPaths).getPlan();\r\n    }\r\n    String parent = relPaths.size() == 0 ? \"\" : relPaths.iterator().next();\r\n    \/\/ we only restrict non-full-text conditions if there is\r\n    \/\/ no relative property in the full-text constraint\r\n    boolean nonFullTextConstraints = parent.isEmpty();\r\n    String plan = getQuery(filter, null, nonFullTextConstraints, analyzer) + \" ft:(\" + ft + \")\";\r\n    if (!parent.isEmpty()) {\r\n        plan += \" parent:\" + parent;\r\n    }\r\n    return plan;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String getPlan(Filter filter, NodeState root) {\r\n    FullTextExpression ft = filter.getFullTextConstraint();\r\n    Set<String> relPaths = getRelativePaths(ft);\r\n    if (relPaths.size() > 1) {\r\n        return new MultiLuceneIndex(filter, root, relPaths).getPlan();\r\n    }\r\n    String parent = relPaths.size() == 0 ? \"\" : relPaths.iterator().next();\r\n            boolean nonFullTextConstraints = parent.isEmpty();\r\n    String plan = getQuery(filter, null, nonFullTextConstraints, analyzer) + \" ft:(\" + ft + \")\";\r\n    if (!parent.isEmpty()) {\r\n        plan += \" parent:\" + parent;\r\n    }\r\n    return plan;\r\n}","lc":0.0454545455,"pi":-0.3349282297,"ma":0.0,"nbd":-0.5,"ml":0.0,"d":0.6527777778,"mi":-0.1365750529,"fo":0.3333333333,"r":0.0263157895,"e":0.6255977594}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1261_4c4b3e2e","label":3,"code":"\/**\r\n * Multiply the fraction by an integer.\r\n * @param i the {@code integer} to multiply by.\r\n * @return this * i\r\n *\/\r\n@Override\r\npublic Fraction multiply(final int i) {\r\n    return new Fraction(numerator * i, denominator);\r\n}","code_comment":"\/**\r\n * Multiply the fraction by an integer.\r\n * @param i the {@code integer} to multiply by.\r\n * @return this * i\r\n *\/\r\n","code_no_comment":"@Override\r\npublic Fraction multiply(final int i) {\r\n    return new Fraction(numerator * i, denominator);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8396053559,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"Closure","project_version":"164","label":2,"code":"@Override\r\npublic boolean isSubtype(JSType other) {\r\n    if (!(other instanceof ArrowType)) {\r\n        return false;\r\n    }\r\n    ArrowType that = (ArrowType) other;\r\n    \/\/ this.returnType <: that.returnType (covariant)\r\n    if (!this.returnType.isSubtype(that.returnType)) {\r\n        return false;\r\n    }\r\n    \/\/ that.paramType[i] <: this.paramType[i] (contravariant)\r\n    \/\/ \r\n    \/\/ If this.paramType[i] is required,\r\n    \/\/ then that.paramType[i] is required.\r\n    \/\/ \r\n    \/\/ In theory, the \"required-ness\" should work in the other direction as\r\n    \/\/ well. In other words, if we have\r\n    \/\/ \r\n    \/\/ function f(number, number) {}\r\n    \/\/ function g(number) {}\r\n    \/\/ \r\n    \/\/ Then f *should* not be a subtype of g, and g *should* not be\r\n    \/\/ a subtype of f. But in practice, we do not implement it this way.\r\n    \/\/ We want to support the use case where you can pass g where f is\r\n    \/\/ expected, and pretend that g ignores the second argument.\r\n    \/\/ That way, you can have a single \"no-op\" function, and you don't have\r\n    \/\/ to create a new no-op function for every possible type signature.\r\n    \/\/ \r\n    \/\/ So, in this case, g < f, but f !< g\r\n    Node thisParam = parameters.getFirstChild();\r\n    Node thatParam = that.parameters.getFirstChild();\r\n    while (thisParam != null && thatParam != null) {\r\n        JSType thisParamType = thisParam.getJSType();\r\n        JSType thatParamType = thatParam.getJSType();\r\n        if (thisParamType != null) {\r\n            if (thatParamType == null || !thatParamType.isSubtype(thisParamType)) {\r\n                return false;\r\n            }\r\n        }\r\n        boolean thisIsVarArgs = thisParam.isVarArgs();\r\n        boolean thatIsVarArgs = thatParam.isVarArgs();\r\n        \/\/ don't advance if we have variable arguments\r\n        if (!thisIsVarArgs) {\r\n            thisParam = thisParam.getNext();\r\n        }\r\n        if (!thatIsVarArgs) {\r\n            thatParam = thatParam.getNext();\r\n        }\r\n        \/\/ both var_args indicates the end\r\n        if (thisIsVarArgs && thatIsVarArgs) {\r\n            thisParam = null;\r\n            thatParam = null;\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean isSubtype(JSType other) {\r\n    if (!(other instanceof ArrowType)) {\r\n        return false;\r\n    }\r\n    ArrowType that = (ArrowType) other;\r\n        if (!this.returnType.isSubtype(that.returnType)) {\r\n        return false;\r\n    }\r\n                                                                                Node thisParam = parameters.getFirstChild();\r\n    Node thatParam = that.parameters.getFirstChild();\r\n    while (thisParam != null && thatParam != null) {\r\n        JSType thisParamType = thisParam.getJSType();\r\n        JSType thatParamType = thatParam.getJSType();\r\n        if (thisParamType != null) {\r\n            if (thatParamType == null || !thatParamType.isSubtype(thisParamType)) {\r\n                return false;\r\n            }\r\n        }\r\n        boolean thisIsVarArgs = thisParam.isVarArgs();\r\n        boolean thatIsVarArgs = thatParam.isVarArgs();\r\n                if (!thisIsVarArgs) {\r\n            thisParam = thisParam.getNext();\r\n        }\r\n        if (!thatIsVarArgs) {\r\n            thatParam = thatParam.getNext();\r\n        }\r\n                if (thisIsVarArgs && thatIsVarArgs) {\r\n            thisParam = null;\r\n            thatParam = null;\r\n        }\r\n    }\r\n    return true;\r\n}","lc":0.9090909091,"pi":0.3684210526,"ma":1.0,"nbd":0.5,"ml":1.3333333333,"d":1.369047619,"mi":-0.5825229035,"fo":0.3333333333,"r":-0.0263157895,"e":1.5987759548}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1458_91f9bfc7","label":1,"code":"@SuppressWarnings(\"unchecked\")\r\nprivate <OUT, IN1, IN2> TypeInformation<OUT> analyzePojo(Class<OUT> clazz, ArrayList<Type> typeHierarchy, ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\r\n    \/\/ add the hierarchy of the POJO itself if it is generic\r\n    if (parameterizedType != null) {\r\n        getTypeHierarchy(typeHierarchy, parameterizedType, Object.class);\r\n    } else \/\/ create a type hierarchy, if the incoming only contains the most bottom one or none.\r\n    if (typeHierarchy.size() <= 1) {\r\n        getTypeHierarchy(typeHierarchy, clazz, Object.class);\r\n    }\r\n    List<Field> fields = getAllDeclaredFields(clazz);\r\n    List<PojoField> pojoFields = new ArrayList<PojoField>();\r\n    for (Field field : fields) {\r\n        Type fieldType = field.getGenericType();\r\n        if (!isValidPojoField(field, clazz, typeHierarchy)) {\r\n            LOG.warn(\"Class \" + clazz + \" is not a valid POJO type\");\r\n            return null;\r\n        }\r\n        try {\r\n            ArrayList<Type> fieldTypeHierarchy = new ArrayList<Type>(typeHierarchy);\r\n            fieldTypeHierarchy.add(fieldType);\r\n            TypeInformation<?> ti = createTypeInfoWithTypeHierarchy(fieldTypeHierarchy, fieldType, in1Type, in2Type);\r\n            pojoFields.add(new PojoField(field, ti));\r\n        } catch (InvalidTypesException e) {\r\n            Class<?> genericClass = Object.class;\r\n            if (isClassType(fieldType)) {\r\n                genericClass = typeToClass(fieldType);\r\n            }\r\n            pojoFields.add(new PojoField(field, new GenericTypeInfo<OUT>((Class<OUT>) genericClass)));\r\n        }\r\n    }\r\n    CompositeType<OUT> pojoType = new PojoTypeInfo<OUT>(clazz, pojoFields);\r\n    \/\/ \r\n    \/\/ Validate the correctness of the pojo.\r\n    \/\/ returning \"null\" will result create a generic type information.\r\n    \/\/ \r\n    List<Method> methods = getAllDeclaredMethods(clazz);\r\n    for (Method method : methods) {\r\n        if (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\r\n            LOG.warn(\"Class \" + clazz + \" contains custom serialization methods we do not call.\");\r\n            return null;\r\n        }\r\n    }\r\n    \/\/ we cannot use this because the serializer uses it.\r\n    try {\r\n        clazz.getDeclaredConstructor();\r\n    } catch (NoSuchMethodException e) {\r\n        LOG.warn(\"Class \" + clazz + \" must have a default constructor to be used as a POJO.\");\r\n        return null;\r\n    }\r\n    \/\/ everything is checked, we return the pojo\r\n    return pojoType;\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings(\"unchecked\")\r\nprivate <OUT, IN1, IN2> TypeInformation<OUT> analyzePojo(Class<OUT> clazz, ArrayList<Type> typeHierarchy, ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\r\n        if (parameterizedType != null) {\r\n        getTypeHierarchy(typeHierarchy, parameterizedType, Object.class);\r\n    } else     if (typeHierarchy.size() <= 1) {\r\n        getTypeHierarchy(typeHierarchy, clazz, Object.class);\r\n    }\r\n    List<Field> fields = getAllDeclaredFields(clazz);\r\n    List<PojoField> pojoFields = new ArrayList<PojoField>();\r\n    for (Field field : fields) {\r\n        Type fieldType = field.getGenericType();\r\n        if (!isValidPojoField(field, clazz, typeHierarchy)) {\r\n            LOG.warn(\"Class \" + clazz + \" is not a valid POJO type\");\r\n            return null;\r\n        }\r\n        try {\r\n            ArrayList<Type> fieldTypeHierarchy = new ArrayList<Type>(typeHierarchy);\r\n            fieldTypeHierarchy.add(fieldType);\r\n            TypeInformation<?> ti = createTypeInfoWithTypeHierarchy(fieldTypeHierarchy, fieldType, in1Type, in2Type);\r\n            pojoFields.add(new PojoField(field, ti));\r\n        } catch (InvalidTypesException e) {\r\n            Class<?> genericClass = Object.class;\r\n            if (isClassType(fieldType)) {\r\n                genericClass = typeToClass(fieldType);\r\n            }\r\n            pojoFields.add(new PojoField(field, new GenericTypeInfo<OUT>((Class<OUT>) genericClass)));\r\n        }\r\n    }\r\n    CompositeType<OUT> pojoType = new PojoTypeInfo<OUT>(clazz, pojoFields);\r\n                    List<Method> methods = getAllDeclaredMethods(clazz);\r\n    for (Method method : methods) {\r\n        if (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\r\n            LOG.warn(\"Class \" + clazz + \" contains custom serialization methods we do not call.\");\r\n            return null;\r\n        }\r\n    }\r\n        try {\r\n        clazz.getDeclaredConstructor();\r\n    } catch (NoSuchMethodException e) {\r\n        LOG.warn(\"Class \" + clazz + \" must have a default constructor to be used as a POJO.\");\r\n        return null;\r\n    }\r\n        return pojoType;\r\n}","lc":1.4090909091,"pi":0.4306220096,"ma":1.2,"nbd":0.5,"ml":0.9166666667,"d":1.0297619048,"mi":-0.8328400282,"fo":1.25,"r":-0.0263157895,"e":2.9644830945}
{"project_name":"Compress","project_version":"3","label":1,"code":"\/**\r\n * Ends the TAR archive without closing the underlying OutputStream.\r\n *\r\n * An archive consists of a series of file entries terminated by an\r\n * end-of-archive entry, which consists of two 512 blocks of zero bytes.\r\n * POSIX.1 requires two EOF records, like some other implementations.\r\n *\r\n * @throws IOException on error\r\n *\/\r\npublic void finish() throws IOException {\r\n    writeEOFRecord();\r\n    writeEOFRecord();\r\n}","code_comment":"\/**\r\n * Ends the TAR archive without closing the underlying OutputStream.\r\n *\r\n * An archive consists of a series of file entries terminated by an\r\n * end-of-archive entry, which consists of two 512 blocks of zero bytes.\r\n * POSIX.1 requires two EOF records, like some other implementations.\r\n *\r\n * @throws IOException on error\r\n *\/\r\n","code_no_comment":"public void finish() throws IOException {\r\n    writeEOFRecord();\r\n    writeEOFRecord();\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0005637773,"fo":-0.3333333333,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"Closure","project_version":"90","label":2,"code":"@Override\r\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\r\n    setResolvedTypeInternal(this);\r\n    call = (ArrowType) safeResolve(call, t, scope);\r\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\r\n    \/\/ Warning about typeOfThis if it doesn't resolve to an ObjectType\r\n    \/\/ is handled further upstream.\r\n    \/\/ \r\n    \/\/ TODO(nicksantos): Handle this correctly if we have a UnionType.\r\n    \/\/ \r\n    \/\/ TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\r\n    \/\/ activation object. In ES5, it leaves it as null. Just punt on this\r\n    \/\/ issue for now by coercing out null. This is complicated by the\r\n    \/\/ fact that when most people write @this {Foo}, they really don't\r\n    \/\/ mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\r\n    \/\/ the name for them.\r\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\r\n    if (maybeTypeOfThis instanceof ObjectType) {\r\n        typeOfThis = (ObjectType) maybeTypeOfThis;\r\n    }\r\n    boolean changed = false;\r\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\r\n    for (ObjectType iface : implementedInterfaces) {\r\n        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\r\n        resolvedInterfaces.add(resolvedIface);\r\n        changed |= (resolvedIface != iface);\r\n    }\r\n    if (changed) {\r\n        implementedInterfaces = resolvedInterfaces.build();\r\n    }\r\n    if (subTypes != null) {\r\n        for (int i = 0; i < subTypes.size(); i++) {\r\n            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\r\n        }\r\n    }\r\n    return super.resolveInternal(t, scope);\r\n}","code_comment":null,"code_no_comment":"@Override\r\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\r\n    setResolvedTypeInternal(this);\r\n    call = (ArrowType) safeResolve(call, t, scope);\r\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\r\n                                                JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\r\n    if (maybeTypeOfThis instanceof ObjectType) {\r\n        typeOfThis = (ObjectType) maybeTypeOfThis;\r\n    }\r\n    boolean changed = false;\r\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\r\n    for (ObjectType iface : implementedInterfaces) {\r\n        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\r\n        resolvedInterfaces.add(resolvedIface);\r\n        changed |= (resolvedIface != iface);\r\n    }\r\n    if (changed) {\r\n        implementedInterfaces = resolvedInterfaces.build();\r\n    }\r\n    if (subTypes != null) {\r\n        for (int i = 0; i < subTypes.size(); i++) {\r\n            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\r\n        }\r\n    }\r\n    return super.resolveInternal(t, scope);\r\n}","lc":0.5454545455,"pi":-0.0956937799,"ma":0.4,"nbd":0.0,"ml":0.3333333333,"d":0.5138888889,"mi":-0.4652572234,"fo":0.5833333333,"r":-0.0263157895,"e":0.8950490713}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-101_c79a743b","label":1,"code":"\/**\r\n * Create a SyslogAppender.\r\n * @param host The name of the host to connect to.\r\n * @param portNum The port to connect to on the target host.\r\n * @param protocol The Protocol to use.\r\n * @param delay The interval in which failed writes should be retried.\r\n * @param name The name of the Appender.\r\n * @param immediateFlush \"true\" if data should be flushed on each write.\r\n * @param suppress \"true\" if exceptions should be hidden from the application, \"false\" otherwise.\r\n * The default is \"true\".\r\n * @param facility The Facility is used to try to classify the message.\r\n * @param id The default structured data id to use when formatting according to RFC 5424.\r\n * @param ein The IANA enterprise number.\r\n * @param includeMDC Indicates whether data from the ThreadContextMap will be included in the RFC 5424 Syslog\r\n * record. Defaults to \"true:.\r\n * @param mdcId The id to use for the MDC Structured Data Element.\r\n * @param includeNL If true, a newline will be appended to the end of the syslog record. The default is false.\r\n * @param appName The value to use as the APP-NAME in the RFC 5424 syslog record.\r\n * @param msgId The default value to be used in the MSGID field of RFC 5424 syslog records.\r\n * @param excludes A comma separated list of mdc keys that should be excluded from the LogEvent.\r\n * @param includes A comma separated list of mdc keys that should be included in the FlumeEvent.\r\n * @param required A comma separated list of mdc keys that must be present in the MDC.\r\n * @param format If set to \"RFC5424\" the data will be formatted in accordance with RFC 5424. Otherwise,\r\n * it will be formatted as a BSD Syslog record.\r\n * @param filter A Filter to determine if the event should be handled by this Appender.\r\n * @param config The Configuration.\r\n * @param charset The character set to use when converting the syslog String to a byte array.\r\n * @return A SyslogAppender.\r\n *\/\r\n@PluginFactory\r\npublic static SyslogAppender createAppender(@PluginAttr(\"host\") String host, @PluginAttr(\"port\") String portNum, @PluginAttr(\"protocol\") String protocol, @PluginAttr(\"reconnectionDelay\") String delay, @PluginAttr(\"name\") String name, @PluginAttr(\"immediateFlush\") String immediateFlush, @PluginAttr(\"suppressExceptions\") String suppress, @PluginAttr(\"facility\") String facility, @PluginAttr(\"id\") String id, @PluginAttr(\"enterpriseNumber\") String ein, @PluginAttr(\"includeMDC\") String includeMDC, @PluginAttr(\"mdcId\") String mdcId, @PluginAttr(\"newLine\") String includeNL, @PluginAttr(\"appName\") String appName, @PluginAttr(\"messageId\") String msgId, @PluginAttr(\"mdcExcludes\") String excludes, @PluginAttr(\"mdcIncludes\") String includes, @PluginAttr(\"mdcRequired\") String required, @PluginAttr(\"format\") String format, @PluginElement(\"filters\") Filter filter, @PluginConfiguration Configuration config, @PluginAttr(\"charset\") String charset) {\r\n    boolean isFlush = immediateFlush == null ? true : Boolean.valueOf(immediateFlush);\r\n    boolean handleExceptions = suppress == null ? true : Boolean.valueOf(suppress);\r\n    int reconnectDelay = delay == null ? 0 : Integer.parseInt(delay);\r\n    int port = portNum == null ? 0 : Integer.parseInt(portNum);\r\n    Charset c = Charset.isSupported(\"UTF-8\") ? Charset.forName(\"UTF-8\") : Charset.defaultCharset();\r\n    if (charset != null) {\r\n        if (Charset.isSupported(charset)) {\r\n            c = Charset.forName(charset);\r\n        } else {\r\n            LOGGER.error(\"Charset \" + charset + \" is not supported for layout, using \" + c.displayName());\r\n        }\r\n    }\r\n    Layout layout = (format.equalsIgnoreCase(RFC5424)) ? RFC5424Layout.createLayout(facility, id, ein, includeMDC, mdcId, includeNL, appName, msgId, excludes, includes, required, charset, config) : SyslogLayout.createLayout(facility, includeNL, charset);\r\n    if (name == null) {\r\n        LOGGER.error(\"No name provided for SyslogAppender\");\r\n        return null;\r\n    }\r\n    AbstractSocketManager manager = createSocketManager(protocol, host, port, reconnectDelay);\r\n    if (manager == null) {\r\n        return null;\r\n    }\r\n    return new SyslogAppender(name, layout, filter, handleExceptions, isFlush, manager);\r\n}","code_comment":"\/**\r\n * Create a SyslogAppender.\r\n * @param host The name of the host to connect to.\r\n * @param portNum The port to connect to on the target host.\r\n * @param protocol The Protocol to use.\r\n * @param delay The interval in which failed writes should be retried.\r\n * @param name The name of the Appender.\r\n * @param immediateFlush \"true\" if data should be flushed on each write.\r\n * @param suppress \"true\" if exceptions should be hidden from the application, \"false\" otherwise.\r\n * The default is \"true\".\r\n * @param facility The Facility is used to try to classify the message.\r\n * @param id The default structured data id to use when formatting according to RFC 5424.\r\n * @param ein The IANA enterprise number.\r\n * @param includeMDC Indicates whether data from the ThreadContextMap will be included in the RFC 5424 Syslog\r\n * record. Defaults to \"true:.\r\n * @param mdcId The id to use for the MDC Structured Data Element.\r\n * @param includeNL If true, a newline will be appended to the end of the syslog record. The default is false.\r\n * @param appName The value to use as the APP-NAME in the RFC 5424 syslog record.\r\n * @param msgId The default value to be used in the MSGID field of RFC 5424 syslog records.\r\n * @param excludes A comma separated list of mdc keys that should be excluded from the LogEvent.\r\n * @param includes A comma separated list of mdc keys that should be included in the FlumeEvent.\r\n * @param required A comma separated list of mdc keys that must be present in the MDC.\r\n * @param format If set to \"RFC5424\" the data will be formatted in accordance with RFC 5424. Otherwise,\r\n * it will be formatted as a BSD Syslog record.\r\n * @param filter A Filter to determine if the event should be handled by this Appender.\r\n * @param config The Configuration.\r\n * @param charset The character set to use when converting the syslog String to a byte array.\r\n * @return A SyslogAppender.\r\n *\/\r\n","code_no_comment":"@PluginFactory\r\npublic static SyslogAppender createAppender(@PluginAttr(\"host\") String host, @PluginAttr(\"port\") String portNum, @PluginAttr(\"protocol\") String protocol, @PluginAttr(\"reconnectionDelay\") String delay, @PluginAttr(\"name\") String name, @PluginAttr(\"immediateFlush\") String immediateFlush, @PluginAttr(\"suppressExceptions\") String suppress, @PluginAttr(\"facility\") String facility, @PluginAttr(\"id\") String id, @PluginAttr(\"enterpriseNumber\") String ein, @PluginAttr(\"includeMDC\") String includeMDC, @PluginAttr(\"mdcId\") String mdcId, @PluginAttr(\"newLine\") String includeNL, @PluginAttr(\"appName\") String appName, @PluginAttr(\"messageId\") String msgId, @PluginAttr(\"mdcExcludes\") String excludes, @PluginAttr(\"mdcIncludes\") String includes, @PluginAttr(\"mdcRequired\") String required, @PluginAttr(\"format\") String format, @PluginElement(\"filters\") Filter filter, @PluginConfiguration Configuration config, @PluginAttr(\"charset\") String charset) {\r\n    boolean isFlush = immediateFlush == null ? true : Boolean.valueOf(immediateFlush);\r\n    boolean handleExceptions = suppress == null ? true : Boolean.valueOf(suppress);\r\n    int reconnectDelay = delay == null ? 0 : Integer.parseInt(delay);\r\n    int port = portNum == null ? 0 : Integer.parseInt(portNum);\r\n    Charset c = Charset.isSupported(\"UTF-8\") ? Charset.forName(\"UTF-8\") : Charset.defaultCharset();\r\n    if (charset != null) {\r\n        if (Charset.isSupported(charset)) {\r\n            c = Charset.forName(charset);\r\n        } else {\r\n            LOGGER.error(\"Charset \" + charset + \" is not supported for layout, using \" + c.displayName());\r\n        }\r\n    }\r\n    Layout layout = (format.equalsIgnoreCase(RFC5424)) ? RFC5424Layout.createLayout(facility, id, ein, includeMDC, mdcId, includeNL, appName, msgId, excludes, includes, required, charset, config) : SyslogLayout.createLayout(facility, includeNL, charset);\r\n    if (name == null) {\r\n        LOGGER.error(\"No name provided for SyslogAppender\");\r\n        return null;\r\n    }\r\n    AbstractSocketManager manager = createSocketManager(protocol, host, port, reconnectDelay);\r\n    if (manager == null) {\r\n        return null;\r\n    }\r\n    return new SyslogAppender(name, layout, filter, handleExceptions, isFlush, manager);\r\n}","lc":0.5,"pi":0.0526315789,"ma":1.4,"nbd":0.0,"ml":1.25,"d":0.6706349206,"mi":-0.6160676533,"fo":0.8333333333,"r":-0.0263157895,"e":2.9963405428}
{"project_name":"Codec","project_version":"17","label":1,"code":"\/**\r\n * Constructs a new <code>String<\/code> by decoding the specified array of bytes using the ISO-8859-1 charset.\r\n *\r\n * @param bytes\r\n *            The bytes to be decoded into characters, may be <code>null<\/code>\r\n * @return A new <code>String<\/code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\r\n *         <code>null<\/code> if the input byte array was <code>null<\/code>.\r\n * @throws NullPointerException\r\n *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\r\n *             required by the Java platform specification.\r\n * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\r\n *\/\r\npublic static String newStringIso8859_1(final byte[] bytes) {\r\n    return new String(bytes, Charsets.ISO_8859_1);\r\n}","code_comment":"\/**\r\n * Constructs a new <code>String<\/code> by decoding the specified array of bytes using the ISO-8859-1 charset.\r\n *\r\n * @param bytes\r\n *            The bytes to be decoded into characters, may be <code>null<\/code>\r\n * @return A new <code>String<\/code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\r\n *         <code>null<\/code> if the input byte array was <code>null<\/code>.\r\n * @throws NullPointerException\r\n *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\r\n *             required by the Java platform specification.\r\n * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\r\n *\/\r\n","code_no_comment":"public static String newStringIso8859_1(final byte[] bytes) {\r\n    return new String(bytes, Charsets.ISO_8859_1);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0253699789,"fo":-0.5,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3719_5ad32df9","label":1,"code":"\/**\r\n *  Adds a child component to this container.\r\n *\r\n *  @param childs\r\n *             The child(s)\r\n *  @throws IllegalArgumentException\r\n *              Thrown if a child with the same id is replaced by the add operation.\r\n *  @return This\r\n *\/\r\npublic final MarkupContainer add(final Component... childs) {\r\n    for (Component child : childs) {\r\n        if (child == null) {\r\n            throw new IllegalArgumentException(\"argument child may not be null\");\r\n        }\r\n        MarkupContainer parent = getParent();\r\n        while (parent != null) {\r\n            if (child == parent) {\r\n                String msg = \"You can not add a component's parent as child to the component (loop): Component: \" + this.toString(false) + \"; parent == child: \" + parent.toString(false);\r\n                if (child instanceof Border.BorderBodyContainer) {\r\n                    msg += \". Please consider using Border.addToBorder(new \" + this.getClass().getSimpleName() + \"(\\\"\" + this.getId() + \"\\\", ...) instead of add(...)\";\r\n                }\r\n                throw new WicketRuntimeException(msg);\r\n            }\r\n            parent = parent.getParent();\r\n        }\r\n        checkHierarchyChange(child);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Add \" + child.getId() + \" to \" + this);\r\n        }\r\n        \/\/ Add to map\r\n        addedComponent(child);\r\n        if (put(child) != null) {\r\n            throw new IllegalArgumentException(exceptionMessage(\"A child with id '\" + child.getId() + \"' already exists\"));\r\n        }\r\n        \/\/ Page.\r\n        if (getMarkupType() != null) {\r\n            \/\/ Check if the markup is available after the child has been added to the parent\r\n            try {\r\n                \/\/ If not yet triggered, than do now (e.g. Pages)\r\n                if (getMarkup() != null) {\r\n                    internalOnMarkupAttached();\r\n                }\r\n                if (child.getMarkup() != null) {\r\n                    child.internalOnMarkupAttached();\r\n                    \/\/ Tell all children of \"component\" as well\r\n                    if (child instanceof MarkupContainer) {\r\n                        MarkupContainer container = (MarkupContainer) child;\r\n                        container.visitChildren(new IVisitor<Component, Void>() {\r\n\r\n                            public void component(final Component component, final IVisit<Void> visit) {\r\n                                if (component.internalOnMarkupAttached()) {\r\n                                    visit.dontGoDeeper();\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            } catch (WicketRuntimeException exception) {\r\n            \/\/ ignore\r\n            }\r\n        }\r\n    }\r\n    return this;\r\n}","code_comment":"\/**\r\n *  Adds a child component to this container.\r\n *\r\n *  @param childs\r\n *             The child(s)\r\n *  @throws IllegalArgumentException\r\n *              Thrown if a child with the same id is replaced by the add operation.\r\n *  @return This\r\n *\/\r\n","code_no_comment":"public final MarkupContainer add(final Component... childs) {\r\n    for (Component child : childs) {\r\n        if (child == null) {\r\n            throw new IllegalArgumentException(\"argument child may not be null\");\r\n        }\r\n        MarkupContainer parent = getParent();\r\n        while (parent != null) {\r\n            if (child == parent) {\r\n                String msg = \"You can not add a component's parent as child to the component (loop): Component: \" + this.toString(false) + \"; parent == child: \" + parent.toString(false);\r\n                if (child instanceof Border.BorderBodyContainer) {\r\n                    msg += \". Please consider using Border.addToBorder(new \" + this.getClass().getSimpleName() + \"(\\\"\" + this.getId() + \"\\\", ...) instead of add(...)\";\r\n                }\r\n                throw new WicketRuntimeException(msg);\r\n            }\r\n            parent = parent.getParent();\r\n        }\r\n        checkHierarchyChange(child);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Add \" + child.getId() + \" to \" + this);\r\n        }\r\n                addedComponent(child);\r\n        if (put(child) != null) {\r\n            throw new IllegalArgumentException(exceptionMessage(\"A child with id '\" + child.getId() + \"' already exists\"));\r\n        }\r\n                if (getMarkupType() != null) {\r\n                        try {\r\n                                if (getMarkup() != null) {\r\n                    internalOnMarkupAttached();\r\n                }\r\n                if (child.getMarkup() != null) {\r\n                    child.internalOnMarkupAttached();\r\n                                        if (child instanceof MarkupContainer) {\r\n                        MarkupContainer container = (MarkupContainer) child;\r\n                        container.visitChildren(new IVisitor<Component, Void>() {\r\n\r\n                            public void component(final Component component, final IVisit<Void> visit) {\r\n                                if (component.internalOnMarkupAttached()) {\r\n                                    visit.dontGoDeeper();\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            } catch (WicketRuntimeException exception) {\r\n                        }\r\n        }\r\n    }\r\n    return this;\r\n}","lc":1.5454545455,"pi":2.4928229665,"ma":2.6,"nbd":2.5,"ml":1.1666666667,"d":0.4206349206,"mi":-0.8500352361,"fo":1.4166666667,"r":-0.0263157895,"e":1.0242169626}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3021_494da6de","label":1,"code":"@Override\r\npublic Validator childNodeChanged(String name, NodeState before, NodeState after) throws CommitFailedException {\r\n    Tree treeAfter = checkNotNull(parentAfter.getChild(name));\r\n    checkValidTree(parentAfter, treeAfter, after);\r\n    return new AccessControlValidator(this, treeAfter);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Validator childNodeChanged(String name, NodeState before, NodeState after) throws CommitFailedException {\r\n    Tree treeAfter = checkNotNull(parentAfter.getChild(name));\r\n    checkValidTree(parentAfter, treeAfter, after);\r\n    return new AccessControlValidator(this, treeAfter);\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4776603242,"fo":-0.25,"r":0.0,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1402_7792679c","label":1,"code":"@Override\r\npublic PropertiesConfiguration build() {\r\n    Map<String, String> rootProps = new HashMap<>();\r\n    for (String key : rootProperties.stringPropertyNames()) {\r\n        if (!key.contains(\".\")) {\r\n            builder.addRootProperty(key, rootProperties.getProperty(key));\r\n        }\r\n    }\r\n    builder.setStatusLevel(Level.toLevel(rootProperties.getProperty(STATUS_KEY), Level.ERROR)).setShutdownHook(rootProperties.getProperty(SHUTDOWN_HOOK)).setVerbosity(rootProperties.getProperty(VERBOSE)).setPackages(rootProperties.getProperty(PACKAGES)).setConfigurationName(rootProperties.getProperty(CONFIG_NAME)).setMonitorInterval(rootProperties.getProperty(MONITOR_INTERVAL, \"0\")).setAdvertiser(rootProperties.getProperty(ADVERTISER_KEY));\r\n    final Properties propertyPlaceholders = PropertiesUtil.extractSubset(rootProperties, \"property\");\r\n    for (final String key : propertyPlaceholders.stringPropertyNames()) {\r\n        builder.addProperty(key, propertyPlaceholders.getProperty(key));\r\n    }\r\n    final Map<String, Properties> scripts = PropertiesUtil.partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties, \"script\"));\r\n    for (final Map.Entry<String, Properties> entry : scripts.entrySet()) {\r\n        final Properties scriptProps = entry.getValue();\r\n        final String type = (String) scriptProps.remove(\"type\");\r\n        if (type == null) {\r\n            throw new ConfigurationException(\"No type provided for script - must be Script or ScriptFile\");\r\n        }\r\n        if (type.equalsIgnoreCase(\"script\")) {\r\n            builder.add(createScript(scriptProps));\r\n        } else {\r\n            builder.add(createScriptFile(scriptProps));\r\n        }\r\n    }\r\n    final Properties levelProps = PropertiesUtil.extractSubset(rootProperties, \"customLevel\");\r\n    if (levelProps.size() > 0) {\r\n        for (final String key : levelProps.stringPropertyNames()) {\r\n            builder.add(builder.newCustomLevel(key, Integer.parseInt(levelProps.getProperty(key))));\r\n        }\r\n    }\r\n    final Map<String, Properties> filters = PropertiesUtil.partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties, \"filter\"));\r\n    for (final Map.Entry<String, Properties> entry : filters.entrySet()) {\r\n        builder.add(createFilter(entry.getKey().trim(), entry.getValue()));\r\n    }\r\n    final Map<String, Properties> appenders = PropertiesUtil.partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties, \"appender\"));\r\n    for (final Map.Entry<String, Properties> entry : appenders.entrySet()) {\r\n        builder.add(createAppender(entry.getKey().trim(), entry.getValue()));\r\n    }\r\n    final Map<String, Properties> loggers = PropertiesUtil.partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties, \"logger\"));\r\n    for (final Map.Entry<String, Properties> entry : loggers.entrySet()) {\r\n        final String name = entry.getKey().trim();\r\n        if (!name.equals(LoggerConfig.ROOT)) {\r\n            builder.add(createLogger(name, entry.getValue()));\r\n        }\r\n    }\r\n    final Properties props = PropertiesUtil.extractSubset(rootProperties, \"rootLogger\");\r\n    if (props.size() > 0) {\r\n        builder.add(createRootLogger(props));\r\n    }\r\n    return builder.build(false);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic PropertiesConfiguration build() {\r\n    Map<String, String> rootProps = new HashMap<>();\r\n    for (String key : rootProperties.stringPropertyNames()) {\r\n        if (!key.contains(\".\")) {\r\n            builder.addRootProperty(key, rootProperties.getProperty(key));\r\n        }\r\n    }\r\n    builder.setStatusLevel(Level.toLevel(rootProperties.getProperty(STATUS_KEY), Level.ERROR)).setShutdownHook(rootProperties.getProperty(SHUTDOWN_HOOK)).setVerbosity(rootProperties.getProperty(VERBOSE)).setPackages(rootProperties.getProperty(PACKAGES)).setConfigurationName(rootProperties.getProperty(CONFIG_NAME)).setMonitorInterval(rootProperties.getProperty(MONITOR_INTERVAL, \"0\")).setAdvertiser(rootProperties.getProperty(ADVERTISER_KEY));\r\n    final Properties propertyPlaceholders = PropertiesUtil.extractSubset(rootProperties, \"property\");\r\n    for (final String key : propertyPlaceholders.stringPropertyNames()) {\r\n        builder.addProperty(key, propertyPlaceholders.getProperty(key));\r\n    }\r\n    final Map<String, Properties> scripts = PropertiesUtil.partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties, \"script\"));\r\n    for (final Map.Entry<String, Properties> entry : scripts.entrySet()) {\r\n        final Properties scriptProps = entry.getValue();\r\n        final String type = (String) scriptProps.remove(\"type\");\r\n        if (type == null) {\r\n            throw new ConfigurationException(\"No type provided for script - must be Script or ScriptFile\");\r\n        }\r\n        if (type.equalsIgnoreCase(\"script\")) {\r\n            builder.add(createScript(scriptProps));\r\n        } else {\r\n            builder.add(createScriptFile(scriptProps));\r\n        }\r\n    }\r\n    final Properties levelProps = PropertiesUtil.extractSubset(rootProperties, \"customLevel\");\r\n    if (levelProps.size() > 0) {\r\n        for (final String key : levelProps.stringPropertyNames()) {\r\n            builder.add(builder.newCustomLevel(key, Integer.parseInt(levelProps.getProperty(key))));\r\n        }\r\n    }\r\n    final Map<String, Properties> filters = PropertiesUtil.partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties, \"filter\"));\r\n    for (final Map.Entry<String, Properties> entry : filters.entrySet()) {\r\n        builder.add(createFilter(entry.getKey().trim(), entry.getValue()));\r\n    }\r\n    final Map<String, Properties> appenders = PropertiesUtil.partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties, \"appender\"));\r\n    for (final Map.Entry<String, Properties> entry : appenders.entrySet()) {\r\n        builder.add(createAppender(entry.getKey().trim(), entry.getValue()));\r\n    }\r\n    final Map<String, Properties> loggers = PropertiesUtil.partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties, \"logger\"));\r\n    for (final Map.Entry<String, Properties> entry : loggers.entrySet()) {\r\n        final String name = entry.getKey().trim();\r\n        if (!name.equals(LoggerConfig.ROOT)) {\r\n            builder.add(createLogger(name, entry.getValue()));\r\n        }\r\n    }\r\n    final Properties props = PropertiesUtil.extractSubset(rootProperties, \"rootLogger\");\r\n    if (props.size() > 0) {\r\n        builder.add(createRootLogger(props));\r\n    }\r\n    return builder.build(false);\r\n}","lc":1.7727272727,"pi":0.038277512,"ma":2.2,"nbd":0.0,"ml":0.5833333333,"d":0.7718253968,"mi":-1.015503876,"fo":5.3333333333,"r":-0.0263157895,"e":4.0995579837}
{"project_name":"Math","project_version":"66","label":1,"code":"public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    clearResult();\r\n    return localMin(getGoalType() == GoalType.MINIMIZE, f, goalType, min, startValue, max, getRelativeAccuracy(), getAbsoluteAccuracy());\r\n}","code_comment":null,"code_no_comment":"public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    clearResult();\r\n    return localMin(getGoalType() == GoalType.MINIMIZE, f, goalType, min, startValue, max, getRelativeAccuracy(), getAbsoluteAccuracy());\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6628611698,"fo":-0.0833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5968_8b7946d8","label":1,"code":"\/**\r\n *  {@inheritDoc}\r\n *\r\n *  Checks for {@link IResourceStreamReference} in the cache and returns <code>null<\/code> if the\r\n *  result is {@link NullResourceStreamReference#INSTANCE}, or {@link FileResourceStream} \/\r\n *  {@link UrlResourceStream} if there is an entry in the cache. Otherwise asks the delegate to\r\n *  find one and puts it in the cache.\r\n *\/\r\n@Override\r\npublic IResourceStream locate(Class<?> clazz, String path) {\r\n    CacheKey key = new CacheKey(clazz.getName(), path, null, null, null, null);\r\n    IResourceStreamReference resourceStreamReference = cache.get(key);\r\n    final IResourceStream result;\r\n    if (resourceStreamReference == null) {\r\n        result = delegate.locate(clazz, path);\r\n        updateCache(key, result);\r\n    } else {\r\n        result = resourceStreamReference.getReference();\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n *  {@inheritDoc}\r\n *\r\n *  Checks for {@link IResourceStreamReference} in the cache and returns <code>null<\/code> if the\r\n *  result is {@link NullResourceStreamReference#INSTANCE}, or {@link FileResourceStream} \/\r\n *  {@link UrlResourceStream} if there is an entry in the cache. Otherwise asks the delegate to\r\n *  find one and puts it in the cache.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic IResourceStream locate(Class<?> clazz, String path) {\r\n    CacheKey key = new CacheKey(clazz.getName(), path, null, null, null, null);\r\n    IResourceStreamReference resourceStreamReference = cache.get(key);\r\n    final IResourceStream result;\r\n    if (resourceStreamReference == null) {\r\n        result = delegate.locate(clazz, path);\r\n        updateCache(key, result);\r\n    } else {\r\n        result = resourceStreamReference.getReference();\r\n    }\r\n    return result;\r\n}","lc":-0.0454545455,"pi":-0.1291866029,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.0218253968,"mi":0.0195912615,"fo":-0.0833333333,"r":-0.0263157895,"e":0.013607418}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1093_7cfbc0da","label":1,"code":"\/**\r\n * Add an arc limit to a BSP tree under construction.\r\n * @param tree BSP tree under construction\r\n * @param alpha arc limit\r\n * @param isStart if true, the limit is the start of an arc\r\n *\/\r\nprivate void addArcLimit(final BSPTree<Sphere1D> tree, final double alpha, final boolean isStart) {\r\n    final LimitAngle limit = new LimitAngle(new S1Point(alpha), !isStart, getTolerance());\r\n    final BSPTree<Sphere1D> node = tree.getCell(limit.getLocation(), getTolerance());\r\n    if (node.getCut() != null) {\r\n        \/\/ we find again an already added limit,\r\n        \/\/ this means we have done a full turn around the circle\r\n        leafBefore(node).setAttribute(Boolean.valueOf(!isStart));\r\n    } else {\r\n        \/\/ it's a new node\r\n        node.insertCut(limit);\r\n        node.setAttribute(null);\r\n        node.getPlus().setAttribute(Boolean.FALSE);\r\n        node.getMinus().setAttribute(Boolean.TRUE);\r\n    }\r\n}","code_comment":"\/**\r\n * Add an arc limit to a BSP tree under construction.\r\n * @param tree BSP tree under construction\r\n * @param alpha arc limit\r\n * @param isStart if true, the limit is the start of an arc\r\n *\/\r\n","code_no_comment":"private void addArcLimit(final BSPTree<Sphere1D> tree, final double alpha, final boolean isStart) {\r\n    final LimitAngle limit = new LimitAngle(new S1Point(alpha), !isStart, getTolerance());\r\n    final BSPTree<Sphere1D> node = tree.getCell(limit.getLocation(), getTolerance());\r\n    if (node.getCut() != null) {\r\n                        leafBefore(node).setAttribute(Boolean.valueOf(!isStart));\r\n    } else {\r\n                node.insertCut(limit);\r\n        node.setAttribute(null);\r\n        node.getPlus().setAttribute(Boolean.FALSE);\r\n        node.getMinus().setAttribute(Boolean.TRUE);\r\n    }\r\n}","lc":-0.0909090909,"pi":-0.04784689,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.0079365079,"mi":0.0204369274,"fo":0.6666666667,"r":-0.0263157895,"e":0.0538787365}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5916_def03add","label":1,"code":"\/**\r\n *  Gets the attached status of this model instance\r\n *\r\n *  @return true if the model is attached, false otherwise\r\n *\/\r\npublic final boolean isAttached() {\r\n    return attached;\r\n}","code_comment":"\/**\r\n *  Gets the attached status of this model instance\r\n *\r\n *  @return true if the model is attached, false otherwise\r\n *\/\r\n","code_no_comment":"public final boolean isAttached() {\r\n    return attached;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.2407329105,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"Cli","project_version":"2","label":0,"code":"\/**\r\n * <p>Breaks <code>token<\/code> into its constituent parts\r\n * using the following algorithm.\r\n * <ul>\r\n *  <li>ignore the first character (\"<b>-<\/b>\")<\/li>\r\n *  <li>foreach remaining character check if an {@link Option}\r\n *  exists with that id.<\/li>\r\n *  <li>if an {@link Option} does exist then add that character\r\n *  prepended with \"<b>-<\/b>\" to the list of processed tokens.<\/li>\r\n *  <li>if the {@link Option} can have an argument value and there\r\n *  are remaining characters in the token then add the remaining\r\n *  characters as a token to the list of processed tokens.<\/li>\r\n *  <li>if an {@link Option} does <b>NOT<\/b> exist <b>AND<\/b>\r\n *  <code>stopAtNonOption<\/code> <b>IS<\/b> set then add the special token\r\n *  \"<b>--<\/b>\" followed by the remaining characters and also\r\n *  the remaining tokens directly to the processed tokens list.<\/li>\r\n *  <li>if an {@link Option} does <b>NOT<\/b> exist <b>AND<\/b>\r\n *  <code>stopAtNonOption<\/code> <b>IS NOT<\/b> set then add that\r\n *  character prepended with \"<b>-<\/b>\".<\/li>\r\n * <\/ul>\r\n * <\/p>\r\n *\r\n * @param token The current token to be <b>burst<\/b>\r\n * @param stopAtNonOption Specifies whether to stop processing\r\n * at the first non-Option encountered.\r\n *\/\r\nprotected void burstToken(String token, boolean stopAtNonOption) {\r\n    int tokenLength = token.length();\r\n    for (int i = 1; i < tokenLength; i++) {\r\n        String ch = String.valueOf(token.charAt(i));\r\n        boolean hasOption = options.hasOption(ch);\r\n        if (hasOption) {\r\n            tokens.add(\"-\" + ch);\r\n            currentOption = options.getOption(ch);\r\n            if (currentOption.hasArg() && (token.length() != (i + 1))) {\r\n                tokens.add(token.substring(i + 1));\r\n                break;\r\n            }\r\n        } else if (stopAtNonOption) {\r\n            process(token.substring(i));\r\n        } else {\r\n            tokens.add(\"-\" + ch);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * <p>Breaks <code>token<\/code> into its constituent parts\r\n * using the following algorithm.\r\n * <ul>\r\n *  <li>ignore the first character (\"<b>-<\/b>\")<\/li>\r\n *  <li>foreach remaining character check if an {@link Option}\r\n *  exists with that id.<\/li>\r\n *  <li>if an {@link Option} does exist then add that character\r\n *  prepended with \"<b>-<\/b>\" to the list of processed tokens.<\/li>\r\n *  <li>if the {@link Option} can have an argument value and there\r\n *  are remaining characters in the token then add the remaining\r\n *  characters as a token to the list of processed tokens.<\/li>\r\n *  <li>if an {@link Option} does <b>NOT<\/b> exist <b>AND<\/b>\r\n *  <code>stopAtNonOption<\/code> <b>IS<\/b> set then add the special token\r\n *  \"<b>--<\/b>\" followed by the remaining characters and also\r\n *  the remaining tokens directly to the processed tokens list.<\/li>\r\n *  <li>if an {@link Option} does <b>NOT<\/b> exist <b>AND<\/b>\r\n *  <code>stopAtNonOption<\/code> <b>IS NOT<\/b> set then add that\r\n *  character prepended with \"<b>-<\/b>\".<\/li>\r\n * <\/ul>\r\n * <\/p>\r\n *\r\n * @param token The current token to be <b>burst<\/b>\r\n * @param stopAtNonOption Specifies whether to stop processing\r\n * at the first non-Option encountered.\r\n *\/\r\n","code_no_comment":"protected void burstToken(String token, boolean stopAtNonOption) {\r\n    int tokenLength = token.length();\r\n    for (int i = 1; i < tokenLength; i++) {\r\n        String ch = String.valueOf(token.charAt(i));\r\n        boolean hasOption = options.hasOption(ch);\r\n        if (hasOption) {\r\n            tokens.add(\"-\" + ch);\r\n            currentOption = options.getOption(ch);\r\n            if (currentOption.hasArg() && (token.length() != (i + 1))) {\r\n                tokens.add(token.substring(i + 1));\r\n                break;\r\n            }\r\n        } else if (stopAtNonOption) {\r\n            process(token.substring(i));\r\n        } else {\r\n            tokens.add(\"-\" + ch);\r\n        }\r\n    }\r\n}","lc":0.2272727273,"pi":0.7416267943,"ma":0.4,"nbd":0.5,"ml":0.5,"d":1.0952380952,"mi":-0.2524312896,"fo":0.5833333333,"r":-0.0263157895,"e":0.9306731672}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-864_abe53a53","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected PointValuePair doOptimize() {\r\n    checkParameters();\r\n    \/\/ -------------------- Initialization --------------------------------\r\n    isMinimize = getGoalType().equals(GoalType.MINIMIZE);\r\n    final FitnessFunction fitfun = new FitnessFunction();\r\n    final double[] guess = fitfun.encode(getStartPoint());\r\n    \/\/ number of objective variables\/problem dimension\r\n    dimension = guess.length;\r\n    initializeCMA(guess);\r\n    iterations = 0;\r\n    double bestValue = fitfun.value(guess);\r\n    push(fitnessHistory, bestValue);\r\n    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);\r\n    PointValuePair lastResult = null;\r\n    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {\r\n        \/\/ Generate and evaluate lambda offspring\r\n        RealMatrix arz = randn1(dimension, lambda);\r\n        RealMatrix arx = zeros(dimension, lambda);\r\n        double[] fitness = new double[lambda];\r\n        \/\/ generate random offspring\r\n        for (int k = 0; k < lambda; k++) {\r\n            RealMatrix arxk = null;\r\n            for (int i = 0; i < checkFeasableCount + 1; i++) {\r\n                if (diagonalOnly <= 0) {\r\n                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(\/\/ m + sig * Normal(0,C)\r\n                    sigma));\r\n                } else {\r\n                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));\r\n                }\r\n                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\r\n                    break;\r\n                }\r\n                \/\/ regenerate random arguments for row\r\n                arz.setColumn(k, randn(dimension));\r\n            }\r\n            copyColumn(arxk, 0, arx, k);\r\n            try {\r\n                \/\/ compute fitness\r\n                fitness[k] = fitfun.value(arx.getColumn(k));\r\n            } catch (TooManyEvaluationsException e) {\r\n                break generationLoop;\r\n            }\r\n        }\r\n        \/\/ Sort by fitness and compute weighted mean into xmean\r\n        int[] arindex = sortedIndices(fitness);\r\n        \/\/ Calculate new xmean, this is selection and recombination\r\n        \/\/ for speed up of Eq. (2) and (3)\r\n        RealMatrix xold = xmean;\r\n        RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\r\n        xmean = bestArx.multiply(weights);\r\n        RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\r\n        RealMatrix zmean = bestArz.multiply(weights);\r\n        boolean hsig = updateEvolutionPaths(zmean, xold);\r\n        if (diagonalOnly <= 0) {\r\n            updateCovariance(hsig, bestArx, arz, arindex, xold);\r\n        } else {\r\n            updateCovarianceDiagonalOnly(hsig, bestArz, xold);\r\n        }\r\n        \/\/ Adapt step size sigma - Eq. (5)\r\n        sigma *= Math.exp(Math.min(1.0, (normps \/ chiN - 1.) * cs \/ damps));\r\n        double bestFitness = fitness[arindex[0]];\r\n        double worstFitness = fitness[arindex[arindex.length - 1]];\r\n        if (bestValue > bestFitness) {\r\n            bestValue = bestFitness;\r\n            lastResult = optimum;\r\n            optimum = new PointValuePair(fitfun.decode(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);\r\n            if (getConvergenceChecker() != null && lastResult != null) {\r\n                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\r\n                    break generationLoop;\r\n                }\r\n            }\r\n        }\r\n        \/\/ Break, if fitness is good enough\r\n        if (stopFitness != 0) {\r\n            \/\/ only if stopFitness is defined\r\n            if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\r\n                break generationLoop;\r\n            }\r\n        }\r\n        double[] sqrtDiagC = sqrt(diagC).getColumn(0);\r\n        double[] pcCol = pc.getColumn(0);\r\n        for (int i = 0; i < dimension; i++) {\r\n            if (sigma * (Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {\r\n                break;\r\n            }\r\n            if (i >= dimension - 1) {\r\n                break generationLoop;\r\n            }\r\n        }\r\n        for (int i = 0; i < dimension; i++) {\r\n            if (sigma * sqrtDiagC[i] > stopTolUpX) {\r\n                break generationLoop;\r\n            }\r\n        }\r\n        double historyBest = min(fitnessHistory);\r\n        double historyWorst = max(fitnessHistory);\r\n        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {\r\n            break generationLoop;\r\n        }\r\n        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {\r\n            break generationLoop;\r\n        }\r\n        \/\/ condition number of the covariance matrix exceeds 1e14\r\n        if (max(diagD) \/ min(diagD) > 1e7) {\r\n            break generationLoop;\r\n        }\r\n        \/\/ user defined termination\r\n        if (getConvergenceChecker() != null) {\r\n            PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);\r\n            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {\r\n                break generationLoop;\r\n            }\r\n            lastResult = current;\r\n        }\r\n        \/\/ Adjust step size in case of equal function values (flat fitness)\r\n        if (bestValue == fitness[arindex[(int) (0.1 + lambda \/ 4.)]]) {\r\n            sigma = sigma * Math.exp(0.2 + cs \/ damps);\r\n        }\r\n        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {\r\n            sigma = sigma * Math.exp(0.2 + cs \/ damps);\r\n        }\r\n        \/\/ store best in history\r\n        push(fitnessHistory, bestFitness);\r\n        fitfun.setValueRange(worstFitness - bestFitness);\r\n        if (generateStatistics) {\r\n            statisticsSigmaHistory.add(sigma);\r\n            statisticsFitnessHistory.add(bestFitness);\r\n            statisticsMeanHistory.add(xmean.transpose());\r\n            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\r\n        }\r\n    }\r\n    return optimum;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected PointValuePair doOptimize() {\r\n    checkParameters();\r\n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\r\n    final FitnessFunction fitfun = new FitnessFunction();\r\n    final double[] guess = fitfun.encode(getStartPoint());\r\n        dimension = guess.length;\r\n    initializeCMA(guess);\r\n    iterations = 0;\r\n    double bestValue = fitfun.value(guess);\r\n    push(fitnessHistory, bestValue);\r\n    PointValuePair optimum = new PointValuePair(getStartPoint(), isMinimize ? bestValue : -bestValue);\r\n    PointValuePair lastResult = null;\r\n    generationLoop: for (iterations = 1; iterations <= maxIterations; iterations++) {\r\n                RealMatrix arz = randn1(dimension, lambda);\r\n        RealMatrix arx = zeros(dimension, lambda);\r\n        double[] fitness = new double[lambda];\r\n                for (int k = 0; k < lambda; k++) {\r\n            RealMatrix arxk = null;\r\n            for (int i = 0; i < checkFeasableCount + 1; i++) {\r\n                if (diagonalOnly <= 0) {\r\n                    arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(                    sigma));\r\n                } else {\r\n                    arxk = xmean.add(times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));\r\n                }\r\n                if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\r\n                    break;\r\n                }\r\n                                arz.setColumn(k, randn(dimension));\r\n            }\r\n            copyColumn(arxk, 0, arx, k);\r\n            try {\r\n                                fitness[k] = fitfun.value(arx.getColumn(k));\r\n            } catch (TooManyEvaluationsException e) {\r\n                break generationLoop;\r\n            }\r\n        }\r\n                int[] arindex = sortedIndices(fitness);\r\n                        RealMatrix xold = xmean;\r\n        RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\r\n        xmean = bestArx.multiply(weights);\r\n        RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\r\n        RealMatrix zmean = bestArz.multiply(weights);\r\n        boolean hsig = updateEvolutionPaths(zmean, xold);\r\n        if (diagonalOnly <= 0) {\r\n            updateCovariance(hsig, bestArx, arz, arindex, xold);\r\n        } else {\r\n            updateCovarianceDiagonalOnly(hsig, bestArz, xold);\r\n        }\r\n                sigma *= Math.exp(Math.min(1.0, (normps \/ chiN - 1.) * cs \/ damps));\r\n        double bestFitness = fitness[arindex[0]];\r\n        double worstFitness = fitness[arindex[arindex.length - 1]];\r\n        if (bestValue > bestFitness) {\r\n            bestValue = bestFitness;\r\n            lastResult = optimum;\r\n            optimum = new PointValuePair(fitfun.decode(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);\r\n            if (getConvergenceChecker() != null && lastResult != null) {\r\n                if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\r\n                    break generationLoop;\r\n                }\r\n            }\r\n        }\r\n                if (stopFitness != 0) {\r\n                        if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\r\n                break generationLoop;\r\n            }\r\n        }\r\n        double[] sqrtDiagC = sqrt(diagC).getColumn(0);\r\n        double[] pcCol = pc.getColumn(0);\r\n        for (int i = 0; i < dimension; i++) {\r\n            if (sigma * (Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {\r\n                break;\r\n            }\r\n            if (i >= dimension - 1) {\r\n                break generationLoop;\r\n            }\r\n        }\r\n        for (int i = 0; i < dimension; i++) {\r\n            if (sigma * sqrtDiagC[i] > stopTolUpX) {\r\n                break generationLoop;\r\n            }\r\n        }\r\n        double historyBest = min(fitnessHistory);\r\n        double historyWorst = max(fitnessHistory);\r\n        if (iterations > 2 && Math.max(historyWorst, worstFitness) - Math.min(historyBest, bestFitness) < stopTolFun) {\r\n            break generationLoop;\r\n        }\r\n        if (iterations > fitnessHistory.length && historyWorst - historyBest < stopTolHistFun) {\r\n            break generationLoop;\r\n        }\r\n                if (max(diagD) \/ min(diagD) > 1e7) {\r\n            break generationLoop;\r\n        }\r\n                if (getConvergenceChecker() != null) {\r\n            PointValuePair current = new PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);\r\n            if (lastResult != null && getConvergenceChecker().converged(iterations, current, lastResult)) {\r\n                break generationLoop;\r\n            }\r\n            lastResult = current;\r\n        }\r\n                if (bestValue == fitness[arindex[(int) (0.1 + lambda \/ 4.)]]) {\r\n            sigma = sigma * Math.exp(0.2 + cs \/ damps);\r\n        }\r\n        if (iterations > 2 && Math.max(historyWorst, bestFitness) - Math.min(historyBest, bestFitness) == 0) {\r\n            sigma = sigma * Math.exp(0.2 + cs \/ damps);\r\n        }\r\n                push(fitnessHistory, bestFitness);\r\n        fitfun.setValueRange(worstFitness - bestFitness);\r\n        if (generateStatistics) {\r\n            statisticsSigmaHistory.add(sigma);\r\n            statisticsFitnessHistory.add(bestFitness);\r\n            statisticsMeanHistory.add(xmean.transpose());\r\n            statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\r\n        }\r\n    }\r\n    return optimum;\r\n}","lc":4.7272727273,"pi":0.6220095694,"ma":7.4,"nbd":1.0,"ml":5.5833333333,"d":4.0912698413,"mi":-1.6553911205,"fo":5.4166666667,"r":-0.0263157895,"e":34.2329097584}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1008_0c20bfd8","label":1,"code":"private void loadImplementationsInBundle(final Test test, final String packageName) {\r\n    \/\/ Do not remove the cast on the next line as removing it will cause a compile error on Java 7.\r\n    @SuppressWarnings(\"RedundantCast\")\r\n    final BundleWiring wiring = (BundleWiring) FrameworkUtil.getBundle(ResolverUtil.class).adapt(BundleWiring.class);\r\n    @SuppressWarnings(\"unchecked\")\r\n    final Collection<String> list = (Collection<String>) wiring.listResources(packageName, \"*.class\", BundleWiring.LISTRESOURCES_RECURSE);\r\n    for (final String name : list) {\r\n        addIfMatching(test, name);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void loadImplementationsInBundle(final Test test, final String packageName) {\r\n        @SuppressWarnings(\"RedundantCast\")\r\n    final BundleWiring wiring = (BundleWiring) FrameworkUtil.getBundle(ResolverUtil.class).adapt(BundleWiring.class);\r\n    @SuppressWarnings(\"unchecked\")\r\n    final Collection<String> list = (Collection<String>) wiring.listResources(packageName, \"*.class\", BundleWiring.LISTRESOURCES_RECURSE);\r\n    for (final String name : list) {\r\n        addIfMatching(test, name);\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.3444976077,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.2107117689,"fo":-0.1666666667,"r":0.0,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8227_54d7fc59","label":3,"code":"@Override\r\nprotected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {\r\n    \/\/ here we iterate the recipient lists and create the exchange pair for each of those\r\n    List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>();\r\n    \/\/ at first we must lookup the endpoint and acquire the producer which can send to the endpoint\r\n    int index = 0;\r\n    while (iter.hasNext()) {\r\n        Object recipient = iter.next();\r\n        Endpoint endpoint;\r\n        Producer producer;\r\n        ExchangePattern pattern;\r\n        try {\r\n            endpoint = resolveEndpoint(exchange, recipient);\r\n            pattern = resolveExchangePattern(exchange, recipient);\r\n            producer = producerCache.acquireProducer(endpoint);\r\n        } catch (Exception e) {\r\n            if (isIgnoreInvalidEndpoints()) {\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Endpoint uri is invalid: \" + recipient + \". This exception will be ignored.\", e);\r\n                }\r\n                continue;\r\n            } else {\r\n                \/\/ failure so break out\r\n                throw e;\r\n            }\r\n        }\r\n        \/\/ then create the exchange pair\r\n        result.add(createProcessorExchangePair(index++, endpoint, producer, exchange, pattern));\r\n    }\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {\r\n        List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>();\r\n        int index = 0;\r\n    while (iter.hasNext()) {\r\n        Object recipient = iter.next();\r\n        Endpoint endpoint;\r\n        Producer producer;\r\n        ExchangePattern pattern;\r\n        try {\r\n            endpoint = resolveEndpoint(exchange, recipient);\r\n            pattern = resolveExchangePattern(exchange, recipient);\r\n            producer = producerCache.acquireProducer(endpoint);\r\n        } catch (Exception e) {\r\n            if (isIgnoreInvalidEndpoints()) {\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Endpoint uri is invalid: \" + recipient + \". This exception will be ignored.\", e);\r\n                }\r\n                continue;\r\n            } else {\r\n                                throw e;\r\n            }\r\n        }\r\n                result.add(createProcessorExchangePair(index++, endpoint, producer, exchange, pattern));\r\n    }\r\n    return result;\r\n}","lc":0.5909090909,"pi":1.0861244019,"ma":0.6,"nbd":1.0,"ml":0.0833333333,"d":-0.0436507937,"mi":-0.4365045807,"fo":0.3333333333,"r":-0.0263157895,"e":0.1077643886}
{"project_name":"Math","project_version":"36","label":1,"code":"\/**\r\n * <p>\r\n * Gets the fraction as a <tt>float<\/tt>. This calculates the fraction as\r\n * the numerator divided by denominator.\r\n * <\/p>\r\n *\r\n * @return the fraction as a <tt>float<\/tt>.\r\n * @see java.lang.Number#floatValue()\r\n *\/\r\n@Override\r\npublic float floatValue() {\r\n    float result = numerator.floatValue() \/ denominator.floatValue();\r\n    \/\/ Calculate how far to shift them to put them in range.\r\n    return result;\r\n}","code_comment":"\/**\r\n * <p>\r\n * Gets the fraction as a <tt>float<\/tt>. This calculates the fraction as\r\n * the numerator divided by denominator.\r\n * <\/p>\r\n *\r\n * @return the fraction as a <tt>float<\/tt>.\r\n * @see java.lang.Number#floatValue()\r\n *\/\r\n","code_no_comment":"@Override\r\npublic float floatValue() {\r\n    float result = numerator.floatValue() \/ denominator.floatValue();\r\n        return result;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.0674603175,"mi":0.7237491191,"fo":-0.3333333333,"r":2.3947368421,"e":-0.1399722227}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4877_6470c3f7","label":3,"code":"\/**\r\n *  Parses the given URL string.\r\n *\r\n *  @param _url\r\n *             absolute or relative url with query string\r\n *  @param charset\r\n *  @return Url object\r\n *\/\r\npublic static Url parse(CharSequence _url, Charset charset) {\r\n    Args.notNull(_url, \"_url\");\r\n    final Url result = new Url(charset);\r\n    \/\/ the url object resolved the charset, use that\r\n    charset = result.getCharset();\r\n    String url = _url.toString();\r\n    \/\/ extract query string part\r\n    final String queryString;\r\n    final String absoluteUrl;\r\n    final int queryAt = url.indexOf('?');\r\n    if (queryAt == -1) {\r\n        queryString = \"\";\r\n        absoluteUrl = url;\r\n    } else {\r\n        absoluteUrl = url.substring(0, queryAt);\r\n        queryString = url.substring(queryAt + 1);\r\n    }\r\n    \/\/ get absolute \/ relative part of url\r\n    String relativeUrl;\r\n    \/\/ absolute urls contain a scheme:\/\/\r\n    final int idxOfFirstSlash = absoluteUrl.indexOf('\/');\r\n    final int protocolAt = absoluteUrl.indexOf(\":\/\/\");\r\n    if (protocolAt > -1 && (protocolAt < idxOfFirstSlash)) {\r\n        result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\r\n        final String afterProto = absoluteUrl.substring(protocolAt + 3);\r\n        final String hostAndPort;\r\n        final int relativeAt = afterProto.indexOf('\/');\r\n        if (relativeAt == -1) {\r\n            relativeUrl = \"\";\r\n            hostAndPort = afterProto;\r\n        } else {\r\n            relativeUrl = afterProto.substring(relativeAt);\r\n            hostAndPort = afterProto.substring(0, relativeAt);\r\n        }\r\n        final int portAt = hostAndPort.lastIndexOf(':');\r\n        if (portAt == -1) {\r\n            result.host = hostAndPort;\r\n            result.port = getDefaultPortForProtocol(result.protocol);\r\n        } else {\r\n            result.host = hostAndPort.substring(0, portAt);\r\n            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\r\n        }\r\n        if (relativeAt < 0) {\r\n            relativeUrl = \"\/\";\r\n        }\r\n    } else {\r\n        relativeUrl = absoluteUrl;\r\n    }\r\n    if (relativeUrl.length() > 0) {\r\n        boolean removeLast = false;\r\n        if (relativeUrl.endsWith(\"\/\")) {\r\n            \/\/ we need to append something and remove it after splitting\r\n            \/\/ because otherwise the\r\n            \/\/ trailing slashes will be lost\r\n            relativeUrl += \"\/x\";\r\n            removeLast = true;\r\n        }\r\n        String[] segmentArray = Strings.split(relativeUrl, '\/');\r\n        if (removeLast) {\r\n            segmentArray[segmentArray.length - 1] = null;\r\n        }\r\n        for (String s : segmentArray) {\r\n            if (s != null) {\r\n                result.segments.add(decodeSegment(s, charset));\r\n            }\r\n        }\r\n    }\r\n    if (queryString.length() > 0) {\r\n        String[] queryArray = Strings.split(queryString, '&');\r\n        for (String s : queryArray) {\r\n            if (Strings.isEmpty(s) == false) {\r\n                result.parameters.add(parseQueryParameter(s, charset));\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n *  Parses the given URL string.\r\n *\r\n *  @param _url\r\n *             absolute or relative url with query string\r\n *  @param charset\r\n *  @return Url object\r\n *\/\r\n","code_no_comment":"public static Url parse(CharSequence _url, Charset charset) {\r\n    Args.notNull(_url, \"_url\");\r\n    final Url result = new Url(charset);\r\n        charset = result.getCharset();\r\n    String url = _url.toString();\r\n        final String queryString;\r\n    final String absoluteUrl;\r\n    final int queryAt = url.indexOf('?');\r\n    if (queryAt == -1) {\r\n        queryString = \"\";\r\n        absoluteUrl = url;\r\n    } else {\r\n        absoluteUrl = url.substring(0, queryAt);\r\n        queryString = url.substring(queryAt + 1);\r\n    }\r\n        String relativeUrl;\r\n        final int idxOfFirstSlash = absoluteUrl.indexOf('\/');\r\n    final int protocolAt = absoluteUrl.indexOf(\":\/\/\");\r\n    if (protocolAt > -1 && (protocolAt < idxOfFirstSlash)) {\r\n        result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\r\n        final String afterProto = absoluteUrl.substring(protocolAt + 3);\r\n        final String hostAndPort;\r\n        final int relativeAt = afterProto.indexOf('\/');\r\n        if (relativeAt == -1) {\r\n            relativeUrl = \"\";\r\n            hostAndPort = afterProto;\r\n        } else {\r\n            relativeUrl = afterProto.substring(relativeAt);\r\n            hostAndPort = afterProto.substring(0, relativeAt);\r\n        }\r\n        final int portAt = hostAndPort.lastIndexOf(':');\r\n        if (portAt == -1) {\r\n            result.host = hostAndPort;\r\n            result.port = getDefaultPortForProtocol(result.protocol);\r\n        } else {\r\n            result.host = hostAndPort.substring(0, portAt);\r\n            result.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\r\n        }\r\n        if (relativeAt < 0) {\r\n            relativeUrl = \"\/\";\r\n        }\r\n    } else {\r\n        relativeUrl = absoluteUrl;\r\n    }\r\n    if (relativeUrl.length() > 0) {\r\n        boolean removeLast = false;\r\n        if (relativeUrl.endsWith(\"\/\")) {\r\n                                                relativeUrl += \"\/x\";\r\n            removeLast = true;\r\n        }\r\n        String[] segmentArray = Strings.split(relativeUrl, '\/');\r\n        if (removeLast) {\r\n            segmentArray[segmentArray.length - 1] = null;\r\n        }\r\n        for (String s : segmentArray) {\r\n            if (s != null) {\r\n                result.segments.add(decodeSegment(s, charset));\r\n            }\r\n        }\r\n    }\r\n    if (queryString.length() > 0) {\r\n        String[] queryArray = Strings.split(queryString, '&');\r\n        for (String s : queryArray) {\r\n            if (Strings.isEmpty(s) == false) {\r\n                result.parameters.add(parseQueryParameter(s, charset));\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}","lc":2.5454545455,"pi":0.2296650718,"ma":2.0,"nbd":0.5,"ml":1.5,"d":2.003968254,"mi":-1.1214940099,"fo":1.9166666667,"r":-0.0263157895,"e":7.8842873855}
{"project_name":"Time","project_version":"26","label":2,"code":"\/**\r\n * Set values which may be out of bounds by adding the difference between\r\n * the new value and the current value.\r\n *\/\r\npublic long set(long instant, int value) {\r\n    \/\/ lenient needs to handle time zone chronologies\r\n    \/\/ so we do the calculation using local milliseconds\r\n    long localInstant = iBase.getZone().convertUTCToLocal(instant);\r\n    long difference = FieldUtils.safeSubtract(value, get(instant));\r\n    localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\r\n    return iBase.getZone().convertLocalToUTC(localInstant, false);\r\n}","code_comment":"\/**\r\n * Set values which may be out of bounds by adding the difference between\r\n * the new value and the current value.\r\n *\/\r\n","code_no_comment":"public long set(long instant, int value) {\r\n            long localInstant = iBase.getZone().convertUTCToLocal(instant);\r\n    long difference = FieldUtils.safeSubtract(value, get(instant));\r\n    localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\r\n    return iBase.getZone().convertLocalToUTC(localInstant, false);\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4376321353,"fo":0.3333333333,"r":1.0526315789,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"@Override\r\npublic boolean moveTo(NodeStateBuilder destParent, String destName) {\r\n    if (!(destParent instanceof KernelNodeStateBuilder)) {\r\n        throw new IllegalArgumentException(\"Alien builder for destParent\");\r\n    }\r\n    if (destParent.getChildBuilder(destName) != null) {\r\n        return false;\r\n    }\r\n    KernelNodeStateBuilder destParentBuilder = (KernelNodeStateBuilder) destParent;\r\n    String destPath = PathUtils.concat(destParentBuilder.path, destName);\r\n    context.moveNode(path, destPath);\r\n    path = destPath;\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean moveTo(NodeStateBuilder destParent, String destName) {\r\n    if (!(destParent instanceof KernelNodeStateBuilder)) {\r\n        throw new IllegalArgumentException(\"Alien builder for destParent\");\r\n    }\r\n    if (destParent.getChildBuilder(destName) != null) {\r\n        return false;\r\n    }\r\n    KernelNodeStateBuilder destParentBuilder = (KernelNodeStateBuilder) destParent;\r\n    String destPath = PathUtils.concat(destParentBuilder.path, destName);\r\n    context.moveNode(path, destPath);\r\n    path = destPath;\r\n    return true;\r\n}","lc":0.0,"pi":-0.2966507177,"ma":0.0,"nbd":-0.5,"ml":0.0,"d":-0.0436507937,"mi":-0.0136715997,"fo":-0.25,"r":0.0,"e":-0.0293194562}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-780_dd6cefb0","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected void computeGeometricalProperties() {\r\n    final Vector2D[][] v = getVertices();\r\n    if (v.length == 0) {\r\n        if ((Boolean) getTree(false).getAttribute()) {\r\n            setSize(Double.POSITIVE_INFINITY);\r\n            setBarycenter(Vector2D.NaN);\r\n        } else {\r\n            setSize(0);\r\n            setBarycenter(new Vector2D(0, 0));\r\n        }\r\n    } else if (v[0][0] == null) {\r\n        \/\/ there is at least one open-loop: the polygon is infinite\r\n        setSize(Double.POSITIVE_INFINITY);\r\n        setBarycenter(Vector2D.NaN);\r\n    } else {\r\n        \/\/ all loops are closed, we compute some integrals around the shape\r\n        double sum = 0;\r\n        double sumX = 0;\r\n        double sumY = 0;\r\n        for (Vector2D[] loop : v) {\r\n            double x1 = loop[loop.length - 1].getX();\r\n            double y1 = loop[loop.length - 1].getY();\r\n            for (final Vector2D point : loop) {\r\n                final double x0 = x1;\r\n                final double y0 = y1;\r\n                x1 = point.getX();\r\n                y1 = point.getY();\r\n                final double factor = x0 * y1 - y0 * x1;\r\n                sum += factor;\r\n                sumX += factor * (x0 + x1);\r\n                sumY += factor * (y0 + y1);\r\n            }\r\n        }\r\n        if (sum < 0) {\r\n            \/\/ the polygon as a finite outside surrounded by an infinite inside\r\n            setSize(Double.POSITIVE_INFINITY);\r\n            setBarycenter(Vector2D.NaN);\r\n        } else {\r\n            setSize(sum \/ 2);\r\n            setBarycenter(new Vector2D(sumX \/ (3 * sum), sumY \/ (3 * sum)));\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void computeGeometricalProperties() {\r\n    final Vector2D[][] v = getVertices();\r\n    if (v.length == 0) {\r\n        if ((Boolean) getTree(false).getAttribute()) {\r\n            setSize(Double.POSITIVE_INFINITY);\r\n            setBarycenter(Vector2D.NaN);\r\n        } else {\r\n            setSize(0);\r\n            setBarycenter(new Vector2D(0, 0));\r\n        }\r\n    } else if (v[0][0] == null) {\r\n                setSize(Double.POSITIVE_INFINITY);\r\n        setBarycenter(Vector2D.NaN);\r\n    } else {\r\n                double sum = 0;\r\n        double sumX = 0;\r\n        double sumY = 0;\r\n        for (Vector2D[] loop : v) {\r\n            double x1 = loop[loop.length - 1].getX();\r\n            double y1 = loop[loop.length - 1].getY();\r\n            for (final Vector2D point : loop) {\r\n                final double x0 = x1;\r\n                final double y0 = y1;\r\n                x1 = point.getX();\r\n                y1 = point.getY();\r\n                final double factor = x0 * y1 - y0 * x1;\r\n                sum += factor;\r\n                sumX += factor * (x0 + x1);\r\n                sumY += factor * (y0 + y1);\r\n            }\r\n        }\r\n        if (sum < 0) {\r\n                        setSize(Double.POSITIVE_INFINITY);\r\n            setBarycenter(Vector2D.NaN);\r\n        } else {\r\n            setSize(sum \/ 2);\r\n            setBarycenter(new Vector2D(sumX \/ (3 * sum), sumY \/ (3 * sum)));\r\n        }\r\n    }\r\n}","lc":1.2272727273,"pi":0.7655502392,"ma":0.6,"nbd":1.0,"ml":0.0833333333,"d":2.1111111111,"mi":-0.7276955603,"fo":0.9166666667,"r":-0.0263157895,"e":3.9694634141}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7429_43956f93","label":1,"code":"private String doParseUri(String uri, Properties properties, List<String> replaced, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) {\r\n    StringBuilder sb = new StringBuilder();\r\n    int pivot = 0;\r\n    int size = uri.length();\r\n    while (pivot < size) {\r\n        int idx = findTokenPosition(uri, pivot, prefixToken);\r\n        if (idx < 0) {\r\n            sb.append(createConstantPart(uri, pivot, size));\r\n            break;\r\n        } else {\r\n            if (pivot < idx) {\r\n                sb.append(createConstantPart(uri, pivot, idx));\r\n            }\r\n            pivot = idx + prefixToken.length();\r\n            int endIdx = findTokenPosition(uri, pivot, suffixToken);\r\n            if (endIdx < 0) {\r\n                throw new IllegalArgumentException(\"Expecting \" + suffixToken + \" but found end of string from text: \" + uri);\r\n            }\r\n            String key = uri.substring(pivot, endIdx);\r\n            String augmentedKey = key;\r\n            if (propertyPrefix != null) {\r\n                log.debug(\"Augmenting property key [{}] with prefix: {}\", key, propertyPrefix);\r\n                augmentedKey = propertyPrefix + augmentedKey;\r\n            }\r\n            if (propertySuffix != null) {\r\n                log.debug(\"Augmenting property key [{}] with suffix: {}\", key, propertySuffix);\r\n                augmentedKey = augmentedKey + propertySuffix;\r\n            }\r\n            String part = createPlaceholderPart(augmentedKey, properties, replaced, prefixToken, suffixToken);\r\n            \/\/ Note: Only fallback to unaugmented when the original key was actually augmented\r\n            if (part == null && fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {\r\n                log.debug(\"Property wth key [{}] not found, attempting with unaugmented key: {}\", augmentedKey, key);\r\n                part = createPlaceholderPart(key, properties, replaced, prefixToken, suffixToken);\r\n            }\r\n            if (part == null) {\r\n                StringBuilder esb = new StringBuilder();\r\n                esb.append(\"Property with key [\").append(augmentedKey).append(\"] \");\r\n                if (fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {\r\n                    esb.append(\"(and original key [\").append(key).append(\"]) \");\r\n                }\r\n                esb.append(\"not found in properties from text: \").append(uri);\r\n                throw new IllegalArgumentException(esb.toString());\r\n            }\r\n            sb.append(part);\r\n            pivot = endIdx + suffixToken.length();\r\n        }\r\n    }\r\n    return sb.toString();\r\n}","code_comment":null,"code_no_comment":"private String doParseUri(String uri, Properties properties, List<String> replaced, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) {\r\n    StringBuilder sb = new StringBuilder();\r\n    int pivot = 0;\r\n    int size = uri.length();\r\n    while (pivot < size) {\r\n        int idx = findTokenPosition(uri, pivot, prefixToken);\r\n        if (idx < 0) {\r\n            sb.append(createConstantPart(uri, pivot, size));\r\n            break;\r\n        } else {\r\n            if (pivot < idx) {\r\n                sb.append(createConstantPart(uri, pivot, idx));\r\n            }\r\n            pivot = idx + prefixToken.length();\r\n            int endIdx = findTokenPosition(uri, pivot, suffixToken);\r\n            if (endIdx < 0) {\r\n                throw new IllegalArgumentException(\"Expecting \" + suffixToken + \" but found end of string from text: \" + uri);\r\n            }\r\n            String key = uri.substring(pivot, endIdx);\r\n            String augmentedKey = key;\r\n            if (propertyPrefix != null) {\r\n                log.debug(\"Augmenting property key [{}] with prefix: {}\", key, propertyPrefix);\r\n                augmentedKey = propertyPrefix + augmentedKey;\r\n            }\r\n            if (propertySuffix != null) {\r\n                log.debug(\"Augmenting property key [{}] with suffix: {}\", key, propertySuffix);\r\n                augmentedKey = augmentedKey + propertySuffix;\r\n            }\r\n            String part = createPlaceholderPart(augmentedKey, properties, replaced, prefixToken, suffixToken);\r\n                        if (part == null && fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {\r\n                log.debug(\"Property wth key [{}] not found, attempting with unaugmented key: {}\", augmentedKey, key);\r\n                part = createPlaceholderPart(key, properties, replaced, prefixToken, suffixToken);\r\n            }\r\n            if (part == null) {\r\n                StringBuilder esb = new StringBuilder();\r\n                esb.append(\"Property with key [\").append(augmentedKey).append(\"] \");\r\n                if (fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {\r\n                    esb.append(\"(and original key [\").append(key).append(\"]) \");\r\n                }\r\n                esb.append(\"not found in properties from text: \").append(uri);\r\n                throw new IllegalArgumentException(esb.toString());\r\n            }\r\n            sb.append(part);\r\n            pivot = endIdx + suffixToken.length();\r\n        }\r\n    }\r\n    return sb.toString();\r\n}","lc":1.5454545455,"pi":0.7655502392,"ma":1.8,"nbd":1.0,"ml":1.4166666667,"d":1.7916666667,"mi":-0.9055673009,"fo":1.6666666667,"r":-0.0263157895,"e":5.5203771258}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4173_84bbbf68","label":1,"code":"\/**\r\n *  Convenience method for setting next page to be rendered.\r\n *\r\n *  @param pageClass\r\n *\/\r\npublic void setResponsePage(Class<? extends IRequestablePage> pageClass) {\r\n    IPageProvider provider = new PageProvider(pageClass, null);\r\n    scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(provider, RenderPageRequestHandler.RedirectPolicy.AUTO_REDIRECT));\r\n}","code_comment":"\/**\r\n *  Convenience method for setting next page to be rendered.\r\n *\r\n *  @param pageClass\r\n *\/\r\n","code_no_comment":"public void setResponsePage(Class<? extends IRequestablePage> pageClass) {\r\n    IPageProvider provider = new PageProvider(pageClass, null);\r\n    scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(provider, RenderPageRequestHandler.RedirectPolicy.AUTO_REDIRECT));\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7268498943,"fo":-0.4166666667,"r":2.2105263158,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-294_5c592d85","label":1,"code":"\/**\r\n *  Checks if the specified path matches any mount, and if so returns the\r\n *  coding strategy for that mount. Returns null if the path doesnt match\r\n *  any mounts.\r\n *\r\n *  NOTE: path here is not the mount - it is the full url path\r\n *\r\n *  @param path\r\n *             non-null url path\r\n *  @return coding strategy or null\r\n *\/\r\npublic IRequestTargetUrlCodingStrategy strategyForPath(String path) {\r\n    if (path == null) {\r\n        throw new IllegalArgumentException(\"Argument [[path]] cannot be null\");\r\n    }\r\n    if (caseSensitiveMounts == false) {\r\n        path = path.toLowerCase();\r\n    }\r\n    for (final Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\r\n        final Map.Entry entry = (Entry) it.next();\r\n        final String key = (String) entry.getKey();\r\n        if (path.startsWith(key)) {\r\n            return (IRequestTargetUrlCodingStrategy) entry.getValue();\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":"\/**\r\n *  Checks if the specified path matches any mount, and if so returns the\r\n *  coding strategy for that mount. Returns null if the path doesnt match\r\n *  any mounts.\r\n *\r\n *  NOTE: path here is not the mount - it is the full url path\r\n *\r\n *  @param path\r\n *             non-null url path\r\n *  @return coding strategy or null\r\n *\/\r\n","code_no_comment":"public IRequestTargetUrlCodingStrategy strategyForPath(String path) {\r\n    if (path == null) {\r\n        throw new IllegalArgumentException(\"Argument [[path]] cannot be null\");\r\n    }\r\n    if (caseSensitiveMounts == false) {\r\n        path = path.toLowerCase();\r\n    }\r\n    for (final Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\r\n        final Map.Entry entry = (Entry) it.next();\r\n        final String key = (String) entry.getKey();\r\n        if (path.startsWith(key)) {\r\n            return (IRequestTargetUrlCodingStrategy) entry.getValue();\r\n        }\r\n    }\r\n    return null;\r\n}","lc":0.0909090909,"pi":0.0622009569,"ma":0.4,"nbd":0.0,"ml":0.3333333333,"d":-0.0555555556,"mi":-0.1140239605,"fo":0.1666666667,"r":0.0,"e":-0.0089048714}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4105_64656c98","label":1,"code":"@Override\r\npublic void afterRender(final Component component) {\r\n    final RequestCycle requestCycle = RequestCycle.get();\r\n    try {\r\n        BufferedWebResponse response = (BufferedWebResponse) requestCycle.getResponse();\r\n        \/\/ Transform the data\r\n        CharSequence output = transform(component, response.getText());\r\n        response.setText(output);\r\n        response.writeTo(webResponse);\r\n    } catch (Exception ex) {\r\n        throw new WicketRuntimeException(\"Error while transforming the output: \" + this, ex);\r\n    } finally {\r\n        \/\/ Restore the original response object\r\n        requestCycle.setResponse(webResponse);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void afterRender(final Component component) {\r\n    final RequestCycle requestCycle = RequestCycle.get();\r\n    try {\r\n        BufferedWebResponse response = (BufferedWebResponse) requestCycle.getResponse();\r\n                CharSequence output = transform(component, response.getText());\r\n        response.setText(output);\r\n        response.writeTo(webResponse);\r\n    } catch (Exception ex) {\r\n        throw new WicketRuntimeException(\"Error while transforming the output: \" + this, ex);\r\n    } finally {\r\n                requestCycle.setResponse(webResponse);\r\n    }\r\n}","lc":0.0,"pi":0.04784689,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.0714285714,"mi":-0.0052149401,"fo":0.0833333333,"r":0.0,"e":-0.0425280799}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1719_c3773d53","label":1,"code":"\/**\r\n * Copies the full content from the source to the target repository.\r\n * <p>\r\n * The source repository <strong>must not be modified<\/strong> while\r\n * the copy operation is running to avoid an inconsistent copy.\r\n * <p>\r\n * This method leaves the search indexes of the target repository in\r\n * an\r\n * Note that both the source and the target repository must be closed\r\n * during the copy operation as this method requires exclusive access\r\n * to the repositories.\r\n *\r\n * @throws RepositoryException if the copy operation fails\r\n *\/\r\npublic void copy() throws RepositoryException {\r\n    RepositoryConfig config = source.getRepositoryConfig();\r\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\r\n    try {\r\n        NodeBuilder builder = target.getRoot().builder();\r\n        \/\/ init target repository first\r\n        new InitialContent().initialize(builder);\r\n        Map<String, String> uriToPrefix = newHashMap();\r\n        Map<Integer, String> idxToPrefix = newHashMap();\r\n        copyNamespaces(builder, uriToPrefix, idxToPrefix);\r\n        copyNodeTypes(builder);\r\n        copyPrivileges(builder);\r\n        NodeState root = builder.getNodeState();\r\n        copyVersionStore(builder, root, uriToPrefix, idxToPrefix);\r\n        String workspaceName = copyWorkspaces(builder, root, uriToPrefix, idxToPrefix);\r\n        logger.info(\"Applying default commit hooks\");\r\n        String groupsPath;\r\n        UserManagerConfig userConfig = config.getSecurityConfig().getSecurityManagerConfig().getUserManagerConfig();\r\n        if (userConfig != null) {\r\n            groupsPath = userConfig.getParameters().getProperty(UserManagerImpl.PARAM_GROUPS_PATH, UserConstants.DEFAULT_GROUP_PATH);\r\n        } else {\r\n            groupsPath = UserConstants.DEFAULT_GROUP_PATH;\r\n        }\r\n        \/\/ TODO: default hooks?\r\n        List<CommitHook> hooks = newArrayList();\r\n        hooks.add(new EditorHook(new CompositeEditorProvider(new GroupEditorProvider(groupsPath), new TypeEditorProvider(false), new IndexUpdateProvider(new CompositeIndexEditorProvider(new ReferenceEditorProvider(), new PropertyIndexEditorProvider())))));\r\n        hooks.addAll(new AuthorizationConfigurationImpl().getCommitHooks(workspaceName));\r\n        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);\r\n    } catch (Exception e) {\r\n        throw new RepositoryException(\"Failed to copy content\", e);\r\n    }\r\n}","code_comment":"\/**\r\n * Copies the full content from the source to the target repository.\r\n * <p>\r\n * The source repository <strong>must not be modified<\/strong> while\r\n * the copy operation is running to avoid an inconsistent copy.\r\n * <p>\r\n * This method leaves the search indexes of the target repository in\r\n * an\r\n * Note that both the source and the target repository must be closed\r\n * during the copy operation as this method requires exclusive access\r\n * to the repositories.\r\n *\r\n * @throws RepositoryException if the copy operation fails\r\n *\/\r\n","code_no_comment":"public void copy() throws RepositoryException {\r\n    RepositoryConfig config = source.getRepositoryConfig();\r\n    logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\r\n    try {\r\n        NodeBuilder builder = target.getRoot().builder();\r\n                new InitialContent().initialize(builder);\r\n        Map<String, String> uriToPrefix = newHashMap();\r\n        Map<Integer, String> idxToPrefix = newHashMap();\r\n        copyNamespaces(builder, uriToPrefix, idxToPrefix);\r\n        copyNodeTypes(builder);\r\n        copyPrivileges(builder);\r\n        NodeState root = builder.getNodeState();\r\n        copyVersionStore(builder, root, uriToPrefix, idxToPrefix);\r\n        String workspaceName = copyWorkspaces(builder, root, uriToPrefix, idxToPrefix);\r\n        logger.info(\"Applying default commit hooks\");\r\n        String groupsPath;\r\n        UserManagerConfig userConfig = config.getSecurityConfig().getSecurityManagerConfig().getUserManagerConfig();\r\n        if (userConfig != null) {\r\n            groupsPath = userConfig.getParameters().getProperty(UserManagerImpl.PARAM_GROUPS_PATH, UserConstants.DEFAULT_GROUP_PATH);\r\n        } else {\r\n            groupsPath = UserConstants.DEFAULT_GROUP_PATH;\r\n        }\r\n                List<CommitHook> hooks = newArrayList();\r\n        hooks.add(new EditorHook(new CompositeEditorProvider(new GroupEditorProvider(groupsPath), new TypeEditorProvider(false), new IndexUpdateProvider(new CompositeIndexEditorProvider(new ReferenceEditorProvider(), new PropertyIndexEditorProvider())))));\r\n        hooks.addAll(new AuthorizationConfigurationImpl().getCommitHooks(workspaceName));\r\n        target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);\r\n    } catch (Exception e) {\r\n        throw new RepositoryException(\"Failed to copy content\", e);\r\n    }\r\n}","lc":0.7272727273,"pi":-0.1531100478,"ma":0.0,"nbd":0.0,"ml":-0.25,"d":-0.0515873016,"mi":-0.5740662438,"fo":1.6666666667,"r":-0.0263157895,"e":0.3909084098}
{"project_name":"Closure","project_version":"167","label":2,"code":"\/**\r\n * Computes the restricted type of this type knowing that the\r\n * {@code ToBoolean} predicate has a specific value. For more information\r\n * about the {@code ToBoolean} predicate, see\r\n * {@link #getPossibleToBooleanOutcomes}.\r\n *\r\n * @param outcome the value of the {@code ToBoolean} predicate\r\n *\r\n * @return the restricted type, or the Any Type if the underlying type could\r\n *         not have yielded this ToBoolean value\r\n *\r\n * TODO(user): Move this method to the SemanticRAI and use the visit\r\n * method of types to get the restricted type.\r\n *\/\r\npublic JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {\r\n    BooleanLiteralSet literals = getPossibleToBooleanOutcomes();\r\n    if (literals.contains(outcome)) {\r\n        return this;\r\n    } else {\r\n        return getNativeType(JSTypeNative.NO_TYPE);\r\n    }\r\n}","code_comment":"\/**\r\n * Computes the restricted type of this type knowing that the\r\n * {@code ToBoolean} predicate has a specific value. For more information\r\n * about the {@code ToBoolean} predicate, see\r\n * {@link #getPossibleToBooleanOutcomes}.\r\n *\r\n * @param outcome the value of the {@code ToBoolean} predicate\r\n *\r\n * @return the restricted type, or the Any Type if the underlying type could\r\n *         not have yielded this ToBoolean value\r\n *\r\n * TODO(user): Move this method to the SemanticRAI and use the visit\r\n * method of types to get the restricted type.\r\n *\/\r\n","code_no_comment":"public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {\r\n    BooleanLiteralSet literals = getPossibleToBooleanOutcomes();\r\n    if (literals.contains(outcome)) {\r\n        return this;\r\n    } else {\r\n        return getNativeType(JSTypeNative.NO_TYPE);\r\n    }\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.4410147992,"fo":-0.25,"r":0.1842105263,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2172_ea4a3f8a","label":3,"code":"\/\/ \/\/\r\n\/\/ \/\/ getAs convenience methods\r\n\/\/ \/\/\r\n\/**\r\n *  @see IValueMap#getAsBoolean(String)\r\n *\/\r\npublic Boolean getAsBoolean(String key) {\r\n    if (!containsKey(key))\r\n        return null;\r\n    try {\r\n        return getBoolean(key);\r\n    } catch (StringValueConversionException ignored) {\r\n        return null;\r\n    }\r\n}","code_comment":"\/**\r\n *  @see IValueMap#getAsBoolean(String)\r\n *\/\r\n","code_no_comment":"public Boolean getAsBoolean(String key) {\r\n    if (!containsKey(key))\r\n        return null;\r\n    try {\r\n        return getBoolean(key);\r\n    } catch (StringValueConversionException ignored) {\r\n        return null;\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.3860465116,"fo":-0.3333333333,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4113_27300d81","label":0,"code":"public static ByteBuffer toByteBuffers(ByteSequence bs) {\r\n    if (bs == null)\r\n        return null;\r\n    if (bs.isBackedByArray()) {\r\n        return ByteBuffer.wrap(bs.getBackingArray(), bs.offset(), bs.length());\r\n    } else {\r\n        \/\/ TODO create more efficient impl\r\n        return ByteBuffer.wrap(bs.toArray());\r\n    }\r\n}","code_comment":null,"code_no_comment":"public static ByteBuffer toByteBuffers(ByteSequence bs) {\r\n    if (bs == null)\r\n        return null;\r\n    if (bs.isBackedByArray()) {\r\n        return ByteBuffer.wrap(bs.getBackingArray(), bs.offset(), bs.length());\r\n    } else {\r\n                return ByteBuffer.wrap(bs.toArray());\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.303453136,"fo":0.0833333333,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-3092_5ffd8903","label":1,"code":"public boolean containsVersion(ArtifactVersion version) {\r\n    if (lowerBound != null) {\r\n        int comparison = lowerBound.compareTo(version);\r\n        if ((comparison == 0) && !lowerBoundInclusive) {\r\n            return false;\r\n        }\r\n        if (comparison > 0) {\r\n            return false;\r\n        }\r\n    }\r\n    if (upperBound != null) {\r\n        int comparison = upperBound.compareTo(version);\r\n        if ((comparison == 0) && !upperBoundInclusive) {\r\n            return false;\r\n        }\r\n        if (comparison < 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"public boolean containsVersion(ArtifactVersion version) {\r\n    if (lowerBound != null) {\r\n        int comparison = lowerBound.compareTo(version);\r\n        if ((comparison == 0) && !lowerBoundInclusive) {\r\n            return false;\r\n        }\r\n        if (comparison > 0) {\r\n            return false;\r\n        }\r\n    }\r\n    if (upperBound != null) {\r\n        int comparison = upperBound.compareTo(version);\r\n        if ((comparison == 0) && !upperBoundInclusive) {\r\n            return false;\r\n        }\r\n        if (comparison < 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}","lc":0.3181818182,"pi":0.2296650718,"ma":0.6,"nbd":0.0,"ml":0.6666666667,"d":0.9523809524,"mi":-0.2262156448,"fo":-0.3333333333,"r":0.0789473684,"e":0.4156336624}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"private void fetchNextPossiblyDuplicate() {\r\n    while (!nodeIterators.isEmpty()) {\r\n        Iterator<? extends ChildNodeEntry> iterator = nodeIterators.getLast();\r\n        if (iterator.hasNext()) {\r\n            ChildNodeEntry entry = iterator.next();\r\n            readCount++;\r\n            if (readCount % 1000 == 0) {\r\n                FilterIterators.checkReadLimit(readCount, maxMemoryEntries);\r\n                LOG.warn(\"Traversed \" + readCount + \" nodes using index \" + indexName + \" with filter \" + filter);\r\n            }\r\n            NodeState node = entry.getNodeState();\r\n            String name = entry.getName();\r\n            if (NodeStateUtils.isHidden(name)) {\r\n                continue;\r\n            }\r\n            currentPath = PathUtils.concat(parentPath, name);\r\n            nodeIterators.addLast(node.getChildNodeEntries().iterator());\r\n            parentPath = currentPath;\r\n            if (node.getBoolean(\"match\")) {\r\n                return;\r\n            }\r\n        } else {\r\n            nodeIterators.removeLast();\r\n            parentPath = PathUtils.getParentPath(parentPath);\r\n        }\r\n    }\r\n    currentPath = null;\r\n    closed = true;\r\n}","code_comment":null,"code_no_comment":"private void fetchNextPossiblyDuplicate() {\r\n    while (!nodeIterators.isEmpty()) {\r\n        Iterator<? extends ChildNodeEntry> iterator = nodeIterators.getLast();\r\n        if (iterator.hasNext()) {\r\n            ChildNodeEntry entry = iterator.next();\r\n            readCount++;\r\n            if (readCount % 1000 == 0) {\r\n                FilterIterators.checkReadLimit(readCount, maxMemoryEntries);\r\n                LOG.warn(\"Traversed \" + readCount + \" nodes using index \" + indexName + \" with filter \" + filter);\r\n            }\r\n            NodeState node = entry.getNodeState();\r\n            String name = entry.getName();\r\n            if (NodeStateUtils.isHidden(name)) {\r\n                continue;\r\n            }\r\n            currentPath = PathUtils.concat(parentPath, name);\r\n            nodeIterators.addLast(node.getChildNodeEntries().iterator());\r\n            parentPath = currentPath;\r\n            if (node.getBoolean(\"match\")) {\r\n                return;\r\n            }\r\n        } else {\r\n            nodeIterators.removeLast();\r\n            parentPath = PathUtils.getParentPath(parentPath);\r\n        }\r\n    }\r\n    currentPath = null;\r\n    closed = true;\r\n}","lc":0.6818181818,"pi":0.6794258373,"ma":0.6,"nbd":0.5,"ml":0.5,"d":0.5218253968,"mi":-0.5041578576,"fo":0.8333333333,"r":0.0,"e":0.7833774197}
{"project_name":"Closure","project_version":"85","label":1,"code":"private Node computeFollowing(Node n) {\r\n    Node next = ControlFlowAnalysis.computeFollowNode(n);\r\n    return next;\r\n}","code_comment":null,"code_no_comment":"private Node computeFollowing(Node n) {\r\n    Node next = ControlFlowAnalysis.computeFollowNode(n);\r\n    return next;\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8128259338,"fo":-0.4166666667,"r":1.9210526316,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-395_e6c31270","label":1,"code":"private Property internalSetProperty(final String jcrName, final Value[] values, final int type, final boolean exactTypeMatch) throws RepositoryException {\r\n    checkStatus();\r\n    checkProtected();\r\n    return sessionDelegate.perform(new SessionOperation<Property>() {\r\n\r\n        @Override\r\n        public Property perform() throws RepositoryException {\r\n            if (values == null) {\r\n                Property p = getProperty(jcrName);\r\n                p.remove();\r\n                return p;\r\n            } else {\r\n                String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\r\n                PropertyDefinition definition;\r\n                if (hasProperty(jcrName)) {\r\n                    definition = getProperty(jcrName).getDefinition();\r\n                } else {\r\n                    definition = dlg.sessionDelegate.getDefinitionProvider().getDefinition(NodeImpl.this, oakName, true, type, exactTypeMatch);\r\n                }\r\n                checkProtected(definition);\r\n                if (!definition.isMultiple()) {\r\n                    throw new ValueFormatException(\"Cannot set value array to single value property\");\r\n                }\r\n                int targetType = getTargetType(values, definition);\r\n                Value[] targetValues = ValueHelper.convert(values, targetType, getValueFactory());\r\n                Iterable<Value> nonNullValues = Iterables.filter(Arrays.asList(targetValues), Predicates.notNull());\r\n                return new PropertyImpl(dlg.setProperty(oakName, nonNullValues));\r\n            }\r\n        }\r\n    });\r\n}","code_comment":null,"code_no_comment":"private Property internalSetProperty(final String jcrName, final Value[] values, final int type, final boolean exactTypeMatch) throws RepositoryException {\r\n    checkStatus();\r\n    checkProtected();\r\n    return sessionDelegate.perform(new SessionOperation<Property>() {\r\n\r\n        @Override\r\n        public Property perform() throws RepositoryException {\r\n            if (values == null) {\r\n                Property p = getProperty(jcrName);\r\n                p.remove();\r\n                return p;\r\n            } else {\r\n                String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\r\n                PropertyDefinition definition;\r\n                if (hasProperty(jcrName)) {\r\n                    definition = getProperty(jcrName).getDefinition();\r\n                } else {\r\n                    definition = dlg.sessionDelegate.getDefinitionProvider().getDefinition(NodeImpl.this, oakName, true, type, exactTypeMatch);\r\n                }\r\n                checkProtected(definition);\r\n                if (!definition.isMultiple()) {\r\n                    throw new ValueFormatException(\"Cannot set value array to single value property\");\r\n                }\r\n                int targetType = getTargetType(values, definition);\r\n                Value[] targetValues = ValueHelper.convert(values, targetType, getValueFactory());\r\n                Iterable<Value> nonNullValues = Iterables.filter(Arrays.asList(targetValues), Predicates.notNull());\r\n                return new PropertyImpl(dlg.setProperty(oakName, nonNullValues));\r\n            }\r\n        }\r\n    });\r\n}","lc":0.7272727273,"pi":1.3540669856,"ma":0.2,"nbd":0.5,"ml":0.1666666667,"d":-0.0257936508,"mi":-0.5275546159,"fo":1.1666666667,"r":-0.0263157895,"e":0.2561988901}
{"project_name":"Cli","project_version":"20","label":1,"code":"\/**\r\n * <p>An implementation of {@link Parser}'s abstract\r\n * {@link Parser#flatten(Options,String[],boolean) flatten} method.<\/p>\r\n *\r\n * <p>The following are the rules used by this flatten method.\r\n * <ol>\r\n *  <li>if <code>stopAtNonOption<\/code> is <b>true<\/b> then do not\r\n *  burst anymore of <code>arguments<\/code> entries, just add each\r\n *  successive entry without further processing.  Otherwise, ignore\r\n *  <code>stopAtNonOption<\/code>.<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is \"<b>--<\/b>\"\r\n *  just add the entry to the list of processed tokens<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is \"<b>-<\/b>\"\r\n *  just add the entry to the list of processed tokens<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is two characters\r\n *  in length and the first character is \"<b>-<\/b>\" then check if this\r\n *  is a valid {@link Option} id.  If it is a valid id, then add the\r\n *  entry to the list of processed tokens and set the current {@link Option}\r\n *  member.  If it is not a valid id and <code>stopAtNonOption<\/code>\r\n *  is true, then the remaining entries are copied to the list of\r\n *  processed tokens.  Otherwise, the current entry is ignored.<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is more than two\r\n *  characters in length and the first character is \"<b>-<\/b>\" then\r\n *  we need to burst the entry to determine its constituents.  For more\r\n *  information on the bursting algorithm see\r\n *  {@link PosixParser#burstToken(String, boolean) burstToken}.<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is not handled\r\n *  by any of the previous rules, then the entry is added to the list\r\n *  of processed tokens.<\/li>\r\n * <\/ol>\r\n * <\/p>\r\n *\r\n * @param options The command line {@link Options}\r\n * @param arguments The command line arguments to be parsed\r\n * @param stopAtNonOption Specifies whether to stop flattening\r\n * when an non option is found.\r\n * @return The flattened <code>arguments<\/code> String array.\r\n *\/\r\nprotected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {\r\n    init();\r\n    this.options = options;\r\n    \/\/ an iterator for the command line tokens\r\n    Iterator iter = Arrays.asList(arguments).iterator();\r\n    \/\/ process each command line token\r\n    while (iter.hasNext()) {\r\n        \/\/ get the next command line token\r\n        String token = (String) iter.next();\r\n        \/\/ handle long option --foo or --foo=bar\r\n        if (token.startsWith(\"--\")) {\r\n            if (token.indexOf('=') != -1) {\r\n                tokens.add(token.substring(0, token.indexOf('=')));\r\n                tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\r\n            } else {\r\n                tokens.add(token);\r\n            }\r\n        } else \/\/ single hyphen\r\n        if (\"-\".equals(token)) {\r\n            tokens.add(token);\r\n        } else if (token.startsWith(\"-\")) {\r\n            if (token.length() == 2) {\r\n                processOptionToken(token, stopAtNonOption);\r\n            } else if (options.hasOption(token)) {\r\n                tokens.add(token);\r\n            } else \/\/ requires bursting\r\n            {\r\n                burstToken(token, stopAtNonOption);\r\n            }\r\n        } else if (stopAtNonOption) {\r\n            process(token);\r\n        } else {\r\n            tokens.add(token);\r\n        }\r\n        gobble(iter);\r\n    }\r\n    return (String[]) tokens.toArray(new String[tokens.size()]);\r\n}","code_comment":"\/**\r\n * <p>An implementation of {@link Parser}'s abstract\r\n * {@link Parser#flatten(Options,String[],boolean) flatten} method.<\/p>\r\n *\r\n * <p>The following are the rules used by this flatten method.\r\n * <ol>\r\n *  <li>if <code>stopAtNonOption<\/code> is <b>true<\/b> then do not\r\n *  burst anymore of <code>arguments<\/code> entries, just add each\r\n *  successive entry without further processing.  Otherwise, ignore\r\n *  <code>stopAtNonOption<\/code>.<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is \"<b>--<\/b>\"\r\n *  just add the entry to the list of processed tokens<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is \"<b>-<\/b>\"\r\n *  just add the entry to the list of processed tokens<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is two characters\r\n *  in length and the first character is \"<b>-<\/b>\" then check if this\r\n *  is a valid {@link Option} id.  If it is a valid id, then add the\r\n *  entry to the list of processed tokens and set the current {@link Option}\r\n *  member.  If it is not a valid id and <code>stopAtNonOption<\/code>\r\n *  is true, then the remaining entries are copied to the list of\r\n *  processed tokens.  Otherwise, the current entry is ignored.<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is more than two\r\n *  characters in length and the first character is \"<b>-<\/b>\" then\r\n *  we need to burst the entry to determine its constituents.  For more\r\n *  information on the bursting algorithm see\r\n *  {@link PosixParser#burstToken(String, boolean) burstToken}.<\/li>\r\n *  <li>if the current <code>arguments<\/code> entry is not handled\r\n *  by any of the previous rules, then the entry is added to the list\r\n *  of processed tokens.<\/li>\r\n * <\/ol>\r\n * <\/p>\r\n *\r\n * @param options The command line {@link Options}\r\n * @param arguments The command line arguments to be parsed\r\n * @param stopAtNonOption Specifies whether to stop flattening\r\n * when an non option is found.\r\n * @return The flattened <code>arguments<\/code> String array.\r\n *\/\r\n","code_no_comment":"protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {\r\n    init();\r\n    this.options = options;\r\n        Iterator iter = Arrays.asList(arguments).iterator();\r\n        while (iter.hasNext()) {\r\n                String token = (String) iter.next();\r\n                if (token.startsWith(\"--\")) {\r\n            if (token.indexOf('=') != -1) {\r\n                tokens.add(token.substring(0, token.indexOf('=')));\r\n                tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\r\n            } else {\r\n                tokens.add(token);\r\n            }\r\n        } else         if (\"-\".equals(token)) {\r\n            tokens.add(token);\r\n        } else if (token.startsWith(\"-\")) {\r\n            if (token.length() == 2) {\r\n                processOptionToken(token, stopAtNonOption);\r\n            } else if (options.hasOption(token)) {\r\n                tokens.add(token);\r\n            } else             {\r\n                burstToken(token, stopAtNonOption);\r\n            }\r\n        } else if (stopAtNonOption) {\r\n            process(token);\r\n        } else {\r\n            tokens.add(token);\r\n        }\r\n        gobble(iter);\r\n    }\r\n    return (String[]) tokens.toArray(new String[tokens.size()]);\r\n}","lc":0.9090909091,"pi":0.7464114833,"ma":1.0,"nbd":2.0,"ml":1.0,"d":0.626984127,"mi":-0.6076109937,"fo":1.8333333333,"r":-0.0263157895,"e":1.0351619094}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-924_2836a6f9","label":0,"code":"\/**\r\n * Computes the square-root of the weight matrix.\r\n *\r\n * @param m Symmetric, positive-definite (weight) matrix.\r\n * @return the square-root of the weight matrix.\r\n *\/\r\nprivate RealMatrix squareRoot(RealMatrix m) {\r\n    final EigenDecomposition dec = new EigenDecomposition(m);\r\n    return dec.getSquareRoot();\r\n}","code_comment":"\/**\r\n * Computes the square-root of the weight matrix.\r\n *\r\n * @param m Symmetric, positive-definite (weight) matrix.\r\n * @return the square-root of the weight matrix.\r\n *\/\r\n","code_no_comment":"private RealMatrix squareRoot(RealMatrix m) {\r\n    final EigenDecomposition dec = new EigenDecomposition(m);\r\n    return dec.getSquareRoot();\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8128259338,"fo":-0.4166666667,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5569_5efb8091","label":3,"code":"\/**\r\n *  If the child has not been directly added to the container, but via a\r\n *  TransparentWebMarkupContainer, then we are in trouble. In general Wicket iterates over the\r\n *  markup elements and searches for associated components, not the other way around. Because of\r\n *  TransparentWebMarkupContainer (or more generally resolvers), there is no \"synchronous\" search\r\n *  possible.\r\n *\r\n *  @param container\r\n *             the parent container.\r\n *  @param child\r\n *             The component to find the markup for.\r\n *  @return the markup fragment for the child, or {@code null}.\r\n *\/\r\nprotected IMarkupFragment searchMarkupInTransparentResolvers(final MarkupContainer container, final Component child) {\r\n    IMarkupFragment markup = null;\r\n    for (Component ch : container) {\r\n        if ((ch != child) && (ch instanceof MarkupContainer) && (ch instanceof IComponentResolver)) {\r\n            markup = ((MarkupContainer) ch).getMarkup(child);\r\n            if (markup != null) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return markup;\r\n}","code_comment":"\/**\r\n *  If the child has not been directly added to the container, but via a\r\n *  TransparentWebMarkupContainer, then we are in trouble. In general Wicket iterates over the\r\n *  markup elements and searches for associated components, not the other way around. Because of\r\n *  TransparentWebMarkupContainer (or more generally resolvers), there is no \"synchronous\" search\r\n *  possible.\r\n *\r\n *  @param container\r\n *             the parent container.\r\n *  @param child\r\n *             The component to find the markup for.\r\n *  @return the markup fragment for the child, or {@code null}.\r\n *\/\r\n","code_no_comment":"protected IMarkupFragment searchMarkupInTransparentResolvers(final MarkupContainer container, final Component child) {\r\n    IMarkupFragment markup = null;\r\n    for (Component ch : container) {\r\n        if ((ch != child) && (ch instanceof MarkupContainer) && (ch instanceof IComponentResolver)) {\r\n            markup = ((MarkupContainer) ch).getMarkup(child);\r\n            if (markup != null) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return markup;\r\n}","lc":-0.0909090909,"pi":0.9282296651,"ma":0.2,"nbd":0.5,"ml":0.1666666667,"d":0.0813492063,"mi":0.1027484144,"fo":-0.4166666667,"r":0.2105263158,"e":-0.0331045452}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1624_6d8146f8","label":0,"code":"public static boolean isValidLocalName(String local) {\r\n    if (local.isEmpty() || \".\".equals(local) || \"..\".equals(local)) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < local.length(); i++) {\r\n        char ch = local.charAt(i);\r\n        if (\"\/:[]|*\".indexOf(ch) != -1) {\r\n            \/\/ TODO: XMLChar check\r\n            return false;\r\n        }\r\n    }\r\n    \/\/ TODO: Other name rules?\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"public static boolean isValidLocalName(String local) {\r\n    if (local.isEmpty() || \".\".equals(local) || \"..\".equals(local)) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < local.length(); i++) {\r\n        char ch = local.charAt(i);\r\n        if (\"\/:[]|*\".indexOf(ch) != -1) {\r\n                        return false;\r\n        }\r\n    }\r\n        return true;\r\n}","lc":-0.0909090909,"pi":0.1961722488,"ma":0.0,"nbd":0.0,"ml":0.6666666667,"d":0.5932539683,"mi":0.0683579986,"fo":0.0,"r":0.5,"e":0.2050102868}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"private boolean isDisconnected() {\r\n    if (isRoot()) {\r\n        return false;\r\n    }\r\n    if (parent.nodeBuilder == null) {\r\n        return false;\r\n    }\r\n    if (!parent.nodeBuilder.isConnected()) {\r\n        return true;\r\n    }\r\n    return !getNodeBuilder().isConnected();\r\n}","code_comment":null,"code_no_comment":"private boolean isDisconnected() {\r\n    if (isRoot()) {\r\n        return false;\r\n    }\r\n    if (parent.nodeBuilder == null) {\r\n        return false;\r\n    }\r\n    if (!parent.nodeBuilder.isConnected()) {\r\n        return true;\r\n    }\r\n    return !getNodeBuilder().isConnected();\r\n}","lc":-0.0909090909,"pi":-0.2057416268,"ma":0.0,"nbd":-0.5,"ml":0.0833333333,"d":-0.0873015873,"mi":0.2143763214,"fo":-0.1666666667,"r":0.2631578947,"e":-0.1234579854}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-1718_bb7f9cf5","label":1,"code":"\/**\r\n *  @see org.apache.wicket.Component#onAfterRender()\r\n *\/\r\n@Override\r\nprotected void onAfterRender() {\r\n    \/\/ only in development mode validate the headers\r\n    if (getApplication().usesDevelopmentConfig()) {\r\n        validateHeaders();\r\n    }\r\n    super.onAfterRender();\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.Component#onAfterRender()\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void onAfterRender() {\r\n        if (getApplication().usesDevelopmentConfig()) {\r\n        validateHeaders();\r\n    }\r\n    super.onAfterRender();\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.6515856237,"fo":-0.1666666667,"r":2.2105263158,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4379_7a162f77","label":3,"code":"\/**\r\n *  @see org.apache.wicket.resource.loader.ComponentStringResourceLoader#loadStringResource(org.apache.wicket.Component,\r\n *       java.lang.String, java.util.Locale, java.lang.String, java.lang.String)\r\n *\/\r\n@Override\r\npublic String loadStringResource(final Component component, final String key, final Locale locale, final String style, final String variation) {\r\n    if (component == null || !(component instanceof FormComponent)) {\r\n        return null;\r\n    }\r\n    FormComponent<?> fc = (FormComponent<?>) component;\r\n    for (IValidator<?> validator : fc.getValidators()) {\r\n        String resource = loadStringResource(validator.getClass(), key, locale, style, variation);\r\n        if (resource != null) {\r\n            return resource;\r\n        }\r\n    }\r\n    \/\/ not found\r\n    return null;\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.resource.loader.ComponentStringResourceLoader#loadStringResource(org.apache.wicket.Component,\r\n *       java.lang.String, java.util.Locale, java.lang.String, java.lang.String)\r\n *\/\r\n","code_no_comment":"@Override\r\npublic String loadStringResource(final Component component, final String key, final Locale locale, final String style, final String variation) {\r\n    if (component == null || !(component instanceof FormComponent)) {\r\n        return null;\r\n    }\r\n    FormComponent<?> fc = (FormComponent<?>) component;\r\n    for (IValidator<?> validator : fc.getValidators()) {\r\n        String resource = loadStringResource(validator.getClass(), key, locale, style, variation);\r\n        if (resource != null) {\r\n            return resource;\r\n        }\r\n    }\r\n        return null;\r\n}","lc":0.0,"pi":0.2153110048,"ma":0.0,"nbd":0.0,"ml":0.0,"d":0.4702380952,"mi":-0.037914024,"fo":-0.25,"r":-0.0263157895,"e":0.2466186039}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"@Override\r\npublic void removeProperty(String name) {\r\n    if (hasProperty(name)) {\r\n        context.removeProperty(PathUtils.concat(path, name));\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void removeProperty(String name) {\r\n    if (hasProperty(name)) {\r\n        context.removeProperty(PathUtils.concat(path, name));\r\n    }\r\n}","lc":-0.3636363636,"pi":-0.004784689,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.5943622269,"fo":-0.25,"r":0.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2049_4af0d4ee","label":0,"code":"\/**\r\n * Adds a segment header to the buffer and writes a segment to the segment\r\n * store. This is done automatically (called from prepare) when there is not\r\n * enough space for a record. It can also be called explicitly.\r\n *\/\r\npublic synchronized void flush() {\r\n    if (length > 0) {\r\n        int refcount = segment.getRefCount();\r\n        int rootcount = roots.size();\r\n        buffer[Segment.ROOT_COUNT_OFFSET] = (byte) (rootcount >> 8);\r\n        buffer[Segment.ROOT_COUNT_OFFSET + 1] = (byte) rootcount;\r\n        int blobrefcount = blobrefs.size();\r\n        buffer[Segment.BLOBREF_COUNT_OFFSET] = (byte) (blobrefcount >> 8);\r\n        buffer[Segment.BLOBREF_COUNT_OFFSET + 1] = (byte) blobrefcount;\r\n        length = align(refcount * 16 + rootcount * 3 + blobrefcount * 2 + length, 16);\r\n        int pos = refcount * 16;\r\n        if (pos + length <= buffer.length) {\r\n            \/\/ the whole segment fits to the space *after* the referenced\r\n            \/\/ segment identifiers we've already written, so we can safely\r\n            \/\/ copy those bits ahead even if concurrent code is still\r\n            \/\/ reading from that part of the buffer\r\n            System.arraycopy(buffer, 0, buffer, buffer.length - length, pos);\r\n            pos += buffer.length - length;\r\n        } else {\r\n            \/\/ this might leave some empty space between the header and\r\n            \/\/ the record data, but this case only occurs when the\r\n            \/\/ segment is >252kB in size and the maximum overhead is <<4kB,\r\n            \/\/ which is acceptable\r\n            length = buffer.length;\r\n        }\r\n        for (Map.Entry<RecordId, RecordType> entry : roots.entrySet()) {\r\n            int offset = entry.getKey().getOffset();\r\n            buffer[pos++] = (byte) entry.getValue().ordinal();\r\n            buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\r\n            buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\r\n        }\r\n        for (RecordId blobref : blobrefs) {\r\n            int offset = blobref.getOffset();\r\n            buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\r\n            buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\r\n        }\r\n        SegmentId id = segment.getSegmentId();\r\n        log.debug(\"Writing data segment {} ({} bytes)\", id, length);\r\n        store.writeSegment(id, buffer, buffer.length - length, length);\r\n        \/\/ Keep this segment in memory as it's likely to be accessed soon\r\n        ByteBuffer data;\r\n        if (buffer.length - length > 4096) {\r\n            data = ByteBuffer.allocate(length);\r\n            data.put(buffer, buffer.length - length, length);\r\n            data.rewind();\r\n        } else {\r\n            data = ByteBuffer.wrap(buffer, buffer.length - length, length);\r\n        }\r\n        tracker.setSegment(id, new Segment(tracker, id, data));\r\n        buffer = createNewBuffer();\r\n        roots.clear();\r\n        blobrefs.clear();\r\n        length = 0;\r\n        position = buffer.length;\r\n        segment = new Segment(tracker, buffer);\r\n        segment.getSegmentId().setSegment(segment);\r\n    }\r\n}","code_comment":"\/**\r\n * Adds a segment header to the buffer and writes a segment to the segment\r\n * store. This is done automatically (called from prepare) when there is not\r\n * enough space for a record. It can also be called explicitly.\r\n *\/\r\n","code_no_comment":"public synchronized void flush() {\r\n    if (length > 0) {\r\n        int refcount = segment.getRefCount();\r\n        int rootcount = roots.size();\r\n        buffer[Segment.ROOT_COUNT_OFFSET] = (byte) (rootcount >> 8);\r\n        buffer[Segment.ROOT_COUNT_OFFSET + 1] = (byte) rootcount;\r\n        int blobrefcount = blobrefs.size();\r\n        buffer[Segment.BLOBREF_COUNT_OFFSET] = (byte) (blobrefcount >> 8);\r\n        buffer[Segment.BLOBREF_COUNT_OFFSET + 1] = (byte) blobrefcount;\r\n        length = align(refcount * 16 + rootcount * 3 + blobrefcount * 2 + length, 16);\r\n        int pos = refcount * 16;\r\n        if (pos + length <= buffer.length) {\r\n                                                            System.arraycopy(buffer, 0, buffer, buffer.length - length, pos);\r\n            pos += buffer.length - length;\r\n        } else {\r\n                                                            length = buffer.length;\r\n        }\r\n        for (Map.Entry<RecordId, RecordType> entry : roots.entrySet()) {\r\n            int offset = entry.getKey().getOffset();\r\n            buffer[pos++] = (byte) entry.getValue().ordinal();\r\n            buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\r\n            buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\r\n        }\r\n        for (RecordId blobref : blobrefs) {\r\n            int offset = blobref.getOffset();\r\n            buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\r\n            buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\r\n        }\r\n        SegmentId id = segment.getSegmentId();\r\n        log.debug(\"Writing data segment {} ({} bytes)\", id, length);\r\n        store.writeSegment(id, buffer, buffer.length - length, length);\r\n                ByteBuffer data;\r\n        if (buffer.length - length > 4096) {\r\n            data = ByteBuffer.allocate(length);\r\n            data.put(buffer, buffer.length - length, length);\r\n            data.rewind();\r\n        } else {\r\n            data = ByteBuffer.wrap(buffer, buffer.length - length, length);\r\n        }\r\n        tracker.setSegment(id, new Segment(tracker, id, data));\r\n        buffer = createNewBuffer();\r\n        roots.clear();\r\n        blobrefs.clear();\r\n        length = 0;\r\n        position = buffer.length;\r\n        segment = new Segment(tracker, buffer);\r\n        segment.getSegmentId().setSegment(segment);\r\n    }\r\n}","lc":1.5909090909,"pi":-0.1291866029,"ma":0.4,"nbd":0.0,"ml":0.0833333333,"d":2.0972222222,"mi":-0.9044397463,"fo":1.5,"r":-0.0263157895,"e":8.0652109519}
{"project_name":"Lang","project_version":"9","label":1,"code":"\/**\r\n * Initialize derived fields from defining fields.\r\n * This is called from constructor and from readObject (de-serialization)\r\n *\/\r\nprivate void init() {\r\n    thisYear = Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\r\n    nameValues = new ConcurrentHashMap<Integer, KeyValue[]>();\r\n    StringBuilder regex = new StringBuilder();\r\n    List<Strategy> collector = new ArrayList<Strategy>();\r\n    Matcher patternMatcher = formatPattern.matcher(pattern);\r\n    if (!patternMatcher.lookingAt()) {\r\n        throw new IllegalArgumentException(\"Invalid pattern\");\r\n    }\r\n    currentFormatField = patternMatcher.group();\r\n    Strategy currentStrategy = getStrategy(currentFormatField);\r\n    for (; ; ) {\r\n        patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\r\n        if (!patternMatcher.lookingAt()) {\r\n            nextStrategy = null;\r\n            break;\r\n        }\r\n        String nextFormatField = patternMatcher.group();\r\n        nextStrategy = getStrategy(nextFormatField);\r\n        if (currentStrategy.addRegex(this, regex)) {\r\n            collector.add(currentStrategy);\r\n        }\r\n        currentFormatField = nextFormatField;\r\n        currentStrategy = nextStrategy;\r\n    }\r\n    if (currentStrategy.addRegex(this, regex)) {\r\n        collector.add(currentStrategy);\r\n    }\r\n    currentFormatField = null;\r\n    strategies = collector.toArray(new Strategy[collector.size()]);\r\n    parsePattern = Pattern.compile(regex.toString());\r\n}","code_comment":"\/**\r\n * Initialize derived fields from defining fields.\r\n * This is called from constructor and from readObject (de-serialization)\r\n *\/\r\n","code_no_comment":"private void init() {\r\n    thisYear = Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\r\n    nameValues = new ConcurrentHashMap<Integer, KeyValue[]>();\r\n    StringBuilder regex = new StringBuilder();\r\n    List<Strategy> collector = new ArrayList<Strategy>();\r\n    Matcher patternMatcher = formatPattern.matcher(pattern);\r\n    if (!patternMatcher.lookingAt()) {\r\n        throw new IllegalArgumentException(\"Invalid pattern\");\r\n    }\r\n    currentFormatField = patternMatcher.group();\r\n    Strategy currentStrategy = getStrategy(currentFormatField);\r\n    for (; ; ) {\r\n        patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\r\n        if (!patternMatcher.lookingAt()) {\r\n            nextStrategy = null;\r\n            break;\r\n        }\r\n        String nextFormatField = patternMatcher.group();\r\n        nextStrategy = getStrategy(nextFormatField);\r\n        if (currentStrategy.addRegex(this, regex)) {\r\n            collector.add(currentStrategy);\r\n        }\r\n        currentFormatField = nextFormatField;\r\n        currentStrategy = nextStrategy;\r\n    }\r\n    if (currentStrategy.addRegex(this, regex)) {\r\n        collector.add(currentStrategy);\r\n    }\r\n    currentFormatField = null;\r\n    strategies = collector.toArray(new Strategy[collector.size()]);\r\n    parsePattern = Pattern.compile(regex.toString());\r\n}","lc":0.8181818182,"pi":0.004784689,"ma":0.8,"nbd":0.0,"ml":0.1666666667,"d":-0.0099206349,"mi":-0.5864693446,"fo":1.1666666667,"r":-0.0263157895,"e":0.3044691482}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"\/**\r\n *  Static utility to parse a field of type int from a byte sequence that represents text characters\r\n *  (such as when read from a file stream).\r\n *\r\n *  @param bytes The bytes containing the text data that should be parsed.\r\n *  @param startPos The offset to start the parsing.\r\n *  @param length The length of the byte sequence (counting from the offset).\r\n *  @param delimiter The delimiter that terminates the field.\r\n *\r\n *  @return The parsed value.\r\n *\r\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\r\n *\/\r\npublic static final int parseField(byte[] bytes, int startPos, int length, char delimiter) {\r\n    if (length <= 0) {\r\n        throw new NumberFormatException(\"Invalid input: Empty string\");\r\n    }\r\n    long val = 0;\r\n    boolean neg = false;\r\n    if (bytes[startPos] == '-') {\r\n        neg = true;\r\n        startPos++;\r\n        length--;\r\n        if (length == 0 || bytes[startPos] == delimiter) {\r\n            throw new NumberFormatException(\"Orphaned minus sign.\");\r\n        }\r\n    }\r\n    for (; length > 0; startPos++, length--) {\r\n        if (bytes[startPos] == delimiter) {\r\n            return (int) (neg ? -val : val);\r\n        }\r\n        if (bytes[startPos] < 48 || bytes[startPos] > 57) {\r\n            throw new NumberFormatException(\"Invalid character.\");\r\n        }\r\n        val *= 10;\r\n        val += bytes[startPos] - 48;\r\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\r\n            throw new NumberFormatException(\"Value overflow\/underflow\");\r\n        }\r\n    }\r\n    return (int) (neg ? -val : val);\r\n}","code_comment":"\/**\r\n *  Static utility to parse a field of type int from a byte sequence that represents text characters\r\n *  (such as when read from a file stream).\r\n *\r\n *  @param bytes The bytes containing the text data that should be parsed.\r\n *  @param startPos The offset to start the parsing.\r\n *  @param length The length of the byte sequence (counting from the offset).\r\n *  @param delimiter The delimiter that terminates the field.\r\n *\r\n *  @return The parsed value.\r\n *\r\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\r\n *\/\r\n","code_no_comment":"public static final int parseField(byte[] bytes, int startPos, int length, char delimiter) {\r\n    if (length <= 0) {\r\n        throw new NumberFormatException(\"Invalid input: Empty string\");\r\n    }\r\n    long val = 0;\r\n    boolean neg = false;\r\n    if (bytes[startPos] == '-') {\r\n        neg = true;\r\n        startPos++;\r\n        length--;\r\n        if (length == 0 || bytes[startPos] == delimiter) {\r\n            throw new NumberFormatException(\"Orphaned minus sign.\");\r\n        }\r\n    }\r\n    for (; length > 0; startPos++, length--) {\r\n        if (bytes[startPos] == delimiter) {\r\n            return (int) (neg ? -val : val);\r\n        }\r\n        if (bytes[startPos] < 48 || bytes[startPos] > 57) {\r\n            throw new NumberFormatException(\"Invalid character.\");\r\n        }\r\n        val *= 10;\r\n        val += bytes[startPos] - 48;\r\n        if (val > OVERFLOW_BOUND && (!neg || val > UNDERFLOW_BOUND)) {\r\n            throw new NumberFormatException(\"Value overflow\/underflow\");\r\n        }\r\n    }\r\n    return (int) (neg ? -val : val);\r\n}","lc":0.6818181818,"pi":0.0861244019,"ma":2.0,"nbd":0.0,"ml":1.0,"d":2.9900793651,"mi":-0.5484143763,"fo":-0.5,"r":-0.0263157895,"e":3.3959740207}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3789_9319e139","label":1,"code":"public boolean storeFile(String fileName, Exchange exchange) throws GenericFileOperationFailedException {\r\n    ObjectHelper.notNull(endpoint, \"endpoint\");\r\n    File file = new File(fileName);\r\n    \/\/ if an existing file already exists what should we do?\r\n    if (file.exists()) {\r\n        if (endpoint.getFileExist() == GenericFileExist.Ignore) {\r\n            \/\/ ignore but indicate that the file was written\r\n            LOG.trace(\"An existing file already exists: {}. Ignore and do not override it.\", file);\r\n            return true;\r\n        } else if (endpoint.getFileExist() == GenericFileExist.Fail) {\r\n            throw new GenericFileOperationFailedException(\"File already exist: \" + file + \". Cannot write new file.\");\r\n        }\r\n    }\r\n    \/\/ 3. write stream to file\r\n    try {\r\n        \/\/ is the body file based\r\n        File source = null;\r\n        \/\/ get the File Object from in message\r\n        source = exchange.getIn().getBody(File.class);\r\n        if (source != null) {\r\n            \/\/ okay we know the body is a file type\r\n            \/\/ so try to see if we can optimize by renaming the local work path file instead of doing\r\n            \/\/ a full file to file copy, as the local work copy is to be deleted afterwards anyway\r\n            \/\/ local work path\r\n            File local = exchange.getIn().getHeader(Exchange.FILE_LOCAL_WORK_PATH, File.class);\r\n            if (local != null && local.exists()) {\r\n                boolean renamed = writeFileByLocalWorkPath(local, file);\r\n                if (renamed) {\r\n                    \/\/ try to keep last modified timestamp if configured to do so\r\n                    keepLastModified(exchange, file);\r\n                    \/\/ clear header as we have renamed the file\r\n                    exchange.getIn().setHeader(Exchange.FILE_LOCAL_WORK_PATH, null);\r\n                    \/\/ to the target.\r\n                    return true;\r\n                }\r\n            } else if (source.exists()) {\r\n                \/\/ no there is no local work file so use file to file copy if the source exists\r\n                writeFileByFile(source, file);\r\n                \/\/ try to keep last modified timestamp if configured to do so\r\n                keepLastModified(exchange, file);\r\n                return true;\r\n            }\r\n        }\r\n        \/\/ fallback and use stream based\r\n        InputStream in = ExchangeHelper.getMandatoryInBody(exchange, InputStream.class);\r\n        writeFileByStream(in, file);\r\n        \/\/ try to keep last modified timestamp if configured to do so\r\n        keepLastModified(exchange, file);\r\n        return true;\r\n    } catch (IOException e) {\r\n        throw new GenericFileOperationFailedException(\"Cannot store file: \" + file, e);\r\n    } catch (InvalidPayloadException e) {\r\n        throw new GenericFileOperationFailedException(\"Cannot store file: \" + file, e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public boolean storeFile(String fileName, Exchange exchange) throws GenericFileOperationFailedException {\r\n    ObjectHelper.notNull(endpoint, \"endpoint\");\r\n    File file = new File(fileName);\r\n        if (file.exists()) {\r\n        if (endpoint.getFileExist() == GenericFileExist.Ignore) {\r\n                        LOG.trace(\"An existing file already exists: {}. Ignore and do not override it.\", file);\r\n            return true;\r\n        } else if (endpoint.getFileExist() == GenericFileExist.Fail) {\r\n            throw new GenericFileOperationFailedException(\"File already exist: \" + file + \". Cannot write new file.\");\r\n        }\r\n    }\r\n        try {\r\n                File source = null;\r\n                source = exchange.getIn().getBody(File.class);\r\n        if (source != null) {\r\n                                                            File local = exchange.getIn().getHeader(Exchange.FILE_LOCAL_WORK_PATH, File.class);\r\n            if (local != null && local.exists()) {\r\n                boolean renamed = writeFileByLocalWorkPath(local, file);\r\n                if (renamed) {\r\n                                        keepLastModified(exchange, file);\r\n                                        exchange.getIn().setHeader(Exchange.FILE_LOCAL_WORK_PATH, null);\r\n                                        return true;\r\n                }\r\n            } else if (source.exists()) {\r\n                                writeFileByFile(source, file);\r\n                                keepLastModified(exchange, file);\r\n                return true;\r\n            }\r\n        }\r\n                InputStream in = ExchangeHelper.getMandatoryInBody(exchange, InputStream.class);\r\n        writeFileByStream(in, file);\r\n                keepLastModified(exchange, file);\r\n        return true;\r\n    } catch (IOException e) {\r\n        throw new GenericFileOperationFailedException(\"Cannot store file: \" + file, e);\r\n    } catch (InvalidPayloadException e) {\r\n        throw new GenericFileOperationFailedException(\"Cannot store file: \" + file, e);\r\n    }\r\n}","lc":1.1363636364,"pi":1.0861244019,"ma":1.8,"nbd":1.0,"ml":1.0,"d":0.5813492063,"mi":-0.7330514447,"fo":1.1666666667,"r":-0.0263157895,"e":1.3073978666}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5138_e8dab4a0","label":1,"code":"\/**\r\n *  Provide a standard getter for filterPath.\r\n *  @return The configured filterPath.\r\n *\/\r\nprotected String getFilterPath() {\r\n    return filterPath;\r\n}","code_comment":"\/**\r\n *  Provide a standard getter for filterPath.\r\n *  @return The configured filterPath.\r\n *\/\r\n","code_no_comment":"protected String getFilterPath() {\r\n    return filterPath;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1646229739,"fo":-0.5,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7160_095fa2b4","label":1,"code":"\/*\r\n     * Determine what the next available time slot is for handling an Exchange\r\n     *\/\r\nprotected synchronized TimeSlot nextSlot() {\r\n    if (slot == null) {\r\n        slot = new TimeSlot();\r\n    }\r\n    if (slot.isFull() || !slot.isActive()) {\r\n        slot = slot.next();\r\n    }\r\n    slot.assign();\r\n    return slot;\r\n}","code_comment":null,"code_no_comment":"protected synchronized TimeSlot nextSlot() {\r\n    if (slot == null) {\r\n        slot = new TimeSlot();\r\n    }\r\n    if (slot.isFull() || !slot.isActive()) {\r\n        slot = slot.next();\r\n    }\r\n    slot.assign();\r\n    return slot;\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":-0.2,"nbd":-0.5,"ml":0.0833333333,"d":0.3849206349,"mi":0.2617336152,"fo":-0.1666666667,"r":0.4736842105,"e":-0.0210024031}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"\/**\r\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT.\r\n *\r\n *  Adds a child component to this container.\r\n *\r\n *  @param child\r\n *             The child\r\n *  @throws IllegalArgumentException\r\n *              Thrown if a child with the same id is replaced by the add\r\n *              operation.\r\n *\/\r\npublic void internalAdd(final Component child) {\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"internalAdd \" + child.getId() + \" to \" + this);\r\n    }\r\n    \/\/ Add to map\r\n    addedComponent(child);\r\n    put(child);\r\n}","code_comment":"\/**\r\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT.\r\n *\r\n *  Adds a child component to this container.\r\n *\r\n *  @param child\r\n *             The child\r\n *  @throws IllegalArgumentException\r\n *              Thrown if a child with the same id is replaced by the add\r\n *              operation.\r\n *\/\r\n","code_no_comment":"public void internalAdd(final Component child) {\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"internalAdd \" + child.getId() + \" to \" + this);\r\n    }\r\n        addedComponent(child);\r\n    put(child);\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.4689217759,"fo":-0.0833333333,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"@Nonnull\r\nprotected synchronized NodeBuilder getNodeBuilder() {\r\n    if (nodeBuilder == null) {\r\n        nodeBuilder = parent.getNodeBuilder().child(name);\r\n    }\r\n    return nodeBuilder;\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\nprotected synchronized NodeBuilder getNodeBuilder() {\r\n    if (nodeBuilder == null) {\r\n        nodeBuilder = parent.getNodeBuilder().child(name);\r\n    }\r\n    return nodeBuilder;\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1011904762,"mi":0.5072586328,"fo":-0.3333333333,"r":1.2894736842,"e":-0.1330198302}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2368_fae1601b","label":1,"code":"public Object component(final Component component) {\r\n    \/\/ If component never rendered\r\n    if (renderedComponents == null || !renderedComponents.contains(component)) {\r\n        \/\/ If auto component ...\r\n        if (!component.isAuto() && component.isVisibleInHierarchy()) {\r\n            \/\/ Increase number of unrendered components\r\n            unrenderedComponents.add(component);\r\n            \/\/ Add to explanatory string to buffer\r\n            buffer.append(Integer.toString(unrenderedComponents.size()) + \". \" + component + \"\\n\");\r\n            String metadata = component.getMetaData(Component.CONSTRUCTED_AT_KEY);\r\n            if (metadata != null) {\r\n                buffer.append(metadata);\r\n            }\r\n            metadata = component.getMetaData(Component.ADDED_AT_KEY);\r\n            if (metadata != null) {\r\n                buffer.append(metadata);\r\n            }\r\n        } else {\r\n            \/\/ not visible\r\n            return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;\r\n        }\r\n    }\r\n    return CONTINUE_TRAVERSAL;\r\n}","code_comment":null,"code_no_comment":"public Object component(final Component component) {\r\n        if (renderedComponents == null || !renderedComponents.contains(component)) {\r\n                if (!component.isAuto() && component.isVisibleInHierarchy()) {\r\n                        unrenderedComponents.add(component);\r\n                        buffer.append(Integer.toString(unrenderedComponents.size()) + \". \" + component + \"\\n\");\r\n            String metadata = component.getMetaData(Component.CONSTRUCTED_AT_KEY);\r\n            if (metadata != null) {\r\n                buffer.append(metadata);\r\n            }\r\n            metadata = component.getMetaData(Component.ADDED_AT_KEY);\r\n            if (metadata != null) {\r\n                buffer.append(metadata);\r\n            }\r\n        } else {\r\n                        return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;\r\n        }\r\n    }\r\n    return CONTINUE_TRAVERSAL;\r\n}","lc":0.2272727273,"pi":0.8133971292,"ma":0.2,"nbd":0.5,"ml":0.5833333333,"d":0.8015873016,"mi":-0.2329809725,"fo":0.4166666667,"r":-0.0263157895,"e":0.6369161437}
{"project_name":"Compress","project_version":"22","label":3,"code":"private int setupRandPartC() throws IOException {\r\n    if (this.su_j2 < this.su_z) {\r\n        this.currentChar = this.su_ch2;\r\n        this.crc.updateCRC(this.su_ch2);\r\n        this.su_j2++;\r\n        return this.su_ch2;\r\n    } else {\r\n        this.currentState = RAND_PART_A_STATE;\r\n        this.su_i2++;\r\n        this.su_count = 0;\r\n        return setupRandPartA();\r\n    }\r\n}","code_comment":null,"code_no_comment":"private int setupRandPartC() throws IOException {\r\n    if (this.su_j2 < this.su_z) {\r\n        this.currentChar = this.su_ch2;\r\n        this.crc.updateCRC(this.su_ch2);\r\n        this.su_j2++;\r\n        return this.su_ch2;\r\n    } else {\r\n        this.currentState = RAND_PART_A_STATE;\r\n        this.su_i2++;\r\n        this.su_count = 0;\r\n        return setupRandPartA();\r\n    }\r\n}","lc":-0.0454545455,"pi":-0.004784689,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.126984127,"mi":0.1182522903,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.1074278338}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-657_97b440fc","label":3,"code":"\/**\r\n * Returns a {@code Complex} whose value is {@code (this \/ divisor)},\r\n * with {@code divisor} interpreted as a real number.\r\n *\r\n * @param  divisor Value by which this {@code Complex} is to be divided.\r\n * @return {@code this \/ divisor}.\r\n * @see #divide(Complex)\r\n *\/\r\npublic Complex divide(double divisor) {\r\n    if (isNaN || Double.isNaN(divisor)) {\r\n        return NaN;\r\n    }\r\n    if (divisor == 0d) {\r\n        return isZero ? NaN : INF;\r\n    }\r\n    if (Double.isInfinite(divisor)) {\r\n        return !isInfinite() ? ZERO : NaN;\r\n    }\r\n    return createComplex(real \/ divisor, imaginary \/ divisor);\r\n}","code_comment":"\/**\r\n * Returns a {@code Complex} whose value is {@code (this \/ divisor)},\r\n * with {@code divisor} interpreted as a real number.\r\n *\r\n * @param  divisor Value by which this {@code Complex} is to be divided.\r\n * @return {@code this \/ divisor}.\r\n * @see #divide(Complex)\r\n *\/\r\n","code_no_comment":"public Complex divide(double divisor) {\r\n    if (isNaN || Double.isNaN(divisor)) {\r\n        return NaN;\r\n    }\r\n    if (divisor == 0d) {\r\n        return isZero ? NaN : INF;\r\n    }\r\n    if (Double.isInfinite(divisor)) {\r\n        return !isInfinite() ? ZERO : NaN;\r\n    }\r\n    return createComplex(real \/ divisor, imaginary \/ divisor);\r\n}","lc":-0.0909090909,"pi":-0.2057416268,"ma":0.4,"nbd":-0.5,"ml":0.5833333333,"d":0.2956349206,"mi":0.0934460888,"fo":-0.1666666667,"r":0.3157894737,"e":0.0330492211}
{"project_name":"Math","project_version":"101","label":1,"code":"\/**\r\n * Parses a string to produce a {@link Complex} object.\r\n *\r\n * @param source the string to parse\r\n * @param pos input\/ouput parsing parameter.\r\n * @return the parsed {@link Complex} object.\r\n *\/\r\npublic Complex parse(String source, ParsePosition pos) {\r\n    int initialIndex = pos.getIndex();\r\n    \/\/ parse whitespace\r\n    parseAndIgnoreWhitespace(source, pos);\r\n    \/\/ parse real\r\n    Number re = parseNumber(source, getRealFormat(), pos);\r\n    if (re == null) {\r\n        \/\/ invalid real number\r\n        \/\/ set index back to initial, error index should already be set\r\n        \/\/ character examined.\r\n        pos.setIndex(initialIndex);\r\n        return null;\r\n    }\r\n    \/\/ parse sign\r\n    int startIndex = pos.getIndex();\r\n    char c = parseNextCharacter(source, pos);\r\n    int sign = 0;\r\n    switch(c) {\r\n        case 0:\r\n            \/\/ return real only complex number\r\n            return new Complex(re.doubleValue(), 0.0);\r\n        case '-':\r\n            sign = -1;\r\n            break;\r\n        case '+':\r\n            sign = 1;\r\n            break;\r\n        default:\r\n            \/\/ invalid sign\r\n            \/\/ set index back to initial, error index should be the last\r\n            \/\/ character examined.\r\n            pos.setIndex(initialIndex);\r\n            pos.setErrorIndex(startIndex);\r\n            return null;\r\n    }\r\n    \/\/ parse whitespace\r\n    parseAndIgnoreWhitespace(source, pos);\r\n    \/\/ parse imaginary\r\n    Number im = parseNumber(source, getRealFormat(), pos);\r\n    if (im == null) {\r\n        \/\/ invalid imaginary number\r\n        \/\/ set index back to initial, error index should already be set\r\n        \/\/ character examined.\r\n        pos.setIndex(initialIndex);\r\n        return null;\r\n    }\r\n    \/\/ parse imaginary character\r\n    int n = getImaginaryCharacter().length();\r\n    startIndex = pos.getIndex();\r\n    int endIndex = startIndex + n;\r\n    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\r\n        \/\/ set index back to initial, error index should be the start index\r\n        \/\/ character examined.\r\n        pos.setIndex(initialIndex);\r\n        pos.setErrorIndex(startIndex);\r\n        return null;\r\n    }\r\n    pos.setIndex(endIndex);\r\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\r\n}","code_comment":"\/**\r\n * Parses a string to produce a {@link Complex} object.\r\n *\r\n * @param source the string to parse\r\n * @param pos input\/ouput parsing parameter.\r\n * @return the parsed {@link Complex} object.\r\n *\/\r\n","code_no_comment":"public Complex parse(String source, ParsePosition pos) {\r\n    int initialIndex = pos.getIndex();\r\n        parseAndIgnoreWhitespace(source, pos);\r\n        Number re = parseNumber(source, getRealFormat(), pos);\r\n    if (re == null) {\r\n                                pos.setIndex(initialIndex);\r\n        return null;\r\n    }\r\n        int startIndex = pos.getIndex();\r\n    char c = parseNextCharacter(source, pos);\r\n    int sign = 0;\r\n    switch(c) {\r\n        case 0:\r\n                        return new Complex(re.doubleValue(), 0.0);\r\n        case '-':\r\n            sign = -1;\r\n            break;\r\n        case '+':\r\n            sign = 1;\r\n            break;\r\n        default:\r\n                                                pos.setIndex(initialIndex);\r\n            pos.setErrorIndex(startIndex);\r\n            return null;\r\n    }\r\n        parseAndIgnoreWhitespace(source, pos);\r\n        Number im = parseNumber(source, getRealFormat(), pos);\r\n    if (im == null) {\r\n                                pos.setIndex(initialIndex);\r\n        return null;\r\n    }\r\n        int n = getImaginaryCharacter().length();\r\n    startIndex = pos.getIndex();\r\n    int endIndex = startIndex + n;\r\n    if (source.substring(startIndex, endIndex).compareTo(getImaginaryCharacter()) != 0) {\r\n                        pos.setIndex(initialIndex);\r\n        pos.setErrorIndex(startIndex);\r\n        return null;\r\n    }\r\n    pos.setIndex(endIndex);\r\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\r\n}","lc":1.2727272727,"pi":0.1913875598,"ma":1.2,"nbd":0.0,"ml":0.5,"d":1.3849206349,"mi":-0.7372797745,"fo":1.5833333333,"r":-0.0263157895,"e":2.3701780167}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4358_74cbba24","label":1,"code":"@Override\r\nprotected Revision computeNext() {\r\n    if (stack.isEmpty()) {\r\n        return endOfData();\r\n    }\r\n    Revision next = stack.first();\r\n    stack.remove(next);\r\n    fillStackIfNeeded();\r\n    return next;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected Revision computeNext() {\r\n    if (stack.isEmpty()) {\r\n        return endOfData();\r\n    }\r\n    Revision next = stack.first();\r\n    stack.remove(next);\r\n    fillStackIfNeeded();\r\n    return next;\r\n}","lc":-0.1818181818,"pi":-0.2822966507,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.310782241,"fo":-0.0833333333,"r":1.1842105263,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2390_28294266","label":1,"code":"@SuppressWarnings(\"unchecked\")\r\npublic static <T> T trace(final T instance, final Sampler sampler) {\r\n    InvocationHandler handler = new InvocationHandler() {\r\n\r\n        @Override\r\n        public Object invoke(Object obj, Method method, Object[] args) throws Throwable {\r\n            if (!sampler.next()) {\r\n                return method.invoke(instance, args);\r\n            }\r\n            Span span = Trace.on(method.getName());\r\n            try {\r\n                return method.invoke(instance, args);\r\n            } catch (Throwable ex) {\r\n                ex.printStackTrace();\r\n                throw ex;\r\n            } finally {\r\n                span.stop();\r\n            }\r\n        }\r\n    };\r\n    return (T) Proxy.newProxyInstance(instance.getClass().getClassLoader(), instance.getClass().getInterfaces(), handler);\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings(\"unchecked\")\r\npublic static <T> T trace(final T instance, final Sampler sampler) {\r\n    InvocationHandler handler = new InvocationHandler() {\r\n\r\n        @Override\r\n        public Object invoke(Object obj, Method method, Object[] args) throws Throwable {\r\n            if (!sampler.next()) {\r\n                return method.invoke(instance, args);\r\n            }\r\n            Span span = Trace.on(method.getName());\r\n            try {\r\n                return method.invoke(instance, args);\r\n            } catch (Throwable ex) {\r\n                ex.printStackTrace();\r\n                throw ex;\r\n            } finally {\r\n                span.stop();\r\n            }\r\n        }\r\n    };\r\n    return (T) Proxy.newProxyInstance(instance.getClass().getClassLoader(), instance.getClass().getInterfaces(), handler);\r\n}","lc":0.3181818182,"pi":1.1770334928,"ma":0.0,"nbd":0.0,"ml":-0.25,"d":-0.0178571429,"mi":-0.2747004933,"fo":0.5,"r":0.0,"e":0.0793785262}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5720_4a05eccf","label":3,"code":"\/**\r\n * Tests whether the given exchange is complete or not\r\n *\r\n * @param key      the correlation key\r\n * @param exchange the incoming exchange\r\n * @return <tt>null<\/tt> if not completed, otherwise a String with the type that triggered the completion\r\n *\/\r\nprotected String isCompleted(String key, Exchange exchange) {\r\n    if (getCompletionPredicate() != null) {\r\n        boolean answer = getCompletionPredicate().matches(exchange);\r\n        if (answer) {\r\n            return \"predicate\";\r\n        }\r\n    }\r\n    if (getCompletionSizeExpression() != null) {\r\n        Integer value = getCompletionSizeExpression().evaluate(exchange, Integer.class);\r\n        if (value != null && value > 0) {\r\n            int size = exchange.getProperty(Exchange.AGGREGATED_SIZE, 1, Integer.class);\r\n            if (size >= value) {\r\n                return \"size\";\r\n            }\r\n        }\r\n    }\r\n    if (getCompletionSize() > 0) {\r\n        int size = exchange.getProperty(Exchange.AGGREGATED_SIZE, 1, Integer.class);\r\n        if (size >= getCompletionSize()) {\r\n            return \"size\";\r\n        }\r\n    }\r\n    \/\/ timeout can be either evaluated based on an expression or from a fixed value\r\n    \/\/ expression takes precedence\r\n    boolean timeoutSet = false;\r\n    if (getCompletionTimeoutExpression() != null) {\r\n        Long value = getCompletionTimeoutExpression().evaluate(exchange, Long.class);\r\n        if (value != null && value > 0) {\r\n            if (LOG.isTraceEnabled()) {\r\n                LOG.trace(\"Updating correlation key {} to timeout after {} ms. as exchange received: {}\", new Object[] { key, value, exchange });\r\n            }\r\n            addExchangeToTimeoutMap(key, exchange, value);\r\n            timeoutSet = true;\r\n        }\r\n    }\r\n    if (!timeoutSet && getCompletionTimeout() > 0) {\r\n        \/\/ timeout is used so use the timeout map to keep an eye on this\r\n        if (LOG.isTraceEnabled()) {\r\n            LOG.trace(\"Updating correlation key {} to timeout after {} ms. as exchange received: {}\", new Object[] { key, getCompletionTimeout(), exchange });\r\n        }\r\n        addExchangeToTimeoutMap(key, exchange, getCompletionTimeout());\r\n    }\r\n    if (isCompletionFromBatchConsumer()) {\r\n        batchConsumerCorrelationKeys.add(key);\r\n        batchConsumerCounter.incrementAndGet();\r\n        int size = exchange.getProperty(Exchange.BATCH_SIZE, 0, Integer.class);\r\n        if (size > 0 && batchConsumerCounter.intValue() >= size) {\r\n            \/\/ batch consumer is complete then reset the counter\r\n            batchConsumerCounter.set(0);\r\n            return \"consumer\";\r\n        }\r\n    }\r\n    \/\/ not complete\r\n    return null;\r\n}","code_comment":"\/**\r\n * Tests whether the given exchange is complete or not\r\n *\r\n * @param key      the correlation key\r\n * @param exchange the incoming exchange\r\n * @return <tt>null<\/tt> if not completed, otherwise a String with the type that triggered the completion\r\n *\/\r\n","code_no_comment":"protected String isCompleted(String key, Exchange exchange) {\r\n    if (getCompletionPredicate() != null) {\r\n        boolean answer = getCompletionPredicate().matches(exchange);\r\n        if (answer) {\r\n            return \"predicate\";\r\n        }\r\n    }\r\n    if (getCompletionSizeExpression() != null) {\r\n        Integer value = getCompletionSizeExpression().evaluate(exchange, Integer.class);\r\n        if (value != null && value > 0) {\r\n            int size = exchange.getProperty(Exchange.AGGREGATED_SIZE, 1, Integer.class);\r\n            if (size >= value) {\r\n                return \"size\";\r\n            }\r\n        }\r\n    }\r\n    if (getCompletionSize() > 0) {\r\n        int size = exchange.getProperty(Exchange.AGGREGATED_SIZE, 1, Integer.class);\r\n        if (size >= getCompletionSize()) {\r\n            return \"size\";\r\n        }\r\n    }\r\n            boolean timeoutSet = false;\r\n    if (getCompletionTimeoutExpression() != null) {\r\n        Long value = getCompletionTimeoutExpression().evaluate(exchange, Long.class);\r\n        if (value != null && value > 0) {\r\n            if (LOG.isTraceEnabled()) {\r\n                LOG.trace(\"Updating correlation key {} to timeout after {} ms. as exchange received: {}\", new Object[] { key, value, exchange });\r\n            }\r\n            addExchangeToTimeoutMap(key, exchange, value);\r\n            timeoutSet = true;\r\n        }\r\n    }\r\n    if (!timeoutSet && getCompletionTimeout() > 0) {\r\n                if (LOG.isTraceEnabled()) {\r\n            LOG.trace(\"Updating correlation key {} to timeout after {} ms. as exchange received: {}\", new Object[] { key, getCompletionTimeout(), exchange });\r\n        }\r\n        addExchangeToTimeoutMap(key, exchange, getCompletionTimeout());\r\n    }\r\n    if (isCompletionFromBatchConsumer()) {\r\n        batchConsumerCorrelationKeys.add(key);\r\n        batchConsumerCounter.incrementAndGet();\r\n        int size = exchange.getProperty(Exchange.BATCH_SIZE, 0, Integer.class);\r\n        if (size > 0 && batchConsumerCounter.intValue() >= size) {\r\n                        batchConsumerCounter.set(0);\r\n            return \"consumer\";\r\n        }\r\n    }\r\n        return null;\r\n}","lc":1.6363636364,"pi":0.3205741627,"ma":2.2,"nbd":0.5,"ml":2.0833333333,"d":1.2936507937,"mi":-0.8858350951,"fo":1.8333333333,"r":-0.0263157895,"e":2.9143456487}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1460_f1ba7a42","label":1,"code":"@Override\r\npublic Resolution addExistingProperty(NodeBuilder parent, PropertyState ours, PropertyState theirs) {\r\n    if (isChildOrderProperty(ours)) {\r\n        \/\/ that was previously unordered.\r\n        return Resolution.THEIRS;\r\n    } else {\r\n        return handler.addExistingProperty(parent, ours, theirs);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Resolution addExistingProperty(NodeBuilder parent, PropertyState ours, PropertyState theirs) {\r\n    if (isChildOrderProperty(ours)) {\r\n                return Resolution.THEIRS;\r\n    } else {\r\n        return handler.addExistingProperty(parent, ours, theirs);\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.3961945032,"fo":-0.3333333333,"r":0.2368421053,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5965_31c88569","label":1,"code":"\/**\r\n *  Handle tag &lt;head&gt;\r\n *  @param tag\r\n *\/\r\nprivate void handleHeadTag(ComponentTag tag) {\r\n    \/\/ we found <head>\r\n    if (tag.isOpen()) {\r\n        if (foundHead) {\r\n            throw new MarkupException(new MarkupStream(markup), \"Tag <head> is not allowed at this position (do you have multiple <head> tags in your markup?).\");\r\n        }\r\n        foundHead = true;\r\n        if (tag.getId() == null) {\r\n            tag.setId(HEADER_ID);\r\n            tag.setAutoComponentTag(true);\r\n            tag.setModified(true);\r\n        }\r\n    } else if (tag.isClose()) {\r\n        if (foundHeaderItemsTag) {\r\n            \/\/ revert the settings from above\r\n            ComponentTag headOpenTag = tag.getOpenTag();\r\n            \/\/ change the id because it is special. See HtmlHeaderResolver\r\n            headOpenTag.setId(HEADER_ID + \"-Ignored\");\r\n            headOpenTag.setAutoComponentTag(false);\r\n            headOpenTag.setModified(false);\r\n            headOpenTag.setFlag(ComponentTag.RENDER_RAW, true);\r\n        }\r\n        foundClosingHead = true;\r\n    }\r\n}","code_comment":"\/**\r\n *  Handle tag &lt;head&gt;\r\n *  @param tag\r\n *\/\r\n","code_no_comment":"private void handleHeadTag(ComponentTag tag) {\r\n        if (tag.isOpen()) {\r\n        if (foundHead) {\r\n            throw new MarkupException(new MarkupStream(markup), \"Tag <head> is not allowed at this position (do you have multiple <head> tags in your markup?).\");\r\n        }\r\n        foundHead = true;\r\n        if (tag.getId() == null) {\r\n            tag.setId(HEADER_ID);\r\n            tag.setAutoComponentTag(true);\r\n            tag.setModified(true);\r\n        }\r\n    } else if (tag.isClose()) {\r\n        if (foundHeaderItemsTag) {\r\n                        ComponentTag headOpenTag = tag.getOpenTag();\r\n                        headOpenTag.setId(HEADER_ID + \"-Ignored\");\r\n            headOpenTag.setAutoComponentTag(false);\r\n            headOpenTag.setModified(false);\r\n            headOpenTag.setFlag(ComponentTag.RENDER_RAW, true);\r\n        }\r\n        foundClosingHead = true;\r\n    }\r\n}","lc":0.3636363636,"pi":0.3875598086,"ma":0.6,"nbd":0.5,"ml":0.4166666667,"d":0.0079365079,"mi":-0.2958421424,"fo":0.4166666667,"r":-0.0263157895,"e":0.0651371864}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-859_66dece12","label":1,"code":"\/**\r\n * Use this method to get information about whether the lower bound\r\n * of the support is inclusive or not.\r\n *\r\n * @return whether the lower bound of the support is inclusive or not\r\n *\/\r\nboolean isSupportLowerBoundInclusive();","code_comment":"\/**\r\n * Use this method to get information about whether the lower bound\r\n * of the support is inclusive or not.\r\n *\r\n * @return whether the lower bound of the support is inclusive or not\r\n *\/\r\n","code_no_comment":"boolean isSupportLowerBoundInclusive();","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.8696264975,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1822_3e83a4c1","label":1,"code":"\/**\r\n * Set the property to the given value.\r\n *\r\n * @param property the property name\r\n * @param value the value\r\n *\/\r\nvoid set(String property, Object value) {\r\n    Operation op = new Operation();\r\n    op.type = Operation.Type.SET;\r\n    op.value = value;\r\n    changes.put(new Key(property, null), op);\r\n}","code_comment":"\/**\r\n * Set the property to the given value.\r\n *\r\n * @param property the property name\r\n * @param value the value\r\n *\/\r\n","code_no_comment":"void set(String property, Object value) {\r\n    Operation op = new Operation();\r\n    op.type = Operation.Type.SET;\r\n    op.value = value;\r\n    changes.put(new Key(property, null), op);\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4720225511,"fo":-0.4166666667,"r":1.6315789474,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-276_1bf5c550","label":1,"code":"@Override\r\npublic boolean markNode(Id id) throws Exception {\r\n    return touch(id, gcStart);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean markNode(Id id) throws Exception {\r\n    return touch(id, gcStart);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8548273432,"fo":-0.4166666667,"r":1.7894736842,"e":-0.1627934049}
{"project_name":"Closure","project_version":"163","label":1,"code":"\/**\r\n * Returns true if this is the r-value of an assignment.\r\n *\/\r\nprivate boolean isPrototypePropertyAssign(Node assign) {\r\n    Node n = assign.getFirstChild();\r\n    if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) {\r\n        boolean isChainedProperty = n.getFirstChild().isGetProp();\r\n        \/**\r\n         * Returns the name of a prototype property being assigned to this r-value.\r\n         *\r\n         * Returns null if this is not the R-value of a prototype property, or if\r\n         * the R-value is used in multiple expressions (i.e., if there's\r\n         * a prototype property assignment in a more complex expression).\r\n         *\/\r\n        if (isChainedProperty) {\r\n            Node child = n.getFirstChild().getFirstChild().getNext();\r\n            if (child.isString() && child.getString().equals(\"prototype\")) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":"\/**\r\n * Returns true if this is the r-value of an assignment.\r\n *\/\r\n\/**\r\n * Returns the name of a prototype property being assigned to this r-value.\r\n *\r\n * Returns null if this is not the R-value of a prototype property, or if\r\n * the R-value is used in multiple expressions (i.e., if there's\r\n * a prototype property assignment in a more complex expression).\r\n *\/\r\n","code_no_comment":"private boolean isPrototypePropertyAssign(Node assign) {\r\n    Node n = assign.getFirstChild();\r\n    if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.isGetProp() && assign.getParent().isExprResult()) {\r\n        boolean isChainedProperty = n.getFirstChild().isGetProp();\r\n        \/**\r\n         * Returns the name of a prototype property being assigned to this r-value.\r\n         *\r\n         * Returns null if this is not the R-value of a prototype property, or if\r\n         * the R-value is used in multiple expressions (i.e., if there's\r\n         * a prototype property assignment in a more complex expression).\r\n         *\/\r\n        if (isChainedProperty) {\r\n            Node child = n.getFirstChild().getFirstChild().getNext();\r\n            if (child.isString() && child.getString().equals(\"prototype\")) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}","lc":0.2727272727,"pi":0.4497607656,"ma":0.0,"nbd":0.5,"ml":0.8333333333,"d":-0.005952381,"mi":-0.200845666,"fo":0.5833333333,"r":0.1842105263,"e":0.0131556047}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3280_295e73bd","label":1,"code":"@Override\r\nprotected void invoke(WebResponse response) {\r\n    response.write(builder);\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void invoke(WebResponse response) {\r\n    response.write(builder);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.881888654,"fo":-0.4166666667,"r":1.6315789474,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3396_c83755c3","label":0,"code":"@Nonnull\r\nprivate ExternalGroup createGroup(@Nonnull Entry entry, @CheckForNull String name) throws LdapInvalidAttributeValueException {\r\n    ExternalIdentityRef ref = new ExternalIdentityRef(entry.getDn().getName(), this.getName());\r\n    if (name == null) {\r\n        name = entry.get(config.getGroupConfig().getIdAttribute()).getString();\r\n    }\r\n    String path = config.getGroupConfig().makeDnPath() ? createDNPath(entry.getDn()) : null;\r\n    LdapGroup group = new LdapGroup(this, ref, name, path);\r\n    Map<String, Object> props = group.getProperties();\r\n    applyAttributes(props, entry);\r\n    return group;\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\nprivate ExternalGroup createGroup(@Nonnull Entry entry, @CheckForNull String name) throws LdapInvalidAttributeValueException {\r\n    ExternalIdentityRef ref = new ExternalIdentityRef(entry.getDn().getName(), this.getName());\r\n    if (name == null) {\r\n        name = entry.get(config.getGroupConfig().getIdAttribute()).getString();\r\n    }\r\n    String path = config.getGroupConfig().makeDnPath() ? createDNPath(entry.getDn()) : null;\r\n    LdapGroup group = new LdapGroup(this, ref, name, path);\r\n    Map<String, Object> props = group.getProperties();\r\n    applyAttributes(props, entry);\r\n    return group;\r\n}","lc":-0.0909090909,"pi":-0.3732057416,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0218253968,"mi":-0.007751938,"fo":0.5833333333,"r":-0.0263157895,"e":0.0689545478}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  Detaches any attached models referenced by this page.\r\n *\/\r\npublic void detachModels() {\r\n    \/\/ \/\/ visit all this page's children to detach the models\r\n    \/\/ visitChildren(new IVisitor()\r\n    \/\/ {\r\n    \/\/ public Object component(Component component)\r\n    \/\/ {\r\n    \/\/ try\r\n    \/\/ {\r\n    \/\/ \/\/ detach any models of the component\r\n    \/\/ component.detachModels();\r\n    \/\/ }\r\n    \/\/ catch (Exception e) \/\/ catch anything; we MUST detach all models\r\n    \/\/ {\r\n    \/\/ log.error(\"detaching models of component \" + component + \" failed:\", e);\r\n    \/\/ }\r\n    \/\/ return IVisitor.CONTINUE_TRAVERSAL;\r\n    \/\/ }\r\n    \/\/ });\r\n    super.detachModels();\r\n}","code_comment":"\/**\r\n *  Detaches any attached models referenced by this page.\r\n *\/\r\n","code_no_comment":"public void detachModels() {\r\n                                                                        super.detachModels();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.3083861875,"fo":-0.4166666667,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"Closure","project_version":"1","label":2,"code":"\/**\r\n * Removes unreferenced arguments from a function declaration and when\r\n * possible the function's callSites.\r\n *\r\n * @param fnScope The scope inside the function\r\n *\/\r\nprivate void removeUnreferencedFunctionArgs(Scope fnScope) {\r\n    \/\/ Notice that removing unreferenced function args breaks\r\n    \/\/ Function.prototype.length. In advanced mode, we don't really care\r\n    \/\/ about this: we consider \"length\" the equivalent of reflecting on\r\n    \/\/ the function's lexical source.\r\n    \/\/ \r\n    \/\/ Rather than create a new option for this, we assume that if the user\r\n    \/\/ is removing globals, then it's OK to remove unused function args.\r\n    \/\/ \r\n    \/\/ See http:\/\/code.google.com\/p\/closure-compiler\/issues\/detail?id=253\r\n    Node function = fnScope.getRootNode();\r\n    Preconditions.checkState(function.isFunction());\r\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\r\n        \/\/ The parameters object literal setters can not be removed.\r\n        return;\r\n    }\r\n    Node argList = getFunctionArgList(function);\r\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\r\n    if (!modifyCallers) {\r\n        \/\/ Strip unreferenced args off the end of the function declaration.\r\n        Node lastArg;\r\n        while ((lastArg = argList.getLastChild()) != null) {\r\n            Var var = fnScope.getVar(lastArg.getString());\r\n            if (!referenced.contains(var)) {\r\n                argList.removeChild(lastArg);\r\n                compiler.reportCodeChange();\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        callSiteOptimizer.optimize(fnScope, referenced);\r\n    }\r\n}","code_comment":"\/**\r\n * Removes unreferenced arguments from a function declaration and when\r\n * possible the function's callSites.\r\n *\r\n * @param fnScope The scope inside the function\r\n *\/\r\n","code_no_comment":"private void removeUnreferencedFunctionArgs(Scope fnScope) {\r\n                                        Node function = fnScope.getRootNode();\r\n    Preconditions.checkState(function.isFunction());\r\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\r\n                return;\r\n    }\r\n    Node argList = getFunctionArgList(function);\r\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\r\n    if (!modifyCallers) {\r\n                Node lastArg;\r\n        while ((lastArg = argList.getLastChild()) != null) {\r\n            Var var = fnScope.getVar(lastArg.getString());\r\n            if (!referenced.contains(var)) {\r\n                argList.removeChild(lastArg);\r\n                compiler.reportCodeChange();\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        callSiteOptimizer.optimize(fnScope, referenced);\r\n    }\r\n}","lc":0.4090909091,"pi":0.8468899522,"ma":0.4,"nbd":0.5,"ml":0.3333333333,"d":0.253968254,"mi":-0.3316420014,"fo":0.6666666667,"r":-0.0263157895,"e":0.2766641886}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1429_c2f5ca6c","label":1,"code":"private void diffManyChildren(JsopWriter w, String path, Revision fromRev, Revision toRev) {\r\n    long minTimestamp = Math.min(fromRev.getTimestamp(), toRev.getTimestamp());\r\n    long minValue = Commit.getModified(minTimestamp);\r\n    String fromKey = Utils.getKeyLowerLimit(path);\r\n    String toKey = Utils.getKeyUpperLimit(path);\r\n    Set<String> paths = Sets.newHashSet();\r\n    for (NodeDocument doc : store.query(Collection.NODES, fromKey, toKey, NodeDocument.MODIFIED, minValue, Integer.MAX_VALUE)) {\r\n        paths.add(Utils.getPathFromId(doc.getId()));\r\n    }\r\n    \/\/ also consider nodes with not yet stored modifications (OAK-1107)\r\n    Revision minRev = new Revision(minTimestamp, 0, getClusterId());\r\n    addPathsForDiff(path, paths, getPendingModifications(), minRev);\r\n    for (Revision r : new Revision[] { fromRev, toRev }) {\r\n        if (r.isBranch()) {\r\n            Branch b = getBranches().getBranch(fromRev);\r\n            if (b != null) {\r\n                addPathsForDiff(path, paths, b.getModifications(r), r);\r\n            }\r\n        }\r\n    }\r\n    for (String p : paths) {\r\n        DocumentNodeState fromNode = getNode(p, fromRev);\r\n        DocumentNodeState toNode = getNode(p, toRev);\r\n        if (fromNode != null) {\r\n            \/\/ exists in fromRev\r\n            if (toNode != null) {\r\n                \/\/ check if different\r\n                if (!fromNode.getLastRevision().equals(toNode.getLastRevision())) {\r\n                    w.tag('^').key(p).object().endObject().newline();\r\n                }\r\n            } else {\r\n                \/\/ does not exist in toRev -> was removed\r\n                w.tag('-').value(p).newline();\r\n            }\r\n        } else {\r\n            \/\/ does not exist in fromRev\r\n            if (toNode != null) {\r\n                \/\/ exists in toRev\r\n                w.tag('+').key(p).object().endObject().newline();\r\n            } else {\r\n            \/\/ does not exist in either revisions\r\n            \/\/ -> do nothing\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void diffManyChildren(JsopWriter w, String path, Revision fromRev, Revision toRev) {\r\n    long minTimestamp = Math.min(fromRev.getTimestamp(), toRev.getTimestamp());\r\n    long minValue = Commit.getModified(minTimestamp);\r\n    String fromKey = Utils.getKeyLowerLimit(path);\r\n    String toKey = Utils.getKeyUpperLimit(path);\r\n    Set<String> paths = Sets.newHashSet();\r\n    for (NodeDocument doc : store.query(Collection.NODES, fromKey, toKey, NodeDocument.MODIFIED, minValue, Integer.MAX_VALUE)) {\r\n        paths.add(Utils.getPathFromId(doc.getId()));\r\n    }\r\n        Revision minRev = new Revision(minTimestamp, 0, getClusterId());\r\n    addPathsForDiff(path, paths, getPendingModifications(), minRev);\r\n    for (Revision r : new Revision[] { fromRev, toRev }) {\r\n        if (r.isBranch()) {\r\n            Branch b = getBranches().getBranch(fromRev);\r\n            if (b != null) {\r\n                addPathsForDiff(path, paths, b.getModifications(r), r);\r\n            }\r\n        }\r\n    }\r\n    for (String p : paths) {\r\n        DocumentNodeState fromNode = getNode(p, fromRev);\r\n        DocumentNodeState toNode = getNode(p, toRev);\r\n        if (fromNode != null) {\r\n                        if (toNode != null) {\r\n                                if (!fromNode.getLastRevision().equals(toNode.getLastRevision())) {\r\n                    w.tag('^').key(p).object().endObject().newline();\r\n                }\r\n            } else {\r\n                                w.tag('-').value(p).newline();\r\n            }\r\n        } else {\r\n                        if (toNode != null) {\r\n                                w.tag('+').key(p).object().endObject().newline();\r\n            } else {\r\n                                    }\r\n        }\r\n    }\r\n}","lc":1.0909090909,"pi":0.9425837321,"ma":1.2,"nbd":1.0,"ml":0.5833333333,"d":0.0357142857,"mi":-0.7451726568,"fo":2.5833333333,"r":-0.0263157895,"e":0.6714521994}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3314_8fc7e7af","label":0,"code":"@Override\r\npublic final void cancel() throws Exception {\r\n    isRunning = false;\r\n    cancelTask();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic final void cancel() throws Exception {\r\n    isRunning = false;\r\n    cancelTask();\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.770260747,"fo":-0.4166666667,"r":2.3684210526,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5522_5b730c0b","label":1,"code":"\/**\r\n *  Should the page be rendered immediately.\r\n *\/\r\nprotected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url currentUrl, Url targetUrl) {\r\n    \/\/ WICKET-5484 never render and write for Ajax requests\r\n    if (isAjax(cycle)) {\r\n        return false;\r\n    }\r\n    return neverRedirect(getRedirectPolicy()) || ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(), isPageStateless()))) || (targetUrl.equals(currentUrl) && isRedirectToRender()) || (shouldPreserveClientUrl(cycle) && notForcedRedirect(getRedirectPolicy()));\r\n}","code_comment":"\/**\r\n *  Should the page be rendered immediately.\r\n *\/\r\n","code_no_comment":"protected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url currentUrl, Url targetUrl) {\r\n        if (isAjax(cycle)) {\r\n        return false;\r\n    }\r\n    return neverRedirect(getRedirectPolicy()) || ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(), isPageStateless()))) || (targetUrl.equals(currentUrl) && isRedirectToRender()) || (shouldPreserveClientUrl(cycle) && notForcedRedirect(getRedirectPolicy()));\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0515873016,"mi":0.4040873855,"fo":0.75,"r":1.5789473684,"e":-0.0476870501}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1789_9f7c1df0","label":1,"code":"private Map<String, PropertyState> createProperties(NodePropBundle bundle) {\r\n    Map<String, PropertyState> properties = newHashMap();\r\n    String primary;\r\n    if (bundle.getNodeTypeName() != null) {\r\n        primary = createName(bundle.getNodeTypeName());\r\n    } else {\r\n        warn(\"Missing primary node type; defaulting to nt:unstructured\");\r\n        primary = NT_UNSTRUCTURED;\r\n    }\r\n    properties.put(JCR_PRIMARYTYPE, PropertyStates.createProperty(JCR_PRIMARYTYPE, primary, Type.NAME));\r\n    Set<String> mixins = newLinkedHashSet();\r\n    if (bundle.getMixinTypeNames() != null) {\r\n        for (Name mixin : bundle.getMixinTypeNames()) {\r\n            mixins.add(createName(mixin));\r\n        }\r\n    }\r\n    if (!mixins.isEmpty()) {\r\n        properties.put(JCR_MIXINTYPES, PropertyStates.createProperty(JCR_MIXINTYPES, mixins, Type.NAMES));\r\n    }\r\n    if (bundle.isReferenceable() || isReferenceable.apply(primary, mixins)) {\r\n        properties.put(JCR_UUID, PropertyStates.createProperty(JCR_UUID, bundle.getId().toString()));\r\n    }\r\n    if (isOrderable.apply(primary, mixins)) {\r\n        properties.put(OAK_CHILD_ORDER, PropertyStates.createProperty(OAK_CHILD_ORDER, nodes.keySet(), Type.NAMES));\r\n    }\r\n    for (PropertyEntry property : bundle.getPropertyEntries()) {\r\n        String name = createName(property.getName());\r\n        try {\r\n            int type = property.getType();\r\n            if (property.isMultiValued()) {\r\n                properties.put(name, createProperty(name, type, property.getValues()));\r\n            } else {\r\n                properties.put(name, createProperty(name, type, property.getValues()[0]));\r\n            }\r\n        } catch (Exception e) {\r\n            warn(\"Skipping broken property entry \" + name, e);\r\n        }\r\n    }\r\n    \/\/ OAK-1789: Convert the jcr:frozenUuid of a non-referenceable\r\n    \/\/ frozen node from UUID to a path identifier\r\n    PropertyState frozenUuid = properties.get(JCR_FROZENUUID);\r\n    if (frozenUuid != null && frozenUuid.getType() == STRING && isFrozenNode.apply(primary, mixins)) {\r\n        String frozenPrimary = NT_UNSTRUCTURED;\r\n        Set<String> frozenMixins = newHashSet();\r\n        PropertyState property = properties.get(JCR_FROZENPRIMARYTYPE);\r\n        if (property != null && property.getType() == NAME) {\r\n            primary = property.getValue(NAME);\r\n        }\r\n        property = properties.get(JCR_FROZENMIXINTYPES);\r\n        if (property != null && property.getType() == NAMES) {\r\n            addAll(frozenMixins, property.getValue(NAMES));\r\n        }\r\n        if (!isReferenceable.apply(frozenPrimary, frozenMixins)) {\r\n            frozenUuid = PropertyStates.createProperty(JCR_FROZENUUID, parent.getString(JCR_FROZENUUID) + \"\/\" + name);\r\n            properties.put(JCR_FROZENUUID, frozenUuid);\r\n        }\r\n    }\r\n    return properties;\r\n}","code_comment":null,"code_no_comment":"private Map<String, PropertyState> createProperties(NodePropBundle bundle) {\r\n    Map<String, PropertyState> properties = newHashMap();\r\n    String primary;\r\n    if (bundle.getNodeTypeName() != null) {\r\n        primary = createName(bundle.getNodeTypeName());\r\n    } else {\r\n        warn(\"Missing primary node type; defaulting to nt:unstructured\");\r\n        primary = NT_UNSTRUCTURED;\r\n    }\r\n    properties.put(JCR_PRIMARYTYPE, PropertyStates.createProperty(JCR_PRIMARYTYPE, primary, Type.NAME));\r\n    Set<String> mixins = newLinkedHashSet();\r\n    if (bundle.getMixinTypeNames() != null) {\r\n        for (Name mixin : bundle.getMixinTypeNames()) {\r\n            mixins.add(createName(mixin));\r\n        }\r\n    }\r\n    if (!mixins.isEmpty()) {\r\n        properties.put(JCR_MIXINTYPES, PropertyStates.createProperty(JCR_MIXINTYPES, mixins, Type.NAMES));\r\n    }\r\n    if (bundle.isReferenceable() || isReferenceable.apply(primary, mixins)) {\r\n        properties.put(JCR_UUID, PropertyStates.createProperty(JCR_UUID, bundle.getId().toString()));\r\n    }\r\n    if (isOrderable.apply(primary, mixins)) {\r\n        properties.put(OAK_CHILD_ORDER, PropertyStates.createProperty(OAK_CHILD_ORDER, nodes.keySet(), Type.NAMES));\r\n    }\r\n    for (PropertyEntry property : bundle.getPropertyEntries()) {\r\n        String name = createName(property.getName());\r\n        try {\r\n            int type = property.getType();\r\n            if (property.isMultiValued()) {\r\n                properties.put(name, createProperty(name, type, property.getValues()));\r\n            } else {\r\n                properties.put(name, createProperty(name, type, property.getValues()[0]));\r\n            }\r\n        } catch (Exception e) {\r\n            warn(\"Skipping broken property entry \" + name, e);\r\n        }\r\n    }\r\n            PropertyState frozenUuid = properties.get(JCR_FROZENUUID);\r\n    if (frozenUuid != null && frozenUuid.getType() == STRING && isFrozenNode.apply(primary, mixins)) {\r\n        String frozenPrimary = NT_UNSTRUCTURED;\r\n        Set<String> frozenMixins = newHashSet();\r\n        PropertyState property = properties.get(JCR_FROZENPRIMARYTYPE);\r\n        if (property != null && property.getType() == NAME) {\r\n            primary = property.getValue(NAME);\r\n        }\r\n        property = properties.get(JCR_FROZENMIXINTYPES);\r\n        if (property != null && property.getType() == NAMES) {\r\n            addAll(frozenMixins, property.getValue(NAMES));\r\n        }\r\n        if (!isReferenceable.apply(frozenPrimary, frozenMixins)) {\r\n            frozenUuid = PropertyStates.createProperty(JCR_FROZENUUID, parent.getString(JCR_FROZENUUID) + \"\/\" + name);\r\n            properties.put(JCR_FROZENUUID, frozenUuid);\r\n        }\r\n    }\r\n    return properties;\r\n}","lc":1.9545454545,"pi":0.2679425837,"ma":2.0,"nbd":0.5,"ml":2.25,"d":1.2996031746,"mi":-1.0205778717,"fo":3.8333333333,"r":-0.0263157895,"e":5.2273854186}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-320_c06cc933","label":1,"code":"\/**\r\n * Get the pseudo-inverse of the decomposed matrix.\r\n * @return inverse matrix\r\n * @throws InvalidMatrixException if decomposed matrix is singular\r\n *\/\r\npublic RealMatrix getInverse() throws InvalidMatrixException {\r\n    if (!isNonSingular()) {\r\n        throw new SingularMatrixException();\r\n    }\r\n    return solve(MatrixUtils.createRealIdentityMatrix(singularValues.length));\r\n}","code_comment":"\/**\r\n * Get the pseudo-inverse of the decomposed matrix.\r\n * @return inverse matrix\r\n * @throws InvalidMatrixException if decomposed matrix is singular\r\n *\/\r\n","code_no_comment":"public RealMatrix getInverse() throws InvalidMatrixException {\r\n    if (!isNonSingular()) {\r\n        throw new SingularMatrixException();\r\n    }\r\n    return solve(MatrixUtils.createRealIdentityMatrix(singularValues.length));\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.5884425652,"fo":-0.25,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-334_9d8cc45d","label":1,"code":"@Override\r\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\r\n    return new ColumnAgeOffFilter(getSource(), ttls, currentTime);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\r\n    return new ColumnAgeOffFilter(getSource(), ttls, currentTime);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7866102889,"fo":-0.4166666667,"r":0.1315789474,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"@Override\r\npublic void setProperty(PropertyState property) {\r\n    root.checkLive();\r\n    NodeBuilder builder = getNodeBuilder();\r\n    builder.setProperty(property);\r\n    root.updated();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void setProperty(PropertyState property) {\r\n    root.checkLive();\r\n    NodeBuilder builder = getNodeBuilder();\r\n    builder.setProperty(property);\r\n    root.updated();\r\n}","lc":-0.3181818182,"pi":-0.4832535885,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4889358703,"fo":-0.1666666667,"r":1.2105263158,"e":-0.1627934049}
{"project_name":"Math","project_version":"59","label":1,"code":"\/**\r\n * Compute the maximum of two values\r\n * @param a first value\r\n * @param b second value\r\n * @return b if a is lesser or equal to b, a otherwise\r\n *\/\r\npublic static float max(final float a, final float b) {\r\n    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\r\n}","code_comment":"\/**\r\n * Compute the maximum of two values\r\n * @param a first value\r\n * @param b second value\r\n * @return b if a is lesser or equal to b, a otherwise\r\n *\/\r\n","code_no_comment":"public static float max(final float a, final float b) {\r\n    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.2,"nbd":-1.0,"ml":0.0,"d":0.0317460317,"mi":0.881042988,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1160261176}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3412_2f85bd78","label":1,"code":"public static boolean isValidLocalName(String local) {\r\n    if (local.isEmpty() || \".\".equals(local) || \"..\".equals(local)) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < local.length(); i++) {\r\n        char ch = local.charAt(i);\r\n        if (Character.isSpaceChar(ch)) {\r\n            if (i == 0) {\r\n                \/\/ leading whitespace\r\n                return false;\r\n            } else if (i == local.length() - 1) {\r\n                \/\/ trailing whitespace\r\n                return false;\r\n            } else if (ch != ' ') {\r\n                \/\/ only spaces are allowed as whitespace\r\n                return false;\r\n            }\r\n        } else if (\"\/:[]|*\".indexOf(ch) != -1) {\r\n            \/\/ invalid name character\r\n            return false;\r\n        }\r\n    }\r\n    \/\/ TODO: Other name rules?\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"public static boolean isValidLocalName(String local) {\r\n    if (local.isEmpty() || \".\".equals(local) || \"..\".equals(local)) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < local.length(); i++) {\r\n        char ch = local.charAt(i);\r\n        if (Character.isSpaceChar(ch)) {\r\n            if (i == 0) {\r\n                                return false;\r\n            } else if (i == local.length() - 1) {\r\n                                return false;\r\n            } else if (ch != ' ') {\r\n                                return false;\r\n            }\r\n        } else if (\"\/:[]|*\".indexOf(ch) != -1) {\r\n                        return false;\r\n        }\r\n    }\r\n        return true;\r\n}","lc":0.2727272727,"pi":0.9043062201,"ma":0.8,"nbd":1.5,"ml":1.0833333333,"d":0.8531746032,"mi":-0.2572233968,"fo":0.1666666667,"r":0.3684210526,"e":0.5724036583}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4072_7d5b8645","label":1,"code":"\/**\r\n *  return query string part of url in given encoding\r\n *\r\n *  @param charset\r\n *           character set for encoding\r\n *\r\n *  @return query string\r\n *\/\r\npublic String getQueryString(Charset charset) {\r\n    Args.notNull(charset, \"charset\");\r\n    StringBuilder query = new StringBuilder();\r\n    for (QueryParameter parameter : getQueryParameters()) {\r\n        query.append(query.length() == 0 ? '?' : '&');\r\n        query.append(parameter.toString(charset));\r\n    }\r\n    return query.toString();\r\n}","code_comment":"\/**\r\n *  return query string part of url in given encoding\r\n *\r\n *  @param charset\r\n *           character set for encoding\r\n *\r\n *  @return query string\r\n *\/\r\n","code_no_comment":"public String getQueryString(Charset charset) {\r\n    Args.notNull(charset, \"charset\");\r\n    StringBuilder query = new StringBuilder();\r\n    for (QueryParameter parameter : getQueryParameters()) {\r\n        query.append(query.length() == 0 ? '?' : '&');\r\n        query.append(parameter.toString(charset));\r\n    }\r\n    return query.toString();\r\n}","lc":-0.2272727273,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0456349206,"mi":0.2369274137,"fo":0.0833333333,"r":1.0789473684,"e":-0.0632746091}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3433_e76d23b0","label":3,"code":"\/**\r\n * Returns an expression which converts the given expression to the given type\r\n *\/\r\n@SuppressWarnings(\"unchecked\")\r\npublic static Expression convertToExpression(final Expression expression, final Class type) {\r\n    return new ExpressionAdapter() {\r\n\r\n        public Object evaluate(Exchange exchange) {\r\n            return expression.evaluate(exchange, type);\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"\" + expression + \".convertTo(\" + type.getCanonicalName() + \".class)\";\r\n        }\r\n    };\r\n}","code_comment":"\/**\r\n * Returns an expression which converts the given expression to the given type\r\n *\/\r\n","code_no_comment":"@SuppressWarnings(\"unchecked\")\r\npublic static Expression convertToExpression(final Expression expression, final Class type) {\r\n    return new ExpressionAdapter() {\r\n\r\n        public Object evaluate(Exchange exchange) {\r\n            return expression.evaluate(exchange, type);\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"\" + expression + \".convertTo(\" + type.getCanonicalName() + \".class)\";\r\n        }\r\n    };\r\n}","lc":-0.0909090909,"pi":0.5598086124,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.1309372798,"fo":-0.3333333333,"r":1.2631578947,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-395_962315ba","label":1,"code":"\/**\r\n * Increment the iterations counter by 1.\r\n *\r\n * @throws OptimizationException if the maximal number\r\n * of iterations is exceeded.\r\n * @since 2.2\r\n *\/\r\nprotected void incrementIterationsCounter() throws ConvergenceException {\r\n    if (++iterationCount > maximalIterationCount) {\r\n        throw new ConvergenceException(new MaxIterationsExceededException(maximalIterationCount));\r\n    }\r\n}","code_comment":"\/**\r\n * Increment the iterations counter by 1.\r\n *\r\n * @throws OptimizationException if the maximal number\r\n * of iterations is exceeded.\r\n * @since 2.2\r\n *\/\r\n","code_no_comment":"protected void incrementIterationsCounter() throws ConvergenceException {\r\n    if (++iterationCount > maximalIterationCount) {\r\n        throw new ConvergenceException(new MaxIterationsExceededException(maximalIterationCount));\r\n    }\r\n}","lc":-0.4090909091,"pi":0.0,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":-0.1011904762,"mi":0.7245947851,"fo":-0.5,"r":2.5526315789,"e":-0.1443520456}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3197_be70e608","label":1,"code":"\/**\r\n *  @see org.apache.wicket.Component#onComponentTag(org.apache.wicket.markup.ComponentTag)\r\n *\/\r\n@Override\r\nprotected void onComponentTag(final ComponentTag tag) {\r\n    if (tag.isOpenClose()) {\r\n        wasOpenCloseTag = true;\r\n        \/\/ Convert <span wicket:id=\"myPanel\" \/> into\r\n        \/\/ <span wicket:id=\"myPanel\">...<\/span>\r\n        tag.setType(XmlTag.OPEN);\r\n    }\r\n    super.onComponentTag(tag);\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.Component#onComponentTag(org.apache.wicket.markup.ComponentTag)\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void onComponentTag(final ComponentTag tag) {\r\n    if (tag.isOpenClose()) {\r\n        wasOpenCloseTag = true;\r\n                        tag.setType(XmlTag.OPEN);\r\n    }\r\n    super.onComponentTag(tag);\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.421564482,"fo":-0.25,"r":1.1315789474,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2900_0e70ce39","label":3,"code":"\/**\r\n *  Returns the name of the Bean as registered to Spring. Throws IllegalState exception if none\r\n *  or more than one beans are found.\r\n *\r\n *  @param ctx\r\n *             spring application context\r\n *  @param clazz\r\n *             bean class\r\n *  @throws IllegalStateException\r\n *  @return spring name of the bean\r\n *\/\r\nprivate final String getBeanNameOfClass(ApplicationContext ctx, Class<?> clazz) {\r\n    \/\/ get the list of all possible matching beans\r\n    List<String> names = new ArrayList<String>(Arrays.asList(BeanFactoryUtils.beanNamesForTypeIncludingAncestors(ctx, clazz)));\r\n    \/\/ filter out beans that are not candidates for autowiring\r\n    Iterator<String> it = names.iterator();\r\n    while (it.hasNext()) {\r\n        final String possibility = it.next();\r\n        BeanDefinition beanDef = ((AbstractApplicationContext) ctx).getBeanFactory().getBeanDefinition(possibility);\r\n        if (BeanFactoryUtils.isFactoryDereference(possibility) || possibility.startsWith(\"scopedTarget.\") || !beanDef.isAutowireCandidate()) {\r\n            it.remove();\r\n        }\r\n    }\r\n    if (names.isEmpty()) {\r\n        throw new IllegalStateException(\"bean of type [\" + clazz.getName() + \"] not found\");\r\n    } else if (names.size() > 1) {\r\n        if (ctx instanceof AbstractApplicationContext) {\r\n            for (String name : names) {\r\n                BeanDefinition beanDef = ((AbstractApplicationContext) ctx).getBeanFactory().getBeanDefinition(name);\r\n                if (beanDef instanceof AbstractBeanDefinition) {\r\n                    if (((AbstractBeanDefinition) beanDef).isPrimary()) {\r\n                        return name;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        StringBuilder msg = new StringBuilder();\r\n        msg.append(\"More than one bean of type [\");\r\n        msg.append(clazz.getName());\r\n        msg.append(\"] found, you have to specify the name of the bean \");\r\n        msg.append(\"(@SpringBean(name=\\\"foo\\\")) in order to resolve this conflict. \");\r\n        msg.append(\"Matched beans: \");\r\n        msg.append(Strings.join(\",\", names.toArray(new String[0])));\r\n        throw new IllegalStateException(msg.toString());\r\n    } else {\r\n        return names.get(0);\r\n    }\r\n}","code_comment":"\/**\r\n *  Returns the name of the Bean as registered to Spring. Throws IllegalState exception if none\r\n *  or more than one beans are found.\r\n *\r\n *  @param ctx\r\n *             spring application context\r\n *  @param clazz\r\n *             bean class\r\n *  @throws IllegalStateException\r\n *  @return spring name of the bean\r\n *\/\r\n","code_no_comment":"private final String getBeanNameOfClass(ApplicationContext ctx, Class<?> clazz) {\r\n        List<String> names = new ArrayList<String>(Arrays.asList(BeanFactoryUtils.beanNamesForTypeIncludingAncestors(ctx, clazz)));\r\n        Iterator<String> it = names.iterator();\r\n    while (it.hasNext()) {\r\n        final String possibility = it.next();\r\n        BeanDefinition beanDef = ((AbstractApplicationContext) ctx).getBeanFactory().getBeanDefinition(possibility);\r\n        if (BeanFactoryUtils.isFactoryDereference(possibility) || possibility.startsWith(\"scopedTarget.\") || !beanDef.isAutowireCandidate()) {\r\n            it.remove();\r\n        }\r\n    }\r\n    if (names.isEmpty()) {\r\n        throw new IllegalStateException(\"bean of type [\" + clazz.getName() + \"] not found\");\r\n    } else if (names.size() > 1) {\r\n        if (ctx instanceof AbstractApplicationContext) {\r\n            for (String name : names) {\r\n                BeanDefinition beanDef = ((AbstractApplicationContext) ctx).getBeanFactory().getBeanDefinition(name);\r\n                if (beanDef instanceof AbstractBeanDefinition) {\r\n                    if (((AbstractBeanDefinition) beanDef).isPrimary()) {\r\n                        return name;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        StringBuilder msg = new StringBuilder();\r\n        msg.append(\"More than one bean of type [\");\r\n        msg.append(clazz.getName());\r\n        msg.append(\"] found, you have to specify the name of the bean \");\r\n        msg.append(\"(@SpringBean(name=\\\"foo\\\")) in order to resolve this conflict. \");\r\n        msg.append(\"Matched beans: \");\r\n        msg.append(Strings.join(\",\", names.toArray(new String[0])));\r\n        throw new IllegalStateException(msg.toString());\r\n    } else {\r\n        return names.get(0);\r\n    }\r\n}","lc":0.9545454545,"pi":1.1483253589,"ma":1.4,"nbd":2.0,"ml":1.1666666667,"d":0.4285714286,"mi":-0.6763918252,"fo":1.8333333333,"r":-0.0263157895,"e":1.1173181653}
{"project_name":"Closure","project_version":"35","label":2,"code":"\/**\r\n * Suppose X is an object with inferred properties.\r\n * Suppose also that X is used in a way where it would only type-check\r\n * correctly if some of those properties are widened.\r\n * Then we should be polite and automatically widen X's properties for him.\r\n *\r\n * For a concrete example, consider:\r\n * param x {{prop: (number|undefined)}}\r\n * function f(x) {}\r\n * f({});\r\n *\r\n * If we give the anonymous object an inferred property of (number|undefined),\r\n * then this code will type-check appropriately.\r\n *\/\r\nprivate void inferPropertyTypesToMatchConstraint(JSType type, JSType constraint) {\r\n    if (type == null || constraint == null) {\r\n        return;\r\n    }\r\n    ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined());\r\n    if (constraintObj != null && constraintObj.isRecordType()) {\r\n        ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\r\n        if (objType != null) {\r\n            for (String prop : constraintObj.getOwnPropertyNames()) {\r\n                JSType propType = constraintObj.getPropertyType(prop);\r\n                if (!objType.isPropertyTypeDeclared(prop)) {\r\n                    JSType typeToInfer = propType;\r\n                    if (!objType.hasProperty(prop)) {\r\n                        typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);\r\n                    }\r\n                    objType.defineInferredProperty(prop, typeToInfer, null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Suppose X is an object with inferred properties.\r\n * Suppose also that X is used in a way where it would only type-check\r\n * correctly if some of those properties are widened.\r\n * Then we should be polite and automatically widen X's properties for him.\r\n *\r\n * For a concrete example, consider:\r\n * param x {{prop: (number|undefined)}}\r\n * function f(x) {}\r\n * f({});\r\n *\r\n * If we give the anonymous object an inferred property of (number|undefined),\r\n * then this code will type-check appropriately.\r\n *\/\r\n","code_no_comment":"private void inferPropertyTypesToMatchConstraint(JSType type, JSType constraint) {\r\n    if (type == null || constraint == null) {\r\n        return;\r\n    }\r\n    ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined());\r\n    if (constraintObj != null && constraintObj.isRecordType()) {\r\n        ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\r\n        if (objType != null) {\r\n            for (String prop : constraintObj.getOwnPropertyNames()) {\r\n                JSType propType = constraintObj.getPropertyType(prop);\r\n                if (!objType.isPropertyTypeDeclared(prop)) {\r\n                    JSType typeToInfer = propType;\r\n                    if (!objType.hasProperty(prop)) {\r\n                        typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);\r\n                    }\r\n                    objType.defineInferredProperty(prop, typeToInfer, null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","lc":0.3181818182,"pi":2.019138756,"ma":0.6,"nbd":1.5,"ml":0.8333333333,"d":1.0238095238,"mi":-0.3119097956,"fo":0.5,"r":0.0263157895,"e":0.9298709681}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8125_36e7b668","label":3,"code":"public String resolvePropertyPlaceholders(String text) throws Exception {\r\n    \/\/ While it is more efficient to only do the lookup if we are sure we need the component,\r\n    \/\/ with custom tokens, we cannot know if the URI contains a property or not without having\r\n    \/\/ the component.  We also lose fail-fast behavior for the missing component with this change.\r\n    PropertiesComponent pc = getPropertiesComponent();\r\n    \/\/ Do not parse uris that are designated for the properties component as it will handle that itself\r\n    if (text != null && !text.startsWith(\"properties:\")) {\r\n        \/\/ No component, assume default tokens.\r\n        if (pc == null && text.contains(PropertiesComponent.DEFAULT_PREFIX_TOKEN)) {\r\n            \/\/ try to lookup component, as we may be initializing CamelContext itself\r\n            Component existing = lookupPropertiesComponent();\r\n            if (existing != null) {\r\n                if (existing instanceof PropertiesComponent) {\r\n                    pc = (PropertiesComponent) existing;\r\n                } else {\r\n                    \/\/ properties component must be expected type\r\n                    throw new IllegalArgumentException(\"Found properties component of type: \" + existing.getClass() + \" instead of expected: \" + PropertiesComponent.class);\r\n                }\r\n            }\r\n            if (pc == null) {\r\n                \/\/ create a default properties component to be used as there may be default values we can use\r\n                log.info(\"No existing PropertiesComponent has been configured, creating a new default PropertiesComponent with name: properties\");\r\n                pc = getComponent(\"properties\", PropertiesComponent.class);\r\n            }\r\n        }\r\n        if (pc != null && text.contains(pc.getPrefixToken())) {\r\n            \/\/ the parser will throw exception if property key was not found\r\n            String answer = pc.parseUri(text);\r\n            log.debug(\"Resolved text: {} -> {}\", text, answer);\r\n            return answer;\r\n        }\r\n    }\r\n    \/\/ return original text as is\r\n    return text;\r\n}","code_comment":null,"code_no_comment":"public String resolvePropertyPlaceholders(String text) throws Exception {\r\n                PropertiesComponent pc = getPropertiesComponent();\r\n        if (text != null && !text.startsWith(\"properties:\")) {\r\n                if (pc == null && text.contains(PropertiesComponent.DEFAULT_PREFIX_TOKEN)) {\r\n                        Component existing = lookupPropertiesComponent();\r\n            if (existing != null) {\r\n                if (existing instanceof PropertiesComponent) {\r\n                    pc = (PropertiesComponent) existing;\r\n                } else {\r\n                                        throw new IllegalArgumentException(\"Found properties component of type: \" + existing.getClass() + \" instead of expected: \" + PropertiesComponent.class);\r\n                }\r\n            }\r\n            if (pc == null) {\r\n                                log.info(\"No existing PropertiesComponent has been configured, creating a new default PropertiesComponent with name: properties\");\r\n                pc = getComponent(\"properties\", PropertiesComponent.class);\r\n            }\r\n        }\r\n        if (pc != null && text.contains(pc.getPrefixToken())) {\r\n                        String answer = pc.parseUri(text);\r\n            log.debug(\"Resolved text: {} -> {}\", text, answer);\r\n            return answer;\r\n        }\r\n    }\r\n        return text;\r\n}","lc":0.5,"pi":1.2153110048,"ma":0.8,"nbd":1.0,"ml":0.9166666667,"d":0.8849206349,"mi":-0.4235377026,"fo":0.4166666667,"r":-0.0263157895,"e":1.0084634314}
{"project_name":"JxPath","project_version":"9","label":1,"code":"public Object computeValue(EvalContext context) {\r\n    return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE;\r\n}","code_comment":null,"code_no_comment":"public Object computeValue(EvalContext context) {\r\n    return equal(context, args[0], args[1]) ? Boolean.TRUE : Boolean.FALSE;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.8787878788,"fo":-0.4166666667,"r":0.0,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"\/**\r\n *  Removes the given component\r\n *\r\n *  @param id\r\n *             The id of the component to remove\r\n *\/\r\npublic final void remove(final String id) {\r\n    if (id == null) {\r\n        throw new IllegalArgumentException(\"argument id may not be null\");\r\n    }\r\n    final Component component = get(id);\r\n    if (component != null) {\r\n        remove(component);\r\n    } else {\r\n        throw new WicketRuntimeException(\"Unable to find a component with id '\" + id + \"' to remove\");\r\n    }\r\n}","code_comment":"\/**\r\n *  Removes the given component\r\n *\r\n *  @param id\r\n *             The id of the component to remove\r\n *\/\r\n","code_no_comment":"public final void remove(final String id) {\r\n    if (id == null) {\r\n        throw new IllegalArgumentException(\"argument id may not be null\");\r\n    }\r\n    final Component component = get(id);\r\n    if (component != null) {\r\n        remove(component);\r\n    } else {\r\n        throw new WicketRuntimeException(\"Unable to find a component with id '\" + id + \"' to remove\");\r\n    }\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":0.2,"nbd":-0.5,"ml":-0.0833333333,"d":0.246031746,"mi":0.178012685,"fo":-0.3333333333,"r":2.0789473684,"e":-0.0236349072}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1516_7c62bd81","label":1,"code":"static Query tokenToQuery(String text, String fieldName, Analyzer analyzer, IndexReader reader) {\r\n    if (analyzer == null) {\r\n        return null;\r\n    }\r\n    List<String> tokens = tokenize(text, analyzer);\r\n    if (tokens.isEmpty()) {\r\n        \/\/ TODO what should be returned in the case there are no tokens?\r\n        return new BooleanQuery();\r\n    }\r\n    if (tokens.size() == 1) {\r\n        String token = tokens.iterator().next();\r\n        if (hasFulltextToken(token)) {\r\n            return new WildcardQuery(newFulltextTerm(token, fieldName));\r\n        } else {\r\n            return new TermQuery(newFulltextTerm(token, fieldName));\r\n        }\r\n    } else {\r\n        if (hasFulltextToken(tokens)) {\r\n            MultiPhraseQuery mpq = new MultiPhraseQuery();\r\n            for (String token : tokens) {\r\n                if (hasFulltextToken(token)) {\r\n                    Term[] terms = extractMatchingTokens(reader, token);\r\n                    if (terms != null && terms.length > 0) {\r\n                        mpq.add(terms);\r\n                    }\r\n                } else {\r\n                    mpq.add(newFulltextTerm(token, fieldName));\r\n                }\r\n            }\r\n            return mpq;\r\n        } else {\r\n            PhraseQuery pq = new PhraseQuery();\r\n            for (String t : tokens) {\r\n                pq.add(newFulltextTerm(t, fieldName));\r\n            }\r\n            return pq;\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"static Query tokenToQuery(String text, String fieldName, Analyzer analyzer, IndexReader reader) {\r\n    if (analyzer == null) {\r\n        return null;\r\n    }\r\n    List<String> tokens = tokenize(text, analyzer);\r\n    if (tokens.isEmpty()) {\r\n                return new BooleanQuery();\r\n    }\r\n    if (tokens.size() == 1) {\r\n        String token = tokens.iterator().next();\r\n        if (hasFulltextToken(token)) {\r\n            return new WildcardQuery(newFulltextTerm(token, fieldName));\r\n        } else {\r\n            return new TermQuery(newFulltextTerm(token, fieldName));\r\n        }\r\n    } else {\r\n        if (hasFulltextToken(tokens)) {\r\n            MultiPhraseQuery mpq = new MultiPhraseQuery();\r\n            for (String token : tokens) {\r\n                if (hasFulltextToken(token)) {\r\n                    Term[] terms = extractMatchingTokens(reader, token);\r\n                    if (terms != null && terms.length > 0) {\r\n                        mpq.add(terms);\r\n                    }\r\n                } else {\r\n                    mpq.add(newFulltextTerm(token, fieldName));\r\n                }\r\n            }\r\n            return mpq;\r\n        } else {\r\n            PhraseQuery pq = new PhraseQuery();\r\n            for (String t : tokens) {\r\n                pq.add(newFulltextTerm(t, fieldName));\r\n            }\r\n            return pq;\r\n        }\r\n    }\r\n}","lc":1.0909090909,"pi":1.3684210526,"ma":1.2,"nbd":1.5,"ml":1.0,"d":0.5396825397,"mi":-0.6572233968,"fo":0.8333333333,"r":-0.0263157895,"e":0.872416913}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1203_b148046a","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\r\n * <p>Algorithm description:<ol>\r\n * <li>Find the bin B that x belongs to.<\/li>\r\n * <li>Compute P(B) = the mass of B and P(B-) = the combined mass of the bins below B.<\/li>\r\n * <li>Compute K(B) = the probability mass of B with respect to the within-bin kernel\r\n * and K(B-) = the kernel distribution evaluated at the lower endpoint of B<\/li>\r\n * <li>Return P(B-) + P(B) * [K(x) - K(B-)] \/ K(B) where\r\n * K(x) is the within-bin kernel distribution function evaluated at x.<\/li><\/ol><\/p>\r\n *\r\n * @since 3.1\r\n *\/\r\npublic double cumulativeProbability(double x) {\r\n    if (x < min) {\r\n        return 0d;\r\n    } else if (x >= max) {\r\n        return 1d;\r\n    }\r\n    final int binIndex = findBin(x);\r\n    final double pBminus = pBminus(binIndex);\r\n    final double pB = pB(binIndex);\r\n    final double[] binBounds = getUpperBounds();\r\n    final double kB = kB(binIndex);\r\n    final double lower = binIndex == 0 ? min : binBounds[binIndex - 1];\r\n    final RealDistribution kernel = k(x);\r\n    final double withinBinCum = (kernel.cumulativeProbability(x) - kernel.cumulativeProbability(lower)) \/ kB;\r\n    return pBminus + pB * withinBinCum;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\r\n * <p>Algorithm description:<ol>\r\n * <li>Find the bin B that x belongs to.<\/li>\r\n * <li>Compute P(B) = the mass of B and P(B-) = the combined mass of the bins below B.<\/li>\r\n * <li>Compute K(B) = the probability mass of B with respect to the within-bin kernel\r\n * and K(B-) = the kernel distribution evaluated at the lower endpoint of B<\/li>\r\n * <li>Return P(B-) + P(B) * [K(x) - K(B-)] \/ K(B) where\r\n * K(x) is the within-bin kernel distribution function evaluated at x.<\/li><\/ol><\/p>\r\n *\r\n * @since 3.1\r\n *\/\r\n","code_no_comment":"public double cumulativeProbability(double x) {\r\n    if (x < min) {\r\n        return 0d;\r\n    } else if (x >= max) {\r\n        return 1d;\r\n    }\r\n    final int binIndex = findBin(x);\r\n    final double pBminus = pBminus(binIndex);\r\n    final double pB = pB(binIndex);\r\n    final double[] binBounds = getUpperBounds();\r\n    final double kB = kB(binIndex);\r\n    final double lower = binIndex == 0 ? min : binBounds[binIndex - 1];\r\n    final RealDistribution kernel = k(x);\r\n    final double withinBinCum = (kernel.cumulativeProbability(x) - kernel.cumulativeProbability(lower)) \/ kB;\r\n    return pBminus + pB * withinBinCum;\r\n}","lc":0.0909090909,"pi":-0.4736842105,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":1.3353174603,"mi":-0.148696265,"fo":0.1666666667,"r":0.1052631579,"e":1.0082467454}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1817_78c37386","label":1,"code":"public synchronized void flush() {\r\n    if (length > 0) {\r\n        int refcount = segment.getRefCount();\r\n        int rootcount = roots.size();\r\n        buffer[Segment.ROOT_COUNT_OFFSET] = (byte) (rootcount >> 8);\r\n        buffer[Segment.ROOT_COUNT_OFFSET + 1] = (byte) rootcount;\r\n        int blobrefcount = blobrefs.size();\r\n        buffer[Segment.BLOBREF_COUNT_OFFSET] = (byte) (blobrefcount >> 8);\r\n        buffer[Segment.BLOBREF_COUNT_OFFSET + 1] = (byte) blobrefcount;\r\n        length = align(refcount * 16 + rootcount * 3 + blobrefcount * 2 + length, 16);\r\n        int pos = refcount * 16;\r\n        if (pos + length <= buffer.length) {\r\n            \/\/ the whole segment fits to the space *after* the referenced\r\n            \/\/ segment identifiers we've already written, so we can safely\r\n            \/\/ copy those bits ahead even if concurrent code is still\r\n            \/\/ reading from that part of the buffer\r\n            System.arraycopy(buffer, 0, buffer, buffer.length - length, pos);\r\n            pos += buffer.length - length;\r\n        } else {\r\n            \/\/ this might leave some empty space between the header and\r\n            \/\/ the record data, but this case only occurs when the\r\n            \/\/ segment is >252kB in size and the maximum overhead is <<4kB,\r\n            \/\/ which is acceptable\r\n            length = buffer.length;\r\n        }\r\n        for (Map.Entry<RecordId, RecordType> entry : roots.entrySet()) {\r\n            int offset = entry.getKey().getOffset();\r\n            buffer[pos++] = (byte) entry.getValue().ordinal();\r\n            buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\r\n            buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\r\n        }\r\n        for (RecordId blobref : blobrefs) {\r\n            int offset = blobref.getOffset();\r\n            buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\r\n            buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\r\n        }\r\n        SegmentId id = segment.getSegmentId();\r\n        log.debug(\"Writing data segment {} ({} bytes)\", id, length);\r\n        store.writeSegment(id, buffer, buffer.length - length, length);\r\n        \/\/ Keep this segment in memory as it's likely to be accessed soon\r\n        ByteBuffer data;\r\n        if (buffer.length - length > 4096) {\r\n            data = ByteBuffer.allocate(length);\r\n            data.put(buffer, buffer.length - length, length);\r\n            data.rewind();\r\n        } else {\r\n            data = ByteBuffer.wrap(buffer);\r\n        }\r\n        tracker.setSegment(id, new Segment(tracker, id, data));\r\n        buffer = createNewBuffer();\r\n        roots.clear();\r\n        blobrefs.clear();\r\n        length = 0;\r\n        position = buffer.length;\r\n        segment = new Segment(tracker, buffer);\r\n        segment.getSegmentId().setSegment(segment);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public synchronized void flush() {\r\n    if (length > 0) {\r\n        int refcount = segment.getRefCount();\r\n        int rootcount = roots.size();\r\n        buffer[Segment.ROOT_COUNT_OFFSET] = (byte) (rootcount >> 8);\r\n        buffer[Segment.ROOT_COUNT_OFFSET + 1] = (byte) rootcount;\r\n        int blobrefcount = blobrefs.size();\r\n        buffer[Segment.BLOBREF_COUNT_OFFSET] = (byte) (blobrefcount >> 8);\r\n        buffer[Segment.BLOBREF_COUNT_OFFSET + 1] = (byte) blobrefcount;\r\n        length = align(refcount * 16 + rootcount * 3 + blobrefcount * 2 + length, 16);\r\n        int pos = refcount * 16;\r\n        if (pos + length <= buffer.length) {\r\n                                                            System.arraycopy(buffer, 0, buffer, buffer.length - length, pos);\r\n            pos += buffer.length - length;\r\n        } else {\r\n                                                            length = buffer.length;\r\n        }\r\n        for (Map.Entry<RecordId, RecordType> entry : roots.entrySet()) {\r\n            int offset = entry.getKey().getOffset();\r\n            buffer[pos++] = (byte) entry.getValue().ordinal();\r\n            buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\r\n            buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\r\n        }\r\n        for (RecordId blobref : blobrefs) {\r\n            int offset = blobref.getOffset();\r\n            buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));\r\n            buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);\r\n        }\r\n        SegmentId id = segment.getSegmentId();\r\n        log.debug(\"Writing data segment {} ({} bytes)\", id, length);\r\n        store.writeSegment(id, buffer, buffer.length - length, length);\r\n                ByteBuffer data;\r\n        if (buffer.length - length > 4096) {\r\n            data = ByteBuffer.allocate(length);\r\n            data.put(buffer, buffer.length - length, length);\r\n            data.rewind();\r\n        } else {\r\n            data = ByteBuffer.wrap(buffer);\r\n        }\r\n        tracker.setSegment(id, new Segment(tracker, id, data));\r\n        buffer = createNewBuffer();\r\n        roots.clear();\r\n        blobrefs.clear();\r\n        length = 0;\r\n        position = buffer.length;\r\n        segment = new Segment(tracker, buffer);\r\n        segment.getSegmentId().setSegment(segment);\r\n    }\r\n}","lc":1.5909090909,"pi":-0.1291866029,"ma":0.4,"nbd":0.0,"ml":0.0833333333,"d":2.0436507937,"mi":-0.9010570825,"fo":1.5,"r":-0.0263157895,"e":7.712639823}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3055_94c2a31f","label":0,"code":"private int stopProcessWithTimeout(final Process proc, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\r\n    FutureTask<Integer> future = new FutureTask<Integer>(new Callable<Integer>() {\r\n\r\n        @Override\r\n        public Integer call() throws InterruptedException {\r\n            proc.destroy();\r\n            return proc.waitFor();\r\n        }\r\n    });\r\n    executor.execute(future);\r\n    return future.get(timeout, unit);\r\n}","code_comment":null,"code_no_comment":"private int stopProcessWithTimeout(final Process proc, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\r\n    FutureTask<Integer> future = new FutureTask<Integer>(new Callable<Integer>() {\r\n\r\n        @Override\r\n        public Integer call() throws InterruptedException {\r\n            proc.destroy();\r\n            return proc.waitFor();\r\n        }\r\n    });\r\n    executor.execute(future);\r\n    return future.get(timeout, unit);\r\n}","lc":-0.1363636364,"pi":0.4593301435,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.1444679352,"fo":-0.1666666667,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-366_db4a291f","label":1,"code":"long getFlushID() {\r\n    try {\r\n        String zTablePath = Constants.ZROOT + \"\/\" + HdfsZooInstance.getInstance().getInstanceID() + Constants.ZTABLES + \"\/\" + extent.getTableId() + Constants.ZTABLE_FLUSH_ID;\r\n        return Long.parseLong(new String(ZooReaderWriter.getRetryingInstance().getData(zTablePath, null)));\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"long getFlushID() {\r\n    try {\r\n        String zTablePath = Constants.ZROOT + \"\/\" + HdfsZooInstance.getInstance().getInstanceID() + Constants.ZTABLES + \"\/\" + extent.getTableId() + Constants.ZTABLE_FLUSH_ID;\r\n        return Long.parseLong(new String(ZooReaderWriter.getRetryingInstance().getData(zTablePath, null)));\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.1150793651,"mi":0.2800563777,"fo":0.0,"r":0.1578947368,"e":-0.0791111265}
{"project_name":"Codec","project_version":"8","label":1,"code":"void setInitialBuffer(byte[] out, int outPos, int outAvail) {\r\n    if (out != null && out.length == outAvail) {\r\n        buffer = out;\r\n        pos = outPos;\r\n        readPos = outPos;\r\n    }\r\n}","code_comment":null,"code_no_comment":"void setInitialBuffer(byte[] out, int outPos, int outAvail) {\r\n    if (out != null && out.length == outAvail) {\r\n        buffer = out;\r\n        pos = outPos;\r\n        readPos = outPos;\r\n    }\r\n}","lc":-0.3181818182,"pi":0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":0.0,"d":0.2698412698,"mi":0.4269203665,"fo":-0.5,"r":1.2631578947,"e":-0.0392178558}
{"project_name":"Math","project_version":"92","label":1,"code":"\/**\r\n * Returns an exact representation of the <a\r\n * href=\"http:\/\/mathworld.wolfram.com\/BinomialCoefficient.html\"> Binomial\r\n * Coefficient<\/a>, \"<code>n choose k<\/code>\", the number of\r\n * <code>k<\/code>-element subsets that can be selected from an\r\n * <code>n<\/code>-element set.\r\n * <p>\r\n * <Strong>Preconditions<\/strong>:\r\n * <ul>\r\n * <li> <code>0 <= k <= n <\/code> (otherwise\r\n * <code>IllegalArgumentException<\/code> is thrown)<\/li>\r\n * <li> The result is small enough to fit into a <code>long<\/code>. The\r\n * largest value of <code>n<\/code> for which all coefficients are\r\n * <code> < Long.MAX_VALUE<\/code> is 66. If the computed value exceeds\r\n * <code>Long.MAX_VALUE<\/code> an <code>ArithMeticException<\/code> is\r\n * thrown.<\/li>\r\n * <\/ul><\/p>\r\n *\r\n * @param n the size of the set\r\n * @param k the size of the subsets to be counted\r\n * @return <code>n choose k<\/code>\r\n * @throws IllegalArgumentException if preconditions are not met.\r\n * @throws ArithmeticException if the result is too large to be represented\r\n *         by a long integer.\r\n *\/\r\npublic static long binomialCoefficient(final int n, final int k) {\r\n    if (n < k) {\r\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\r\n    }\r\n    if (n < 0) {\r\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\r\n    }\r\n    if ((n == k) || (k == 0)) {\r\n        return 1;\r\n    }\r\n    if ((k == 1) || (k == n - 1)) {\r\n        return n;\r\n    }\r\n    long result = Math.round(binomialCoefficientDouble(n, k));\r\n    if (result == Long.MAX_VALUE) {\r\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\r\n    }\r\n    \/\/ unnecessary.\r\n    return result;\r\n}","code_comment":"\/**\r\n * Returns an exact representation of the <a\r\n * href=\"http:\/\/mathworld.wolfram.com\/BinomialCoefficient.html\"> Binomial\r\n * Coefficient<\/a>, \"<code>n choose k<\/code>\", the number of\r\n * <code>k<\/code>-element subsets that can be selected from an\r\n * <code>n<\/code>-element set.\r\n * <p>\r\n * <Strong>Preconditions<\/strong>:\r\n * <ul>\r\n * <li> <code>0 <= k <= n <\/code> (otherwise\r\n * <code>IllegalArgumentException<\/code> is thrown)<\/li>\r\n * <li> The result is small enough to fit into a <code>long<\/code>. The\r\n * largest value of <code>n<\/code> for which all coefficients are\r\n * <code> < Long.MAX_VALUE<\/code> is 66. If the computed value exceeds\r\n * <code>Long.MAX_VALUE<\/code> an <code>ArithMeticException<\/code> is\r\n * thrown.<\/li>\r\n * <\/ul><\/p>\r\n *\r\n * @param n the size of the set\r\n * @param k the size of the subsets to be counted\r\n * @return <code>n choose k<\/code>\r\n * @throws IllegalArgumentException if preconditions are not met.\r\n * @throws ArithmeticException if the result is too large to be represented\r\n *         by a long integer.\r\n *\/\r\n","code_no_comment":"public static long binomialCoefficient(final int n, final int k) {\r\n    if (n < k) {\r\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\r\n    }\r\n    if (n < 0) {\r\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\r\n    }\r\n    if ((n == k) || (k == 0)) {\r\n        return 1;\r\n    }\r\n    if ((k == 1) || (k == n - 1)) {\r\n        return n;\r\n    }\r\n    long result = Math.round(binomialCoefficientDouble(n, k));\r\n    if (result == Long.MAX_VALUE) {\r\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\r\n    }\r\n        return result;\r\n}","lc":0.2272727273,"pi":-0.3110047847,"ma":1.0,"nbd":-0.5,"ml":0.4166666667,"d":0.4523809524,"mi":-0.2056377731,"fo":-0.3333333333,"r":-0.0263157895,"e":0.2266281703}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1985_f620b79b","label":1,"code":"@CheckForNull\r\nprivate NodeUtil getTokenParent(String userId) {\r\n    NodeUtil tokenParent = null;\r\n    String parentPath = null;\r\n    try {\r\n        Authorizable user = userManager.getAuthorizable(userId);\r\n        if (user != null && !user.isGroup()) {\r\n            String userPath = user.getPath();\r\n            NodeUtil userNode = new NodeUtil(root.getTree(userPath));\r\n            tokenParent = userNode.getChild(TOKENS_NODE_NAME);\r\n            if (tokenParent == null) {\r\n                tokenParent = userNode.addChild(TOKENS_NODE_NAME, TOKENS_NT_NAME);\r\n                parentPath = userPath + '\/' + TOKENS_NODE_NAME;\r\n                root.commit();\r\n            }\r\n        } else {\r\n            log.debug(\"Cannot create login token: No corresponding node for User \" + userId + '.');\r\n        }\r\n    } catch (RepositoryException e) {\r\n        \/\/ error while accessing user.\r\n        log.debug(\"Error while accessing user \" + userId + '.', e);\r\n    } catch (CommitFailedException e) {\r\n        \/\/ conflict while creating token store for this user -> refresh and\r\n        \/\/ try to get the tree from the updated root.\r\n        log.debug(\"Conflict while creating token store -> retrying\", e.getMessage());\r\n        root.refresh();\r\n        if (parentPath != null) {\r\n            Tree parentTree = root.getTree(parentPath);\r\n            if (parentTree.exists()) {\r\n                tokenParent = new NodeUtil(parentTree);\r\n            }\r\n        }\r\n    }\r\n    return tokenParent;\r\n}","code_comment":null,"code_no_comment":"@CheckForNull\r\nprivate NodeUtil getTokenParent(String userId) {\r\n    NodeUtil tokenParent = null;\r\n    String parentPath = null;\r\n    try {\r\n        Authorizable user = userManager.getAuthorizable(userId);\r\n        if (user != null && !user.isGroup()) {\r\n            String userPath = user.getPath();\r\n            NodeUtil userNode = new NodeUtil(root.getTree(userPath));\r\n            tokenParent = userNode.getChild(TOKENS_NODE_NAME);\r\n            if (tokenParent == null) {\r\n                tokenParent = userNode.addChild(TOKENS_NODE_NAME, TOKENS_NT_NAME);\r\n                parentPath = userPath + '\/' + TOKENS_NODE_NAME;\r\n                root.commit();\r\n            }\r\n        } else {\r\n            log.debug(\"Cannot create login token: No corresponding node for User \" + userId + '.');\r\n        }\r\n    } catch (RepositoryException e) {\r\n                log.debug(\"Error while accessing user \" + userId + '.', e);\r\n    } catch (CommitFailedException e) {\r\n                        log.debug(\"Conflict while creating token store -> retrying\", e.getMessage());\r\n        root.refresh();\r\n        if (parentPath != null) {\r\n            Tree parentTree = root.getTree(parentPath);\r\n            if (parentTree.exists()) {\r\n                tokenParent = new NodeUtil(parentTree);\r\n            }\r\n        }\r\n    }\r\n    return tokenParent;\r\n}","lc":0.8181818182,"pi":0.7990430622,"ma":0.6,"nbd":0.5,"ml":0.4166666667,"d":0.9007936508,"mi":-0.5766032417,"fo":0.6666666667,"r":-0.0263157895,"e":1.4699123459}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-520_ec961a38","label":1,"code":"@Override\r\npublic void remove(NodeBuilder index, String key, Iterable<String> values) {\r\n    if (!index.hasChildNode(key)) {\r\n        return;\r\n    }\r\n    NodeBuilder child = index.child(key);\r\n    Queue<NodeBuilder> parentQueue = new LinkedList<NodeBuilder>();\r\n    for (String rm : values) {\r\n        if (PathUtils.denotesRoot(rm)) {\r\n            child.removeProperty(\"match\");\r\n        } else {\r\n            NodeBuilder indexEntry = child;\r\n            Iterator<String> segments = PathUtils.elements(rm).iterator();\r\n            while (segments.hasNext()) {\r\n                String segment = segments.next();\r\n                if (segments.hasNext()) {\r\n                    parentQueue.add(indexEntry);\r\n                    indexEntry = indexEntry.child(segment);\r\n                } else {\r\n                    \/\/ last segment\r\n                    if (indexEntry.hasChildNode(segment)) {\r\n                        indexEntry.removeNode(segment);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \/\/ finally remove the index node if empty\r\n    if (child.getChildNodeCount() == 0) {\r\n        index.removeNode(key);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void remove(NodeBuilder index, String key, Iterable<String> values) {\r\n    if (!index.hasChildNode(key)) {\r\n        return;\r\n    }\r\n    NodeBuilder child = index.child(key);\r\n    Queue<NodeBuilder> parentQueue = new LinkedList<NodeBuilder>();\r\n    for (String rm : values) {\r\n        if (PathUtils.denotesRoot(rm)) {\r\n            child.removeProperty(\"match\");\r\n        } else {\r\n            NodeBuilder indexEntry = child;\r\n            Iterator<String> segments = PathUtils.elements(rm).iterator();\r\n            while (segments.hasNext()) {\r\n                String segment = segments.next();\r\n                if (segments.hasNext()) {\r\n                    parentQueue.add(indexEntry);\r\n                    indexEntry = indexEntry.child(segment);\r\n                } else {\r\n                                        if (indexEntry.hasChildNode(segment)) {\r\n                        indexEntry.removeNode(segment);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n        if (child.getChildNodeCount() == 0) {\r\n        index.removeNode(key);\r\n    }\r\n}","lc":0.7272727273,"pi":1.7990430622,"ma":0.8,"nbd":1.5,"ml":0.75,"d":0.0773809524,"mi":-0.5027484144,"fo":0.75,"r":-0.0263157895,"e":0.2391959567}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-412_5594b2e0","label":1,"code":"public AssignmentStats importFiles(List<String> files, Path failureDir) throws IOException, AccumuloException, AccumuloSecurityException, ThriftTableOperationException {\r\n    int numThreads = acuConf.getCount(Property.TSERV_BULK_PROCESS_THREADS);\r\n    int numAssignThreads = acuConf.getCount(Property.TSERV_BULK_ASSIGNMENT_THREADS);\r\n    timer = new StopWatch<Timers>(Timers.class);\r\n    timer.start(Timers.TOTAL);\r\n    Configuration conf = CachedConfiguration.getInstance();\r\n    final FileSystem fs = FileSystem.get(conf);\r\n    Set<Path> paths = new HashSet<Path>();\r\n    for (String file : files) {\r\n        paths.add(new Path(file));\r\n    }\r\n    AssignmentStats assignmentStats = new AssignmentStats(paths.size());\r\n    final Map<Path, List<KeyExtent>> completeFailures = Collections.synchronizedSortedMap(new TreeMap<Path, List<KeyExtent>>());\r\n    if (!fs.exists(failureDir)) {\r\n        log.error(failureDir + \" does not exist\");\r\n        throw new RuntimeException(\"Directory does not exist \" + failureDir);\r\n    }\r\n    ClientService.Iface client = null;\r\n    final TabletLocator locator = TabletLocator.getInstance(instance, credentials, new Text(tableId));\r\n    try {\r\n        final Map<Path, List<TabletLocation>> assignments = Collections.synchronizedSortedMap(new TreeMap<Path, List<TabletLocation>>());\r\n        timer.start(Timers.EXAMINE_MAP_FILES);\r\n        ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);\r\n        for (Path path : paths) {\r\n            final Path mapFile = path;\r\n            Runnable getAssignments = new Runnable() {\r\n\r\n                public void run() {\r\n                    List<TabletLocation> tabletsToAssignMapFileTo = Collections.emptyList();\r\n                    try {\r\n                        tabletsToAssignMapFileTo = findOverlappingTablets(instance.getConfiguration(), fs, locator, mapFile);\r\n                    } catch (Exception ex) {\r\n                        log.warn(\"Unable to find tablets that overlap file \" + mapFile.toString());\r\n                    }\r\n                    if (tabletsToAssignMapFileTo.size() == 0) {\r\n                        List<KeyExtent> empty = Collections.emptyList();\r\n                        completeFailures.put(mapFile, empty);\r\n                    } else\r\n                        assignments.put(mapFile, tabletsToAssignMapFileTo);\r\n                }\r\n            };\r\n            threadPool.submit(new TraceRunnable(new LoggingRunnable(log, getAssignments)));\r\n        }\r\n        threadPool.shutdown();\r\n        while (!threadPool.isTerminated()) {\r\n            try {\r\n                threadPool.awaitTermination(60, TimeUnit.SECONDS);\r\n            } catch (InterruptedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n        timer.stop(Timers.EXAMINE_MAP_FILES);\r\n        assignmentStats.attemptingAssignments(assignments);\r\n        Map<Path, List<KeyExtent>> assignmentFailures = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);\r\n        assignmentStats.assignmentsFailed(assignmentFailures);\r\n        Map<Path, Integer> failureCount = new TreeMap<Path, Integer>();\r\n        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) failureCount.put(entry.getKey(), 1);\r\n        while (assignmentFailures.size() > 0) {\r\n            locator.invalidateCache();\r\n            \/\/ assumption about assignment failures is that it caused by a split\r\n            \/\/ happening or a missing location\r\n            \/\/ \r\n            \/\/ for splits we need to find children key extents that cover the\r\n            \/\/ same key range and are contiguous (no holes, no overlap)\r\n            timer.start(Timers.SLEEP);\r\n            UtilWaitThread.sleep(4000);\r\n            timer.stop(Timers.SLEEP);\r\n            log.debug(\"Trying to assign \" + assignmentFailures.size() + \" map files that previously failed on some key extents\");\r\n            assignments.clear();\r\n            \/\/ assign to\r\n            for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) {\r\n                Iterator<KeyExtent> keListIter = entry.getValue().iterator();\r\n                List<TabletLocation> tabletsToAssignMapFileTo = new ArrayList<TabletLocation>();\r\n                while (keListIter.hasNext()) {\r\n                    KeyExtent ke = keListIter.next();\r\n                    try {\r\n                        timer.start(Timers.QUERY_METADATA);\r\n                        tabletsToAssignMapFileTo.addAll(findOverlappingTablets(instance.getConfiguration(), fs, locator, entry.getKey(), ke));\r\n                        timer.stop(Timers.QUERY_METADATA);\r\n                        keListIter.remove();\r\n                    } catch (Exception ex) {\r\n                        log.warn(\"Exception finding overlapping tablets, will retry tablet \" + ke);\r\n                    }\r\n                }\r\n                if (tabletsToAssignMapFileTo.size() > 0)\r\n                    assignments.put(entry.getKey(), tabletsToAssignMapFileTo);\r\n            }\r\n            assignmentStats.attemptingAssignments(assignments);\r\n            Map<Path, List<KeyExtent>> assignmentFailures2 = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);\r\n            assignmentStats.assignmentsFailed(assignmentFailures2);\r\n            \/\/ merge assignmentFailures2 into assignmentFailures\r\n            for (Entry<Path, List<KeyExtent>> entry : assignmentFailures2.entrySet()) {\r\n                assignmentFailures.get(entry.getKey()).addAll(entry.getValue());\r\n                Integer fc = failureCount.get(entry.getKey());\r\n                if (fc == null)\r\n                    fc = 0;\r\n                failureCount.put(entry.getKey(), fc + 1);\r\n            }\r\n            \/\/ remove map files that have no more key extents to assign\r\n            Iterator<Entry<Path, List<KeyExtent>>> afIter = assignmentFailures.entrySet().iterator();\r\n            while (afIter.hasNext()) {\r\n                Entry<Path, List<KeyExtent>> entry = afIter.next();\r\n                if (entry.getValue().size() == 0)\r\n                    afIter.remove();\r\n            }\r\n            Set<Entry<Path, Integer>> failureIter = failureCount.entrySet();\r\n            for (Entry<Path, Integer> entry : failureIter) {\r\n                if (entry.getValue() > acuConf.getCount(Property.TSERV_BULK_RETRY) && assignmentFailures.get(entry.getKey()) != null) {\r\n                    log.error(\"Map file \" + entry.getKey() + \" failed more than three times, giving up.\");\r\n                    completeFailures.put(entry.getKey(), assignmentFailures.get(entry.getKey()));\r\n                    assignmentFailures.remove(entry.getKey());\r\n                }\r\n            }\r\n        }\r\n        assignmentStats.assignmentsAbandoned(completeFailures);\r\n        Set<Path> failedFailures = processFailures(conf, fs, failureDir, completeFailures);\r\n        assignmentStats.unrecoveredMapFiles(failedFailures);\r\n        timer.stop(Timers.TOTAL);\r\n        printReport();\r\n        return assignmentStats;\r\n    } finally {\r\n        if (client != null)\r\n            ServerClient.close(client);\r\n        locator.invalidateCache();\r\n    }\r\n}","code_comment":null,"code_no_comment":"public AssignmentStats importFiles(List<String> files, Path failureDir) throws IOException, AccumuloException, AccumuloSecurityException, ThriftTableOperationException {\r\n    int numThreads = acuConf.getCount(Property.TSERV_BULK_PROCESS_THREADS);\r\n    int numAssignThreads = acuConf.getCount(Property.TSERV_BULK_ASSIGNMENT_THREADS);\r\n    timer = new StopWatch<Timers>(Timers.class);\r\n    timer.start(Timers.TOTAL);\r\n    Configuration conf = CachedConfiguration.getInstance();\r\n    final FileSystem fs = FileSystem.get(conf);\r\n    Set<Path> paths = new HashSet<Path>();\r\n    for (String file : files) {\r\n        paths.add(new Path(file));\r\n    }\r\n    AssignmentStats assignmentStats = new AssignmentStats(paths.size());\r\n    final Map<Path, List<KeyExtent>> completeFailures = Collections.synchronizedSortedMap(new TreeMap<Path, List<KeyExtent>>());\r\n    if (!fs.exists(failureDir)) {\r\n        log.error(failureDir + \" does not exist\");\r\n        throw new RuntimeException(\"Directory does not exist \" + failureDir);\r\n    }\r\n    ClientService.Iface client = null;\r\n    final TabletLocator locator = TabletLocator.getInstance(instance, credentials, new Text(tableId));\r\n    try {\r\n        final Map<Path, List<TabletLocation>> assignments = Collections.synchronizedSortedMap(new TreeMap<Path, List<TabletLocation>>());\r\n        timer.start(Timers.EXAMINE_MAP_FILES);\r\n        ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);\r\n        for (Path path : paths) {\r\n            final Path mapFile = path;\r\n            Runnable getAssignments = new Runnable() {\r\n\r\n                public void run() {\r\n                    List<TabletLocation> tabletsToAssignMapFileTo = Collections.emptyList();\r\n                    try {\r\n                        tabletsToAssignMapFileTo = findOverlappingTablets(instance.getConfiguration(), fs, locator, mapFile);\r\n                    } catch (Exception ex) {\r\n                        log.warn(\"Unable to find tablets that overlap file \" + mapFile.toString());\r\n                    }\r\n                    if (tabletsToAssignMapFileTo.size() == 0) {\r\n                        List<KeyExtent> empty = Collections.emptyList();\r\n                        completeFailures.put(mapFile, empty);\r\n                    } else\r\n                        assignments.put(mapFile, tabletsToAssignMapFileTo);\r\n                }\r\n            };\r\n            threadPool.submit(new TraceRunnable(new LoggingRunnable(log, getAssignments)));\r\n        }\r\n        threadPool.shutdown();\r\n        while (!threadPool.isTerminated()) {\r\n            try {\r\n                threadPool.awaitTermination(60, TimeUnit.SECONDS);\r\n            } catch (InterruptedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n        timer.stop(Timers.EXAMINE_MAP_FILES);\r\n        assignmentStats.attemptingAssignments(assignments);\r\n        Map<Path, List<KeyExtent>> assignmentFailures = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);\r\n        assignmentStats.assignmentsFailed(assignmentFailures);\r\n        Map<Path, Integer> failureCount = new TreeMap<Path, Integer>();\r\n        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) failureCount.put(entry.getKey(), 1);\r\n        while (assignmentFailures.size() > 0) {\r\n            locator.invalidateCache();\r\n                                                                        timer.start(Timers.SLEEP);\r\n            UtilWaitThread.sleep(4000);\r\n            timer.stop(Timers.SLEEP);\r\n            log.debug(\"Trying to assign \" + assignmentFailures.size() + \" map files that previously failed on some key extents\");\r\n            assignments.clear();\r\n                        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures.entrySet()) {\r\n                Iterator<KeyExtent> keListIter = entry.getValue().iterator();\r\n                List<TabletLocation> tabletsToAssignMapFileTo = new ArrayList<TabletLocation>();\r\n                while (keListIter.hasNext()) {\r\n                    KeyExtent ke = keListIter.next();\r\n                    try {\r\n                        timer.start(Timers.QUERY_METADATA);\r\n                        tabletsToAssignMapFileTo.addAll(findOverlappingTablets(instance.getConfiguration(), fs, locator, entry.getKey(), ke));\r\n                        timer.stop(Timers.QUERY_METADATA);\r\n                        keListIter.remove();\r\n                    } catch (Exception ex) {\r\n                        log.warn(\"Exception finding overlapping tablets, will retry tablet \" + ke);\r\n                    }\r\n                }\r\n                if (tabletsToAssignMapFileTo.size() > 0)\r\n                    assignments.put(entry.getKey(), tabletsToAssignMapFileTo);\r\n            }\r\n            assignmentStats.attemptingAssignments(assignments);\r\n            Map<Path, List<KeyExtent>> assignmentFailures2 = assignMapFiles(acuConf, instance, conf, credentials, fs, tableId, assignments, paths, numAssignThreads, numThreads);\r\n            assignmentStats.assignmentsFailed(assignmentFailures2);\r\n                        for (Entry<Path, List<KeyExtent>> entry : assignmentFailures2.entrySet()) {\r\n                assignmentFailures.get(entry.getKey()).addAll(entry.getValue());\r\n                Integer fc = failureCount.get(entry.getKey());\r\n                if (fc == null)\r\n                    fc = 0;\r\n                failureCount.put(entry.getKey(), fc + 1);\r\n            }\r\n                        Iterator<Entry<Path, List<KeyExtent>>> afIter = assignmentFailures.entrySet().iterator();\r\n            while (afIter.hasNext()) {\r\n                Entry<Path, List<KeyExtent>> entry = afIter.next();\r\n                if (entry.getValue().size() == 0)\r\n                    afIter.remove();\r\n            }\r\n            Set<Entry<Path, Integer>> failureIter = failureCount.entrySet();\r\n            for (Entry<Path, Integer> entry : failureIter) {\r\n                if (entry.getValue() > acuConf.getCount(Property.TSERV_BULK_RETRY) && assignmentFailures.get(entry.getKey()) != null) {\r\n                    log.error(\"Map file \" + entry.getKey() + \" failed more than three times, giving up.\");\r\n                    completeFailures.put(entry.getKey(), assignmentFailures.get(entry.getKey()));\r\n                    assignmentFailures.remove(entry.getKey());\r\n                }\r\n            }\r\n        }\r\n        assignmentStats.assignmentsAbandoned(completeFailures);\r\n        Set<Path> failedFailures = processFailures(conf, fs, failureDir, completeFailures);\r\n        assignmentStats.unrecoveredMapFiles(failedFailures);\r\n        timer.stop(Timers.TOTAL);\r\n        printReport();\r\n        return assignmentStats;\r\n    } finally {\r\n        if (client != null)\r\n            ServerClient.close(client);\r\n        locator.invalidateCache();\r\n    }\r\n}","lc":4.6818181818,"pi":1.5693779904,"ma":3.8,"nbd":1.5,"ml":1.75,"d":1.496031746,"mi":-1.5443269908,"fo":7.5833333333,"r":-0.0263157895,"e":15.1663376037}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4255_c250db9c","label":1,"code":"\/**\r\n *  Returns <code>true<\/code> if the authority is properly formatted. An authority is the\r\n *  combination of host name and port. A <code>null<\/code> authority value is considered invalid.\r\n *\r\n *  @param authority\r\n *             an authority value to validate\r\n *  @return true if authority (host name and port) is valid.\r\n *\/\r\nprotected boolean isValidAuthority(String authority) {\r\n    if (authority == null) {\r\n        return false;\r\n    }\r\n    Matcher authorityMatcher = Pattern.compile(AUTHORITY_PATTERN).matcher(authority);\r\n    if (!authorityMatcher.matches()) {\r\n        return false;\r\n    }\r\n    boolean ipV4Address = false;\r\n    boolean hostname = false;\r\n    \/\/ check if authority is IP address or hostname\r\n    String hostIP = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP);\r\n    Matcher matchIPV4Pat = Pattern.compile(IP_V4_DOMAIN_PATTERN).matcher(hostIP);\r\n    ipV4Address = matchIPV4Pat.matches();\r\n    if (ipV4Address) {\r\n        \/\/ this is an IP address so check components\r\n        for (int i = 1; i <= 4; i++) {\r\n            String ipSegment = matchIPV4Pat.group(i);\r\n            if (ipSegment == null || ipSegment.length() <= 0) {\r\n                return false;\r\n            }\r\n            try {\r\n                if (Integer.parseInt(ipSegment) > 255) {\r\n                    return false;\r\n                }\r\n            } catch (NumberFormatException e) {\r\n                return false;\r\n            }\r\n        }\r\n    } else {\r\n        \/\/ Domain is hostname name\r\n        hostname = Pattern.compile(DOMAIN_PATTERN).matcher(hostIP).matches();\r\n    }\r\n    \/\/ rightmost hostname will never start with a digit.\r\n    if (hostname) {\r\n        \/\/ LOW-TECH FIX FOR VALIDATOR-202\r\n        \/\/ TODO: Rewrite to use ArrayList and .add semantics: see\r\n        \/\/ VALIDATOR-203\r\n        char[] chars = hostIP.toCharArray();\r\n        int size = 1;\r\n        for (char ch : chars) {\r\n            if (ch == '.') {\r\n                size++;\r\n            }\r\n        }\r\n        String[] domainSegment = new String[size];\r\n        boolean match = true;\r\n        int segmentCount = 0;\r\n        int segmentLength = 0;\r\n        while (match) {\r\n            Matcher atomMatcher = Pattern.compile(ATOM_PATTERN).matcher(hostIP);\r\n            match = atomMatcher.find();\r\n            if (match) {\r\n                domainSegment[segmentCount] = atomMatcher.group(1);\r\n                segmentLength = domainSegment[segmentCount].length() + 1;\r\n                hostIP = (segmentLength >= hostIP.length()) ? \"\" : hostIP.substring(segmentLength);\r\n                segmentCount++;\r\n            }\r\n        }\r\n        if (segmentCount > 1) {\r\n            String topLevel = domainSegment[segmentCount - 1];\r\n            if (topLevel.length() < 2 || topLevel.length() > 4) {\r\n                return false;\r\n            }\r\n            \/\/ First letter of top level must be a alpha\r\n            Matcher alphaMatcher = Pattern.compile(ALPHA_PATTERN).matcher(topLevel.substring(0, 1));\r\n            if (!alphaMatcher.matches()) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    if (!hostname && !ipV4Address) {\r\n        return false;\r\n    }\r\n    String port = authorityMatcher.group(PARSE_AUTHORITY_PORT);\r\n    if (port != null) {\r\n        Matcher portMatcher = Pattern.compile(PORT_PATTERN).matcher(port);\r\n        if (!portMatcher.matches()) {\r\n            return false;\r\n        }\r\n    }\r\n    String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA);\r\n    if (!isBlankOrNull(extra)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n *  Returns <code>true<\/code> if the authority is properly formatted. An authority is the\r\n *  combination of host name and port. A <code>null<\/code> authority value is considered invalid.\r\n *\r\n *  @param authority\r\n *             an authority value to validate\r\n *  @return true if authority (host name and port) is valid.\r\n *\/\r\n","code_no_comment":"protected boolean isValidAuthority(String authority) {\r\n    if (authority == null) {\r\n        return false;\r\n    }\r\n    Matcher authorityMatcher = Pattern.compile(AUTHORITY_PATTERN).matcher(authority);\r\n    if (!authorityMatcher.matches()) {\r\n        return false;\r\n    }\r\n    boolean ipV4Address = false;\r\n    boolean hostname = false;\r\n        String hostIP = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP);\r\n    Matcher matchIPV4Pat = Pattern.compile(IP_V4_DOMAIN_PATTERN).matcher(hostIP);\r\n    ipV4Address = matchIPV4Pat.matches();\r\n    if (ipV4Address) {\r\n                for (int i = 1; i <= 4; i++) {\r\n            String ipSegment = matchIPV4Pat.group(i);\r\n            if (ipSegment == null || ipSegment.length() <= 0) {\r\n                return false;\r\n            }\r\n            try {\r\n                if (Integer.parseInt(ipSegment) > 255) {\r\n                    return false;\r\n                }\r\n            } catch (NumberFormatException e) {\r\n                return false;\r\n            }\r\n        }\r\n    } else {\r\n                hostname = Pattern.compile(DOMAIN_PATTERN).matcher(hostIP).matches();\r\n    }\r\n        if (hostname) {\r\n                                char[] chars = hostIP.toCharArray();\r\n        int size = 1;\r\n        for (char ch : chars) {\r\n            if (ch == '.') {\r\n                size++;\r\n            }\r\n        }\r\n        String[] domainSegment = new String[size];\r\n        boolean match = true;\r\n        int segmentCount = 0;\r\n        int segmentLength = 0;\r\n        while (match) {\r\n            Matcher atomMatcher = Pattern.compile(ATOM_PATTERN).matcher(hostIP);\r\n            match = atomMatcher.find();\r\n            if (match) {\r\n                domainSegment[segmentCount] = atomMatcher.group(1);\r\n                segmentLength = domainSegment[segmentCount].length() + 1;\r\n                hostIP = (segmentLength >= hostIP.length()) ? \"\" : hostIP.substring(segmentLength);\r\n                segmentCount++;\r\n            }\r\n        }\r\n        if (segmentCount > 1) {\r\n            String topLevel = domainSegment[segmentCount - 1];\r\n            if (topLevel.length() < 2 || topLevel.length() > 4) {\r\n                return false;\r\n            }\r\n                        Matcher alphaMatcher = Pattern.compile(ALPHA_PATTERN).matcher(topLevel.substring(0, 1));\r\n            if (!alphaMatcher.matches()) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    if (!hostname && !ipV4Address) {\r\n        return false;\r\n    }\r\n    String port = authorityMatcher.group(PARSE_AUTHORITY_PORT);\r\n    if (port != null) {\r\n        Matcher portMatcher = Pattern.compile(PORT_PATTERN).matcher(port);\r\n        if (!portMatcher.matches()) {\r\n            return false;\r\n        }\r\n    }\r\n    String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA);\r\n    if (!isBlankOrNull(extra)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}","lc":2.9545454545,"pi":0.7320574163,"ma":3.4,"nbd":1.0,"ml":2.9166666667,"d":3.248015873,"mi":-1.2147991543,"fo":2.25,"r":-0.0263157895,"e":11.5035424699}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-434_133cbc2d","label":1,"code":"\/**\r\n * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\r\n * @param tableau simple tableau for the problem\r\n * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\r\n * @return row with the minimum ratio\r\n *\/\r\nprivate Integer getPivotRow(SimplexTableau tableau, final int col) {\r\n    \/\/ create a list of all the rows that tie for the lowest score in the minimum ratio test\r\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\r\n    double minRatio = Double.MAX_VALUE;\r\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\r\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\r\n        final double entry = tableau.getEntry(i, col);\r\n        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\r\n            final double ratio = rhs \/ entry;\r\n            if (MathUtils.equals(ratio, minRatio, epsilon)) {\r\n                minRatioPositions.add(i);\r\n            } else if (ratio < minRatio) {\r\n                minRatio = ratio;\r\n                minRatioPositions = new ArrayList<Integer>();\r\n                minRatioPositions.add(i);\r\n            }\r\n        }\r\n    }\r\n    if (minRatioPositions.size() == 0) {\r\n        return null;\r\n    } else if (minRatioPositions.size() > 1) {\r\n        \/\/ check if there's an artificial variable that can be forced out of the basis\r\n        for (Integer row : minRatioPositions) {\r\n            for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\r\n                int column = i + tableau.getArtificialVariableOffset();\r\n                if (MathUtils.equals(tableau.getEntry(row, column), 1, epsilon) && row.equals(tableau.getBasicRow(column))) {\r\n                    return row;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return minRatioPositions.get(0);\r\n}","code_comment":"\/**\r\n * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\r\n * @param tableau simple tableau for the problem\r\n * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\r\n * @return row with the minimum ratio\r\n *\/\r\n","code_no_comment":"private Integer getPivotRow(SimplexTableau tableau, final int col) {\r\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\r\n    double minRatio = Double.MAX_VALUE;\r\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\r\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\r\n        final double entry = tableau.getEntry(i, col);\r\n        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\r\n            final double ratio = rhs \/ entry;\r\n            if (MathUtils.equals(ratio, minRatio, epsilon)) {\r\n                minRatioPositions.add(i);\r\n            } else if (ratio < minRatio) {\r\n                minRatio = ratio;\r\n                minRatioPositions = new ArrayList<Integer>();\r\n                minRatioPositions.add(i);\r\n            }\r\n        }\r\n    }\r\n    if (minRatioPositions.size() == 0) {\r\n        return null;\r\n    } else if (minRatioPositions.size() > 1) {\r\n                for (Integer row : minRatioPositions) {\r\n            for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\r\n                int column = i + tableau.getArtificialVariableOffset();\r\n                if (MathUtils.equals(tableau.getEntry(row, column), 1, epsilon) && row.equals(tableau.getBasicRow(column))) {\r\n                    return row;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return minRatioPositions.get(0);\r\n}","lc":0.7727272727,"pi":1.1196172249,"ma":1.2,"nbd":1.5,"ml":1.6666666667,"d":1.8353174603,"mi":-0.6047921071,"fo":1.0,"r":-0.0263157895,"e":3.1576102303}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-891_2b852d79","label":1,"code":"\/**\r\n * Applies rank transform to each of the columns of <code>matrix<\/code>\r\n * using the current <code>rankingAlgorithm<\/code>\r\n *\r\n * @param matrix matrix to transform\r\n *\/\r\nprivate void rankTransform(RealMatrix matrix) {\r\n    for (int i = 0; i < matrix.getColumnDimension(); i++) {\r\n        matrix.setColumn(i, rankingAlgorithm.rank(matrix.getColumn(i)));\r\n    }\r\n}","code_comment":"\/**\r\n * Applies rank transform to each of the columns of <code>matrix<\/code>\r\n * using the current <code>rankingAlgorithm<\/code>\r\n *\r\n * @param matrix matrix to transform\r\n *\/\r\n","code_no_comment":"private void rankTransform(RealMatrix matrix) {\r\n    for (int i = 0; i < matrix.getColumnDimension(); i++) {\r\n        matrix.setColumn(i, rankingAlgorithm.rank(matrix.getColumn(i)));\r\n    }\r\n}","lc":-0.4090909091,"pi":0.0,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0396825397,"mi":0.5873150106,"fo":-0.1666666667,"r":0.4473684211,"e":-0.1024763288}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-888_6d82cb64","label":1,"code":"\/**\r\n * Calculate the number of elements in the path. The root path has zero\r\n * elements.\r\n *\r\n * @param path the path\r\n * @return the number of elements\r\n *\/\r\npublic static int getDepth(String path) {\r\n    assert isValid(path);\r\n    int count = 1, i = 0;\r\n    if (isAbsolutePath(path)) {\r\n        if (denotesRootPath(path)) {\r\n            return 0;\r\n        }\r\n        i++;\r\n    }\r\n    while (true) {\r\n        i = path.indexOf('\/', i) + 1;\r\n        if (i == 0) {\r\n            return count;\r\n        }\r\n        count++;\r\n    }\r\n}","code_comment":"\/**\r\n * Calculate the number of elements in the path. The root path has zero\r\n * elements.\r\n *\r\n * @param path the path\r\n * @return the number of elements\r\n *\/\r\n","code_no_comment":"public static int getDepth(String path) {\r\n    assert isValid(path);\r\n    int count = 1, i = 0;\r\n    if (isAbsolutePath(path)) {\r\n        if (denotesRootPath(path)) {\r\n            return 0;\r\n        }\r\n        i++;\r\n    }\r\n    while (true) {\r\n        i = path.indexOf('\/', i) + 1;\r\n        if (i == 0) {\r\n            return count;\r\n        }\r\n        count++;\r\n    }\r\n}","lc":0.1363636364,"pi":0.1913875598,"ma":0.2,"nbd":0.0,"ml":0.25,"d":-0.3650793651,"mi":0.3465821001,"fo":-0.1666666667,"r":0.3684210526,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1096_faf99727","label":0,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic EnclosingBall<S, P> enclose(final List<P> points) {\r\n    if (points == null || points.isEmpty()) {\r\n        \/\/ return an empty ball\r\n        return generator.ballOnSupport(new ArrayList<P>());\r\n    }\r\n    \/\/ Emo Welzl algorithm with Bernd G\u00e4rtner and Linus K\u00e4llberg improvements\r\n    return pivotingBall(points);\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public EnclosingBall<S, P> enclose(final List<P> points) {\r\n    if (points == null || points.isEmpty()) {\r\n                return generator.ballOnSupport(new ArrayList<P>());\r\n    }\r\n        return pivotingBall(points);\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0912698413,"mi":0.5075405215,"fo":-0.25,"r":2.4473684211,"e":-0.1129141382}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3314_8fc7e7af","label":0,"code":"\/\/ ------------------------------------------------------------------------\r\n\/\/ Core work methods of the Stream Task\r\n\/\/ ------------------------------------------------------------------------\r\n@Override\r\npublic final void invoke() throws Exception {\r\n    boolean disposed = false;\r\n    try {\r\n        \/\/ -------- Initialize ---------\r\n        LOG.debug(\"Initializing {}\", getName());\r\n        userClassLoader = getUserCodeClassLoader();\r\n        configuration = new StreamConfig(getTaskConfiguration());\r\n        accumulatorMap = getEnvironment().getAccumulatorRegistry().getUserMap();\r\n        headOperator = configuration.getStreamOperator(userClassLoader);\r\n        operatorChain = new OperatorChain<>(this, headOperator, getEnvironment().getAccumulatorRegistry().getReadWriteReporter());\r\n        if (headOperator != null) {\r\n            headOperator.setup(this, configuration, operatorChain.getChainEntryPoint());\r\n        }\r\n        timerService = Executors.newSingleThreadScheduledExecutor(new DispatcherThreadFactory(TRIGGER_THREAD_GROUP, \"Time Trigger for \" + getName()));\r\n        \/\/ task specific initialization\r\n        init();\r\n        \/\/ -------- Invoke --------\r\n        LOG.debug(\"Invoking {}\", getName());\r\n        \/\/ first order of business is to give operators back their state\r\n        stateBackend = createStateBackend();\r\n        stateBackend.initializeForJob(getEnvironment());\r\n        restoreState();\r\n        \/\/ executed before all operators are opened\r\n        synchronized (lock) {\r\n            openAllOperators();\r\n        }\r\n        \/\/ let the task do its work\r\n        isRunning = true;\r\n        run();\r\n        isRunning = false;\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Finished task {}\", getName());\r\n        }\r\n        \/\/ we also need to make sure that no triggers fire concurrently with the close logic\r\n        synchronized (lock) {\r\n            \/\/ this is part of the main logic, so if this fails, the task is considered failed\r\n            closeAllOperators();\r\n        }\r\n        \/\/ make sure all buffered data is flushed\r\n        operatorChain.flushOutputs();\r\n        \/\/ make an attempt to dispose the operators such that failures in the dispose call\r\n        \/\/ still let the computation fail\r\n        tryDisposeAllOperators();\r\n        disposed = true;\r\n    } finally {\r\n        \/\/ clean up everything we initialized\r\n        isRunning = false;\r\n        \/\/ stop all timers and threads\r\n        if (timerService != null) {\r\n            try {\r\n                timerService.shutdownNow();\r\n            } catch (Throwable t) {\r\n                \/\/ catch and log the exception to not replace the original exception\r\n                LOG.error(\"Could not shut down timer service\", t);\r\n            }\r\n        }\r\n        \/\/ stop all asynchronous checkpoint threads\r\n        try {\r\n            for (Thread checkpointThread : asyncCheckpointThreads) {\r\n                checkpointThread.interrupt();\r\n            }\r\n            asyncCheckpointThreads.clear();\r\n        } catch (Throwable t) {\r\n            \/\/ catch and log the exception to not replace the original exception\r\n            LOG.error(\"Could not shut down async checkpoint threads\", t);\r\n        }\r\n        \/\/ release the output resources. this method should never fail.\r\n        if (operatorChain != null) {\r\n            operatorChain.releaseOutputs();\r\n        }\r\n        \/\/ we must! perform this cleanup\r\n        try {\r\n            cleanup();\r\n        } catch (Throwable t) {\r\n            \/\/ catch and log the exception to not replace the original exception\r\n            LOG.error(\"Error during cleanup of stream task\", t);\r\n        }\r\n        \/\/ if the operators were not disposed before, do a hard dispose\r\n        if (!disposed) {\r\n            disposeAllOperators();\r\n        }\r\n        try {\r\n            if (stateBackend != null) {\r\n                stateBackend.close();\r\n            }\r\n        } catch (Throwable t) {\r\n            LOG.error(\"Error while closing the state backend\", t);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic final void invoke() throws Exception {\r\n    boolean disposed = false;\r\n    try {\r\n                LOG.debug(\"Initializing {}\", getName());\r\n        userClassLoader = getUserCodeClassLoader();\r\n        configuration = new StreamConfig(getTaskConfiguration());\r\n        accumulatorMap = getEnvironment().getAccumulatorRegistry().getUserMap();\r\n        headOperator = configuration.getStreamOperator(userClassLoader);\r\n        operatorChain = new OperatorChain<>(this, headOperator, getEnvironment().getAccumulatorRegistry().getReadWriteReporter());\r\n        if (headOperator != null) {\r\n            headOperator.setup(this, configuration, operatorChain.getChainEntryPoint());\r\n        }\r\n        timerService = Executors.newSingleThreadScheduledExecutor(new DispatcherThreadFactory(TRIGGER_THREAD_GROUP, \"Time Trigger for \" + getName()));\r\n                init();\r\n                LOG.debug(\"Invoking {}\", getName());\r\n                stateBackend = createStateBackend();\r\n        stateBackend.initializeForJob(getEnvironment());\r\n        restoreState();\r\n                synchronized (lock) {\r\n            openAllOperators();\r\n        }\r\n                isRunning = true;\r\n        run();\r\n        isRunning = false;\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Finished task {}\", getName());\r\n        }\r\n                synchronized (lock) {\r\n                        closeAllOperators();\r\n        }\r\n                operatorChain.flushOutputs();\r\n                        tryDisposeAllOperators();\r\n        disposed = true;\r\n    } finally {\r\n                isRunning = false;\r\n                if (timerService != null) {\r\n            try {\r\n                timerService.shutdownNow();\r\n            } catch (Throwable t) {\r\n                                LOG.error(\"Could not shut down timer service\", t);\r\n            }\r\n        }\r\n                try {\r\n            for (Thread checkpointThread : asyncCheckpointThreads) {\r\n                checkpointThread.interrupt();\r\n            }\r\n            asyncCheckpointThreads.clear();\r\n        } catch (Throwable t) {\r\n                        LOG.error(\"Could not shut down async checkpoint threads\", t);\r\n        }\r\n                if (operatorChain != null) {\r\n            operatorChain.releaseOutputs();\r\n        }\r\n                try {\r\n            cleanup();\r\n        } catch (Throwable t) {\r\n                        LOG.error(\"Error during cleanup of stream task\", t);\r\n        }\r\n                if (!disposed) {\r\n            disposeAllOperators();\r\n        }\r\n        try {\r\n            if (stateBackend != null) {\r\n                stateBackend.close();\r\n            }\r\n        } catch (Throwable t) {\r\n            LOG.error(\"Error while closing the state backend\", t);\r\n        }\r\n    }\r\n}","lc":2.5909090909,"pi":0.1148325359,"ma":1.6,"nbd":0.5,"ml":0.5833333333,"d":0.369047619,"mi":-1.0369274137,"fo":2.9166666667,"r":-0.0263157895,"e":1.2997769748}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7304_fa165d6b","label":3,"code":"@Override\r\npublic Processor createProcessor(final RouteContext routeContext) throws Exception {\r\n    \/\/ create the detour\r\n    final Processor detour = this.createChildProcessor(routeContext, true);\r\n    \/\/ register endpoint callback so we can proxy the endpoint\r\n    routeContext.getCamelContext().addRegisterEndpointCallback(new EndpointStrategy() {\r\n\r\n        public Endpoint registerEndpoint(String uri, Endpoint endpoint) {\r\n            if (endpoint instanceof InterceptSendToEndpoint) {\r\n                \/\/ endpoint already decorated\r\n                return endpoint;\r\n            } else if (getUri() == null || EndpointHelper.matchEndpoint(routeContext.getCamelContext(), uri, getUri())) {\r\n                \/\/ only proxy if the uri is matched decorate endpoint with our proxy\r\n                \/\/ should be false by default\r\n                boolean skip = isSkipSendToOriginalEndpoint();\r\n                InterceptSendToEndpoint proxy = new InterceptSendToEndpoint(endpoint, skip);\r\n                proxy.setDetour(detour);\r\n                return proxy;\r\n            } else {\r\n                \/\/ no proxy so return regular endpoint\r\n                return endpoint;\r\n            }\r\n        }\r\n    });\r\n    \/\/ remove the original intercepted route from the outputs as we do not intercept as the regular interceptor\r\n    \/\/ instead we use the proxy endpoints producer do the triggering. That is we trigger when someone sends\r\n    \/\/ an exchange to the endpoint, see InterceptSendToEndpoint for details.\r\n    RouteDefinition route = routeContext.getRoute();\r\n    List<ProcessorDefinition<?>> outputs = route.getOutputs();\r\n    outputs.remove(this);\r\n    return new InterceptEndpointProcessor(uri, detour);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Processor createProcessor(final RouteContext routeContext) throws Exception {\r\n        final Processor detour = this.createChildProcessor(routeContext, true);\r\n        routeContext.getCamelContext().addRegisterEndpointCallback(new EndpointStrategy() {\r\n\r\n        public Endpoint registerEndpoint(String uri, Endpoint endpoint) {\r\n            if (endpoint instanceof InterceptSendToEndpoint) {\r\n                                return endpoint;\r\n            } else if (getUri() == null || EndpointHelper.matchEndpoint(routeContext.getCamelContext(), uri, getUri())) {\r\n                                                boolean skip = isSkipSendToOriginalEndpoint();\r\n                InterceptSendToEndpoint proxy = new InterceptSendToEndpoint(endpoint, skip);\r\n                proxy.setDetour(detour);\r\n                return proxy;\r\n            } else {\r\n                                return endpoint;\r\n            }\r\n        }\r\n    });\r\n                RouteDefinition route = routeContext.getRoute();\r\n    List<ProcessorDefinition<?>> outputs = route.getOutputs();\r\n    outputs.remove(this);\r\n    return new InterceptEndpointProcessor(uri, detour);\r\n}","lc":0.3636363636,"pi":1.3540669856,"ma":-0.2,"nbd":0.5,"ml":0.25,"d":-0.0396825397,"mi":-0.311627907,"fo":0.5,"r":-0.0263157895,"e":0.1007797237}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5701_087c0a26","label":1,"code":"\/**\r\n *  Sends the payload either to the page (and its WebSocketBehavior)\r\n *  or to the WebSocketResource with name {@linkplain #resourceName}\r\n *\r\n *  @param payload\r\n *           The payload with the web socket message\r\n *  @param page\r\n *           The page that owns the WebSocketBehavior, in case of behavior usage\r\n *\/\r\nprivate void sendPayload(final WebSocketPayload payload, final Page page) {\r\n    final Runnable action = new Runnable() {\r\n\r\n        @Override\r\n        public void run() {\r\n            if (pageId != NO_PAGE_ID) {\r\n                page.send(application, Broadcast.BREADTH, payload);\r\n            } else {\r\n                ResourceReference reference = new SharedResourceReference(resourceName);\r\n                IResource resource = reference.getResource();\r\n                if (resource instanceof WebSocketResource) {\r\n                    WebSocketResource wsResource = (WebSocketResource) resource;\r\n                    wsResource.onPayload(payload);\r\n                } else {\r\n                    throw new IllegalStateException(String.format(\"Shared resource with name '%s' is not a %s but %s\", resourceName, WebSocketResource.class.getSimpleName(), Classes.name(resource.getClass())));\r\n                }\r\n            }\r\n        }\r\n    };\r\n    WebSocketSettings webSocketSettings = WebSocketSettings.Holder.get(application);\r\n    webSocketSettings.getSendPayloadExecutor().run(action);\r\n}","code_comment":"\/**\r\n *  Sends the payload either to the page (and its WebSocketBehavior)\r\n *  or to the WebSocketResource with name {@linkplain #resourceName}\r\n *\r\n *  @param payload\r\n *           The payload with the web socket message\r\n *  @param page\r\n *           The page that owns the WebSocketBehavior, in case of behavior usage\r\n *\/\r\n","code_no_comment":"private void sendPayload(final WebSocketPayload payload, final Page page) {\r\n    final Runnable action = new Runnable() {\r\n\r\n        @Override\r\n        public void run() {\r\n            if (pageId != NO_PAGE_ID) {\r\n                page.send(application, Broadcast.BREADTH, payload);\r\n            } else {\r\n                ResourceReference reference = new SharedResourceReference(resourceName);\r\n                IResource resource = reference.getResource();\r\n                if (resource instanceof WebSocketResource) {\r\n                    WebSocketResource wsResource = (WebSocketResource) resource;\r\n                    wsResource.onPayload(payload);\r\n                } else {\r\n                    throw new IllegalStateException(String.format(\"Shared resource with name '%s' is not a %s but %s\", resourceName, WebSocketResource.class.getSimpleName(), Classes.name(resource.getClass())));\r\n                }\r\n            }\r\n        }\r\n    };\r\n    WebSocketSettings webSocketSettings = WebSocketSettings.Holder.get(application);\r\n    webSocketSettings.getSendPayloadExecutor().run(action);\r\n}","lc":0.3181818182,"pi":1.6315789474,"ma":0.0,"nbd":0.5,"ml":-0.0833333333,"d":-0.0753968254,"mi":-0.2918957012,"fo":0.3333333333,"r":-0.0263157895,"e":0.0646392697}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4276_32c76c4a","label":1,"code":"\/**\r\n *  Checks if the specified option is selected based on raw input\r\n *\r\n *  @param option\r\n *  @return true} iff the option is selected\r\n *\/\r\nboolean isSelected(final SelectOption<?> option) {\r\n    Args.notNull(option, \"option\");\r\n    \/\/ if the raw input is specified use that, otherwise use model\r\n    if (hasRawInput()) {\r\n        String[] paths = getInputAsArray();\r\n        if ((paths != null) && (paths.length > 0)) {\r\n            for (String path : paths) {\r\n                if (path.equals(option.getPath())) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    return compareModels(getDefaultModelObject(), option.getDefaultModelObject());\r\n}","code_comment":"\/**\r\n *  Checks if the specified option is selected based on raw input\r\n *\r\n *  @param option\r\n *  @return true} iff the option is selected\r\n *\/\r\n","code_no_comment":"boolean isSelected(final SelectOption<?> option) {\r\n    Args.notNull(option, \"option\");\r\n        if (hasRawInput()) {\r\n        String[] paths = getInputAsArray();\r\n        if ((paths != null) && (paths.length > 0)) {\r\n            for (String path : paths) {\r\n                if (path.equals(option.getPath())) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    return compareModels(getDefaultModelObject(), option.getDefaultModelObject());\r\n}","lc":0.0454545455,"pi":1.3540669856,"ma":0.2,"nbd":1.0,"ml":0.3333333333,"d":0.2301587302,"mi":-0.0317124736,"fo":0.1666666667,"r":0.2368421053,"e":0.0528183584}
{"project_name":"Closure","project_version":"162","label":2,"code":"@Override\r\npublic void enterScope(NodeTraversal t) {\r\n    Node n = t.getCurrentNode().getParent();\r\n    if (n != null && isCallToScopeMethod(n)) {\r\n        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void enterScope(NodeTraversal t) {\r\n    Node n = t.getCurrentNode().getParent();\r\n    if (n != null && isCallToScopeMethod(n)) {\r\n        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\r\n    }\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":-0.1051587302,"mi":0.392248062,"fo":0.0,"r":0.2105263158,"e":-0.0985298779}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1096_faf99727","label":0,"code":"\/**\r\n * Select the point farthest to the current ball.\r\n * @param points points to be enclosed\r\n * @param ball current ball\r\n * @return farthest point\r\n *\/\r\npublic P selectFarthest(final List<P> points, final EnclosingBall<S, P> ball) {\r\n    final P center = ball.getCenter();\r\n    P farthest = null;\r\n    double dMax = -1.0;\r\n    for (final P point : points) {\r\n        final double d = point.distance(center);\r\n        if (d > dMax) {\r\n            farthest = point;\r\n            dMax = d;\r\n        }\r\n    }\r\n    return farthest;\r\n}","code_comment":"\/**\r\n * Select the point farthest to the current ball.\r\n * @param points points to be enclosed\r\n * @param ball current ball\r\n * @return farthest point\r\n *\/\r\n","code_no_comment":"public P selectFarthest(final List<P> points, final EnclosingBall<S, P> ball) {\r\n    final P center = ball.getCenter();\r\n    P farthest = null;\r\n    double dMax = -1.0;\r\n    for (final P point : points) {\r\n        final double d = point.distance(center);\r\n        if (d > dMax) {\r\n            farthest = point;\r\n            dMax = d;\r\n        }\r\n    }\r\n    return farthest;\r\n}","lc":-0.0454545455,"pi":0.3349282297,"ma":-0.2,"nbd":0.0,"ml":-0.1666666667,"d":0.0198412698,"mi":0.0280479211,"fo":-0.3333333333,"r":1.4210526316,"e":-0.0042115454}
{"project_name":"Closure","project_version":"9","label":2,"code":"private String normalizeSourceName(String filename) {\r\n    if (filename.indexOf(filenamePrefix) == 0) {\r\n        filename = filename.substring(filenamePrefix.length());\r\n    }\r\n    return filename;\r\n}","code_comment":null,"code_no_comment":"private String normalizeSourceName(String filename) {\r\n    if (filename.indexOf(filenamePrefix) == 0) {\r\n        filename = filename.substring(filenamePrefix.length());\r\n    }\r\n    return filename;\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0337301587,"mi":0.5492600423,"fo":-0.25,"r":0.3421052632,"e":-0.1176028538}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5056_56169634","label":1,"code":"\/**\r\n *  @see AbstractBookmarkableMapper#getCompatibilityScore(org.apache.wicket.request.Request)\r\n *\/\r\n@Override\r\npublic int getCompatibilityScore(Request request) {\r\n    if (urlStartsWith(request.getUrl(), mountSegments)) {\r\n        return mountSegments.length;\r\n    } else {\r\n        return 0;\r\n    }\r\n}","code_comment":"\/**\r\n *  @see AbstractBookmarkableMapper#getCompatibilityScore(org.apache.wicket.request.Request)\r\n *\/\r\n","code_no_comment":"@Override\r\npublic int getCompatibilityScore(Request request) {\r\n    if (urlStartsWith(request.getUrl(), mountSegments)) {\r\n        return mountSegments.length;\r\n    } else {\r\n        return 0;\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.4748414376,"fo":-0.3333333333,"r":1.1578947368,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-373_bfe4623c","label":1,"code":"\/**\r\n * Returns the sum of the natural logs of the entries in the specified portion of\r\n * the input array, or <code>Double.NaN<\/code> if the designated subarray\r\n * is empty.\r\n * <p>\r\n * Throws <code>IllegalArgumentException<\/code> if the array is null.<\/p>\r\n * <p>\r\n * See {@link SumOfLogs}.<\/p>\r\n *\r\n * @param values the input array\r\n * @param begin index of the first array element to include\r\n * @param length the number of elements to include\r\n * @return the sum of the natural logs of the values or Double.NaN if\r\n * length = 0\r\n * @throws IllegalArgumentException if the array is null or the array index\r\n *  parameters are not valid\r\n *\/\r\n@Override\r\npublic double evaluate(final double[] values, final int begin, final int length) {\r\n    double sumLog = Double.NaN;\r\n    if (test(values, begin, length)) {\r\n        sumLog = 0.0;\r\n        for (int i = begin; i < begin + length; i++) {\r\n            sumLog += FastMath.log(values[i]);\r\n        }\r\n    }\r\n    return sumLog;\r\n}","code_comment":"\/**\r\n * Returns the sum of the natural logs of the entries in the specified portion of\r\n * the input array, or <code>Double.NaN<\/code> if the designated subarray\r\n * is empty.\r\n * <p>\r\n * Throws <code>IllegalArgumentException<\/code> if the array is null.<\/p>\r\n * <p>\r\n * See {@link SumOfLogs}.<\/p>\r\n *\r\n * @param values the input array\r\n * @param begin index of the first array element to include\r\n * @param length the number of elements to include\r\n * @return the sum of the natural logs of the values or Double.NaN if\r\n * length = 0\r\n * @throws IllegalArgumentException if the array is null or the array index\r\n *  parameters are not valid\r\n *\/\r\n","code_no_comment":"@Override\r\npublic double evaluate(final double[] values, final int begin, final int length) {\r\n    double sumLog = Double.NaN;\r\n    if (test(values, begin, length)) {\r\n        sumLog = 0.0;\r\n        for (int i = begin; i < begin + length; i++) {\r\n            sumLog += FastMath.log(values[i]);\r\n        }\r\n    }\r\n    return sumLog;\r\n}","lc":-0.1363636364,"pi":0.3588516746,"ma":-0.2,"nbd":0.0,"ml":0.1666666667,"d":0.4007936508,"mi":0.1343199436,"fo":-0.3333333333,"r":-0.0263157895,"e":0.0940440172}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"\/\/ ------------------------------------------------------------< private >---\r\nprivate NodeState getNodeState() {\r\n    return builder.getNodeState();\r\n}","code_comment":null,"code_no_comment":"private NodeState getNodeState() {\r\n    return builder.getNodeState();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1319238901,"fo":-0.4166666667,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3563_c62b66c1","label":1,"code":"\/**\r\n *  Renders a placeholder tag for the component when it is invisible and\r\n *  {@link #setOutputMarkupPlaceholderTag(boolean)} has been called with <code>true<\/code>.\r\n *\r\n *  @param tag\r\n *             component tag\r\n *  @param response\r\n *             response\r\n *\/\r\nprotected void renderPlaceholderTag(final ComponentTag tag, final Response response) {\r\n    String ns = Strings.isEmpty(tag.getNamespace()) ? null : tag.getNamespace() + \":\";\r\n    response.write(\"<\");\r\n    if (ns != null) {\r\n        response.write(ns);\r\n    }\r\n    response.write(tag.getName());\r\n    response.write(\" id=\\\"\");\r\n    response.write(getMarkupId());\r\n    response.write(\"\\\" style=\\\"display:none\\\"><\/\");\r\n    if (ns != null) {\r\n        response.write(ns);\r\n    }\r\n    response.write(tag.getName());\r\n    response.write(\">\");\r\n}","code_comment":"\/**\r\n *  Renders a placeholder tag for the component when it is invisible and\r\n *  {@link #setOutputMarkupPlaceholderTag(boolean)} has been called with <code>true<\/code>.\r\n *\r\n *  @param tag\r\n *             component tag\r\n *  @param response\r\n *             response\r\n *\/\r\n","code_no_comment":"protected void renderPlaceholderTag(final ComponentTag tag, final Response response) {\r\n    String ns = Strings.isEmpty(tag.getNamespace()) ? null : tag.getNamespace() + \":\";\r\n    response.write(\"<\");\r\n    if (ns != null) {\r\n        response.write(ns);\r\n    }\r\n    response.write(tag.getName());\r\n    response.write(\" id=\\\"\");\r\n    response.write(getMarkupId());\r\n    response.write(\"\\\" style=\\\"display:none\\\"><\/\");\r\n    if (ns != null) {\r\n        response.write(ns);\r\n    }\r\n    response.write(tag.getName());\r\n    response.write(\">\");\r\n}","lc":0.0909090909,"pi":-0.4736842105,"ma":0.0,"nbd":-0.5,"ml":0.0833333333,"d":0.121031746,"mi":-0.117688513,"fo":0.75,"r":-0.0263157895,"e":0.1080087366}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3634_90ad50da","label":1,"code":"@Override\r\npublic CacheInvalidationStats invalidateCache(Iterable<String> keys) {\r\n    LOG.debug(\"invalidateCache: start\");\r\n    final InvalidationResult result = new InvalidationResult();\r\n    int size = 0;\r\n    final Iterator<String> it = keys.iterator();\r\n    while (it.hasNext()) {\r\n        \/\/ read chunks of documents only\r\n        final List<String> ids = new ArrayList<String>(IN_CLAUSE_BATCH_SIZE);\r\n        while (it.hasNext() && ids.size() < IN_CLAUSE_BATCH_SIZE) {\r\n            final String id = it.next();\r\n            if (nodesCache.getIfPresent(id) != null) {\r\n                \/\/ only add those that we actually do have cached\r\n                ids.add(id);\r\n            }\r\n        }\r\n        size += ids.size();\r\n        if (LOG.isTraceEnabled()) {\r\n            LOG.trace(\"invalidateCache: batch size: {} of total so far {}\", ids.size(), size);\r\n        }\r\n        QueryBuilder query = QueryBuilder.start(Document.ID).in(ids);\r\n        \/\/ Fetch only the modCount and id\r\n        final BasicDBObject fields = new BasicDBObject(Document.ID, 1);\r\n        fields.put(Document.MOD_COUNT, 1);\r\n        DBCursor cursor = nodes.find(query.get(), fields);\r\n        cursor.setReadPreference(ReadPreference.primary());\r\n        result.queryCount++;\r\n        Map<String, Number> modCounts = new HashMap<String, Number>();\r\n        for (DBObject obj : cursor) {\r\n            String id = (String) obj.get(Document.ID);\r\n            Number modCount = (Number) obj.get(Document.MOD_COUNT);\r\n            modCounts.put(id, modCount);\r\n        }\r\n        int invalidated = nodesCache.invalidateOutdated(modCounts);\r\n        result.cacheEntriesProcessedCount += modCounts.size();\r\n        result.invalidationCount += invalidated;\r\n        result.upToDateCount = modCounts.size() - invalidated;\r\n    }\r\n    result.cacheSize = size;\r\n    LOG.trace(\"invalidateCache: end. total: {}\", size);\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic CacheInvalidationStats invalidateCache(Iterable<String> keys) {\r\n    LOG.debug(\"invalidateCache: start\");\r\n    final InvalidationResult result = new InvalidationResult();\r\n    int size = 0;\r\n    final Iterator<String> it = keys.iterator();\r\n    while (it.hasNext()) {\r\n                final List<String> ids = new ArrayList<String>(IN_CLAUSE_BATCH_SIZE);\r\n        while (it.hasNext() && ids.size() < IN_CLAUSE_BATCH_SIZE) {\r\n            final String id = it.next();\r\n            if (nodesCache.getIfPresent(id) != null) {\r\n                                ids.add(id);\r\n            }\r\n        }\r\n        size += ids.size();\r\n        if (LOG.isTraceEnabled()) {\r\n            LOG.trace(\"invalidateCache: batch size: {} of total so far {}\", ids.size(), size);\r\n        }\r\n        QueryBuilder query = QueryBuilder.start(Document.ID).in(ids);\r\n                final BasicDBObject fields = new BasicDBObject(Document.ID, 1);\r\n        fields.put(Document.MOD_COUNT, 1);\r\n        DBCursor cursor = nodes.find(query.get(), fields);\r\n        cursor.setReadPreference(ReadPreference.primary());\r\n        result.queryCount++;\r\n        Map<String, Number> modCounts = new HashMap<String, Number>();\r\n        for (DBObject obj : cursor) {\r\n            String id = (String) obj.get(Document.ID);\r\n            Number modCount = (Number) obj.get(Document.MOD_COUNT);\r\n            modCounts.put(id, modCount);\r\n        }\r\n        int invalidated = nodesCache.invalidateOutdated(modCounts);\r\n        result.cacheEntriesProcessedCount += modCounts.size();\r\n        result.invalidationCount += invalidated;\r\n        result.upToDateCount = modCounts.size() - invalidated;\r\n    }\r\n    result.cacheSize = size;\r\n    LOG.trace(\"invalidateCache: end. total: {}\", size);\r\n    return result;\r\n}","lc":1.1363636364,"pi":0.2775119617,"ma":0.4,"nbd":0.5,"ml":0.4166666667,"d":0.9087301587,"mi":-0.7460183228,"fo":1.6666666667,"r":-0.0263157895,"e":2.7752701371}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1025_a96b455c","label":1,"code":"\/*\r\n     * TODO consider making public.\r\n     *\/\r\nprivate void mapLog4jToJul(Level level, java.util.logging.Level julLevel) {\r\n    log4jToJul.put(level, julLevel);\r\n}","code_comment":null,"code_no_comment":"private void mapLog4jToJul(Level level, java.util.logging.Level julLevel) {\r\n    log4jToJul.put(level, julLevel);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9174066244,"fo":-0.4166666667,"r":2.2105263158,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3318_e12e2052","label":3,"code":"private static Iterable<String> getMixinTypeNames(Tree tree) {\r\n    PropertyState property = tree.getProperty(JcrConstants.JCR_MIMETYPE);\r\n    return property != null ? property.getValue(Type.NAMES) : Collections.<String>emptyList();\r\n}","code_comment":null,"code_no_comment":"private static Iterable<String> getMixinTypeNames(Tree tree) {\r\n    PropertyState property = tree.getProperty(JcrConstants.JCR_MIMETYPE);\r\n    return property != null ? property.getValue(Type.NAMES) : Collections.<String>emptyList();\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.119047619,"mi":0.6600422833,"fo":-0.25,"r":0.1315789474,"e":-0.1071512134}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2494_0dc92ca1","label":1,"code":"public long getSum() {\r\n    return sum;\r\n}","code_comment":null,"code_no_comment":"public long getSum() {\r\n    return sum;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.2407329105,"fo":-0.5,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"Cli","project_version":"1","label":1,"code":"\/**\r\n * Query to see if an option has been set.\r\n *\r\n * @param opt Short name of the option\r\n * @return true if set, false if not\r\n *\/\r\npublic boolean hasOption(String opt) {\r\n    return options.containsKey(opt);\r\n}","code_comment":"\/**\r\n * Query to see if an option has been set.\r\n *\r\n * @param opt Short name of the option\r\n * @return true if set, false if not\r\n *\/\r\n","code_no_comment":"public boolean hasOption(String opt) {\r\n    return options.containsKey(opt);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0451021846,"fo":-0.4166666667,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2021_004db804","label":1,"code":"\/**\r\n * Get the left-hand-side expression for equality conditions.\r\n * For example, for x=1, it is x. If it is not equality, return null.\r\n *\r\n * @return the left-hand-side expression, or null\r\n *\/\r\npublic String getCommonLeftPart() {\r\n    if (!\"=\".equals(operator)) {\r\n        return null;\r\n    }\r\n    return left.toString();\r\n}","code_comment":"\/**\r\n * Get the left-hand-side expression for equality conditions.\r\n * For example, for x=1, it is x. If it is not equality, return null.\r\n *\r\n * @return the left-hand-side expression, or null\r\n *\/\r\n","code_no_comment":"public String getCommonLeftPart() {\r\n    if (!\"=\".equals(operator)) {\r\n        return null;\r\n    }\r\n    return left.toString();\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.6329809725,"fo":-0.3333333333,"r":1.8421052632,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"@Override\r\npublic String toString() {\r\n    StringBuilder sb = new StringBuilder(\"update_result(\");\r\n    boolean first = true;\r\n    sb.append(\"ouch1:\");\r\n    if (this.ouch1 == null) {\r\n        sb.append(\"null\");\r\n    } else {\r\n        sb.append(this.ouch1);\r\n    }\r\n    first = false;\r\n    if (!first)\r\n        sb.append(\", \");\r\n    sb.append(\"ouch2:\");\r\n    if (this.ouch2 == null) {\r\n        sb.append(\"null\");\r\n    } else {\r\n        sb.append(this.ouch2);\r\n    }\r\n    first = false;\r\n    sb.append(\")\");\r\n    return sb.toString();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String toString() {\r\n    StringBuilder sb = new StringBuilder(\"update_result(\");\r\n    boolean first = true;\r\n    sb.append(\"ouch1:\");\r\n    if (this.ouch1 == null) {\r\n        sb.append(\"null\");\r\n    } else {\r\n        sb.append(this.ouch1);\r\n    }\r\n    first = false;\r\n    if (!first)\r\n        sb.append(\", \");\r\n    sb.append(\"ouch2:\");\r\n    if (this.ouch2 == null) {\r\n        sb.append(\"null\");\r\n    } else {\r\n        sb.append(this.ouch2);\r\n    }\r\n    first = false;\r\n    sb.append(\")\");\r\n    return sb.toString();\r\n}","lc":0.4090909091,"pi":-0.3157894737,"ma":0.0,"nbd":-0.5,"ml":0.0833333333,"d":0.130952381,"mi":-0.2763918252,"fo":0.25,"r":0.0,"e":0.1004569999}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-447_0343e9c7","label":1,"code":"\/**\r\n * Formats a {@link org.apache.logging.log4j.core.LogEvent} in conformance with the log4j.dtd.\r\n *\r\n * @param event The LogEvent.\r\n * @return The XML representation of the LogEvent.\r\n *\/\r\n@Override\r\npublic String toSerializable(final LogEvent event) {\r\n    final StringBuilder buf = new StringBuilder(DEFAULT_SIZE);\r\n    buf.append(this.indent1);\r\n    buf.append('<');\r\n    if (!complete) {\r\n        buf.append(this.namespacePrefix);\r\n    }\r\n    buf.append(\"Event logger=\\\"\");\r\n    String name = event.getLoggerName();\r\n    if (name.isEmpty()) {\r\n        name = \"root\";\r\n    }\r\n    buf.append(Transform.escapeHtmlTags(name));\r\n    buf.append(\"\\\" timestamp=\\\"\");\r\n    buf.append(event.getMillis());\r\n    buf.append(\"\\\" level=\\\"\");\r\n    buf.append(Transform.escapeHtmlTags(String.valueOf(event.getLevel())));\r\n    buf.append(\"\\\" thread=\\\"\");\r\n    buf.append(Transform.escapeHtmlTags(event.getThreadName()));\r\n    buf.append(\"\\\">\");\r\n    buf.append(this.eol);\r\n    final Message msg = event.getMessage();\r\n    if (msg != null) {\r\n        boolean xmlSupported = false;\r\n        if (msg instanceof MultiformatMessage) {\r\n            final String[] formats = ((MultiformatMessage) msg).getFormats();\r\n            for (final String format : formats) {\r\n                if (format.equalsIgnoreCase(\"XML\")) {\r\n                    xmlSupported = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        buf.append(this.indent2);\r\n        buf.append('<');\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"Message>\");\r\n        if (xmlSupported) {\r\n            buf.append(((MultiformatMessage) msg).getFormattedMessage(FORMATS));\r\n        } else {\r\n            buf.append(\"<![CDATA[\");\r\n            \/\/ Append the rendered message. Also make sure to escape any\r\n            \/\/ existing CDATA sections.\r\n            Transform.appendEscapingCDATA(buf, event.getMessage().getFormattedMessage());\r\n            buf.append(\"]]>\");\r\n        }\r\n        buf.append(\"<\/\");\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"Message>\");\r\n        buf.append(this.eol);\r\n    }\r\n    if (event.getContextStack().getDepth() > 0) {\r\n        buf.append(this.indent2);\r\n        buf.append('<');\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"NDC><![CDATA[\");\r\n        Transform.appendEscapingCDATA(buf, event.getContextStack().toString());\r\n        buf.append(\"]]><\/\");\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"NDC>\");\r\n        buf.append(this.eol);\r\n    }\r\n    final Throwable throwable = event.getThrown();\r\n    if (throwable != null) {\r\n        final List<String> s = Throwables.toStringList(throwable);\r\n        buf.append(this.indent2);\r\n        buf.append('<');\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"Throwable><![CDATA[\");\r\n        for (final String str : s) {\r\n            Transform.appendEscapingCDATA(buf, str);\r\n            buf.append(this.eol);\r\n        }\r\n        buf.append(\"]]><\/\");\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"Throwable>\");\r\n        buf.append(this.eol);\r\n    }\r\n    if (locationInfo) {\r\n        final StackTraceElement element = event.getSource();\r\n        buf.append(this.indent2);\r\n        buf.append('<');\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"LocationInfo class=\\\"\");\r\n        buf.append(Transform.escapeHtmlTags(element.getClassName()));\r\n        buf.append(\"\\\" method=\\\"\");\r\n        buf.append(Transform.escapeHtmlTags(element.getMethodName()));\r\n        buf.append(\"\\\" file=\\\"\");\r\n        buf.append(Transform.escapeHtmlTags(element.getFileName()));\r\n        buf.append(\"\\\" line=\\\"\");\r\n        buf.append(element.getLineNumber());\r\n        buf.append(\"\\\"\/>\");\r\n        buf.append(this.eol);\r\n    }\r\n    if (properties && event.getContextMap().size() > 0) {\r\n        buf.append(this.indent2);\r\n        buf.append('<');\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"Properties>\");\r\n        buf.append(this.eol);\r\n        for (final Map.Entry<String, String> entry : event.getContextMap().entrySet()) {\r\n            buf.append(this.indent3);\r\n            buf.append('<');\r\n            if (!complete) {\r\n                buf.append(this.namespacePrefix);\r\n            }\r\n            buf.append(\"Data name=\\\"\");\r\n            buf.append(Transform.escapeHtmlTags(entry.getKey()));\r\n            buf.append(\"\\\" value=\\\"\");\r\n            buf.append(Transform.escapeHtmlTags(String.valueOf(entry.getValue())));\r\n            buf.append(\"\\\"\/>\");\r\n            buf.append(this.eol);\r\n        }\r\n        buf.append(this.indent2);\r\n        buf.append(\"<\/\");\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"Properties>\");\r\n        buf.append(this.eol);\r\n    }\r\n    buf.append(this.indent1);\r\n    buf.append(\"<\/\");\r\n    if (!complete) {\r\n        buf.append(this.namespacePrefix);\r\n    }\r\n    buf.append(\"Event>\");\r\n    buf.append(this.eol);\r\n    return buf.toString();\r\n}","code_comment":"\/**\r\n * Formats a {@link org.apache.logging.log4j.core.LogEvent} in conformance with the log4j.dtd.\r\n *\r\n * @param event The LogEvent.\r\n * @return The XML representation of the LogEvent.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic String toSerializable(final LogEvent event) {\r\n    final StringBuilder buf = new StringBuilder(DEFAULT_SIZE);\r\n    buf.append(this.indent1);\r\n    buf.append('<');\r\n    if (!complete) {\r\n        buf.append(this.namespacePrefix);\r\n    }\r\n    buf.append(\"Event logger=\\\"\");\r\n    String name = event.getLoggerName();\r\n    if (name.isEmpty()) {\r\n        name = \"root\";\r\n    }\r\n    buf.append(Transform.escapeHtmlTags(name));\r\n    buf.append(\"\\\" timestamp=\\\"\");\r\n    buf.append(event.getMillis());\r\n    buf.append(\"\\\" level=\\\"\");\r\n    buf.append(Transform.escapeHtmlTags(String.valueOf(event.getLevel())));\r\n    buf.append(\"\\\" thread=\\\"\");\r\n    buf.append(Transform.escapeHtmlTags(event.getThreadName()));\r\n    buf.append(\"\\\">\");\r\n    buf.append(this.eol);\r\n    final Message msg = event.getMessage();\r\n    if (msg != null) {\r\n        boolean xmlSupported = false;\r\n        if (msg instanceof MultiformatMessage) {\r\n            final String[] formats = ((MultiformatMessage) msg).getFormats();\r\n            for (final String format : formats) {\r\n                if (format.equalsIgnoreCase(\"XML\")) {\r\n                    xmlSupported = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        buf.append(this.indent2);\r\n        buf.append('<');\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"Message>\");\r\n        if (xmlSupported) {\r\n            buf.append(((MultiformatMessage) msg).getFormattedMessage(FORMATS));\r\n        } else {\r\n            buf.append(\"<![CDATA[\");\r\n                                    Transform.appendEscapingCDATA(buf, event.getMessage().getFormattedMessage());\r\n            buf.append(\"]]>\");\r\n        }\r\n        buf.append(\"<\/\");\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"Message>\");\r\n        buf.append(this.eol);\r\n    }\r\n    if (event.getContextStack().getDepth() > 0) {\r\n        buf.append(this.indent2);\r\n        buf.append('<');\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"NDC><![CDATA[\");\r\n        Transform.appendEscapingCDATA(buf, event.getContextStack().toString());\r\n        buf.append(\"]]><\/\");\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"NDC>\");\r\n        buf.append(this.eol);\r\n    }\r\n    final Throwable throwable = event.getThrown();\r\n    if (throwable != null) {\r\n        final List<String> s = Throwables.toStringList(throwable);\r\n        buf.append(this.indent2);\r\n        buf.append('<');\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"Throwable><![CDATA[\");\r\n        for (final String str : s) {\r\n            Transform.appendEscapingCDATA(buf, str);\r\n            buf.append(this.eol);\r\n        }\r\n        buf.append(\"]]><\/\");\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"Throwable>\");\r\n        buf.append(this.eol);\r\n    }\r\n    if (locationInfo) {\r\n        final StackTraceElement element = event.getSource();\r\n        buf.append(this.indent2);\r\n        buf.append('<');\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"LocationInfo class=\\\"\");\r\n        buf.append(Transform.escapeHtmlTags(element.getClassName()));\r\n        buf.append(\"\\\" method=\\\"\");\r\n        buf.append(Transform.escapeHtmlTags(element.getMethodName()));\r\n        buf.append(\"\\\" file=\\\"\");\r\n        buf.append(Transform.escapeHtmlTags(element.getFileName()));\r\n        buf.append(\"\\\" line=\\\"\");\r\n        buf.append(element.getLineNumber());\r\n        buf.append(\"\\\"\/>\");\r\n        buf.append(this.eol);\r\n    }\r\n    if (properties && event.getContextMap().size() > 0) {\r\n        buf.append(this.indent2);\r\n        buf.append('<');\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"Properties>\");\r\n        buf.append(this.eol);\r\n        for (final Map.Entry<String, String> entry : event.getContextMap().entrySet()) {\r\n            buf.append(this.indent3);\r\n            buf.append('<');\r\n            if (!complete) {\r\n                buf.append(this.namespacePrefix);\r\n            }\r\n            buf.append(\"Data name=\\\"\");\r\n            buf.append(Transform.escapeHtmlTags(entry.getKey()));\r\n            buf.append(\"\\\" value=\\\"\");\r\n            buf.append(Transform.escapeHtmlTags(String.valueOf(entry.getValue())));\r\n            buf.append(\"\\\"\/>\");\r\n            buf.append(this.eol);\r\n        }\r\n        buf.append(this.indent2);\r\n        buf.append(\"<\/\");\r\n        if (!complete) {\r\n            buf.append(this.namespacePrefix);\r\n        }\r\n        buf.append(\"Properties>\");\r\n        buf.append(this.eol);\r\n    }\r\n    buf.append(this.indent1);\r\n    buf.append(\"<\/\");\r\n    if (!complete) {\r\n        buf.append(this.namespacePrefix);\r\n    }\r\n    buf.append(\"Event>\");\r\n    buf.append(this.eol);\r\n    return buf.toString();\r\n}","lc":5.9545454545,"pi":0.2153110048,"ma":4.4,"nbd":1.0,"ml":2.25,"d":1.2003968254,"mi":-1.6201550388,"fo":9.5,"r":-0.0263157895,"e":9.558338664}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4105_64656c98","label":1,"code":"@Override\r\npublic void detach(Component component) {\r\n    webResponse = null;\r\n    super.detach(component);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void detach(Component component) {\r\n    webResponse = null;\r\n    super.detach(component);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7375616631,"fo":-0.4166666667,"r":1.8684210526,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"\/**\r\n * Update the child order with children that have been removed or added.\r\n * Added children are appended to the end of the {@link #OAK_CHILD_ORDER}\r\n * property.\r\n *\/\r\nvoid updateChildOrder() {\r\n    if (!hasOrderableChildren()) {\r\n        return;\r\n    }\r\n    Set<String> names = Sets.newLinkedHashSet();\r\n    for (String name : getOrderedChildNames()) {\r\n        if (getNodeBuilder().hasChildNode(name)) {\r\n            names.add(name);\r\n        }\r\n    }\r\n    for (String name : getNodeBuilder().getChildNodeNames()) {\r\n        names.add(name);\r\n    }\r\n    PropertyBuilder<String> builder = MemoryPropertyBuilder.array(Type.STRING, OAK_CHILD_ORDER);\r\n    builder.setValues(names);\r\n    getNodeBuilder().setProperty(builder.getPropertyState());\r\n}","code_comment":"\/**\r\n * Update the child order with children that have been removed or added.\r\n * Added children are appended to the end of the {@link #OAK_CHILD_ORDER}\r\n * property.\r\n *\/\r\n","code_no_comment":"void updateChildOrder() {\r\n    if (!hasOrderableChildren()) {\r\n        return;\r\n    }\r\n    Set<String> names = Sets.newLinkedHashSet();\r\n    for (String name : getOrderedChildNames()) {\r\n        if (getNodeBuilder().hasChildNode(name)) {\r\n            names.add(name);\r\n        }\r\n    }\r\n    for (String name : getNodeBuilder().getChildNodeNames()) {\r\n        names.add(name);\r\n    }\r\n    PropertyBuilder<String> builder = MemoryPropertyBuilder.array(Type.STRING, OAK_CHILD_ORDER);\r\n    builder.setValues(names);\r\n    getNodeBuilder().setProperty(builder.getPropertyState());\r\n}","lc":0.1363636364,"pi":-0.033492823,"ma":0.2,"nbd":0.0,"ml":0.0,"d":-0.0436507937,"mi":-0.1233262861,"fo":0.6666666667,"r":0.0526315789,"e":-0.0148890925}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1930_4dbf030a","label":1,"code":"private Buffer requestBuffer(boolean isBlocking) throws InterruptedException, IOException {\r\n    synchronized (availableMemorySegments) {\r\n        returnExcessMemorySegments();\r\n        boolean askToRecycle = owner != null;\r\n        while (availableMemorySegments.isEmpty()) {\r\n            if (isDestroyed) {\r\n                return null;\r\n            }\r\n            if (numberOfRequestedMemorySegments < currentPoolSize) {\r\n                final MemorySegment segment = networkBufferPool.requestMemorySegment();\r\n                if (segment != null) {\r\n                    numberOfRequestedMemorySegments++;\r\n                    availableMemorySegments.add(segment);\r\n                    continue;\r\n                }\r\n            }\r\n            if (askToRecycle) {\r\n                owner.releaseMemory(1);\r\n            }\r\n            if (isBlocking) {\r\n                availableMemorySegments.wait(2000);\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        return new Buffer(availableMemorySegments.poll(), this);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private Buffer requestBuffer(boolean isBlocking) throws InterruptedException, IOException {\r\n    synchronized (availableMemorySegments) {\r\n        returnExcessMemorySegments();\r\n        boolean askToRecycle = owner != null;\r\n        while (availableMemorySegments.isEmpty()) {\r\n            if (isDestroyed) {\r\n                return null;\r\n            }\r\n            if (numberOfRequestedMemorySegments < currentPoolSize) {\r\n                final MemorySegment segment = networkBufferPool.requestMemorySegment();\r\n                if (segment != null) {\r\n                    numberOfRequestedMemorySegments++;\r\n                    availableMemorySegments.add(segment);\r\n                    continue;\r\n                }\r\n            }\r\n            if (askToRecycle) {\r\n                owner.releaseMemory(1);\r\n            }\r\n            if (isBlocking) {\r\n                availableMemorySegments.wait(2000);\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        return new Buffer(availableMemorySegments.poll(), this);\r\n    }\r\n}","lc":0.6363636364,"pi":1.1244019139,"ma":0.8,"nbd":1.0,"ml":0.6666666667,"d":0.253968254,"mi":-0.385764623,"fo":0.0833333333,"r":-0.0263157895,"e":0.1516594342}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2249_6dde8e9d","label":1,"code":"private static void addToUnionList(Expression condition, ArrayList<Expression> unionList) {\r\n    if (condition.containsFullTextCondition()) {\r\n    \/\/ do not use union\r\n    } else if (condition instanceof OrCondition) {\r\n        OrCondition or = (OrCondition) condition;\r\n        \/\/ conditions of type\r\n        \/\/ @x = 1 or @y = 2\r\n        \/\/ or similar are converted to\r\n        \/\/ (@x = 1) union (@y = 2)\r\n        addToUnionList(or.left, unionList);\r\n        addToUnionList(or.right, unionList);\r\n        return;\r\n    } else if (condition instanceof AndCondition) {\r\n        \/\/ conditions of type\r\n        \/\/ @a = 1 and (@x = 1 or @y = 2)\r\n        \/\/ are automatically converted to\r\n        \/\/ (@a = 1 and @x = 1) union (@a = 1 and @y = 2)\r\n        AndCondition and = (AndCondition) condition;\r\n        and = and.pullOrRight();\r\n        if (and.right instanceof OrCondition) {\r\n            OrCondition or = (OrCondition) and.right;\r\n            \/\/ same as above, but with the added \"and\"\r\n            addToUnionList(new AndCondition(and.left, or.left), unionList);\r\n            addToUnionList(new AndCondition(and.left, or.right), unionList);\r\n            return;\r\n        }\r\n    }\r\n    unionList.add(condition);\r\n}","code_comment":null,"code_no_comment":"private static void addToUnionList(Expression condition, ArrayList<Expression> unionList) {\r\n    if (condition.containsFullTextCondition()) {\r\n        } else if (condition instanceof OrCondition) {\r\n        OrCondition or = (OrCondition) condition;\r\n                                        addToUnionList(or.left, unionList);\r\n        addToUnionList(or.right, unionList);\r\n        return;\r\n    } else if (condition instanceof AndCondition) {\r\n                                        AndCondition and = (AndCondition) condition;\r\n        and = and.pullOrRight();\r\n        if (and.right instanceof OrCondition) {\r\n            OrCondition or = (OrCondition) and.right;\r\n                        addToUnionList(new AndCondition(and.left, or.left), unionList);\r\n            addToUnionList(new AndCondition(and.left, or.right), unionList);\r\n            return;\r\n        }\r\n    }\r\n    unionList.add(condition);\r\n}","lc":0.2272727273,"pi":0.3062200957,"ma":0.2,"nbd":1.0,"ml":0.1666666667,"d":-0.3650793651,"mi":-0.2053558844,"fo":0.0833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1270_70564c7c","label":1,"code":"static Query tokenToQuery(String text, Analyzer analyzer) {\r\n    if (analyzer == null) {\r\n        return null;\r\n    }\r\n    List<String> tokens = new ArrayList<String>();\r\n    tokens = tokenize(text, analyzer);\r\n    if (tokens.isEmpty()) {\r\n        \/\/ TODO what should be returned in the case there are no tokens?\r\n        return new BooleanQuery();\r\n    }\r\n    if (tokens.size() == 1) {\r\n        text = tokens.iterator().next();\r\n        boolean hasFulltextToken = false;\r\n        for (char c : fulltextTokens) {\r\n            if (text.indexOf(c) != -1) {\r\n                hasFulltextToken = true;\r\n                break;\r\n            }\r\n        }\r\n        if (hasFulltextToken) {\r\n            return new WildcardQuery(newFulltextTerm(text));\r\n        } else {\r\n            return new TermQuery(newFulltextTerm(text));\r\n        }\r\n    } else {\r\n        PhraseQuery pq = new PhraseQuery();\r\n        for (String t : tokens) {\r\n            pq.add(newFulltextTerm(t));\r\n        }\r\n        return pq;\r\n    }\r\n}","code_comment":null,"code_no_comment":"static Query tokenToQuery(String text, Analyzer analyzer) {\r\n    if (analyzer == null) {\r\n        return null;\r\n    }\r\n    List<String> tokens = new ArrayList<String>();\r\n    tokens = tokenize(text, analyzer);\r\n    if (tokens.isEmpty()) {\r\n                return new BooleanQuery();\r\n    }\r\n    if (tokens.size() == 1) {\r\n        text = tokens.iterator().next();\r\n        boolean hasFulltextToken = false;\r\n        for (char c : fulltextTokens) {\r\n            if (text.indexOf(c) != -1) {\r\n                hasFulltextToken = true;\r\n                break;\r\n            }\r\n        }\r\n        if (hasFulltextToken) {\r\n            return new WildcardQuery(newFulltextTerm(text));\r\n        } else {\r\n            return new TermQuery(newFulltextTerm(text));\r\n        }\r\n    } else {\r\n        PhraseQuery pq = new PhraseQuery();\r\n        for (String t : tokens) {\r\n            pq.add(newFulltextTerm(t));\r\n        }\r\n        return pq;\r\n    }\r\n}","lc":0.7727272727,"pi":0.4354066986,"ma":1.0,"nbd":0.5,"ml":0.5,"d":0.3650793651,"mi":-0.5050035236,"fo":0.3333333333,"r":-0.0263157895,"e":0.4198567337}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3433_b76b31f7","label":0,"code":"@Override\r\npublic void acquiring() {\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void acquiring() {\r\n}","lc":-0.5,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.2407329105,"fo":-0.5,"r":2.1842105263,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2734_8b40bb7a","label":0,"code":"@Override\r\npublic Tuple getKey(IN value) throws Exception {\r\n    key = (Tuple) tupleClasses[fields.length - 1].newInstance();\r\n    for (int i = 0; i < fields.length; i++) {\r\n        int pos = fields[i];\r\n        key.setField(Array.get(value, fields[pos]), i);\r\n    }\r\n    return key;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Tuple getKey(IN value) throws Exception {\r\n    key = (Tuple) tupleClasses[fields.length - 1].newInstance();\r\n    for (int i = 0; i < fields.length; i++) {\r\n        int pos = fields[i];\r\n        key.setField(Array.get(value, fields[pos]), i);\r\n    }\r\n    return key;\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":0.3035714286,"mi":0.2067653277,"fo":-0.25,"r":0.0526315789,"e":0.1041544925}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * This function allows you to control the number of elements contained\r\n * in this array, and can be used to \"throw out\" the last n values in an\r\n * array. This function will also expand the internal array as needed.\r\n *\r\n * @param i a new number of elements\r\n * @throws MathIllegalArgumentException if <code>i<\/code> is negative.\r\n *\/\r\npublic synchronized void setNumElements(int i) throws MathIllegalArgumentException {\r\n    \/\/ If index is negative thrown an error.\r\n    if (i < 0) {\r\n        throw new MathIllegalArgumentException(LocalizedFormats.INDEX_NOT_POSITIVE, i);\r\n    }\r\n    \/\/ Test the new num elements, check to see if the array needs to be\r\n    \/\/ expanded to accommodate this new number of elements.\r\n    final int newSize = startIndex + i;\r\n    if (newSize > internalArray.length) {\r\n        expandTo(newSize);\r\n    }\r\n    \/\/ Set the new number of elements to new value.\r\n    numElements = i;\r\n}","code_comment":"\/**\r\n * This function allows you to control the number of elements contained\r\n * in this array, and can be used to \"throw out\" the last n values in an\r\n * array. This function will also expand the internal array as needed.\r\n *\r\n * @param i a new number of elements\r\n * @throws MathIllegalArgumentException if <code>i<\/code> is negative.\r\n *\/\r\n","code_no_comment":"public synchronized void setNumElements(int i) throws MathIllegalArgumentException {\r\n        if (i < 0) {\r\n        throw new MathIllegalArgumentException(LocalizedFormats.INDEX_NOT_POSITIVE, i);\r\n    }\r\n            final int newSize = startIndex + i;\r\n    if (newSize > internalArray.length) {\r\n        expandTo(newSize);\r\n    }\r\n        numElements = i;\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":0.0,"nbd":-0.5,"ml":0.0,"d":0.246031746,"mi":0.221987315,"fo":-0.4166666667,"r":0.4473684211,"e":-0.0178350997}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1312_d9ab8449","label":1,"code":"@Override\r\npublic Connector getConnector(String principal, AuthenticationToken token) throws AccumuloException, AccumuloSecurityException {\r\n    Connector conn = new MockConnector(principal, acu, this);\r\n    if (!acu.users.containsKey(principal))\r\n        conn.securityOperations().createLocalUser(principal, (PasswordToken) token);\r\n    else if (!acu.users.get(principal).token.equals(token))\r\n        throw new AccumuloSecurityException(principal, SecurityErrorCode.BAD_CREDENTIALS);\r\n    return conn;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Connector getConnector(String principal, AuthenticationToken token) throws AccumuloException, AccumuloSecurityException {\r\n    Connector conn = new MockConnector(principal, acu, this);\r\n    if (!acu.users.containsKey(principal))\r\n        conn.securityOperations().createLocalUser(principal, (PasswordToken) token);\r\n    else if (!acu.users.get(principal).token.equals(token))\r\n        throw new AccumuloSecurityException(principal, SecurityErrorCode.BAD_CREDENTIALS);\r\n    return conn;\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":0.0,"nbd":-1.0,"ml":0.0833333333,"d":-0.0317460317,"mi":0.1842142354,"fo":-0.0833333333,"r":-0.0263157895,"e":-0.0205920829}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-880_2a9cbbab","label":1,"code":"\/**\r\n * Mark the incoming edge as processed.\r\n *\/\r\npublic void incomingProcessed() {\r\n    incomingNeedsProcessing = false;\r\n}","code_comment":"\/**\r\n * Mark the incoming edge as processed.\r\n *\/\r\n","code_no_comment":"public void incomingProcessed() {\r\n    incomingNeedsProcessing = false;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"Compress","project_version":"28","label":1,"code":"\/**\r\n * Reads bytes from the current tar archive entry.\r\n *\r\n * This method is aware of the boundaries of the current\r\n * entry in the archive and will deal with them as if they\r\n * were this stream's start and EOF.\r\n *\r\n * @param buf The buffer into which to place bytes read.\r\n * @param offset The offset at which to place bytes read.\r\n * @param numToRead The number of bytes to read.\r\n * @return The number of bytes read, or -1 at EOF.\r\n * @throws IOException on error\r\n *\/\r\n@Override\r\npublic int read(byte[] buf, int offset, int numToRead) throws IOException {\r\n    int totalRead = 0;\r\n    if (hasHitEOF || entryOffset >= entrySize) {\r\n        return -1;\r\n    }\r\n    if (currEntry == null) {\r\n        throw new IllegalStateException(\"No current tar entry\");\r\n    }\r\n    numToRead = Math.min(numToRead, available());\r\n    totalRead = is.read(buf, offset, numToRead);\r\n    count(totalRead);\r\n    if (totalRead == -1) {\r\n        hasHitEOF = true;\r\n    } else {\r\n        entryOffset += totalRead;\r\n    }\r\n    return totalRead;\r\n}","code_comment":"\/**\r\n * Reads bytes from the current tar archive entry.\r\n *\r\n * This method is aware of the boundaries of the current\r\n * entry in the archive and will deal with them as if they\r\n * were this stream's start and EOF.\r\n *\r\n * @param buf The buffer into which to place bytes read.\r\n * @param offset The offset at which to place bytes read.\r\n * @param numToRead The number of bytes to read.\r\n * @return The number of bytes read, or -1 at EOF.\r\n * @throws IOException on error\r\n *\/\r\n","code_no_comment":"@Override\r\npublic int read(byte[] buf, int offset, int numToRead) throws IOException {\r\n    int totalRead = 0;\r\n    if (hasHitEOF || entryOffset >= entrySize) {\r\n        return -1;\r\n    }\r\n    if (currEntry == null) {\r\n        throw new IllegalStateException(\"No current tar entry\");\r\n    }\r\n    numToRead = Math.min(numToRead, available());\r\n    totalRead = is.read(buf, offset, numToRead);\r\n    count(totalRead);\r\n    if (totalRead == -1) {\r\n        hasHitEOF = true;\r\n    } else {\r\n        entryOffset += totalRead;\r\n    }\r\n    return totalRead;\r\n}","lc":0.2272727273,"pi":-0.2727272727,"ma":0.2,"nbd":-0.5,"ml":0.3333333333,"d":0.5932539683,"mi":-0.1985905567,"fo":-0.1666666667,"r":0.2894736842,"e":0.3560357993}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-413_51aa6e6c","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goalType, final double min, final double max, final double startValue) throws FunctionEvaluationException {\r\n    \/\/ XXX This method should set \"startValue\" to min + 0.5 * (max - min)\r\n    return optimize(f, goalType, min, max);\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goalType, final double min, final double max, final double startValue) throws FunctionEvaluationException {\r\n        return optimize(f, goalType, min, max);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.881042988,"fo":-0.4166666667,"r":1.2105263158,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1061_86d8944f","label":1,"code":"@Override\r\npublic boolean remove(final Marker marker) {\r\n    return this.marker.remove(MarkerManager.getMarker(marker.getName()));\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean remove(final Marker marker) {\r\n    return this.marker.remove(MarkerManager.getMarker(marker.getName()));\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8255109232,"fo":-0.25,"r":0.2105263158,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  @return Returns feedback messages from all components in this page\r\n *          (including the page itself).\r\n *\/\r\npublic final FeedbackMessages getFeedbackMessages() {\r\n    if (feedbackMessages == null) {\r\n        feedbackMessages = new FeedbackMessages();\r\n    }\r\n    return feedbackMessages;\r\n}","code_comment":"\/**\r\n *  @return Returns feedback messages from all components in this page\r\n *          (including the page itself).\r\n *\/\r\n","code_no_comment":"public final FeedbackMessages getFeedbackMessages() {\r\n    if (feedbackMessages == null) {\r\n        feedbackMessages = new FeedbackMessages();\r\n    }\r\n    return feedbackMessages;\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0476190476,"mi":0.6575052854,"fo":-0.5,"r":2.5263157895,"e":-0.1420837583}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-428_4a6a573b","label":3,"code":"public Iterator iterator() {\r\n    return new Iterator() {\r\n\r\n        public boolean hasNext() {\r\n            return i < size;\r\n        }\r\n\r\n        public Object next() {\r\n            \/\/ Find next key\r\n            i = nextKey(nextIndex(i));\r\n            \/\/ Just in case... (WICKET-428)\r\n            if (!hasNext()) {\r\n                throw new NoSuchElementException();\r\n            }\r\n            \/\/ Get key\r\n            return keys[i];\r\n        }\r\n\r\n        public void remove() {\r\n            keys[i] = null;\r\n            values[i] = null;\r\n            size--;\r\n        }\r\n\r\n        int i = -1;\r\n    };\r\n}","code_comment":null,"code_no_comment":"public Iterator iterator() {\r\n    return new Iterator() {\r\n\r\n        public boolean hasNext() {\r\n            return i < size;\r\n        }\r\n\r\n        public Object next() {\r\n                        i = nextKey(nextIndex(i));\r\n                        if (!hasNext()) {\r\n                throw new NoSuchElementException();\r\n            }\r\n                        return keys[i];\r\n        }\r\n\r\n        public void remove() {\r\n            keys[i] = null;\r\n            values[i] = null;\r\n            size--;\r\n        }\r\n\r\n        int i = -1;\r\n    };\r\n}","lc":0.2727272727,"pi":0.5406698565,"ma":-0.2,"nbd":0.0,"ml":-0.25,"d":0.3055555556,"mi":-0.147850599,"fo":-0.25,"r":2.3947368421,"e":0.0764094673}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-359_296ea4a5","label":1,"code":"@Override\r\npublic void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {\r\n    if (servletContext.getMajorVersion() > 2) {\r\n        servletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\");\r\n        final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);\r\n        initializer.initialize();\r\n        \/\/ the application is just now starting to start up\r\n        initializer.setLoggerContext();\r\n        servletContext.addListener(new Log4jServletContextListener());\r\n        final FilterRegistration.Dynamic filter = servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\r\n        if (filter == null) {\r\n            throw new UnavailableException(\"In a Servlet 3.0+ application, you must not define a \" + \"log4jServletFilter in web.xml. Log4j 2 defines this for you automatically.\");\r\n        }\r\n        filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, \"\/*\");\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {\r\n    if (servletContext.getMajorVersion() > 2) {\r\n        servletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\");\r\n        final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);\r\n        initializer.initialize();\r\n                initializer.setLoggerContext();\r\n        servletContext.addListener(new Log4jServletContextListener());\r\n        final FilterRegistration.Dynamic filter = servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\r\n        if (filter == null) {\r\n            throw new UnavailableException(\"In a Servlet 3.0+ application, you must not define a \" + \"log4jServletFilter in web.xml. Log4j 2 defines this for you automatically.\");\r\n        }\r\n        filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, \"\/*\");\r\n    }\r\n}","lc":0.0454545455,"pi":0.2631578947,"ma":0.0,"nbd":0.0,"ml":-0.0833333333,"d":0.128968254,"mi":-0.1072586328,"fo":0.25,"r":-0.0263157895,"e":0.1504330838}
{"project_name":"Compress","project_version":"22","label":3,"code":"private int read0() throws IOException {\r\n    final int retChar = this.currentChar;\r\n    switch(currentState) {\r\n        case EOF:\r\n            return -1;\r\n        case START_BLOCK_STATE:\r\n            throw new IllegalStateException();\r\n        case RAND_PART_A_STATE:\r\n            throw new IllegalStateException();\r\n        case RAND_PART_B_STATE:\r\n            setupRandPartB();\r\n            break;\r\n        case RAND_PART_C_STATE:\r\n            setupRandPartC();\r\n            break;\r\n        case NO_RAND_PART_A_STATE:\r\n            throw new IllegalStateException();\r\n        case NO_RAND_PART_B_STATE:\r\n            setupNoRandPartB();\r\n            break;\r\n        case NO_RAND_PART_C_STATE:\r\n            setupNoRandPartC();\r\n            break;\r\n        default:\r\n            throw new IllegalStateException();\r\n    }\r\n    return retChar;\r\n}","code_comment":null,"code_no_comment":"private int read0() throws IOException {\r\n    final int retChar = this.currentChar;\r\n    switch(currentState) {\r\n        case EOF:\r\n            return -1;\r\n        case START_BLOCK_STATE:\r\n            throw new IllegalStateException();\r\n        case RAND_PART_A_STATE:\r\n            throw new IllegalStateException();\r\n        case RAND_PART_B_STATE:\r\n            setupRandPartB();\r\n            break;\r\n        case RAND_PART_C_STATE:\r\n            setupRandPartC();\r\n            break;\r\n        case NO_RAND_PART_A_STATE:\r\n            throw new IllegalStateException();\r\n        case NO_RAND_PART_B_STATE:\r\n            setupNoRandPartB();\r\n            break;\r\n        case NO_RAND_PART_C_STATE:\r\n            setupNoRandPartC();\r\n            break;\r\n        default:\r\n            throw new IllegalStateException();\r\n    }\r\n    return retChar;\r\n}","lc":0.6363636364,"pi":0.3444976077,"ma":2.8,"nbd":0.0,"ml":0.3333333333,"d":-0.126984127,"mi":-0.3575757576,"fo":-0.1666666667,"r":0.0526315789,"e":-0.0986497467}
{"project_name":"Cli","project_version":"39","label":3,"code":"\/**\r\n * Returns the <code>Object<\/code> of type <code>clazz<\/code>\r\n * with the value of <code>str<\/code>.\r\n *\r\n * @param str the command line value\r\n * @param clazz the type of argument\r\n * @return The instance of <code>clazz<\/code> initialised with\r\n * the value of <code>str<\/code>.\r\n * @throws ParseException if the value creation for the given class failed\r\n *\/\r\npublic static Object createValue(final String str, final Class<?> clazz) throws ParseException {\r\n    if (PatternOptionBuilder.STRING_VALUE == clazz) {\r\n        return str;\r\n    } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) {\r\n        return createObject(str);\r\n    } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) {\r\n        return createNumber(str);\r\n    } else if (PatternOptionBuilder.DATE_VALUE == clazz) {\r\n        return createDate(str);\r\n    } else if (PatternOptionBuilder.CLASS_VALUE == clazz) {\r\n        return createClass(str);\r\n    } else if (PatternOptionBuilder.FILE_VALUE == clazz) {\r\n        return createFile(str);\r\n    } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) {\r\n        return createFile(str);\r\n    } else if (PatternOptionBuilder.FILES_VALUE == clazz) {\r\n        return createFiles(str);\r\n    } else if (PatternOptionBuilder.URL_VALUE == clazz) {\r\n        return createURL(str);\r\n    } else {\r\n        return null;\r\n    }\r\n}","code_comment":"\/**\r\n * Returns the <code>Object<\/code> of type <code>clazz<\/code>\r\n * with the value of <code>str<\/code>.\r\n *\r\n * @param str the command line value\r\n * @param clazz the type of argument\r\n * @return The instance of <code>clazz<\/code> initialised with\r\n * the value of <code>str<\/code>.\r\n * @throws ParseException if the value creation for the given class failed\r\n *\/\r\n","code_no_comment":"public static Object createValue(final String str, final Class<?> clazz) throws ParseException {\r\n    if (PatternOptionBuilder.STRING_VALUE == clazz) {\r\n        return str;\r\n    } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) {\r\n        return createObject(str);\r\n    } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) {\r\n        return createNumber(str);\r\n    } else if (PatternOptionBuilder.DATE_VALUE == clazz) {\r\n        return createDate(str);\r\n    } else if (PatternOptionBuilder.CLASS_VALUE == clazz) {\r\n        return createClass(str);\r\n    } else if (PatternOptionBuilder.FILE_VALUE == clazz) {\r\n        return createFile(str);\r\n    } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) {\r\n        return createFile(str);\r\n    } else if (PatternOptionBuilder.FILES_VALUE == clazz) {\r\n        return createFiles(str);\r\n    } else if (PatternOptionBuilder.URL_VALUE == clazz) {\r\n        return createURL(str);\r\n    } else {\r\n        return null;\r\n    }\r\n}","lc":0.4090909091,"pi":-0.2200956938,"ma":1.2,"nbd":3.5,"ml":0.4166666667,"d":-0.3650793651,"mi":-0.3525017618,"fo":0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4988_a4a3a9a6","label":1,"code":"\/**\r\n *  Parses a value as a String and returns a Number.\r\n *\r\n *  @param value\r\n *             The object to parse (after converting with toString())\r\n *  @param min\r\n *             The minimum allowed value\r\n *  @param max\r\n *             The maximum allowed value\r\n *  @param locale\r\n *  @return The number\r\n *  @throws ConversionException\r\n *              if value is unparsable or out of range\r\n *\/\r\nprotected N parse(Object value, final double min, final double max, Locale locale) {\r\n    if (locale == null) {\r\n        locale = Locale.getDefault();\r\n    }\r\n    if (value == null) {\r\n        return null;\r\n    } else if (value instanceof String) {\r\n        \/\/ Convert spaces to no-break space (U+00A0) to fix problems with\r\n        \/\/ browser conversions.\r\n        \/\/ Space is not valid thousands-separator, but no-br space is.\r\n        value = ((String) value).replace(' ', '\\u00A0');\r\n    }\r\n    final NumberFormat numberFormat = getNumberFormat(locale);\r\n    final N number = parse(numberFormat, value, locale);\r\n    if (number == null) {\r\n        return null;\r\n    }\r\n    if (number.doubleValue() < min) {\r\n        throw newConversionException(\"Value cannot be less than \" + min, value, locale).setFormat(numberFormat);\r\n    }\r\n    if (number.doubleValue() > max) {\r\n        throw newConversionException(\"Value cannot be greater than \" + max, value, locale).setFormat(numberFormat);\r\n    }\r\n    return number;\r\n}","code_comment":"\/**\r\n *  Parses a value as a String and returns a Number.\r\n *\r\n *  @param value\r\n *             The object to parse (after converting with toString())\r\n *  @param min\r\n *             The minimum allowed value\r\n *  @param max\r\n *             The maximum allowed value\r\n *  @param locale\r\n *  @return The number\r\n *  @throws ConversionException\r\n *              if value is unparsable or out of range\r\n *\/\r\n","code_no_comment":"protected N parse(Object value, final double min, final double max, Locale locale) {\r\n    if (locale == null) {\r\n        locale = Locale.getDefault();\r\n    }\r\n    if (value == null) {\r\n        return null;\r\n    } else if (value instanceof String) {\r\n                                value = ((String) value).replace(' ', '\\u00A0');\r\n    }\r\n    final NumberFormat numberFormat = getNumberFormat(locale);\r\n    final N number = parse(numberFormat, value, locale);\r\n    if (number == null) {\r\n        return null;\r\n    }\r\n    if (number.doubleValue() < min) {\r\n        throw newConversionException(\"Value cannot be less than \" + min, value, locale).setFormat(numberFormat);\r\n    }\r\n    if (number.doubleValue() > max) {\r\n        throw newConversionException(\"Value cannot be greater than \" + max, value, locale).setFormat(numberFormat);\r\n    }\r\n    return number;\r\n}","lc":0.3636363636,"pi":-0.3301435407,"ma":1.0,"nbd":0.0,"ml":0.5833333333,"d":0.6111111111,"mi":-0.3468639887,"fo":0.3333333333,"r":-0.0263157895,"e":0.6080369749}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2330_408a566e","label":3,"code":"private Document makeDocument(String path, NodeState state, boolean isUpdate) throws CommitFailedException {\r\n    if (!isIndexable()) {\r\n        return null;\r\n    }\r\n    List<Field> fields = new ArrayList<Field>();\r\n    boolean dirty = false;\r\n    for (PropertyState property : state.getProperties()) {\r\n        String pname = property.getName();\r\n        if (!isVisible(pname)) {\r\n            continue;\r\n        }\r\n        PropertyDefinition pd = indexingRule.getConfig(pname);\r\n        if (pd == null || !pd.index) {\r\n            continue;\r\n        }\r\n        if (pd.ordered) {\r\n            dirty |= addTypedOrderedFields(fields, property, pname, pd);\r\n        }\r\n        dirty |= indexProperty(path, fields, state, property, pname, false, pd);\r\n    }\r\n    dirty |= indexAggregates(path, fields, state);\r\n    if (isUpdate && !dirty) {\r\n        \/\/ updated the state but had no relevant changes\r\n        return null;\r\n    }\r\n    \/\/ none of the properties are indexed\r\n    if (!indexingRule.isFulltextEnabled() && !dirty) {\r\n        return null;\r\n    }\r\n    Document document = new Document();\r\n    document.add(newPathField(path));\r\n    String name = getName(path);\r\n    \/\/ TODO Possibly index nodeName without tokenization for node name based queries\r\n    if (indexingRule.isFulltextEnabled()) {\r\n        document.add(newFulltextField(name));\r\n    }\r\n    if (getDefinition().evaluatePathRestrictions()) {\r\n        document.add(newAncestorsField(PathUtils.getParentPath(path)));\r\n        document.add(newDepthField(path));\r\n    }\r\n    for (Field f : fields) {\r\n        document.add(f);\r\n    }\r\n    return document;\r\n}","code_comment":null,"code_no_comment":"private Document makeDocument(String path, NodeState state, boolean isUpdate) throws CommitFailedException {\r\n    if (!isIndexable()) {\r\n        return null;\r\n    }\r\n    List<Field> fields = new ArrayList<Field>();\r\n    boolean dirty = false;\r\n    for (PropertyState property : state.getProperties()) {\r\n        String pname = property.getName();\r\n        if (!isVisible(pname)) {\r\n            continue;\r\n        }\r\n        PropertyDefinition pd = indexingRule.getConfig(pname);\r\n        if (pd == null || !pd.index) {\r\n            continue;\r\n        }\r\n        if (pd.ordered) {\r\n            dirty |= addTypedOrderedFields(fields, property, pname, pd);\r\n        }\r\n        dirty |= indexProperty(path, fields, state, property, pname, false, pd);\r\n    }\r\n    dirty |= indexAggregates(path, fields, state);\r\n    if (isUpdate && !dirty) {\r\n                return null;\r\n    }\r\n        if (!indexingRule.isFulltextEnabled() && !dirty) {\r\n        return null;\r\n    }\r\n    Document document = new Document();\r\n    document.add(newPathField(path));\r\n    String name = getName(path);\r\n        if (indexingRule.isFulltextEnabled()) {\r\n        document.add(newFulltextField(name));\r\n    }\r\n    if (getDefinition().evaluatePathRestrictions()) {\r\n        document.add(newAncestorsField(PathUtils.getParentPath(path)));\r\n        document.add(newDepthField(path));\r\n    }\r\n    for (Field f : fields) {\r\n        document.add(f);\r\n    }\r\n    return document;\r\n}","lc":1.2727272727,"pi":-0.0956937799,"ma":1.8,"nbd":0.0,"ml":1.3333333333,"d":0.9841269841,"mi":-0.7708245243,"fo":1.4166666667,"r":-0.0263157895,"e":1.9889766774}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-9444_baece126","label":1,"code":"\/**\r\n * Sends the given exchange to the recipient list\r\n *\/\r\npublic boolean sendToRecipientList(Exchange exchange, Object recipientList, AsyncCallback callback) {\r\n    Iterator<Object> iter;\r\n    if (delimiter != null && delimiter.equalsIgnoreCase(IGNORE_DELIMITER_MARKER)) {\r\n        iter = ObjectHelper.createIterator(recipientList, null);\r\n    } else {\r\n        iter = ObjectHelper.createIterator(recipientList, delimiter);\r\n    }\r\n    RecipientListProcessor rlp = new RecipientListProcessor(exchange.getContext(), producerCache, iter, getAggregationStrategy(), isParallelProcessing(), getExecutorService(), isShutdownExecutorService(), isStreaming(), isStopOnException(), getTimeout(), getOnPrepare(), isShareUnitOfWork(), isParallelAggregate()) {\r\n\r\n        @Override\r\n        protected synchronized ExecutorService createAggregateExecutorService(String name) {\r\n            \/\/ use a shared executor service to avoid creating new thread pools\r\n            if (aggregateExecutorService == null) {\r\n                aggregateExecutorService = super.createAggregateExecutorService(\"RecipientList-AggregateTask\");\r\n            }\r\n            return aggregateExecutorService;\r\n        }\r\n    };\r\n    rlp.setIgnoreInvalidEndpoints(isIgnoreInvalidEndpoints());\r\n    \/\/ start the service\r\n    try {\r\n        ServiceHelper.startService(rlp);\r\n    } catch (Exception e) {\r\n        exchange.setException(e);\r\n        callback.done(true);\r\n        return true;\r\n    }\r\n    AsyncProcessor target = rlp;\r\n    if (isShareUnitOfWork()) {\r\n        \/\/ wrap answer in a sub unit of work, since we share the unit of work\r\n        CamelInternalProcessor internalProcessor = new CamelInternalProcessor(rlp);\r\n        internalProcessor.addAdvice(new CamelInternalProcessor.SubUnitOfWorkProcessorAdvice());\r\n        target = internalProcessor;\r\n    }\r\n    \/\/ now let the multicast process the exchange\r\n    return target.process(exchange, callback);\r\n}","code_comment":"\/**\r\n * Sends the given exchange to the recipient list\r\n *\/\r\n","code_no_comment":"public boolean sendToRecipientList(Exchange exchange, Object recipientList, AsyncCallback callback) {\r\n    Iterator<Object> iter;\r\n    if (delimiter != null && delimiter.equalsIgnoreCase(IGNORE_DELIMITER_MARKER)) {\r\n        iter = ObjectHelper.createIterator(recipientList, null);\r\n    } else {\r\n        iter = ObjectHelper.createIterator(recipientList, delimiter);\r\n    }\r\n    RecipientListProcessor rlp = new RecipientListProcessor(exchange.getContext(), producerCache, iter, getAggregationStrategy(), isParallelProcessing(), getExecutorService(), isShutdownExecutorService(), isStreaming(), isStopOnException(), getTimeout(), getOnPrepare(), isShareUnitOfWork(), isParallelAggregate()) {\r\n\r\n        @Override\r\n        protected synchronized ExecutorService createAggregateExecutorService(String name) {\r\n                        if (aggregateExecutorService == null) {\r\n                aggregateExecutorService = super.createAggregateExecutorService(\"RecipientList-AggregateTask\");\r\n            }\r\n            return aggregateExecutorService;\r\n        }\r\n    };\r\n    rlp.setIgnoreInvalidEndpoints(isIgnoreInvalidEndpoints());\r\n        try {\r\n        ServiceHelper.startService(rlp);\r\n    } catch (Exception e) {\r\n        exchange.setException(e);\r\n        callback.done(true);\r\n        return true;\r\n    }\r\n    AsyncProcessor target = rlp;\r\n    if (isShareUnitOfWork()) {\r\n                CamelInternalProcessor internalProcessor = new CamelInternalProcessor(rlp);\r\n        internalProcessor.addAdvice(new CamelInternalProcessor.SubUnitOfWorkProcessorAdvice());\r\n        target = internalProcessor;\r\n    }\r\n        return target.process(exchange, callback);\r\n}","lc":0.8181818182,"pi":0.2153110048,"ma":0.2,"nbd":0.0,"ml":0.25,"d":0.2857142857,"mi":-0.5664552502,"fo":1.4166666667,"r":-0.0263157895,"e":0.6935772203}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"\/**\r\n *  Static utility to parse a field of type float from a byte sequence that represents text characters\r\n *  (such as when read from a file stream).\r\n *\r\n *  @param bytes The bytes containing the text data that should be parsed.\r\n *  @param startPos The offset to start the parsing.\r\n *  @param length The length of the byte sequence (counting from the offset).\r\n *  @param delimiter The delimiter that terminates the field.\r\n *\r\n *  @return The parsed value.\r\n *\r\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\r\n *\/\r\npublic static final float parseField(byte[] bytes, int startPos, int length, char delimiter) {\r\n    if (length <= 0) {\r\n        throw new NumberFormatException(\"Invalid input: Empty string\");\r\n    }\r\n    int i = 0;\r\n    final byte delByte = (byte) delimiter;\r\n    while (i < length && bytes[i] != delByte) {\r\n        i++;\r\n    }\r\n    String str = new String(bytes, startPos, i);\r\n    return Float.parseFloat(str);\r\n}","code_comment":"\/**\r\n *  Static utility to parse a field of type float from a byte sequence that represents text characters\r\n *  (such as when read from a file stream).\r\n *\r\n *  @param bytes The bytes containing the text data that should be parsed.\r\n *  @param startPos The offset to start the parsing.\r\n *  @param length The length of the byte sequence (counting from the offset).\r\n *  @param delimiter The delimiter that terminates the field.\r\n *\r\n *  @return The parsed value.\r\n *\r\n *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\r\n *\/\r\n","code_no_comment":"public static final float parseField(byte[] bytes, int startPos, int length, char delimiter) {\r\n    if (length <= 0) {\r\n        throw new NumberFormatException(\"Invalid input: Empty string\");\r\n    }\r\n    int i = 0;\r\n    final byte delByte = (byte) delimiter;\r\n    while (i < length && bytes[i] != delByte) {\r\n        i++;\r\n    }\r\n    String str = new String(bytes, startPos, i);\r\n    return Float.parseFloat(str);\r\n}","lc":-0.0909090909,"pi":-0.3253588517,"ma":0.0,"nbd":-0.5,"ml":0.0833333333,"d":0.7857142857,"mi":0.0706131078,"fo":-0.4166666667,"r":0.1315789474,"e":0.271772618}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4291_cdb34ffc","label":0,"code":"@Override\r\npublic void flush() throws IOException {\r\n    List<SegmentBufferWriter> toFlush = newArrayList();\r\n    synchronized (this) {\r\n        toFlush.addAll(writers.values());\r\n        toFlush.addAll(disposed);\r\n        writers.clear();\r\n        disposed.clear();\r\n        borrowed.clear();\r\n    }\r\n    \/\/ deadlocks of that method calling SegmentStore.writeSegment\r\n    for (SegmentBufferWriter writer : toFlush) {\r\n        writer.flush();\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void flush() throws IOException {\r\n    List<SegmentBufferWriter> toFlush = newArrayList();\r\n    synchronized (this) {\r\n        toFlush.addAll(writers.values());\r\n        toFlush.addAll(disposed);\r\n        writers.clear();\r\n        disposed.clear();\r\n        borrowed.clear();\r\n    }\r\n        for (SegmentBufferWriter writer : toFlush) {\r\n        writer.flush();\r\n    }\r\n}","lc":0.0,"pi":0.04784689,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.0731501057,"fo":0.1666666667,"r":0.2894736842,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-395_962315ba","label":1,"code":"\/**\r\n * Find the minimum of the function {@code f} within the interval {@code (a, b)}.\r\n *\r\n * If the function {@code f} is defined on the interval {@code (a, b)}, then\r\n * this method finds an approximation {@code x} to the point at which {@code f}\r\n * attains its minimum.<br\/>\r\n * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t} and\r\n * {@code f} is never evaluated at two points closer together than {@code tol}.\r\n * {@code eps} should be no smaller than <em>2 macheps<\/em> and preferable not\r\n * much less than <em>sqrt(macheps)<\/em>, where <em>macheps<\/em> is the relative\r\n * machine precision. {@code t} should be positive.\r\n * @param f the function to solve.\r\n * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\r\n * or {@link GoalType#MINIMIZE}.\r\n * @param lo Lower bound of the interval.\r\n * @param mid Point inside the interval {@code [lo, hi]}.\r\n * @param hi Higher bound of the interval.\r\n * @param eps Relative accuracy.\r\n * @param t Absolute accuracy.\r\n * @return the optimum point.\r\n * @throws MaxIterationsExceededException if the maximum iteration count\r\n * is exceeded.\r\n * @throws FunctionEvaluationException if an error occurs evaluating\r\n * the function.\r\n *\/\r\nprivate double localMin(UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    if (eps <= 0) {\r\n        throw new NotStrictlyPositiveException(eps);\r\n    }\r\n    if (t <= 0) {\r\n        throw new NotStrictlyPositiveException(t);\r\n    }\r\n    double a, b;\r\n    if (lo < hi) {\r\n        a = lo;\r\n        b = hi;\r\n    } else {\r\n        a = hi;\r\n        b = lo;\r\n    }\r\n    double x = mid;\r\n    double v = x;\r\n    double w = x;\r\n    double e = 0;\r\n    double fx = computeObjectiveValue(f, x);\r\n    if (goalType == GoalType.MAXIMIZE) {\r\n        fx = -fx;\r\n    }\r\n    double fv = fx;\r\n    double fw = fx;\r\n    int count = 0;\r\n    while (count < maximalIterationCount) {\r\n        double m = 0.5 * (a + b);\r\n        final double tol1 = eps * Math.abs(x) + t;\r\n        final double tol2 = 2 * tol1;\r\n        \/\/ Check stopping criterion.\r\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\r\n            double p = 0;\r\n            double q = 0;\r\n            double r = 0;\r\n            double d = 0;\r\n            double u = 0;\r\n            if (Math.abs(e) > tol1) {\r\n                \/\/ Fit parabola.\r\n                r = (x - w) * (fx - fv);\r\n                q = (x - v) * (fx - fw);\r\n                p = (x - v) * q - (x - w) * r;\r\n                q = 2 * (q - r);\r\n                if (q > 0) {\r\n                    p = -p;\r\n                } else {\r\n                    q = -q;\r\n                }\r\n                r = e;\r\n                e = d;\r\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\r\n                    \/\/ Parabolic interpolation step.\r\n                    d = p \/ q;\r\n                    u = x + d;\r\n                    \/\/ f must not be evaluated too close to a or b.\r\n                    if (u - a < tol2 || b - u < tol2) {\r\n                        if (x <= m) {\r\n                            d = tol1;\r\n                        } else {\r\n                            d = -tol1;\r\n                        }\r\n                    }\r\n                } else {\r\n                    \/\/ Golden section step.\r\n                    if (x < m) {\r\n                        e = b - x;\r\n                    } else {\r\n                        e = a - x;\r\n                    }\r\n                    d = GOLDEN_SECTION * e;\r\n                }\r\n            } else {\r\n                \/\/ Golden section step.\r\n                if (x < m) {\r\n                    e = b - x;\r\n                } else {\r\n                    e = a - x;\r\n                }\r\n                d = GOLDEN_SECTION * e;\r\n            }\r\n            \/\/ Update by at least \"tol1\".\r\n            if (Math.abs(d) < tol1) {\r\n                if (d >= 0) {\r\n                    u = x + tol1;\r\n                } else {\r\n                    u = x - tol1;\r\n                }\r\n            } else {\r\n                u = x + d;\r\n            }\r\n            double fu = computeObjectiveValue(f, u);\r\n            if (goalType == GoalType.MAXIMIZE) {\r\n                fu = -fu;\r\n            }\r\n            \/\/ Update a, b, v, w and x.\r\n            if (fu <= fx) {\r\n                if (u < x) {\r\n                    b = x;\r\n                } else {\r\n                    a = x;\r\n                }\r\n                v = w;\r\n                fv = fw;\r\n                w = x;\r\n                fw = fx;\r\n                x = u;\r\n                fx = fu;\r\n            } else {\r\n                if (u < x) {\r\n                    a = u;\r\n                } else {\r\n                    b = u;\r\n                }\r\n                if (fu <= fw || w == x) {\r\n                    v = w;\r\n                    fv = fw;\r\n                    w = u;\r\n                    fw = fu;\r\n                } else if (fu <= fv || v == x || v == w) {\r\n                    v = u;\r\n                    fv = fu;\r\n                }\r\n            }\r\n        } else {\r\n            \/\/ termination\r\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\r\n            return x;\r\n        }\r\n        ++count;\r\n    }\r\n    throw new MaxIterationsExceededException(maximalIterationCount);\r\n}","code_comment":"\/**\r\n * Find the minimum of the function {@code f} within the interval {@code (a, b)}.\r\n *\r\n * If the function {@code f} is defined on the interval {@code (a, b)}, then\r\n * this method finds an approximation {@code x} to the point at which {@code f}\r\n * attains its minimum.<br\/>\r\n * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t} and\r\n * {@code f} is never evaluated at two points closer together than {@code tol}.\r\n * {@code eps} should be no smaller than <em>2 macheps<\/em> and preferable not\r\n * much less than <em>sqrt(macheps)<\/em>, where <em>macheps<\/em> is the relative\r\n * machine precision. {@code t} should be positive.\r\n * @param f the function to solve.\r\n * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\r\n * or {@link GoalType#MINIMIZE}.\r\n * @param lo Lower bound of the interval.\r\n * @param mid Point inside the interval {@code [lo, hi]}.\r\n * @param hi Higher bound of the interval.\r\n * @param eps Relative accuracy.\r\n * @param t Absolute accuracy.\r\n * @return the optimum point.\r\n * @throws MaxIterationsExceededException if the maximum iteration count\r\n * is exceeded.\r\n * @throws FunctionEvaluationException if an error occurs evaluating\r\n * the function.\r\n *\/\r\n","code_no_comment":"private double localMin(UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    if (eps <= 0) {\r\n        throw new NotStrictlyPositiveException(eps);\r\n    }\r\n    if (t <= 0) {\r\n        throw new NotStrictlyPositiveException(t);\r\n    }\r\n    double a, b;\r\n    if (lo < hi) {\r\n        a = lo;\r\n        b = hi;\r\n    } else {\r\n        a = hi;\r\n        b = lo;\r\n    }\r\n    double x = mid;\r\n    double v = x;\r\n    double w = x;\r\n    double e = 0;\r\n    double fx = computeObjectiveValue(f, x);\r\n    if (goalType == GoalType.MAXIMIZE) {\r\n        fx = -fx;\r\n    }\r\n    double fv = fx;\r\n    double fw = fx;\r\n    int count = 0;\r\n    while (count < maximalIterationCount) {\r\n        double m = 0.5 * (a + b);\r\n        final double tol1 = eps * Math.abs(x) + t;\r\n        final double tol2 = 2 * tol1;\r\n                if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\r\n            double p = 0;\r\n            double q = 0;\r\n            double r = 0;\r\n            double d = 0;\r\n            double u = 0;\r\n            if (Math.abs(e) > tol1) {\r\n                                r = (x - w) * (fx - fv);\r\n                q = (x - v) * (fx - fw);\r\n                p = (x - v) * q - (x - w) * r;\r\n                q = 2 * (q - r);\r\n                if (q > 0) {\r\n                    p = -p;\r\n                } else {\r\n                    q = -q;\r\n                }\r\n                r = e;\r\n                e = d;\r\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\r\n                                        d = p \/ q;\r\n                    u = x + d;\r\n                                        if (u - a < tol2 || b - u < tol2) {\r\n                        if (x <= m) {\r\n                            d = tol1;\r\n                        } else {\r\n                            d = -tol1;\r\n                        }\r\n                    }\r\n                } else {\r\n                                        if (x < m) {\r\n                        e = b - x;\r\n                    } else {\r\n                        e = a - x;\r\n                    }\r\n                    d = GOLDEN_SECTION * e;\r\n                }\r\n            } else {\r\n                                if (x < m) {\r\n                    e = b - x;\r\n                } else {\r\n                    e = a - x;\r\n                }\r\n                d = GOLDEN_SECTION * e;\r\n            }\r\n                        if (Math.abs(d) < tol1) {\r\n                if (d >= 0) {\r\n                    u = x + tol1;\r\n                } else {\r\n                    u = x - tol1;\r\n                }\r\n            } else {\r\n                u = x + d;\r\n            }\r\n            double fu = computeObjectiveValue(f, u);\r\n            if (goalType == GoalType.MAXIMIZE) {\r\n                fu = -fu;\r\n            }\r\n                        if (fu <= fx) {\r\n                if (u < x) {\r\n                    b = x;\r\n                } else {\r\n                    a = x;\r\n                }\r\n                v = w;\r\n                fv = fw;\r\n                w = x;\r\n                fw = fx;\r\n                x = u;\r\n                fx = fu;\r\n            } else {\r\n                if (u < x) {\r\n                    a = u;\r\n                } else {\r\n                    b = u;\r\n                }\r\n                if (fu <= fw || w == x) {\r\n                    v = w;\r\n                    fv = fw;\r\n                    w = u;\r\n                    fw = fu;\r\n                } else if (fu <= fv || v == x || v == w) {\r\n                    v = u;\r\n                    fv = fu;\r\n                }\r\n            }\r\n        } else {\r\n                        setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\r\n            return x;\r\n        }\r\n        ++count;\r\n    }\r\n    throw new MaxIterationsExceededException(maximalIterationCount);\r\n}","lc":4.9545454545,"pi":1.6028708134,"ma":4.4,"nbd":2.0,"ml":4.4166666667,"d":6.9444444444,"mi":-1.5265680056,"fo":0.25,"r":-0.0263157895,"e":39.7813431073}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3448_b345dd82","label":0,"code":"@Override\r\npublic int hashCode() {\r\n    int result = exceptionClass.hashCode();\r\n    result = 31 * result + (when != null ? when.hashCode() : 0);\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int hashCode() {\r\n    int result = exceptionClass.hashCode();\r\n    result = 31 * result + (when != null ? when.hashCode() : 0);\r\n    return result;\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":0.2956349206,"mi":0.5154334038,"fo":-0.3333333333,"r":1.3684210526,"e":-0.0490563211}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5459_c225847e","label":1,"code":"private Model loadPom(RepositorySystemSession session, ArtifactDescriptorRequest request, ArtifactDescriptorResult result) throws ArtifactDescriptorException {\r\n    RequestTrace trace = RequestTrace.newChild(request.getTrace(), request);\r\n    Set<String> visited = new LinkedHashSet<String>();\r\n    for (Artifact artifact = request.getArtifact(); ; ) {\r\n        try {\r\n            VersionRequest versionRequest = new VersionRequest(artifact, request.getRepositories(), request.getRequestContext());\r\n            versionRequest.setTrace(trace);\r\n            VersionResult versionResult = versionResolver.resolveVersion(session, versionRequest);\r\n            artifact = artifact.setVersion(versionResult.getVersion());\r\n        } catch (VersionResolutionException e) {\r\n            result.addException(e);\r\n            throw new ArtifactDescriptorException(result);\r\n        }\r\n        if (!visited.add(artifact.getGroupId() + ':' + artifact.getArtifactId() + ':' + artifact.getBaseVersion())) {\r\n            RepositoryException exception = new RepositoryException(\"Artifact relocations form a cycle: \" + visited);\r\n            invalidDescriptor(session, trace, artifact, exception);\r\n            if ((getPolicy(session, artifact, request) & ArtifactDescriptorPolicy.IGNORE_INVALID) != 0) {\r\n                return null;\r\n            }\r\n            result.addException(exception);\r\n            throw new ArtifactDescriptorException(result);\r\n        }\r\n        Artifact pomArtifact = ArtifactDescriptorUtils.toPomArtifact(artifact);\r\n        ArtifactResult resolveResult;\r\n        try {\r\n            ArtifactRequest resolveRequest = new ArtifactRequest(pomArtifact, request.getRepositories(), request.getRequestContext());\r\n            resolveRequest.setTrace(trace);\r\n            resolveResult = artifactResolver.resolveArtifact(session, resolveRequest);\r\n            pomArtifact = resolveResult.getArtifact();\r\n            result.setRepository(resolveResult.getRepository());\r\n        } catch (ArtifactResolutionException e) {\r\n            if (e.getCause() instanceof ArtifactNotFoundException) {\r\n                missingDescriptor(session, trace, artifact, (Exception) e.getCause());\r\n                if ((getPolicy(session, artifact, request) & ArtifactDescriptorPolicy.IGNORE_MISSING) != 0) {\r\n                    return null;\r\n                }\r\n            }\r\n            result.addException(e);\r\n            throw new ArtifactDescriptorException(result);\r\n        }\r\n        Model model;\r\n        try {\r\n            ModelBuildingRequest modelRequest = new DefaultModelBuildingRequest();\r\n            modelRequest.setValidationLevel(ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL);\r\n            modelRequest.setProcessPlugins(false);\r\n            modelRequest.setTwoPhaseBuilding(false);\r\n            modelRequest.setSystemProperties(toProperties(session.getUserProperties(), session.getSystemProperties()));\r\n            modelRequest.setModelCache(DefaultModelCache.newInstance(session));\r\n            modelRequest.setModelResolver(new DefaultModelResolver(session, trace.newChild(modelRequest), request.getRequestContext(), artifactResolver, remoteRepositoryManager, request.getRepositories()));\r\n            if (resolveResult.getRepository() instanceof WorkspaceRepository) {\r\n                modelRequest.setPomFile(pomArtifact.getFile());\r\n            } else {\r\n                modelRequest.setModelSource(new FileModelSource(pomArtifact.getFile()));\r\n            }\r\n            model = modelBuilder.build(modelRequest).getEffectiveModel();\r\n        } catch (ModelBuildingException e) {\r\n            for (ModelProblem problem : e.getProblems()) {\r\n                if (problem.getException() instanceof UnresolvableModelException) {\r\n                    result.addException(problem.getException());\r\n                    throw new ArtifactDescriptorException(result);\r\n                }\r\n            }\r\n            invalidDescriptor(session, trace, artifact, e);\r\n            if ((getPolicy(session, artifact, request) & ArtifactDescriptorPolicy.IGNORE_INVALID) != 0) {\r\n                return null;\r\n            }\r\n            result.addException(e);\r\n            throw new ArtifactDescriptorException(result);\r\n        }\r\n        Relocation relocation = getRelocation(model);\r\n        if (relocation != null) {\r\n            result.addRelocation(artifact);\r\n            artifact = new RelocatedArtifact(artifact, relocation.getGroupId(), relocation.getArtifactId(), relocation.getVersion());\r\n            result.setArtifact(artifact);\r\n        } else {\r\n            return model;\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private Model loadPom(RepositorySystemSession session, ArtifactDescriptorRequest request, ArtifactDescriptorResult result) throws ArtifactDescriptorException {\r\n    RequestTrace trace = RequestTrace.newChild(request.getTrace(), request);\r\n    Set<String> visited = new LinkedHashSet<String>();\r\n    for (Artifact artifact = request.getArtifact(); ; ) {\r\n        try {\r\n            VersionRequest versionRequest = new VersionRequest(artifact, request.getRepositories(), request.getRequestContext());\r\n            versionRequest.setTrace(trace);\r\n            VersionResult versionResult = versionResolver.resolveVersion(session, versionRequest);\r\n            artifact = artifact.setVersion(versionResult.getVersion());\r\n        } catch (VersionResolutionException e) {\r\n            result.addException(e);\r\n            throw new ArtifactDescriptorException(result);\r\n        }\r\n        if (!visited.add(artifact.getGroupId() + ':' + artifact.getArtifactId() + ':' + artifact.getBaseVersion())) {\r\n            RepositoryException exception = new RepositoryException(\"Artifact relocations form a cycle: \" + visited);\r\n            invalidDescriptor(session, trace, artifact, exception);\r\n            if ((getPolicy(session, artifact, request) & ArtifactDescriptorPolicy.IGNORE_INVALID) != 0) {\r\n                return null;\r\n            }\r\n            result.addException(exception);\r\n            throw new ArtifactDescriptorException(result);\r\n        }\r\n        Artifact pomArtifact = ArtifactDescriptorUtils.toPomArtifact(artifact);\r\n        ArtifactResult resolveResult;\r\n        try {\r\n            ArtifactRequest resolveRequest = new ArtifactRequest(pomArtifact, request.getRepositories(), request.getRequestContext());\r\n            resolveRequest.setTrace(trace);\r\n            resolveResult = artifactResolver.resolveArtifact(session, resolveRequest);\r\n            pomArtifact = resolveResult.getArtifact();\r\n            result.setRepository(resolveResult.getRepository());\r\n        } catch (ArtifactResolutionException e) {\r\n            if (e.getCause() instanceof ArtifactNotFoundException) {\r\n                missingDescriptor(session, trace, artifact, (Exception) e.getCause());\r\n                if ((getPolicy(session, artifact, request) & ArtifactDescriptorPolicy.IGNORE_MISSING) != 0) {\r\n                    return null;\r\n                }\r\n            }\r\n            result.addException(e);\r\n            throw new ArtifactDescriptorException(result);\r\n        }\r\n        Model model;\r\n        try {\r\n            ModelBuildingRequest modelRequest = new DefaultModelBuildingRequest();\r\n            modelRequest.setValidationLevel(ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL);\r\n            modelRequest.setProcessPlugins(false);\r\n            modelRequest.setTwoPhaseBuilding(false);\r\n            modelRequest.setSystemProperties(toProperties(session.getUserProperties(), session.getSystemProperties()));\r\n            modelRequest.setModelCache(DefaultModelCache.newInstance(session));\r\n            modelRequest.setModelResolver(new DefaultModelResolver(session, trace.newChild(modelRequest), request.getRequestContext(), artifactResolver, remoteRepositoryManager, request.getRepositories()));\r\n            if (resolveResult.getRepository() instanceof WorkspaceRepository) {\r\n                modelRequest.setPomFile(pomArtifact.getFile());\r\n            } else {\r\n                modelRequest.setModelSource(new FileModelSource(pomArtifact.getFile()));\r\n            }\r\n            model = modelBuilder.build(modelRequest).getEffectiveModel();\r\n        } catch (ModelBuildingException e) {\r\n            for (ModelProblem problem : e.getProblems()) {\r\n                if (problem.getException() instanceof UnresolvableModelException) {\r\n                    result.addException(problem.getException());\r\n                    throw new ArtifactDescriptorException(result);\r\n                }\r\n            }\r\n            invalidDescriptor(session, trace, artifact, e);\r\n            if ((getPolicy(session, artifact, request) & ArtifactDescriptorPolicy.IGNORE_INVALID) != 0) {\r\n                return null;\r\n            }\r\n            result.addException(e);\r\n            throw new ArtifactDescriptorException(result);\r\n        }\r\n        Relocation relocation = getRelocation(model);\r\n        if (relocation != null) {\r\n            result.addRelocation(artifact);\r\n            artifact = new RelocatedArtifact(artifact, relocation.getGroupId(), relocation.getArtifactId(), relocation.getVersion());\r\n            result.setArtifact(artifact);\r\n        } else {\r\n            return model;\r\n        }\r\n    }\r\n}","lc":2.9545454545,"pi":0.3636363636,"ma":3.0,"nbd":1.0,"ml":1.25,"d":0.5992063492,"mi":-1.2474982382,"fo":4.75,"r":-0.0263157895,"e":4.0891616673}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2430_be3a9114","label":1,"code":"@Override\r\npublic boolean childNodeDeleted(String name, NodeState before) {\r\n    if (!loader.isRunning()) {\r\n        return false;\r\n    }\r\n    builder.getChildNode(name).remove();\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean childNodeDeleted(String name, NodeState before) {\r\n    if (!loader.isRunning()) {\r\n        return false;\r\n    }\r\n    builder.getChildNode(name).remove();\r\n    return true;\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.4088794926,"fo":-0.25,"r":0.3421052632,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1784_2426deae","label":0,"code":"private static CommitHook newCommitHook(final String name, final PropertyState state) throws CommitFailedException {\r\n    return new CommitHook() {\r\n\r\n        @Override\r\n        @Nonnull\r\n        public NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {\r\n            \/\/ check for concurrent updates by this async task\r\n            PropertyState stateAfterRebase = before.getChildNode(ASYNC).getProperty(name);\r\n            if (Objects.equal(state, stateAfterRebase)) {\r\n                return postAsyncRunNodeStatus(after.builder(), name).getNodeState();\r\n            } else {\r\n                throw CONCURRENT_UPDATE;\r\n            }\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"private static CommitHook newCommitHook(final String name, final PropertyState state) throws CommitFailedException {\r\n    return new CommitHook() {\r\n\r\n        @Override\r\n        @Nonnull\r\n        public NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {\r\n                        PropertyState stateAfterRebase = before.getChildNode(ASYNC).getProperty(name);\r\n            if (Objects.equal(state, stateAfterRebase)) {\r\n                return postAsyncRunNodeStatus(after.builder(), name).getNodeState();\r\n            } else {\r\n                throw CONCURRENT_UPDATE;\r\n            }\r\n        }\r\n    };\r\n}","lc":0.0,"pi":0.95215311,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":-0.0088794926,"fo":0.0,"r":0.0526315789,"e":-0.1627934049}
{"project_name":"Closure","project_version":"90","label":2,"code":"@Override\r\npublic boolean apply(JSType type) {\r\n    \/\/ union types can also be object types, etc.\r\n    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\r\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\r\n        return false;\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean apply(JSType type) {\r\n        if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\r\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\r\n        return false;\r\n    }\r\n    return true;\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.3998590557,"fo":-0.1666666667,"r":0.7105263158,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4789_6f0863f4","label":0,"code":"\/**\r\n *  Try to reduce url by eliminating '..' and '.' from the path where appropriate\r\n *  (this is somehow similar to {@link java.io.File#getCanonicalPath()}).\r\n *  Either by different \/ unexpected browser behavior or by malicious attacks it\r\n *  can happen that these kind of redundant urls are processed by wicket. These urls\r\n *  can cause some trouble when mapping the request.\r\n *  <p\/>\r\n *  <strong>example:<\/strong>\r\n *\r\n *  the url\r\n *\r\n *  <pre>  \/example\/..;jsessionid=234792?0<\/pre>\r\n *\r\n *  will not get normalized by the browser due to the ';jsessionid' string that\r\n *  gets appended by the servlet container. After wicket strips the\r\n *  jsessionid part the resulting internal url will be\r\n *\r\n *  <pre>  \/example\/..<\/pre>\r\n *\r\n *  instead of\r\n *\r\n *  <pre>  \/<\/pre>\r\n *\r\n *  <p\/>\r\n *\r\n *  This code correlates to\r\n *  <a href=\"https:\/\/issues.apache.org\/jira\/browse\/WICKET-4303\">WICKET-4303<\/a>\r\n *\r\n *  @return canonical url\r\n *\/\r\npublic Url canonical() {\r\n    Url url = new Url(this);\r\n    url.segments.clear();\r\n    for (int i = 0; i < this.segments.size(); i++) {\r\n        final String segment = this.segments.get(i);\r\n        \/\/ drop '.' from path\r\n        if (\".\".equals(segment)) {\r\n            continue;\r\n        }\r\n        \/\/ skip segment if following segment is a '..'\r\n        if ((i + 1) < this.segments.size() && \"..\".equals(this.segments.get(i + 1))) {\r\n            i++;\r\n            continue;\r\n        }\r\n        url.segments.add(segment);\r\n    }\r\n    return url;\r\n}","code_comment":"\/**\r\n *  Try to reduce url by eliminating '..' and '.' from the path where appropriate\r\n *  (this is somehow similar to {@link java.io.File#getCanonicalPath()}).\r\n *  Either by different \/ unexpected browser behavior or by malicious attacks it\r\n *  can happen that these kind of redundant urls are processed by wicket. These urls\r\n *  can cause some trouble when mapping the request.\r\n *  <p\/>\r\n *  <strong>example:<\/strong>\r\n *\r\n *  the url\r\n *\r\n *  <pre>  \/example\/..;jsessionid=234792?0<\/pre>\r\n *\r\n *  will not get normalized by the browser due to the ';jsessionid' string that\r\n *  gets appended by the servlet container. After wicket strips the\r\n *  jsessionid part the resulting internal url will be\r\n *\r\n *  <pre>  \/example\/..<\/pre>\r\n *\r\n *  instead of\r\n *\r\n *  <pre>  \/<\/pre>\r\n *\r\n *  <p\/>\r\n *\r\n *  This code correlates to\r\n *  <a href=\"https:\/\/issues.apache.org\/jira\/browse\/WICKET-4303\">WICKET-4303<\/a>\r\n *\r\n *  @return canonical url\r\n *\/\r\n","code_no_comment":"public Url canonical() {\r\n    Url url = new Url(this);\r\n    url.segments.clear();\r\n    for (int i = 0; i < this.segments.size(); i++) {\r\n        final String segment = this.segments.get(i);\r\n                if (\".\".equals(segment)) {\r\n            continue;\r\n        }\r\n                if ((i + 1) < this.segments.size() && \"..\".equals(this.segments.get(i + 1))) {\r\n            i++;\r\n            continue;\r\n        }\r\n        url.segments.add(segment);\r\n    }\r\n    return url;\r\n}","lc":0.0909090909,"pi":0.3444976077,"ma":0.4,"nbd":0.0,"ml":0.4166666667,"d":0.5456349206,"mi":-0.1171247357,"fo":0.1666666667,"r":0.0,"e":0.2994346571}
{"project_name":"Closure","project_version":"15","label":2,"code":"@Override\r\npublic boolean apply(Node n) {\r\n    \/\/ where the function returns (possibly without an return statement)\r\n    if (n == null) {\r\n        return false;\r\n    }\r\n    \/\/ function.\r\n    if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\r\n        return true;\r\n    }\r\n    if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\r\n        return true;\r\n    }\r\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\r\n        if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean apply(Node n) {\r\n        if (n == null) {\r\n        return false;\r\n    }\r\n        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\r\n        return true;\r\n    }\r\n    if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\r\n        return true;\r\n    }\r\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\r\n        if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","lc":0.1818181818,"pi":0.0717703349,"ma":0.4,"nbd":0.0,"ml":0.9166666667,"d":0.4285714286,"mi":-0.1571529246,"fo":0.1666666667,"r":0.4210526316,"e":0.2042588014}
{"project_name":"Closure","project_version":"12","label":1,"code":"private boolean hasExceptionHandler(Node cfgNode) {\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"private boolean hasExceptionHandler(Node cfgNode) {\r\n    return false;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.5,"r":2.2631578947,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4291_cdb34ffc","label":0,"code":"private synchronized SegmentBufferWriter borrowWriter(Object key) {\r\n    SegmentBufferWriter writer = writers.remove(key);\r\n    if (writer == null) {\r\n        writer = new SegmentBufferWriter(store, tracker, reader, version, getWriterId(wid), gcGeneration.get());\r\n    } else if (writer.getGeneration() != gcGeneration.get()) {\r\n        disposed.add(writer);\r\n        writer = new SegmentBufferWriter(store, tracker, reader, version, getWriterId(wid), gcGeneration.get());\r\n    }\r\n    borrowed.add(writer);\r\n    return writer;\r\n}","code_comment":null,"code_no_comment":"private synchronized SegmentBufferWriter borrowWriter(Object key) {\r\n    SegmentBufferWriter writer = writers.remove(key);\r\n    if (writer == null) {\r\n        writer = new SegmentBufferWriter(store, tracker, reader, version, getWriterId(wid), gcGeneration.get());\r\n    } else if (writer.getGeneration() != gcGeneration.get()) {\r\n        disposed.add(writer);\r\n        writer = new SegmentBufferWriter(store, tracker, reader, version, getWriterId(wid), gcGeneration.get());\r\n    }\r\n    borrowed.add(writer);\r\n    return writer;\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":0.0416666667,"mi":0.0725863284,"fo":0.25,"r":-0.0263157895,"e":0.0449669496}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1705_5308ac83","label":1,"code":"\/\/ --------------------------------------------------------------------------------------------\r\n\/\/ Serialization\r\n\/\/ --------------------------------------------------------------------------------------------\r\n@Override\r\npublic void read(DataInputView in) throws IOException {\r\n    final int addr_length = in.readInt();\r\n    byte[] address = new byte[addr_length];\r\n    in.readFully(address);\r\n    this.dataPort = in.readInt();\r\n    this.fqdnHostName = StringUtils.readNullableString(in);\r\n    this.hostName = StringUtils.readNullableString(in);\r\n    this.fqdnHostNameIsIP = in.readBoolean();\r\n    try {\r\n        this.inetAddress = InetAddress.getByAddress(address);\r\n    } catch (UnknownHostException e) {\r\n        throw new IOException(\"This lookup should never fail.\", e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void read(DataInputView in) throws IOException {\r\n    final int addr_length = in.readInt();\r\n    byte[] address = new byte[addr_length];\r\n    in.readFully(address);\r\n    this.dataPort = in.readInt();\r\n    this.fqdnHostName = StringUtils.readNullableString(in);\r\n    this.hostName = StringUtils.readNullableString(in);\r\n    this.fqdnHostNameIsIP = in.readBoolean();\r\n    try {\r\n        this.inetAddress = InetAddress.getByAddress(address);\r\n    } catch (UnknownHostException e) {\r\n        throw new IOException(\"This lookup should never fail.\", e);\r\n    }\r\n}","lc":0.0454545455,"pi":-0.3349282297,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.0565186751,"fo":0.0833333333,"r":0.0,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"public boolean equals(update_result that) {\r\n    if (that == null)\r\n        return false;\r\n    boolean this_present_ouch1 = true && this.isSetOuch1();\r\n    boolean that_present_ouch1 = true && that.isSetOuch1();\r\n    if (this_present_ouch1 || that_present_ouch1) {\r\n        if (!(this_present_ouch1 && that_present_ouch1))\r\n            return false;\r\n        if (!this.ouch1.equals(that.ouch1))\r\n            return false;\r\n    }\r\n    boolean this_present_ouch2 = true && this.isSetOuch2();\r\n    boolean that_present_ouch2 = true && that.isSetOuch2();\r\n    if (this_present_ouch2 || that_present_ouch2) {\r\n        if (!(this_present_ouch2 && that_present_ouch2))\r\n            return false;\r\n        if (!this.ouch2.equals(that.ouch2))\r\n            return false;\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"public boolean equals(update_result that) {\r\n    if (that == null)\r\n        return false;\r\n    boolean this_present_ouch1 = true && this.isSetOuch1();\r\n    boolean that_present_ouch1 = true && that.isSetOuch1();\r\n    if (this_present_ouch1 || that_present_ouch1) {\r\n        if (!(this_present_ouch1 && that_present_ouch1))\r\n            return false;\r\n        if (!this.ouch1.equals(that.ouch1))\r\n            return false;\r\n    }\r\n    boolean this_present_ouch2 = true && this.isSetOuch2();\r\n    boolean that_present_ouch2 = true && that.isSetOuch2();\r\n    if (this_present_ouch2 || that_present_ouch2) {\r\n        if (!(this_present_ouch2 && that_present_ouch2))\r\n            return false;\r\n        if (!this.ouch2.equals(that.ouch2))\r\n            return false;\r\n    }\r\n    return true;\r\n}","lc":0.3181818182,"pi":0.3014354067,"ma":0.8,"nbd":-0.5,"ml":1.25,"d":0.746031746,"mi":-0.2769556025,"fo":0.0,"r":-0.0263157895,"e":0.4955492932}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1437_fb7ce0e3","label":1,"code":"@Override\r\npublic void copy(DataInputView source, DataOutputView target) throws IOException {\r\n    \/\/ copy the Non-Null\/Null tag\r\n    target.writeBoolean(source.readBoolean());\r\n    for (int i = 0; i < numFields; i++) {\r\n        target.writeBoolean(source.readBoolean());\r\n        fieldSerializers[i].copy(source, target);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void copy(DataInputView source, DataOutputView target) throws IOException {\r\n        target.writeBoolean(source.readBoolean());\r\n    for (int i = 0; i < numFields; i++) {\r\n        target.writeBoolean(source.readBoolean());\r\n        fieldSerializers[i].copy(source, target);\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":0.003968254,"mi":0.3150105708,"fo":-0.0833333333,"r":0.1842105263,"e":-0.0613013837}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"@Override\r\npublic boolean orderBefore(final String name) {\r\n    root.checkLive();\r\n    if (isRoot()) {\r\n        \/\/ root does not have siblings\r\n        return false;\r\n    }\r\n    if (name != null && !parent.hasChild(name)) {\r\n        \/\/ so such sibling or not accessible\r\n        return false;\r\n    }\r\n    \/\/ perform the reorder\r\n    parent.ensureChildOrderProperty();\r\n    \/\/ all siblings but not this one\r\n    Iterable<String> filtered = Iterables.filter(parent.getOrderedChildNames(), new Predicate<String>() {\r\n\r\n        @Override\r\n        public boolean apply(@Nullable String input) {\r\n            return !TreeImpl.this.getName().equals(input);\r\n        }\r\n    });\r\n    \/\/ create head and tail\r\n    Iterable<String> head;\r\n    Iterable<String> tail;\r\n    if (name == null) {\r\n        head = filtered;\r\n        tail = Collections.emptyList();\r\n    } else {\r\n        int idx = Iterables.indexOf(filtered, new Predicate<String>() {\r\n\r\n            @Override\r\n            public boolean apply(@Nullable String input) {\r\n                return name.equals(input);\r\n            }\r\n        });\r\n        head = Iterables.limit(filtered, idx);\r\n        tail = Iterables.skip(filtered, idx);\r\n    }\r\n    \/\/ concatenate head, this name and tail\r\n    parent.getNodeBuilder().setProperty(MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, Iterables.concat(head, Collections.singleton(getName()), tail)));\r\n    root.updated();\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean orderBefore(final String name) {\r\n    root.checkLive();\r\n    if (isRoot()) {\r\n                return false;\r\n    }\r\n    if (name != null && !parent.hasChild(name)) {\r\n                return false;\r\n    }\r\n        parent.ensureChildOrderProperty();\r\n        Iterable<String> filtered = Iterables.filter(parent.getOrderedChildNames(), new Predicate<String>() {\r\n\r\n        @Override\r\n        public boolean apply(@Nullable String input) {\r\n            return !TreeImpl.this.getName().equals(input);\r\n        }\r\n    });\r\n        Iterable<String> head;\r\n    Iterable<String> tail;\r\n    if (name == null) {\r\n        head = filtered;\r\n        tail = Collections.emptyList();\r\n    } else {\r\n        int idx = Iterables.indexOf(filtered, new Predicate<String>() {\r\n\r\n            @Override\r\n            public boolean apply(@Nullable String input) {\r\n                return name.equals(input);\r\n            }\r\n        });\r\n        head = Iterables.limit(filtered, idx);\r\n        tail = Iterables.skip(filtered, idx);\r\n    }\r\n        parent.getNodeBuilder().setProperty(MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, Iterables.concat(head, Collections.singleton(getName()), tail)));\r\n    root.updated();\r\n    return true;\r\n}","lc":0.9545454545,"pi":0.3014354067,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":0.4662698413,"mi":-0.5968992248,"fo":1.1666666667,"r":-0.0263157895,"e":0.8995948664}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5686_8e794fc4","label":1,"code":"@Override\r\npublic Object getFieldValue(final Field field, final Object fieldOwner) {\r\n    if (supportsField(field)) {\r\n        SpringBean annot = field.getAnnotation(SpringBean.class);\r\n        String name;\r\n        boolean required;\r\n        if (annot != null) {\r\n            name = annot.name();\r\n            required = annot.required();\r\n        } else {\r\n            Named named = field.getAnnotation(Named.class);\r\n            name = named != null ? named.value() : \"\";\r\n            required = false;\r\n        }\r\n        String beanName = getBeanName(field, name, required);\r\n        if (beanName == null) {\r\n            return null;\r\n        }\r\n        SpringBeanLocator locator = new SpringBeanLocator(beanName, field.getType(), contextLocator);\r\n        \/\/ only check the cache if the bean is a singleton\r\n        Object cachedValue = cache.get(locator);\r\n        if (cachedValue != null) {\r\n            return cachedValue;\r\n        }\r\n        Object target;\r\n        try {\r\n            \/\/ check whether there is a bean with the provided properties\r\n            target = locator.locateProxyTarget();\r\n        } catch (IllegalStateException isx) {\r\n            if (required) {\r\n                throw isx;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        if (wrapInProxies) {\r\n            target = LazyInitProxyFactory.createProxy(field.getType(), locator);\r\n        }\r\n        \/\/ only put the proxy into the cache if the bean is a singleton\r\n        if (locator.isSingletonBean()) {\r\n            Object tmpTarget = cache.putIfAbsent(locator, target);\r\n            if (tmpTarget != null) {\r\n                target = tmpTarget;\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Object getFieldValue(final Field field, final Object fieldOwner) {\r\n    if (supportsField(field)) {\r\n        SpringBean annot = field.getAnnotation(SpringBean.class);\r\n        String name;\r\n        boolean required;\r\n        if (annot != null) {\r\n            name = annot.name();\r\n            required = annot.required();\r\n        } else {\r\n            Named named = field.getAnnotation(Named.class);\r\n            name = named != null ? named.value() : \"\";\r\n            required = false;\r\n        }\r\n        String beanName = getBeanName(field, name, required);\r\n        if (beanName == null) {\r\n            return null;\r\n        }\r\n        SpringBeanLocator locator = new SpringBeanLocator(beanName, field.getType(), contextLocator);\r\n                Object cachedValue = cache.get(locator);\r\n        if (cachedValue != null) {\r\n            return cachedValue;\r\n        }\r\n        Object target;\r\n        try {\r\n                        target = locator.locateProxyTarget();\r\n        } catch (IllegalStateException isx) {\r\n            if (required) {\r\n                throw isx;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        if (wrapInProxies) {\r\n            target = LazyInitProxyFactory.createProxy(field.getType(), locator);\r\n        }\r\n                if (locator.isSingletonBean()) {\r\n            Object tmpTarget = cache.putIfAbsent(locator, target);\r\n            if (tmpTarget != null) {\r\n                target = tmpTarget;\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n    return null;\r\n}","lc":1.4545454545,"pi":0.3301435407,"ma":1.6,"nbd":0.5,"ml":1.1666666667,"d":0.1130952381,"mi":-0.7871740662,"fo":0.6666666667,"r":-0.0263157895,"e":0.5083107139}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-705_645d642b","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic void readExternal(final ObjectInput in) throws IOException, ClassNotFoundException {\r\n    \/\/ read the base class\r\n    final double t = readBaseExternal(in);\r\n    \/\/ read the local attributes\r\n    final int n = (currentState == null) ? -1 : currentState.length;\r\n    final int kMax = in.readInt();\r\n    yDotK = (kMax < 0) ? null : new double[kMax][];\r\n    for (int k = 0; k < kMax; ++k) {\r\n        yDotK[k] = (n < 0) ? null : new double[n];\r\n        for (int i = 0; i < n; ++i) {\r\n            yDotK[k][i] = in.readDouble();\r\n        }\r\n    }\r\n    integrator = null;\r\n    if (currentState != null) {\r\n        \/\/ we can now set the interpolated time and state\r\n        setInterpolatedTime(t);\r\n    } else {\r\n        interpolatedTime = t;\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void readExternal(final ObjectInput in) throws IOException, ClassNotFoundException {\r\n        final double t = readBaseExternal(in);\r\n        final int n = (currentState == null) ? -1 : currentState.length;\r\n    final int kMax = in.readInt();\r\n    yDotK = (kMax < 0) ? null : new double[kMax][];\r\n    for (int k = 0; k < kMax; ++k) {\r\n        yDotK[k] = (n < 0) ? null : new double[n];\r\n        for (int i = 0; i < n; ++i) {\r\n            yDotK[k][i] = in.readDouble();\r\n        }\r\n    }\r\n    integrator = null;\r\n    if (currentState != null) {\r\n                setInterpolatedTime(t);\r\n    } else {\r\n        interpolatedTime = t;\r\n    }\r\n}","lc":0.2272727273,"pi":0.038277512,"ma":0.6,"nbd":0.0,"ml":0.5,"d":0.9484126984,"mi":-0.2724453841,"fo":-0.1666666667,"r":1.3684210526,"e":0.9162981276}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-135_438e31a7","label":1,"code":"@Override\r\n@Nonnull\r\npublic NodeIterator getNodes() throws RepositoryException {\r\n    checkStatus();\r\n    Iterator<NodeDelegate> children = dlg.getChildren();\r\n    return new NodeIteratorAdapter(nodeIterator(children));\r\n}","code_comment":null,"code_no_comment":"@Override\r\n@Nonnull\r\npublic NodeIterator getNodes() throws RepositoryException {\r\n    checkStatus();\r\n    Iterator<NodeDelegate> children = dlg.getChildren();\r\n    return new NodeIteratorAdapter(nodeIterator(children));\r\n}","lc":-0.3181818182,"pi":-0.4832535885,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4762508809,"fo":-0.25,"r":1.3947368421,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"public update_result setOuch1(UnknownWriter ouch1) {\r\n    this.ouch1 = ouch1;\r\n    return this;\r\n}","code_comment":null,"code_no_comment":"public update_result setOuch1(UnknownWriter ouch1) {\r\n    this.ouch1 = ouch1;\r\n    return this;\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8940098661,"fo":-0.5,"r":1.8947368421,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1369_ce0b0955","label":1,"code":"private Expression parsePropertyOrFunction() throws ParseException {\r\n    StringBuilder buff = new StringBuilder();\r\n    boolean isPath = false;\r\n    while (true) {\r\n        if (currentTokenType == IDENTIFIER) {\r\n            String name = readPathSegment();\r\n            buff.append(name);\r\n        } else if (readIf(\"*\")) {\r\n            \/\/ any node\r\n            buff.append('*');\r\n            isPath = true;\r\n        } else if (readIf(\".\")) {\r\n            buff.append('.');\r\n            if (readIf(\".\")) {\r\n                buff.append('.');\r\n            }\r\n            isPath = true;\r\n        } else if (readIf(\"@\")) {\r\n            if (readIf(\"*\")) {\r\n                \/\/ xpath supports @*, even thought jackrabbit may not\r\n                buff.append('*');\r\n            } else {\r\n                buff.append(readPathSegment());\r\n            }\r\n            return new Expression.Property(currentSelector, buff.toString(), false);\r\n        } else {\r\n            break;\r\n        }\r\n        if (readIf(\"\/\")) {\r\n            isPath = true;\r\n            buff.append('\/');\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    if (!isPath && readIf(\"(\")) {\r\n        return parseFunction(buff.toString());\r\n    } else if (buff.length() > 0) {\r\n        \/\/ jcr:contains(jcr:content, 'x')\r\n        if (buff.toString().equals(\".\")) {\r\n            buff = new StringBuilder(\"*\");\r\n        } else {\r\n            buff.append(\"\/*\");\r\n        }\r\n        return new Expression.Property(currentSelector, buff.toString(), true);\r\n    }\r\n    throw getSyntaxError();\r\n}","code_comment":null,"code_no_comment":"private Expression parsePropertyOrFunction() throws ParseException {\r\n    StringBuilder buff = new StringBuilder();\r\n    boolean isPath = false;\r\n    while (true) {\r\n        if (currentTokenType == IDENTIFIER) {\r\n            String name = readPathSegment();\r\n            buff.append(name);\r\n        } else if (readIf(\"*\")) {\r\n                        buff.append('*');\r\n            isPath = true;\r\n        } else if (readIf(\".\")) {\r\n            buff.append('.');\r\n            if (readIf(\".\")) {\r\n                buff.append('.');\r\n            }\r\n            isPath = true;\r\n        } else if (readIf(\"@\")) {\r\n            if (readIf(\"*\")) {\r\n                                buff.append('*');\r\n            } else {\r\n                buff.append(readPathSegment());\r\n            }\r\n            return new Expression.Property(currentSelector, buff.toString(), false);\r\n        } else {\r\n            break;\r\n        }\r\n        if (readIf(\"\/\")) {\r\n            isPath = true;\r\n            buff.append('\/');\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    if (!isPath && readIf(\"(\")) {\r\n        return parseFunction(buff.toString());\r\n    } else if (buff.length() > 0) {\r\n                if (buff.toString().equals(\".\")) {\r\n            buff = new StringBuilder(\"*\");\r\n        } else {\r\n            buff.append(\"\/*\");\r\n        }\r\n        return new Expression.Property(currentSelector, buff.toString(), true);\r\n    }\r\n    throw getSyntaxError();\r\n}","lc":1.4090909091,"pi":0.4354066986,"ma":2.2,"nbd":2.0,"ml":1.3333333333,"d":0.7718253968,"mi":-0.7682875264,"fo":1.5833333333,"r":-0.0263157895,"e":1.1523383067}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-8964_ea8ee025","label":1,"code":"\/**\r\n * Resumes each element of the given {@code services} if {@code services} itself is\r\n * not {@code null}, otherwise this method would return immediately.\r\n * <p\/>\r\n * If there's any exception being thrown while resuming the elements one after the\r\n * other this method would rethrow the <b>first<\/b> such exception being thrown.\r\n *\r\n * @see #resumeService(Service)\r\n *\/\r\npublic static void resumeServices(Collection<?> services) throws Exception {\r\n    if (services == null) {\r\n        return;\r\n    }\r\n    Exception firstException = null;\r\n    for (Object value : services) {\r\n        if (value instanceof Service) {\r\n            Service service = (Service) value;\r\n            try {\r\n                resumeService(service);\r\n            } catch (Exception e) {\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Caught exception resuming service: \" + service, e);\r\n                }\r\n                if (firstException == null) {\r\n                    firstException = e;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (firstException != null) {\r\n        throw firstException;\r\n    }\r\n}","code_comment":"\/**\r\n * Resumes each element of the given {@code services} if {@code services} itself is\r\n * not {@code null}, otherwise this method would return immediately.\r\n * <p\/>\r\n * If there's any exception being thrown while resuming the elements one after the\r\n * other this method would rethrow the <b>first<\/b> such exception being thrown.\r\n *\r\n * @see #resumeService(Service)\r\n *\/\r\n","code_no_comment":"public static void resumeServices(Collection<?> services) throws Exception {\r\n    if (services == null) {\r\n        return;\r\n    }\r\n    Exception firstException = null;\r\n    for (Object value : services) {\r\n        if (value instanceof Service) {\r\n            Service service = (Service) value;\r\n            try {\r\n                resumeService(service);\r\n            } catch (Exception e) {\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Caught exception resuming service: \" + service, e);\r\n                }\r\n                if (firstException == null) {\r\n                    firstException = e;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (firstException != null) {\r\n        throw firstException;\r\n    }\r\n}","lc":0.4545454545,"pi":1.4306220096,"ma":1.0,"nbd":1.0,"ml":0.3333333333,"d":0.498015873,"mi":-0.3037350247,"fo":-0.25,"r":0.0263157895,"e":0.2250560444}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"\/**\r\n *  Get the markup stream for this component.\r\n *\r\n *  @return The markup stream for this component, or if it doesn't have one,\r\n *          the markup stream for the nearest parent which does have one\r\n *\/\r\n@Override\r\nprotected final MarkupStream findMarkupStream() {\r\n    \/\/ Start here\r\n    MarkupContainer c = this;\r\n    \/\/ Walk up hierarchy until markup found\r\n    while (c.getMarkupStream() == null) {\r\n        \/\/ Check parent\r\n        c = c.getParent();\r\n        \/\/ Are we at the top of the hierarchy?\r\n        if (c == null) {\r\n            \/\/ Failed to find markup stream\r\n            throw new WicketRuntimeException(exceptionMessage(\"No markup found\"));\r\n        }\r\n    }\r\n    return c.getMarkupStream();\r\n}","code_comment":"\/**\r\n *  Get the markup stream for this component.\r\n *\r\n *  @return The markup stream for this component, or if it doesn't have one,\r\n *          the markup stream for the nearest parent which does have one\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected final MarkupStream findMarkupStream() {\r\n        MarkupContainer c = this;\r\n        while (c.getMarkupStream() == null) {\r\n                c = c.getParent();\r\n                if (c == null) {\r\n                        throw new WicketRuntimeException(exceptionMessage(\"No markup found\"));\r\n        }\r\n    }\r\n    return c.getMarkupStream();\r\n}","lc":-0.1363636364,"pi":0.3588516746,"ma":0.0,"nbd":0.0,"ml":-0.0833333333,"d":-0.0515873016,"mi":0.2011275546,"fo":-0.1666666667,"r":1.5263157895,"e":-0.098871043}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5082_217fbb3b","label":1,"code":"\/**\r\n *  @param response\r\n *       the response to write to\r\n *  @param component\r\n *       to component which will contribute to the header\r\n *\/\r\nprotected void writeHeaderContribution(final Response response, final Component component) {\r\n    headerRendering = true;\r\n    \/\/ create the htmlheadercontainer if needed\r\n    if (header == null) {\r\n        header = new AjaxHtmlHeaderContainer(this);\r\n        final Page parentPage = component.getPage();\r\n        parentPage.addOrReplace(header);\r\n    }\r\n    RequestCycle requestCycle = component.getRequestCycle();\r\n    \/\/ save old response, set new\r\n    Response oldResponse = requestCycle.setResponse(encodingHeaderResponse);\r\n    try {\r\n        encodingHeaderResponse.reset();\r\n        \/\/ render the head of component and all it's children\r\n        component.renderHead(header);\r\n        if (component instanceof MarkupContainer) {\r\n            ((MarkupContainer) component).visitChildren(new IVisitor<Component, Void>() {\r\n\r\n                @Override\r\n                public void component(final Component component, final IVisit<Void> visit) {\r\n                    if (component.isVisibleInHierarchy()) {\r\n                        component.renderHead(header);\r\n                    } else {\r\n                        visit.dontGoDeeper();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    } finally {\r\n        \/\/ revert to old response\r\n        requestCycle.setResponse(oldResponse);\r\n    }\r\n    writeHeaderContribution(response);\r\n    headerRendering = false;\r\n}","code_comment":"\/**\r\n *  @param response\r\n *       the response to write to\r\n *  @param component\r\n *       to component which will contribute to the header\r\n *\/\r\n","code_no_comment":"protected void writeHeaderContribution(final Response response, final Component component) {\r\n    headerRendering = true;\r\n        if (header == null) {\r\n        header = new AjaxHtmlHeaderContainer(this);\r\n        final Page parentPage = component.getPage();\r\n        parentPage.addOrReplace(header);\r\n    }\r\n    RequestCycle requestCycle = component.getRequestCycle();\r\n        Response oldResponse = requestCycle.setResponse(encodingHeaderResponse);\r\n    try {\r\n        encodingHeaderResponse.reset();\r\n                component.renderHead(header);\r\n        if (component instanceof MarkupContainer) {\r\n            ((MarkupContainer) component).visitChildren(new IVisitor<Component, Void>() {\r\n\r\n                @Override\r\n                public void component(final Component component, final IVisit<Void> visit) {\r\n                    if (component.isVisibleInHierarchy()) {\r\n                        component.renderHead(header);\r\n                    } else {\r\n                        visit.dontGoDeeper();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    } finally {\r\n                requestCycle.setResponse(oldResponse);\r\n    }\r\n    writeHeaderContribution(response);\r\n    headerRendering = false;\r\n}","lc":0.7272727273,"pi":1.8277511962,"ma":0.0,"nbd":1.0,"ml":0.0833333333,"d":0.0079365079,"mi":-0.4618745595,"fo":0.5,"r":-0.0263157895,"e":0.1437665324}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4105_64656c98","label":1,"code":"@Override\r\npublic void beforeRender(Component component) {\r\n    super.beforeRender(component);\r\n    final RequestCycle requestCycle = RequestCycle.get();\r\n    \/\/ Temporarily replace the web response with a String response\r\n    webResponse = (WebResponse) requestCycle.getResponse();\r\n    \/\/ Create a new response object\r\n    final BufferedWebResponse response = newResponse(webResponse);\r\n    if (response == null) {\r\n        throw new IllegalStateException(\"newResponse() must not return null\");\r\n    }\r\n    \/\/ and make it the current one\r\n    requestCycle.setResponse(response);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void beforeRender(Component component) {\r\n    super.beforeRender(component);\r\n    final RequestCycle requestCycle = RequestCycle.get();\r\n        webResponse = (WebResponse) requestCycle.getResponse();\r\n        final BufferedWebResponse response = newResponse(webResponse);\r\n    if (response == null) {\r\n        throw new IllegalStateException(\"newResponse() must not return null\");\r\n    }\r\n        requestCycle.setResponse(response);\r\n}","lc":-0.1363636364,"pi":-0.3301435407,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0793650794,"mi":0.1501057082,"fo":-0.0833333333,"r":0.0789473684,"e":-0.0764509604}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2172_ea4a3f8a","label":3,"code":"\/**\r\n *  @see IValueMap#getAsDouble(String)\r\n *\/\r\npublic Double getAsDouble(String key) {\r\n    if (!containsKey(key))\r\n        return null;\r\n    try {\r\n        return getDouble(key);\r\n    } catch (StringValueConversionException ignored) {\r\n        return null;\r\n    }\r\n}","code_comment":"\/**\r\n *  @see IValueMap#getAsDouble(String)\r\n *\/\r\n","code_no_comment":"public Double getAsDouble(String key) {\r\n    if (!containsKey(key))\r\n        return null;\r\n    try {\r\n        return getDouble(key);\r\n    } catch (StringValueConversionException ignored) {\r\n        return null;\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.3860465116,"fo":-0.3333333333,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3267_ed3810b1","label":0,"code":"private void checkKryoInitialized() {\r\n    if (this.kryo == null) {\r\n        this.kryo = getKryoInstance();\r\n        \/\/ Throwable and all subclasses should be serialized via java serialization\r\n        kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\r\n        \/\/ are registered with a default serializer\r\n        for (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> entry : defaultSerializers.entrySet()) {\r\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\r\n        }\r\n        for (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry : defaultSerializerClasses.entrySet()) {\r\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue());\r\n        }\r\n        \/\/ register the type of our class\r\n        kryo.register(type);\r\n        \/\/ more specific serializer overrides this\r\n        for (Class<?> type : registeredTypes) {\r\n            kryo.register(type);\r\n        }\r\n        \/\/ register given serializer classes\r\n        for (Map.Entry<Class<?>, Class<? extends Serializer<?>>> e : registeredTypesWithSerializerClasses.entrySet()) {\r\n            Class<?> typeClass = e.getKey();\r\n            Class<? extends Serializer<?>> serializerClass = e.getValue();\r\n            Serializer<?> serializer = ReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\r\n            kryo.register(typeClass, serializer);\r\n        }\r\n        \/\/ register given serializers\r\n        for (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> e : registeredTypesWithSerializers.entrySet()) {\r\n            kryo.register(e.getKey(), e.getValue().getSerializer());\r\n        }\r\n        \/\/ this is needed for Avro but can not be added on demand.\r\n        kryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\r\n        kryo.setRegistrationRequired(false);\r\n        kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void checkKryoInitialized() {\r\n    if (this.kryo == null) {\r\n        this.kryo = getKryoInstance();\r\n                kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\r\n                for (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> entry : defaultSerializers.entrySet()) {\r\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\r\n        }\r\n        for (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry : defaultSerializerClasses.entrySet()) {\r\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue());\r\n        }\r\n                kryo.register(type);\r\n                for (Class<?> type : registeredTypes) {\r\n            kryo.register(type);\r\n        }\r\n                for (Map.Entry<Class<?>, Class<? extends Serializer<?>>> e : registeredTypesWithSerializerClasses.entrySet()) {\r\n            Class<?> typeClass = e.getKey();\r\n            Class<? extends Serializer<?>> serializerClass = e.getValue();\r\n            Serializer<?> serializer = ReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\r\n            kryo.register(typeClass, serializer);\r\n        }\r\n                for (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> e : registeredTypesWithSerializers.entrySet()) {\r\n            kryo.register(e.getKey(), e.getValue().getSerializer());\r\n        }\r\n                kryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\r\n        kryo.setRegistrationRequired(false);\r\n        kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\r\n    }\r\n}","lc":0.6363636364,"pi":0.0956937799,"ma":0.6,"nbd":0.0,"ml":-0.25,"d":0.1388888889,"mi":-0.525017618,"fo":1.8333333333,"r":-0.0263157895,"e":0.5288958812}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-1895_24db0eb9","label":0,"code":"private void recurse(ResolutionNode node, Map resolvedArtifacts, Map managedVersions, ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List listeners) throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException {\r\n    fireEvent(ResolutionListener.TEST_ARTIFACT, listeners, node);\r\n    \/\/ TODO: use as a conflict resolver\r\n    Object key = node.getKey();\r\n    if (managedVersions.containsKey(key)) {\r\n        Artifact artifact = (Artifact) managedVersions.get(key);\r\n        fireEvent(ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact);\r\n        if (artifact.getVersion() != null) {\r\n            node.getArtifact().setVersion(artifact.getVersion());\r\n        }\r\n        if (artifact.getScope() != null) {\r\n            node.getArtifact().setScope(artifact.getScope());\r\n        }\r\n    }\r\n    List previousNodes = (List) resolvedArtifacts.get(key);\r\n    if (previousNodes != null) {\r\n        for (Iterator i = previousNodes.iterator(); i.hasNext(); ) {\r\n            ResolutionNode previous = (ResolutionNode) i.next();\r\n            if (previous.isActive()) {\r\n                \/\/ Version mediation\r\n                VersionRange previousRange = previous.getArtifact().getVersionRange();\r\n                VersionRange currentRange = node.getArtifact().getVersionRange();\r\n                \/\/ TODO: why do we force the version on it? what if they don't match?\r\n                if (previousRange == null) {\r\n                    \/\/ version was already resolved\r\n                    node.getArtifact().setVersion(previous.getArtifact().getVersion());\r\n                } else if (currentRange == null) {\r\n                    \/\/ version was already resolved\r\n                    previous.getArtifact().setVersion(node.getArtifact().getVersion());\r\n                } else {\r\n                    \/\/ TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended\r\n                    \/\/ version but the restriction is identical\r\n                    VersionRange newRange = previousRange.restrict(currentRange);\r\n                    \/\/ TODO: ick. this forces the OCE that should have come from the previous call. It is still correct\r\n                    if (newRange.isSelectedVersionKnown(previous.getArtifact())) {\r\n                        fireEvent(ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(), newRange);\r\n                    }\r\n                    previous.getArtifact().setVersionRange(newRange);\r\n                    node.getArtifact().setVersionRange(currentRange.restrict(previousRange));\r\n                    \/\/ Select an appropriate available version from the (now restricted) range\r\n                    \/\/ Note this version was selected before to get the appropriate POM\r\n                    \/\/ But it was reset by the call to setVersionRange on restricting the version\r\n                    ResolutionNode[] resetNodes = { previous, node };\r\n                    for (int j = 0; j < 2; j++) {\r\n                        Artifact resetArtifact = resetNodes[j].getArtifact();\r\n                        if (resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null && resetArtifact.getAvailableVersions() != null) {\r\n                            resetArtifact.selectVersion(resetArtifact.getVersionRange().matchVersion(resetArtifact.getAvailableVersions()).toString());\r\n                            fireEvent(ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j]);\r\n                        }\r\n                    }\r\n                }\r\n                \/\/ Conflict Resolution\r\n                \/\/ TODO: use as conflict resolver(s), chain\r\n                \/\/ TODO: should this be part of mediation?\r\n                \/\/ previous one is more dominant\r\n                ResolutionNode nearest, farthest;\r\n                if (previous.getDepth() <= node.getDepth()) {\r\n                    nearest = previous;\r\n                    farthest = node;\r\n                } else {\r\n                    nearest = node;\r\n                    farthest = previous;\r\n                }\r\n                \/* if we need to update scope of nearest to use farthest scope *\/\r\n                if (checkScopeUpdate(farthest, nearest, listeners)) {\r\n                    fireEvent(ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthest.getArtifact());\r\n                    \/\/ previously we cloned the artifact, but it is more effecient to just update the scope\r\n                    \/\/ if problems are later discovered that the original object needs its original scope value, cloning may\r\n                    \/\/ again be appropriate\r\n                    nearest.getArtifact().setScope(farthest.getArtifact().getScope());\r\n                }\r\n                fireEvent(ResolutionListener.OMIT_FOR_NEARER, listeners, farthest, nearest.getArtifact());\r\n                farthest.disable();\r\n            }\r\n        }\r\n    } else {\r\n        previousNodes = new ArrayList();\r\n        resolvedArtifacts.put(key, previousNodes);\r\n    }\r\n    previousNodes.add(node);\r\n    if (node.isActive()) {\r\n        fireEvent(ResolutionListener.INCLUDE_ARTIFACT, listeners, node);\r\n    }\r\n    \/\/ don't pull in the transitive deps of a system-scoped dependency.\r\n    if (node.isActive() && !Artifact.SCOPE_SYSTEM.equals(node.getArtifact().getScope())) {\r\n        fireEvent(ResolutionListener.PROCESS_CHILDREN, listeners, node);\r\n        for (Iterator i = node.getChildrenIterator(); i.hasNext(); ) {\r\n            ResolutionNode child = (ResolutionNode) i.next();\r\n            \/\/ We leave in optional ones, but don't pick up its dependencies\r\n            if (!child.isResolved() && (!child.getArtifact().isOptional() || child.isChildOfRootNode())) {\r\n                Artifact artifact = child.getArtifact();\r\n                try {\r\n                    if (artifact.getVersion() == null) {\r\n                        \/\/ set the recommended version\r\n                        \/\/ TODO: maybe its better to just pass the range through to retrieval and use a transformation?\r\n                        ArtifactVersion version;\r\n                        if (!artifact.isSelectedVersionKnown()) {\r\n                            List versions = artifact.getAvailableVersions();\r\n                            if (versions == null) {\r\n                                versions = source.retrieveAvailableVersions(artifact, localRepository, remoteRepositories);\r\n                                artifact.setAvailableVersions(versions);\r\n                            }\r\n                            VersionRange versionRange = artifact.getVersionRange();\r\n                            version = versionRange.matchVersion(versions);\r\n                            if (version == null) {\r\n                                if (versions.isEmpty()) {\r\n                                    throw new OverConstrainedVersionException(\"No versions are present in the repository for the artifact with a range \" + versionRange, artifact, remoteRepositories);\r\n                                } else {\r\n                                    throw new OverConstrainedVersionException(\"Couldn't find a version in \" + versions + \" to match range \" + versionRange, artifact, remoteRepositories);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            version = artifact.getSelectedVersion();\r\n                        }\r\n                        artifact.selectVersion(version.toString());\r\n                        fireEvent(ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child);\r\n                    }\r\n                    artifact.setDependencyTrail(node.getDependencyTrail());\r\n                    ResolutionGroup rGroup = source.retrieve(artifact, localRepository, remoteRepositories);\r\n                    \/\/ and catch here rather than have it return null\r\n                    if (rGroup == null) {\r\n                        \/\/ relocated dependency artifact is declared excluded, no need to add and recurse further\r\n                        continue;\r\n                    }\r\n                    child.addDependencies(rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter);\r\n                } catch (CyclicDependencyException e) {\r\n                    \/\/ would like to throw this, but we have crappy stuff in the repo\r\n                    fireEvent(ResolutionListener.OMIT_FOR_CYCLE, listeners, new ResolutionNode(e.getArtifact(), remoteRepositories, child));\r\n                } catch (ArtifactMetadataRetrievalException e) {\r\n                    artifact.setDependencyTrail(node.getDependencyTrail());\r\n                    throw new ArtifactResolutionException(\"Unable to get dependency information: \" + e.getMessage(), artifact, remoteRepositories, e);\r\n                }\r\n                recurse(child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter, listeners);\r\n            }\r\n        }\r\n        fireEvent(ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void recurse(ResolutionNode node, Map resolvedArtifacts, Map managedVersions, ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List listeners) throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException {\r\n    fireEvent(ResolutionListener.TEST_ARTIFACT, listeners, node);\r\n        Object key = node.getKey();\r\n    if (managedVersions.containsKey(key)) {\r\n        Artifact artifact = (Artifact) managedVersions.get(key);\r\n        fireEvent(ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact);\r\n        if (artifact.getVersion() != null) {\r\n            node.getArtifact().setVersion(artifact.getVersion());\r\n        }\r\n        if (artifact.getScope() != null) {\r\n            node.getArtifact().setScope(artifact.getScope());\r\n        }\r\n    }\r\n    List previousNodes = (List) resolvedArtifacts.get(key);\r\n    if (previousNodes != null) {\r\n        for (Iterator i = previousNodes.iterator(); i.hasNext(); ) {\r\n            ResolutionNode previous = (ResolutionNode) i.next();\r\n            if (previous.isActive()) {\r\n                                VersionRange previousRange = previous.getArtifact().getVersionRange();\r\n                VersionRange currentRange = node.getArtifact().getVersionRange();\r\n                                if (previousRange == null) {\r\n                                        node.getArtifact().setVersion(previous.getArtifact().getVersion());\r\n                } else if (currentRange == null) {\r\n                                        previous.getArtifact().setVersion(node.getArtifact().getVersion());\r\n                } else {\r\n                                                            VersionRange newRange = previousRange.restrict(currentRange);\r\n                                        if (newRange.isSelectedVersionKnown(previous.getArtifact())) {\r\n                        fireEvent(ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(), newRange);\r\n                    }\r\n                    previous.getArtifact().setVersionRange(newRange);\r\n                    node.getArtifact().setVersionRange(currentRange.restrict(previousRange));\r\n                                                                                ResolutionNode[] resetNodes = { previous, node };\r\n                    for (int j = 0; j < 2; j++) {\r\n                        Artifact resetArtifact = resetNodes[j].getArtifact();\r\n                        if (resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null && resetArtifact.getAvailableVersions() != null) {\r\n                            resetArtifact.selectVersion(resetArtifact.getVersionRange().matchVersion(resetArtifact.getAvailableVersions()).toString());\r\n                            fireEvent(ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j]);\r\n                        }\r\n                    }\r\n                }\r\n                                                                                ResolutionNode nearest, farthest;\r\n                if (previous.getDepth() <= node.getDepth()) {\r\n                    nearest = previous;\r\n                    farthest = node;\r\n                } else {\r\n                    nearest = node;\r\n                    farthest = previous;\r\n                }\r\n                                if (checkScopeUpdate(farthest, nearest, listeners)) {\r\n                    fireEvent(ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthest.getArtifact());\r\n                                                                                nearest.getArtifact().setScope(farthest.getArtifact().getScope());\r\n                }\r\n                fireEvent(ResolutionListener.OMIT_FOR_NEARER, listeners, farthest, nearest.getArtifact());\r\n                farthest.disable();\r\n            }\r\n        }\r\n    } else {\r\n        previousNodes = new ArrayList();\r\n        resolvedArtifacts.put(key, previousNodes);\r\n    }\r\n    previousNodes.add(node);\r\n    if (node.isActive()) {\r\n        fireEvent(ResolutionListener.INCLUDE_ARTIFACT, listeners, node);\r\n    }\r\n        if (node.isActive() && !Artifact.SCOPE_SYSTEM.equals(node.getArtifact().getScope())) {\r\n        fireEvent(ResolutionListener.PROCESS_CHILDREN, listeners, node);\r\n        for (Iterator i = node.getChildrenIterator(); i.hasNext(); ) {\r\n            ResolutionNode child = (ResolutionNode) i.next();\r\n                        if (!child.isResolved() && (!child.getArtifact().isOptional() || child.isChildOfRootNode())) {\r\n                Artifact artifact = child.getArtifact();\r\n                try {\r\n                    if (artifact.getVersion() == null) {\r\n                                                                        ArtifactVersion version;\r\n                        if (!artifact.isSelectedVersionKnown()) {\r\n                            List versions = artifact.getAvailableVersions();\r\n                            if (versions == null) {\r\n                                versions = source.retrieveAvailableVersions(artifact, localRepository, remoteRepositories);\r\n                                artifact.setAvailableVersions(versions);\r\n                            }\r\n                            VersionRange versionRange = artifact.getVersionRange();\r\n                            version = versionRange.matchVersion(versions);\r\n                            if (version == null) {\r\n                                if (versions.isEmpty()) {\r\n                                    throw new OverConstrainedVersionException(\"No versions are present in the repository for the artifact with a range \" + versionRange, artifact, remoteRepositories);\r\n                                } else {\r\n                                    throw new OverConstrainedVersionException(\"Couldn't find a version in \" + versions + \" to match range \" + versionRange, artifact, remoteRepositories);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            version = artifact.getSelectedVersion();\r\n                        }\r\n                        artifact.selectVersion(version.toString());\r\n                        fireEvent(ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child);\r\n                    }\r\n                    artifact.setDependencyTrail(node.getDependencyTrail());\r\n                    ResolutionGroup rGroup = source.retrieve(artifact, localRepository, remoteRepositories);\r\n                                        if (rGroup == null) {\r\n                                                continue;\r\n                    }\r\n                    child.addDependencies(rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter);\r\n                } catch (CyclicDependencyException e) {\r\n                                        fireEvent(ResolutionListener.OMIT_FOR_CYCLE, listeners, new ResolutionNode(e.getArtifact(), remoteRepositories, child));\r\n                } catch (ArtifactMetadataRetrievalException e) {\r\n                    artifact.setDependencyTrail(node.getDependencyTrail());\r\n                    throw new ArtifactResolutionException(\"Unable to get dependency information: \" + e.getMessage(), artifact, remoteRepositories, e);\r\n                }\r\n                recurse(child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source, filter, listeners);\r\n            }\r\n        }\r\n        fireEvent(ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node);\r\n    }\r\n}","lc":4.4545454545,"pi":2.6220095694,"ma":5.2,"nbd":3.0,"ml":4.5833333333,"d":3.1587301587,"mi":-1.5437632135,"fo":8.1666666667,"r":-0.0263157895,"e":24.134970004}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4301_50b52742","label":3,"code":"\/**\r\n *  @see org.apache.wicket.request.resource.AbstractResource#newResourceResponse(org.apache.wicket.request.resource.IResource.Attributes)\r\n *\/\r\n@Override\r\nprotected ResourceResponse newResourceResponse(final Attributes attributes) {\r\n    final ResourceResponse response = new ResourceResponse();\r\n    String contentType = this.contentType;\r\n    if (contentType == null) {\r\n        if (filename != null) {\r\n            contentType = URLConnection.getFileNameMap().getContentTypeFor(filename);\r\n        }\r\n        if (contentType == null) {\r\n            contentType = \"application\/octet-stream\";\r\n        }\r\n    }\r\n    response.setContentType(contentType);\r\n    response.setLastModified(lastModified);\r\n    final byte[] data = getData(attributes);\r\n    if (data == null) {\r\n        throw new WicketRuntimeException(\"ByteArrayResource's data cannot be 'null'.\");\r\n    }\r\n    response.setContentLength(data.length);\r\n    if (response.dataNeedsToBeWritten(attributes)) {\r\n        if (filename != null) {\r\n            response.setFileName(filename);\r\n            response.setContentDisposition(ContentDisposition.ATTACHMENT);\r\n        } else {\r\n            response.setContentDisposition(ContentDisposition.INLINE);\r\n        }\r\n        response.setWriteCallback(new WriteCallback() {\r\n\r\n            @Override\r\n            public void writeData(final Attributes attributes) {\r\n                attributes.getResponse().write(data);\r\n            }\r\n        });\r\n        configureResponse(response, attributes);\r\n    }\r\n    return response;\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.request.resource.AbstractResource#newResourceResponse(org.apache.wicket.request.resource.IResource.Attributes)\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected ResourceResponse newResourceResponse(final Attributes attributes) {\r\n    final ResourceResponse response = new ResourceResponse();\r\n    String contentType = this.contentType;\r\n    if (contentType == null) {\r\n        if (filename != null) {\r\n            contentType = URLConnection.getFileNameMap().getContentTypeFor(filename);\r\n        }\r\n        if (contentType == null) {\r\n            contentType = \"application\/octet-stream\";\r\n        }\r\n    }\r\n    response.setContentType(contentType);\r\n    response.setLastModified(lastModified);\r\n    final byte[] data = getData(attributes);\r\n    if (data == null) {\r\n        throw new WicketRuntimeException(\"ByteArrayResource's data cannot be 'null'.\");\r\n    }\r\n    response.setContentLength(data.length);\r\n    if (response.dataNeedsToBeWritten(attributes)) {\r\n        if (filename != null) {\r\n            response.setFileName(filename);\r\n            response.setContentDisposition(ContentDisposition.ATTACHMENT);\r\n        } else {\r\n            response.setContentDisposition(ContentDisposition.INLINE);\r\n        }\r\n        response.setWriteCallback(new WriteCallback() {\r\n\r\n            @Override\r\n            public void writeData(final Attributes attributes) {\r\n                attributes.getResponse().write(data);\r\n            }\r\n        });\r\n        configureResponse(response, attributes);\r\n    }\r\n    return response;\r\n}","lc":1.0,"pi":0.4497607656,"ma":0.8,"nbd":0.0,"ml":0.5,"d":0.0376984127,"mi":-0.6025369979,"fo":0.6666666667,"r":-0.0263157895,"e":0.2473239859}
{"project_name":"Closure","project_version":"127","label":2,"code":"\/**\r\n * Tries to remove n if it is an unconditional branch node (break, continue,\r\n * or return) and the target of n is the same as the the follow of n.\r\n * That is, if removing n preserves the control flow. Also if n targets\r\n * another unconditional branch, this function will recursively try to\r\n * remove the target branch as well. The reason why we want to cascade this\r\n * removal is because we only run this pass once. If we have code such as\r\n *\r\n * break -> break -> break\r\n *\r\n * where all 3 breaks are useless, then the order of removal matters. When\r\n * we first look at the first break, we see that it branches to the 2nd\r\n * break. However, if we remove the last break, the 2nd break becomes\r\n * useless and finally the first break becomes useless as well.\r\n *\r\n * @returns The target of this jump. If the target is also useless jump,\r\n *     the target of that useless jump recursively.\r\n *\/\r\n@SuppressWarnings(\"fallthrough\")\r\nprivate void tryRemoveUnconditionalBranching(Node n) {\r\n    \/\/ If n is null the target is the end of the function, nothing to do.\r\n    if (n == null) {\r\n        return;\r\n    }\r\n    DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\r\n    if (gNode == null) {\r\n        return;\r\n    }\r\n    switch(n.getType()) {\r\n        case Token.RETURN:\r\n            if (n.hasChildren()) {\r\n                break;\r\n            }\r\n        case Token.BREAK:\r\n        case Token.CONTINUE:\r\n            \/\/ We are looking for a control flow changing statement that always\r\n            \/\/ branches to the same node. If after removing it control still\r\n            \/\/ branches to the same node, it is safe to remove.\r\n            List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();\r\n            if (outEdges.size() == 1 && \/\/ If there is a next node, this jump is not useless.\r\n            (n.getNext() == null || n.getNext().isFunction())) {\r\n                Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\r\n                Node fallThrough = computeFollowing(n);\r\n                Node nextCfgNode = outEdges.get(0).getDestination().getValue();\r\n                if (nextCfgNode == fallThrough) {\r\n                    removeNode(n);\r\n                }\r\n            }\r\n    }\r\n}","code_comment":"\/**\r\n * Tries to remove n if it is an unconditional branch node (break, continue,\r\n * or return) and the target of n is the same as the the follow of n.\r\n * That is, if removing n preserves the control flow. Also if n targets\r\n * another unconditional branch, this function will recursively try to\r\n * remove the target branch as well. The reason why we want to cascade this\r\n * removal is because we only run this pass once. If we have code such as\r\n *\r\n * break -> break -> break\r\n *\r\n * where all 3 breaks are useless, then the order of removal matters. When\r\n * we first look at the first break, we see that it branches to the 2nd\r\n * break. However, if we remove the last break, the 2nd break becomes\r\n * useless and finally the first break becomes useless as well.\r\n *\r\n * @returns The target of this jump. If the target is also useless jump,\r\n *     the target of that useless jump recursively.\r\n *\/\r\n","code_no_comment":"@SuppressWarnings(\"fallthrough\")\r\nprivate void tryRemoveUnconditionalBranching(Node n) {\r\n        if (n == null) {\r\n        return;\r\n    }\r\n    DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\r\n    if (gNode == null) {\r\n        return;\r\n    }\r\n    switch(n.getType()) {\r\n        case Token.RETURN:\r\n            if (n.hasChildren()) {\r\n                break;\r\n            }\r\n        case Token.BREAK:\r\n        case Token.CONTINUE:\r\n                                                List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();\r\n            if (outEdges.size() == 1 &&             (n.getNext() == null || n.getNext().isFunction())) {\r\n                Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\r\n                Node fallThrough = computeFollowing(n);\r\n                Node nextCfgNode = outEdges.get(0).getDestination().getValue();\r\n                if (nextCfgNode == fallThrough) {\r\n                    removeNode(n);\r\n                }\r\n            }\r\n    }\r\n}","lc":0.6363636364,"pi":1.2679425837,"ma":1.2,"nbd":1.0,"ml":1.1666666667,"d":0.3432539683,"mi":-0.4934460888,"fo":0.8333333333,"r":-0.0263157895,"e":0.5245391101}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-405_784e4f69","label":1,"code":"\/**\r\n * Get a Chi-Square-like value assuming the N residuals follow N\r\n * distinct normal distributions centered on 0 and whose variances are\r\n * the reciprocal of the weights.\r\n * @return chi-square value\r\n *\/\r\npublic double getChiSquare() {\r\n    double chiSquare = 0;\r\n    for (int i = 0; i < rows; ++i) {\r\n        final double residual = residuals[i];\r\n        chiSquare += residual * residual * residualsWeights[i];\r\n    }\r\n    return chiSquare;\r\n}","code_comment":"\/**\r\n * Get a Chi-Square-like value assuming the N residuals follow N\r\n * distinct normal distributions centered on 0 and whose variances are\r\n * the reciprocal of the weights.\r\n * @return chi-square value\r\n *\/\r\n","code_no_comment":"public double getChiSquare() {\r\n    double chiSquare = 0;\r\n    for (int i = 0; i < rows; ++i) {\r\n        final double residual = residuals[i];\r\n        chiSquare += residual * residual * residualsWeights[i];\r\n    }\r\n    return chiSquare;\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":0.4285714286,"mi":0.3471458774,"fo":-0.5,"r":2.5526315789,"e":0.0127406741}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * <p>Copies source to dest, copying the underlying data, so dest is\r\n * a new, independent copy of source.  Does not contract before\r\n * the copy.<\/p>\r\n *\r\n * <p>Obtains synchronization locks on both source and dest\r\n * (in that order) before performing the copy.<\/p>\r\n *\r\n * <p>Neither source nor dest may be null; otherwise a {@link NullArgumentException}\r\n * is thrown<\/p>\r\n *\r\n * @param source ResizableDoubleArray to copy\r\n * @param dest ResizableArray to replace with a copy of the source array\r\n * @exception NullArgumentException if either source or dest is null\r\n * @since 2.0\r\n *\/\r\npublic static void copy(ResizableDoubleArray source, ResizableDoubleArray dest) throws NullArgumentException {\r\n    MathUtils.checkNotNull(source);\r\n    MathUtils.checkNotNull(dest);\r\n    synchronized (source) {\r\n        synchronized (dest) {\r\n            dest.contractionCriterion = source.contractionCriterion;\r\n            dest.expansionFactor = source.expansionFactor;\r\n            dest.expansionMode = source.expansionMode;\r\n            dest.internalArray = new double[source.internalArray.length];\r\n            System.arraycopy(source.internalArray, 0, dest.internalArray, 0, dest.internalArray.length);\r\n            dest.numElements = source.numElements;\r\n            dest.startIndex = source.startIndex;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * <p>Copies source to dest, copying the underlying data, so dest is\r\n * a new, independent copy of source.  Does not contract before\r\n * the copy.<\/p>\r\n *\r\n * <p>Obtains synchronization locks on both source and dest\r\n * (in that order) before performing the copy.<\/p>\r\n *\r\n * <p>Neither source nor dest may be null; otherwise a {@link NullArgumentException}\r\n * is thrown<\/p>\r\n *\r\n * @param source ResizableDoubleArray to copy\r\n * @param dest ResizableArray to replace with a copy of the source array\r\n * @exception NullArgumentException if either source or dest is null\r\n * @since 2.0\r\n *\/\r\n","code_no_comment":"public static void copy(ResizableDoubleArray source, ResizableDoubleArray dest) throws NullArgumentException {\r\n    MathUtils.checkNotNull(source);\r\n    MathUtils.checkNotNull(dest);\r\n    synchronized (source) {\r\n        synchronized (dest) {\r\n            dest.contractionCriterion = source.contractionCriterion;\r\n            dest.expansionFactor = source.expansionFactor;\r\n            dest.expansionMode = source.expansionMode;\r\n            dest.internalArray = new double[source.internalArray.length];\r\n            System.arraycopy(source.internalArray, 0, dest.internalArray, 0, dest.internalArray.length);\r\n            dest.numElements = source.numElements;\r\n            dest.startIndex = source.startIndex;\r\n        }\r\n    }\r\n}","lc":0.0454545455,"pi":0.7177033493,"ma":-0.6,"nbd":0.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.0703312192,"fo":-0.25,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-9243_1957a828","label":1,"code":"private void removeAllAbstractMethods(List<MethodInfo> methods) {\r\n    Iterator<MethodInfo> it = methods.iterator();\r\n    while (it.hasNext()) {\r\n        MethodInfo info = it.next();\r\n        if (Modifier.isAbstract(info.getMethod().getModifiers())) {\r\n            \/\/ we cannot invoke an abstract method\r\n            it.remove();\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void removeAllAbstractMethods(List<MethodInfo> methods) {\r\n    Iterator<MethodInfo> it = methods.iterator();\r\n    while (it.hasNext()) {\r\n        MethodInfo info = it.next();\r\n        if (Modifier.isAbstract(info.getMethod().getModifiers())) {\r\n                        it.remove();\r\n        }\r\n    }\r\n}","lc":-0.2272727273,"pi":0.3732057416,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":-0.3650793651,"mi":0.2766737139,"fo":0.0833333333,"r":0.2368421053,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1270_70564c7c","label":1,"code":"static Query getFullTextQuery(FullTextExpression ft, final Analyzer analyzer) {\r\n    \/\/ a reference to the query, so it can be set in the visitor\r\n    \/\/ (a \"non-local return\")\r\n    final AtomicReference<Query> result = new AtomicReference<Query>();\r\n    ft.accept(new FullTextVisitor() {\r\n\r\n        @Override\r\n        public boolean visit(FullTextOr or) {\r\n            BooleanQuery q = new BooleanQuery();\r\n            for (FullTextExpression e : or.list) {\r\n                Query x = getFullTextQuery(e, analyzer);\r\n                q.add(x, SHOULD);\r\n            }\r\n            result.set(q);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean visit(FullTextAnd and) {\r\n            BooleanQuery q = new BooleanQuery();\r\n            for (FullTextExpression e : and.list) {\r\n                Query x = getFullTextQuery(e, analyzer);\r\n                \/\/ Lucene can't deal with \"must(must_not(x))\"\r\n                if (x instanceof BooleanQuery) {\r\n                    BooleanQuery bq = (BooleanQuery) x;\r\n                    for (BooleanClause c : bq.clauses()) {\r\n                        q.add(c);\r\n                    }\r\n                } else {\r\n                    q.add(x, MUST);\r\n                }\r\n            }\r\n            result.set(q);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean visit(FullTextTerm term) {\r\n            String p = term.getPropertyName();\r\n            if (p != null && p.indexOf('\/') >= 0) {\r\n                \/\/ do not add constraints on child nodes properties\r\n                p = \"*\";\r\n            }\r\n            Query q = tokenToQuery(term.getText(), analyzer);\r\n            if (q == null) {\r\n                return false;\r\n            }\r\n            String boost = term.getBoost();\r\n            if (boost != null) {\r\n                q.setBoost(Float.parseFloat(boost));\r\n            }\r\n            if (term.isNot()) {\r\n                BooleanQuery bq = new BooleanQuery();\r\n                bq.add(q, MUST_NOT);\r\n                result.set(bq);\r\n            } else {\r\n                result.set(q);\r\n            }\r\n            return true;\r\n        }\r\n    });\r\n    return result.get();\r\n}","code_comment":null,"code_no_comment":"static Query getFullTextQuery(FullTextExpression ft, final Analyzer analyzer) {\r\n            final AtomicReference<Query> result = new AtomicReference<Query>();\r\n    ft.accept(new FullTextVisitor() {\r\n\r\n        @Override\r\n        public boolean visit(FullTextOr or) {\r\n            BooleanQuery q = new BooleanQuery();\r\n            for (FullTextExpression e : or.list) {\r\n                Query x = getFullTextQuery(e, analyzer);\r\n                q.add(x, SHOULD);\r\n            }\r\n            result.set(q);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean visit(FullTextAnd and) {\r\n            BooleanQuery q = new BooleanQuery();\r\n            for (FullTextExpression e : and.list) {\r\n                Query x = getFullTextQuery(e, analyzer);\r\n                                if (x instanceof BooleanQuery) {\r\n                    BooleanQuery bq = (BooleanQuery) x;\r\n                    for (BooleanClause c : bq.clauses()) {\r\n                        q.add(c);\r\n                    }\r\n                } else {\r\n                    q.add(x, MUST);\r\n                }\r\n            }\r\n            result.set(q);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean visit(FullTextTerm term) {\r\n            String p = term.getPropertyName();\r\n            if (p != null && p.indexOf('\/') >= 0) {\r\n                                p = \"*\";\r\n            }\r\n            Query q = tokenToQuery(term.getText(), analyzer);\r\n            if (q == null) {\r\n                return false;\r\n            }\r\n            String boost = term.getBoost();\r\n            if (boost != null) {\r\n                q.setBoost(Float.parseFloat(boost));\r\n            }\r\n            if (term.isNot()) {\r\n                BooleanQuery bq = new BooleanQuery();\r\n                bq.add(q, MUST_NOT);\r\n                result.set(bq);\r\n            } else {\r\n                result.set(q);\r\n            }\r\n            return true;\r\n        }\r\n    });\r\n    return result.get();\r\n}","lc":1.9090909091,"pi":0.8708133971,"ma":1.0,"nbd":1.0,"ml":0.5833333333,"d":0.626984127,"mi":-0.9081042988,"fo":1.25,"r":-0.0263157895,"e":1.8002939092}
{"project_name":"Math","project_version":"41","label":1,"code":"\/**\r\n * Returns the weighted variance of the entries in the specified portion of\r\n * the input array, using the precomputed weighted mean value.  Returns\r\n * <code>Double.NaN<\/code> if the designated subarray is empty.\r\n * <p>\r\n * Uses the formula <pre>\r\n *   &Sigma;(weights[i]*(values[i] - mean)<sup>2<\/sup>)\/(&Sigma;(weights[i]) - 1)\r\n * <\/pre><\/p>\r\n * <p>\r\n * The formula used assumes that the supplied mean value is the weighted arithmetic\r\n * mean of the sample data, not a known population parameter. This method\r\n * is supplied only to save computation when the mean has already been\r\n * computed.<\/p>\r\n * <p>\r\n * This formula will not return the same result as the unweighted variance when all\r\n * weights are equal, unless all weights are equal to 1. The formula assumes that\r\n * weights are to be treated as \"expansion values,\" as will be the case if for example\r\n * the weights represent frequency counts. To normalize weights so that the denominator\r\n * in the variance computation equals the length of the input vector minus one, use <pre>\r\n *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); <\/code>\r\n * <\/pre>\r\n * <p>\r\n * Returns 0 for a single-value (i.e. length = 1) sample.<\/p>\r\n * <p>\r\n * Throws <code>IllegalArgumentException<\/code> if any of the following are true:\r\n * <ul><li>the values array is null<\/li>\r\n *     <li>the weights array is null<\/li>\r\n *     <li>the weights array does not have the same length as the values array<\/li>\r\n *     <li>the weights array contains one or more infinite values<\/li>\r\n *     <li>the weights array contains one or more NaN values<\/li>\r\n *     <li>the weights array contains negative values<\/li>\r\n *     <li>the start and length arguments do not determine a valid array<\/li>\r\n * <\/ul><\/p>\r\n * <p>\r\n * Does not change the internal state of the statistic.<\/p>\r\n *\r\n * @param values the input array\r\n * @param weights the weights array\r\n * @param mean the precomputed weighted mean value\r\n * @param begin index of the first array element to include\r\n * @param length the number of elements to include\r\n * @return the variance of the values or Double.NaN if length = 0\r\n * @throws IllegalArgumentException if the parameters are not valid\r\n * @since 2.1\r\n *\/\r\npublic double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {\r\n    double var = Double.NaN;\r\n    if (test(values, weights, begin, length)) {\r\n        if (length == 1) {\r\n            var = 0.0;\r\n        } else if (length > 1) {\r\n            double accum = 0.0;\r\n            double dev = 0.0;\r\n            double accum2 = 0.0;\r\n            for (int i = begin; i < begin + length; i++) {\r\n                dev = values[i] - mean;\r\n                accum += weights[i] * (dev * dev);\r\n                accum2 += weights[i] * dev;\r\n            }\r\n            double sumWts = 0;\r\n            for (int i = 0; i < weights.length; i++) {\r\n                sumWts += weights[i];\r\n            }\r\n            if (isBiasCorrected) {\r\n                var = (accum - (accum2 * accum2 \/ sumWts)) \/ (sumWts - 1.0);\r\n            } else {\r\n                var = (accum - (accum2 * accum2 \/ sumWts)) \/ sumWts;\r\n            }\r\n        }\r\n    }\r\n    return var;\r\n}","code_comment":"\/**\r\n * Returns the weighted variance of the entries in the specified portion of\r\n * the input array, using the precomputed weighted mean value.  Returns\r\n * <code>Double.NaN<\/code> if the designated subarray is empty.\r\n * <p>\r\n * Uses the formula <pre>\r\n *   &Sigma;(weights[i]*(values[i] - mean)<sup>2<\/sup>)\/(&Sigma;(weights[i]) - 1)\r\n * <\/pre><\/p>\r\n * <p>\r\n * The formula used assumes that the supplied mean value is the weighted arithmetic\r\n * mean of the sample data, not a known population parameter. This method\r\n * is supplied only to save computation when the mean has already been\r\n * computed.<\/p>\r\n * <p>\r\n * This formula will not return the same result as the unweighted variance when all\r\n * weights are equal, unless all weights are equal to 1. The formula assumes that\r\n * weights are to be treated as \"expansion values,\" as will be the case if for example\r\n * the weights represent frequency counts. To normalize weights so that the denominator\r\n * in the variance computation equals the length of the input vector minus one, use <pre>\r\n *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); <\/code>\r\n * <\/pre>\r\n * <p>\r\n * Returns 0 for a single-value (i.e. length = 1) sample.<\/p>\r\n * <p>\r\n * Throws <code>IllegalArgumentException<\/code> if any of the following are true:\r\n * <ul><li>the values array is null<\/li>\r\n *     <li>the weights array is null<\/li>\r\n *     <li>the weights array does not have the same length as the values array<\/li>\r\n *     <li>the weights array contains one or more infinite values<\/li>\r\n *     <li>the weights array contains one or more NaN values<\/li>\r\n *     <li>the weights array contains negative values<\/li>\r\n *     <li>the start and length arguments do not determine a valid array<\/li>\r\n * <\/ul><\/p>\r\n * <p>\r\n * Does not change the internal state of the statistic.<\/p>\r\n *\r\n * @param values the input array\r\n * @param weights the weights array\r\n * @param mean the precomputed weighted mean value\r\n * @param begin index of the first array element to include\r\n * @param length the number of elements to include\r\n * @return the variance of the values or Double.NaN if length = 0\r\n * @throws IllegalArgumentException if the parameters are not valid\r\n * @since 2.1\r\n *\/\r\n","code_no_comment":"public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {\r\n    double var = Double.NaN;\r\n    if (test(values, weights, begin, length)) {\r\n        if (length == 1) {\r\n            var = 0.0;\r\n        } else if (length > 1) {\r\n            double accum = 0.0;\r\n            double dev = 0.0;\r\n            double accum2 = 0.0;\r\n            for (int i = begin; i < begin + length; i++) {\r\n                dev = values[i] - mean;\r\n                accum += weights[i] * (dev * dev);\r\n                accum2 += weights[i] * dev;\r\n            }\r\n            double sumWts = 0;\r\n            for (int i = 0; i < weights.length; i++) {\r\n                sumWts += weights[i];\r\n            }\r\n            if (isBiasCorrected) {\r\n                var = (accum - (accum2 * accum2 \/ sumWts)) \/ (sumWts - 1.0);\r\n            } else {\r\n                var = (accum - (accum2 * accum2 \/ sumWts)) \/ sumWts;\r\n            }\r\n        }\r\n    }\r\n    return var;\r\n}","lc":0.5909090909,"pi":0.8564593301,"ma":0.6,"nbd":1.0,"ml":0.75,"d":3.0357142857,"mi":-0.4909090909,"fo":-0.4166666667,"r":-0.0263157895,"e":3.9876558151}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"private BatchWriter getWriter(ByteBuffer login, String tableName, WriterOptions opts) throws Exception {\r\n    BatchWriterConfig cfg = new BatchWriterConfig();\r\n    if (opts != null) {\r\n        if (opts.maxMemory != 0)\r\n            cfg.setMaxMemory(opts.maxMemory);\r\n        if (opts.threads != 0)\r\n            cfg.setMaxWriteThreads(opts.threads);\r\n        if (opts.timeoutMs != 0)\r\n            cfg.setTimeout(opts.timeoutMs, TimeUnit.MILLISECONDS);\r\n        if (opts.latencyMs != 0)\r\n            cfg.setMaxLatency(opts.latencyMs, TimeUnit.MILLISECONDS);\r\n    }\r\n    return getConnector(login).createBatchWriter(tableName, cfg);\r\n}","code_comment":null,"code_no_comment":"private BatchWriter getWriter(ByteBuffer login, String tableName, WriterOptions opts) throws Exception {\r\n    BatchWriterConfig cfg = new BatchWriterConfig();\r\n    if (opts != null) {\r\n        if (opts.maxMemory != 0)\r\n            cfg.setMaxMemory(opts.maxMemory);\r\n        if (opts.threads != 0)\r\n            cfg.setMaxWriteThreads(opts.threads);\r\n        if (opts.timeoutMs != 0)\r\n            cfg.setTimeout(opts.timeoutMs, TimeUnit.MILLISECONDS);\r\n        if (opts.latencyMs != 0)\r\n            cfg.setMaxLatency(opts.latencyMs, TimeUnit.MILLISECONDS);\r\n    }\r\n    return getConnector(login).createBatchWriter(tableName, cfg);\r\n}","lc":0.0,"pi":0.5406698565,"ma":0.4,"nbd":-0.5,"ml":0.4166666667,"d":0.0317460317,"mi":-0.0917547569,"fo":0.0,"r":-0.0263157895,"e":0.0943021963}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-4467_79168a23","label":3,"code":"private void doStartCamel() throws Exception {\r\n    if (isStreamCaching()) {\r\n        \/\/ only add a new stream cache if not already configured\r\n        if (StreamCaching.getStreamCaching(this) == null) {\r\n            log.info(\"StreamCaching is enabled on CamelContext: \" + getName());\r\n            addInterceptStrategy(new StreamCaching());\r\n        }\r\n    }\r\n    if (isTracing()) {\r\n        \/\/ tracing is added in the DefaultChannel so we can enable it on the fly\r\n        log.info(\"Tracing is enabled on CamelContext: \" + getName());\r\n    }\r\n    if (isUseMDCLogging()) {\r\n        \/\/ log if MDC has been enabled\r\n        log.info(\"MDC logging is enabled on CamelContext: \" + getName());\r\n    }\r\n    if (isHandleFault()) {\r\n        \/\/ only add a new handle fault if not already configured\r\n        if (HandleFault.getHandleFault(this) == null) {\r\n            log.info(\"HandleFault is enabled on CamelContext: \" + getName());\r\n            addInterceptStrategy(new HandleFault());\r\n        }\r\n    }\r\n    if (getDelayer() != null && getDelayer() > 0) {\r\n        \/\/ only add a new delayer if not already configured\r\n        if (Delayer.getDelayer(this) == null) {\r\n            long millis = getDelayer();\r\n            log.info(\"Delayer is enabled with: \" + millis + \" ms. on CamelContext: \" + getName());\r\n            addInterceptStrategy(new Delayer(millis));\r\n        }\r\n    }\r\n    \/\/ register debugger\r\n    if (getDebugger() != null) {\r\n        log.info(\"Debugger: \" + getDebugger() + \" is enabled on CamelContext: \" + getName());\r\n        \/\/ register this camel context on the debugger\r\n        getDebugger().setCamelContext(this);\r\n        startService(getDebugger());\r\n        addInterceptStrategy(new Debug(getDebugger()));\r\n    }\r\n    \/\/ start management strategy before lifecycles are started\r\n    getManagementStrategy().start();\r\n    \/\/ start lifecycle strategies\r\n    Iterator<LifecycleStrategy> it = lifecycleStrategies.iterator();\r\n    while (it.hasNext()) {\r\n        LifecycleStrategy strategy = it.next();\r\n        try {\r\n            strategy.onContextStart(this);\r\n        } catch (VetoCamelContextStartException e) {\r\n            \/\/ okay we should not start Camel since it was vetoed\r\n            log.warn(\"Lifecycle strategy vetoed starting CamelContext (\" + getName() + \")\", e);\r\n            throw e;\r\n        } catch (Exception e) {\r\n            log.warn(\"Lifecycle strategy \" + strategy + \" failed starting CamelContext (\" + getName() + \")\", e);\r\n            throw e;\r\n        }\r\n    }\r\n    \/\/ start notifiers as services\r\n    for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {\r\n        if (notifier instanceof Service) {\r\n            Service service = (Service) notifier;\r\n            for (LifecycleStrategy strategy : lifecycleStrategies) {\r\n                strategy.onServiceAdd(this, service, null);\r\n            }\r\n        }\r\n        if (notifier instanceof Service) {\r\n            startService((Service) notifier);\r\n        }\r\n    }\r\n    \/\/ must let some bootstrap service be started before we can notify the starting event\r\n    EventHelper.notifyCamelContextStarting(this);\r\n    forceLazyInitialization();\r\n    \/\/ re-create endpoint registry as the cache size limit may be set after the constructor of this instance was called.\r\n    \/\/ and we needed to create endpoints up-front as it may be accessed before this context is started\r\n    endpoints = new EndpointRegistry(this, endpoints);\r\n    addService(endpoints);\r\n    addService(executorServiceManager);\r\n    addService(producerServicePool);\r\n    addService(inflightRepository);\r\n    addService(shutdownStrategy);\r\n    addService(packageScanClassResolver);\r\n    startServices(components.values());\r\n    \/\/ start the route definitions before the routes is started\r\n    startRouteDefinitions(routeDefinitions);\r\n    \/\/ start routes\r\n    if (doNotStartRoutesOnFirstStart) {\r\n        log.info(\"Cannot start routes as CamelContext has been configured with autoStartup=false\");\r\n    }\r\n    \/\/ invoke this logic to warmup the routes and if possible also start the routes\r\n    doStartOrResumeRoutes(routeServices, true, !doNotStartRoutesOnFirstStart, false, true);\r\n\/\/ starting will continue in the start method\r\n}","code_comment":null,"code_no_comment":"private void doStartCamel() throws Exception {\r\n    if (isStreamCaching()) {\r\n                if (StreamCaching.getStreamCaching(this) == null) {\r\n            log.info(\"StreamCaching is enabled on CamelContext: \" + getName());\r\n            addInterceptStrategy(new StreamCaching());\r\n        }\r\n    }\r\n    if (isTracing()) {\r\n                log.info(\"Tracing is enabled on CamelContext: \" + getName());\r\n    }\r\n    if (isUseMDCLogging()) {\r\n                log.info(\"MDC logging is enabled on CamelContext: \" + getName());\r\n    }\r\n    if (isHandleFault()) {\r\n                if (HandleFault.getHandleFault(this) == null) {\r\n            log.info(\"HandleFault is enabled on CamelContext: \" + getName());\r\n            addInterceptStrategy(new HandleFault());\r\n        }\r\n    }\r\n    if (getDelayer() != null && getDelayer() > 0) {\r\n                if (Delayer.getDelayer(this) == null) {\r\n            long millis = getDelayer();\r\n            log.info(\"Delayer is enabled with: \" + millis + \" ms. on CamelContext: \" + getName());\r\n            addInterceptStrategy(new Delayer(millis));\r\n        }\r\n    }\r\n        if (getDebugger() != null) {\r\n        log.info(\"Debugger: \" + getDebugger() + \" is enabled on CamelContext: \" + getName());\r\n                getDebugger().setCamelContext(this);\r\n        startService(getDebugger());\r\n        addInterceptStrategy(new Debug(getDebugger()));\r\n    }\r\n        getManagementStrategy().start();\r\n        Iterator<LifecycleStrategy> it = lifecycleStrategies.iterator();\r\n    while (it.hasNext()) {\r\n        LifecycleStrategy strategy = it.next();\r\n        try {\r\n            strategy.onContextStart(this);\r\n        } catch (VetoCamelContextStartException e) {\r\n                        log.warn(\"Lifecycle strategy vetoed starting CamelContext (\" + getName() + \")\", e);\r\n            throw e;\r\n        } catch (Exception e) {\r\n            log.warn(\"Lifecycle strategy \" + strategy + \" failed starting CamelContext (\" + getName() + \")\", e);\r\n            throw e;\r\n        }\r\n    }\r\n        for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {\r\n        if (notifier instanceof Service) {\r\n            Service service = (Service) notifier;\r\n            for (LifecycleStrategy strategy : lifecycleStrategies) {\r\n                strategy.onServiceAdd(this, service, null);\r\n            }\r\n        }\r\n        if (notifier instanceof Service) {\r\n            startService((Service) notifier);\r\n        }\r\n    }\r\n        EventHelper.notifyCamelContextStarting(this);\r\n    forceLazyInitialization();\r\n            endpoints = new EndpointRegistry(this, endpoints);\r\n    addService(endpoints);\r\n    addService(executorServiceManager);\r\n    addService(producerServicePool);\r\n    addService(inflightRepository);\r\n    addService(shutdownStrategy);\r\n    addService(packageScanClassResolver);\r\n    startServices(components.values());\r\n        startRouteDefinitions(routeDefinitions);\r\n        if (doNotStartRoutesOnFirstStart) {\r\n        log.info(\"Cannot start routes as CamelContext has been configured with autoStartup=false\");\r\n    }\r\n        doStartOrResumeRoutes(routeServices, true, !doNotStartRoutesOnFirstStart, false, true);\r\n}","lc":2.6818181818,"pi":0.2392344498,"ma":3.2,"nbd":0.5,"ml":1.75,"d":0.8253968254,"mi":-1.1423537703,"fo":4.5,"r":-0.0263157895,"e":2.9753588861}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3079_33c18762","label":1,"code":"\/**\r\n * Recover the correct _lastRev updates for the given candidate nodes.\r\n *\r\n * @param suspects the potential suspects\r\n * @param clusterId the cluster id for which _lastRev recovery needed\r\n * @param dryRun if {@code true}, this method will only perform a check\r\n *               but not apply the changes to the _lastRev fields.\r\n * @return the number of documents that required recovery. This method\r\n *          returns the number of the affected documents even if\r\n *          {@code dryRun} is set true and no document was changed.\r\n *\/\r\npublic int recover(Iterator<NodeDocument> suspects, int clusterId, boolean dryRun) {\r\n    UnsavedModifications unsaved = new UnsavedModifications();\r\n    UnsavedModifications unsavedParents = new UnsavedModifications();\r\n    \/\/ Map of known last rev of checked paths\r\n    Map<String, Revision> knownLastRevs = MapFactory.getInstance().create();\r\n    final DocumentStore docStore = nodeStore.getDocumentStore();\r\n    final JournalEntry changes = JOURNAL.newDocument(docStore);\r\n    long count = 0;\r\n    while (suspects.hasNext()) {\r\n        NodeDocument doc = suspects.next();\r\n        count++;\r\n        if (count % 100000 == 0) {\r\n            log.info(\"Scanned {} suspects so far...\", count);\r\n        }\r\n        Revision currentLastRev = doc.getLastRev().get(clusterId);\r\n        if (currentLastRev != null) {\r\n            knownLastRevs.put(doc.getPath(), currentLastRev);\r\n        }\r\n        \/\/ 1. determine last committed modification on document\r\n        Revision lastModifiedRev = determineLastModification(doc, clusterId);\r\n        Revision lastRevForParents = Utils.max(lastModifiedRev, currentLastRev);\r\n        \/\/ 2. Update lastRev for parent paths aka rollup\r\n        if (lastRevForParents != null) {\r\n            String path = doc.getPath();\r\n            \/\/ track all changes\r\n            changes.modified(path);\r\n            while (true) {\r\n                if (PathUtils.denotesRoot(path)) {\r\n                    break;\r\n                }\r\n                path = PathUtils.getParentPath(path);\r\n                unsavedParents.put(path, lastRevForParents);\r\n            }\r\n        }\r\n    }\r\n    for (String parentPath : unsavedParents.getPaths()) {\r\n        Revision calcLastRev = unsavedParents.get(parentPath);\r\n        Revision knownLastRev = knownLastRevs.get(parentPath);\r\n        \/\/ This check ensures that unnecessary updates are not made\r\n        if (knownLastRev == null || calcLastRev.compareRevisionTime(knownLastRev) > 0) {\r\n            unsaved.put(parentPath, calcLastRev);\r\n        }\r\n    }\r\n    \/\/ take the root's lastRev\r\n    final Revision lastRootRev = unsaved.get(\"\/\");\r\n    \/\/ Note the size before persist as persist operation\r\n    \/\/ would empty the internal state\r\n    int size = unsaved.getPaths().size();\r\n    String updates = unsaved.toString();\r\n    if (dryRun) {\r\n        log.info(\"Dry run of lastRev recovery identified [{}] documents for \" + \"cluster node [{}]: {}\", size, clusterId, updates);\r\n    } else {\r\n        \/\/ UnsavedModifications is designed to be used in concurrent\r\n        \/\/ access mode. For recovery case there is no concurrent access\r\n        \/\/ involve so just pass a new lock instance\r\n        \/\/ the lock uses to do the persisting is a plain reentrant lock\r\n        \/\/ thus it doesn't matter, where exactly the check is done\r\n        \/\/ as to whether the recovered lastRev has already been\r\n        \/\/ written to the journal.\r\n        unsaved.persist(nodeStore, new UnsavedModifications.Snapshot() {\r\n\r\n            @Override\r\n            public void acquiring() {\r\n                if (lastRootRev == null) {\r\n                    \/\/ then we cannot and probably don't have to persist anything\r\n                    return;\r\n                }\r\n                \/\/ lastRootRev never null at this point\r\n                final String id = JournalEntry.asId(lastRootRev);\r\n                final JournalEntry existingEntry = docStore.find(Collection.JOURNAL, id);\r\n                if (existingEntry != null) {\r\n                    \/\/ hence: nothing to be done here. return.\r\n                    return;\r\n                }\r\n                \/\/ otherwise store a new journal entry now\r\n                docStore.create(JOURNAL, singletonList(changes.asUpdateOp(lastRootRev)));\r\n            }\r\n        }, new ReentrantLock());\r\n        log.info(\"Updated lastRev of [{}] documents while performing lastRev recovery for \" + \"cluster node [{}]: {}\", size, clusterId, updates);\r\n    }\r\n    return size;\r\n}","code_comment":"\/**\r\n * Recover the correct _lastRev updates for the given candidate nodes.\r\n *\r\n * @param suspects the potential suspects\r\n * @param clusterId the cluster id for which _lastRev recovery needed\r\n * @param dryRun if {@code true}, this method will only perform a check\r\n *               but not apply the changes to the _lastRev fields.\r\n * @return the number of documents that required recovery. This method\r\n *          returns the number of the affected documents even if\r\n *          {@code dryRun} is set true and no document was changed.\r\n *\/\r\n","code_no_comment":"public int recover(Iterator<NodeDocument> suspects, int clusterId, boolean dryRun) {\r\n    UnsavedModifications unsaved = new UnsavedModifications();\r\n    UnsavedModifications unsavedParents = new UnsavedModifications();\r\n        Map<String, Revision> knownLastRevs = MapFactory.getInstance().create();\r\n    final DocumentStore docStore = nodeStore.getDocumentStore();\r\n    final JournalEntry changes = JOURNAL.newDocument(docStore);\r\n    long count = 0;\r\n    while (suspects.hasNext()) {\r\n        NodeDocument doc = suspects.next();\r\n        count++;\r\n        if (count % 100000 == 0) {\r\n            log.info(\"Scanned {} suspects so far...\", count);\r\n        }\r\n        Revision currentLastRev = doc.getLastRev().get(clusterId);\r\n        if (currentLastRev != null) {\r\n            knownLastRevs.put(doc.getPath(), currentLastRev);\r\n        }\r\n                Revision lastModifiedRev = determineLastModification(doc, clusterId);\r\n        Revision lastRevForParents = Utils.max(lastModifiedRev, currentLastRev);\r\n                if (lastRevForParents != null) {\r\n            String path = doc.getPath();\r\n                        changes.modified(path);\r\n            while (true) {\r\n                if (PathUtils.denotesRoot(path)) {\r\n                    break;\r\n                }\r\n                path = PathUtils.getParentPath(path);\r\n                unsavedParents.put(path, lastRevForParents);\r\n            }\r\n        }\r\n    }\r\n    for (String parentPath : unsavedParents.getPaths()) {\r\n        Revision calcLastRev = unsavedParents.get(parentPath);\r\n        Revision knownLastRev = knownLastRevs.get(parentPath);\r\n                if (knownLastRev == null || calcLastRev.compareRevisionTime(knownLastRev) > 0) {\r\n            unsaved.put(parentPath, calcLastRev);\r\n        }\r\n    }\r\n        final Revision lastRootRev = unsaved.get(\"\/\");\r\n            int size = unsaved.getPaths().size();\r\n    String updates = unsaved.toString();\r\n    if (dryRun) {\r\n        log.info(\"Dry run of lastRev recovery identified [{}] documents for \" + \"cluster node [{}]: {}\", size, clusterId, updates);\r\n    } else {\r\n                                                                unsaved.persist(nodeStore, new UnsavedModifications.Snapshot() {\r\n\r\n            @Override\r\n            public void acquiring() {\r\n                if (lastRootRev == null) {\r\n                                        return;\r\n                }\r\n                                final String id = JournalEntry.asId(lastRootRev);\r\n                final JournalEntry existingEntry = docStore.find(Collection.JOURNAL, id);\r\n                if (existingEntry != null) {\r\n                                        return;\r\n                }\r\n                                docStore.create(JOURNAL, singletonList(changes.asUpdateOp(lastRootRev)));\r\n            }\r\n        }, new ReentrantLock());\r\n        log.info(\"Updated lastRev of [{}] documents while performing lastRev recovery for \" + \"cluster node [{}]: {}\", size, clusterId, updates);\r\n    }\r\n    return size;\r\n}","lc":2.1818181818,"pi":0.995215311,"ma":1.8,"nbd":1.0,"ml":1.4166666667,"d":1.4523809524,"mi":-1.0436927414,"fo":2.4166666667,"r":-0.0263157895,"e":5.3699509575}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1167_259f10c0","label":3,"code":"private boolean visit(DumpableNode<?> node, PrintWriter writer, boolean first) {\r\n    \/\/ check for duplicate traversal\r\n    if (this.nodeIds.containsKey(node)) {\r\n        return false;\r\n    }\r\n    \/\/ assign an id first\r\n    this.nodeIds.put(node, this.nodeCnt++);\r\n    \/\/ then recurse\r\n    for (DumpableNode<?> child : node.getPredecessors()) {\r\n        \/\/ to set first to false!\r\n        if (visit(child, writer, first)) {\r\n            first = false;\r\n        }\r\n        ;\r\n    }\r\n    \/\/ check if this node should be skipped from the dump\r\n    final OptimizerNode n = node.getOptimizerNode();\r\n    \/\/ start a new node and output node id\r\n    if (!first) {\r\n        writer.print(\",\\n\");\r\n    }\r\n    \/\/ open the node\r\n    writer.print(\"\\t{\\n\");\r\n    \/\/ recurse, it is is an iteration node\r\n    if (node instanceof BulkIterationNode || node instanceof BulkIterationPlanNode) {\r\n        DumpableNode<?> innerChild = node instanceof BulkIterationNode ? ((BulkIterationNode) node).getNextPartialSolution() : ((BulkIterationPlanNode) node).getRootOfStepFunction();\r\n        DumpableNode<?> begin = node instanceof BulkIterationNode ? ((BulkIterationNode) node).getPartialSolution() : ((BulkIterationPlanNode) node).getPartialSolutionPlanNode();\r\n        writer.print(\"\\t\\t\\\"step_function\\\": [\\n\");\r\n        visit(innerChild, writer, true);\r\n        writer.print(\"\\n\\t\\t],\\n\");\r\n        writer.print(\"\\t\\t\\\"partial_solution\\\": \" + this.nodeIds.get(begin) + \",\\n\");\r\n        writer.print(\"\\t\\t\\\"next_partial_solution\\\": \" + this.nodeIds.get(innerChild) + \",\\n\");\r\n    } else if (node instanceof WorksetIterationNode || node instanceof WorksetIterationPlanNode) {\r\n        DumpableNode<?> worksetRoot = node instanceof WorksetIterationNode ? ((WorksetIterationNode) node).getNextWorkset() : ((WorksetIterationPlanNode) node).getNextWorkSetPlanNode();\r\n        DumpableNode<?> solutionDelta = node instanceof WorksetIterationNode ? ((WorksetIterationNode) node).getSolutionSetDelta() : ((WorksetIterationPlanNode) node).getSolutionSetDeltaPlanNode();\r\n        DumpableNode<?> workset = node instanceof WorksetIterationNode ? ((WorksetIterationNode) node).getWorksetNode() : ((WorksetIterationPlanNode) node).getWorksetPlanNode();\r\n        DumpableNode<?> solutionSet = node instanceof WorksetIterationNode ? ((WorksetIterationNode) node).getSolutionSetNode() : ((WorksetIterationPlanNode) node).getSolutionSetPlanNode();\r\n        writer.print(\"\\t\\t\\\"step_function\\\": [\\n\");\r\n        visit(worksetRoot, writer, true);\r\n        visit(solutionDelta, writer, false);\r\n        writer.print(\"\\n\\t\\t],\\n\");\r\n        writer.print(\"\\t\\t\\\"workset\\\": \" + this.nodeIds.get(workset) + \",\\n\");\r\n        writer.print(\"\\t\\t\\\"solution_set\\\": \" + this.nodeIds.get(solutionSet) + \",\\n\");\r\n        writer.print(\"\\t\\t\\\"next_workset\\\": \" + this.nodeIds.get(worksetRoot) + \",\\n\");\r\n        writer.print(\"\\t\\t\\\"solution_delta\\\": \" + this.nodeIds.get(solutionDelta) + \",\\n\");\r\n    }\r\n    \/\/ print the id\r\n    writer.print(\"\\t\\t\\\"id\\\": \" + this.nodeIds.get(node));\r\n    final String type;\r\n    final String contents;\r\n    if (n instanceof DataSinkNode) {\r\n        type = \"sink\";\r\n        contents = n.getPactContract().toString();\r\n    } else if (n instanceof DataSourceNode) {\r\n        type = \"source\";\r\n        contents = n.getPactContract().toString();\r\n    } else if (n instanceof BulkIterationNode) {\r\n        type = \"bulk_iteration\";\r\n        contents = n.getPactContract().getName();\r\n    } else if (n instanceof WorksetIterationNode) {\r\n        type = \"workset_iteration\";\r\n        contents = n.getPactContract().getName();\r\n    } else if (n instanceof BinaryUnionNode) {\r\n        type = \"pact\";\r\n        contents = \"\";\r\n    } else {\r\n        type = \"pact\";\r\n        contents = n.getPactContract().getName();\r\n    }\r\n    String name = n.getName();\r\n    if (name.equals(\"Reduce\") && (node instanceof SingleInputPlanNode) && ((SingleInputPlanNode) node).getDriverStrategy() == DriverStrategy.SORTED_GROUP_COMBINE) {\r\n        name = \"Combine\";\r\n    }\r\n    \/\/ output the type identifier\r\n    writer.print(\",\\n\\t\\t\\\"type\\\": \\\"\" + type + \"\\\"\");\r\n    \/\/ output node name\r\n    writer.print(\",\\n\\t\\t\\\"pact\\\": \\\"\" + name + \"\\\"\");\r\n    \/\/ output node contents\r\n    writer.print(\",\\n\\t\\t\\\"contents\\\": \\\"\" + contents + \"\\\"\");\r\n    \/\/ degree of parallelism\r\n    writer.print(\",\\n\\t\\t\\\"parallelism\\\": \\\"\" + (n.getDegreeOfParallelism() >= 1 ? n.getDegreeOfParallelism() : \"default\") + \"\\\"\");\r\n    \/\/ output node predecessors\r\n    Iterator<? extends DumpableConnection<?>> inConns = node.getDumpableInputs().iterator();\r\n    String child1name = \"\", child2name = \"\";\r\n    if (inConns != null && inConns.hasNext()) {\r\n        \/\/ start predecessor list\r\n        writer.print(\",\\n\\t\\t\\\"predecessors\\\": [\");\r\n        int connNum = 0;\r\n        int inputNum = 0;\r\n        while (inConns.hasNext()) {\r\n            final DumpableConnection<?> conn = inConns.next();\r\n            final Collection<DumpableConnection<?>> inConnsForInput;\r\n            if (conn.getSource() instanceof NAryUnionPlanNode) {\r\n                inConnsForInput = new ArrayList<DumpableConnection<?>>();\r\n                for (DumpableConnection<?> inputOfUnion : conn.getSource().getDumpableInputs()) {\r\n                    inConnsForInput.add(inputOfUnion);\r\n                }\r\n            } else {\r\n                inConnsForInput = Collections.<DumpableConnection<?>>singleton(conn);\r\n            }\r\n            for (DumpableConnection<?> inConn : inConnsForInput) {\r\n                final DumpableNode<?> source = inConn.getSource();\r\n                writer.print(connNum == 0 ? \"\\n\" : \",\\n\");\r\n                if (connNum == 0) {\r\n                    child1name += child1name.length() > 0 ? \", \" : \"\";\r\n                    child1name += source.getOptimizerNode().getPactContract().getName();\r\n                } else if (connNum == 1) {\r\n                    child2name += child2name.length() > 0 ? \", \" : \"\";\r\n                    child2name = source.getOptimizerNode().getPactContract().getName();\r\n                }\r\n                \/\/ output predecessor id\r\n                writer.print(\"\\t\\t\\t{\\\"id\\\": \" + this.nodeIds.get(source));\r\n                \/\/ output connection side\r\n                if (inConns.hasNext() || inputNum > 0) {\r\n                    writer.print(\", \\\"side\\\": \\\"\" + (inputNum == 0 ? \"first\" : \"second\") + \"\\\"\");\r\n                }\r\n                \/\/ output shipping strategy and channel type\r\n                final Channel channel = (inConn instanceof Channel) ? (Channel) inConn : null;\r\n                final ShipStrategyType shipType = channel != null ? channel.getShipStrategy() : ((PactConnection) inConn).getShipStrategy();\r\n                String shipStrategy = null;\r\n                if (shipType != null) {\r\n                    switch(shipType) {\r\n                        case NONE:\r\n                            \/\/ nothing\r\n                            break;\r\n                        case FORWARD:\r\n                            shipStrategy = \"Forward\";\r\n                            break;\r\n                        case BROADCAST:\r\n                            shipStrategy = \"Broadcast\";\r\n                            break;\r\n                        case PARTITION_HASH:\r\n                            shipStrategy = \"Hash Partition\";\r\n                            break;\r\n                        case PARTITION_RANGE:\r\n                            shipStrategy = \"Range Partition\";\r\n                            break;\r\n                        case PARTITION_RANDOM:\r\n                            shipStrategy = \"Redistribute\";\r\n                            break;\r\n                        case PARTITION_FORCED_REBALANCE:\r\n                            shipStrategy = \"Rebalance\";\r\n                            break;\r\n                        default:\r\n                            throw new CompilerException(\"Unknown ship strategy '\" + conn.getShipStrategy().name() + \"' in JSON generator.\");\r\n                    }\r\n                }\r\n                if (channel != null && channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {\r\n                    shipStrategy += \" on \" + (channel.getShipStrategySortOrder() == null ? channel.getShipStrategyKeys().toString() : Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString());\r\n                }\r\n                if (shipStrategy != null) {\r\n                    writer.print(\", \\\"ship_strategy\\\": \\\"\" + shipStrategy + \"\\\"\");\r\n                }\r\n                if (channel != null) {\r\n                    String localStrategy = null;\r\n                    switch(channel.getLocalStrategy()) {\r\n                        case NONE:\r\n                            break;\r\n                        case SORT:\r\n                            localStrategy = \"Sort\";\r\n                            break;\r\n                        case COMBININGSORT:\r\n                            localStrategy = \"Sort (combining)\";\r\n                            break;\r\n                        default:\r\n                            throw new CompilerException(\"Unknown local strategy \" + channel.getLocalStrategy().name());\r\n                    }\r\n                    if (channel != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {\r\n                        localStrategy += \" on \" + (channel.getLocalStrategySortOrder() == null ? channel.getLocalStrategyKeys().toString() : Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString());\r\n                    }\r\n                    if (localStrategy != null) {\r\n                        writer.print(\", \\\"local_strategy\\\": \\\"\" + localStrategy + \"\\\"\");\r\n                    }\r\n                    if (channel != null && channel.getTempMode() != TempMode.NONE) {\r\n                        String tempMode = channel.getTempMode().toString();\r\n                        writer.print(\", \\\"temp_mode\\\": \\\"\" + tempMode + \"\\\"\");\r\n                    }\r\n                }\r\n                writer.print('}');\r\n                connNum++;\r\n            }\r\n            inputNum++;\r\n        }\r\n        \/\/ finish predecessors\r\n        writer.print(\"\\n\\t\\t]\");\r\n    }\r\n    \/\/ ---------------------------------------------------------------------------------------\r\n    \/\/ the part below here is relevant only to plan nodes with concrete strategies, etc\r\n    \/\/ ---------------------------------------------------------------------------------------\r\n    final PlanNode p = node.getPlanNode();\r\n    if (p == null) {\r\n        \/\/ finish node\r\n        writer.print(\"\\n\\t}\");\r\n        return true;\r\n    }\r\n    \/\/ local strategy\r\n    String locString = null;\r\n    if (p.getDriverStrategy() != null) {\r\n        switch(p.getDriverStrategy()) {\r\n            case NONE:\r\n            case BINARY_NO_OP:\r\n                break;\r\n            case UNARY_NO_OP:\r\n                locString = \"No-Op\";\r\n                break;\r\n            case COLLECTOR_MAP:\r\n            case MAP:\r\n                locString = \"Map\";\r\n                break;\r\n            case FLAT_MAP:\r\n                locString = \"FlatMap\";\r\n                break;\r\n            case MAP_PARTITION:\r\n                locString = \"Map Partition\";\r\n                break;\r\n            case ALL_REDUCE:\r\n                locString = \"Reduce All\";\r\n                break;\r\n            case ALL_GROUP_REDUCE:\r\n            case ALL_GROUP_COMBINE:\r\n                locString = \"Group Reduce All\";\r\n                break;\r\n            case SORTED_REDUCE:\r\n                locString = \"Sorted Reduce\";\r\n                break;\r\n            case SORTED_PARTIAL_REDUCE:\r\n                locString = \"Sorted Combine\/Reduce\";\r\n                break;\r\n            case SORTED_GROUP_REDUCE:\r\n                locString = \"Sorted Group Reduce\";\r\n                break;\r\n            case SORTED_GROUP_COMBINE:\r\n                locString = \"Sorted Combine\";\r\n                break;\r\n            case HYBRIDHASH_BUILD_FIRST:\r\n                locString = \"Hybrid Hash (build: \" + child1name + \")\";\r\n                break;\r\n            case HYBRIDHASH_BUILD_SECOND:\r\n                locString = \"Hybrid Hash (build: \" + child2name + \")\";\r\n                break;\r\n            case HYBRIDHASH_BUILD_FIRST_CACHED:\r\n                locString = \"Hybrid Hash (CACHED) (build: \" + child1name + \")\";\r\n                break;\r\n            case HYBRIDHASH_BUILD_SECOND_CACHED:\r\n                locString = \"Hybrid Hash (CACHED) (build: \" + child2name + \")\";\r\n                break;\r\n            case NESTEDLOOP_BLOCKED_OUTER_FIRST:\r\n                locString = \"Nested Loops (Blocked Outer: \" + child1name + \")\";\r\n                break;\r\n            case NESTEDLOOP_BLOCKED_OUTER_SECOND:\r\n                locString = \"Nested Loops (Blocked Outer: \" + child2name + \")\";\r\n                break;\r\n            case NESTEDLOOP_STREAMED_OUTER_FIRST:\r\n                locString = \"Nested Loops (Streamed Outer: \" + child1name + \")\";\r\n                break;\r\n            case NESTEDLOOP_STREAMED_OUTER_SECOND:\r\n                locString = \"Nested Loops (Streamed Outer: \" + child2name + \")\";\r\n                break;\r\n            case MERGE:\r\n                locString = \"Merge\";\r\n                break;\r\n            case CO_GROUP:\r\n                locString = \"Co-Group\";\r\n                break;\r\n            default:\r\n                locString = p.getDriverStrategy().name();\r\n                break;\r\n        }\r\n        if (locString != null) {\r\n            writer.print(\",\\n\\t\\t\\\"driver_strategy\\\": \\\"\");\r\n            writer.print(locString);\r\n            writer.print(\"\\\"\");\r\n        }\r\n    }\r\n    {\r\n        \/\/ output node global properties\r\n        final GlobalProperties gp = p.getGlobalProperties();\r\n        writer.print(\",\\n\\t\\t\\\"global_properties\\\": [\\n\");\r\n        addProperty(writer, \"Partitioning\", gp.getPartitioning().name(), true);\r\n        if (gp.getPartitioningFields() != null) {\r\n            addProperty(writer, \"Partitioned on\", gp.getPartitioningFields().toString(), false);\r\n        }\r\n        if (gp.getPartitioningOrdering() != null) {\r\n            addProperty(writer, \"Partitioning Order\", gp.getPartitioningOrdering().toString(), false);\r\n        } else {\r\n            addProperty(writer, \"Partitioning Order\", \"(none)\", false);\r\n        }\r\n        if (n.getUniqueFields() == null || n.getUniqueFields().size() == 0) {\r\n            addProperty(writer, \"Uniqueness\", \"not unique\", false);\r\n        } else {\r\n            addProperty(writer, \"Uniqueness\", n.getUniqueFields().toString(), false);\r\n        }\r\n        writer.print(\"\\n\\t\\t]\");\r\n    }\r\n    {\r\n        \/\/ output node local properties\r\n        LocalProperties lp = p.getLocalProperties();\r\n        writer.print(\",\\n\\t\\t\\\"local_properties\\\": [\\n\");\r\n        if (lp.getOrdering() != null) {\r\n            addProperty(writer, \"Order\", lp.getOrdering().toString(), true);\r\n        } else {\r\n            addProperty(writer, \"Order\", \"(none)\", true);\r\n        }\r\n        if (lp.getGroupedFields() != null && lp.getGroupedFields().size() > 0) {\r\n            addProperty(writer, \"Grouped on\", lp.getGroupedFields().toString(), false);\r\n        } else {\r\n            addProperty(writer, \"Grouping\", \"not grouped\", false);\r\n        }\r\n        if (n.getUniqueFields() == null || n.getUniqueFields().size() == 0) {\r\n            addProperty(writer, \"Uniqueness\", \"not unique\", false);\r\n        } else {\r\n            addProperty(writer, \"Uniqueness\", n.getUniqueFields().toString(), false);\r\n        }\r\n        writer.print(\"\\n\\t\\t]\");\r\n    }\r\n    \/\/ output node size estimates\r\n    writer.print(\",\\n\\t\\t\\\"estimates\\\": [\\n\");\r\n    addProperty(writer, \"Est. Output Size\", n.getEstimatedOutputSize() == -1 ? \"(unknown)\" : formatNumber(n.getEstimatedOutputSize(), \"B\"), true);\r\n    addProperty(writer, \"Est. Cardinality\", n.getEstimatedNumRecords() == -1 ? \"(unknown)\" : formatNumber(n.getEstimatedNumRecords()), false);\r\n    writer.print(\"\\t\\t]\");\r\n    \/\/ output node cost\r\n    if (p.getNodeCosts() != null) {\r\n        writer.print(\",\\n\\t\\t\\\"costs\\\": [\\n\");\r\n        addProperty(writer, \"Network\", p.getNodeCosts().getNetworkCost() == -1 ? \"(unknown)\" : formatNumber(p.getNodeCosts().getNetworkCost(), \"B\"), true);\r\n        addProperty(writer, \"Disk I\/O\", p.getNodeCosts().getDiskCost() == -1 ? \"(unknown)\" : formatNumber(p.getNodeCosts().getDiskCost(), \"B\"), false);\r\n        addProperty(writer, \"CPU\", p.getNodeCosts().getCpuCost() == -1 ? \"(unknown)\" : formatNumber(p.getNodeCosts().getCpuCost(), \"\"), false);\r\n        addProperty(writer, \"Cumulative Network\", p.getCumulativeCosts().getNetworkCost() == -1 ? \"(unknown)\" : formatNumber(p.getCumulativeCosts().getNetworkCost(), \"B\"), false);\r\n        addProperty(writer, \"Cumulative Disk I\/O\", p.getCumulativeCosts().getDiskCost() == -1 ? \"(unknown)\" : formatNumber(p.getCumulativeCosts().getDiskCost(), \"B\"), false);\r\n        addProperty(writer, \"Cumulative CPU\", p.getCumulativeCosts().getCpuCost() == -1 ? \"(unknown)\" : formatNumber(p.getCumulativeCosts().getCpuCost(), \"\"), false);\r\n        writer.print(\"\\n\\t\\t]\");\r\n    }\r\n    \/\/ output the node compiler hints\r\n    if (n.getPactContract().getCompilerHints() != null) {\r\n        CompilerHints hints = n.getPactContract().getCompilerHints();\r\n        CompilerHints defaults = new CompilerHints();\r\n        String size = hints.getOutputSize() == defaults.getOutputSize() ? \"(none)\" : String.valueOf(hints.getOutputSize());\r\n        String card = hints.getOutputCardinality() == defaults.getOutputCardinality() ? \"(none)\" : String.valueOf(hints.getOutputCardinality());\r\n        String width = hints.getAvgOutputRecordSize() == defaults.getAvgOutputRecordSize() ? \"(none)\" : String.valueOf(hints.getAvgOutputRecordSize());\r\n        String filter = hints.getFilterFactor() == defaults.getFilterFactor() ? \"(none)\" : String.valueOf(hints.getFilterFactor());\r\n        writer.print(\",\\n\\t\\t\\\"compiler_hints\\\": [\\n\");\r\n        addProperty(writer, \"Output Size (bytes)\", size, true);\r\n        addProperty(writer, \"Output Cardinality\", card, false);\r\n        addProperty(writer, \"Avg. Output Record Size (bytes)\", width, false);\r\n        addProperty(writer, \"Filter Factor\", filter, false);\r\n        writer.print(\"\\t\\t]\");\r\n    }\r\n    \/\/ finish node\r\n    writer.print(\"\\n\\t}\");\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"private boolean visit(DumpableNode<?> node, PrintWriter writer, boolean first) {\r\n        if (this.nodeIds.containsKey(node)) {\r\n        return false;\r\n    }\r\n        this.nodeIds.put(node, this.nodeCnt++);\r\n        for (DumpableNode<?> child : node.getPredecessors()) {\r\n                if (visit(child, writer, first)) {\r\n            first = false;\r\n        }\r\n        ;\r\n    }\r\n        final OptimizerNode n = node.getOptimizerNode();\r\n        if (!first) {\r\n        writer.print(\",\\n\");\r\n    }\r\n        writer.print(\"\\t{\\n\");\r\n        if (node instanceof BulkIterationNode || node instanceof BulkIterationPlanNode) {\r\n        DumpableNode<?> innerChild = node instanceof BulkIterationNode ? ((BulkIterationNode) node).getNextPartialSolution() : ((BulkIterationPlanNode) node).getRootOfStepFunction();\r\n        DumpableNode<?> begin = node instanceof BulkIterationNode ? ((BulkIterationNode) node).getPartialSolution() : ((BulkIterationPlanNode) node).getPartialSolutionPlanNode();\r\n        writer.print(\"\\t\\t\\\"step_function\\\": [\\n\");\r\n        visit(innerChild, writer, true);\r\n        writer.print(\"\\n\\t\\t],\\n\");\r\n        writer.print(\"\\t\\t\\\"partial_solution\\\": \" + this.nodeIds.get(begin) + \",\\n\");\r\n        writer.print(\"\\t\\t\\\"next_partial_solution\\\": \" + this.nodeIds.get(innerChild) + \",\\n\");\r\n    } else if (node instanceof WorksetIterationNode || node instanceof WorksetIterationPlanNode) {\r\n        DumpableNode<?> worksetRoot = node instanceof WorksetIterationNode ? ((WorksetIterationNode) node).getNextWorkset() : ((WorksetIterationPlanNode) node).getNextWorkSetPlanNode();\r\n        DumpableNode<?> solutionDelta = node instanceof WorksetIterationNode ? ((WorksetIterationNode) node).getSolutionSetDelta() : ((WorksetIterationPlanNode) node).getSolutionSetDeltaPlanNode();\r\n        DumpableNode<?> workset = node instanceof WorksetIterationNode ? ((WorksetIterationNode) node).getWorksetNode() : ((WorksetIterationPlanNode) node).getWorksetPlanNode();\r\n        DumpableNode<?> solutionSet = node instanceof WorksetIterationNode ? ((WorksetIterationNode) node).getSolutionSetNode() : ((WorksetIterationPlanNode) node).getSolutionSetPlanNode();\r\n        writer.print(\"\\t\\t\\\"step_function\\\": [\\n\");\r\n        visit(worksetRoot, writer, true);\r\n        visit(solutionDelta, writer, false);\r\n        writer.print(\"\\n\\t\\t],\\n\");\r\n        writer.print(\"\\t\\t\\\"workset\\\": \" + this.nodeIds.get(workset) + \",\\n\");\r\n        writer.print(\"\\t\\t\\\"solution_set\\\": \" + this.nodeIds.get(solutionSet) + \",\\n\");\r\n        writer.print(\"\\t\\t\\\"next_workset\\\": \" + this.nodeIds.get(worksetRoot) + \",\\n\");\r\n        writer.print(\"\\t\\t\\\"solution_delta\\\": \" + this.nodeIds.get(solutionDelta) + \",\\n\");\r\n    }\r\n        writer.print(\"\\t\\t\\\"id\\\": \" + this.nodeIds.get(node));\r\n    final String type;\r\n    final String contents;\r\n    if (n instanceof DataSinkNode) {\r\n        type = \"sink\";\r\n        contents = n.getPactContract().toString();\r\n    } else if (n instanceof DataSourceNode) {\r\n        type = \"source\";\r\n        contents = n.getPactContract().toString();\r\n    } else if (n instanceof BulkIterationNode) {\r\n        type = \"bulk_iteration\";\r\n        contents = n.getPactContract().getName();\r\n    } else if (n instanceof WorksetIterationNode) {\r\n        type = \"workset_iteration\";\r\n        contents = n.getPactContract().getName();\r\n    } else if (n instanceof BinaryUnionNode) {\r\n        type = \"pact\";\r\n        contents = \"\";\r\n    } else {\r\n        type = \"pact\";\r\n        contents = n.getPactContract().getName();\r\n    }\r\n    String name = n.getName();\r\n    if (name.equals(\"Reduce\") && (node instanceof SingleInputPlanNode) && ((SingleInputPlanNode) node).getDriverStrategy() == DriverStrategy.SORTED_GROUP_COMBINE) {\r\n        name = \"Combine\";\r\n    }\r\n        writer.print(\",\\n\\t\\t\\\"type\\\": \\\"\" + type + \"\\\"\");\r\n        writer.print(\",\\n\\t\\t\\\"pact\\\": \\\"\" + name + \"\\\"\");\r\n        writer.print(\",\\n\\t\\t\\\"contents\\\": \\\"\" + contents + \"\\\"\");\r\n        writer.print(\",\\n\\t\\t\\\"parallelism\\\": \\\"\" + (n.getDegreeOfParallelism() >= 1 ? n.getDegreeOfParallelism() : \"default\") + \"\\\"\");\r\n        Iterator<? extends DumpableConnection<?>> inConns = node.getDumpableInputs().iterator();\r\n    String child1name = \"\", child2name = \"\";\r\n    if (inConns != null && inConns.hasNext()) {\r\n                writer.print(\",\\n\\t\\t\\\"predecessors\\\": [\");\r\n        int connNum = 0;\r\n        int inputNum = 0;\r\n        while (inConns.hasNext()) {\r\n            final DumpableConnection<?> conn = inConns.next();\r\n            final Collection<DumpableConnection<?>> inConnsForInput;\r\n            if (conn.getSource() instanceof NAryUnionPlanNode) {\r\n                inConnsForInput = new ArrayList<DumpableConnection<?>>();\r\n                for (DumpableConnection<?> inputOfUnion : conn.getSource().getDumpableInputs()) {\r\n                    inConnsForInput.add(inputOfUnion);\r\n                }\r\n            } else {\r\n                inConnsForInput = Collections.<DumpableConnection<?>>singleton(conn);\r\n            }\r\n            for (DumpableConnection<?> inConn : inConnsForInput) {\r\n                final DumpableNode<?> source = inConn.getSource();\r\n                writer.print(connNum == 0 ? \"\\n\" : \",\\n\");\r\n                if (connNum == 0) {\r\n                    child1name += child1name.length() > 0 ? \", \" : \"\";\r\n                    child1name += source.getOptimizerNode().getPactContract().getName();\r\n                } else if (connNum == 1) {\r\n                    child2name += child2name.length() > 0 ? \", \" : \"\";\r\n                    child2name = source.getOptimizerNode().getPactContract().getName();\r\n                }\r\n                                writer.print(\"\\t\\t\\t{\\\"id\\\": \" + this.nodeIds.get(source));\r\n                                if (inConns.hasNext() || inputNum > 0) {\r\n                    writer.print(\", \\\"side\\\": \\\"\" + (inputNum == 0 ? \"first\" : \"second\") + \"\\\"\");\r\n                }\r\n                                final Channel channel = (inConn instanceof Channel) ? (Channel) inConn : null;\r\n                final ShipStrategyType shipType = channel != null ? channel.getShipStrategy() : ((PactConnection) inConn).getShipStrategy();\r\n                String shipStrategy = null;\r\n                if (shipType != null) {\r\n                    switch(shipType) {\r\n                        case NONE:\r\n                                                        break;\r\n                        case FORWARD:\r\n                            shipStrategy = \"Forward\";\r\n                            break;\r\n                        case BROADCAST:\r\n                            shipStrategy = \"Broadcast\";\r\n                            break;\r\n                        case PARTITION_HASH:\r\n                            shipStrategy = \"Hash Partition\";\r\n                            break;\r\n                        case PARTITION_RANGE:\r\n                            shipStrategy = \"Range Partition\";\r\n                            break;\r\n                        case PARTITION_RANDOM:\r\n                            shipStrategy = \"Redistribute\";\r\n                            break;\r\n                        case PARTITION_FORCED_REBALANCE:\r\n                            shipStrategy = \"Rebalance\";\r\n                            break;\r\n                        default:\r\n                            throw new CompilerException(\"Unknown ship strategy '\" + conn.getShipStrategy().name() + \"' in JSON generator.\");\r\n                    }\r\n                }\r\n                if (channel != null && channel.getShipStrategyKeys() != null && channel.getShipStrategyKeys().size() > 0) {\r\n                    shipStrategy += \" on \" + (channel.getShipStrategySortOrder() == null ? channel.getShipStrategyKeys().toString() : Utils.createOrdering(channel.getShipStrategyKeys(), channel.getShipStrategySortOrder()).toString());\r\n                }\r\n                if (shipStrategy != null) {\r\n                    writer.print(\", \\\"ship_strategy\\\": \\\"\" + shipStrategy + \"\\\"\");\r\n                }\r\n                if (channel != null) {\r\n                    String localStrategy = null;\r\n                    switch(channel.getLocalStrategy()) {\r\n                        case NONE:\r\n                            break;\r\n                        case SORT:\r\n                            localStrategy = \"Sort\";\r\n                            break;\r\n                        case COMBININGSORT:\r\n                            localStrategy = \"Sort (combining)\";\r\n                            break;\r\n                        default:\r\n                            throw new CompilerException(\"Unknown local strategy \" + channel.getLocalStrategy().name());\r\n                    }\r\n                    if (channel != null && channel.getLocalStrategyKeys() != null && channel.getLocalStrategyKeys().size() > 0) {\r\n                        localStrategy += \" on \" + (channel.getLocalStrategySortOrder() == null ? channel.getLocalStrategyKeys().toString() : Utils.createOrdering(channel.getLocalStrategyKeys(), channel.getLocalStrategySortOrder()).toString());\r\n                    }\r\n                    if (localStrategy != null) {\r\n                        writer.print(\", \\\"local_strategy\\\": \\\"\" + localStrategy + \"\\\"\");\r\n                    }\r\n                    if (channel != null && channel.getTempMode() != TempMode.NONE) {\r\n                        String tempMode = channel.getTempMode().toString();\r\n                        writer.print(\", \\\"temp_mode\\\": \\\"\" + tempMode + \"\\\"\");\r\n                    }\r\n                }\r\n                writer.print('}');\r\n                connNum++;\r\n            }\r\n            inputNum++;\r\n        }\r\n                writer.print(\"\\n\\t\\t]\");\r\n    }\r\n                final PlanNode p = node.getPlanNode();\r\n    if (p == null) {\r\n                writer.print(\"\\n\\t}\");\r\n        return true;\r\n    }\r\n        String locString = null;\r\n    if (p.getDriverStrategy() != null) {\r\n        switch(p.getDriverStrategy()) {\r\n            case NONE:\r\n            case BINARY_NO_OP:\r\n                break;\r\n            case UNARY_NO_OP:\r\n                locString = \"No-Op\";\r\n                break;\r\n            case COLLECTOR_MAP:\r\n            case MAP:\r\n                locString = \"Map\";\r\n                break;\r\n            case FLAT_MAP:\r\n                locString = \"FlatMap\";\r\n                break;\r\n            case MAP_PARTITION:\r\n                locString = \"Map Partition\";\r\n                break;\r\n            case ALL_REDUCE:\r\n                locString = \"Reduce All\";\r\n                break;\r\n            case ALL_GROUP_REDUCE:\r\n            case ALL_GROUP_COMBINE:\r\n                locString = \"Group Reduce All\";\r\n                break;\r\n            case SORTED_REDUCE:\r\n                locString = \"Sorted Reduce\";\r\n                break;\r\n            case SORTED_PARTIAL_REDUCE:\r\n                locString = \"Sorted Combine\/Reduce\";\r\n                break;\r\n            case SORTED_GROUP_REDUCE:\r\n                locString = \"Sorted Group Reduce\";\r\n                break;\r\n            case SORTED_GROUP_COMBINE:\r\n                locString = \"Sorted Combine\";\r\n                break;\r\n            case HYBRIDHASH_BUILD_FIRST:\r\n                locString = \"Hybrid Hash (build: \" + child1name + \")\";\r\n                break;\r\n            case HYBRIDHASH_BUILD_SECOND:\r\n                locString = \"Hybrid Hash (build: \" + child2name + \")\";\r\n                break;\r\n            case HYBRIDHASH_BUILD_FIRST_CACHED:\r\n                locString = \"Hybrid Hash (CACHED) (build: \" + child1name + \")\";\r\n                break;\r\n            case HYBRIDHASH_BUILD_SECOND_CACHED:\r\n                locString = \"Hybrid Hash (CACHED) (build: \" + child2name + \")\";\r\n                break;\r\n            case NESTEDLOOP_BLOCKED_OUTER_FIRST:\r\n                locString = \"Nested Loops (Blocked Outer: \" + child1name + \")\";\r\n                break;\r\n            case NESTEDLOOP_BLOCKED_OUTER_SECOND:\r\n                locString = \"Nested Loops (Blocked Outer: \" + child2name + \")\";\r\n                break;\r\n            case NESTEDLOOP_STREAMED_OUTER_FIRST:\r\n                locString = \"Nested Loops (Streamed Outer: \" + child1name + \")\";\r\n                break;\r\n            case NESTEDLOOP_STREAMED_OUTER_SECOND:\r\n                locString = \"Nested Loops (Streamed Outer: \" + child2name + \")\";\r\n                break;\r\n            case MERGE:\r\n                locString = \"Merge\";\r\n                break;\r\n            case CO_GROUP:\r\n                locString = \"Co-Group\";\r\n                break;\r\n            default:\r\n                locString = p.getDriverStrategy().name();\r\n                break;\r\n        }\r\n        if (locString != null) {\r\n            writer.print(\",\\n\\t\\t\\\"driver_strategy\\\": \\\"\");\r\n            writer.print(locString);\r\n            writer.print(\"\\\"\");\r\n        }\r\n    }\r\n    {\r\n                final GlobalProperties gp = p.getGlobalProperties();\r\n        writer.print(\",\\n\\t\\t\\\"global_properties\\\": [\\n\");\r\n        addProperty(writer, \"Partitioning\", gp.getPartitioning().name(), true);\r\n        if (gp.getPartitioningFields() != null) {\r\n            addProperty(writer, \"Partitioned on\", gp.getPartitioningFields().toString(), false);\r\n        }\r\n        if (gp.getPartitioningOrdering() != null) {\r\n            addProperty(writer, \"Partitioning Order\", gp.getPartitioningOrdering().toString(), false);\r\n        } else {\r\n            addProperty(writer, \"Partitioning Order\", \"(none)\", false);\r\n        }\r\n        if (n.getUniqueFields() == null || n.getUniqueFields().size() == 0) {\r\n            addProperty(writer, \"Uniqueness\", \"not unique\", false);\r\n        } else {\r\n            addProperty(writer, \"Uniqueness\", n.getUniqueFields().toString(), false);\r\n        }\r\n        writer.print(\"\\n\\t\\t]\");\r\n    }\r\n    {\r\n                LocalProperties lp = p.getLocalProperties();\r\n        writer.print(\",\\n\\t\\t\\\"local_properties\\\": [\\n\");\r\n        if (lp.getOrdering() != null) {\r\n            addProperty(writer, \"Order\", lp.getOrdering().toString(), true);\r\n        } else {\r\n            addProperty(writer, \"Order\", \"(none)\", true);\r\n        }\r\n        if (lp.getGroupedFields() != null && lp.getGroupedFields().size() > 0) {\r\n            addProperty(writer, \"Grouped on\", lp.getGroupedFields().toString(), false);\r\n        } else {\r\n            addProperty(writer, \"Grouping\", \"not grouped\", false);\r\n        }\r\n        if (n.getUniqueFields() == null || n.getUniqueFields().size() == 0) {\r\n            addProperty(writer, \"Uniqueness\", \"not unique\", false);\r\n        } else {\r\n            addProperty(writer, \"Uniqueness\", n.getUniqueFields().toString(), false);\r\n        }\r\n        writer.print(\"\\n\\t\\t]\");\r\n    }\r\n        writer.print(\",\\n\\t\\t\\\"estimates\\\": [\\n\");\r\n    addProperty(writer, \"Est. Output Size\", n.getEstimatedOutputSize() == -1 ? \"(unknown)\" : formatNumber(n.getEstimatedOutputSize(), \"B\"), true);\r\n    addProperty(writer, \"Est. Cardinality\", n.getEstimatedNumRecords() == -1 ? \"(unknown)\" : formatNumber(n.getEstimatedNumRecords()), false);\r\n    writer.print(\"\\t\\t]\");\r\n        if (p.getNodeCosts() != null) {\r\n        writer.print(\",\\n\\t\\t\\\"costs\\\": [\\n\");\r\n        addProperty(writer, \"Network\", p.getNodeCosts().getNetworkCost() == -1 ? \"(unknown)\" : formatNumber(p.getNodeCosts().getNetworkCost(), \"B\"), true);\r\n        addProperty(writer, \"Disk I\/O\", p.getNodeCosts().getDiskCost() == -1 ? \"(unknown)\" : formatNumber(p.getNodeCosts().getDiskCost(), \"B\"), false);\r\n        addProperty(writer, \"CPU\", p.getNodeCosts().getCpuCost() == -1 ? \"(unknown)\" : formatNumber(p.getNodeCosts().getCpuCost(), \"\"), false);\r\n        addProperty(writer, \"Cumulative Network\", p.getCumulativeCosts().getNetworkCost() == -1 ? \"(unknown)\" : formatNumber(p.getCumulativeCosts().getNetworkCost(), \"B\"), false);\r\n        addProperty(writer, \"Cumulative Disk I\/O\", p.getCumulativeCosts().getDiskCost() == -1 ? \"(unknown)\" : formatNumber(p.getCumulativeCosts().getDiskCost(), \"B\"), false);\r\n        addProperty(writer, \"Cumulative CPU\", p.getCumulativeCosts().getCpuCost() == -1 ? \"(unknown)\" : formatNumber(p.getCumulativeCosts().getCpuCost(), \"\"), false);\r\n        writer.print(\"\\n\\t\\t]\");\r\n    }\r\n        if (n.getPactContract().getCompilerHints() != null) {\r\n        CompilerHints hints = n.getPactContract().getCompilerHints();\r\n        CompilerHints defaults = new CompilerHints();\r\n        String size = hints.getOutputSize() == defaults.getOutputSize() ? \"(none)\" : String.valueOf(hints.getOutputSize());\r\n        String card = hints.getOutputCardinality() == defaults.getOutputCardinality() ? \"(none)\" : String.valueOf(hints.getOutputCardinality());\r\n        String width = hints.getAvgOutputRecordSize() == defaults.getAvgOutputRecordSize() ? \"(none)\" : String.valueOf(hints.getAvgOutputRecordSize());\r\n        String filter = hints.getFilterFactor() == defaults.getFilterFactor() ? \"(none)\" : String.valueOf(hints.getFilterFactor());\r\n        writer.print(\",\\n\\t\\t\\\"compiler_hints\\\": [\\n\");\r\n        addProperty(writer, \"Output Size (bytes)\", size, true);\r\n        addProperty(writer, \"Output Cardinality\", card, false);\r\n        addProperty(writer, \"Avg. Output Record Size (bytes)\", width, false);\r\n        addProperty(writer, \"Filter Factor\", filter, false);\r\n        writer.print(\"\\t\\t]\");\r\n    }\r\n        writer.print(\"\\n\\t}\");\r\n    return true;\r\n}","lc":13.8636363636,"pi":1.8325358852,"ma":26.6,"nbd":2.0,"ml":13.5833333333,"d":3.9226190476,"mi":-2.8841437632,"fo":20.1666666667,"r":-0.0263157895,"e":93.3752805104}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-867_bfbb156d","label":1,"code":"\/**\r\n * Initialization of the dynamic search parameters\r\n *\r\n * @param guess Initial guess for the arguments of the fitness function.\r\n *\/\r\nprivate void initializeCMA(double[] guess) {\r\n    if (lambda <= 0) {\r\n        lambda = 4 + (int) (3. * Math.log(dimension));\r\n    }\r\n    \/\/ initialize sigma\r\n    double[][] sigmaArray = new double[guess.length][1];\r\n    for (int i = 0; i < guess.length; i++) {\r\n        final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\r\n        sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) \/ range;\r\n    }\r\n    RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\r\n    \/\/ overall standard deviation\r\n    sigma = max(insigma);\r\n    \/\/ initialize termination criteria\r\n    stopTolUpX = 1e3 * max(insigma);\r\n    stopTolX = 1e-11 * max(insigma);\r\n    stopTolFun = 1e-12;\r\n    stopTolHistFun = 1e-13;\r\n    \/\/ initialize selection strategy parameters\r\n    \/\/ number of parents\/points for recombination\r\n    mu = lambda \/ 2;\r\n    logMu2 = Math.log(mu + 0.5);\r\n    weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2);\r\n    double sumw = 0;\r\n    double sumwq = 0;\r\n    for (int i = 0; i < mu; i++) {\r\n        double w = weights.getEntry(i, 0);\r\n        sumw += w;\r\n        sumwq += w * w;\r\n    }\r\n    weights = weights.scalarMultiply(1. \/ sumw);\r\n    \/\/ variance-effectiveness of sum w_i x_i\r\n    mueff = sumw * sumw \/ sumwq;\r\n    \/\/ initialize dynamic strategy parameters and constants\r\n    cc = (4. + mueff \/ dimension) \/ (dimension + 4. + 2. * mueff \/ dimension);\r\n    cs = (mueff + 2.) \/ (dimension + mueff + 3.);\r\n    damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) \/ (dimension + 1.)) - 1.)) * Math.max(0.3, 1. - dimension \/ (1e-6 + Math.min(maxIterations, getMaxEvaluations() \/ lambda))) + \/\/ minor increment\r\n    cs;\r\n    ccov1 = 2. \/ ((dimension + 1.3) * (dimension + 1.3) + mueff);\r\n    ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. \/ mueff) \/ ((dimension + 2.) * (dimension + 2.) + mueff));\r\n    ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) \/ 3.);\r\n    ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) \/ 3.);\r\n    chiN = Math.sqrt(dimension) * (1. - 1. \/ (4. * dimension) + 1 \/ (21. * dimension * dimension));\r\n    \/\/ intialize CMA internal values - updated each generation\r\n    \/\/ objective\r\n    xmean = MatrixUtils.createColumnRealMatrix(guess);\r\n    \/\/ variables\r\n    diagD = insigma.scalarMultiply(1. \/ sigma);\r\n    diagC = square(diagD);\r\n    \/\/ evolution paths for C and sigma\r\n    pc = zeros(dimension, 1);\r\n    \/\/ B defines the coordinate system\r\n    ps = zeros(dimension, 1);\r\n    normps = ps.getFrobeniusNorm();\r\n    B = eye(dimension, dimension);\r\n    \/\/ diagonal D defines the scaling\r\n    D = ones(dimension, 1);\r\n    BD = times(B, repmat(diagD.transpose(), dimension, 1));\r\n    \/\/ covariance\r\n    C = B.multiply(diag(square(D)).multiply(B.transpose()));\r\n    historySize = 10 + (int) (3. * 10. * dimension \/ lambda);\r\n    \/\/ history of fitness values\r\n    fitnessHistory = new double[historySize];\r\n    for (int i = 0; i < historySize; i++) {\r\n        fitnessHistory[i] = Double.MAX_VALUE;\r\n    }\r\n}","code_comment":"\/**\r\n * Initialization of the dynamic search parameters\r\n *\r\n * @param guess Initial guess for the arguments of the fitness function.\r\n *\/\r\n","code_no_comment":"private void initializeCMA(double[] guess) {\r\n    if (lambda <= 0) {\r\n        lambda = 4 + (int) (3. * Math.log(dimension));\r\n    }\r\n        double[][] sigmaArray = new double[guess.length][1];\r\n    for (int i = 0; i < guess.length; i++) {\r\n        final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\r\n        sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) \/ range;\r\n    }\r\n    RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\r\n        sigma = max(insigma);\r\n        stopTolUpX = 1e3 * max(insigma);\r\n    stopTolX = 1e-11 * max(insigma);\r\n    stopTolFun = 1e-12;\r\n    stopTolHistFun = 1e-13;\r\n            mu = lambda \/ 2;\r\n    logMu2 = Math.log(mu + 0.5);\r\n    weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2);\r\n    double sumw = 0;\r\n    double sumwq = 0;\r\n    for (int i = 0; i < mu; i++) {\r\n        double w = weights.getEntry(i, 0);\r\n        sumw += w;\r\n        sumwq += w * w;\r\n    }\r\n    weights = weights.scalarMultiply(1. \/ sumw);\r\n        mueff = sumw * sumw \/ sumwq;\r\n        cc = (4. + mueff \/ dimension) \/ (dimension + 4. + 2. * mueff \/ dimension);\r\n    cs = (mueff + 2.) \/ (dimension + mueff + 3.);\r\n    damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) \/ (dimension + 1.)) - 1.)) * Math.max(0.3, 1. - dimension \/ (1e-6 + Math.min(maxIterations, getMaxEvaluations() \/ lambda))) +     cs;\r\n    ccov1 = 2. \/ ((dimension + 1.3) * (dimension + 1.3) + mueff);\r\n    ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. \/ mueff) \/ ((dimension + 2.) * (dimension + 2.) + mueff));\r\n    ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) \/ 3.);\r\n    ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) \/ 3.);\r\n    chiN = Math.sqrt(dimension) * (1. - 1. \/ (4. * dimension) + 1 \/ (21. * dimension * dimension));\r\n            xmean = MatrixUtils.createColumnRealMatrix(guess);\r\n        diagD = insigma.scalarMultiply(1. \/ sigma);\r\n    diagC = square(diagD);\r\n        pc = zeros(dimension, 1);\r\n        ps = zeros(dimension, 1);\r\n    normps = ps.getFrobeniusNorm();\r\n    B = eye(dimension, dimension);\r\n        D = ones(dimension, 1);\r\n    BD = times(B, repmat(diagD.transpose(), dimension, 1));\r\n        C = B.multiply(diag(square(D)).multiply(B.transpose()));\r\n    historySize = 10 + (int) (3. * 10. * dimension \/ lambda);\r\n        fitnessHistory = new double[historySize];\r\n    for (int i = 0; i < historySize; i++) {\r\n        fitnessHistory[i] = Double.MAX_VALUE;\r\n    }\r\n}","lc":1.7272727273,"pi":-0.6555023923,"ma":0.6,"nbd":-0.5,"ml":0.6666666667,"d":2.4007936508,"mi":-1.0225510923,"fo":2.5,"r":-0.0263157895,"e":16.2825515926}
{"project_name":"Math","project_version":"94","label":3,"code":"\/**\r\n * <p>\r\n * Gets the greatest common divisor of the absolute value of two numbers,\r\n * using the \"binary gcd\" method which avoids division and modulo\r\n * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\r\n * Stein (1961).\r\n * <\/p>\r\n *\r\n * @param u a non-zero number\r\n * @param v a non-zero number\r\n * @return the greatest common divisor, never zero\r\n * @since 1.1\r\n *\/\r\npublic static int gcd(int u, int v) {\r\n    if (u * v == 0) {\r\n        return (Math.abs(u) + Math.abs(v));\r\n    }\r\n    \/* assert u!=0 && v!=0; *\/\r\n    if (u > 0) {\r\n        u = -u;\r\n    }\r\n    \/\/ make u negative\r\n    if (v > 0) {\r\n        v = -v;\r\n    }\r\n    \/\/ make v negative\r\n    \/\/ B1. [Find power of 2]\r\n    int k = 0;\r\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\r\n        \/\/ while u and v are\r\n        \/\/ both even...\r\n        u \/= 2;\r\n        v \/= 2;\r\n        \/\/ cast out twos.\r\n        k++;\r\n    }\r\n    if (k == 31) {\r\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\r\n    }\r\n    \/\/ B2. Initialize: u and v have been divided by 2^k and at least\r\n    \/\/ one is odd.\r\n    int t = ((u & 1) == 1) ? v : -(u \/ 2);\r\n    \/\/ t positive: u was even, v is odd (t replaces u)\r\n    do {\r\n        \/\/ B4\/B3: cast out twos from t.\r\n        while ((t & 1) == 0) {\r\n            \/\/ while t is even..\r\n            \/\/ cast out twos\r\n            t \/= 2;\r\n        }\r\n        \/\/ B5 [reset max(u,v)]\r\n        if (t > 0) {\r\n            u = -t;\r\n        } else {\r\n            v = t;\r\n        }\r\n        \/\/ B6\/B3. at this point both u and v should be odd.\r\n        t = (v - u) \/ 2;\r\n    \/\/ |u| larger: t positive (replace u)\r\n    \/\/ |v| larger: t negative (replace v)\r\n    } while (t != 0);\r\n    \/\/ gcd is u*2^k\r\n    return -u * (1 << k);\r\n}","code_comment":"\/**\r\n * <p>\r\n * Gets the greatest common divisor of the absolute value of two numbers,\r\n * using the \"binary gcd\" method which avoids division and modulo\r\n * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\r\n * Stein (1961).\r\n * <\/p>\r\n *\r\n * @param u a non-zero number\r\n * @param v a non-zero number\r\n * @return the greatest common divisor, never zero\r\n * @since 1.1\r\n *\/\r\n","code_no_comment":"public static int gcd(int u, int v) {\r\n    if (u * v == 0) {\r\n        return (Math.abs(u) + Math.abs(v));\r\n    }\r\n        if (u > 0) {\r\n        u = -u;\r\n    }\r\n        if (v > 0) {\r\n        v = -v;\r\n    }\r\n            int k = 0;\r\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\r\n                        u \/= 2;\r\n        v \/= 2;\r\n                k++;\r\n    }\r\n    if (k == 31) {\r\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\r\n    }\r\n            int t = ((u & 1) == 1) ? v : -(u \/ 2);\r\n        do {\r\n                while ((t & 1) == 0) {\r\n                                    t \/= 2;\r\n        }\r\n                if (t > 0) {\r\n            u = -t;\r\n        } else {\r\n            v = t;\r\n        }\r\n                t = (v - u) \/ 2;\r\n            } while (t != 0);\r\n        return -u * (1 << k);\r\n}","lc":0.8636363636,"pi":-0.009569378,"ma":1.4,"nbd":0.0,"ml":0.8333333333,"d":6.2817460317,"mi":-0.6056377731,"fo":-0.3333333333,"r":0.2894736842,"e":7.7817257655}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7513_85ced066","label":1,"code":"protected AggregationStrategyMethodInfo createMethodInfo() {\r\n    Class<?>[] parameterTypes = method.getParameterTypes();\r\n    int size = parameterTypes.length;\r\n    if (LOG.isTraceEnabled()) {\r\n        LOG.trace(\"Creating MethodInfo for class: {} method: {} having {} parameters\", new Object[] { type, method, size });\r\n    }\r\n    \/\/ must have equal number of parameters\r\n    if (size < 2) {\r\n        throw new IllegalArgumentException(\"The method \" + method.getName() + \" must have at least two parameters, has: \" + size);\r\n    } else if (size % 2 != 0) {\r\n        throw new IllegalArgumentException(\"The method \" + method.getName() + \" must have equal number of parameters, has: \" + size);\r\n    }\r\n    \/\/ must not have annotations as they are not supported (yet)\r\n    for (int i = 0; i < size; i++) {\r\n        Class<?> type = parameterTypes[i];\r\n        if (type.getAnnotations().length > 0) {\r\n            throw new IllegalArgumentException(\"Parameter annotations at index \" + i + \" is not supported on method: \" + method);\r\n        }\r\n    }\r\n    List<ParameterInfo> oldParameters = new ArrayList<ParameterInfo>();\r\n    List<ParameterInfo> newParameters = new ArrayList<ParameterInfo>();\r\n    for (int i = 0; i < size \/ 2; i++) {\r\n        Class<?> oldType = parameterTypes[i];\r\n        if (oldParameters.size() == 0) {\r\n            \/\/ the first parameter is the body\r\n            Expression oldBody = ExpressionBuilder.mandatoryBodyExpression(oldType);\r\n            ParameterInfo info = new ParameterInfo(i, oldType, null, oldBody);\r\n            oldParameters.add(info);\r\n        } else if (oldParameters.size() == 1) {\r\n            \/\/ the 2nd parameter is the headers\r\n            Expression oldHeaders = ExpressionBuilder.headersExpression();\r\n            ParameterInfo info = new ParameterInfo(i, oldType, null, oldHeaders);\r\n            oldParameters.add(info);\r\n        } else if (oldParameters.size() == 2) {\r\n            \/\/ the 3rd parameter is the properties\r\n            Expression oldProperties = ExpressionBuilder.propertiesExpression();\r\n            ParameterInfo info = new ParameterInfo(i, oldType, null, oldProperties);\r\n            oldParameters.add(info);\r\n        }\r\n    }\r\n    for (int i = size \/ 2; i < size; i++) {\r\n        Class<?> newType = parameterTypes[i];\r\n        if (newParameters.size() == 0) {\r\n            \/\/ the first parameter is the body\r\n            Expression newBody = ExpressionBuilder.mandatoryBodyExpression(newType);\r\n            ParameterInfo info = new ParameterInfo(i, newType, null, newBody);\r\n            newParameters.add(info);\r\n        } else if (newParameters.size() == 1) {\r\n            \/\/ the 2nd parameter is the headers\r\n            Expression newHeaders = ExpressionBuilder.headersExpression();\r\n            ParameterInfo info = new ParameterInfo(i, newType, null, newHeaders);\r\n            newParameters.add(info);\r\n        } else if (newParameters.size() == 2) {\r\n            \/\/ the 3rd parameter is the properties\r\n            Expression newProperties = ExpressionBuilder.propertiesExpression();\r\n            ParameterInfo info = new ParameterInfo(i, newType, null, newProperties);\r\n            newParameters.add(info);\r\n        }\r\n    }\r\n    return new AggregationStrategyMethodInfo(camelContext, type, method, oldParameters, newParameters);\r\n}","code_comment":null,"code_no_comment":"protected AggregationStrategyMethodInfo createMethodInfo() {\r\n    Class<?>[] parameterTypes = method.getParameterTypes();\r\n    int size = parameterTypes.length;\r\n    if (LOG.isTraceEnabled()) {\r\n        LOG.trace(\"Creating MethodInfo for class: {} method: {} having {} parameters\", new Object[] { type, method, size });\r\n    }\r\n        if (size < 2) {\r\n        throw new IllegalArgumentException(\"The method \" + method.getName() + \" must have at least two parameters, has: \" + size);\r\n    } else if (size % 2 != 0) {\r\n        throw new IllegalArgumentException(\"The method \" + method.getName() + \" must have equal number of parameters, has: \" + size);\r\n    }\r\n        for (int i = 0; i < size; i++) {\r\n        Class<?> type = parameterTypes[i];\r\n        if (type.getAnnotations().length > 0) {\r\n            throw new IllegalArgumentException(\"Parameter annotations at index \" + i + \" is not supported on method: \" + method);\r\n        }\r\n    }\r\n    List<ParameterInfo> oldParameters = new ArrayList<ParameterInfo>();\r\n    List<ParameterInfo> newParameters = new ArrayList<ParameterInfo>();\r\n    for (int i = 0; i < size \/ 2; i++) {\r\n        Class<?> oldType = parameterTypes[i];\r\n        if (oldParameters.size() == 0) {\r\n                        Expression oldBody = ExpressionBuilder.mandatoryBodyExpression(oldType);\r\n            ParameterInfo info = new ParameterInfo(i, oldType, null, oldBody);\r\n            oldParameters.add(info);\r\n        } else if (oldParameters.size() == 1) {\r\n                        Expression oldHeaders = ExpressionBuilder.headersExpression();\r\n            ParameterInfo info = new ParameterInfo(i, oldType, null, oldHeaders);\r\n            oldParameters.add(info);\r\n        } else if (oldParameters.size() == 2) {\r\n                        Expression oldProperties = ExpressionBuilder.propertiesExpression();\r\n            ParameterInfo info = new ParameterInfo(i, oldType, null, oldProperties);\r\n            oldParameters.add(info);\r\n        }\r\n    }\r\n    for (int i = size \/ 2; i < size; i++) {\r\n        Class<?> newType = parameterTypes[i];\r\n        if (newParameters.size() == 0) {\r\n                        Expression newBody = ExpressionBuilder.mandatoryBodyExpression(newType);\r\n            ParameterInfo info = new ParameterInfo(i, newType, null, newBody);\r\n            newParameters.add(info);\r\n        } else if (newParameters.size() == 1) {\r\n                        Expression newHeaders = ExpressionBuilder.headersExpression();\r\n            ParameterInfo info = new ParameterInfo(i, newType, null, newHeaders);\r\n            newParameters.add(info);\r\n        } else if (newParameters.size() == 2) {\r\n                        Expression newProperties = ExpressionBuilder.propertiesExpression();\r\n            ParameterInfo info = new ParameterInfo(i, newType, null, newProperties);\r\n            newParameters.add(info);\r\n        }\r\n    }\r\n    return new AggregationStrategyMethodInfo(camelContext, type, method, oldParameters, newParameters);\r\n}","lc":1.7727272727,"pi":0.2918660287,"ma":2.6,"nbd":1.0,"ml":1.1666666667,"d":2.7777777778,"mi":-1.006483439,"fo":1.5,"r":-0.0263157895,"e":9.9738685938}
{"project_name":"Closure","project_version":"65","label":2,"code":"\/**\r\n * Helper to escape javascript string as well as regular expression\r\n *\/\r\nstatic String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {\r\n    StringBuilder sb = new StringBuilder(s.length() + 2);\r\n    sb.append(quote);\r\n    for (int i = 0; i < s.length(); i++) {\r\n        char c = s.charAt(i);\r\n        switch(c) {\r\n            case '\\0':\r\n                sb.append(\"\\\\0\");\r\n                break;\r\n            case '\\n':\r\n                sb.append(\"\\\\n\");\r\n                break;\r\n            case '\\r':\r\n                sb.append(\"\\\\r\");\r\n                break;\r\n            case '\\t':\r\n                sb.append(\"\\\\t\");\r\n                break;\r\n            case '\\\\':\r\n                sb.append(backslashEscape);\r\n                break;\r\n            case '\\\"':\r\n                sb.append(doublequoteEscape);\r\n                break;\r\n            case '\\'':\r\n                sb.append(singlequoteEscape);\r\n                break;\r\n            case \/\/ Break --> into --\\> or ]]> into ]]\\>\r\n            '>':\r\n                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\r\n                    sb.append(\"\\\\>\");\r\n                } else {\r\n                    sb.append(c);\r\n                }\r\n                break;\r\n            case '<':\r\n                \/\/ Break <\/script into <\\\/script\r\n                final String END_SCRIPT = \"\/script\";\r\n                \/\/ Break <!-- into <\\!--\r\n                final String START_COMMENT = \"!--\";\r\n                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {\r\n                    sb.append(\"<\\\\\");\r\n                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {\r\n                    sb.append(\"<\\\\\");\r\n                } else {\r\n                    sb.append(c);\r\n                }\r\n                break;\r\n            default:\r\n                \/\/ character can be represented in this character set.\r\n                if (outputCharsetEncoder != null) {\r\n                    if (outputCharsetEncoder.canEncode(c)) {\r\n                        sb.append(c);\r\n                    } else {\r\n                        \/\/ Unicode-escape the character.\r\n                        appendHexJavaScriptRepresentation(sb, c);\r\n                    }\r\n                } else {\r\n                    \/\/ check is measurably faster than using the CharsetEncoder.\r\n                    if (c > 0x1f && c < 0x7f) {\r\n                        sb.append(c);\r\n                    } else {\r\n                        \/\/ Other characters can be misinterpreted by some js parsers,\r\n                        \/\/ or perhaps mangled by proxies along the way,\r\n                        \/\/ so we play it safe and unicode escape them.\r\n                        appendHexJavaScriptRepresentation(sb, c);\r\n                    }\r\n                }\r\n        }\r\n    }\r\n    sb.append(quote);\r\n    return sb.toString();\r\n}","code_comment":"\/**\r\n * Helper to escape javascript string as well as regular expression\r\n *\/\r\n","code_no_comment":"static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) {\r\n    StringBuilder sb = new StringBuilder(s.length() + 2);\r\n    sb.append(quote);\r\n    for (int i = 0; i < s.length(); i++) {\r\n        char c = s.charAt(i);\r\n        switch(c) {\r\n            case '\\0':\r\n                sb.append(\"\\\\0\");\r\n                break;\r\n            case '\\n':\r\n                sb.append(\"\\\\n\");\r\n                break;\r\n            case '\\r':\r\n                sb.append(\"\\\\r\");\r\n                break;\r\n            case '\\t':\r\n                sb.append(\"\\\\t\");\r\n                break;\r\n            case '\\\\':\r\n                sb.append(backslashEscape);\r\n                break;\r\n            case '\\\"':\r\n                sb.append(doublequoteEscape);\r\n                break;\r\n            case '\\'':\r\n                sb.append(singlequoteEscape);\r\n                break;\r\n            case             '>':\r\n                if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\r\n                    sb.append(\"\\\\>\");\r\n                } else {\r\n                    sb.append(c);\r\n                }\r\n                break;\r\n            case '<':\r\n                                final String END_SCRIPT = \"\/script\";\r\n                                final String START_COMMENT = \"!--\";\r\n                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {\r\n                    sb.append(\"<\\\\\");\r\n                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {\r\n                    sb.append(\"<\\\\\");\r\n                } else {\r\n                    sb.append(c);\r\n                }\r\n                break;\r\n            default:\r\n                                if (outputCharsetEncoder != null) {\r\n                    if (outputCharsetEncoder.canEncode(c)) {\r\n                        sb.append(c);\r\n                    } else {\r\n                                                appendHexJavaScriptRepresentation(sb, c);\r\n                    }\r\n                } else {\r\n                                        if (c > 0x1f && c < 0x7f) {\r\n                        sb.append(c);\r\n                    } else {\r\n                                                                                                appendHexJavaScriptRepresentation(sb, c);\r\n                    }\r\n                }\r\n        }\r\n    }\r\n    sb.append(quote);\r\n    return sb.toString();\r\n}","lc":2.3181818182,"pi":1.2440191388,"ma":4.6,"nbd":1.5,"ml":2.25,"d":2.630952381,"mi":-1.1243128964,"fo":2.0833333333,"r":-0.0263157895,"e":7.1863833613}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4927_8c827e33","label":1,"code":"@Override\r\npublic void sendRedirect(String url) {\r\n    checkHeader();\r\n    bufferedResponse.sendRedirect(url);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void sendRedirect(String url) {\r\n    checkHeader();\r\n    bufferedResponse.sendRedirect(url);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7626497533,"fo":-0.3333333333,"r":1.5526315789,"e":-0.1627934049}
{"project_name":"Compress","project_version":"46","label":1,"code":"private static ZipLong unixTimeToZipLong(long l) {\r\n    final long TWO_TO_32 = 0x100000000L;\r\n    if (l >= TWO_TO_32) {\r\n        throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\r\n    }\r\n    return new ZipLong(l);\r\n}","code_comment":null,"code_no_comment":"private static ZipLong unixTimeToZipLong(long l) {\r\n    final long TWO_TO_32 = 0x100000000L;\r\n    if (l >= TWO_TO_32) {\r\n        throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\r\n    }\r\n    return new ZipLong(l);\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0436507937,"mi":0.4813248767,"fo":-0.5,"r":1.9210526316,"e":-0.1213233981}
{"project_name":"Closure","project_version":"169","label":2,"code":"\/**\r\n * Whether this type is meaningfully different from {@code that} type for\r\n * the purposes of data flow analysis.\r\n *\r\n * This is a trickier check than pure equality, because it has to properly\r\n * handle unknown types. See {@code EquivalenceMethod} for more info.\r\n *\r\n * @see <a href=\"http:\/\/www.youtube.com\/watch?v=_RpSv3HjpEw\">Unknown\r\n *     unknowns<\/a>\r\n *\/\r\npublic final boolean differsFrom(JSType that) {\r\n    return !checkEquivalenceHelper(that, true);\r\n}","code_comment":"\/**\r\n * Whether this type is meaningfully different from {@code that} type for\r\n * the purposes of data flow analysis.\r\n *\r\n * This is a trickier check than pure equality, because it has to properly\r\n * handle unknown types. See {@code EquivalenceMethod} for more info.\r\n *\r\n * @see <a href=\"http:\/\/www.youtube.com\/watch?v=_RpSv3HjpEw\">Unknown\r\n *     unknowns<\/a>\r\n *\/\r\n","code_no_comment":"public final boolean differsFrom(JSType that) {\r\n    return !checkEquivalenceHelper(that, true);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0132487667,"fo":-0.4166666667,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-193_c831e44d","label":3,"code":"public String toStringNoTime() {\r\n    String labelString = new ColumnVisibility(colVisibility).toString();\r\n    String s = new String(row, 0, row.length) + \" \" + new String(colFamily, 0, colFamily.length) + \":\" + new String(colQualifier, 0, colQualifier.length) + \" \" + labelString;\r\n    return s;\r\n}","code_comment":null,"code_no_comment":"public String toStringNoTime() {\r\n    String labelString = new ColumnVisibility(colVisibility).toString();\r\n    String s = new String(row, 0, row.length) + \" \" + new String(colFamily, 0, colFamily.length) + \":\" + new String(colQualifier, 0, colQualifier.length) + \" \" + labelString;\r\n    return s;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":0.0317460317,"mi":0.5171247357,"fo":-0.4166666667,"r":-0.0263157895,"e":-0.0384202671}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5432_93935780","label":1,"code":"public Producer createProducer() throws Exception {\r\n    return new SedaProducer(this, getQueue(), getWaitForTaskToComplete(), getTimeout(), isBlockWhenFull());\r\n}","code_comment":null,"code_no_comment":"public Producer createProducer() throws Exception {\r\n    return new SedaProducer(this, getQueue(), getWaitForTaskToComplete(), getTimeout(), isBlockWhenFull());\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9782945736,"fo":-0.1666666667,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3789_9319e139","label":1,"code":"private void writeFileByStream(InputStream in, File target) throws IOException {\r\n    FileChannel out = null;\r\n    try {\r\n        out = prepareOutputFileChannel(target, out);\r\n        LOG.trace(\"Using InputStream to transfer from: {} to: {}\", in, out);\r\n        int size = endpoint.getBufferSize();\r\n        byte[] buffer = new byte[size];\r\n        ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);\r\n        int bytesRead;\r\n        while ((bytesRead = in.read(buffer)) != -1) {\r\n            if (bytesRead < size) {\r\n                byteBuffer.limit(bytesRead);\r\n            }\r\n            out.write(byteBuffer);\r\n            byteBuffer.clear();\r\n        }\r\n    } finally {\r\n        IOHelper.close(in, target.getName(), LOG);\r\n        IOHelper.close(out, target.getName(), LOG);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void writeFileByStream(InputStream in, File target) throws IOException {\r\n    FileChannel out = null;\r\n    try {\r\n        out = prepareOutputFileChannel(target, out);\r\n        LOG.trace(\"Using InputStream to transfer from: {} to: {}\", in, out);\r\n        int size = endpoint.getBufferSize();\r\n        byte[] buffer = new byte[size];\r\n        ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);\r\n        int bytesRead;\r\n        while ((bytesRead = in.read(buffer)) != -1) {\r\n            if (bytesRead < size) {\r\n                byteBuffer.limit(bytesRead);\r\n            }\r\n            out.write(byteBuffer);\r\n            byteBuffer.clear();\r\n        }\r\n    } finally {\r\n        IOHelper.close(in, target.getName(), LOG);\r\n        IOHelper.close(out, target.getName(), LOG);\r\n    }\r\n}","lc":0.3181818182,"pi":0.4258373206,"ma":-0.2,"nbd":0.5,"ml":-0.0833333333,"d":0.3888888889,"mi":-0.2848484848,"fo":0.5,"r":-0.0263157895,"e":0.4254582966}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-812_6eb46555","label":1,"code":"\/**\r\n * Optimized method to compute the dot product with an OpenMapRealVector.\r\n * It iterates over the smallest of the two.\r\n *\r\n * @param v Cector to compute the dot product with.\r\n * @return the dot product of {@code this} and {@code v}.\r\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\r\n * if the dimensions do not match.\r\n *\/\r\npublic double dotProduct(OpenMapRealVector v) {\r\n    checkVectorDimensions(v.getDimension());\r\n    boolean thisIsSmaller = entries.size() < v.entries.size();\r\n    Iterator iter = thisIsSmaller ? entries.iterator() : v.entries.iterator();\r\n    OpenIntToDoubleHashMap larger = thisIsSmaller ? v.entries : entries;\r\n    double d = 0;\r\n    while (iter.hasNext()) {\r\n        iter.advance();\r\n        d += iter.value() * larger.get(iter.key());\r\n    }\r\n    return d;\r\n}","code_comment":"\/**\r\n * Optimized method to compute the dot product with an OpenMapRealVector.\r\n * It iterates over the smallest of the two.\r\n *\r\n * @param v Cector to compute the dot product with.\r\n * @return the dot product of {@code this} and {@code v}.\r\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\r\n * if the dimensions do not match.\r\n *\/\r\n","code_no_comment":"public double dotProduct(OpenMapRealVector v) {\r\n    checkVectorDimensions(v.getDimension());\r\n    boolean thisIsSmaller = entries.size() < v.entries.size();\r\n    Iterator iter = thisIsSmaller ? entries.iterator() : v.entries.iterator();\r\n    OpenIntToDoubleHashMap larger = thisIsSmaller ? v.entries : entries;\r\n    double d = 0;\r\n    while (iter.hasNext()) {\r\n        iter.advance();\r\n        d += iter.value() * larger.get(iter.key());\r\n    }\r\n    return d;\r\n}","lc":-0.0909090909,"pi":-0.3253588517,"ma":0.0,"nbd":-0.5,"ml":0.0,"d":0.4087301587,"mi":0.0243833686,"fo":0.4166666667,"r":0.1052631579,"e":0.2384859644}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1044_ea2f9856","label":0,"code":"public String getViolationDescription(short violationCode) {\r\n    switch(violationCode) {\r\n        case 1:\r\n            return \"data file size must be a non-negative integer\";\r\n        case 2:\r\n            return \"Invalid column name given.\";\r\n        case 3:\r\n            return \"Prev end row is greater than or equal to end row.\";\r\n        case 4:\r\n            return \"Invalid metadata row format\";\r\n        case 5:\r\n            return \"Row can not be less than \" + Constants.METADATA_TABLE_ID;\r\n        case 6:\r\n            return \"Empty values are not allowed for any \" + Constants.METADATA_TABLE_NAME + \" column\";\r\n        case 7:\r\n            return \"Lock not held in zookeeper by writer\";\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"public String getViolationDescription(short violationCode) {\r\n    switch(violationCode) {\r\n        case 1:\r\n            return \"data file size must be a non-negative integer\";\r\n        case 2:\r\n            return \"Invalid column name given.\";\r\n        case 3:\r\n            return \"Prev end row is greater than or equal to end row.\";\r\n        case 4:\r\n            return \"Invalid metadata row format\";\r\n        case 5:\r\n            return \"Row can not be less than \" + Constants.METADATA_TABLE_ID;\r\n        case 6:\r\n            return \"Empty values are not allowed for any \" + Constants.METADATA_TABLE_NAME + \" column\";\r\n        case 7:\r\n            return \"Lock not held in zookeeper by writer\";\r\n    }\r\n    return null;\r\n}","lc":0.2272727273,"pi":0.4306220096,"ma":0.8,"nbd":0.0,"ml":0.25,"d":-0.3650793651,"mi":-0.1252995067,"fo":-0.5,"r":0.0,"e":-0.1627934049}
{"project_name":"Math","project_version":"37","label":3,"code":"\/**\r\n * Compute the\r\n * <a href=\"http:\/\/mathworld.wolfram.com\/HyperbolicTangent.html\" TARGET=\"_top\">\r\n * hyperbolic tangent<\/a> of this complex number.\r\n * Implements the formula:\r\n * <pre>\r\n *  <code>\r\n *   tan(a + bi) = sinh(2a)\/(cosh(2a)+cos(2b)) + [sin(2b)\/(cosh(2a)+cos(2b))]i\r\n *  <\/code>\r\n * <\/pre>\r\n * where the (real) functions on the right-hand side are\r\n * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\r\n * {@link FastMath#sinh}.\r\n * <br\/>\r\n * Returns {@link Complex#NaN} if either real or imaginary part of the\r\n * input argument is {@code NaN}.\r\n * <br\/>\r\n * Infinite values in real or imaginary parts of the input may result in\r\n * infinite or NaN values returned in parts of the result.\r\n * <pre>\r\n *  Examples:\r\n *  <code>\r\n *   tanh(a &plusmn; INFINITY i) = NaN + NaN i\r\n *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i\r\n *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\r\n *   tanh(0 + (&pi;\/2)i) = NaN + INFINITY i\r\n *  <\/code>\r\n * <\/pre>\r\n *\r\n * @return the hyperbolic tangent of {@code this}.\r\n * @since 1.2\r\n *\/\r\npublic Complex tanh() {\r\n    if (isNaN) {\r\n        return NaN;\r\n    }\r\n    double real2 = 2.0 * real;\r\n    double imaginary2 = 2.0 * imaginary;\r\n    double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\r\n    return createComplex(FastMath.sinh(real2) \/ d, FastMath.sin(imaginary2) \/ d);\r\n}","code_comment":"\/**\r\n * Compute the\r\n * <a href=\"http:\/\/mathworld.wolfram.com\/HyperbolicTangent.html\" TARGET=\"_top\">\r\n * hyperbolic tangent<\/a> of this complex number.\r\n * Implements the formula:\r\n * <pre>\r\n *  <code>\r\n *   tan(a + bi) = sinh(2a)\/(cosh(2a)+cos(2b)) + [sin(2b)\/(cosh(2a)+cos(2b))]i\r\n *  <\/code>\r\n * <\/pre>\r\n * where the (real) functions on the right-hand side are\r\n * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\r\n * {@link FastMath#sinh}.\r\n * <br\/>\r\n * Returns {@link Complex#NaN} if either real or imaginary part of the\r\n * input argument is {@code NaN}.\r\n * <br\/>\r\n * Infinite values in real or imaginary parts of the input may result in\r\n * infinite or NaN values returned in parts of the result.\r\n * <pre>\r\n *  Examples:\r\n *  <code>\r\n *   tanh(a &plusmn; INFINITY i) = NaN + NaN i\r\n *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i\r\n *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\r\n *   tanh(0 + (&pi;\/2)i) = NaN + INFINITY i\r\n *  <\/code>\r\n * <\/pre>\r\n *\r\n * @return the hyperbolic tangent of {@code this}.\r\n * @since 1.2\r\n *\/\r\n","code_no_comment":"public Complex tanh() {\r\n    if (isNaN) {\r\n        return NaN;\r\n    }\r\n    double real2 = 2.0 * real;\r\n    double imaginary2 = 2.0 * imaginary;\r\n    double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\r\n    return createComplex(FastMath.sinh(real2) \/ d, FastMath.sin(imaginary2) \/ d);\r\n}","lc":-0.2272727273,"pi":-0.3444976077,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.2658730159,"mi":0.2231148696,"fo":-0.0833333333,"r":0.7631578947,"e":0.0623387101}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3253_71b6e905","label":1,"code":"\/**\r\n *  @return model object class\r\n *\/\r\n@SuppressWarnings(\"unchecked\")\r\npublic Class<T> getObjectClass() {\r\n    final String expression = propertyExpression();\r\n    if (Strings.isEmpty(expression)) {\r\n        \/\/ Return a meaningful value for an empty property expression\r\n        Object target = getTarget();\r\n        return (Class<T>) (target != null ? target.getClass() : null);\r\n    }\r\n    final Object target = getTarget();\r\n    if (target != null) {\r\n        try {\r\n            return (Class<T>) PropertyResolver.getPropertyClass(expression, target);\r\n        } catch (Exception e) {\r\n        \/\/ ignore.\r\n        }\r\n    } else if (this.target instanceof IObjectClassAwareModel) {\r\n        try {\r\n            return PropertyResolver.getPropertyClass(expression, ((IObjectClassAwareModel<?>) this.target).getObjectClass());\r\n        } catch (WicketRuntimeException e) {\r\n        \/\/ it was just a try.\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":"\/**\r\n *  @return model object class\r\n *\/\r\n","code_no_comment":"@SuppressWarnings(\"unchecked\")\r\npublic Class<T> getObjectClass() {\r\n    final String expression = propertyExpression();\r\n    if (Strings.isEmpty(expression)) {\r\n                Object target = getTarget();\r\n        return (Class<T>) (target != null ? target.getClass() : null);\r\n    }\r\n    final Object target = getTarget();\r\n    if (target != null) {\r\n        try {\r\n            return (Class<T>) PropertyResolver.getPropertyClass(expression, target);\r\n        } catch (Exception e) {\r\n                }\r\n    } else if (this.target instanceof IObjectClassAwareModel) {\r\n        try {\r\n            return PropertyResolver.getPropertyClass(expression, ((IObjectClassAwareModel<?>) this.target).getObjectClass());\r\n        } catch (WicketRuntimeException e) {\r\n                }\r\n    }\r\n    return null;\r\n}","lc":0.3181818182,"pi":0.1961722488,"ma":0.6,"nbd":0.5,"ml":0.25,"d":0.0496031746,"mi":-0.2577871741,"fo":0.1666666667,"r":0.0,"e":0.0626153305}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2288_57bd2dc5","label":3,"code":"\/**\r\n * Returns <code>true<\/code> if the given revision\r\n * {@link Utils#isCommitted(String)} in the revisions map (including\r\n * revisions split off to previous documents) and is visible from the\r\n * <code>readRevision<\/code>.\r\n *\r\n * @param revision  the revision to check.\r\n * @param commitValue the commit value of the revision to check or\r\n *                    <code>null<\/code> if unknown.\r\n * @param readRevision the read revision.\r\n * @return <code>true<\/code> if the revision is committed, otherwise\r\n *         <code>false<\/code>.\r\n *\/\r\nprivate boolean isCommitted(@Nonnull RevisionContext context, @Nonnull Revision revision, @Nullable String commitValue, @Nonnull Revision readRevision) {\r\n    if (revision.equalsIgnoreBranch(readRevision)) {\r\n        return true;\r\n    }\r\n    if (commitValue == null) {\r\n        commitValue = getCommitValue(revision);\r\n    }\r\n    if (commitValue == null) {\r\n        return false;\r\n    }\r\n    if (Utils.isCommitted(commitValue)) {\r\n        if (context.getBranches().getBranch(readRevision) == null && !readRevision.isBranch()) {\r\n            \/\/ resolve commit revision\r\n            revision = Utils.resolveCommitRevision(revision, commitValue);\r\n            \/\/ compare resolved revision as is\r\n            return !isRevisionNewer(context, revision, readRevision);\r\n        } else {\r\n            \/\/ on same merged branch?\r\n            if (commitValue.equals(getCommitValue(readRevision.asTrunkRevision()))) {\r\n                \/\/ compare unresolved revision\r\n                return !isRevisionNewer(context, revision, readRevision);\r\n            }\r\n        }\r\n    } else {\r\n        \/\/ branch commit (not merged)\r\n        if (Revision.fromString(commitValue).getClusterId() != context.getClusterId()) {\r\n            \/\/ hence never visible to us\r\n            return false;\r\n        }\r\n    }\r\n    return includeRevision(context, Utils.resolveCommitRevision(revision, commitValue), readRevision);\r\n}","code_comment":"\/**\r\n * Returns <code>true<\/code> if the given revision\r\n * {@link Utils#isCommitted(String)} in the revisions map (including\r\n * revisions split off to previous documents) and is visible from the\r\n * <code>readRevision<\/code>.\r\n *\r\n * @param revision  the revision to check.\r\n * @param commitValue the commit value of the revision to check or\r\n *                    <code>null<\/code> if unknown.\r\n * @param readRevision the read revision.\r\n * @return <code>true<\/code> if the revision is committed, otherwise\r\n *         <code>false<\/code>.\r\n *\/\r\n","code_no_comment":"private boolean isCommitted(@Nonnull RevisionContext context, @Nonnull Revision revision, @Nullable String commitValue, @Nonnull Revision readRevision) {\r\n    if (revision.equalsIgnoreBranch(readRevision)) {\r\n        return true;\r\n    }\r\n    if (commitValue == null) {\r\n        commitValue = getCommitValue(revision);\r\n    }\r\n    if (commitValue == null) {\r\n        return false;\r\n    }\r\n    if (Utils.isCommitted(commitValue)) {\r\n        if (context.getBranches().getBranch(readRevision) == null && !readRevision.isBranch()) {\r\n                        revision = Utils.resolveCommitRevision(revision, commitValue);\r\n                        return !isRevisionNewer(context, revision, readRevision);\r\n        } else {\r\n                        if (commitValue.equals(getCommitValue(readRevision.asTrunkRevision()))) {\r\n                                return !isRevisionNewer(context, revision, readRevision);\r\n            }\r\n        }\r\n    } else {\r\n                if (Revision.fromString(commitValue).getClusterId() != context.getClusterId()) {\r\n                        return false;\r\n        }\r\n    }\r\n    return includeRevision(context, Utils.resolveCommitRevision(revision, commitValue), readRevision);\r\n}","lc":0.5454545455,"pi":0.4497607656,"ma":0.8,"nbd":0.5,"ml":1.1666666667,"d":0.6349206349,"mi":-0.4367864693,"fo":0.9166666667,"r":-0.0263157895,"e":0.7428801946}
{"project_name":"Closure","project_version":"148","label":2,"code":"\/**\r\n * Write any entries needed between the current position the next position\r\n * and update the current position.\r\n *\/\r\nprivate void writeCharsUpTo(int nextLine, int nextCol, int id) throws IOException {\r\n    Preconditions.checkState(line <= nextLine, \"\");\r\n    Preconditions.checkState(line < nextLine || col <= nextCol);\r\n    if (line == nextLine && col == nextCol) {\r\n        \/\/ Nothing to do.\r\n        return;\r\n    }\r\n    String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);\r\n    for (int i = line; i <= nextLine; i++) {\r\n        if (i == nextLine) {\r\n            for (int j = col; j < nextCol; j++) {\r\n                addCharEntry(idString);\r\n            }\r\n            break;\r\n        }\r\n        closeLine();\r\n        openLine();\r\n    }\r\n    line = nextLine;\r\n    col = nextCol;\r\n}","code_comment":"\/**\r\n * Write any entries needed between the current position the next position\r\n * and update the current position.\r\n *\/\r\n","code_no_comment":"private void writeCharsUpTo(int nextLine, int nextCol, int id) throws IOException {\r\n    Preconditions.checkState(line <= nextLine, \"\");\r\n    Preconditions.checkState(line < nextLine || col <= nextCol);\r\n    if (line == nextLine && col == nextCol) {\r\n                return;\r\n    }\r\n    String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);\r\n    for (int i = line; i <= nextLine; i++) {\r\n        if (i == nextLine) {\r\n            for (int j = col; j < nextCol; j++) {\r\n                addCharEntry(idString);\r\n            }\r\n            break;\r\n        }\r\n        closeLine();\r\n        openLine();\r\n    }\r\n    line = nextLine;\r\n    col = nextCol;\r\n}","lc":0.2727272727,"pi":0.5215311005,"ma":0.6,"nbd":0.5,"ml":0.6666666667,"d":1.0238095238,"mi":-0.282311487,"fo":0.0,"r":0.1842105263,"e":0.876676867}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4766_cda34428","label":1,"code":"\/**\r\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT.\r\n *\r\n *  Temporarily replaces the response with a StringResponse to capture the header output for this\r\n *  part of the stream and pass it to {@link IHeaderResponse}.\r\n *\r\n *  @see org.apache.wicket.MarkupContainer#renderNext(org.apache.wicket.markup.MarkupStream)\r\n *\/\r\n@Override\r\nprotected final boolean renderNext(MarkupStream markupStream) {\r\n    StringResponse markupHeaderResponse = new StringResponse();\r\n    Response oldResponse = getResponse();\r\n    RequestCycle.get().setResponse(markupHeaderResponse);\r\n    try {\r\n        boolean ret = super.renderNext(markupStream);\r\n        getHeaderResponse().render(new PageHeaderItem(markupHeaderResponse.getBuffer()));\r\n        return ret;\r\n    } finally {\r\n        RequestCycle.get().setResponse(oldResponse);\r\n    }\r\n}","code_comment":"\/**\r\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT.\r\n *\r\n *  Temporarily replaces the response with a StringResponse to capture the header output for this\r\n *  part of the stream and pass it to {@link IHeaderResponse}.\r\n *\r\n *  @see org.apache.wicket.MarkupContainer#renderNext(org.apache.wicket.markup.MarkupStream)\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected final boolean renderNext(MarkupStream markupStream) {\r\n    StringResponse markupHeaderResponse = new StringResponse();\r\n    Response oldResponse = getResponse();\r\n    RequestCycle.get().setResponse(markupHeaderResponse);\r\n    try {\r\n        boolean ret = super.renderNext(markupStream);\r\n        getHeaderResponse().render(new PageHeaderItem(markupHeaderResponse.getBuffer()));\r\n        return ret;\r\n    } finally {\r\n        RequestCycle.get().setResponse(oldResponse);\r\n    }\r\n}","lc":-0.0454545455,"pi":-0.033492823,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.0844256519,"fo":0.25,"r":0.1842105263,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-713_f656676e","label":1,"code":"\/**\r\n * Get the current solution.\r\n *\r\n * @return current solution\r\n *\/\r\nprotected RealPointValuePair getSolution() {\r\n    int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\r\n    Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\r\n    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\r\n    Set<Integer> basicRows = new HashSet<Integer>();\r\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\r\n    for (int i = 0; i < coefficients.length; i++) {\r\n        int colIndex = columnLabels.indexOf(\"x\" + i);\r\n        if (colIndex < 0) {\r\n            coefficients[i] = 0;\r\n            continue;\r\n        }\r\n        Integer basicRow = getBasicRow(colIndex);\r\n        if (basicRows.contains(basicRow)) {\r\n            \/\/ if multiple variables can take a given value\r\n            \/\/ then we choose the first and set the rest equal to 0\r\n            coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\r\n        } else {\r\n            basicRows.add(basicRow);\r\n            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\r\n        }\r\n    }\r\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\r\n}","code_comment":"\/**\r\n * Get the current solution.\r\n *\r\n * @return current solution\r\n *\/\r\n","code_no_comment":"protected RealPointValuePair getSolution() {\r\n    int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\r\n    Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\r\n    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\r\n    Set<Integer> basicRows = new HashSet<Integer>();\r\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\r\n    for (int i = 0; i < coefficients.length; i++) {\r\n        int colIndex = columnLabels.indexOf(\"x\" + i);\r\n        if (colIndex < 0) {\r\n            coefficients[i] = 0;\r\n            continue;\r\n        }\r\n        Integer basicRow = getBasicRow(colIndex);\r\n        if (basicRows.contains(basicRow)) {\r\n                                    coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\r\n        } else {\r\n            basicRows.add(basicRow);\r\n            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\r\n        }\r\n    }\r\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\r\n}","lc":0.3636363636,"pi":0.3349282297,"ma":1.2,"nbd":0.0,"ml":0.9166666667,"d":1.1428571429,"mi":-0.4097251586,"fo":0.5,"r":0.0,"e":1.589513782}
{"project_name":"Closure","project_version":"144","label":2,"code":"\/**\r\n * Infer the return type from JSDocInfo.\r\n *\/\r\nFunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {\r\n    returnType = info != null && info.hasReturnType() ? info.getReturnType().evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE);\r\n    if (templateTypeName != null && returnType.restrictByNotNullOrUndefined().isTemplateType()) {\r\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\r\n    }\r\n    return this;\r\n}","code_comment":"\/**\r\n * Infer the return type from JSDocInfo.\r\n *\/\r\n","code_no_comment":"FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {\r\n    returnType = info != null && info.hasReturnType() ? info.getReturnType().evaluate(scope, typeRegistry) : typeRegistry.getNativeType(UNKNOWN_TYPE);\r\n    if (templateTypeName != null && returnType.restrictByNotNullOrUndefined().isTemplateType()) {\r\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\r\n    }\r\n    return this;\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.2,"nbd":-0.5,"ml":0.25,"d":-0.1091269841,"mi":0.3384073291,"fo":0.0833333333,"r":1.3684210526,"e":-0.0758239542}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3534_734ba01d","label":0,"code":"\/\/ --------------------------------------------------------------------------------------------\r\n\/\/ Internal Actions\r\n\/\/ --------------------------------------------------------------------------------------------\r\nprivate boolean processFail(Throwable t, boolean isCallback) {\r\n    \/\/ atomically switch to failed\r\n    while (true) {\r\n        ExecutionState current = this.state;\r\n        if (current == FAILED) {\r\n            \/\/ already failed. It is enough to remember once that we failed (its sad enough)\r\n            return false;\r\n        }\r\n        if (current == CANCELED || current == FINISHED) {\r\n            \/\/ we are already aborting or are already aborted or we are already finished\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"Ignoring transition of vertex {} to {} while being {}.\", getVertexWithAttempt(), FAILED, current);\r\n            }\r\n            return false;\r\n        }\r\n        if (transitionState(current, FAILED, t)) {\r\n            \/\/ success (in a manner of speaking)\r\n            this.failureCause = t;\r\n            try {\r\n                if (assignedResource != null) {\r\n                    assignedResource.releaseSlot();\r\n                }\r\n                vertex.getExecutionGraph().deregisterExecution(this);\r\n            } finally {\r\n                vertex.executionFailed(t);\r\n            }\r\n            if (!isCallback && (current == RUNNING || current == DEPLOYING)) {\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Sending out cancel request, to remove task execution from TaskManager.\");\r\n                }\r\n                try {\r\n                    if (assignedResource != null) {\r\n                        sendCancelRpcCall();\r\n                    }\r\n                } catch (Throwable tt) {\r\n                    \/\/ no reason this should ever happen, but log it to be safe\r\n                    LOG.error(\"Error triggering cancel call while marking task as failed.\", tt);\r\n                }\r\n            }\r\n            \/\/ leave the loop\r\n            return true;\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private boolean processFail(Throwable t, boolean isCallback) {\r\n        while (true) {\r\n        ExecutionState current = this.state;\r\n        if (current == FAILED) {\r\n                        return false;\r\n        }\r\n        if (current == CANCELED || current == FINISHED) {\r\n                        if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"Ignoring transition of vertex {} to {} while being {}.\", getVertexWithAttempt(), FAILED, current);\r\n            }\r\n            return false;\r\n        }\r\n        if (transitionState(current, FAILED, t)) {\r\n                        this.failureCause = t;\r\n            try {\r\n                if (assignedResource != null) {\r\n                    assignedResource.releaseSlot();\r\n                }\r\n                vertex.getExecutionGraph().deregisterExecution(this);\r\n            } finally {\r\n                vertex.executionFailed(t);\r\n            }\r\n            if (!isCallback && (current == RUNNING || current == DEPLOYING)) {\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Sending out cancel request, to remove task execution from TaskManager.\");\r\n                }\r\n                try {\r\n                    if (assignedResource != null) {\r\n                        sendCancelRpcCall();\r\n                    }\r\n                } catch (Throwable tt) {\r\n                                        LOG.error(\"Error triggering cancel call while marking task as failed.\", tt);\r\n                }\r\n            }\r\n                        return true;\r\n        }\r\n    }\r\n}","lc":1.0909090909,"pi":1.1866028708,"ma":1.4,"nbd":1.5,"ml":1.0833333333,"d":0.7023809524,"mi":-0.6307258633,"fo":0.5,"r":-0.0263157895,"e":0.8144557206}
{"project_name":"Lang","project_version":"1","label":1,"code":"\/\/ -----------------------------------------------------------------------\r\n\/\/ must handle Long, Float, Integer, Float, Short,\r\n\/\/ BigDecimal, BigInteger and Byte\r\n\/\/ useful methods:\r\n\/\/ Byte.decode(String)\r\n\/\/ Byte.valueOf(String,int radix)\r\n\/\/ Byte.valueOf(String)\r\n\/\/ Double.valueOf(String)\r\n\/\/ Float.valueOf(String)\r\n\/\/ Float.valueOf(String)\r\n\/\/ Integer.valueOf(String,int radix)\r\n\/\/ Integer.valueOf(String)\r\n\/\/ Integer.decode(String)\r\n\/\/ Integer.getInteger(String)\r\n\/\/ Integer.getInteger(String,int val)\r\n\/\/ Integer.getInteger(String,Integer val)\r\n\/\/ Integer.valueOf(String)\r\n\/\/ Double.valueOf(String)\r\n\/\/ new Byte(String)\r\n\/\/ Long.valueOf(String)\r\n\/\/ Long.getLong(String)\r\n\/\/ Long.getLong(String,int)\r\n\/\/ Long.getLong(String,Integer)\r\n\/\/ Long.valueOf(String,int)\r\n\/\/ Long.valueOf(String)\r\n\/\/ Short.valueOf(String)\r\n\/\/ Short.decode(String)\r\n\/\/ Short.valueOf(String,int)\r\n\/\/ Short.valueOf(String)\r\n\/\/ new BigDecimal(String)\r\n\/\/ new BigInteger(String)\r\n\/\/ new BigInteger(String,int radix)\r\n\/\/ Possible inputs:\r\n\/\/ 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\r\n\/\/ plus minus everything. Prolly more. A lot are not separable.\r\n\/**\r\n * <p>Turns a string value into a java.lang.Number.<\/p>\r\n *\r\n * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\r\n * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\r\n * prefix is more than 8 - or BigInteger if there are more than 16 digits.\r\n * <\/p>\r\n * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\r\n * <code>'f','F','d','D','l','L'<\/code>.  If it is found, it starts\r\n * trying to create successively larger types from the type specified\r\n * until one is found that can represent the value.<\/p>\r\n *\r\n * <p>If a type specifier is not found, it will check for a decimal point\r\n * and then try successively larger types from <code>Integer<\/code> to\r\n * <code>BigInteger<\/code> and from <code>Float<\/code> to\r\n * <code>BigDecimal<\/code>.<\/p>\r\n *\r\n * <p>\r\n * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\r\n * be Integer, Long or BigDecimal as appropriate.\r\n * <\/p>\r\n *\r\n * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\r\n *\r\n * <p>This method does not trim the input string, i.e., strings with leading\r\n * or trailing spaces will generate NumberFormatExceptions.<\/p>\r\n *\r\n * @param str  String containing a number, may be null\r\n * @return Number created from the string (or null if the input is null)\r\n * @throws NumberFormatException if the value cannot be converted\r\n *\/\r\npublic static Number createNumber(final String str) throws NumberFormatException {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    if (StringUtils.isBlank(str)) {\r\n        throw new NumberFormatException(\"A blank string is not a valid number\");\r\n    }\r\n    \/\/ Need to deal with all possible hex prefixes here\r\n    final String[] hex_prefixes = { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\r\n    int pfxLen = 0;\r\n    for (final String pfx : hex_prefixes) {\r\n        if (str.startsWith(pfx)) {\r\n            pfxLen += pfx.length();\r\n            break;\r\n        }\r\n    }\r\n    if (pfxLen > 0) {\r\n        \/\/ we have a hex number\r\n        final int hexDigits = str.length() - pfxLen;\r\n        if (hexDigits > 16) {\r\n            \/\/ too many for Long\r\n            return createBigInteger(str);\r\n        }\r\n        if (hexDigits > 8) {\r\n            \/\/ too many for an int\r\n            return createLong(str);\r\n        }\r\n        return createInteger(str);\r\n    }\r\n    final char lastChar = str.charAt(str.length() - 1);\r\n    String mant;\r\n    String dec;\r\n    String exp;\r\n    final int decPos = str.indexOf('.');\r\n    \/\/ assumes both not present\r\n    final int expPos = str.indexOf('e') + str.indexOf('E') + 1;\r\n    \/\/ if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\r\n    \/\/ and the parsing which will detect if e or E appear in a number due to using the wrong offset\r\n    \/\/ Check required precision (LANG-693)\r\n    int numDecimals = 0;\r\n    if (decPos > -1) {\r\n        if (expPos > -1) {\r\n            \/\/ there is an exponent\r\n            if (expPos < decPos || expPos > str.length()) {\r\n                \/\/ prevents double exponent causing IOOBE\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            }\r\n            dec = str.substring(decPos + 1, expPos);\r\n        } else {\r\n            dec = str.substring(decPos + 1);\r\n        }\r\n        mant = str.substring(0, decPos);\r\n        \/\/ gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\r\n        numDecimals = dec.length();\r\n    } else {\r\n        if (expPos > -1) {\r\n            if (expPos > str.length()) {\r\n                \/\/ prevents double exponent causing IOOBE\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            }\r\n            mant = str.substring(0, expPos);\r\n        } else {\r\n            mant = str;\r\n        }\r\n        dec = null;\r\n    }\r\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\r\n        if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length() - 1);\r\n        } else {\r\n            exp = null;\r\n        }\r\n        \/\/ Requesting a specific type..\r\n        final String numeric = str.substring(0, str.length() - 1);\r\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n        switch(lastChar) {\r\n            case 'l':\r\n            case 'L':\r\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\r\n                    try {\r\n                        return createLong(numeric);\r\n                    } catch (final NumberFormatException nfe) {\r\n                    \/\/ NOPMD\r\n                    \/\/ Too big for a long\r\n                    }\r\n                    return createBigInteger(numeric);\r\n                }\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            case 'f':\r\n            case 'F':\r\n                try {\r\n                    final Float f = NumberUtils.createFloat(numeric);\r\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                        \/\/ has non-zeros in it, then float does not have the precision we want\r\n                        return f;\r\n                    }\r\n                } catch (final NumberFormatException nfe) {\r\n                \/\/ NOPMD\r\n                \/\/ ignore the bad number\r\n                }\r\n            \/\/ $FALL-THROUGH$\r\n            case 'd':\r\n            case 'D':\r\n                try {\r\n                    final Double d = NumberUtils.createDouble(numeric);\r\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\r\n                        return d;\r\n                    }\r\n                } catch (final NumberFormatException nfe) {\r\n                \/\/ NOPMD\r\n                \/\/ ignore the bad number\r\n                }\r\n                try {\r\n                    return createBigDecimal(numeric);\r\n                } catch (final NumberFormatException e) {\r\n                \/\/ NOPMD\r\n                \/\/ ignore the bad number\r\n                }\r\n            \/\/ $FALL-THROUGH$\r\n            default:\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n        }\r\n    }\r\n    \/\/ small and go from there...\r\n    if (expPos > -1 && expPos < str.length() - 1) {\r\n        exp = str.substring(expPos + 1, str.length());\r\n    } else {\r\n        exp = null;\r\n    }\r\n    if (dec == null && exp == null) {\r\n        \/\/ Must be an Integer, Long, Biginteger\r\n        try {\r\n            return createInteger(str);\r\n        } catch (final NumberFormatException nfe) {\r\n        \/\/ NOPMD\r\n        \/\/ ignore the bad number\r\n        }\r\n        try {\r\n            return createLong(str);\r\n        } catch (final NumberFormatException nfe) {\r\n        \/\/ NOPMD\r\n        \/\/ ignore the bad number\r\n        }\r\n        return createBigInteger(str);\r\n    }\r\n    \/\/ Must be a Float, Double, BigDecimal\r\n    final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n    try {\r\n        if (numDecimals <= 7) {\r\n            \/\/ If number has 7 or fewer digits past the decimal point then make it a float\r\n            final Float f = createFloat(str);\r\n            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                return f;\r\n            }\r\n        }\r\n    } catch (final NumberFormatException nfe) {\r\n    \/\/ NOPMD\r\n    \/\/ ignore the bad number\r\n    }\r\n    try {\r\n        if (numDecimals <= 16) {\r\n            \/\/ If number has between 8 and 16 digits past the decimal point then make it a double\r\n            final Double d = createDouble(str);\r\n            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\r\n                return d;\r\n            }\r\n        }\r\n    } catch (final NumberFormatException nfe) {\r\n    \/\/ NOPMD\r\n    \/\/ ignore the bad number\r\n    }\r\n    return createBigDecimal(str);\r\n}","code_comment":"\/**\r\n * <p>Turns a string value into a java.lang.Number.<\/p>\r\n *\r\n * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\r\n * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\r\n * prefix is more than 8 - or BigInteger if there are more than 16 digits.\r\n * <\/p>\r\n * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\r\n * <code>'f','F','d','D','l','L'<\/code>.  If it is found, it starts\r\n * trying to create successively larger types from the type specified\r\n * until one is found that can represent the value.<\/p>\r\n *\r\n * <p>If a type specifier is not found, it will check for a decimal point\r\n * and then try successively larger types from <code>Integer<\/code> to\r\n * <code>BigInteger<\/code> and from <code>Float<\/code> to\r\n * <code>BigDecimal<\/code>.<\/p>\r\n *\r\n * <p>\r\n * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\r\n * be Integer, Long or BigDecimal as appropriate.\r\n * <\/p>\r\n *\r\n * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\r\n *\r\n * <p>This method does not trim the input string, i.e., strings with leading\r\n * or trailing spaces will generate NumberFormatExceptions.<\/p>\r\n *\r\n * @param str  String containing a number, may be null\r\n * @return Number created from the string (or null if the input is null)\r\n * @throws NumberFormatException if the value cannot be converted\r\n *\/\r\n","code_no_comment":"public static Number createNumber(final String str) throws NumberFormatException {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    if (StringUtils.isBlank(str)) {\r\n        throw new NumberFormatException(\"A blank string is not a valid number\");\r\n    }\r\n        final String[] hex_prefixes = { \"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\" };\r\n    int pfxLen = 0;\r\n    for (final String pfx : hex_prefixes) {\r\n        if (str.startsWith(pfx)) {\r\n            pfxLen += pfx.length();\r\n            break;\r\n        }\r\n    }\r\n    if (pfxLen > 0) {\r\n                final int hexDigits = str.length() - pfxLen;\r\n        if (hexDigits > 16) {\r\n                        return createBigInteger(str);\r\n        }\r\n        if (hexDigits > 8) {\r\n                        return createLong(str);\r\n        }\r\n        return createInteger(str);\r\n    }\r\n    final char lastChar = str.charAt(str.length() - 1);\r\n    String mant;\r\n    String dec;\r\n    String exp;\r\n    final int decPos = str.indexOf('.');\r\n        final int expPos = str.indexOf('e') + str.indexOf('E') + 1;\r\n                int numDecimals = 0;\r\n    if (decPos > -1) {\r\n        if (expPos > -1) {\r\n                        if (expPos < decPos || expPos > str.length()) {\r\n                                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            }\r\n            dec = str.substring(decPos + 1, expPos);\r\n        } else {\r\n            dec = str.substring(decPos + 1);\r\n        }\r\n        mant = str.substring(0, decPos);\r\n                numDecimals = dec.length();\r\n    } else {\r\n        if (expPos > -1) {\r\n            if (expPos > str.length()) {\r\n                                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            }\r\n            mant = str.substring(0, expPos);\r\n        } else {\r\n            mant = str;\r\n        }\r\n        dec = null;\r\n    }\r\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\r\n        if (expPos > -1 && expPos < str.length() - 1) {\r\n            exp = str.substring(expPos + 1, str.length() - 1);\r\n        } else {\r\n            exp = null;\r\n        }\r\n                final String numeric = str.substring(0, str.length() - 1);\r\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n        switch(lastChar) {\r\n            case 'l':\r\n            case 'L':\r\n                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\r\n                    try {\r\n                        return createLong(numeric);\r\n                    } catch (final NumberFormatException nfe) {\r\n                                                            }\r\n                    return createBigInteger(numeric);\r\n                }\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n            case 'f':\r\n            case 'F':\r\n                try {\r\n                    final Float f = NumberUtils.createFloat(numeric);\r\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                                                return f;\r\n                    }\r\n                } catch (final NumberFormatException nfe) {\r\n                                                }\r\n                        case 'd':\r\n            case 'D':\r\n                try {\r\n                    final Double d = NumberUtils.createDouble(numeric);\r\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\r\n                        return d;\r\n                    }\r\n                } catch (final NumberFormatException nfe) {\r\n                                                }\r\n                try {\r\n                    return createBigDecimal(numeric);\r\n                } catch (final NumberFormatException e) {\r\n                                                }\r\n                        default:\r\n                throw new NumberFormatException(str + \" is not a valid number.\");\r\n        }\r\n    }\r\n        if (expPos > -1 && expPos < str.length() - 1) {\r\n        exp = str.substring(expPos + 1, str.length());\r\n    } else {\r\n        exp = null;\r\n    }\r\n    if (dec == null && exp == null) {\r\n                try {\r\n            return createInteger(str);\r\n        } catch (final NumberFormatException nfe) {\r\n                        }\r\n        try {\r\n            return createLong(str);\r\n        } catch (final NumberFormatException nfe) {\r\n                        }\r\n        return createBigInteger(str);\r\n    }\r\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\r\n    try {\r\n        if (numDecimals <= 7) {\r\n                        final Float f = createFloat(str);\r\n            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\r\n                return f;\r\n            }\r\n        }\r\n    } catch (final NumberFormatException nfe) {\r\n            }\r\n    try {\r\n        if (numDecimals <= 16) {\r\n                        final Double d = createDouble(str);\r\n            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\r\n                return d;\r\n            }\r\n        }\r\n    } catch (final NumberFormatException nfe) {\r\n            }\r\n    return createBigDecimal(str);\r\n}","lc":5.5454545455,"pi":1.1722488038,"ma":8.2,"nbd":1.5,"ml":5.4166666667,"d":4.6031746032,"mi":-1.7021846371,"fo":4.0833333333,"r":-0.0263157895,"e":28.2385136264}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4000_38e928c1","label":1,"code":"\/**\r\n *  Render the child hierarchy headers.\r\n *\r\n *  @param headerContainer\r\n *  @param rootComponent\r\n *\/\r\n@Override\r\nprotected void renderChildHeaders(final HtmlHeaderContainer headerContainer, final Component rootComponent) {\r\n    Args.notNull(headerContainer, \"headerContainer\");\r\n    Args.notNull(rootComponent, \"rootComponent\");\r\n    if (rootComponent instanceof MarkupContainer) {\r\n        new DeepChildFirstVisitor() {\r\n\r\n            @Override\r\n            public void component(final Component component, final IVisit<Void> visit) {\r\n                component.renderHead(headerContainer);\r\n            }\r\n\r\n            @Override\r\n            public boolean preCheck(Component component) {\r\n                return component.isVisibleInHierarchy();\r\n            }\r\n        }.visit(rootComponent);\r\n    }\r\n}","code_comment":"\/**\r\n *  Render the child hierarchy headers.\r\n *\r\n *  @param headerContainer\r\n *  @param rootComponent\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void renderChildHeaders(final HtmlHeaderContainer headerContainer, final Component rootComponent) {\r\n    Args.notNull(headerContainer, \"headerContainer\");\r\n    Args.notNull(rootComponent, \"rootComponent\");\r\n    if (rootComponent instanceof MarkupContainer) {\r\n        new DeepChildFirstVisitor() {\r\n\r\n            @Override\r\n            public void component(final Component component, final IVisit<Void> visit) {\r\n                component.renderHead(headerContainer);\r\n            }\r\n\r\n            @Override\r\n            public boolean preCheck(Component component) {\r\n                return component.isVisibleInHierarchy();\r\n            }\r\n        }.visit(rootComponent);\r\n    }\r\n}","lc":0.1363636364,"pi":1.1100478469,"ma":-0.4,"nbd":0.0,"ml":-0.25,"d":-0.3650793651,"mi":-0.0638477801,"fo":-0.0833333333,"r":0.2105263158,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5215_033eb6fe","label":3,"code":"@Converter\r\npublic static InputStream genericFileToInputStream(GenericFile<?> file, Exchange exchange) throws IOException {\r\n    if (exchange != null) {\r\n        \/\/ use a file input stream if its a java.io.File\r\n        if (file.getFile() instanceof java.io.File) {\r\n            return IOHelper.buffered(new FileInputStream((File) file.getFile()));\r\n        }\r\n        \/\/ otherwise ensure the body is loaded as we want the input stream of the body\r\n        file.getBinding().loadContent(exchange, file);\r\n        return exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, file.getBody());\r\n    } else {\r\n        \/\/ should revert to fallback converter if we don't have an exchange\r\n        return null;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Converter\r\npublic static InputStream genericFileToInputStream(GenericFile<?> file, Exchange exchange) throws IOException {\r\n    if (exchange != null) {\r\n                if (file.getFile() instanceof java.io.File) {\r\n            return IOHelper.buffered(new FileInputStream((File) file.getFile()));\r\n        }\r\n                file.getBinding().loadContent(exchange, file);\r\n        return exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, file.getBody());\r\n    } else {\r\n                return null;\r\n    }\r\n}","lc":-0.0909090909,"pi":0.3732057416,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.0708949965,"fo":0.25,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Lang","project_version":"61","label":1,"code":"\/**\r\n * Searches the string builder to find the first reference to the specified\r\n * string starting searching from the given index.\r\n * <p>\r\n * Note that a null input string will return -1, whereas the JDK throws an exception.\r\n *\r\n * @param str  the string to find, null returns -1\r\n * @param startIndex  the index to start at, invalid index rounded to edge\r\n * @return the first index of the string, or -1 if not found\r\n *\/\r\npublic int indexOf(String str, int startIndex) {\r\n    startIndex = (startIndex < 0 ? 0 : startIndex);\r\n    if (str == null || startIndex >= size) {\r\n        return -1;\r\n    }\r\n    int strLen = str.length();\r\n    if (strLen == 1) {\r\n        return indexOf(str.charAt(0), startIndex);\r\n    }\r\n    if (strLen == 0) {\r\n        return startIndex;\r\n    }\r\n    if (strLen > size) {\r\n        return -1;\r\n    }\r\n    char[] thisBuf = buffer;\r\n    int len = thisBuf.length - strLen;\r\n    outer: for (int i = startIndex; i < len; i++) {\r\n        for (int j = 0; j < strLen; j++) {\r\n            if (str.charAt(j) != thisBuf[i + j]) {\r\n                continue outer;\r\n            }\r\n        }\r\n        return i;\r\n    }\r\n    return -1;\r\n}","code_comment":"\/**\r\n * Searches the string builder to find the first reference to the specified\r\n * string starting searching from the given index.\r\n * <p>\r\n * Note that a null input string will return -1, whereas the JDK throws an exception.\r\n *\r\n * @param str  the string to find, null returns -1\r\n * @param startIndex  the index to start at, invalid index rounded to edge\r\n * @return the first index of the string, or -1 if not found\r\n *\/\r\n","code_no_comment":"public int indexOf(String str, int startIndex) {\r\n    startIndex = (startIndex < 0 ? 0 : startIndex);\r\n    if (str == null || startIndex >= size) {\r\n        return -1;\r\n    }\r\n    int strLen = str.length();\r\n    if (strLen == 1) {\r\n        return indexOf(str.charAt(0), startIndex);\r\n    }\r\n    if (strLen == 0) {\r\n        return startIndex;\r\n    }\r\n    if (strLen > size) {\r\n        return -1;\r\n    }\r\n    char[] thisBuf = buffer;\r\n    int len = thisBuf.length - strLen;\r\n    outer: for (int i = startIndex; i < len; i++) {\r\n        for (int j = 0; j < strLen; j++) {\r\n            if (str.charAt(j) != thisBuf[i + j]) {\r\n                continue outer;\r\n            }\r\n        }\r\n        return i;\r\n    }\r\n    return -1;\r\n}","lc":0.5909090909,"pi":0.2440191388,"ma":1.2,"nbd":0.5,"ml":1.0,"d":2.7757936508,"mi":-0.4646934461,"fo":-0.1666666667,"r":-0.0263157895,"e":2.6445900543}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1640_8f321c72","label":1,"code":"\/**\r\n *  Returns the parent of a path or <code>null<\/code> if at root.\r\n *\r\n *  @return the parent of a path or <code>null<\/code> if at root.\r\n *\/\r\npublic Path getParent() {\r\n    final String path = uri.getPath();\r\n    final int lastSlash = path.lastIndexOf('\/');\r\n    final int start = hasWindowsDrive(path, true) ? 3 : 0;\r\n    if (\/\/ empty path\r\n    (path.length() == start) || (lastSlash == start && path.length() == start + 1)) {\r\n        \/\/ at root\r\n        return null;\r\n    }\r\n    String parent;\r\n    if (lastSlash == -1) {\r\n        parent = CUR_DIR;\r\n    } else {\r\n        final int end = hasWindowsDrive(path, true) ? 3 : 0;\r\n        parent = path.substring(0, lastSlash == end ? end + 1 : lastSlash);\r\n    }\r\n    return new Path(uri.getScheme(), uri.getAuthority(), parent);\r\n}","code_comment":"\/**\r\n *  Returns the parent of a path or <code>null<\/code> if at root.\r\n *\r\n *  @return the parent of a path or <code>null<\/code> if at root.\r\n *\/\r\n","code_no_comment":"public Path getParent() {\r\n    final String path = uri.getPath();\r\n    final int lastSlash = path.lastIndexOf('\/');\r\n    final int start = hasWindowsDrive(path, true) ? 3 : 0;\r\n    if (    (path.length() == start) || (lastSlash == start && path.length() == start + 1)) {\r\n                return null;\r\n    }\r\n    String parent;\r\n    if (lastSlash == -1) {\r\n        parent = CUR_DIR;\r\n    } else {\r\n        final int end = hasWindowsDrive(path, true) ? 3 : 0;\r\n        parent = path.substring(0, lastSlash == end ? end + 1 : lastSlash);\r\n    }\r\n    return new Path(uri.getScheme(), uri.getAuthority(), parent);\r\n}","lc":0.1363636364,"pi":-0.3157894737,"ma":0.4,"nbd":-0.5,"ml":0.6666666667,"d":0.9742063492,"mi":-0.2109936575,"fo":0.25,"r":-0.0263157895,"e":0.9061184973}
{"project_name":"Closure","project_version":"158","label":2,"code":"\/**\r\n * Add warning guards.\r\n *\/\r\nCommandLineConfig setJscompError(List<String> jscompError) {\r\n    this.jscompError.clear();\r\n    this.jscompError.addAll(jscompError);\r\n    return this;\r\n}","code_comment":"\/**\r\n * Add warning guards.\r\n *\/\r\n","code_no_comment":"CommandLineConfig setJscompError(List<String> jscompError) {\r\n    this.jscompError.clear();\r\n    this.jscompError.addAll(jscompError);\r\n    return this;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7237491191,"fo":-0.3333333333,"r":1.8157894737,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4376_037dea72","label":1,"code":"private Statement convertToStatement(String query) throws ParseException {\r\n    query = query.trim();\r\n    Statement statement = new Statement();\r\n    if (query.startsWith(\"explain \")) {\r\n        query = query.substring(\"explain\".length()).trim();\r\n        statement.setExplain(true);\r\n    }\r\n    if (query.startsWith(\"measure\")) {\r\n        query = query.substring(\"measure\".length()).trim();\r\n        statement.setMeasure(true);\r\n    }\r\n    if (query.isEmpty()) {\r\n        \/\/ special case, will always result in an empty result\r\n        query = \"\/\/jcr:root\";\r\n    }\r\n    statement.setOriginalQuery(query);\r\n    initialize(query);\r\n    expected = new ArrayList<String>();\r\n    read();\r\n    if (currentTokenType == END) {\r\n        throw getSyntaxError(\"the query may not be empty\");\r\n    }\r\n    currentSelector.name = \"a\";\r\n    String pathPattern = \"\";\r\n    boolean startOfQuery = true;\r\n    while (true) {\r\n        \/\/ if true, path or nodeType conditions are not allowed\r\n        boolean shortcut = false;\r\n        boolean slash = readIf(\"\/\");\r\n        if (!slash) {\r\n            if (startOfQuery) {\r\n                \/\/ the query doesn't start with \"\/\"\r\n                currentSelector.path = \"\/\";\r\n                pathPattern = \"\/\";\r\n                currentSelector.isChild = true;\r\n            } else {\r\n                break;\r\n            }\r\n        } else if (readIf(\"jcr:root\")) {\r\n            \/\/ \"\/jcr:root\" may only appear at the beginning\r\n            if (!pathPattern.isEmpty()) {\r\n                throw getSyntaxError(\"jcr:root needs to be at the beginning\");\r\n            }\r\n            if (readIf(\"\/\")) {\r\n                \/\/ \"\/jcr:root\/\"\r\n                currentSelector.path = \"\/\";\r\n                pathPattern = \"\/\";\r\n                if (readIf(\"\/\")) {\r\n                    \/\/ \"\/jcr:root\/\/\"\r\n                    pathPattern = \"\/\/\";\r\n                    currentSelector.isDescendant = true;\r\n                } else {\r\n                    currentSelector.isChild = true;\r\n                }\r\n            } else {\r\n                \/\/ for example \"\/jcr:root[condition]\"\r\n                pathPattern = \"\/%\";\r\n                currentSelector.path = \"\/\";\r\n                shortcut = true;\r\n            }\r\n        } else if (readIf(\"\/\")) {\r\n            \/\/ \"\/\/\" was read\r\n            pathPattern += \"%\";\r\n            currentSelector.isDescendant = true;\r\n        } else {\r\n            \/\/ the token \"\/\" was read\r\n            pathPattern += \"\/\";\r\n            if (startOfQuery) {\r\n                currentSelector.path = \"\/\";\r\n            } else {\r\n                currentSelector.isChild = true;\r\n            }\r\n        }\r\n        int startParseIndex = parseIndex;\r\n        if (shortcut) {\r\n        \/\/ \"*\" and so on are not allowed now\r\n        } else if (readIf(\"*\")) {\r\n            \/\/ \"...*\"\r\n            pathPattern += \"%\";\r\n            if (!currentSelector.isDescendant) {\r\n                if (selectors.size() == 0 && currentSelector.path.equals(\"\")) {\r\n                    \/\/ the query \/* is special\r\n                    currentSelector.path = \"\/\";\r\n                }\r\n            }\r\n        } else if (readIf(\"text\")) {\r\n            \/\/ \"...text()\"\r\n            currentSelector.isChild = false;\r\n            pathPattern += \"jcr:xmltext\";\r\n            read(\"(\");\r\n            read(\")\");\r\n            if (currentSelector.isDescendant) {\r\n                currentSelector.nodeName = \"jcr:xmltext\";\r\n            } else {\r\n                currentSelector.path = PathUtils.concat(currentSelector.path, \"jcr:xmltext\");\r\n            }\r\n        } else if (readIf(\"element\")) {\r\n            \/\/ \"...element(...\"\r\n            read(\"(\");\r\n            if (readIf(\")\")) {\r\n                \/\/ any\r\n                pathPattern += \"%\";\r\n            } else {\r\n                if (readIf(\"*\")) {\r\n                    \/\/ any\r\n                    pathPattern += \"%\";\r\n                } else {\r\n                    String name = readPathSegment();\r\n                    pathPattern += name;\r\n                    appendNodeName(name);\r\n                }\r\n                if (readIf(\",\")) {\r\n                    currentSelector.nodeType = readIdentifier();\r\n                }\r\n                read(\")\");\r\n            }\r\n        } else if (readIf(\"@\")) {\r\n            rewindSelector();\r\n            Expression.Property p = readProperty();\r\n            statement.addSelectColumn(p);\r\n        } else if (readIf(\"rep:excerpt\")) {\r\n            rewindSelector();\r\n            readExcerpt();\r\n            Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\r\n            statement.addSelectColumn(p);\r\n        } else if (readIf(\"(\")) {\r\n            rewindSelector();\r\n            do {\r\n                if (readIf(\"@\")) {\r\n                    Expression.Property p = readProperty();\r\n                    statement.addSelectColumn(p);\r\n                } else if (readIf(\"rep:excerpt\")) {\r\n                    readExcerpt();\r\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\r\n                    statement.addSelectColumn(p);\r\n                } else if (readIf(\"rep:spellcheck\")) {\r\n                    \/\/ only rep:spellcheck() is currently supported\r\n                    read(\"(\");\r\n                    read(\")\");\r\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:spellcheck()\", false);\r\n                    statement.addSelectColumn(p);\r\n                } else if (readIf(\"rep:suggest\")) {\r\n                    readExcerpt();\r\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:suggest()\", false);\r\n                    statement.addSelectColumn(p);\r\n                }\r\n            } while (readIf(\"|\"));\r\n            if (!readIf(\")\")) {\r\n                return convertToUnion(query, statement, startParseIndex - 1);\r\n            }\r\n        } else if (currentTokenType == IDENTIFIER) {\r\n            \/\/ path restriction\r\n            String name = readPathSegment();\r\n            pathPattern += name;\r\n            appendNodeName(name);\r\n        } else if (readIf(\".\")) {\r\n            \/\/ \"a\/.\/b\" is the same as \"a\/b\"\r\n            if (readIf(\".\")) {\r\n                \/\/ \"..\" means \"the parent of the node\"\r\n                \/\/ handle like a regular path restriction\r\n                String name = \"..\";\r\n                pathPattern += name;\r\n                if (!currentSelector.isChild) {\r\n                    currentSelector.nodeName = name;\r\n                } else {\r\n                    if (currentSelector.isChild) {\r\n                        currentSelector.isChild = false;\r\n                        currentSelector.isParent = true;\r\n                    }\r\n                }\r\n            } else {\r\n                if (selectors.size() > 0) {\r\n                    currentSelector = selectors.remove(selectors.size() - 1);\r\n                    currentSelector.condition = null;\r\n                    currentSelector.joinCondition = null;\r\n                }\r\n            }\r\n        } else {\r\n            throw getSyntaxError();\r\n        }\r\n        if (readIf(\"[\")) {\r\n            Expression c = parseConstraint();\r\n            currentSelector.condition = Expression.and(currentSelector.condition, c);\r\n            read(\"]\");\r\n        }\r\n        startOfQuery = false;\r\n        nextSelector(false);\r\n    }\r\n    if (selectors.size() == 0) {\r\n        nextSelector(true);\r\n    }\r\n    \/\/ the current selector wasn't used so far\r\n    \/\/ go back to the last one\r\n    currentSelector = selectors.get(selectors.size() - 1);\r\n    if (selectors.size() == 1) {\r\n        currentSelector.onlySelector = true;\r\n    }\r\n    if (readIf(\"order\")) {\r\n        read(\"by\");\r\n        do {\r\n            Order order = new Order();\r\n            order.expr = parseExpression();\r\n            if (readIf(\"descending\")) {\r\n                order.descending = true;\r\n            } else {\r\n                readIf(\"ascending\");\r\n            }\r\n            statement.addOrderBy(order);\r\n        } while (readIf(\",\"));\r\n    }\r\n    if (!currentToken.isEmpty()) {\r\n        throw getSyntaxError(\"<end>\");\r\n    }\r\n    statement.setColumnSelector(currentSelector);\r\n    statement.setSelectors(selectors);\r\n    Expression where = null;\r\n    for (Selector s : selectors) {\r\n        where = Expression.and(where, s.condition);\r\n    }\r\n    statement.setWhere(where);\r\n    return statement;\r\n}","code_comment":null,"code_no_comment":"private Statement convertToStatement(String query) throws ParseException {\r\n    query = query.trim();\r\n    Statement statement = new Statement();\r\n    if (query.startsWith(\"explain \")) {\r\n        query = query.substring(\"explain\".length()).trim();\r\n        statement.setExplain(true);\r\n    }\r\n    if (query.startsWith(\"measure\")) {\r\n        query = query.substring(\"measure\".length()).trim();\r\n        statement.setMeasure(true);\r\n    }\r\n    if (query.isEmpty()) {\r\n                query = \"\/\/jcr:root\";\r\n    }\r\n    statement.setOriginalQuery(query);\r\n    initialize(query);\r\n    expected = new ArrayList<String>();\r\n    read();\r\n    if (currentTokenType == END) {\r\n        throw getSyntaxError(\"the query may not be empty\");\r\n    }\r\n    currentSelector.name = \"a\";\r\n    String pathPattern = \"\";\r\n    boolean startOfQuery = true;\r\n    while (true) {\r\n                boolean shortcut = false;\r\n        boolean slash = readIf(\"\/\");\r\n        if (!slash) {\r\n            if (startOfQuery) {\r\n                                currentSelector.path = \"\/\";\r\n                pathPattern = \"\/\";\r\n                currentSelector.isChild = true;\r\n            } else {\r\n                break;\r\n            }\r\n        } else if (readIf(\"jcr:root\")) {\r\n                        if (!pathPattern.isEmpty()) {\r\n                throw getSyntaxError(\"jcr:root needs to be at the beginning\");\r\n            }\r\n            if (readIf(\"\/\")) {\r\n                                currentSelector.path = \"\/\";\r\n                pathPattern = \"\/\";\r\n                if (readIf(\"\/\")) {\r\n                                        pathPattern = \"\/\/\";\r\n                    currentSelector.isDescendant = true;\r\n                } else {\r\n                    currentSelector.isChild = true;\r\n                }\r\n            } else {\r\n                                pathPattern = \"\/%\";\r\n                currentSelector.path = \"\/\";\r\n                shortcut = true;\r\n            }\r\n        } else if (readIf(\"\/\")) {\r\n                        pathPattern += \"%\";\r\n            currentSelector.isDescendant = true;\r\n        } else {\r\n                        pathPattern += \"\/\";\r\n            if (startOfQuery) {\r\n                currentSelector.path = \"\/\";\r\n            } else {\r\n                currentSelector.isChild = true;\r\n            }\r\n        }\r\n        int startParseIndex = parseIndex;\r\n        if (shortcut) {\r\n                } else if (readIf(\"*\")) {\r\n                        pathPattern += \"%\";\r\n            if (!currentSelector.isDescendant) {\r\n                if (selectors.size() == 0 && currentSelector.path.equals(\"\")) {\r\n                                        currentSelector.path = \"\/\";\r\n                }\r\n            }\r\n        } else if (readIf(\"text\")) {\r\n                        currentSelector.isChild = false;\r\n            pathPattern += \"jcr:xmltext\";\r\n            read(\"(\");\r\n            read(\")\");\r\n            if (currentSelector.isDescendant) {\r\n                currentSelector.nodeName = \"jcr:xmltext\";\r\n            } else {\r\n                currentSelector.path = PathUtils.concat(currentSelector.path, \"jcr:xmltext\");\r\n            }\r\n        } else if (readIf(\"element\")) {\r\n                        read(\"(\");\r\n            if (readIf(\")\")) {\r\n                                pathPattern += \"%\";\r\n            } else {\r\n                if (readIf(\"*\")) {\r\n                                        pathPattern += \"%\";\r\n                } else {\r\n                    String name = readPathSegment();\r\n                    pathPattern += name;\r\n                    appendNodeName(name);\r\n                }\r\n                if (readIf(\",\")) {\r\n                    currentSelector.nodeType = readIdentifier();\r\n                }\r\n                read(\")\");\r\n            }\r\n        } else if (readIf(\"@\")) {\r\n            rewindSelector();\r\n            Expression.Property p = readProperty();\r\n            statement.addSelectColumn(p);\r\n        } else if (readIf(\"rep:excerpt\")) {\r\n            rewindSelector();\r\n            readExcerpt();\r\n            Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\r\n            statement.addSelectColumn(p);\r\n        } else if (readIf(\"(\")) {\r\n            rewindSelector();\r\n            do {\r\n                if (readIf(\"@\")) {\r\n                    Expression.Property p = readProperty();\r\n                    statement.addSelectColumn(p);\r\n                } else if (readIf(\"rep:excerpt\")) {\r\n                    readExcerpt();\r\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\r\n                    statement.addSelectColumn(p);\r\n                } else if (readIf(\"rep:spellcheck\")) {\r\n                                        read(\"(\");\r\n                    read(\")\");\r\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:spellcheck()\", false);\r\n                    statement.addSelectColumn(p);\r\n                } else if (readIf(\"rep:suggest\")) {\r\n                    readExcerpt();\r\n                    Expression.Property p = new Expression.Property(currentSelector, \"rep:suggest()\", false);\r\n                    statement.addSelectColumn(p);\r\n                }\r\n            } while (readIf(\"|\"));\r\n            if (!readIf(\")\")) {\r\n                return convertToUnion(query, statement, startParseIndex - 1);\r\n            }\r\n        } else if (currentTokenType == IDENTIFIER) {\r\n                        String name = readPathSegment();\r\n            pathPattern += name;\r\n            appendNodeName(name);\r\n        } else if (readIf(\".\")) {\r\n                        if (readIf(\".\")) {\r\n                                                String name = \"..\";\r\n                pathPattern += name;\r\n                if (!currentSelector.isChild) {\r\n                    currentSelector.nodeName = name;\r\n                } else {\r\n                    if (currentSelector.isChild) {\r\n                        currentSelector.isChild = false;\r\n                        currentSelector.isParent = true;\r\n                    }\r\n                }\r\n            } else {\r\n                if (selectors.size() > 0) {\r\n                    currentSelector = selectors.remove(selectors.size() - 1);\r\n                    currentSelector.condition = null;\r\n                    currentSelector.joinCondition = null;\r\n                }\r\n            }\r\n        } else {\r\n            throw getSyntaxError();\r\n        }\r\n        if (readIf(\"[\")) {\r\n            Expression c = parseConstraint();\r\n            currentSelector.condition = Expression.and(currentSelector.condition, c);\r\n            read(\"]\");\r\n        }\r\n        startOfQuery = false;\r\n        nextSelector(false);\r\n    }\r\n    if (selectors.size() == 0) {\r\n        nextSelector(true);\r\n    }\r\n            currentSelector = selectors.get(selectors.size() - 1);\r\n    if (selectors.size() == 1) {\r\n        currentSelector.onlySelector = true;\r\n    }\r\n    if (readIf(\"order\")) {\r\n        read(\"by\");\r\n        do {\r\n            Order order = new Order();\r\n            order.expr = parseExpression();\r\n            if (readIf(\"descending\")) {\r\n                order.descending = true;\r\n            } else {\r\n                readIf(\"ascending\");\r\n            }\r\n            statement.addOrderBy(order);\r\n        } while (readIf(\",\"));\r\n    }\r\n    if (!currentToken.isEmpty()) {\r\n        throw getSyntaxError(\"<end>\");\r\n    }\r\n    statement.setColumnSelector(currentSelector);\r\n    statement.setSelectors(selectors);\r\n    Expression where = null;\r\n    for (Selector s : selectors) {\r\n        where = Expression.and(where, s.condition);\r\n    }\r\n    statement.setWhere(where);\r\n    return statement;\r\n}","lc":8.4090909091,"pi":1.1435406699,"ma":9.6,"nbd":5.5,"ml":5.9166666667,"d":1.7678571429,"mi":-1.969415081,"fo":7.5,"r":-0.0263157895,"e":16.7681033638}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-705_645d642b","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH) {\r\n    if (!vectorsInitialized) {\r\n        if (v == null) {\r\n            v = new double[7][];\r\n            for (int k = 0; k < 7; ++k) {\r\n                v[k] = new double[interpolatedState.length];\r\n            }\r\n        }\r\n        \/\/ perform the last evaluations if they have not been done yet\r\n        finalizeStep();\r\n        \/\/ compute the interpolation vectors for this time step\r\n        for (int i = 0; i < interpolatedState.length; ++i) {\r\n            final double yDot1 = yDotK[0][i];\r\n            final double yDot6 = yDotK[5][i];\r\n            final double yDot7 = yDotK[6][i];\r\n            final double yDot8 = yDotK[7][i];\r\n            final double yDot9 = yDotK[8][i];\r\n            final double yDot10 = yDotK[9][i];\r\n            final double yDot11 = yDotK[10][i];\r\n            final double yDot12 = yDotK[11][i];\r\n            final double yDot13 = yDotK[12][i];\r\n            final double yDot14 = yDotKLast[0][i];\r\n            final double yDot15 = yDotKLast[1][i];\r\n            final double yDot16 = yDotKLast[2][i];\r\n            v[0][i] = B_01 * yDot1 + B_06 * yDot6 + B_07 * yDot7 + B_08 * yDot8 + B_09 * yDot9 + B_10 * yDot10 + B_11 * yDot11 + B_12 * yDot12;\r\n            v[1][i] = yDot1 - v[0][i];\r\n            v[2][i] = v[0][i] - v[1][i] - yDotK[12][i];\r\n            for (int k = 0; k < D.length; ++k) {\r\n                v[k + 3][i] = D[k][0] * yDot1 + D[k][1] * yDot6 + D[k][2] * yDot7 + D[k][3] * yDot8 + D[k][4] * yDot9 + D[k][5] * yDot10 + D[k][6] * yDot11 + D[k][7] * yDot12 + D[k][8] * yDot13 + D[k][9] * yDot14 + D[k][10] * yDot15 + D[k][11] * yDot16;\r\n            }\r\n        }\r\n        vectorsInitialized = true;\r\n    }\r\n    final double eta = 1 - theta;\r\n    final double twoTheta = 2 * theta;\r\n    final double theta2 = theta * theta;\r\n    final double dot1 = 1 - twoTheta;\r\n    final double dot2 = theta * (2 - 3 * theta);\r\n    final double dot3 = twoTheta * (1 + theta * (twoTheta - 3));\r\n    final double dot4 = theta2 * (3 + theta * (5 * theta - 8));\r\n    final double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));\r\n    final double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));\r\n    for (int i = 0; i < interpolatedState.length; ++i) {\r\n        interpolatedState[i] = currentState[i] - oneMinusThetaH * (v[0][i] - theta * (v[1][i] + theta * (v[2][i] + eta * (v[3][i] + theta * (v[4][i] + eta * (v[5][i] + theta * (v[6][i])))))));\r\n        interpolatedDerivatives[i] = v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] + dot3 * v[3][i] + dot4 * v[4][i] + dot5 * v[5][i] + dot6 * v[6][i];\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH) {\r\n    if (!vectorsInitialized) {\r\n        if (v == null) {\r\n            v = new double[7][];\r\n            for (int k = 0; k < 7; ++k) {\r\n                v[k] = new double[interpolatedState.length];\r\n            }\r\n        }\r\n                finalizeStep();\r\n                for (int i = 0; i < interpolatedState.length; ++i) {\r\n            final double yDot1 = yDotK[0][i];\r\n            final double yDot6 = yDotK[5][i];\r\n            final double yDot7 = yDotK[6][i];\r\n            final double yDot8 = yDotK[7][i];\r\n            final double yDot9 = yDotK[8][i];\r\n            final double yDot10 = yDotK[9][i];\r\n            final double yDot11 = yDotK[10][i];\r\n            final double yDot12 = yDotK[11][i];\r\n            final double yDot13 = yDotK[12][i];\r\n            final double yDot14 = yDotKLast[0][i];\r\n            final double yDot15 = yDotKLast[1][i];\r\n            final double yDot16 = yDotKLast[2][i];\r\n            v[0][i] = B_01 * yDot1 + B_06 * yDot6 + B_07 * yDot7 + B_08 * yDot8 + B_09 * yDot9 + B_10 * yDot10 + B_11 * yDot11 + B_12 * yDot12;\r\n            v[1][i] = yDot1 - v[0][i];\r\n            v[2][i] = v[0][i] - v[1][i] - yDotK[12][i];\r\n            for (int k = 0; k < D.length; ++k) {\r\n                v[k + 3][i] = D[k][0] * yDot1 + D[k][1] * yDot6 + D[k][2] * yDot7 + D[k][3] * yDot8 + D[k][4] * yDot9 + D[k][5] * yDot10 + D[k][6] * yDot11 + D[k][7] * yDot12 + D[k][8] * yDot13 + D[k][9] * yDot14 + D[k][10] * yDot15 + D[k][11] * yDot16;\r\n            }\r\n        }\r\n        vectorsInitialized = true;\r\n    }\r\n    final double eta = 1 - theta;\r\n    final double twoTheta = 2 * theta;\r\n    final double theta2 = theta * theta;\r\n    final double dot1 = 1 - twoTheta;\r\n    final double dot2 = theta * (2 - 3 * theta);\r\n    final double dot3 = twoTheta * (1 + theta * (twoTheta - 3));\r\n    final double dot4 = theta2 * (3 + theta * (5 * theta - 8));\r\n    final double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));\r\n    final double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));\r\n    for (int i = 0; i < interpolatedState.length; ++i) {\r\n        interpolatedState[i] = currentState[i] - oneMinusThetaH * (v[0][i] - theta * (v[1][i] + theta * (v[2][i] + eta * (v[3][i] + theta * (v[4][i] + eta * (v[5][i] + theta * (v[6][i])))))));\r\n        interpolatedDerivatives[i] = v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] + dot3 * v[3][i] + dot4 * v[4][i] + dot5 * v[5][i] + dot6 * v[6][i];\r\n    }\r\n}","lc":1.4545454545,"pi":0.6124401914,"ma":0.6,"nbd":0.5,"ml":0.5833333333,"d":3.2638888889,"mi":-0.9715292459,"fo":-0.4166666667,"r":-0.0263157895,"e":22.1821591374}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5359_61122bab","label":3,"code":"\/**\r\n *  Converts this StringValue to a given type or {@code null} if the value is empty.\r\n *\r\n *  @param type\r\n *             The type to convert to\r\n *  @return The converted value\r\n *  @throws StringValueConversionException\r\n *\/\r\npublic final <T> T toOptional(final Class<T> type) throws StringValueConversionException {\r\n    return Strings.isEmpty(text) ? null : to(type);\r\n}","code_comment":"\/**\r\n *  Converts this StringValue to a given type or {@code null} if the value is empty.\r\n *\r\n *  @param type\r\n *             The type to convert to\r\n *  @return The converted value\r\n *  @throws StringValueConversionException\r\n *\/\r\n","code_no_comment":"public final <T> T toOptional(final Class<T> type) throws StringValueConversionException {\r\n    return Strings.isEmpty(text) ? null : to(type);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.8942917548,"fo":-0.3333333333,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1732_941e3cb1","label":3,"code":"\/**\r\n * Initialize a scanner over the given input split using this task attempt configuration.\r\n *\/\r\npublic void initialize(InputSplit inSplit, JobConf job) throws IOException {\r\n    Scanner scanner;\r\n    split = (RangeInputSplit) inSplit;\r\n    log.debug(\"Initializing input split: \" + split.getRange());\r\n    Instance instance = getInstance(job);\r\n    String principal = getPrincipal(job);\r\n    AuthenticationToken token = getAuthenticationToken(job);\r\n    Authorizations authorizations = getScanAuthorizations(job);\r\n    \/\/ in case the table name changed, we can still use the previous name for terms of configuration,\r\n    \/\/ but the scanner will use the table id resolved at job setup time\r\n    BatchScanConfig tableConfig = getBatchScanConfig(job, split.getTableName());\r\n    try {\r\n        log.debug(\"Creating connector with user: \" + principal);\r\n        log.debug(\"Creating scanner for table: \" + split.getTableName());\r\n        log.debug(\"Authorizations are: \" + authorizations);\r\n        if (tableConfig.isOfflineScan()) {\r\n            scanner = new OfflineScanner(instance, new Credentials(principal, token), split.getTableId(), authorizations);\r\n        } else {\r\n            scanner = new ScannerImpl(instance, new Credentials(principal, token), split.getTableId(), authorizations);\r\n        }\r\n        if (tableConfig.shouldUseIsolatedScanners()) {\r\n            log.info(\"Creating isolated scanner\");\r\n            scanner = new IsolatedScanner(scanner);\r\n        }\r\n        if (tableConfig.shouldUseLocalIterators()) {\r\n            log.info(\"Using local iterators\");\r\n            scanner = new ClientSideIteratorScanner(scanner);\r\n        }\r\n        setupIterators(job, scanner, split.getTableId());\r\n    } catch (Exception e) {\r\n        throw new IOException(e);\r\n    }\r\n    \/\/ setup a scanner within the bounds of this split\r\n    for (Pair<Text, Text> c : tableConfig.getFetchedColumns()) {\r\n        if (c.getSecond() != null) {\r\n            log.debug(\"Fetching column \" + c.getFirst() + \":\" + c.getSecond());\r\n            scanner.fetchColumn(c.getFirst(), c.getSecond());\r\n        } else {\r\n            log.debug(\"Fetching column family \" + c.getFirst());\r\n            scanner.fetchColumnFamily(c.getFirst());\r\n        }\r\n    }\r\n    scanner.setRange(split.getRange());\r\n    numKeysRead = 0;\r\n    \/\/ do this last after setting all scanner options\r\n    scannerIterator = scanner.iterator();\r\n}","code_comment":"\/**\r\n * Initialize a scanner over the given input split using this task attempt configuration.\r\n *\/\r\n","code_no_comment":"public void initialize(InputSplit inSplit, JobConf job) throws IOException {\r\n    Scanner scanner;\r\n    split = (RangeInputSplit) inSplit;\r\n    log.debug(\"Initializing input split: \" + split.getRange());\r\n    Instance instance = getInstance(job);\r\n    String principal = getPrincipal(job);\r\n    AuthenticationToken token = getAuthenticationToken(job);\r\n    Authorizations authorizations = getScanAuthorizations(job);\r\n            BatchScanConfig tableConfig = getBatchScanConfig(job, split.getTableName());\r\n    try {\r\n        log.debug(\"Creating connector with user: \" + principal);\r\n        log.debug(\"Creating scanner for table: \" + split.getTableName());\r\n        log.debug(\"Authorizations are: \" + authorizations);\r\n        if (tableConfig.isOfflineScan()) {\r\n            scanner = new OfflineScanner(instance, new Credentials(principal, token), split.getTableId(), authorizations);\r\n        } else {\r\n            scanner = new ScannerImpl(instance, new Credentials(principal, token), split.getTableId(), authorizations);\r\n        }\r\n        if (tableConfig.shouldUseIsolatedScanners()) {\r\n            log.info(\"Creating isolated scanner\");\r\n            scanner = new IsolatedScanner(scanner);\r\n        }\r\n        if (tableConfig.shouldUseLocalIterators()) {\r\n            log.info(\"Using local iterators\");\r\n            scanner = new ClientSideIteratorScanner(scanner);\r\n        }\r\n        setupIterators(job, scanner, split.getTableId());\r\n    } catch (Exception e) {\r\n        throw new IOException(e);\r\n    }\r\n        for (Pair<Text, Text> c : tableConfig.getFetchedColumns()) {\r\n        if (c.getSecond() != null) {\r\n            log.debug(\"Fetching column \" + c.getFirst() + \":\" + c.getSecond());\r\n            scanner.fetchColumn(c.getFirst(), c.getSecond());\r\n        } else {\r\n            log.debug(\"Fetching column family \" + c.getFirst());\r\n            scanner.fetchColumnFamily(c.getFirst());\r\n        }\r\n    }\r\n    scanner.setRange(split.getRange());\r\n    numKeysRead = 0;\r\n        scannerIterator = scanner.iterator();\r\n}","lc":1.3181818182,"pi":0.2105263158,"ma":0.8,"nbd":0.0,"ml":0.25,"d":0.0496031746,"mi":-0.7981677237,"fo":2.5,"r":-0.0263157895,"e":0.7616996018}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1251_424068f7","label":1,"code":"\/**\r\n * Unsupported operation.\r\n * @throws UnsupportedOperationException always\r\n *\/\r\n@Override\r\npublic void setParent(final Logger parent) {\r\n    throw new UnsupportedOperationException(\"Cannot set parent logger\");\r\n}","code_comment":"\/**\r\n * Unsupported operation.\r\n * @throws UnsupportedOperationException always\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void setParent(final Logger parent) {\r\n    throw new UnsupportedOperationException(\"Cannot set parent logger\");\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.4,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8951374207,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-579_7d72e6ed","label":3,"code":"@Override\r\npublic String getPlan(NodeState rootState) {\r\n    StringBuilder buff = new StringBuilder();\r\n    buff.append(toString());\r\n    buff.append(\" \/* \").append(index.getPlan(createFilter(), rootState));\r\n    if (selectorCondition != null) {\r\n        buff.append(\" where \").append(selectorCondition);\r\n    }\r\n    buff.append(\" *\/\");\r\n    return buff.toString();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String getPlan(NodeState rootState) {\r\n    StringBuilder buff = new StringBuilder();\r\n    buff.append(toString());\r\n    buff.append(\" \/* \").append(index.getPlan(createFilter(), rootState));\r\n    if (selectorCondition != null) {\r\n        buff.append(\" where \").append(selectorCondition);\r\n    }\r\n    buff.append(\" *\/\");\r\n    return buff.toString();\r\n}","lc":-0.1363636364,"pi":-0.3301435407,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.0079365079,"mi":0.1408033827,"fo":0.3333333333,"r":1.6578947368,"e":-0.0374520957}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4038_557eec4f","label":1,"code":"@Override\r\npublic SelectorImpl getSelector() {\r\n    return selector;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic SelectorImpl getSelector() {\r\n    return selector;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9785764623,"fo":-0.5,"r":2.0526315789,"e":-0.1627934049}
{"project_name":"Closure","project_version":"173","label":2,"code":"void add(Node n, Context context) {\r\n    if (!cc.continueProcessing()) {\r\n        return;\r\n    }\r\n    int type = n.getType();\r\n    String opstr = NodeUtil.opToStr(type);\r\n    int childCount = n.getChildCount();\r\n    Node first = n.getFirstChild();\r\n    Node last = n.getLastChild();\r\n    \/\/ Handle all binary operators\r\n    if (opstr != null && first != last) {\r\n        Preconditions.checkState(childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\r\n        int p = NodeUtil.precedence(type);\r\n        \/\/ For right-hand-side of operations, only pass context if it's\r\n        \/\/ the IN_FOR_INIT_CLAUSE one.\r\n        Context rhsContext = getContextForNoInOperator(context);\r\n        if (last.getType() == type && NodeUtil.isAssociative(type)) {\r\n            addExpr(first, p, context);\r\n            cc.addOp(opstr, true);\r\n            addExpr(last, p, rhsContext);\r\n        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\r\n            \/\/ Assignments are the only right-associative binary operators\r\n            addExpr(first, p, context);\r\n            cc.addOp(opstr, true);\r\n            addExpr(last, p, rhsContext);\r\n        } else {\r\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\r\n        }\r\n        return;\r\n    }\r\n    cc.startSourceMapping(n);\r\n    switch(type) {\r\n        case Token.TRY:\r\n            {\r\n                Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());\r\n                Preconditions.checkState(childCount >= 2 && childCount <= 3);\r\n                add(\"try\");\r\n                add(first, Context.PRESERVE_BLOCK);\r\n                \/\/ second child contains the catch block, or nothing if there\r\n                \/\/ isn't a catch block\r\n                Node catchblock = first.getNext().getFirstChild();\r\n                if (catchblock != null) {\r\n                    add(catchblock);\r\n                }\r\n                if (childCount == 3) {\r\n                    add(\"finally\");\r\n                    add(last, Context.PRESERVE_BLOCK);\r\n                }\r\n                break;\r\n            }\r\n        case Token.CATCH:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"catch(\");\r\n            add(first);\r\n            add(\")\");\r\n            add(last, Context.PRESERVE_BLOCK);\r\n            break;\r\n        case Token.THROW:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"throw\");\r\n            add(first);\r\n            \/\/ Must have a ';' after a throw statement, otherwise safari can't\r\n            \/\/ parse this.\r\n            cc.endStatement(true);\r\n            break;\r\n        case Token.RETURN:\r\n            add(\"return\");\r\n            if (childCount == 1) {\r\n                add(first);\r\n            } else {\r\n                Preconditions.checkState(childCount == 0);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.VAR:\r\n            if (first != null) {\r\n                add(\"var \");\r\n                addList(first, false, getContextForNoInOperator(context));\r\n            }\r\n            break;\r\n        case Token.LABEL_NAME:\r\n            Preconditions.checkState(!n.getString().isEmpty());\r\n            addIdentifier(n.getString());\r\n            break;\r\n        case Token.NAME:\r\n            if (first == null || first.isEmpty()) {\r\n                addIdentifier(n.getString());\r\n            } else {\r\n                Preconditions.checkState(childCount == 1);\r\n                addIdentifier(n.getString());\r\n                cc.addOp(\"=\", true);\r\n                if (first.isComma()) {\r\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\r\n                } else {\r\n                    \/\/ Add expression, consider nearby code at lowest level of\r\n                    \/\/ precedence.\r\n                    addExpr(first, 0, getContextForNoInOperator(context));\r\n                }\r\n            }\r\n            break;\r\n        case Token.ARRAYLIT:\r\n            add(\"[\");\r\n            addArrayList(first);\r\n            add(\"]\");\r\n            break;\r\n        case Token.PARAM_LIST:\r\n            add(\"(\");\r\n            addList(first);\r\n            add(\")\");\r\n            break;\r\n        case Token.COMMA:\r\n            Preconditions.checkState(childCount == 2);\r\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, getContextForNoInOperator(context), 0, 0);\r\n            break;\r\n        case Token.NUMBER:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addNumber(n.getDouble());\r\n            break;\r\n        case Token.TYPEOF:\r\n        case Token.VOID:\r\n        case Token.NOT:\r\n        case Token.BITNOT:\r\n        case Token.POS:\r\n            {\r\n                \/\/ All of these unary operators are right-associative\r\n                Preconditions.checkState(childCount == 1);\r\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\r\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\r\n                break;\r\n            }\r\n        case Token.NEG:\r\n            {\r\n                Preconditions.checkState(childCount == 1);\r\n                \/\/ NEG is a weird case because Rhino parses \"- -2\" as \"2\".\r\n                if (n.getFirstChild().isNumber()) {\r\n                    cc.addNumber(-n.getFirstChild().getDouble());\r\n                } else {\r\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\r\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\r\n                }\r\n                break;\r\n            }\r\n        case Token.HOOK:\r\n            {\r\n                Preconditions.checkState(childCount == 3);\r\n                int p = NodeUtil.precedence(type);\r\n                Context rhsContext = getContextForNoInOperator(context);\r\n                addExpr(first, p + 1, context);\r\n                cc.addOp(\"?\", true);\r\n                addExpr(first.getNext(), 1, rhsContext);\r\n                cc.addOp(\":\", true);\r\n                addExpr(last, 1, rhsContext);\r\n                break;\r\n            }\r\n        case Token.REGEXP:\r\n            if (!first.isString() || !last.isString()) {\r\n                throw new Error(\"Expected children to be strings\");\r\n            }\r\n            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\r\n            \/\/ I only use one .add because whitespace matters\r\n            if (childCount == 2) {\r\n                add(regexp + last.getString());\r\n            } else {\r\n                Preconditions.checkState(childCount == 1);\r\n                add(regexp);\r\n            }\r\n            break;\r\n        case Token.FUNCTION:\r\n            if (n.getClass() != Node.class) {\r\n                throw new Error(\"Unexpected Node subclass.\");\r\n            }\r\n            Preconditions.checkState(childCount == 3);\r\n            boolean funcNeedsParens = (context == Context.START_OF_EXPR);\r\n            if (funcNeedsParens) {\r\n                add(\"(\");\r\n            }\r\n            add(\"function\");\r\n            add(first);\r\n            add(first.getNext());\r\n            add(last, Context.PRESERVE_BLOCK);\r\n            cc.endFunction(context == Context.STATEMENT);\r\n            if (funcNeedsParens) {\r\n                add(\")\");\r\n            }\r\n            break;\r\n        case Token.GETTER_DEF:\r\n        case Token.SETTER_DEF:\r\n            Preconditions.checkState(n.getParent().isObjectLit());\r\n            Preconditions.checkState(childCount == 1);\r\n            Preconditions.checkState(first.isFunction());\r\n            \/\/ Get methods are unnamed\r\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\r\n            if (type == Token.GETTER_DEF) {\r\n                \/\/ Get methods have no parameters.\r\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\r\n                add(\"get \");\r\n            } else {\r\n                \/\/ Set methods have one parameter.\r\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\r\n                add(\"set \");\r\n            }\r\n            \/\/ The name is on the GET or SET node.\r\n            String name = n.getString();\r\n            Node fn = first;\r\n            Node parameters = fn.getChildAtIndex(1);\r\n            Node body = fn.getLastChild();\r\n            \/\/ Add the property name.\r\n            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && \/\/ Unicode escaped.\r\n            NodeUtil.isLatin(name)) {\r\n                add(name);\r\n            } else {\r\n                \/\/ Determine if the string is a simple number.\r\n                double d = getSimpleNumber(name);\r\n                if (!Double.isNaN(d)) {\r\n                    cc.addNumber(d);\r\n                } else {\r\n                    addJsString(n);\r\n                }\r\n            }\r\n            add(parameters);\r\n            add(body, Context.PRESERVE_BLOCK);\r\n            break;\r\n        case Token.SCRIPT:\r\n        case Token.BLOCK:\r\n            {\r\n                if (n.getClass() != Node.class) {\r\n                    throw new Error(\"Unexpected Node subclass.\");\r\n                }\r\n                boolean preserveBlock = context == Context.PRESERVE_BLOCK;\r\n                if (preserveBlock) {\r\n                    cc.beginBlock();\r\n                }\r\n                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());\r\n                for (Node c = first; c != null; c = c.getNext()) {\r\n                    add(c, Context.STATEMENT);\r\n                    \/\/ VAR doesn't include ';' since it gets used in expressions\r\n                    if (c.isVar()) {\r\n                        cc.endStatement();\r\n                    }\r\n                    if (c.isFunction()) {\r\n                        cc.maybeLineBreak();\r\n                    }\r\n                    \/\/ because top-level statements are more homogeneous.\r\n                    if (preferLineBreaks) {\r\n                        cc.notePreferredLineBreak();\r\n                    }\r\n                }\r\n                if (preserveBlock) {\r\n                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\r\n                }\r\n                break;\r\n            }\r\n        case Token.FOR:\r\n            if (childCount == 4) {\r\n                add(\"for(\");\r\n                if (first.isVar()) {\r\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\r\n                } else {\r\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\r\n                }\r\n                add(\";\");\r\n                add(first.getNext());\r\n                add(\";\");\r\n                add(first.getNext().getNext());\r\n                add(\")\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            } else {\r\n                Preconditions.checkState(childCount == 3);\r\n                add(\"for(\");\r\n                add(first);\r\n                add(\"in\");\r\n                add(first.getNext());\r\n                add(\")\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            }\r\n            break;\r\n        case Token.DO:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"do\");\r\n            addNonEmptyStatement(first, Context.OTHER, false);\r\n            add(\"while(\");\r\n            add(last);\r\n            add(\")\");\r\n            cc.endStatement();\r\n            break;\r\n        case Token.WHILE:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"while(\");\r\n            add(first);\r\n            add(\")\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            break;\r\n        case Token.EMPTY:\r\n            Preconditions.checkState(childCount == 0);\r\n            break;\r\n        case Token.GETPROP:\r\n            {\r\n                Preconditions.checkState(childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\r\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\r\n                boolean needsParens = (first.isNumber());\r\n                if (needsParens) {\r\n                    add(\"(\");\r\n                }\r\n                addExpr(first, NodeUtil.precedence(type), context);\r\n                if (needsParens) {\r\n                    add(\")\");\r\n                }\r\n                if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {\r\n                    \/\/ Check for ECMASCRIPT3 keywords.\r\n                    add(\"[\");\r\n                    add(last);\r\n                    add(\"]\");\r\n                } else {\r\n                    add(\".\");\r\n                    addIdentifier(last.getString());\r\n                }\r\n                break;\r\n            }\r\n        case Token.GETELEM:\r\n            Preconditions.checkState(childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\r\n            addExpr(first, NodeUtil.precedence(type), context);\r\n            add(\"[\");\r\n            add(first.getNext());\r\n            add(\"]\");\r\n            break;\r\n        case Token.WITH:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"with(\");\r\n            add(first);\r\n            add(\")\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            break;\r\n        case Token.INC:\r\n        case Token.DEC:\r\n            {\r\n                Preconditions.checkState(childCount == 1);\r\n                String o = type == Token.INC ? \"++\" : \"--\";\r\n                int postProp = n.getIntProp(Node.INCRDECR_PROP);\r\n                \/\/ is a pre-inc\/dec.\r\n                if (postProp != 0) {\r\n                    addExpr(first, NodeUtil.precedence(type), context);\r\n                    cc.addOp(o, false);\r\n                } else {\r\n                    cc.addOp(o, false);\r\n                    add(first);\r\n                }\r\n                break;\r\n            }\r\n        case Token.CALL:\r\n            \/\/ that must be preserved.\r\n            if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\r\n                add(\"(0,\");\r\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\r\n                add(\")\");\r\n            } else {\r\n                addExpr(first, NodeUtil.precedence(type), context);\r\n            }\r\n            add(\"(\");\r\n            addList(first.getNext());\r\n            add(\")\");\r\n            break;\r\n        case Token.IF:\r\n            boolean hasElse = childCount == 3;\r\n            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;\r\n            if (ambiguousElseClause) {\r\n                cc.beginBlock();\r\n            }\r\n            add(\"if(\");\r\n            add(first);\r\n            add(\")\");\r\n            if (hasElse) {\r\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\r\n                add(\"else\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            } else {\r\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\r\n                Preconditions.checkState(childCount == 2);\r\n            }\r\n            if (ambiguousElseClause) {\r\n                cc.endBlock();\r\n            }\r\n            break;\r\n        case Token.NULL:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addConstant(\"null\");\r\n            break;\r\n        case Token.THIS:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"this\");\r\n            break;\r\n        case Token.FALSE:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addConstant(\"false\");\r\n            break;\r\n        case Token.TRUE:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addConstant(\"true\");\r\n            break;\r\n        case Token.CONTINUE:\r\n            Preconditions.checkState(childCount <= 1);\r\n            add(\"continue\");\r\n            if (childCount == 1) {\r\n                if (!first.isLabelName()) {\r\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n                }\r\n                add(\" \");\r\n                add(first);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.DEBUGGER:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"debugger\");\r\n            cc.endStatement();\r\n            break;\r\n        case Token.BREAK:\r\n            Preconditions.checkState(childCount <= 1);\r\n            add(\"break\");\r\n            if (childCount == 1) {\r\n                if (!first.isLabelName()) {\r\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n                }\r\n                add(\" \");\r\n                add(first);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.EXPR_RESULT:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(first, Context.START_OF_EXPR);\r\n            cc.endStatement();\r\n            break;\r\n        case Token.NEW:\r\n            add(\"new \");\r\n            int precedence = NodeUtil.precedence(type);\r\n            \/\/ first viable parentheses (don't traverse into functions).\r\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\r\n                precedence = NodeUtil.precedence(first.getType()) + 1;\r\n            }\r\n            addExpr(first, precedence, Context.OTHER);\r\n            \/\/ '()' is optional when no arguments are present\r\n            Node next = first.getNext();\r\n            if (next != null) {\r\n                add(\"(\");\r\n                addList(next);\r\n                add(\")\");\r\n            }\r\n            break;\r\n        case Token.STRING_KEY:\r\n            Preconditions.checkState(childCount == 1, \"Object lit key must have 1 child\");\r\n            addJsString(n);\r\n            break;\r\n        case Token.STRING:\r\n            Preconditions.checkState(childCount == 0, \"A string may not have children\");\r\n            addJsString(n);\r\n            break;\r\n        case Token.DELPROP:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"delete \");\r\n            add(first);\r\n            break;\r\n        case Token.OBJECTLIT:\r\n            {\r\n                boolean needsParens = (context == Context.START_OF_EXPR);\r\n                if (needsParens) {\r\n                    add(\"(\");\r\n                }\r\n                add(\"{\");\r\n                for (Node c = first; c != null; c = c.getNext()) {\r\n                    if (c != first) {\r\n                        cc.listSeparator();\r\n                    }\r\n                    if (c.isGetterDef() || c.isSetterDef()) {\r\n                        add(c);\r\n                    } else {\r\n                        Preconditions.checkState(c.isStringKey());\r\n                        String key = c.getString();\r\n                        \/\/ are not JavaScript keywords\r\n                        if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) && \/\/ were Unicode escaped.\r\n                        NodeUtil.isLatin(key)) {\r\n                            add(key);\r\n                        } else {\r\n                            \/\/ Determine if the string is a simple number.\r\n                            double d = getSimpleNumber(key);\r\n                            if (!Double.isNaN(d)) {\r\n                                cc.addNumber(d);\r\n                            } else {\r\n                                addExpr(c, 1, Context.OTHER);\r\n                            }\r\n                        }\r\n                        add(\":\");\r\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\r\n                    }\r\n                }\r\n                add(\"}\");\r\n                if (needsParens) {\r\n                    add(\")\");\r\n                }\r\n                break;\r\n            }\r\n        case Token.SWITCH:\r\n            add(\"switch(\");\r\n            add(first);\r\n            add(\")\");\r\n            cc.beginBlock();\r\n            addAllSiblings(first.getNext());\r\n            cc.endBlock(context == Context.STATEMENT);\r\n            break;\r\n        case Token.CASE:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"case \");\r\n            add(first);\r\n            addCaseBody(last);\r\n            break;\r\n        case Token.DEFAULT_CASE:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"default\");\r\n            addCaseBody(first);\r\n            break;\r\n        case Token.LABEL:\r\n            Preconditions.checkState(childCount == 2);\r\n            if (!first.isLabelName()) {\r\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n            }\r\n            add(first);\r\n            add(\":\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\r\n            break;\r\n        case Token.CAST:\r\n            add(\"(\");\r\n            add(first);\r\n            add(\")\");\r\n            break;\r\n        default:\r\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\r\n    }\r\n    cc.endSourceMapping(n);\r\n}","code_comment":null,"code_no_comment":"void add(Node n, Context context) {\r\n    if (!cc.continueProcessing()) {\r\n        return;\r\n    }\r\n    int type = n.getType();\r\n    String opstr = NodeUtil.opToStr(type);\r\n    int childCount = n.getChildCount();\r\n    Node first = n.getFirstChild();\r\n    Node last = n.getLastChild();\r\n        if (opstr != null && first != last) {\r\n        Preconditions.checkState(childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount);\r\n        int p = NodeUtil.precedence(type);\r\n                        Context rhsContext = getContextForNoInOperator(context);\r\n        if (last.getType() == type && NodeUtil.isAssociative(type)) {\r\n            addExpr(first, p, context);\r\n            cc.addOp(opstr, true);\r\n            addExpr(last, p, rhsContext);\r\n        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\r\n                        addExpr(first, p, context);\r\n            cc.addOp(opstr, true);\r\n            addExpr(last, p, rhsContext);\r\n        } else {\r\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\r\n        }\r\n        return;\r\n    }\r\n    cc.startSourceMapping(n);\r\n    switch(type) {\r\n        case Token.TRY:\r\n            {\r\n                Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());\r\n                Preconditions.checkState(childCount >= 2 && childCount <= 3);\r\n                add(\"try\");\r\n                add(first, Context.PRESERVE_BLOCK);\r\n                                                Node catchblock = first.getNext().getFirstChild();\r\n                if (catchblock != null) {\r\n                    add(catchblock);\r\n                }\r\n                if (childCount == 3) {\r\n                    add(\"finally\");\r\n                    add(last, Context.PRESERVE_BLOCK);\r\n                }\r\n                break;\r\n            }\r\n        case Token.CATCH:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"catch(\");\r\n            add(first);\r\n            add(\")\");\r\n            add(last, Context.PRESERVE_BLOCK);\r\n            break;\r\n        case Token.THROW:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"throw\");\r\n            add(first);\r\n                                    cc.endStatement(true);\r\n            break;\r\n        case Token.RETURN:\r\n            add(\"return\");\r\n            if (childCount == 1) {\r\n                add(first);\r\n            } else {\r\n                Preconditions.checkState(childCount == 0);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.VAR:\r\n            if (first != null) {\r\n                add(\"var \");\r\n                addList(first, false, getContextForNoInOperator(context));\r\n            }\r\n            break;\r\n        case Token.LABEL_NAME:\r\n            Preconditions.checkState(!n.getString().isEmpty());\r\n            addIdentifier(n.getString());\r\n            break;\r\n        case Token.NAME:\r\n            if (first == null || first.isEmpty()) {\r\n                addIdentifier(n.getString());\r\n            } else {\r\n                Preconditions.checkState(childCount == 1);\r\n                addIdentifier(n.getString());\r\n                cc.addOp(\"=\", true);\r\n                if (first.isComma()) {\r\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\r\n                } else {\r\n                                                            addExpr(first, 0, getContextForNoInOperator(context));\r\n                }\r\n            }\r\n            break;\r\n        case Token.ARRAYLIT:\r\n            add(\"[\");\r\n            addArrayList(first);\r\n            add(\"]\");\r\n            break;\r\n        case Token.PARAM_LIST:\r\n            add(\"(\");\r\n            addList(first);\r\n            add(\")\");\r\n            break;\r\n        case Token.COMMA:\r\n            Preconditions.checkState(childCount == 2);\r\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, getContextForNoInOperator(context), 0, 0);\r\n            break;\r\n        case Token.NUMBER:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addNumber(n.getDouble());\r\n            break;\r\n        case Token.TYPEOF:\r\n        case Token.VOID:\r\n        case Token.NOT:\r\n        case Token.BITNOT:\r\n        case Token.POS:\r\n            {\r\n                                Preconditions.checkState(childCount == 1);\r\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\r\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\r\n                break;\r\n            }\r\n        case Token.NEG:\r\n            {\r\n                Preconditions.checkState(childCount == 1);\r\n                                if (n.getFirstChild().isNumber()) {\r\n                    cc.addNumber(-n.getFirstChild().getDouble());\r\n                } else {\r\n                    cc.addOp(NodeUtil.opToStrNoFail(type), false);\r\n                    addExpr(first, NodeUtil.precedence(type), Context.OTHER);\r\n                }\r\n                break;\r\n            }\r\n        case Token.HOOK:\r\n            {\r\n                Preconditions.checkState(childCount == 3);\r\n                int p = NodeUtil.precedence(type);\r\n                Context rhsContext = getContextForNoInOperator(context);\r\n                addExpr(first, p + 1, context);\r\n                cc.addOp(\"?\", true);\r\n                addExpr(first.getNext(), 1, rhsContext);\r\n                cc.addOp(\":\", true);\r\n                addExpr(last, 1, rhsContext);\r\n                break;\r\n            }\r\n        case Token.REGEXP:\r\n            if (!first.isString() || !last.isString()) {\r\n                throw new Error(\"Expected children to be strings\");\r\n            }\r\n            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\r\n                        if (childCount == 2) {\r\n                add(regexp + last.getString());\r\n            } else {\r\n                Preconditions.checkState(childCount == 1);\r\n                add(regexp);\r\n            }\r\n            break;\r\n        case Token.FUNCTION:\r\n            if (n.getClass() != Node.class) {\r\n                throw new Error(\"Unexpected Node subclass.\");\r\n            }\r\n            Preconditions.checkState(childCount == 3);\r\n            boolean funcNeedsParens = (context == Context.START_OF_EXPR);\r\n            if (funcNeedsParens) {\r\n                add(\"(\");\r\n            }\r\n            add(\"function\");\r\n            add(first);\r\n            add(first.getNext());\r\n            add(last, Context.PRESERVE_BLOCK);\r\n            cc.endFunction(context == Context.STATEMENT);\r\n            if (funcNeedsParens) {\r\n                add(\")\");\r\n            }\r\n            break;\r\n        case Token.GETTER_DEF:\r\n        case Token.SETTER_DEF:\r\n            Preconditions.checkState(n.getParent().isObjectLit());\r\n            Preconditions.checkState(childCount == 1);\r\n            Preconditions.checkState(first.isFunction());\r\n                        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\r\n            if (type == Token.GETTER_DEF) {\r\n                                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\r\n                add(\"get \");\r\n            } else {\r\n                                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\r\n                add(\"set \");\r\n            }\r\n                        String name = n.getString();\r\n            Node fn = first;\r\n            Node parameters = fn.getChildAtIndex(1);\r\n            Node body = fn.getLastChild();\r\n                        if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) &&             NodeUtil.isLatin(name)) {\r\n                add(name);\r\n            } else {\r\n                                double d = getSimpleNumber(name);\r\n                if (!Double.isNaN(d)) {\r\n                    cc.addNumber(d);\r\n                } else {\r\n                    addJsString(n);\r\n                }\r\n            }\r\n            add(parameters);\r\n            add(body, Context.PRESERVE_BLOCK);\r\n            break;\r\n        case Token.SCRIPT:\r\n        case Token.BLOCK:\r\n            {\r\n                if (n.getClass() != Node.class) {\r\n                    throw new Error(\"Unexpected Node subclass.\");\r\n                }\r\n                boolean preserveBlock = context == Context.PRESERVE_BLOCK;\r\n                if (preserveBlock) {\r\n                    cc.beginBlock();\r\n                }\r\n                boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());\r\n                for (Node c = first; c != null; c = c.getNext()) {\r\n                    add(c, Context.STATEMENT);\r\n                                        if (c.isVar()) {\r\n                        cc.endStatement();\r\n                    }\r\n                    if (c.isFunction()) {\r\n                        cc.maybeLineBreak();\r\n                    }\r\n                                        if (preferLineBreaks) {\r\n                        cc.notePreferredLineBreak();\r\n                    }\r\n                }\r\n                if (preserveBlock) {\r\n                    cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\r\n                }\r\n                break;\r\n            }\r\n        case Token.FOR:\r\n            if (childCount == 4) {\r\n                add(\"for(\");\r\n                if (first.isVar()) {\r\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\r\n                } else {\r\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\r\n                }\r\n                add(\";\");\r\n                add(first.getNext());\r\n                add(\";\");\r\n                add(first.getNext().getNext());\r\n                add(\")\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            } else {\r\n                Preconditions.checkState(childCount == 3);\r\n                add(\"for(\");\r\n                add(first);\r\n                add(\"in\");\r\n                add(first.getNext());\r\n                add(\")\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            }\r\n            break;\r\n        case Token.DO:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"do\");\r\n            addNonEmptyStatement(first, Context.OTHER, false);\r\n            add(\"while(\");\r\n            add(last);\r\n            add(\")\");\r\n            cc.endStatement();\r\n            break;\r\n        case Token.WHILE:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"while(\");\r\n            add(first);\r\n            add(\")\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            break;\r\n        case Token.EMPTY:\r\n            Preconditions.checkState(childCount == 0);\r\n            break;\r\n        case Token.GETPROP:\r\n            {\r\n                Preconditions.checkState(childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount);\r\n                Preconditions.checkState(last.isString(), \"Bad GETPROP: RHS should be STRING\");\r\n                boolean needsParens = (first.isNumber());\r\n                if (needsParens) {\r\n                    add(\"(\");\r\n                }\r\n                addExpr(first, NodeUtil.precedence(type), context);\r\n                if (needsParens) {\r\n                    add(\")\");\r\n                }\r\n                if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) {\r\n                                        add(\"[\");\r\n                    add(last);\r\n                    add(\"]\");\r\n                } else {\r\n                    add(\".\");\r\n                    addIdentifier(last.getString());\r\n                }\r\n                break;\r\n            }\r\n        case Token.GETELEM:\r\n            Preconditions.checkState(childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount);\r\n            addExpr(first, NodeUtil.precedence(type), context);\r\n            add(\"[\");\r\n            add(first.getNext());\r\n            add(\"]\");\r\n            break;\r\n        case Token.WITH:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"with(\");\r\n            add(first);\r\n            add(\")\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            break;\r\n        case Token.INC:\r\n        case Token.DEC:\r\n            {\r\n                Preconditions.checkState(childCount == 1);\r\n                String o = type == Token.INC ? \"++\" : \"--\";\r\n                int postProp = n.getIntProp(Node.INCRDECR_PROP);\r\n                                if (postProp != 0) {\r\n                    addExpr(first, NodeUtil.precedence(type), context);\r\n                    cc.addOp(o, false);\r\n                } else {\r\n                    cc.addOp(o, false);\r\n                    add(first);\r\n                }\r\n                break;\r\n            }\r\n        case Token.CALL:\r\n                        if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\r\n                add(\"(0,\");\r\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\r\n                add(\")\");\r\n            } else {\r\n                addExpr(first, NodeUtil.precedence(type), context);\r\n            }\r\n            add(\"(\");\r\n            addList(first.getNext());\r\n            add(\")\");\r\n            break;\r\n        case Token.IF:\r\n            boolean hasElse = childCount == 3;\r\n            boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse;\r\n            if (ambiguousElseClause) {\r\n                cc.beginBlock();\r\n            }\r\n            add(\"if(\");\r\n            add(first);\r\n            add(\")\");\r\n            if (hasElse) {\r\n                addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\r\n                add(\"else\");\r\n                addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false);\r\n            } else {\r\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\r\n                Preconditions.checkState(childCount == 2);\r\n            }\r\n            if (ambiguousElseClause) {\r\n                cc.endBlock();\r\n            }\r\n            break;\r\n        case Token.NULL:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addConstant(\"null\");\r\n            break;\r\n        case Token.THIS:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"this\");\r\n            break;\r\n        case Token.FALSE:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addConstant(\"false\");\r\n            break;\r\n        case Token.TRUE:\r\n            Preconditions.checkState(childCount == 0);\r\n            cc.addConstant(\"true\");\r\n            break;\r\n        case Token.CONTINUE:\r\n            Preconditions.checkState(childCount <= 1);\r\n            add(\"continue\");\r\n            if (childCount == 1) {\r\n                if (!first.isLabelName()) {\r\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n                }\r\n                add(\" \");\r\n                add(first);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.DEBUGGER:\r\n            Preconditions.checkState(childCount == 0);\r\n            add(\"debugger\");\r\n            cc.endStatement();\r\n            break;\r\n        case Token.BREAK:\r\n            Preconditions.checkState(childCount <= 1);\r\n            add(\"break\");\r\n            if (childCount == 1) {\r\n                if (!first.isLabelName()) {\r\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n                }\r\n                add(\" \");\r\n                add(first);\r\n            }\r\n            cc.endStatement();\r\n            break;\r\n        case Token.EXPR_RESULT:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(first, Context.START_OF_EXPR);\r\n            cc.endStatement();\r\n            break;\r\n        case Token.NEW:\r\n            add(\"new \");\r\n            int precedence = NodeUtil.precedence(type);\r\n                        if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\r\n                precedence = NodeUtil.precedence(first.getType()) + 1;\r\n            }\r\n            addExpr(first, precedence, Context.OTHER);\r\n                        Node next = first.getNext();\r\n            if (next != null) {\r\n                add(\"(\");\r\n                addList(next);\r\n                add(\")\");\r\n            }\r\n            break;\r\n        case Token.STRING_KEY:\r\n            Preconditions.checkState(childCount == 1, \"Object lit key must have 1 child\");\r\n            addJsString(n);\r\n            break;\r\n        case Token.STRING:\r\n            Preconditions.checkState(childCount == 0, \"A string may not have children\");\r\n            addJsString(n);\r\n            break;\r\n        case Token.DELPROP:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"delete \");\r\n            add(first);\r\n            break;\r\n        case Token.OBJECTLIT:\r\n            {\r\n                boolean needsParens = (context == Context.START_OF_EXPR);\r\n                if (needsParens) {\r\n                    add(\"(\");\r\n                }\r\n                add(\"{\");\r\n                for (Node c = first; c != null; c = c.getNext()) {\r\n                    if (c != first) {\r\n                        cc.listSeparator();\r\n                    }\r\n                    if (c.isGetterDef() || c.isSetterDef()) {\r\n                        add(c);\r\n                    } else {\r\n                        Preconditions.checkState(c.isStringKey());\r\n                        String key = c.getString();\r\n                                                if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) &&                         NodeUtil.isLatin(key)) {\r\n                            add(key);\r\n                        } else {\r\n                                                        double d = getSimpleNumber(key);\r\n                            if (!Double.isNaN(d)) {\r\n                                cc.addNumber(d);\r\n                            } else {\r\n                                addExpr(c, 1, Context.OTHER);\r\n                            }\r\n                        }\r\n                        add(\":\");\r\n                        addExpr(c.getFirstChild(), 1, Context.OTHER);\r\n                    }\r\n                }\r\n                add(\"}\");\r\n                if (needsParens) {\r\n                    add(\")\");\r\n                }\r\n                break;\r\n            }\r\n        case Token.SWITCH:\r\n            add(\"switch(\");\r\n            add(first);\r\n            add(\")\");\r\n            cc.beginBlock();\r\n            addAllSiblings(first.getNext());\r\n            cc.endBlock(context == Context.STATEMENT);\r\n            break;\r\n        case Token.CASE:\r\n            Preconditions.checkState(childCount == 2);\r\n            add(\"case \");\r\n            add(first);\r\n            addCaseBody(last);\r\n            break;\r\n        case Token.DEFAULT_CASE:\r\n            Preconditions.checkState(childCount == 1);\r\n            add(\"default\");\r\n            addCaseBody(first);\r\n            break;\r\n        case Token.LABEL:\r\n            Preconditions.checkState(childCount == 2);\r\n            if (!first.isLabelName()) {\r\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\r\n            }\r\n            add(first);\r\n            add(\":\");\r\n            addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true);\r\n            break;\r\n        case Token.CAST:\r\n            add(\"(\");\r\n            add(first);\r\n            add(\")\");\r\n            break;\r\n        default:\r\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\r\n    }\r\n    cc.endSourceMapping(n);\r\n}","lc":22.5454545455,"pi":0.6650717703,"ma":31.0,"nbd":2.0,"ml":13.8333333333,"d":4.6666666667,"mi":-3.259901339,"fo":29.25,"r":-0.0263157895,"e":124.6451917037}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1167_259f10c0","label":3,"code":"public void setNextPartialSolution(OptimizerNode solutionSetDelta, OptimizerNode nextWorkset) {\r\n    \/\/ the partial solution (so we can potentially do direct updates)\r\n    if (solutionSetDelta instanceof TwoInputNode) {\r\n        TwoInputNode solutionDeltaTwoInput = (TwoInputNode) solutionSetDelta;\r\n        if (solutionDeltaTwoInput.getFirstPredecessorNode() == this.solutionSetNode || solutionDeltaTwoInput.getSecondPredecessorNode() == this.solutionSetNode) {\r\n            this.solutionDeltaImmediatelyAfterSolutionJoin = true;\r\n        }\r\n    }\r\n    \/\/ if the next workset is equal to the workset, we need to inject a no-op node\r\n    if (nextWorkset == worksetNode) {\r\n        NoOpNode noop = new NoOpNode();\r\n        noop.setDegreeOfParallelism(getDegreeOfParallelism());\r\n        PactConnection noOpConn = new PactConnection(nextWorkset, noop);\r\n        noop.setIncomingConnection(noOpConn);\r\n        nextWorkset.addOutgoingConnection(noOpConn);\r\n        nextWorkset = noop;\r\n    }\r\n    \/\/ attach an extra node to the solution set delta for the cases where we need to repartition\r\n    UnaryOperatorNode solutionSetDeltaUpdateAux = new UnaryOperatorNode(\"Solution-Set Delta\", getSolutionSetKeyFields(), new SolutionSetDeltaOperator(getSolutionSetKeyFields()));\r\n    solutionSetDeltaUpdateAux.setDegreeOfParallelism(getDegreeOfParallelism());\r\n    PactConnection conn = new PactConnection(solutionSetDelta, solutionSetDeltaUpdateAux);\r\n    solutionSetDeltaUpdateAux.setIncomingConnection(conn);\r\n    solutionSetDelta.addOutgoingConnection(conn);\r\n    this.solutionSetDelta = solutionSetDeltaUpdateAux;\r\n    this.nextWorkset = nextWorkset;\r\n    this.singleRoot = new SingleRootJoiner();\r\n    this.solutionSetDeltaRootConnection = new PactConnection(solutionSetDeltaUpdateAux, this.singleRoot);\r\n    this.nextWorksetRootConnection = new PactConnection(nextWorkset, this.singleRoot);\r\n    this.singleRoot.setInputs(this.solutionSetDeltaRootConnection, this.nextWorksetRootConnection);\r\n    solutionSetDeltaUpdateAux.addOutgoingConnection(this.solutionSetDeltaRootConnection);\r\n    nextWorkset.addOutgoingConnection(this.nextWorksetRootConnection);\r\n}","code_comment":null,"code_no_comment":"public void setNextPartialSolution(OptimizerNode solutionSetDelta, OptimizerNode nextWorkset) {\r\n        if (solutionSetDelta instanceof TwoInputNode) {\r\n        TwoInputNode solutionDeltaTwoInput = (TwoInputNode) solutionSetDelta;\r\n        if (solutionDeltaTwoInput.getFirstPredecessorNode() == this.solutionSetNode || solutionDeltaTwoInput.getSecondPredecessorNode() == this.solutionSetNode) {\r\n            this.solutionDeltaImmediatelyAfterSolutionJoin = true;\r\n        }\r\n    }\r\n        if (nextWorkset == worksetNode) {\r\n        NoOpNode noop = new NoOpNode();\r\n        noop.setDegreeOfParallelism(getDegreeOfParallelism());\r\n        PactConnection noOpConn = new PactConnection(nextWorkset, noop);\r\n        noop.setIncomingConnection(noOpConn);\r\n        nextWorkset.addOutgoingConnection(noOpConn);\r\n        nextWorkset = noop;\r\n    }\r\n        UnaryOperatorNode solutionSetDeltaUpdateAux = new UnaryOperatorNode(\"Solution-Set Delta\", getSolutionSetKeyFields(), new SolutionSetDeltaOperator(getSolutionSetKeyFields()));\r\n    solutionSetDeltaUpdateAux.setDegreeOfParallelism(getDegreeOfParallelism());\r\n    PactConnection conn = new PactConnection(solutionSetDelta, solutionSetDeltaUpdateAux);\r\n    solutionSetDeltaUpdateAux.setIncomingConnection(conn);\r\n    solutionSetDelta.addOutgoingConnection(conn);\r\n    this.solutionSetDelta = solutionSetDeltaUpdateAux;\r\n    this.nextWorkset = nextWorkset;\r\n    this.singleRoot = new SingleRootJoiner();\r\n    this.solutionSetDeltaRootConnection = new PactConnection(solutionSetDeltaUpdateAux, this.singleRoot);\r\n    this.nextWorksetRootConnection = new PactConnection(nextWorkset, this.singleRoot);\r\n    this.singleRoot.setInputs(this.solutionSetDeltaRootConnection, this.nextWorksetRootConnection);\r\n    solutionSetDeltaUpdateAux.addOutgoingConnection(this.solutionSetDeltaRootConnection);\r\n    nextWorkset.addOutgoingConnection(this.nextWorksetRootConnection);\r\n}","lc":0.6818181818,"pi":-0.1866028708,"ma":0.0,"nbd":0.0,"ml":0.4166666667,"d":0.1686507937,"mi":-0.5035940803,"fo":0.75,"r":-0.0263157895,"e":0.4854480386}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1640_8f321c72","label":1,"code":"\/**\r\n *  Returns the final component of this path.\r\n *\r\n *  @return the final component of the path\r\n *\/\r\npublic String getName() {\r\n    final String path = uri.getPath();\r\n    if (path.endsWith(SEPARATOR)) {\r\n        final int slash = path.lastIndexOf(SEPARATOR, path.length() - SEPARATOR.length() - 1);\r\n        return path.substring(slash + 1, path.length() - SEPARATOR.length());\r\n    } else {\r\n        final int slash = path.lastIndexOf(SEPARATOR);\r\n        return path.substring(slash + 1);\r\n    }\r\n}","code_comment":"\/**\r\n *  Returns the final component of this path.\r\n *\r\n *  @return the final component of the path\r\n *\/\r\n","code_no_comment":"public String getName() {\r\n    final String path = uri.getPath();\r\n    if (path.endsWith(SEPARATOR)) {\r\n        final int slash = path.lastIndexOf(SEPARATOR, path.length() - SEPARATOR.length() - 1);\r\n        return path.substring(slash + 1, path.length() - SEPARATOR.length());\r\n    } else {\r\n        final int slash = path.lastIndexOf(SEPARATOR);\r\n        return path.substring(slash + 1);\r\n    }\r\n}","lc":-0.1818181818,"pi":0.0,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.1686507937,"mi":0.1619450317,"fo":0.3333333333,"r":0.0526315789,"e":0.0457368764}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1068_e7bbeceb","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic void format(final LogEvent event, final StringBuilder toAppendTo) {\r\n    ThrowableProxy proxy = null;\r\n    if (event instanceof Log4jLogEvent) {\r\n        proxy = ((Log4jLogEvent) event).getThrownProxy();\r\n    }\r\n    final Throwable throwable = event.getThrown();\r\n    if (throwable != null && options.anyLines()) {\r\n        if (proxy == null) {\r\n            super.format(event, toAppendTo);\r\n            return;\r\n        }\r\n        final String extStackTrace = proxy.getExtendedStackTraceAsString(options.getPackages());\r\n        final int len = toAppendTo.length();\r\n        if (len > 0 && !Character.isWhitespace(toAppendTo.charAt(len - 1))) {\r\n            toAppendTo.append(' ');\r\n        }\r\n        if (!options.allLines() || !Constants.LINE_SEPARATOR.equals(options.getSeparator())) {\r\n            final StringBuilder sb = new StringBuilder();\r\n            final String[] array = extStackTrace.split(Constants.LINE_SEPARATOR);\r\n            final int limit = options.minLines(array.length) - 1;\r\n            for (int i = 0; i <= limit; ++i) {\r\n                sb.append(array[i]);\r\n                if (i < limit) {\r\n                    sb.append(options.getSeparator());\r\n                }\r\n            }\r\n            toAppendTo.append(sb.toString());\r\n        } else {\r\n            toAppendTo.append(extStackTrace);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void format(final LogEvent event, final StringBuilder toAppendTo) {\r\n    ThrowableProxy proxy = null;\r\n    if (event instanceof Log4jLogEvent) {\r\n        proxy = ((Log4jLogEvent) event).getThrownProxy();\r\n    }\r\n    final Throwable throwable = event.getThrown();\r\n    if (throwable != null && options.anyLines()) {\r\n        if (proxy == null) {\r\n            super.format(event, toAppendTo);\r\n            return;\r\n        }\r\n        final String extStackTrace = proxy.getExtendedStackTraceAsString(options.getPackages());\r\n        final int len = toAppendTo.length();\r\n        if (len > 0 && !Character.isWhitespace(toAppendTo.charAt(len - 1))) {\r\n            toAppendTo.append(' ');\r\n        }\r\n        if (!options.allLines() || !Constants.LINE_SEPARATOR.equals(options.getSeparator())) {\r\n            final StringBuilder sb = new StringBuilder();\r\n            final String[] array = extStackTrace.split(Constants.LINE_SEPARATOR);\r\n            final int limit = options.minLines(array.length) - 1;\r\n            for (int i = 0; i <= limit; ++i) {\r\n                sb.append(array[i]);\r\n                if (i < limit) {\r\n                    sb.append(options.getSeparator());\r\n                }\r\n            }\r\n            toAppendTo.append(sb.toString());\r\n        } else {\r\n            toAppendTo.append(extStackTrace);\r\n        }\r\n    }\r\n}","lc":0.8636363636,"pi":0.8660287081,"ma":0.8,"nbd":1.0,"ml":1.4166666667,"d":1.8313492063,"mi":-0.6236786469,"fo":1.25,"r":-0.0263157895,"e":3.228706281}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3510_292a2582","label":1,"code":"\/**\r\n *  Creates a new DateTextField defaulting to using a short date pattern\r\n *\r\n *  @param id\r\n *             The id of the text field\r\n *  @return DateTextField\r\n *\/\r\npublic static DateTextField forShortStyle(String id) {\r\n    return forShortStyle(id, null);\r\n}","code_comment":"\/**\r\n *  Creates a new DateTextField defaulting to using a short date pattern\r\n *\r\n *  @param id\r\n *             The id of the text field\r\n *  @return DateTextField\r\n *\/\r\n","code_no_comment":"public static DateTextField forShortStyle(String id) {\r\n    return forShortStyle(id, null);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0253699789,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-2931_d7422212","label":1,"code":"public ArtifactResolutionResult collect(Set artifacts, Artifact originatingArtifact, Map managedVersions, ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List listeners) throws ArtifactResolutionException {\r\n    Map resolvedArtifacts = new LinkedHashMap();\r\n    ResolutionNode root = new ResolutionNode(originatingArtifact, remoteRepositories);\r\n    root.addDependencies(artifacts, remoteRepositories, filter);\r\n    ManagedVersionMap versionMap = (managedVersions != null && managedVersions instanceof ManagedVersionMap) ? (ManagedVersionMap) managedVersions : new ManagedVersionMap(managedVersions);\r\n    recurse(root, resolvedArtifacts, versionMap, localRepository, remoteRepositories, source, filter, listeners);\r\n    Set set = new LinkedHashSet();\r\n    for (Iterator i = resolvedArtifacts.values().iterator(); i.hasNext(); ) {\r\n        List nodes = (List) i.next();\r\n        for (Iterator j = nodes.iterator(); j.hasNext(); ) {\r\n            ResolutionNode node = (ResolutionNode) j.next();\r\n            if (!node.equals(root) && node.isActive()) {\r\n                Artifact artifact = node.getArtifact();\r\n                if (node.filterTrail(filter)) {\r\n                    \/\/ we don't add it or its children, just allow the update of the version and scope\r\n                    if (node.isChildOfRootNode() || !artifact.isOptional()) {\r\n                        artifact.setDependencyTrail(node.getDependencyTrail());\r\n                        set.add(node);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    ArtifactResolutionResult result = new ArtifactResolutionResult();\r\n    result.setArtifactResolutionNodes(set);\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"public ArtifactResolutionResult collect(Set artifacts, Artifact originatingArtifact, Map managedVersions, ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source, ArtifactFilter filter, List listeners) throws ArtifactResolutionException {\r\n    Map resolvedArtifacts = new LinkedHashMap();\r\n    ResolutionNode root = new ResolutionNode(originatingArtifact, remoteRepositories);\r\n    root.addDependencies(artifacts, remoteRepositories, filter);\r\n    ManagedVersionMap versionMap = (managedVersions != null && managedVersions instanceof ManagedVersionMap) ? (ManagedVersionMap) managedVersions : new ManagedVersionMap(managedVersions);\r\n    recurse(root, resolvedArtifacts, versionMap, localRepository, remoteRepositories, source, filter, listeners);\r\n    Set set = new LinkedHashSet();\r\n    for (Iterator i = resolvedArtifacts.values().iterator(); i.hasNext(); ) {\r\n        List nodes = (List) i.next();\r\n        for (Iterator j = nodes.iterator(); j.hasNext(); ) {\r\n            ResolutionNode node = (ResolutionNode) j.next();\r\n            if (!node.equals(root) && node.isActive()) {\r\n                Artifact artifact = node.getArtifact();\r\n                if (node.filterTrail(filter)) {\r\n                                        if (node.isChildOfRootNode() || !artifact.isOptional()) {\r\n                        artifact.setDependencyTrail(node.getDependencyTrail());\r\n                        set.add(node);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    ArtifactResolutionResult result = new ArtifactResolutionResult();\r\n    result.setArtifactResolutionNodes(set);\r\n    return result;\r\n}","lc":0.5454545455,"pi":1.956937799,"ma":0.6,"nbd":1.5,"ml":1.1666666667,"d":0.4761904762,"mi":-0.5199436223,"fo":1.0833333333,"r":-0.0263157895,"e":1.2433095325}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2621_c849f986","label":1,"code":"public Object component(Form<?> form) {\r\n    if (form.multiPart) {\r\n        anyEmbeddedMultipart[0] = true;\r\n        return STOP_TRAVERSAL;\r\n    } else {\r\n        return CONTINUE_TRAVERSAL;\r\n    }\r\n}","code_comment":null,"code_no_comment":"public Object component(Form<?> form) {\r\n    if (form.multiPart) {\r\n        anyEmbeddedMultipart[0] = true;\r\n        return STOP_TRAVERSAL;\r\n    } else {\r\n        return CONTINUE_TRAVERSAL;\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.4520084567,"fo":-0.5,"r":0.8421052632,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4398_f88721fd","label":1,"code":"\/**\r\n *  @param qp\r\n *  @param charset\r\n *  @return query parameters\r\n *\/\r\nprivate static QueryParameter parseQueryParameter(final String qp, final Charset charset) {\r\n    if (qp.indexOf('=') == -1) {\r\n        return new QueryParameter(decodeParameter(qp, charset), \"\");\r\n    }\r\n    String[] parts = Strings.split(qp, '=');\r\n    if (parts.length == 0) {\r\n        return new QueryParameter(\"\", \"\");\r\n    } else if (parts.length == 1) {\r\n        return new QueryParameter(\"\", decodeParameter(parts[0], charset));\r\n    } else {\r\n        return new QueryParameter(decodeParameter(parts[0], charset), decodeParameter(parts[1], charset));\r\n    }\r\n}","code_comment":"\/**\r\n *  @param qp\r\n *  @param charset\r\n *  @return query parameters\r\n *\/\r\n","code_no_comment":"private static QueryParameter parseQueryParameter(final String qp, final Charset charset) {\r\n    if (qp.indexOf('=') == -1) {\r\n        return new QueryParameter(decodeParameter(qp, charset), \"\");\r\n    }\r\n    String[] parts = Strings.split(qp, '=');\r\n    if (parts.length == 0) {\r\n        return new QueryParameter(\"\", \"\");\r\n    } else if (parts.length == 1) {\r\n        return new QueryParameter(\"\", decodeParameter(parts[0], charset));\r\n    } else {\r\n        return new QueryParameter(decodeParameter(parts[0], charset), decodeParameter(parts[1], charset));\r\n    }\r\n}","lc":-0.0454545455,"pi":-0.1626794258,"ma":0.0,"nbd":0.0,"ml":0.0,"d":0.1726190476,"mi":-0.0105708245,"fo":0.0,"r":0.0263157895,"e":0.1121810941}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3474_ff81ef72","label":1,"code":"\/**\r\n * Returns a {@link DocumentNodeState} as seen at the given\r\n * <code>readRevision<\/code>.\r\n *\r\n * @param nodeStore    the node store.\r\n * @param readRevision the read revision.\r\n * @param lastModified the revision when this node was last modified, but\r\n *                     the value is potentially not yet reflected in this\r\n *                     document.\r\n *                     See {@link RevisionContext#getPendingModifications()}.\r\n * @return the node or <code>null<\/code> if the node doesn't exist at the\r\n *         given read revision.\r\n *\/\r\n@CheckForNull\r\npublic DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore, @Nonnull Revision readRevision, @Nullable Revision lastModified) {\r\n    Map<Revision, String> validRevisions = Maps.newHashMap();\r\n    Branch branch = nodeStore.getBranches().getBranch(readRevision);\r\n    LastRevs lastRevs = new LastRevs(getLastRev(), readRevision, branch);\r\n    \/\/ overlay with unsaved last modified from this instance\r\n    lastRevs.update(lastModified);\r\n    Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);\r\n    if (min == null) {\r\n        \/\/ deleted\r\n        return null;\r\n    }\r\n    String path = getPath();\r\n    DocumentNodeState n = new DocumentNodeState(nodeStore, path, readRevision, hasChildren());\r\n    Revision lastRevision = min;\r\n    for (String key : keySet()) {\r\n        if (!Utils.isPropertyName(key)) {\r\n            continue;\r\n        }\r\n        \/\/ ignore when local map is empty (OAK-2442)\r\n        SortedMap<Revision, String> local = getLocalMap(key);\r\n        if (local.isEmpty()) {\r\n            continue;\r\n        }\r\n        \/\/ first check local map, which contains most recent values\r\n        Value value = getLatestValue(nodeStore, local, min, readRevision, validRevisions, lastRevs);\r\n        \/\/ check if there may be more recent values in a previous document\r\n        if (!getPreviousRanges().isEmpty()) {\r\n            Revision newest = local.firstKey();\r\n            if (isRevisionNewer(nodeStore, newest, value.revision)) {\r\n                \/\/ not reading the most recent value, we may need to\r\n                \/\/ consider previous documents as well\r\n                Revision newestPrev = getPreviousRanges().firstKey();\r\n                if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {\r\n                    \/\/ a previous document has more recent changes\r\n                    \/\/ than value.revision\r\n                    value = null;\r\n                }\r\n            }\r\n        }\r\n        if (value == null && !getPreviousRanges().isEmpty()) {\r\n            \/\/ check complete revision history\r\n            value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);\r\n        }\r\n        String propertyName = Utils.unescapePropertyName(key);\r\n        String v = value != null ? value.value : null;\r\n        n.setProperty(propertyName, v);\r\n        \/\/ keep track of when this node was last modified\r\n        if (value != null && isRevisionNewer(nodeStore, value.revision, lastRevision)) {\r\n            lastRevision = value.revision;\r\n        }\r\n    }\r\n    \/\/ lastRevision now points to the revision when this node was\r\n    \/\/ last modified directly. but it may also have been 'modified'\r\n    \/\/ by an operation on a descendant node, which is tracked in\r\n    \/\/ _lastRev.\r\n    \/\/ when was this node last modified?\r\n    Revision branchBase = null;\r\n    if (branch != null) {\r\n        branchBase = branch.getBase(readRevision);\r\n    }\r\n    for (Revision r : lastRevs.get().values()) {\r\n        \/\/ ignore if newer than readRevision\r\n        if (isRevisionNewer(nodeStore, r, readRevision)) {\r\n            \/\/ the node has a _lastRev which is newer than readRevision\r\n            \/\/ this means we don't know when this node was\r\n            \/\/ modified by an operation on a descendant node between\r\n            \/\/ current lastRevision and readRevision. therefore we have\r\n            \/\/ to stay on the safe side and use readRevision\r\n            lastRevision = readRevision;\r\n            continue;\r\n        } else if (branchBase != null && isRevisionNewer(nodeStore, r, branchBase)) {\r\n            \/\/ readRevision is on a branch and the node has a\r\n            \/\/ _lastRev which is newer than the base of the branch\r\n            \/\/ we cannot use this _lastRev because it is not visible\r\n            \/\/ from this branch. highest possible revision of visible\r\n            \/\/ changes is the base of the branch\r\n            r = branchBase;\r\n        }\r\n        if (revisionAreAmbiguous(nodeStore, r, lastRevision)) {\r\n            \/\/ _lastRev entries from multiple cluster nodes are ambiguous\r\n            \/\/ use readRevision to make sure read is consistent\r\n            lastRevision = readRevision;\r\n        } else if (isRevisionNewer(nodeStore, r, lastRevision)) {\r\n            lastRevision = r;\r\n        }\r\n    }\r\n    if (branch != null) {\r\n        \/\/ read from a branch\r\n        \/\/ -> possibly overlay with unsaved last revs from branch\r\n        lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));\r\n        Revision r = lastRevs.getBranchRevision();\r\n        if (r != null) {\r\n            lastRevision = r;\r\n        }\r\n    }\r\n    n.setLastRevision(lastRevision);\r\n    return n;\r\n}","code_comment":"\/**\r\n * Returns a {@link DocumentNodeState} as seen at the given\r\n * <code>readRevision<\/code>.\r\n *\r\n * @param nodeStore    the node store.\r\n * @param readRevision the read revision.\r\n * @param lastModified the revision when this node was last modified, but\r\n *                     the value is potentially not yet reflected in this\r\n *                     document.\r\n *                     See {@link RevisionContext#getPendingModifications()}.\r\n * @return the node or <code>null<\/code> if the node doesn't exist at the\r\n *         given read revision.\r\n *\/\r\n","code_no_comment":"@CheckForNull\r\npublic DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore, @Nonnull Revision readRevision, @Nullable Revision lastModified) {\r\n    Map<Revision, String> validRevisions = Maps.newHashMap();\r\n    Branch branch = nodeStore.getBranches().getBranch(readRevision);\r\n    LastRevs lastRevs = new LastRevs(getLastRev(), readRevision, branch);\r\n        lastRevs.update(lastModified);\r\n    Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);\r\n    if (min == null) {\r\n                return null;\r\n    }\r\n    String path = getPath();\r\n    DocumentNodeState n = new DocumentNodeState(nodeStore, path, readRevision, hasChildren());\r\n    Revision lastRevision = min;\r\n    for (String key : keySet()) {\r\n        if (!Utils.isPropertyName(key)) {\r\n            continue;\r\n        }\r\n                SortedMap<Revision, String> local = getLocalMap(key);\r\n        if (local.isEmpty()) {\r\n            continue;\r\n        }\r\n                Value value = getLatestValue(nodeStore, local, min, readRevision, validRevisions, lastRevs);\r\n                if (!getPreviousRanges().isEmpty()) {\r\n            Revision newest = local.firstKey();\r\n            if (isRevisionNewer(nodeStore, newest, value.revision)) {\r\n                                                Revision newestPrev = getPreviousRanges().firstKey();\r\n                if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {\r\n                                                            value = null;\r\n                }\r\n            }\r\n        }\r\n        if (value == null && !getPreviousRanges().isEmpty()) {\r\n                        value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);\r\n        }\r\n        String propertyName = Utils.unescapePropertyName(key);\r\n        String v = value != null ? value.value : null;\r\n        n.setProperty(propertyName, v);\r\n                if (value != null && isRevisionNewer(nodeStore, value.revision, lastRevision)) {\r\n            lastRevision = value.revision;\r\n        }\r\n    }\r\n                        Revision branchBase = null;\r\n    if (branch != null) {\r\n        branchBase = branch.getBase(readRevision);\r\n    }\r\n    for (Revision r : lastRevs.get().values()) {\r\n                if (isRevisionNewer(nodeStore, r, readRevision)) {\r\n                                                                        lastRevision = readRevision;\r\n            continue;\r\n        } else if (branchBase != null && isRevisionNewer(nodeStore, r, branchBase)) {\r\n                                                                        r = branchBase;\r\n        }\r\n        if (revisionAreAmbiguous(nodeStore, r, lastRevision)) {\r\n                                    lastRevision = readRevision;\r\n        } else if (isRevisionNewer(nodeStore, r, lastRevision)) {\r\n            lastRevision = r;\r\n        }\r\n    }\r\n    if (branch != null) {\r\n                        lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));\r\n        Revision r = lastRevs.getBranchRevision();\r\n        if (r != null) {\r\n            lastRevision = r;\r\n        }\r\n    }\r\n    n.setLastRevision(lastRevision);\r\n    return n;\r\n}","lc":2.4545454545,"pi":0.4641148325,"ma":3.6,"nbd":1.0,"ml":3.0,"d":0.880952381,"mi":-1.1598308668,"fo":2.6666666667,"r":-0.0263157895,"e":4.0649942659}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-377_c640932d","label":1,"code":"\/**\r\n * Get the Root Mean Square value.\r\n * Get the Root Mean Square value, i.e. the root of the arithmetic\r\n * mean of the square of all weighted residuals. This is related to the\r\n * criterion that is minimized by the optimizer as follows: if\r\n * <em>c<\/em> if the criterion, and <em>n<\/em> is the number of\r\n * measurements, then the RMS is <em>sqrt (c\/n)<\/em>.\r\n *\r\n * @return RMS value\r\n *\/\r\npublic double getRMS() {\r\n    double criterion = 0;\r\n    for (int i = 0; i < rows; ++i) {\r\n        final double residual = residuals[i];\r\n        criterion += residualsWeights[i] * residual * residual;\r\n    }\r\n    return Math.sqrt(criterion \/ rows);\r\n}","code_comment":"\/**\r\n * Get the Root Mean Square value.\r\n * Get the Root Mean Square value, i.e. the root of the arithmetic\r\n * mean of the square of all weighted residuals. This is related to the\r\n * criterion that is minimized by the optimizer as follows: if\r\n * <em>c<\/em> if the criterion, and <em>n<\/em> is the number of\r\n * measurements, then the RMS is <em>sqrt (c\/n)<\/em>.\r\n *\r\n * @return RMS value\r\n *\/\r\n","code_no_comment":"public double getRMS() {\r\n    double criterion = 0;\r\n    for (int i = 0; i < rows; ++i) {\r\n        final double residual = residuals[i];\r\n        criterion += residualsWeights[i] * residual * residual;\r\n    }\r\n    return Math.sqrt(criterion \/ rows);\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":0.7718253968,"mi":0.3150105708,"fo":-0.4166666667,"r":0.0526315789,"e":0.1501979565}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-478_a7f0e808","label":1,"code":"@Override\r\npublic void childNodeDeleted(String name, NodeState before) {\r\n    childNodeChanged(name, before, EMPTY_NODE);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void childNodeDeleted(String name, NodeState before) {\r\n    childNodeChanged(name, before, EMPTY_NODE);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8173361522,"fo":-0.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Closure","project_version":"168","label":2,"code":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    if (t.inGlobalScope()) {\r\n        return;\r\n    }\r\n    if (n.isReturn() && n.getFirstChild() != null) {\r\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\r\n    }\r\n    if (t.getScopeDepth() <= 2) {\r\n        \/\/ no reason to do this extra computation for them.\r\n        return;\r\n    }\r\n    if (n.isName() && NodeUtil.isLValue(n) && \/\/ in the inner scope, not the scope where the name appears.\r\n    !NodeUtil.isBleedingFunctionName(n)) {\r\n        String name = n.getString();\r\n        Scope scope = t.getScope();\r\n        Var var = scope.getVar(name);\r\n        if (var != null) {\r\n            Scope ownerScope = var.getScope();\r\n            if (ownerScope.isLocal()) {\r\n                data.get(ownerScope.getRootNode()).recordAssignedName(name);\r\n            }\r\n            if (scope != ownerScope && ownerScope.isLocal()) {\r\n                data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\r\n            }\r\n        }\r\n    } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) {\r\n        String name = NodeUtil.getRootOfQualifiedName(n).getString();\r\n        Scope scope = t.getScope();\r\n        Var var = scope.getVar(name);\r\n        if (var != null) {\r\n            Scope ownerScope = var.getScope();\r\n            if (scope != ownerScope && ownerScope.isLocal()) {\r\n                data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName());\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void visit(NodeTraversal t, Node n, Node parent) {\r\n    if (t.inGlobalScope()) {\r\n        return;\r\n    }\r\n    if (n.isReturn() && n.getFirstChild() != null) {\r\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\r\n    }\r\n    if (t.getScopeDepth() <= 2) {\r\n                return;\r\n    }\r\n    if (n.isName() && NodeUtil.isLValue(n) &&     !NodeUtil.isBleedingFunctionName(n)) {\r\n        String name = n.getString();\r\n        Scope scope = t.getScope();\r\n        Var var = scope.getVar(name);\r\n        if (var != null) {\r\n            Scope ownerScope = var.getScope();\r\n            if (ownerScope.isLocal()) {\r\n                data.get(ownerScope.getRootNode()).recordAssignedName(name);\r\n            }\r\n            if (scope != ownerScope && ownerScope.isLocal()) {\r\n                data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\r\n            }\r\n        }\r\n    } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) {\r\n        String name = NodeUtil.getRootOfQualifiedName(n).getString();\r\n        Scope scope = t.getScope();\r\n        Var var = scope.getVar(name);\r\n        if (var != null) {\r\n            Scope ownerScope = var.getScope();\r\n            if (scope != ownerScope && ownerScope.isLocal()) {\r\n                data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName());\r\n            }\r\n        }\r\n    }\r\n}","lc":1.0454545455,"pi":0.6076555024,"ma":1.4,"nbd":1.0,"ml":2.1666666667,"d":0.6805555556,"mi":-0.704298802,"fo":2.4166666667,"r":-0.0263157895,"e":1.5544521476}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Returns the starting index of the internal array.  The starting index is\r\n * the position of the first addressable element in the internal storage\r\n * array.  The addressable elements in the array are <code>\r\n * internalArray[startIndex],...,internalArray[startIndex + numElements -1]\r\n * <\/code>\r\n *\r\n * @return the starting index.\r\n * @deprecated As of 3.1.\r\n *\/\r\n@Deprecated\r\npublic synchronized int start() {\r\n    return startIndex;\r\n}","code_comment":"\/**\r\n * Returns the starting index of the internal array.  The starting index is\r\n * the position of the first addressable element in the internal storage\r\n * array.  The addressable elements in the array are <code>\r\n * internalArray[startIndex],...,internalArray[startIndex + numElements -1]\r\n * <\/code>\r\n *\r\n * @return the starting index.\r\n * @deprecated As of 3.1.\r\n *\/\r\n","code_no_comment":"@Deprecated\r\npublic synchronized int start() {\r\n    return startIndex;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0332628612,"fo":-0.5,"r":1.6578947368,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1310_c6318b63","label":1,"code":"\/**\r\n * Looks up the value of the JNDI resource.\r\n * @param event The current LogEvent (is ignored by this StrLookup).\r\n * @param key  the JNDI resource name to be looked up, may be null\r\n * @return The value of the JNDI resource.\r\n *\/\r\n@Override\r\npublic String lookup(final LogEvent event, final String key) {\r\n    if (key == null) {\r\n        return null;\r\n    }\r\n    final String jndiName = convertJndiName(key);\r\n    final JndiManager jndiManager = JndiManager.getDefaultManager();\r\n    try {\r\n        return jndiManager.lookup(jndiName);\r\n    } catch (final NamingException e) {\r\n        LOGGER.warn(LOOKUP, \"Error looking up JNDI resource [{}].\", jndiName, e);\r\n        return null;\r\n    } finally {\r\n        jndiManager.release();\r\n    }\r\n}","code_comment":"\/**\r\n * Looks up the value of the JNDI resource.\r\n * @param event The current LogEvent (is ignored by this StrLookup).\r\n * @param key  the JNDI resource name to be looked up, may be null\r\n * @return The value of the JNDI resource.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic String lookup(final LogEvent event, final String key) {\r\n    if (key == null) {\r\n        return null;\r\n    }\r\n    final String jndiName = convertJndiName(key);\r\n    final JndiManager jndiManager = JndiManager.getDefaultManager();\r\n    try {\r\n        return jndiManager.lookup(jndiName);\r\n    } catch (final NamingException e) {\r\n        LOGGER.warn(LOOKUP, \"Error looking up JNDI resource [{}].\", jndiName, e);\r\n        return null;\r\n    } finally {\r\n        jndiManager.release();\r\n    }\r\n}","lc":0.0909090909,"pi":-0.1004784689,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0376984127,"mi":-0.0522903453,"fo":-0.0833333333,"r":0.3684210526,"e":-0.0406701129}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1270_70564c7c","label":1,"code":"@Override\r\npublic boolean visit(FullTextAnd and) {\r\n    BooleanQuery q = new BooleanQuery();\r\n    for (FullTextExpression e : and.list) {\r\n        Query x = getFullTextQuery(e, analyzer);\r\n        \/\/ Lucene can't deal with \"must(must_not(x))\"\r\n        if (x instanceof BooleanQuery) {\r\n            BooleanQuery bq = (BooleanQuery) x;\r\n            for (BooleanClause c : bq.clauses()) {\r\n                q.add(c);\r\n            }\r\n        } else {\r\n            q.add(x, MUST);\r\n        }\r\n    }\r\n    result.set(q);\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean visit(FullTextAnd and) {\r\n    BooleanQuery q = new BooleanQuery();\r\n    for (FullTextExpression e : and.list) {\r\n        Query x = getFullTextQuery(e, analyzer);\r\n                if (x instanceof BooleanQuery) {\r\n            BooleanQuery bq = (BooleanQuery) x;\r\n            for (BooleanClause c : bq.clauses()) {\r\n                q.add(c);\r\n            }\r\n        } else {\r\n            q.add(x, MUST);\r\n        }\r\n    }\r\n    result.set(q);\r\n    return true;\r\n}","lc":0.1363636364,"pi":0.8229665072,"ma":0.0,"nbd":0.5,"ml":-0.25,"d":-0.3650793651,"mi":-0.1097956307,"fo":-0.0833333333,"r":0.1842105263,"e":-0.1627934049}
{"project_name":"Math","project_version":"49","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic OpenMapRealVector ebeDivide(RealVector v) {\r\n    checkVectorDimensions(v.getDimension());\r\n    OpenMapRealVector res = new OpenMapRealVector(this);\r\n    Iterator iter = res.entries.iterator();\r\n    while (iter.hasNext()) {\r\n        iter.advance();\r\n        res.setEntry(iter.key(), iter.value() \/ v.getEntry(iter.key()));\r\n    }\r\n    return res;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public OpenMapRealVector ebeDivide(RealVector v) {\r\n    checkVectorDimensions(v.getDimension());\r\n    OpenMapRealVector res = new OpenMapRealVector(this);\r\n    Iterator iter = res.entries.iterator();\r\n    while (iter.hasNext()) {\r\n        iter.advance();\r\n        res.setEntry(iter.key(), iter.value() \/ v.getEntry(iter.key()));\r\n    }\r\n    return res;\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0238095238,"mi":0.1816772375,"fo":0.3333333333,"r":0.1052631579,"e":-0.0461195346}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3055_94c2a31f","label":0,"code":"\/**\r\n * Stops Accumulo and Zookeeper processes. If stop is not called, there is a shutdown hook that is setup to kill the processes. Howerver its probably best to\r\n * call stop in a finally block as soon as possible.\r\n *\/\r\npublic void stop() throws IOException, InterruptedException {\r\n    if (zooKeeperProcess != null) {\r\n        try {\r\n            stopProcessWithTimeout(zooKeeperProcess, 30, TimeUnit.SECONDS);\r\n        } catch (ExecutionException e) {\r\n            log.warn(\"ZooKeeper did not fully stop after 30 seconds\", e);\r\n        } catch (TimeoutException e) {\r\n            log.warn(\"ZooKeeper did not fully stop after 30 seconds\", e);\r\n        }\r\n    }\r\n    if (masterProcess != null) {\r\n        try {\r\n            stopProcessWithTimeout(masterProcess, 30, TimeUnit.SECONDS);\r\n        } catch (ExecutionException e) {\r\n            log.warn(\"Master did not fully stop after 30 seconds\", e);\r\n        } catch (TimeoutException e) {\r\n            log.warn(\"Master did not fully stop after 30 seconds\", e);\r\n        }\r\n    }\r\n    if (tabletServerProcesses != null) {\r\n        for (Process tserver : tabletServerProcesses) {\r\n            try {\r\n                stopProcessWithTimeout(tserver, 30, TimeUnit.SECONDS);\r\n            } catch (ExecutionException e) {\r\n                log.warn(\"TabletServer did not fully stop after 30 seconds\", e);\r\n            } catch (TimeoutException e) {\r\n                log.warn(\"TabletServer did not fully stop after 30 seconds\", e);\r\n            }\r\n        }\r\n    }\r\n    for (LogWriter lw : logWriters) lw.flush();\r\n    if (gcProcess != null) {\r\n        try {\r\n            stopProcessWithTimeout(gcProcess, 30, TimeUnit.SECONDS);\r\n        } catch (ExecutionException e) {\r\n            log.warn(\"GarbageCollector did not fully stop after 30 seconds\", e);\r\n        } catch (TimeoutException e) {\r\n            log.warn(\"GarbageCollector did not fully stop after 30 seconds\", e);\r\n        }\r\n    }\r\n    \/\/ ACCUMULO-2985 stop the ExecutorService after we finished using it to stop accumulo procs\r\n    if (null != executor) {\r\n        List<Runnable> tasksRemaining = executor.shutdownNow();\r\n        \/\/ the single thread executor shouldn't have any pending tasks, but check anyways\r\n        if (!tasksRemaining.isEmpty()) {\r\n            log.warn(\"Unexpectedly had \" + tasksRemaining.size() + \" task(s) remaining in threadpool for execution when being stopped\");\r\n        }\r\n        executor = null;\r\n    }\r\n}","code_comment":"\/**\r\n * Stops Accumulo and Zookeeper processes. If stop is not called, there is a shutdown hook that is setup to kill the processes. Howerver its probably best to\r\n * call stop in a finally block as soon as possible.\r\n *\/\r\n","code_no_comment":"public void stop() throws IOException, InterruptedException {\r\n    if (zooKeeperProcess != null) {\r\n        try {\r\n            stopProcessWithTimeout(zooKeeperProcess, 30, TimeUnit.SECONDS);\r\n        } catch (ExecutionException e) {\r\n            log.warn(\"ZooKeeper did not fully stop after 30 seconds\", e);\r\n        } catch (TimeoutException e) {\r\n            log.warn(\"ZooKeeper did not fully stop after 30 seconds\", e);\r\n        }\r\n    }\r\n    if (masterProcess != null) {\r\n        try {\r\n            stopProcessWithTimeout(masterProcess, 30, TimeUnit.SECONDS);\r\n        } catch (ExecutionException e) {\r\n            log.warn(\"Master did not fully stop after 30 seconds\", e);\r\n        } catch (TimeoutException e) {\r\n            log.warn(\"Master did not fully stop after 30 seconds\", e);\r\n        }\r\n    }\r\n    if (tabletServerProcesses != null) {\r\n        for (Process tserver : tabletServerProcesses) {\r\n            try {\r\n                stopProcessWithTimeout(tserver, 30, TimeUnit.SECONDS);\r\n            } catch (ExecutionException e) {\r\n                log.warn(\"TabletServer did not fully stop after 30 seconds\", e);\r\n            } catch (TimeoutException e) {\r\n                log.warn(\"TabletServer did not fully stop after 30 seconds\", e);\r\n            }\r\n        }\r\n    }\r\n    for (LogWriter lw : logWriters) lw.flush();\r\n    if (gcProcess != null) {\r\n        try {\r\n            stopProcessWithTimeout(gcProcess, 30, TimeUnit.SECONDS);\r\n        } catch (ExecutionException e) {\r\n            log.warn(\"GarbageCollector did not fully stop after 30 seconds\", e);\r\n        } catch (TimeoutException e) {\r\n            log.warn(\"GarbageCollector did not fully stop after 30 seconds\", e);\r\n        }\r\n    }\r\n        if (null != executor) {\r\n        List<Runnable> tasksRemaining = executor.shutdownNow();\r\n                if (!tasksRemaining.isEmpty()) {\r\n            log.warn(\"Unexpectedly had \" + tasksRemaining.size() + \" task(s) remaining in threadpool for execution when being stopped\");\r\n        }\r\n        executor = null;\r\n    }\r\n}","lc":1.5454545455,"pi":0.4114832536,"ma":2.6,"nbd":0.5,"ml":0.5833333333,"d":0.7619047619,"mi":-0.8407329105,"fo":0.9166666667,"r":-0.0263157895,"e":1.4353716798}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4518_f5ebc72d","label":1,"code":"private static void addZeroTokens(List<String> tokens, int max) {\r\n    if (tokens.size() < max) {\r\n        for (int i = 0; i < (max - tokens.size()); i++) {\r\n            tokens.add(\"0\");\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private static void addZeroTokens(List<String> tokens, int max) {\r\n    if (tokens.size() < max) {\r\n        for (int i = 0; i < (max - tokens.size()); i++) {\r\n            tokens.add(\"0\");\r\n        }\r\n    }\r\n}","lc":-0.3181818182,"pi":0.5406698565,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":0.3888888889,"mi":0.407751938,"fo":-0.25,"r":0.0789473684,"e":-0.0027085747}
{"project_name":"Math","project_version":"3","label":1,"code":"\/**\r\n * Compute a linear combination accurately.\r\n * This method computes the sum of the products\r\n * <code>a<sub>i<\/sub> b<sub>i<\/sub><\/code> to high accuracy.\r\n * It does so by using specific multiplication and addition algorithms to\r\n * preserve accuracy and reduce cancellation effects.\r\n * <br\/>\r\n * It is based on the 2005 paper\r\n * <a href=\"http:\/\/citeseerx.ist.psu.edu\/viewdoc\/summary?doi=10.1.1.2.1547\">\r\n * Accurate Sum and Dot Product<\/a> by Takeshi Ogita, Siegfried M. Rump,\r\n * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\r\n *\r\n * @param a Factors.\r\n * @param b Factors.\r\n * @return <code>&Sigma;<sub>i<\/sub> a<sub>i<\/sub> b<sub>i<\/sub><\/code>.\r\n * @throws DimensionMismatchException if arrays dimensions don't match\r\n *\/\r\npublic static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\r\n    final int len = a.length;\r\n    if (len != b.length) {\r\n        throw new DimensionMismatchException(len, b.length);\r\n    }\r\n    \/\/ Revert to scalar multiplication.\r\n    final double[] prodHigh = new double[len];\r\n    double prodLowSum = 0;\r\n    for (int i = 0; i < len; i++) {\r\n        final double ai = a[i];\r\n        final double ca = SPLIT_FACTOR * ai;\r\n        final double aHigh = ca - (ca - ai);\r\n        final double aLow = ai - aHigh;\r\n        final double bi = b[i];\r\n        final double cb = SPLIT_FACTOR * bi;\r\n        final double bHigh = cb - (cb - bi);\r\n        final double bLow = bi - bHigh;\r\n        prodHigh[i] = ai * bi;\r\n        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);\r\n        prodLowSum += prodLow;\r\n    }\r\n    final double prodHighCur = prodHigh[0];\r\n    double prodHighNext = prodHigh[1];\r\n    double sHighPrev = prodHighCur + prodHighNext;\r\n    double sPrime = sHighPrev - prodHighNext;\r\n    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\r\n    final int lenMinusOne = len - 1;\r\n    for (int i = 1; i < lenMinusOne; i++) {\r\n        prodHighNext = prodHigh[i + 1];\r\n        final double sHighCur = sHighPrev + prodHighNext;\r\n        sPrime = sHighCur - prodHighNext;\r\n        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\r\n        sHighPrev = sHighCur;\r\n    }\r\n    double result = sHighPrev + (prodLowSum + sLowSum);\r\n    if (Double.isNaN(result)) {\r\n        \/\/ either we have split infinite numbers or some coefficients were NaNs,\r\n        \/\/ just rely on the naive implementation and let IEEE754 handle this\r\n        result = 0;\r\n        for (int i = 0; i < len; ++i) {\r\n            result += a[i] * b[i];\r\n        }\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n * Compute a linear combination accurately.\r\n * This method computes the sum of the products\r\n * <code>a<sub>i<\/sub> b<sub>i<\/sub><\/code> to high accuracy.\r\n * It does so by using specific multiplication and addition algorithms to\r\n * preserve accuracy and reduce cancellation effects.\r\n * <br\/>\r\n * It is based on the 2005 paper\r\n * <a href=\"http:\/\/citeseerx.ist.psu.edu\/viewdoc\/summary?doi=10.1.1.2.1547\">\r\n * Accurate Sum and Dot Product<\/a> by Takeshi Ogita, Siegfried M. Rump,\r\n * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\r\n *\r\n * @param a Factors.\r\n * @param b Factors.\r\n * @return <code>&Sigma;<sub>i<\/sub> a<sub>i<\/sub> b<sub>i<\/sub><\/code>.\r\n * @throws DimensionMismatchException if arrays dimensions don't match\r\n *\/\r\n","code_no_comment":"public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\r\n    final int len = a.length;\r\n    if (len != b.length) {\r\n        throw new DimensionMismatchException(len, b.length);\r\n    }\r\n        final double[] prodHigh = new double[len];\r\n    double prodLowSum = 0;\r\n    for (int i = 0; i < len; i++) {\r\n        final double ai = a[i];\r\n        final double ca = SPLIT_FACTOR * ai;\r\n        final double aHigh = ca - (ca - ai);\r\n        final double aLow = ai - aHigh;\r\n        final double bi = b[i];\r\n        final double cb = SPLIT_FACTOR * bi;\r\n        final double bHigh = cb - (cb - bi);\r\n        final double bLow = bi - bHigh;\r\n        prodHigh[i] = ai * bi;\r\n        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);\r\n        prodLowSum += prodLow;\r\n    }\r\n    final double prodHighCur = prodHigh[0];\r\n    double prodHighNext = prodHigh[1];\r\n    double sHighPrev = prodHighCur + prodHighNext;\r\n    double sPrime = sHighPrev - prodHighNext;\r\n    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\r\n    final int lenMinusOne = len - 1;\r\n    for (int i = 1; i < lenMinusOne; i++) {\r\n        prodHighNext = prodHigh[i + 1];\r\n        final double sHighCur = sHighPrev + prodHighNext;\r\n        sPrime = sHighCur - prodHighNext;\r\n        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\r\n        sHighPrev = sHighCur;\r\n    }\r\n    double result = sHighPrev + (prodLowSum + sLowSum);\r\n    if (Double.isNaN(result)) {\r\n                        result = 0;\r\n        for (int i = 0; i < len; ++i) {\r\n            result += a[i] * b[i];\r\n        }\r\n    }\r\n    return result;\r\n}","lc":1.2727272727,"pi":-0.2296650718,"ma":0.6,"nbd":0.0,"ml":0.5,"d":2.8849206349,"mi":-0.7984496124,"fo":-0.4166666667,"r":-0.0263157895,"e":7.993243547}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1148_4080feff","label":1,"code":"@Override\r\npublic Collection<Vector2D> findHullVertices(final Collection<Vector2D> points) {\r\n    final List<Vector2D> pointsSortedByXAxis = new ArrayList<Vector2D>(points);\r\n    \/\/ sort the points in increasing order on the x-axis\r\n    Collections.sort(pointsSortedByXAxis, new Comparator<Vector2D>() {\r\n\r\n        public int compare(final Vector2D o1, final Vector2D o2) {\r\n            final int diff = (int) FastMath.signum(o1.getX() - o2.getX());\r\n            if (diff == 0) {\r\n                return (int) FastMath.signum(o1.getY() - o2.getY());\r\n            } else {\r\n                return diff;\r\n            }\r\n        }\r\n    });\r\n    \/\/ build lower hull\r\n    final List<Vector2D> lowerHull = new ArrayList<Vector2D>();\r\n    for (Vector2D p : pointsSortedByXAxis) {\r\n        updateHull(p, lowerHull);\r\n    }\r\n    \/\/ build upper hull\r\n    final List<Vector2D> upperHull = new ArrayList<Vector2D>();\r\n    for (int idx = pointsSortedByXAxis.size() - 1; idx >= 0; idx--) {\r\n        final Vector2D p = pointsSortedByXAxis.get(idx);\r\n        updateHull(p, upperHull);\r\n    }\r\n    \/\/ concatenate the lower and upper hulls\r\n    \/\/ the last point of each list is omitted as it is repeated at the beginning of the other list\r\n    final List<Vector2D> hullVertices = new ArrayList<Vector2D>(lowerHull.size() + upperHull.size() - 2);\r\n    for (int idx = 0; idx < lowerHull.size() - 1; idx++) {\r\n        hullVertices.add(lowerHull.get(idx));\r\n    }\r\n    for (int idx = 0; idx < upperHull.size() - 1; idx++) {\r\n        hullVertices.add(upperHull.get(idx));\r\n    }\r\n    \/\/ special case: if the lower and upper hull may contain only 1 point if all are identical\r\n    if (hullVertices.isEmpty() && !lowerHull.isEmpty()) {\r\n        hullVertices.add(lowerHull.get(0));\r\n    }\r\n    return hullVertices;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Collection<Vector2D> findHullVertices(final Collection<Vector2D> points) {\r\n    final List<Vector2D> pointsSortedByXAxis = new ArrayList<Vector2D>(points);\r\n        Collections.sort(pointsSortedByXAxis, new Comparator<Vector2D>() {\r\n\r\n        public int compare(final Vector2D o1, final Vector2D o2) {\r\n            final int diff = (int) FastMath.signum(o1.getX() - o2.getX());\r\n            if (diff == 0) {\r\n                return (int) FastMath.signum(o1.getY() - o2.getY());\r\n            } else {\r\n                return diff;\r\n            }\r\n        }\r\n    });\r\n        final List<Vector2D> lowerHull = new ArrayList<Vector2D>();\r\n    for (Vector2D p : pointsSortedByXAxis) {\r\n        updateHull(p, lowerHull);\r\n    }\r\n        final List<Vector2D> upperHull = new ArrayList<Vector2D>();\r\n    for (int idx = pointsSortedByXAxis.size() - 1; idx >= 0; idx--) {\r\n        final Vector2D p = pointsSortedByXAxis.get(idx);\r\n        updateHull(p, upperHull);\r\n    }\r\n            final List<Vector2D> hullVertices = new ArrayList<Vector2D>(lowerHull.size() + upperHull.size() - 2);\r\n    for (int idx = 0; idx < lowerHull.size() - 1; idx++) {\r\n        hullVertices.add(lowerHull.get(idx));\r\n    }\r\n    for (int idx = 0; idx < upperHull.size() - 1; idx++) {\r\n        hullVertices.add(upperHull.get(idx));\r\n    }\r\n        if (hullVertices.isEmpty() && !lowerHull.isEmpty()) {\r\n        hullVertices.add(lowerHull.get(0));\r\n    }\r\n    return hullVertices;\r\n}","lc":0.9090909091,"pi":0.4928229665,"ma":0.6,"nbd":0.0,"ml":0.5833333333,"d":3.0912698413,"mi":-0.6504580691,"fo":1.4166666667,"r":-0.0263157895,"e":5.9398212341}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-766_6fc5ea9d","label":1,"code":"@Override\r\npublic TreeLocation getChild(String name) {\r\n    T child = getChildTree(name);\r\n    if (child != null) {\r\n        return createNodeLocation(child);\r\n    }\r\n    PropertyState prop = getPropertyState(name);\r\n    if (prop != null) {\r\n        return createPropertyLocation(this, name);\r\n    }\r\n    return new NullLocation(this, name);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic TreeLocation getChild(String name) {\r\n    T child = getChildTree(name);\r\n    if (child != null) {\r\n        return createNodeLocation(child);\r\n    }\r\n    PropertyState prop = getPropertyState(name);\r\n    if (prop != null) {\r\n        return createPropertyLocation(this, name);\r\n    }\r\n    return new NullLocation(this, name);\r\n}","lc":-0.0909090909,"pi":-0.2057416268,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0674603175,"mi":0.1255813953,"fo":-0.1666666667,"r":0.6052631579,"e":-0.082047913}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"public update_resultStandardScheme getScheme() {\r\n    return new update_resultStandardScheme();\r\n}","code_comment":null,"code_no_comment":"public update_resultStandardScheme getScheme() {\r\n    return new update_resultStandardScheme();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1987315011,"fo":-0.5,"r":1.9736842105,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3156_786b3d76","label":0,"code":"@Override\r\npublic boolean isVirtualRow() {\r\n    return getPath() == null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean isVirtualRow() {\r\n    return getPath() == null;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9362931642,"fo":-0.4166666667,"r":2.3947368421,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public boolean equals(removeTableProperty_result that) {\r\n    if (that == null)\r\n        return false;\r\n    boolean this_present_ouch1 = true && this.isSetOuch1();\r\n    boolean that_present_ouch1 = true && that.isSetOuch1();\r\n    if (this_present_ouch1 || that_present_ouch1) {\r\n        if (!(this_present_ouch1 && that_present_ouch1))\r\n            return false;\r\n        if (!this.ouch1.equals(that.ouch1))\r\n            return false;\r\n    }\r\n    boolean this_present_ouch2 = true && this.isSetOuch2();\r\n    boolean that_present_ouch2 = true && that.isSetOuch2();\r\n    if (this_present_ouch2 || that_present_ouch2) {\r\n        if (!(this_present_ouch2 && that_present_ouch2))\r\n            return false;\r\n        if (!this.ouch2.equals(that.ouch2))\r\n            return false;\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"public boolean equals(removeTableProperty_result that) {\r\n    if (that == null)\r\n        return false;\r\n    boolean this_present_ouch1 = true && this.isSetOuch1();\r\n    boolean that_present_ouch1 = true && that.isSetOuch1();\r\n    if (this_present_ouch1 || that_present_ouch1) {\r\n        if (!(this_present_ouch1 && that_present_ouch1))\r\n            return false;\r\n        if (!this.ouch1.equals(that.ouch1))\r\n            return false;\r\n    }\r\n    boolean this_present_ouch2 = true && this.isSetOuch2();\r\n    boolean that_present_ouch2 = true && that.isSetOuch2();\r\n    if (this_present_ouch2 || that_present_ouch2) {\r\n        if (!(this_present_ouch2 && that_present_ouch2))\r\n            return false;\r\n        if (!this.ouch2.equals(that.ouch2))\r\n            return false;\r\n    }\r\n    return true;\r\n}","lc":0.3181818182,"pi":0.3014354067,"ma":0.8,"nbd":-0.5,"ml":1.25,"d":0.746031746,"mi":-0.2769556025,"fo":0.0,"r":-0.0263157895,"e":0.4955492932}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1173_61c877d8","label":0,"code":"@Override\r\npublic TreePermission getTreePermission(@Nonnull ImmutableTree tree, @Nonnull TreePermission parentPermission) {\r\n    if (tree.isRoot()) {\r\n        return new TreePermissionImpl(tree, TreeTypeProvider.TYPE_DEFAULT, TreePermission.EMPTY);\r\n    }\r\n    int type = tree.getType();\r\n    switch(type) {\r\n        case TreeTypeProvider.TYPE_HIDDEN:\r\n            \/\/ TODO: OAK-753 decide on where to filter out hidden items.\r\n            return TreePermission.ALL;\r\n        case TreeTypeProvider.TYPE_VERSION:\r\n            String ntName = checkNotNull(TreeUtil.getPrimaryTypeName(tree));\r\n            if (VersionConstants.VERSION_STORE_NT_NAMES.contains(ntName) || VersionConstants.NT_ACTIVITY.equals(ntName)) {\r\n                return new TreePermissionImpl(tree, TreeTypeProvider.TYPE_VERSION, parentPermission);\r\n            } else {\r\n                ImmutableTree versionableTree = getVersionableTree(tree);\r\n                if (versionableTree == null) {\r\n                    log.warn(\"Cannot retrieve versionable node for \" + tree.getPath());\r\n                    return TreePermission.EMPTY;\r\n                } else {\r\n                    \/\/ TODO -> evaluation by path would be more accurate (-> see #isGranted)\r\n                    while (!versionableTree.exists()) {\r\n                        versionableTree = versionableTree.getParent();\r\n                    }\r\n                    TreePermission pp = getParentPermission(versionableTree, TreeTypeProvider.TYPE_VERSION);\r\n                    return new TreePermissionImpl(versionableTree, TreeTypeProvider.TYPE_VERSION, pp);\r\n                }\r\n            }\r\n        case TreeTypeProvider.TYPE_PERMISSION_STORE:\r\n            return TreePermission.EMPTY;\r\n        default:\r\n            return new TreePermissionImpl(tree, type, parentPermission);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic TreePermission getTreePermission(@Nonnull ImmutableTree tree, @Nonnull TreePermission parentPermission) {\r\n    if (tree.isRoot()) {\r\n        return new TreePermissionImpl(tree, TreeTypeProvider.TYPE_DEFAULT, TreePermission.EMPTY);\r\n    }\r\n    int type = tree.getType();\r\n    switch(type) {\r\n        case TreeTypeProvider.TYPE_HIDDEN:\r\n                        return TreePermission.ALL;\r\n        case TreeTypeProvider.TYPE_VERSION:\r\n            String ntName = checkNotNull(TreeUtil.getPrimaryTypeName(tree));\r\n            if (VersionConstants.VERSION_STORE_NT_NAMES.contains(ntName) || VersionConstants.NT_ACTIVITY.equals(ntName)) {\r\n                return new TreePermissionImpl(tree, TreeTypeProvider.TYPE_VERSION, parentPermission);\r\n            } else {\r\n                ImmutableTree versionableTree = getVersionableTree(tree);\r\n                if (versionableTree == null) {\r\n                    log.warn(\"Cannot retrieve versionable node for \" + tree.getPath());\r\n                    return TreePermission.EMPTY;\r\n                } else {\r\n                                        while (!versionableTree.exists()) {\r\n                        versionableTree = versionableTree.getParent();\r\n                    }\r\n                    TreePermission pp = getParentPermission(versionableTree, TreeTypeProvider.TYPE_VERSION);\r\n                    return new TreePermissionImpl(versionableTree, TreeTypeProvider.TYPE_VERSION, pp);\r\n                }\r\n            }\r\n        case TreeTypeProvider.TYPE_PERMISSION_STORE:\r\n            return TreePermission.EMPTY;\r\n        default:\r\n            return new TreePermissionImpl(tree, type, parentPermission);\r\n    }\r\n}","lc":0.8181818182,"pi":1.7703349282,"ma":1.0,"nbd":1.5,"ml":0.8333333333,"d":0.4682539683,"mi":-0.5774489077,"fo":0.5,"r":-0.0263157895,"e":0.8261798148}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7163_5f726d0b","label":1,"code":"@ManagedOperation(description = \"Updates the message body on the suspended breakpoint at the given node id\")\r\nvoid setMessageBodyOnBreakpoint(String nodeId, String body);","code_comment":null,"code_no_comment":"@ManagedOperation(description = \"Updates the message body on the suspended breakpoint at the given node id\")\r\nvoid setMessageBodyOnBreakpoint(String nodeId, String body);","lc":-0.5454545455,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1713883016,"fo":-0.5,"r":1.9736842105,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3817_2a02a138","label":3,"code":"Map<String, String> convertNodeState(NodeState state) {\r\n    Map<String, String> result = Maps.newHashMap();\r\n    for (PropertyState ps : state.getProperties()) {\r\n        String name = ps.getName();\r\n        if (ps.getType() != Type.BINARY && !ps.isArray() && !IGNORE_PROP_NAMES.contains(name)) {\r\n            result.put(name, ps.getValue(Type.STRING));\r\n        }\r\n    }\r\n    result.put(LuceneIndexConstants.ANL_LUCENE_MATCH_VERSION, getVersion(state).toString());\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"Map<String, String> convertNodeState(NodeState state) {\r\n    Map<String, String> result = Maps.newHashMap();\r\n    for (PropertyState ps : state.getProperties()) {\r\n        String name = ps.getName();\r\n        if (ps.getType() != Type.BINARY && !ps.isArray() && !IGNORE_PROP_NAMES.contains(name)) {\r\n            result.put(name, ps.getValue(Type.STRING));\r\n        }\r\n    }\r\n    result.put(LuceneIndexConstants.ANL_LUCENE_MATCH_VERSION, getVersion(state).toString());\r\n    return result;\r\n}","lc":-0.1363636364,"pi":0.2200956938,"ma":-0.2,"nbd":0.0,"ml":0.1666666667,"d":0.2956349206,"mi":0.0494714588,"fo":0.4166666667,"r":-0.0263157895,"e":0.2331103081}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4309_b4274415","label":1,"code":"\/**\r\n *  Convert to object types, returning null if text is null.\r\n *\r\n *  @return converted\r\n *  @throws StringValueConversionException\r\n *\/\r\npublic final Long toOptionalLong() throws StringValueConversionException {\r\n    return (text == null) ? null : toLongObject();\r\n}","code_comment":"\/**\r\n *  Convert to object types, returning null if text is null.\r\n *\r\n *  @return converted\r\n *  @throws StringValueConversionException\r\n *\/\r\n","code_no_comment":"public final Long toOptionalLong() throws StringValueConversionException {\r\n    return (text == null) ? null : toLongObject();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.3650793651,"mi":0.9797040169,"fo":-0.4166666667,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1894_35562cce","label":1,"code":"@Override\r\npublic Cursor query(Filter filter, NodeState root) {\r\n    Iterable<String> paths = null;\r\n    PropertyIndexLookup lookup = getLookup(root);\r\n    int depth = 1;\r\n    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\r\n        String propertyName = PathUtils.getName(pr.propertyName);\r\n        depth = PathUtils.getDepth(pr.propertyName);\r\n        \/\/ currently, only indexes on the root node are supported\r\n        if (lookup.isIndexed(propertyName, \"\/\", filter)) {\r\n            \/\/ equality\r\n            if (pr.firstIncluding && pr.lastIncluding && pr.first != null && pr.first.equals(pr.last)) {\r\n                \/\/ \"[property] = $value\"\r\n                paths = lookup.query(filter, propertyName, pr.first);\r\n                break;\r\n            } else if (pr.list != null) {\r\n                for (PropertyValue pv : pr.list) {\r\n                    Iterable<String> p = lookup.query(filter, propertyName, pv);\r\n                    if (paths == null) {\r\n                        paths = p;\r\n                    } else {\r\n                        paths = Iterables.concat(paths, p);\r\n                    }\r\n                }\r\n                break;\r\n            } else {\r\n                \/\/ processed as \"[property] is not null\"\r\n                paths = lookup.query(filter, propertyName, null);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (paths == null) {\r\n        throw new IllegalStateException(\"Property index is used even when no index is available for filter \" + filter);\r\n    }\r\n    Cursor c = Cursors.newPathCursor(paths, filter.getQueryEngineSettings());\r\n    if (depth > 1) {\r\n        c = Cursors.newAncestorCursor(c, depth - 1, filter.getQueryEngineSettings());\r\n    }\r\n    return c;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Cursor query(Filter filter, NodeState root) {\r\n    Iterable<String> paths = null;\r\n    PropertyIndexLookup lookup = getLookup(root);\r\n    int depth = 1;\r\n    for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\r\n        String propertyName = PathUtils.getName(pr.propertyName);\r\n        depth = PathUtils.getDepth(pr.propertyName);\r\n                if (lookup.isIndexed(propertyName, \"\/\", filter)) {\r\n                        if (pr.firstIncluding && pr.lastIncluding && pr.first != null && pr.first.equals(pr.last)) {\r\n                                paths = lookup.query(filter, propertyName, pr.first);\r\n                break;\r\n            } else if (pr.list != null) {\r\n                for (PropertyValue pv : pr.list) {\r\n                    Iterable<String> p = lookup.query(filter, propertyName, pv);\r\n                    if (paths == null) {\r\n                        paths = p;\r\n                    } else {\r\n                        paths = Iterables.concat(paths, p);\r\n                    }\r\n                }\r\n                break;\r\n            } else {\r\n                                paths = lookup.query(filter, propertyName, null);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (paths == null) {\r\n        throw new IllegalStateException(\"Property index is used even when no index is available for filter \" + filter);\r\n    }\r\n    Cursor c = Cursors.newPathCursor(paths, filter.getQueryEngineSettings());\r\n    if (depth > 1) {\r\n        c = Cursors.newAncestorCursor(c, depth - 1, filter.getQueryEngineSettings());\r\n    }\r\n    return c;\r\n}","lc":1.0454545455,"pi":1.8851674641,"ma":1.8,"nbd":2.0,"ml":1.25,"d":1.123015873,"mi":-0.7245947851,"fo":0.6666666667,"r":-0.0263157895,"e":2.4066227532}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-748_503451c1","label":1,"code":"@Override\r\npublic void insert(NodeBuilder index, String key, boolean unique, Iterable<String> values) throws CommitFailedException {\r\n    NodeBuilder child = index.child(key);\r\n    for (String add : values) {\r\n        NodeBuilder indexEntry = child;\r\n        for (String segment : PathUtils.elements(add)) {\r\n            indexEntry = indexEntry.child(segment);\r\n        }\r\n        indexEntry.setProperty(\"match\", true);\r\n    }\r\n    CountingNodeVisitor v = new CountingNodeVisitor(2);\r\n    v.visit(child.getNodeState());\r\n    int matchCount = v.getCount();\r\n    if (matchCount == 0) {\r\n        index.removeNode(key);\r\n    } else if (unique && matchCount > 1) {\r\n        throw new CommitFailedException(\"Uniqueness constraint violated for key \" + key);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void insert(NodeBuilder index, String key, boolean unique, Iterable<String> values) throws CommitFailedException {\r\n    NodeBuilder child = index.child(key);\r\n    for (String add : values) {\r\n        NodeBuilder indexEntry = child;\r\n        for (String segment : PathUtils.elements(add)) {\r\n            indexEntry = indexEntry.child(segment);\r\n        }\r\n        indexEntry.setProperty(\"match\", true);\r\n    }\r\n    CountingNodeVisitor v = new CountingNodeVisitor(2);\r\n    v.visit(child.getNodeState());\r\n    int matchCount = v.getCount();\r\n    if (matchCount == 0) {\r\n        index.removeNode(key);\r\n    } else if (unique && matchCount > 1) {\r\n        throw new CommitFailedException(\"Uniqueness constraint violated for key \" + key);\r\n    }\r\n}","lc":0.2272727273,"pi":0.0717703349,"ma":0.4,"nbd":0.0,"ml":0.0,"d":0.376984127,"mi":-0.2631430585,"fo":0.1666666667,"r":-0.0263157895,"e":0.4347757934}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2389_7c320b1e","label":1,"code":"\/**\r\n * Convert a string to a quoted Json literal using the correct escape\r\n * sequences. The literal is enclosed in double quotes. Characters outside\r\n * the range 32..127 are encoded (backslash u xxxx). The forward slash\r\n * (solidus) is not escaped. Null is encoded as \"null\" (without quotes).\r\n *\r\n * @param s the text to convert\r\n * @return the Json representation (including double quotes)\r\n *\/\r\npublic static String encode(String s) {\r\n    if (s == null) {\r\n        return \"null\";\r\n    }\r\n    int length = s.length();\r\n    if (length == 0) {\r\n        return \"\\\"\\\"\";\r\n    }\r\n    for (int i = 0; i < length; i++) {\r\n        char c = s.charAt(i);\r\n        if (c == '\\\"' || c == '\\\\' || c < ' ' || c >= 127) {\r\n            StringBuilder buff = new StringBuilder(length + 2 + length \/ 8);\r\n            buff.append('\\\"');\r\n            escape(s, length, buff);\r\n            return buff.append('\\\"').toString();\r\n        }\r\n    }\r\n    StringBuilder buff = new StringBuilder(length + 2);\r\n    return buff.append('\\\"').append(s).append('\\\"').toString();\r\n}","code_comment":"\/**\r\n * Convert a string to a quoted Json literal using the correct escape\r\n * sequences. The literal is enclosed in double quotes. Characters outside\r\n * the range 32..127 are encoded (backslash u xxxx). The forward slash\r\n * (solidus) is not escaped. Null is encoded as \"null\" (without quotes).\r\n *\r\n * @param s the text to convert\r\n * @return the Json representation (including double quotes)\r\n *\/\r\n","code_no_comment":"public static String encode(String s) {\r\n    if (s == null) {\r\n        return \"null\";\r\n    }\r\n    int length = s.length();\r\n    if (length == 0) {\r\n        return \"\\\"\\\"\";\r\n    }\r\n    for (int i = 0; i < length; i++) {\r\n        char c = s.charAt(i);\r\n        if (c == '\\\"' || c == '\\\\' || c < ' ' || c >= 127) {\r\n            StringBuilder buff = new StringBuilder(length + 2 + length \/ 8);\r\n            buff.append('\\\"');\r\n            escape(s, length, buff);\r\n            return buff.append('\\\"').toString();\r\n        }\r\n    }\r\n    StringBuilder buff = new StringBuilder(length + 2);\r\n    return buff.append('\\\"').append(s).append('\\\"').toString();\r\n}","lc":0.2727272727,"pi":0.3301435407,"ma":0.2,"nbd":0.0,"ml":0.5,"d":1.871031746,"mi":-0.3000704722,"fo":0.3333333333,"r":0.0263157895,"e":1.9028416982}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4932_f20b2d70","label":1,"code":"\/**\r\n *  Parse the given request to an {@link UrlInfo} instance.\r\n *\r\n *  @param request\r\n *  @return UrlInfo instance or <code>null<\/code> if this encoder can not handle the request\r\n *\/\r\nprotected abstract UrlInfo parseRequest(Request request);","code_comment":"\/**\r\n *  Parse the given request to an {@link UrlInfo} instance.\r\n *\r\n *  @param request\r\n *  @return UrlInfo instance or <code>null<\/code> if this encoder can not handle the request\r\n *\/\r\n","code_no_comment":"protected abstract UrlInfo parseRequest(Request request);","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.6116983791,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1406_a523dcd5","label":0,"code":"private void initThrowable(final Object[] params, final int argCount, final int usedParams) {\r\n    if (usedParams < argCount && this.throwable == null && params[argCount - 1] instanceof Throwable) {\r\n        this.throwable = (Throwable) params[argCount - 1];\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void initThrowable(final Object[] params, final int argCount, final int usedParams) {\r\n    if (usedParams < argCount && this.throwable == null && params[argCount - 1] instanceof Throwable) {\r\n        this.throwable = (Throwable) params[argCount - 1];\r\n    }\r\n}","lc":-0.4090909091,"pi":0.0,"ma":-0.4,"nbd":-0.5,"ml":0.0833333333,"d":0.3888888889,"mi":0.5523608175,"fo":-0.5,"r":0.1578947368,"e":0.0151657129}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5102_d110e307","label":1,"code":"@Override\r\npublic Property resolveProperty(FormComponent<?> component) {\r\n    IModel<?> model = component.getModel();\r\n    if (!(model instanceof IPropertyReflectionAwareModel)) {\r\n        return null;\r\n    }\r\n    IPropertyReflectionAwareModel<?> delegate = (IPropertyReflectionAwareModel<?>) model;\r\n    Field field = delegate.getPropertyField();\r\n    if (field != null) {\r\n        return new Property(field.getDeclaringClass(), field.getName());\r\n    }\r\n    Method getter = delegate.getPropertyGetter();\r\n    if (getter != null) {\r\n        String name = getter.getName().substring(3, 1).toLowerCase() + getter.getName().substring(4);\r\n        return new Property(getter.getDeclaringClass(), name);\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Property resolveProperty(FormComponent<?> component) {\r\n    IModel<?> model = component.getModel();\r\n    if (!(model instanceof IPropertyReflectionAwareModel)) {\r\n        return null;\r\n    }\r\n    IPropertyReflectionAwareModel<?> delegate = (IPropertyReflectionAwareModel<?>) model;\r\n    Field field = delegate.getPropertyField();\r\n    if (field != null) {\r\n        return new Property(field.getDeclaringClass(), field.getName());\r\n    }\r\n    Method getter = delegate.getPropertyGetter();\r\n    if (getter != null) {\r\n        String name = getter.getName().substring(3, 1).toLowerCase() + getter.getName().substring(4);\r\n        return new Property(getter.getDeclaringClass(), name);\r\n    }\r\n    return null;\r\n}","lc":0.1818181818,"pi":-0.2440191388,"ma":0.0,"nbd":-0.5,"ml":0.0833333333,"d":0.3849206349,"mi":-0.2031007752,"fo":0.4166666667,"r":-0.0263157895,"e":0.3549247074}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5571_0e87b84f","label":1,"code":"public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\r\n    int argsLength = (args == null) ? 0 : args.length;\r\n    if (argsLength != 1) {\r\n        throw new RuntimeCamelException(String.format(\"Error creating proxy for %s.%s Number of arguments must be 1 but is %d\", method.getDeclaringClass().getName(), method.getName(), argsLength));\r\n    }\r\n    final ExchangePattern pattern = method.getReturnType() != Void.TYPE ? ExchangePattern.InOut : ExchangePattern.InOnly;\r\n    return invokeWithbody(method, args[0], pattern);\r\n}","code_comment":null,"code_no_comment":"public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\r\n    int argsLength = (args == null) ? 0 : args.length;\r\n    if (argsLength != 1) {\r\n        throw new RuntimeCamelException(String.format(\"Error creating proxy for %s.%s Number of arguments must be 1 but is %d\", method.getDeclaringClass().getName(), method.getName(), argsLength));\r\n    }\r\n    final ExchangePattern pattern = method.getReturnType() != Void.TYPE ? ExchangePattern.InOut : ExchangePattern.InOnly;\r\n    return invokeWithbody(method, args[0], pattern);\r\n}","lc":-0.2727272727,"pi":-0.2822966507,"ma":0.2,"nbd":-0.5,"ml":0.0833333333,"d":-0.0496031746,"mi":0.1949260042,"fo":0.0,"r":-0.0263157895,"e":0.0101404425}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2308_f4d5bbe1","label":1,"code":"\/**\r\n * Determines the last revision value which needs to set for given clusterId\r\n * on the passed document. If the last rev entries are consisted\r\n *\r\n * @param doc NodeDocument where lastRev entries needs to be fixed\r\n * @param clusterId clusterId for which lastRev has to be checked\r\n * @return lastRev which needs to be updated. <tt>null<\/tt> if no\r\n *         updated is required i.e. lastRev entries are valid\r\n *\/\r\n@CheckForNull\r\nprivate Revision determineMissedLastRev(NodeDocument doc, int clusterId) {\r\n    Revision currentLastRev = doc.getLastRev().get(clusterId);\r\n    if (currentLastRev == null) {\r\n        currentLastRev = new Revision(0, 0, clusterId);\r\n    }\r\n    ClusterPredicate cp = new ClusterPredicate(clusterId);\r\n    \/\/ Merge sort the revs for which changes have been made\r\n    \/\/ to this doc\r\n    \/\/ localMap always keeps the most recent valid commit entry\r\n    \/\/ per cluster node so looking into that should be sufficient\r\n    Iterable<Revision> revs = mergeSorted(of(filter(doc.getLocalCommitRoot().keySet(), cp), filter(doc.getLocalRevisions().keySet(), cp)), StableRevisionComparator.REVERSE);\r\n    \/\/ if found then lastRev needs to be fixed\r\n    for (Revision rev : revs) {\r\n        if (rev.compareRevisionTime(currentLastRev) > 0) {\r\n            if (doc.isCommitted(rev)) {\r\n                return rev;\r\n            }\r\n        } else {\r\n            \/\/ and no further checks are required\r\n            break;\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":"\/**\r\n * Determines the last revision value which needs to set for given clusterId\r\n * on the passed document. If the last rev entries are consisted\r\n *\r\n * @param doc NodeDocument where lastRev entries needs to be fixed\r\n * @param clusterId clusterId for which lastRev has to be checked\r\n * @return lastRev which needs to be updated. <tt>null<\/tt> if no\r\n *         updated is required i.e. lastRev entries are valid\r\n *\/\r\n","code_no_comment":"@CheckForNull\r\nprivate Revision determineMissedLastRev(NodeDocument doc, int clusterId) {\r\n    Revision currentLastRev = doc.getLastRev().get(clusterId);\r\n    if (currentLastRev == null) {\r\n        currentLastRev = new Revision(0, 0, clusterId);\r\n    }\r\n    ClusterPredicate cp = new ClusterPredicate(clusterId);\r\n                    Iterable<Revision> revs = mergeSorted(of(filter(doc.getLocalCommitRoot().keySet(), cp), filter(doc.getLocalRevisions().keySet(), cp)), StableRevisionComparator.REVERSE);\r\n        for (Revision rev : revs) {\r\n        if (rev.compareRevisionTime(currentLastRev) > 0) {\r\n            if (doc.isCommitted(rev)) {\r\n                return rev;\r\n            }\r\n        } else {\r\n                        break;\r\n        }\r\n    }\r\n    return null;\r\n}","lc":0.2272727273,"pi":0.6650717703,"ma":0.4,"nbd":0.5,"ml":0.1666666667,"d":0.0238095238,"mi":-0.236645525,"fo":0.5,"r":-0.0263157895,"e":0.0992075978}
{"project_name":"Math","project_version":"29","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic OpenMapRealVector ebeMultiply(RealVector v) {\r\n    checkVectorDimensions(v.getDimension());\r\n    OpenMapRealVector res = new OpenMapRealVector(this);\r\n    Iterator iter = entries.iterator();\r\n    while (iter.hasNext()) {\r\n        iter.advance();\r\n        res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\r\n    }\r\n    \/*\r\n         * MATH-803: the above loop assumes that 0d * x  = 0d for any double x,\r\n         * which allows to consider only the non-zero entries of this. However,\r\n         * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).\r\n         *\r\n         * These special cases are handled below.\r\n         *\/\r\n    return res;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic OpenMapRealVector ebeMultiply(RealVector v) {\r\n    checkVectorDimensions(v.getDimension());\r\n    OpenMapRealVector res = new OpenMapRealVector(this);\r\n    Iterator iter = entries.iterator();\r\n    while (iter.hasNext()) {\r\n        iter.advance();\r\n        res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\r\n    }\r\n        return res;\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0416666667,"mi":0.1357293869,"fo":0.3333333333,"r":0.5789473684,"e":-0.0504578644}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-867_bfbb156d","label":1,"code":"\/**\r\n * @param x Normalized objective variables.\r\n * @return the repaired objective variables - all in bounds.\r\n *\/\r\nprivate double[] repair(final double[] x) {\r\n    double[] repaired = new double[x.length];\r\n    for (int i = 0; i < x.length; i++) {\r\n        if (x[i] < 0) {\r\n            repaired[i] = 0;\r\n        } else if (x[i] > 1.0) {\r\n            repaired[i] = 1.0;\r\n        } else {\r\n            repaired[i] = x[i];\r\n        }\r\n    }\r\n    return repaired;\r\n}","code_comment":"\/**\r\n * @param x Normalized objective variables.\r\n * @return the repaired objective variables - all in bounds.\r\n *\/\r\n","code_no_comment":"private double[] repair(final double[] x) {\r\n    double[] repaired = new double[x.length];\r\n    for (int i = 0; i < x.length; i++) {\r\n        if (x[i] < 0) {\r\n            repaired[i] = 0;\r\n        } else if (x[i] > 1.0) {\r\n            repaired[i] = 1.0;\r\n        } else {\r\n            repaired[i] = x[i];\r\n        }\r\n    }\r\n    return repaired;\r\n}","lc":-0.0454545455,"pi":0.4880382775,"ma":0.0,"nbd":0.5,"ml":0.0,"d":1.0734126984,"mi":0.059901339,"fo":-0.5,"r":0.6052631579,"e":0.2925514197}
{"project_name":"Csv","project_version":"16","label":3,"code":"\/**\r\n * Returns an iterator on the records.\r\n *\r\n * <p>\r\n * An {@link IOException} caught during the iteration are re-thrown as an\r\n * {@link IllegalStateException}.\r\n * <\/p>\r\n * <p>\r\n * If the parser is closed a call to {@link Iterator#next()} will throw a\r\n * {@link NoSuchElementException}.\r\n * <\/p>\r\n *\/\r\n@Override\r\npublic Iterator<CSVRecord> iterator() {\r\n    return new Iterator<CSVRecord>() {\r\n\r\n        private CSVRecord current;\r\n\r\n        private CSVRecord getNextRecord() {\r\n            try {\r\n                return CSVParser.this.nextRecord();\r\n            } catch (final IOException e) {\r\n                throw new IllegalStateException(e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public boolean hasNext() {\r\n            if (CSVParser.this.isClosed()) {\r\n                return false;\r\n            }\r\n            if (this.current == null) {\r\n                this.current = this.getNextRecord();\r\n            }\r\n            return this.current != null;\r\n        }\r\n\r\n        @Override\r\n        public CSVRecord next() {\r\n            if (CSVParser.this.isClosed()) {\r\n                throw new NoSuchElementException(\"CSVParser has been closed\");\r\n            }\r\n            CSVRecord next = this.current;\r\n            this.current = null;\r\n            if (next == null) {\r\n                \/\/ hasNext() wasn't called before\r\n                next = this.getNextRecord();\r\n                if (next == null) {\r\n                    throw new NoSuchElementException(\"No more CSV records available\");\r\n                }\r\n            }\r\n            return next;\r\n        }\r\n\r\n        @Override\r\n        public void remove() {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    };\r\n}","code_comment":"\/**\r\n * Returns an iterator on the records.\r\n *\r\n * <p>\r\n * An {@link IOException} caught during the iteration are re-thrown as an\r\n * {@link IllegalStateException}.\r\n * <\/p>\r\n * <p>\r\n * If the parser is closed a call to {@link Iterator#next()} will throw a\r\n * {@link NoSuchElementException}.\r\n * <\/p>\r\n *\/\r\n","code_no_comment":"@Override\r\npublic Iterator<CSVRecord> iterator() {\r\n    return new Iterator<CSVRecord>() {\r\n\r\n        private CSVRecord current;\r\n\r\n        private CSVRecord getNextRecord() {\r\n            try {\r\n                return CSVParser.this.nextRecord();\r\n            } catch (final IOException e) {\r\n                throw new IllegalStateException(e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public boolean hasNext() {\r\n            if (CSVParser.this.isClosed()) {\r\n                return false;\r\n            }\r\n            if (this.current == null) {\r\n                this.current = this.getNextRecord();\r\n            }\r\n            return this.current != null;\r\n        }\r\n\r\n        @Override\r\n        public CSVRecord next() {\r\n            if (CSVParser.this.isClosed()) {\r\n                throw new NoSuchElementException(\"CSVParser has been closed\");\r\n            }\r\n            CSVRecord next = this.current;\r\n            this.current = null;\r\n            if (next == null) {\r\n                                next = this.getNextRecord();\r\n                if (next == null) {\r\n                    throw new NoSuchElementException(\"No more CSV records available\");\r\n                }\r\n            }\r\n            return next;\r\n        }\r\n\r\n        @Override\r\n        public void remove() {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    };\r\n}","lc":1.2727272727,"pi":0.7320574163,"ma":1.4,"nbd":0.5,"ml":0.25,"d":0.5198412698,"mi":-0.6501761804,"fo":0.1666666667,"r":-0.0263157895,"e":0.5134420221}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5250_6122df49","label":1,"code":"\/**\r\n *  @see org.apache.wicket.request.resource.ResourceReference#getResource()\r\n *\/\r\n@Override\r\npublic PackageResource getResource() {\r\n    final String extension = getExtension();\r\n    final PackageResource resource;\r\n    if (CSS_EXTENSION.equals(extension)) {\r\n        resource = new CssPackageResource(getScope(), getName(), getLocale(), getStyle(), getVariation());\r\n    } else if (JAVASCRIPT_EXTENSION.equals(extension)) {\r\n        resource = new JavaScriptPackageResource(getScope(), getName(), getLocale(), getStyle(), getVariation());\r\n    } else {\r\n        resource = new PackageResource(getScope(), getName(), getLocale(), getStyle(), getVariation());\r\n    }\r\n    String minifiedName = MINIFIED_NAMES_CACHE.get(this);\r\n    if (minifiedName != null && minifiedName != NO_MINIFIED_NAME) {\r\n        resource.setCompress(false);\r\n    }\r\n    return resource;\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.request.resource.ResourceReference#getResource()\r\n *\/\r\n","code_no_comment":"@Override\r\npublic PackageResource getResource() {\r\n    final String extension = getExtension();\r\n    final PackageResource resource;\r\n    if (CSS_EXTENSION.equals(extension)) {\r\n        resource = new CssPackageResource(getScope(), getName(), getLocale(), getStyle(), getVariation());\r\n    } else if (JAVASCRIPT_EXTENSION.equals(extension)) {\r\n        resource = new JavaScriptPackageResource(getScope(), getName(), getLocale(), getStyle(), getVariation());\r\n    } else {\r\n        resource = new PackageResource(getScope(), getName(), getLocale(), getStyle(), getVariation());\r\n    }\r\n    String minifiedName = MINIFIED_NAMES_CACHE.get(this);\r\n    if (minifiedName != null && minifiedName != NO_MINIFIED_NAME) {\r\n        resource.setCompress(false);\r\n    }\r\n    return resource;\r\n}","lc":0.1363636364,"pi":-0.2057416268,"ma":0.0,"nbd":0.0,"ml":0.25,"d":0.0158730159,"mi":-0.1622269204,"fo":1.1666666667,"r":-0.0263157895,"e":0.0755104511}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Adds several element to the end of this expandable array.\r\n *\r\n * @param values Values to be added to end of array.\r\n * @since 2.2\r\n *\/\r\n@Override\r\npublic synchronized void addElements(double[] values) {\r\n    final double[] tempArray = new double[numElements + values.length + 1];\r\n    System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);\r\n    System.arraycopy(values, 0, tempArray, numElements, values.length);\r\n    internalArray = tempArray;\r\n    startIndex = 0;\r\n    numElements += values.length;\r\n}","code_comment":"\/**\r\n * Adds several element to the end of this expandable array.\r\n *\r\n * @param values Values to be added to end of array.\r\n * @since 2.2\r\n *\/\r\n","code_no_comment":"@Override\r\npublic synchronized void addElements(double[] values) {\r\n    final double[] tempArray = new double[numElements + values.length + 1];\r\n    System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);\r\n    System.arraycopy(values, 0, tempArray, numElements, values.length);\r\n    internalArray = tempArray;\r\n    startIndex = 0;\r\n    numElements += values.length;\r\n}","lc":-0.2272727273,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":0.1071428571,"mi":0.2391825229,"fo":-0.3333333333,"r":0.0526315789,"e":-0.0044835555}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2528_239de7b8","label":1,"code":"\/**\r\n * Collect _revisions and _commitRoot entries that can be moved to a\r\n * previous document.\r\n *\/\r\nprivate void collectRevisionsAndCommitRoot() {\r\n    NavigableMap<Revision, String> revisions = new TreeMap<Revision, String>(context.getRevisionComparator());\r\n    for (Map.Entry<Revision, String> entry : doc.getLocalRevisions().entrySet()) {\r\n        if (splitRevs.contains(entry.getKey())) {\r\n            revisions.put(entry.getKey(), entry.getValue());\r\n            numValues++;\r\n        } else {\r\n            \/\/ local changes\r\n            if (context.getClusterId() != entry.getKey().getClusterId()) {\r\n                \/\/ only consider local changes\r\n                continue;\r\n            }\r\n            if (doc.isCommitted(entry.getKey()) && !mostRecentRevs.contains(entry.getKey())) {\r\n                \/\/ this is a commit root for changes in other documents\r\n                revisions.put(entry.getKey(), entry.getValue());\r\n                numValues++;\r\n                trackHigh(entry.getKey());\r\n                trackLow(entry.getKey());\r\n            }\r\n        }\r\n    }\r\n    committedChanges.put(REVISIONS, revisions);\r\n    NavigableMap<Revision, String> commitRoot = new TreeMap<Revision, String>(context.getRevisionComparator());\r\n    for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {\r\n        if (splitRevs.contains(entry.getKey())) {\r\n            commitRoot.put(entry.getKey(), entry.getValue());\r\n            numValues++;\r\n        }\r\n    }\r\n    committedChanges.put(COMMIT_ROOT, commitRoot);\r\n}","code_comment":"\/**\r\n * Collect _revisions and _commitRoot entries that can be moved to a\r\n * previous document.\r\n *\/\r\n","code_no_comment":"private void collectRevisionsAndCommitRoot() {\r\n    NavigableMap<Revision, String> revisions = new TreeMap<Revision, String>(context.getRevisionComparator());\r\n    for (Map.Entry<Revision, String> entry : doc.getLocalRevisions().entrySet()) {\r\n        if (splitRevs.contains(entry.getKey())) {\r\n            revisions.put(entry.getKey(), entry.getValue());\r\n            numValues++;\r\n        } else {\r\n                        if (context.getClusterId() != entry.getKey().getClusterId()) {\r\n                                continue;\r\n            }\r\n            if (doc.isCommitted(entry.getKey()) && !mostRecentRevs.contains(entry.getKey())) {\r\n                                revisions.put(entry.getKey(), entry.getValue());\r\n                numValues++;\r\n                trackHigh(entry.getKey());\r\n                trackLow(entry.getKey());\r\n            }\r\n        }\r\n    }\r\n    committedChanges.put(REVISIONS, revisions);\r\n    NavigableMap<Revision, String> commitRoot = new TreeMap<Revision, String>(context.getRevisionComparator());\r\n    for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {\r\n        if (splitRevs.contains(entry.getKey())) {\r\n            commitRoot.put(entry.getKey(), entry.getValue());\r\n            numValues++;\r\n        }\r\n    }\r\n    committedChanges.put(COMMIT_ROOT, commitRoot);\r\n}","lc":0.6363636364,"pi":0.9330143541,"ma":0.8,"nbd":0.5,"ml":0.5,"d":0.8134920635,"mi":-0.5117688513,"fo":2.1666666667,"r":-0.0263157895,"e":1.2519354783}
{"project_name":"Math","project_version":"11","label":0,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic double density(final double[] vals) throws DimensionMismatchException {\r\n    final int dim = getDimension();\r\n    if (vals.length != dim) {\r\n        throw new DimensionMismatchException(vals.length, dim);\r\n    }\r\n    return FastMath.pow(2 * FastMath.PI, -dim \/ 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals);\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public double density(final double[] vals) throws DimensionMismatchException {\r\n    final int dim = getDimension();\r\n    if (vals.length != dim) {\r\n        throw new DimensionMismatchException(vals.length, dim);\r\n    }\r\n    return FastMath.pow(2 * FastMath.PI, -dim \/ 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals);\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":0.371031746,"mi":0.3448907681,"fo":-0.1666666667,"r":1.0263157895,"e":0.0772531595}
{"project_name":"Lang","project_version":"32","label":1,"code":"\/**\r\n * <p>\r\n * Unregisters the given object.\r\n * <\/p>\r\n *\r\n * <p>\r\n * Used by the reflection methods to avoid infinite loops.\r\n *\r\n * @param value\r\n *            The object to unregister.\r\n * @since 2.3\r\n *\/\r\nstatic void unregister(Object value) {\r\n    getRegistry().remove(new IDKey(value));\r\n}","code_comment":"\/**\r\n * <p>\r\n * Unregisters the given object.\r\n * <\/p>\r\n *\r\n * <p>\r\n * Used by the reflection methods to avoid infinite loops.\r\n *\r\n * @param value\r\n *            The object to unregister.\r\n * @since 2.3\r\n *\/\r\n","code_no_comment":"static void unregister(Object value) {\r\n    getRegistry().remove(new IDKey(value));\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0132487667,"fo":-0.3333333333,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5644_15d0fd9b","label":3,"code":"private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<MethodInfo> operationList, Object body, List<MethodInfo> possibles, List<MethodInfo> possiblesWithException, List<MethodInfo> possibleWithCustomAnnotation) throws AmbiguousMethodCallException {\r\n    Exception exception = ExpressionBuilder.exchangeExceptionExpression().evaluate(exchange, Exception.class);\r\n    if (exception != null && possiblesWithException.size() == 1) {\r\n        LOG.trace(\"Exchange has exception set so we prefer method that also has exception as parameter\");\r\n        \/\/ prefer the method that accepts exception in case we have an exception also\r\n        return possiblesWithException.get(0);\r\n    } else if (possibles.size() == 1) {\r\n        return possibles.get(0);\r\n    } else if (possibles.isEmpty()) {\r\n        LOG.trace(\"No possible methods so now trying to convert body to parameter types\");\r\n        \/\/ let's try converting\r\n        Object newBody = null;\r\n        MethodInfo matched = null;\r\n        int matchCounter = 0;\r\n        for (MethodInfo methodInfo : operationList) {\r\n            if (methodInfo.getBodyParameterType().isInstance(body)) {\r\n                return methodInfo;\r\n            }\r\n            Object value = convertToType(exchange, methodInfo.getBodyParameterType(), body);\r\n            if (value != null) {\r\n                if (LOG.isTraceEnabled()) {\r\n                    LOG.trace(\"Converted body from: {} to: {}\", body.getClass().getCanonicalName(), methodInfo.getBodyParameterType().getCanonicalName());\r\n                }\r\n                matchCounter++;\r\n                newBody = value;\r\n                matched = methodInfo;\r\n            }\r\n        }\r\n        if (matchCounter > 1) {\r\n            throw new AmbiguousMethodCallException(exchange, Arrays.asList(matched, matched));\r\n        }\r\n        if (matched != null) {\r\n            LOG.trace(\"Setting converted body: {}\", body);\r\n            Message in = exchange.getIn();\r\n            in.setBody(newBody);\r\n            return matched;\r\n        }\r\n    } else {\r\n        \/\/ if we only have a single method with custom annotations, let's use that one\r\n        if (possibleWithCustomAnnotation.size() == 1) {\r\n            MethodInfo answer = possibleWithCustomAnnotation.get(0);\r\n            LOG.trace(\"There are only one method with annotations so we choose it: {}\", answer);\r\n            return answer;\r\n        }\r\n        \/\/ phew try to choose among multiple methods with annotations\r\n        return chooseMethodWithCustomAnnotations(exchange, possibles);\r\n    }\r\n    \/\/ cannot find a good method to use\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<MethodInfo> operationList, Object body, List<MethodInfo> possibles, List<MethodInfo> possiblesWithException, List<MethodInfo> possibleWithCustomAnnotation) throws AmbiguousMethodCallException {\r\n    Exception exception = ExpressionBuilder.exchangeExceptionExpression().evaluate(exchange, Exception.class);\r\n    if (exception != null && possiblesWithException.size() == 1) {\r\n        LOG.trace(\"Exchange has exception set so we prefer method that also has exception as parameter\");\r\n                return possiblesWithException.get(0);\r\n    } else if (possibles.size() == 1) {\r\n        return possibles.get(0);\r\n    } else if (possibles.isEmpty()) {\r\n        LOG.trace(\"No possible methods so now trying to convert body to parameter types\");\r\n                Object newBody = null;\r\n        MethodInfo matched = null;\r\n        int matchCounter = 0;\r\n        for (MethodInfo methodInfo : operationList) {\r\n            if (methodInfo.getBodyParameterType().isInstance(body)) {\r\n                return methodInfo;\r\n            }\r\n            Object value = convertToType(exchange, methodInfo.getBodyParameterType(), body);\r\n            if (value != null) {\r\n                if (LOG.isTraceEnabled()) {\r\n                    LOG.trace(\"Converted body from: {} to: {}\", body.getClass().getCanonicalName(), methodInfo.getBodyParameterType().getCanonicalName());\r\n                }\r\n                matchCounter++;\r\n                newBody = value;\r\n                matched = methodInfo;\r\n            }\r\n        }\r\n        if (matchCounter > 1) {\r\n            throw new AmbiguousMethodCallException(exchange, Arrays.asList(matched, matched));\r\n        }\r\n        if (matched != null) {\r\n            LOG.trace(\"Setting converted body: {}\", body);\r\n            Message in = exchange.getIn();\r\n            in.setBody(newBody);\r\n            return matched;\r\n        }\r\n    } else {\r\n                if (possibleWithCustomAnnotation.size() == 1) {\r\n            MethodInfo answer = possibleWithCustomAnnotation.get(0);\r\n            LOG.trace(\"There are only one method with annotations so we choose it: {}\", answer);\r\n            return answer;\r\n        }\r\n                return chooseMethodWithCustomAnnotations(exchange, possibles);\r\n    }\r\n        return null;\r\n}","lc":1.4090909091,"pi":0.6794258373,"ma":1.6,"nbd":2.0,"ml":1.3333333333,"d":1.1408730159,"mi":-0.8286116984,"fo":1.75,"r":-0.0263157895,"e":2.8368873291}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2057_e2d88568","label":1,"code":"\/**\r\n *  @see org.apache.wicket.ajax.IAjaxCallDecorator#decorateOnFailureScript(CharSequence)\r\n *\/\r\npublic CharSequence decorateOnFailureScript(CharSequence script) {\r\n    CharSequence s = (delegate == null) ? script : delegate.decorateOnFailureScript(script);\r\n    return preDecorateOnFailureScript(s);\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.ajax.IAjaxCallDecorator#decorateOnFailureScript(CharSequence)\r\n *\/\r\n","code_no_comment":"public CharSequence decorateOnFailureScript(CharSequence script) {\r\n    CharSequence s = (delegate == null) ? script : delegate.decorateOnFailureScript(script);\r\n    return preDecorateOnFailureScript(s);\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":0.0079365079,"mi":0.7403805497,"fo":-0.3333333333,"r":2.4210526316,"e":-0.1139745163}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2117_c7669f31","label":3,"code":"private void collectIndexEditors(NodeBuilder definitions, NodeState before) throws CommitFailedException {\r\n    for (String name : definitions.getChildNodeNames()) {\r\n        NodeBuilder definition = definitions.getChildNode(name);\r\n        if (Objects.equal(async, definition.getString(ASYNC_PROPERTY_NAME))) {\r\n            String type = definition.getString(TYPE_PROPERTY_NAME);\r\n            boolean shouldReindex = shouldReindex(definition, before, name);\r\n            Editor editor = provider.getIndexEditor(type, definition, root, updateCallback);\r\n            if (editor == null) {\r\n                \/\/ trigger reindexing when an indexer becomes available\r\n                definition.setProperty(REINDEX_PROPERTY_NAME, true);\r\n            } else if (shouldReindex) {\r\n                if (definition.getBoolean(REINDEX_ASYNC_PROPERTY_NAME) && definition.getString(ASYNC_PROPERTY_NAME) == null) {\r\n                    \/\/ switch index to an async update mode\r\n                    definition.setProperty(ASYNC_PROPERTY_NAME, ASYNC_REINDEX_VALUE);\r\n                } else {\r\n                    definition.setProperty(REINDEX_PROPERTY_NAME, false);\r\n                    \/\/ beforehand, we'll remove all child nodes\r\n                    for (String rm : definition.getChildNodeNames()) {\r\n                        definition.getChildNode(rm).remove();\r\n                    }\r\n                    reindex.put(concat(getPath(), INDEX_DEFINITIONS_NAME, name), editor);\r\n                }\r\n            } else {\r\n                editors.add(editor);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void collectIndexEditors(NodeBuilder definitions, NodeState before) throws CommitFailedException {\r\n    for (String name : definitions.getChildNodeNames()) {\r\n        NodeBuilder definition = definitions.getChildNode(name);\r\n        if (Objects.equal(async, definition.getString(ASYNC_PROPERTY_NAME))) {\r\n            String type = definition.getString(TYPE_PROPERTY_NAME);\r\n            boolean shouldReindex = shouldReindex(definition, before, name);\r\n            Editor editor = provider.getIndexEditor(type, definition, root, updateCallback);\r\n            if (editor == null) {\r\n                                definition.setProperty(REINDEX_PROPERTY_NAME, true);\r\n            } else if (shouldReindex) {\r\n                if (definition.getBoolean(REINDEX_ASYNC_PROPERTY_NAME) && definition.getString(ASYNC_PROPERTY_NAME) == null) {\r\n                                        definition.setProperty(ASYNC_PROPERTY_NAME, ASYNC_REINDEX_VALUE);\r\n                } else {\r\n                    definition.setProperty(REINDEX_PROPERTY_NAME, false);\r\n                                        for (String rm : definition.getChildNodeNames()) {\r\n                        definition.getChildNode(rm).remove();\r\n                    }\r\n                    reindex.put(concat(getPath(), INDEX_DEFINITIONS_NAME, name), editor);\r\n                }\r\n            } else {\r\n                editors.add(editor);\r\n            }\r\n        }\r\n    }\r\n}","lc":0.5,"pi":1.5837320574,"ma":0.6,"nbd":2.0,"ml":0.5,"d":0.003968254,"mi":-0.4429880197,"fo":1.0833333333,"r":-0.0263157895,"e":0.2493940285}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4664_2fcb3417","label":1,"code":"\/**\r\n *  Stringizes this url\r\n *\r\n *  @param mode\r\n *             {@link StringMode} that determins how to stringize the url\r\n *  @param charset\r\n *             charset\r\n *  @return sringized version of this url\r\n *\/\r\npublic String toString(StringMode mode, Charset charset) {\r\n    StringBuilder result = new StringBuilder();\r\n    final String path = getPath(charset);\r\n    if (StringMode.FULL == mode) {\r\n        if (Strings.isEmpty(host)) {\r\n            throw new IllegalStateException(\"Cannot render this url in \" + StringMode.FULL.name() + \" mode because it does not have a host set.\");\r\n        }\r\n        if (Strings.isEmpty(protocol) == false) {\r\n            result.append(protocol);\r\n            result.append(\":\/\/\");\r\n        } else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false) {\r\n            result.append(\"\/\/\");\r\n        }\r\n        result.append(host);\r\n        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {\r\n            result.append(':');\r\n            result.append(port);\r\n        }\r\n        if (segments.contains(\"..\")) {\r\n            throw new IllegalStateException(\"Cannot render this url in \" + StringMode.FULL.name() + \" mode because it has a `..` segment: \" + toString());\r\n        }\r\n        if (!path.startsWith(\"\/\")) {\r\n            result.append('\/');\r\n        }\r\n    }\r\n    result.append(path);\r\n    result.append(getQueryString(charset));\r\n    return result.toString();\r\n}","code_comment":"\/**\r\n *  Stringizes this url\r\n *\r\n *  @param mode\r\n *             {@link StringMode} that determins how to stringize the url\r\n *  @param charset\r\n *             charset\r\n *  @return sringized version of this url\r\n *\/\r\n","code_no_comment":"public String toString(StringMode mode, Charset charset) {\r\n    StringBuilder result = new StringBuilder();\r\n    final String path = getPath(charset);\r\n    if (StringMode.FULL == mode) {\r\n        if (Strings.isEmpty(host)) {\r\n            throw new IllegalStateException(\"Cannot render this url in \" + StringMode.FULL.name() + \" mode because it does not have a host set.\");\r\n        }\r\n        if (Strings.isEmpty(protocol) == false) {\r\n            result.append(protocol);\r\n            result.append(\":\/\/\");\r\n        } else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false) {\r\n            result.append(\"\/\/\");\r\n        }\r\n        result.append(host);\r\n        if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false) {\r\n            result.append(':');\r\n            result.append(port);\r\n        }\r\n        if (segments.contains(\"..\")) {\r\n            throw new IllegalStateException(\"Cannot render this url in \" + StringMode.FULL.name() + \" mode because it has a `..` segment: \" + toString());\r\n        }\r\n        if (!path.startsWith(\"\/\")) {\r\n            result.append('\/');\r\n        }\r\n    }\r\n    result.append(path);\r\n    result.append(getQueryString(charset));\r\n    return result.toString();\r\n}","lc":0.6818181818,"pi":0.2631578947,"ma":1.2,"nbd":0.5,"ml":1.1666666667,"d":1.0734126984,"mi":-0.5455954898,"fo":1.4166666667,"r":-0.0263157895,"e":1.6215648646}
{"project_name":"Lang","project_version":"19","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\r\n    int seqEnd = input.length();\r\n    \/\/ Uses -2 to ensure there is something after the &#\r\n    if (input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\r\n        int start = index + 2;\r\n        boolean isHex = false;\r\n        char firstChar = input.charAt(start);\r\n        if (firstChar == 'x' || firstChar == 'X') {\r\n            start++;\r\n            isHex = true;\r\n        \/\/ Check there's more than just an x after the &#\r\n        }\r\n        int end = start;\r\n        \/\/ Note that this supports character codes without a ; on the end\r\n        while (input.charAt(end) != ';') {\r\n            end++;\r\n        }\r\n        int entityValue;\r\n        try {\r\n            if (isHex) {\r\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\r\n            } else {\r\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\r\n            }\r\n        } catch (NumberFormatException nfe) {\r\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start + \"][\" + end + \"]\");\r\n            return 0;\r\n        }\r\n        if (entityValue > 0xFFFF) {\r\n            char[] chrs = Character.toChars(entityValue);\r\n            out.write(chrs[0]);\r\n            out.write(chrs[1]);\r\n        } else {\r\n            out.write(entityValue);\r\n        }\r\n        return 2 + (end - start) + (isHex ? 1 : 0) + 1;\r\n    }\r\n    return 0;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\r\n    int seqEnd = input.length();\r\n        if (input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\r\n        int start = index + 2;\r\n        boolean isHex = false;\r\n        char firstChar = input.charAt(start);\r\n        if (firstChar == 'x' || firstChar == 'X') {\r\n            start++;\r\n            isHex = true;\r\n                }\r\n        int end = start;\r\n                while (input.charAt(end) != ';') {\r\n            end++;\r\n        }\r\n        int entityValue;\r\n        try {\r\n            if (isHex) {\r\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\r\n            } else {\r\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\r\n            }\r\n        } catch (NumberFormatException nfe) {\r\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start + \"][\" + end + \"]\");\r\n            return 0;\r\n        }\r\n        if (entityValue > 0xFFFF) {\r\n            char[] chrs = Character.toChars(entityValue);\r\n            out.write(chrs[0]);\r\n            out.write(chrs[1]);\r\n        } else {\r\n            out.write(entityValue);\r\n        }\r\n        return 2 + (end - start) + (isHex ? 1 : 0) + 1;\r\n    }\r\n    return 0;\r\n}","lc":1.0454545455,"pi":0.4306220096,"ma":0.8,"nbd":0.5,"ml":1.0833333333,"d":1.9146825397,"mi":-0.7006342495,"fo":0.9166666667,"r":-0.0263157895,"e":4.0082640342}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3517_24f7f60a","label":1,"code":"@Override\r\n@Nonnull\r\npublic Node addNode(final String relPath, String primaryNodeTypeName) throws RepositoryException {\r\n    final String oakPath = getOakPathOrThrowNotFound(relPath);\r\n    final String oakTypeName;\r\n    if (primaryNodeTypeName != null) {\r\n        oakTypeName = getOakName(primaryNodeTypeName);\r\n    } else {\r\n        oakTypeName = null;\r\n    }\r\n    checkIndexOnName(relPath);\r\n    return perform(new ItemWriteOperation<Node>(\"addNode\") {\r\n\r\n        @Nonnull\r\n        @Override\r\n        public Node perform() throws RepositoryException {\r\n            String oakName = PathUtils.getName(oakPath);\r\n            String parentPath = PathUtils.getParentPath(oakPath);\r\n            NodeDelegate parent = dlg.getChild(parentPath);\r\n            if (parent == null) {\r\n                \/\/ is it a property?\r\n                String grandParentPath = PathUtils.getParentPath(parentPath);\r\n                NodeDelegate grandParent = dlg.getChild(grandParentPath);\r\n                if (grandParent != null) {\r\n                    String propName = PathUtils.getName(parentPath);\r\n                    if (grandParent.getPropertyOrNull(propName) != null) {\r\n                        throw new ConstraintViolationException(\"Can't add new node to property.\");\r\n                    }\r\n                }\r\n                throw new PathNotFoundException(relPath);\r\n            }\r\n            if (parent.getChild(oakName) != null) {\r\n                throw new ItemExistsException(relPath);\r\n            }\r\n            \/\/ modification of that property in the PermissionValidator\r\n            if (oakTypeName != null) {\r\n                PropertyState prop = PropertyStates.createProperty(JCR_PRIMARYTYPE, oakTypeName, NAME);\r\n                sessionContext.getAccessManager().checkPermissions(dlg.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);\r\n            }\r\n            NodeDelegate added = parent.addChild(oakName, oakTypeName);\r\n            if (added == null) {\r\n                throw new ItemExistsException();\r\n            }\r\n            return createNode(added, sessionContext);\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"Adding node [%s\/%s]\", dlg.getPath(), relPath);\r\n        }\r\n    });\r\n}","code_comment":null,"code_no_comment":"@Override\r\n@Nonnull\r\npublic Node addNode(final String relPath, String primaryNodeTypeName) throws RepositoryException {\r\n    final String oakPath = getOakPathOrThrowNotFound(relPath);\r\n    final String oakTypeName;\r\n    if (primaryNodeTypeName != null) {\r\n        oakTypeName = getOakName(primaryNodeTypeName);\r\n    } else {\r\n        oakTypeName = null;\r\n    }\r\n    checkIndexOnName(relPath);\r\n    return perform(new ItemWriteOperation<Node>(\"addNode\") {\r\n\r\n        @Nonnull\r\n        @Override\r\n        public Node perform() throws RepositoryException {\r\n            String oakName = PathUtils.getName(oakPath);\r\n            String parentPath = PathUtils.getParentPath(oakPath);\r\n            NodeDelegate parent = dlg.getChild(parentPath);\r\n            if (parent == null) {\r\n                                String grandParentPath = PathUtils.getParentPath(parentPath);\r\n                NodeDelegate grandParent = dlg.getChild(grandParentPath);\r\n                if (grandParent != null) {\r\n                    String propName = PathUtils.getName(parentPath);\r\n                    if (grandParent.getPropertyOrNull(propName) != null) {\r\n                        throw new ConstraintViolationException(\"Can't add new node to property.\");\r\n                    }\r\n                }\r\n                throw new PathNotFoundException(relPath);\r\n            }\r\n            if (parent.getChild(oakName) != null) {\r\n                throw new ItemExistsException(relPath);\r\n            }\r\n                        if (oakTypeName != null) {\r\n                PropertyState prop = PropertyStates.createProperty(JCR_PRIMARYTYPE, oakTypeName, NAME);\r\n                sessionContext.getAccessManager().checkPermissions(dlg.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);\r\n            }\r\n            NodeDelegate added = parent.addChild(oakName, oakTypeName);\r\n            if (added == null) {\r\n                throw new ItemExistsException();\r\n            }\r\n            return createNode(added, sessionContext);\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return String.format(\"Adding node [%s\/%s]\", dlg.getPath(), relPath);\r\n        }\r\n    });\r\n}","lc":1.5454545455,"pi":1.3253588517,"ma":1.6,"nbd":1.0,"ml":0.9166666667,"d":0.0833333333,"mi":-0.8480620155,"fo":1.1666666667,"r":-0.0263157895,"e":0.6737619797}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-9269_62b2042b","label":1,"code":"@Override\r\npublic boolean onExchange(Exchange exchange) {\r\n    String id = EndpointHelper.getRouteIdFromEndpoint(exchange.getFromEndpoint());\r\n    \/\/ filter non matching exchanges\r\n    return EndpointHelper.matchPattern(id, routeId);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean onExchange(Exchange exchange) {\r\n    String id = EndpointHelper.getRouteIdFromEndpoint(exchange.getFromEndpoint());\r\n        return EndpointHelper.matchPattern(id, routeId);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6380549683,"fo":-0.25,"r":2.0,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-428_d906576c","label":3,"code":"public Iterator iterator() {\r\n    return new Iterator() {\r\n\r\n        public boolean hasNext() {\r\n            return index < MicroMap.this.size();\r\n        }\r\n\r\n        public Object next() {\r\n            index++;\r\n            return new Map.Entry() {\r\n\r\n                public Object getKey() {\r\n                    return key;\r\n                }\r\n\r\n                public Object getValue() {\r\n                    return value;\r\n                }\r\n\r\n                public Object setValue(final Object value) {\r\n                    final Object oldValue = MicroMap.this.value;\r\n                    MicroMap.this.value = value;\r\n                    return oldValue;\r\n                }\r\n            };\r\n        }\r\n\r\n        public void remove() {\r\n            clear();\r\n        }\r\n\r\n        int index = 0;\r\n    };\r\n}","code_comment":null,"code_no_comment":"public Iterator iterator() {\r\n    return new Iterator() {\r\n\r\n        public boolean hasNext() {\r\n            return index < MicroMap.this.size();\r\n        }\r\n\r\n        public Object next() {\r\n            index++;\r\n            return new Map.Entry() {\r\n\r\n                public Object getKey() {\r\n                    return key;\r\n                }\r\n\r\n                public Object getValue() {\r\n                    return value;\r\n                }\r\n\r\n                public Object setValue(final Object value) {\r\n                    final Object oldValue = MicroMap.this.value;\r\n                    MicroMap.this.value = value;\r\n                    return oldValue;\r\n                }\r\n            };\r\n        }\r\n\r\n        public void remove() {\r\n            clear();\r\n        }\r\n\r\n        int index = 0;\r\n    };\r\n}","lc":0.5909090909,"pi":1.3971291866,"ma":-0.6,"nbd":0.0,"ml":-0.4166666667,"d":-0.0178571429,"mi":-0.2958421424,"fo":-0.3333333333,"r":0.6315789474,"e":-0.0168069939}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5071_d3d42d42","label":1,"code":"\/**\r\n *  Matches when the request url starts with\r\n *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}\/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\r\n *  or when the base url starts with\r\n *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}\/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\r\n *  and the request url with {@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\r\n *\r\n *  @param request\r\n *       the request to check\r\n *  @return {@code true} if the conditions match\r\n *\/\r\nprivate boolean matches(final Request request) {\r\n    boolean matches = false;\r\n    Url url = request.getUrl();\r\n    String namespace = getContext().getNamespace();\r\n    String pageIdentifier = getContext().getPageIdentifier();\r\n    if (urlStartsWith(url, namespace, pageIdentifier)) {\r\n        matches = true;\r\n    } else if (urlStartsWith(request.getClientUrl(), namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier)) {\r\n        matches = true;\r\n    } else if (urlStartsWith(request.getClientUrl(), pageIdentifier) && urlStartsWith(url, pageIdentifier)) {\r\n        matches = true;\r\n    }\r\n    return matches;\r\n}","code_comment":"\/**\r\n *  Matches when the request url starts with\r\n *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}\/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\r\n *  or when the base url starts with\r\n *  {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}\/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\r\n *  and the request url with {@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\r\n *\r\n *  @param request\r\n *       the request to check\r\n *  @return {@code true} if the conditions match\r\n *\/\r\n","code_no_comment":"private boolean matches(final Request request) {\r\n    boolean matches = false;\r\n    Url url = request.getUrl();\r\n    String namespace = getContext().getNamespace();\r\n    String pageIdentifier = getContext().getPageIdentifier();\r\n    if (urlStartsWith(url, namespace, pageIdentifier)) {\r\n        matches = true;\r\n    } else if (urlStartsWith(request.getClientUrl(), namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier)) {\r\n        matches = true;\r\n    } else if (urlStartsWith(request.getClientUrl(), pageIdentifier) && urlStartsWith(url, pageIdentifier)) {\r\n        matches = true;\r\n    }\r\n    return matches;\r\n}","lc":0.0,"pi":-0.2966507177,"ma":0.0,"nbd":0.5,"ml":0.6666666667,"d":0.1488095238,"mi":-0.0474982382,"fo":0.5,"r":-0.0263157895,"e":0.1058603182}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3098_1b7afefc","label":1,"code":"\/**\r\n *  Invokes a given interface on a component's behavior.\r\n *\r\n *  @param component\r\n *             The component\r\n *  @param behavior\r\n *\/\r\npublic final void invoke(final IRequestableComponent component, final IBehavior behavior) {\r\n    if (!component.canCallListenerInterface()) {\r\n        \/\/ just return so that we have a silent fail and just re-render the page\r\n        log.warn(\"component not enabled or visible; ignoring call. Component: \" + component);\r\n        return;\r\n    }\r\n    \/\/ XXX a bit of an ugly cast here from IRequestableComponent to Component\r\n    if (!behavior.isEnabled((Component) component)) {\r\n        log.warn(\"behavior not enabled; ignore call. Behavior {} at component {}\", behavior, component);\r\n    }\r\n    try {\r\n        \/\/ Invoke the interface method on the component\r\n        method.invoke(behavior, new Object[] {});\r\n    } catch (InvocationTargetException e) {\r\n        if (e.getTargetException() instanceof ReplaceHandlerException || e.getTargetException() instanceof AuthorizationException || e.getTargetException() instanceof WicketRuntimeException) {\r\n            throw (RuntimeException) e.getTargetException();\r\n        }\r\n        throw new WicketRuntimeException(\"Method \" + method.getName() + \" of \" + method.getDeclaringClass() + \" targeted at behavior \" + behavior + \" on component \" + component + \" threw an exception\", e);\r\n    } catch (Exception e) {\r\n        throw new WicketRuntimeException(\"Method \" + method.getName() + \" of \" + method.getDeclaringClass() + \" targeted at behavior \" + behavior + \" on component \" + component + \" threw an exception\", e);\r\n    }\r\n}","code_comment":"\/**\r\n *  Invokes a given interface on a component's behavior.\r\n *\r\n *  @param component\r\n *             The component\r\n *  @param behavior\r\n *\/\r\n","code_no_comment":"public final void invoke(final IRequestableComponent component, final IBehavior behavior) {\r\n    if (!component.canCallListenerInterface()) {\r\n                log.warn(\"component not enabled or visible; ignoring call. Component: \" + component);\r\n        return;\r\n    }\r\n        if (!behavior.isEnabled((Component) component)) {\r\n        log.warn(\"behavior not enabled; ignore call. Behavior {} at component {}\", behavior, component);\r\n    }\r\n    try {\r\n                method.invoke(behavior, new Object[] {});\r\n    } catch (InvocationTargetException e) {\r\n        if (e.getTargetException() instanceof ReplaceHandlerException || e.getTargetException() instanceof AuthorizationException || e.getTargetException() instanceof WicketRuntimeException) {\r\n            throw (RuntimeException) e.getTargetException();\r\n        }\r\n        throw new WicketRuntimeException(\"Method \" + method.getName() + \" of \" + method.getDeclaringClass() + \" targeted at behavior \" + behavior + \" on component \" + component + \" threw an exception\", e);\r\n    } catch (Exception e) {\r\n        throw new WicketRuntimeException(\"Method \" + method.getName() + \" of \" + method.getDeclaringClass() + \" targeted at behavior \" + behavior + \" on component \" + component + \" threw an exception\", e);\r\n    }\r\n}","lc":0.2272727273,"pi":0.0,"ma":1.0,"nbd":0.0,"ml":0.25,"d":0.0773809524,"mi":-0.2916138125,"fo":0.5833333333,"r":-0.0263157895,"e":0.2163609435}
{"project_name":"Lang","project_version":"26","label":1,"code":"\/**\r\n * <p>Formats a <code>Date<\/code> object.<\/p>\r\n *\r\n * @param date  the date to format\r\n * @return the formatted string\r\n *\/\r\npublic String format(Date date) {\r\n    Calendar c = new GregorianCalendar(mTimeZone);\r\n    c.setTime(date);\r\n    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\r\n}","code_comment":"\/**\r\n * <p>Formats a <code>Date<\/code> object.<\/p>\r\n *\r\n * @param date  the date to format\r\n * @return the formatted string\r\n *\/\r\n","code_no_comment":"public String format(Date date) {\r\n    Calendar c = new GregorianCalendar(mTimeZone);\r\n    c.setTime(date);\r\n    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6126849894,"fo":-0.25,"r":1.9473684211,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5560_aa82ccfc","label":1,"code":"@Override\r\nprotected UrlInfo parseRequest(Request request) {\r\n    if (matches(request)) {\r\n        Url url = request.getUrl();\r\n        \/\/ try to extract page and component information from URL\r\n        PageComponentInfo info = getPageComponentInfo(url);\r\n        List<String> segments = url.getSegments();\r\n        \/\/ load the page class\r\n        String className;\r\n        if (segments.size() >= 3) {\r\n            className = segments.get(2);\r\n        } else {\r\n            className = segments.get(1);\r\n        }\r\n        Class<? extends IRequestablePage> pageClass = getPageClass(className);\r\n        if (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass)) {\r\n            if (Application.exists()) {\r\n                Application application = Application.get();\r\n                if (application.getSecuritySettings().getEnforceMounts()) {\r\n                    \/\/ we make an exception if the homepage itself was mounted, see WICKET-1898\r\n                    if (!pageClass.equals(application.getHomePage())) {\r\n                        \/\/ WICKET-5094 only enforce mount if page is mounted\r\n                        Url reverseUrl = application.getRootRequestMapper().mapHandler(new RenderPageRequestHandler(new PageProvider(pageClass)));\r\n                        if (!matches(request.cloneWithUrl(reverseUrl))) {\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \/\/ extract the PageParameters from URL if there are any\r\n            PageParameters pageParameters = extractPageParameters(request, 3, pageParametersEncoder);\r\n            return new UrlInfo(info, pageClass, pageParameters);\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected UrlInfo parseRequest(Request request) {\r\n    if (matches(request)) {\r\n        Url url = request.getUrl();\r\n                PageComponentInfo info = getPageComponentInfo(url);\r\n        List<String> segments = url.getSegments();\r\n                String className;\r\n        if (segments.size() >= 3) {\r\n            className = segments.get(2);\r\n        } else {\r\n            className = segments.get(1);\r\n        }\r\n        Class<? extends IRequestablePage> pageClass = getPageClass(className);\r\n        if (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass)) {\r\n            if (Application.exists()) {\r\n                Application application = Application.get();\r\n                if (application.getSecuritySettings().getEnforceMounts()) {\r\n                                        if (!pageClass.equals(application.getHomePage())) {\r\n                                                Url reverseUrl = application.getRootRequestMapper().mapHandler(new RenderPageRequestHandler(new PageProvider(pageClass)));\r\n                        if (!matches(request.cloneWithUrl(reverseUrl))) {\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n                        PageParameters pageParameters = extractPageParameters(request, 3, pageParametersEncoder);\r\n            return new UrlInfo(info, pageClass, pageParameters);\r\n        }\r\n    }\r\n    return null;\r\n}","lc":0.7727272727,"pi":2.043062201,"ma":0.8,"nbd":2.0,"ml":1.25,"d":0.3333333333,"mi":-0.5644820296,"fo":1.1666666667,"r":-0.0263157895,"e":0.7121568899}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5712_145da021","label":3,"code":"private boolean isPageMounted(Class<? extends IRequestablePage> pageClass, Application application) {\r\n    ICompoundRequestMapper applicationMappers = application.getRootRequestMapperAsCompound();\r\n    for (IRequestMapper requestMapper : applicationMappers) {\r\n        if (requestMapper instanceof AbstractBookmarkableMapper && requestMapper != this) {\r\n            AbstractBookmarkableMapper mapper = (AbstractBookmarkableMapper) requestMapper;\r\n            if (mapper.checkPageClass(pageClass)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"private boolean isPageMounted(Class<? extends IRequestablePage> pageClass, Application application) {\r\n    ICompoundRequestMapper applicationMappers = application.getRootRequestMapperAsCompound();\r\n    for (IRequestMapper requestMapper : applicationMappers) {\r\n        if (requestMapper instanceof AbstractBookmarkableMapper && requestMapper != this) {\r\n            AbstractBookmarkableMapper mapper = (AbstractBookmarkableMapper) requestMapper;\r\n            if (mapper.checkPageClass(pageClass)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}","lc":-0.0909090909,"pi":0.9282296651,"ma":0.0,"nbd":0.5,"ml":0.0833333333,"d":-0.0615079365,"mi":0.103875969,"fo":-0.3333333333,"r":0.1052631579,"e":-0.0713703659}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public void removeTableProperty(ByteBuffer login, String tableName, String property) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\r\n    send_removeTableProperty(login, tableName, property);\r\n    recv_removeTableProperty();\r\n}","code_comment":null,"code_no_comment":"public void removeTableProperty(ByteBuffer login, String tableName, String property) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\r\n    send_removeTableProperty(login, tableName, property);\r\n    recv_removeTableProperty();\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7065539112,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Closure","project_version":"145","label":1,"code":"\/**\r\n * @return Whether the Node is a DO or FUNCTION (with or without\r\n * labels).\r\n *\/\r\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\r\n    \/\/ way it isn't a FUNCTION or DO.\r\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\r\n}","code_comment":"\/**\r\n * @return Whether the Node is a DO or FUNCTION (with or without\r\n * labels).\r\n *\/\r\n","code_no_comment":"private boolean isOneExactlyFunctionOrDo(Node n) {\r\n        return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.0674603175,"mi":0.896546864,"fo":-0.3333333333,"r":2.5789473684,"e":-0.1283357249}
{"project_name":"Closure","project_version":"16","label":2,"code":"private void fixTypeNode(Node typeNode) {\r\n    if (typeNode.isString()) {\r\n        String name = typeNode.getString();\r\n        int endIndex = name.indexOf('.');\r\n        if (endIndex == -1) {\r\n            endIndex = name.length();\r\n        }\r\n        String baseName = name.substring(0, endIndex);\r\n        Var aliasVar = aliases.get(baseName);\r\n        if (aliasVar != null) {\r\n            Node aliasedNode = aliasVar.getInitialValue();\r\n            aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));\r\n        }\r\n    }\r\n    for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) {\r\n        fixTypeNode(child);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void fixTypeNode(Node typeNode) {\r\n    if (typeNode.isString()) {\r\n        String name = typeNode.getString();\r\n        int endIndex = name.indexOf('.');\r\n        if (endIndex == -1) {\r\n            endIndex = name.length();\r\n        }\r\n        String baseName = name.substring(0, endIndex);\r\n        Var aliasVar = aliases.get(baseName);\r\n        if (aliasVar != null) {\r\n            Node aliasedNode = aliasVar.getInitialValue();\r\n            aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));\r\n        }\r\n    }\r\n    for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) {\r\n        fixTypeNode(child);\r\n    }\r\n}","lc":0.1818181818,"pi":0.2344497608,"ma":0.2,"nbd":0.0,"ml":0.25,"d":0.375,"mi":-0.2349541931,"fo":0.5833333333,"r":0.0,"e":0.4463707981}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-421_36e70bd7","label":1,"code":"@Override\r\npublic void reset(NodeState newBase) {\r\n    if (this == root) {\r\n        baseState = checkNotNull(newBase);\r\n        writeState = new MutableNodeState(baseState);\r\n        revision++;\r\n    } else {\r\n        throw new IllegalStateException(\"Cannot reset a non-root builder\");\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void reset(NodeState newBase) {\r\n    if (this == root) {\r\n        baseState = checkNotNull(newBase);\r\n        writeState = new MutableNodeState(baseState);\r\n        revision++;\r\n    } else {\r\n        throw new IllegalStateException(\"Cannot reset a non-root builder\");\r\n    }\r\n}","lc":-0.1818181818,"pi":0.1578947368,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.1369047619,"mi":0.2718816068,"fo":-0.4166666667,"r":2.0526315789,"e":-0.1223653349}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public int compareTo(removeConstraint_result other) {\r\n    if (!getClass().equals(other.getClass())) {\r\n        return getClass().getName().compareTo(other.getClass().getName());\r\n    }\r\n    int lastComparison = 0;\r\n    removeConstraint_result typedOther = (removeConstraint_result) other;\r\n    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());\r\n    if (lastComparison != 0) {\r\n        return lastComparison;\r\n    }\r\n    if (isSetOuch1()) {\r\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);\r\n        if (lastComparison != 0) {\r\n            return lastComparison;\r\n        }\r\n    }\r\n    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());\r\n    if (lastComparison != 0) {\r\n        return lastComparison;\r\n    }\r\n    if (isSetOuch2()) {\r\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);\r\n        if (lastComparison != 0) {\r\n            return lastComparison;\r\n        }\r\n    }\r\n    return 0;\r\n}","code_comment":null,"code_no_comment":"public int compareTo(removeConstraint_result other) {\r\n    if (!getClass().equals(other.getClass())) {\r\n        return getClass().getName().compareTo(other.getClass().getName());\r\n    }\r\n    int lastComparison = 0;\r\n    removeConstraint_result typedOther = (removeConstraint_result) other;\r\n    lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());\r\n    if (lastComparison != 0) {\r\n        return lastComparison;\r\n    }\r\n    if (isSetOuch1()) {\r\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);\r\n        if (lastComparison != 0) {\r\n            return lastComparison;\r\n        }\r\n    }\r\n    lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());\r\n    if (lastComparison != 0) {\r\n        return lastComparison;\r\n    }\r\n    if (isSetOuch2()) {\r\n        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);\r\n        if (lastComparison != 0) {\r\n            return lastComparison;\r\n        }\r\n    }\r\n    return 0;\r\n}","lc":0.6363636364,"pi":-0.043062201,"ma":0.8,"nbd":0.0,"ml":0.5833333333,"d":0.2996031746,"mi":-0.4556730092,"fo":1.1666666667,"r":-0.0263157895,"e":0.3821533745}
{"project_name":"Chart","project_version":"16","label":2,"code":"\/**\r\n * Sets the categories for the dataset.\r\n *\r\n * @param categoryKeys  an array of objects representing the categories in\r\n *                      the dataset.\r\n *\r\n * @see #getRowKeys()\r\n * @see #setSeriesKeys(Comparable[])\r\n *\/\r\npublic void setCategoryKeys(Comparable[] categoryKeys) {\r\n    if (categoryKeys == null) {\r\n        throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\r\n    }\r\n    if (categoryKeys.length != this.startData[0].length) {\r\n        throw new IllegalArgumentException(\"The number of categories does not match the data.\");\r\n    }\r\n    for (int i = 0; i < categoryKeys.length; i++) {\r\n        if (categoryKeys[i] == null) {\r\n            throw new IllegalArgumentException(\"DefaultIntervalCategoryDataset.setCategoryKeys(): \" + \"null category not permitted.\");\r\n        }\r\n    }\r\n    this.categoryKeys = categoryKeys;\r\n    fireDatasetChanged();\r\n}","code_comment":"\/**\r\n * Sets the categories for the dataset.\r\n *\r\n * @param categoryKeys  an array of objects representing the categories in\r\n *                      the dataset.\r\n *\r\n * @see #getRowKeys()\r\n * @see #setSeriesKeys(Comparable[])\r\n *\/\r\n","code_no_comment":"public void setCategoryKeys(Comparable[] categoryKeys) {\r\n    if (categoryKeys == null) {\r\n        throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\r\n    }\r\n    if (categoryKeys.length != this.startData[0].length) {\r\n        throw new IllegalArgumentException(\"The number of categories does not match the data.\");\r\n    }\r\n    for (int i = 0; i < categoryKeys.length; i++) {\r\n        if (categoryKeys[i] == null) {\r\n            throw new IllegalArgumentException(\"DefaultIntervalCategoryDataset.setCategoryKeys(): \" + \"null category not permitted.\");\r\n        }\r\n    }\r\n    this.categoryKeys = categoryKeys;\r\n    fireDatasetChanged();\r\n}","lc":0.0454545455,"pi":0.04784689,"ma":0.8,"nbd":0.0,"ml":0.25,"d":0.8253968254,"mi":-0.0610288936,"fo":-0.4166666667,"r":0.0263157895,"e":0.2989090783}
{"project_name":"Closure","project_version":"110","label":2,"code":"public Node getChildBefore(Node child) {\r\n    if (child == first) {\r\n        return null;\r\n    }\r\n    Node n = first;\r\n    while (n.next != child) {\r\n        n = n.next;\r\n        if (n == null) {\r\n            throw new RuntimeException(\"node is not a child\");\r\n        }\r\n    }\r\n    return n;\r\n}","code_comment":null,"code_no_comment":"public Node getChildBefore(Node child) {\r\n    if (child == first) {\r\n        return null;\r\n    }\r\n    Node n = first;\r\n    while (n.next != child) {\r\n        n = n.next;\r\n        if (n == null) {\r\n            throw new RuntimeException(\"node is not a child\");\r\n        }\r\n    }\r\n    return n;\r\n}","lc":-0.0454545455,"pi":0.1435406699,"ma":0.2,"nbd":0.0,"ml":0.1666666667,"d":0.0714285714,"mi":0.0990838619,"fo":-0.5,"r":1.2631578947,"e":-0.0614535249}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2433_7fca85bf","label":1,"code":"@Nonnull\r\nstatic Map<Revision, String> create(@Nonnull final NodeDocument doc, @Nonnull final String property) {\r\n    final SortedMap<Revision, String> map = doc.getLocalMap(property);\r\n    if (doc.getPreviousRanges().isEmpty()) {\r\n        return map;\r\n    }\r\n    final Set<Map.Entry<Revision, String>> entrySet = new AbstractSet<Map.Entry<Revision, String>>() {\r\n\r\n        @Override\r\n        @Nonnull\r\n        public Iterator<Map.Entry<Revision, String>> iterator() {\r\n            final Comparator<? super Revision> c = map.comparator();\r\n            final Iterator<NodeDocument> docs;\r\n            if (map.isEmpty()) {\r\n                docs = doc.getPreviousDocs(property, null).iterator();\r\n            } else {\r\n                docs = Iterators.concat(Iterators.singletonIterator(doc), doc.getPreviousDocs(property, null).iterator());\r\n            }\r\n            return new MergeSortedIterators<Map.Entry<Revision, String>>(new Comparator<Map.Entry<Revision, String>>() {\r\n\r\n                @Override\r\n                public int compare(Map.Entry<Revision, String> o1, Map.Entry<Revision, String> o2) {\r\n                    return c.compare(o1.getKey(), o2.getKey());\r\n                }\r\n            }) {\r\n\r\n                @Override\r\n                public Iterator<Map.Entry<Revision, String>> nextIterator() {\r\n                    NodeDocument d = docs.hasNext() ? docs.next() : null;\r\n                    if (d == null) {\r\n                        return null;\r\n                    }\r\n                    Map<Revision, String> values;\r\n                    if (Objects.equal(d.getId(), doc.getId())) {\r\n                        \/\/ return local map for main document\r\n                        values = d.getLocalMap(property);\r\n                    } else {\r\n                        values = d.getValueMap(property);\r\n                    }\r\n                    return values.entrySet().iterator();\r\n                }\r\n\r\n                @Override\r\n                public String description() {\r\n                    return \"Revisioned values for property \" + doc.getId() + \"\/\" + property + \":\";\r\n                }\r\n            };\r\n        }\r\n\r\n        @Override\r\n        public int size() {\r\n            int size = map.size();\r\n            for (NodeDocument prev : doc.getPreviousDocs(property, null)) {\r\n                size += prev.getValueMap(property).size();\r\n            }\r\n            return size;\r\n        }\r\n    };\r\n    return new AbstractMap<Revision, String>() {\r\n\r\n        private final Map<Revision, String> map = doc.getLocalMap(property);\r\n\r\n        @Override\r\n        @Nonnull\r\n        public Set<Entry<Revision, String>> entrySet() {\r\n            return entrySet;\r\n        }\r\n\r\n        @Override\r\n        public String get(Object key) {\r\n            Revision r = (Revision) key;\r\n            \/\/ first check values map of this document\r\n            if (map.containsKey(r)) {\r\n                return map.get(r);\r\n            }\r\n            for (NodeDocument prev : doc.getPreviousDocs(property, r)) {\r\n                String value = prev.getValueMap(property).get(r);\r\n                if (value != null) {\r\n                    return value;\r\n                }\r\n            }\r\n            \/\/ not found or null\r\n            return null;\r\n        }\r\n\r\n        @Override\r\n        public boolean containsKey(Object key) {\r\n            \/\/ check local map first\r\n            if (map.containsKey(key)) {\r\n                return true;\r\n            }\r\n            Revision r = (Revision) key;\r\n            for (NodeDocument prev : doc.getPreviousDocs(property, r)) {\r\n                if (prev.getValueMap(property).containsKey(key)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\nstatic Map<Revision, String> create(@Nonnull final NodeDocument doc, @Nonnull final String property) {\r\n    final SortedMap<Revision, String> map = doc.getLocalMap(property);\r\n    if (doc.getPreviousRanges().isEmpty()) {\r\n        return map;\r\n    }\r\n    final Set<Map.Entry<Revision, String>> entrySet = new AbstractSet<Map.Entry<Revision, String>>() {\r\n\r\n        @Override\r\n        @Nonnull\r\n        public Iterator<Map.Entry<Revision, String>> iterator() {\r\n            final Comparator<? super Revision> c = map.comparator();\r\n            final Iterator<NodeDocument> docs;\r\n            if (map.isEmpty()) {\r\n                docs = doc.getPreviousDocs(property, null).iterator();\r\n            } else {\r\n                docs = Iterators.concat(Iterators.singletonIterator(doc), doc.getPreviousDocs(property, null).iterator());\r\n            }\r\n            return new MergeSortedIterators<Map.Entry<Revision, String>>(new Comparator<Map.Entry<Revision, String>>() {\r\n\r\n                @Override\r\n                public int compare(Map.Entry<Revision, String> o1, Map.Entry<Revision, String> o2) {\r\n                    return c.compare(o1.getKey(), o2.getKey());\r\n                }\r\n            }) {\r\n\r\n                @Override\r\n                public Iterator<Map.Entry<Revision, String>> nextIterator() {\r\n                    NodeDocument d = docs.hasNext() ? docs.next() : null;\r\n                    if (d == null) {\r\n                        return null;\r\n                    }\r\n                    Map<Revision, String> values;\r\n                    if (Objects.equal(d.getId(), doc.getId())) {\r\n                                                values = d.getLocalMap(property);\r\n                    } else {\r\n                        values = d.getValueMap(property);\r\n                    }\r\n                    return values.entrySet().iterator();\r\n                }\r\n\r\n                @Override\r\n                public String description() {\r\n                    return \"Revisioned values for property \" + doc.getId() + \"\/\" + property + \":\";\r\n                }\r\n            };\r\n        }\r\n\r\n        @Override\r\n        public int size() {\r\n            int size = map.size();\r\n            for (NodeDocument prev : doc.getPreviousDocs(property, null)) {\r\n                size += prev.getValueMap(property).size();\r\n            }\r\n            return size;\r\n        }\r\n    };\r\n    return new AbstractMap<Revision, String>() {\r\n\r\n        private final Map<Revision, String> map = doc.getLocalMap(property);\r\n\r\n        @Override\r\n        @Nonnull\r\n        public Set<Entry<Revision, String>> entrySet() {\r\n            return entrySet;\r\n        }\r\n\r\n        @Override\r\n        public String get(Object key) {\r\n            Revision r = (Revision) key;\r\n                        if (map.containsKey(r)) {\r\n                return map.get(r);\r\n            }\r\n            for (NodeDocument prev : doc.getPreviousDocs(property, r)) {\r\n                String value = prev.getValueMap(property).get(r);\r\n                if (value != null) {\r\n                    return value;\r\n                }\r\n            }\r\n                        return null;\r\n        }\r\n\r\n        @Override\r\n        public boolean containsKey(Object key) {\r\n                        if (map.containsKey(key)) {\r\n                return true;\r\n            }\r\n            Revision r = (Revision) key;\r\n            for (NodeDocument prev : doc.getPreviousDocs(property, r)) {\r\n                if (prev.getValueMap(property).containsKey(key)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    };\r\n}","lc":3.3636363636,"pi":1.2057416268,"ma":1.8,"nbd":0.5,"ml":1.4166666667,"d":1.2222222222,"mi":-1.2249471459,"fo":2.6666666667,"r":-0.0263157895,"e":5.4360032964}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2899_31aea2ad","label":0,"code":"public synchronized void open(String address) throws IOException {\r\n    String filename = UUID.randomUUID().toString();\r\n    String logger = StringUtil.join(Arrays.asList(address.split(\":\")), \"+\");\r\n    log.debug(\"DfsLogger.open() begin\");\r\n    VolumeManager fs = conf.getFileSystem();\r\n    logPath = fs.choose(ServerConstants.getWalDirs()) + \"\/\" + logger + \"\/\" + filename;\r\n    try {\r\n        short replication = (short) conf.getConfiguration().getCount(Property.TSERV_WAL_REPLICATION);\r\n        if (replication == 0)\r\n            replication = fs.getDefaultReplication(new Path(logPath));\r\n        long blockSize = conf.getConfiguration().getMemoryInBytes(Property.TSERV_WAL_BLOCKSIZE);\r\n        if (blockSize == 0)\r\n            blockSize = (long) (conf.getConfiguration().getMemoryInBytes(Property.TSERV_WALOG_MAX_SIZE) * 1.1);\r\n        if (conf.getConfiguration().getBoolean(Property.TSERV_WAL_SYNC))\r\n            logFile = fs.createSyncable(new Path(logPath), 0, replication, blockSize);\r\n        else\r\n            logFile = fs.create(new Path(logPath), true, 0, replication, blockSize);\r\n        String syncMethod = conf.getConfiguration().get(Property.TSERV_WAL_SYNC_METHOD);\r\n        try {\r\n            \/\/ hsync: send data to datanodes and sync the data to disk\r\n            sync = logFile.getClass().getMethod(syncMethod);\r\n        } catch (Exception ex) {\r\n            log.warn(\"Could not find configured \" + syncMethod + \" method, trying to fall back to old Hadoop sync method\", ex);\r\n            try {\r\n                \/\/ sync: send data to datanodes\r\n                sync = logFile.getClass().getMethod(\"sync\");\r\n            } catch (Exception e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n        \/\/ Initialize the crypto operations.\r\n        org.apache.accumulo.core.security.crypto.CryptoModule cryptoModule = org.apache.accumulo.core.security.crypto.CryptoModuleFactory.getCryptoModule(conf.getConfiguration().get(Property.CRYPTO_MODULE_CLASS));\r\n        \/\/ Initialize the log file with a header and the crypto params used to set up this log file.\r\n        logFile.write(LOG_FILE_HEADER_V3.getBytes(Constants.UTF8));\r\n        CryptoModuleParameters params = CryptoModuleFactory.createParamsObjectFromAccumuloConfiguration(conf.getConfiguration());\r\n        NoFlushOutputStream nfos = new NoFlushOutputStream(logFile);\r\n        params.setPlaintextOutputStream(nfos);\r\n        \/\/ In order to bootstrap the reading of this file later, we have to record the CryptoModule that was used to encipher it here,\r\n        \/\/ so that that crypto module can re-read its own parameters.\r\n        logFile.writeUTF(conf.getConfiguration().get(Property.CRYPTO_MODULE_CLASS));\r\n        params = cryptoModule.getEncryptingOutputStream(params);\r\n        OutputStream encipheringOutputStream = params.getEncryptedOutputStream();\r\n        \/\/ another data OutputStream.\r\n        if (encipheringOutputStream == nfos) {\r\n            log.debug(\"No enciphering, using raw output stream\");\r\n            encryptingLogFile = nfos;\r\n        } else {\r\n            log.debug(\"Enciphering found, wrapping in DataOutputStream\");\r\n            encryptingLogFile = new DataOutputStream(encipheringOutputStream);\r\n        }\r\n        LogFileKey key = new LogFileKey();\r\n        key.event = OPEN;\r\n        key.tserverSession = filename;\r\n        key.filename = filename;\r\n        write(key, EMPTY);\r\n        sync.invoke(logFile);\r\n        log.debug(\"Got new write-ahead log: \" + this);\r\n    } catch (Exception ex) {\r\n        if (logFile != null)\r\n            logFile.close();\r\n        logFile = null;\r\n        encryptingLogFile = null;\r\n        throw new IOException(ex);\r\n    }\r\n    syncThread = new Daemon(new LoggingRunnable(log, new LogSyncingTask()));\r\n    syncThread.setName(\"Accumulo WALog thread \" + toString());\r\n    syncThread.start();\r\n}","code_comment":null,"code_no_comment":"public synchronized void open(String address) throws IOException {\r\n    String filename = UUID.randomUUID().toString();\r\n    String logger = StringUtil.join(Arrays.asList(address.split(\":\")), \"+\");\r\n    log.debug(\"DfsLogger.open() begin\");\r\n    VolumeManager fs = conf.getFileSystem();\r\n    logPath = fs.choose(ServerConstants.getWalDirs()) + \"\/\" + logger + \"\/\" + filename;\r\n    try {\r\n        short replication = (short) conf.getConfiguration().getCount(Property.TSERV_WAL_REPLICATION);\r\n        if (replication == 0)\r\n            replication = fs.getDefaultReplication(new Path(logPath));\r\n        long blockSize = conf.getConfiguration().getMemoryInBytes(Property.TSERV_WAL_BLOCKSIZE);\r\n        if (blockSize == 0)\r\n            blockSize = (long) (conf.getConfiguration().getMemoryInBytes(Property.TSERV_WALOG_MAX_SIZE) * 1.1);\r\n        if (conf.getConfiguration().getBoolean(Property.TSERV_WAL_SYNC))\r\n            logFile = fs.createSyncable(new Path(logPath), 0, replication, blockSize);\r\n        else\r\n            logFile = fs.create(new Path(logPath), true, 0, replication, blockSize);\r\n        String syncMethod = conf.getConfiguration().get(Property.TSERV_WAL_SYNC_METHOD);\r\n        try {\r\n                        sync = logFile.getClass().getMethod(syncMethod);\r\n        } catch (Exception ex) {\r\n            log.warn(\"Could not find configured \" + syncMethod + \" method, trying to fall back to old Hadoop sync method\", ex);\r\n            try {\r\n                                sync = logFile.getClass().getMethod(\"sync\");\r\n            } catch (Exception e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n                org.apache.accumulo.core.security.crypto.CryptoModule cryptoModule = org.apache.accumulo.core.security.crypto.CryptoModuleFactory.getCryptoModule(conf.getConfiguration().get(Property.CRYPTO_MODULE_CLASS));\r\n                logFile.write(LOG_FILE_HEADER_V3.getBytes(Constants.UTF8));\r\n        CryptoModuleParameters params = CryptoModuleFactory.createParamsObjectFromAccumuloConfiguration(conf.getConfiguration());\r\n        NoFlushOutputStream nfos = new NoFlushOutputStream(logFile);\r\n        params.setPlaintextOutputStream(nfos);\r\n                        logFile.writeUTF(conf.getConfiguration().get(Property.CRYPTO_MODULE_CLASS));\r\n        params = cryptoModule.getEncryptingOutputStream(params);\r\n        OutputStream encipheringOutputStream = params.getEncryptedOutputStream();\r\n                if (encipheringOutputStream == nfos) {\r\n            log.debug(\"No enciphering, using raw output stream\");\r\n            encryptingLogFile = nfos;\r\n        } else {\r\n            log.debug(\"Enciphering found, wrapping in DataOutputStream\");\r\n            encryptingLogFile = new DataOutputStream(encipheringOutputStream);\r\n        }\r\n        LogFileKey key = new LogFileKey();\r\n        key.event = OPEN;\r\n        key.tserverSession = filename;\r\n        key.filename = filename;\r\n        write(key, EMPTY);\r\n        sync.invoke(logFile);\r\n        log.debug(\"Got new write-ahead log: \" + this);\r\n    } catch (Exception ex) {\r\n        if (logFile != null)\r\n            logFile.close();\r\n        logFile = null;\r\n        encryptingLogFile = null;\r\n        throw new IOException(ex);\r\n    }\r\n    syncThread = new Daemon(new LoggingRunnable(log, new LogSyncingTask()));\r\n    syncThread.setName(\"Accumulo WALog thread \" + toString());\r\n    syncThread.start();\r\n}","lc":2.1363636364,"pi":0.1339712919,"ma":1.4,"nbd":0.5,"ml":0.5,"d":0.4623015873,"mi":-1.0693446089,"fo":3.5833333333,"r":-0.0263157895,"e":3.2880275237}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3709_4c37e773","label":3,"code":"\/\/ Properties\r\n\/\/ -----------------------------------------------------------------------\r\npublic String getUri() {\r\n    return uri;\r\n}","code_comment":null,"code_no_comment":"public String getUri() {\r\n    return uri;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1646229739,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5916_def03add","label":1,"code":"\/**\r\n *  @see org.apache.wicket.model.IModel#getObject()\r\n *\/\r\n@Override\r\npublic final T getObject() {\r\n    if (!attached) {\r\n        transientModelObject = load();\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"loaded transient object \" + transientModelObject + \" for \" + this + \", requestCycle \" + RequestCycle.get());\r\n        }\r\n        attached = true;\r\n        onAttach();\r\n    }\r\n    return transientModelObject;\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.model.IModel#getObject()\r\n *\/\r\n","code_no_comment":"@Override\r\npublic final T getObject() {\r\n    if (!attached) {\r\n        transientModelObject = load();\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"loaded transient object \" + transientModelObject + \" for \" + this + \", requestCycle \" + RequestCycle.get());\r\n        }\r\n        attached = true;\r\n        onAttach();\r\n    }\r\n    return transientModelObject;\r\n}","lc":-0.0909090909,"pi":0.3732057416,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.119047619,"mi":0.1371388302,"fo":-0.0833333333,"r":1.1842105263,"e":-0.1012591991}
{"project_name":"Closure","project_version":"137","label":2,"code":"@Override\r\npublic void addDeclaredName(String name) {\r\n    if (!declarations.containsKey(name)) {\r\n        declarations.put(name, getUniqueName(name));\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void addDeclaredName(String name) {\r\n    if (!declarations.containsKey(name)) {\r\n        declarations.put(name, getUniqueName(name));\r\n    }\r\n}","lc":-0.3636363636,"pi":-0.004784689,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.5836504581,"fo":-0.25,"r":0.3421052632,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1705_5308ac83","label":1,"code":"public String getInetAdress() {\r\n    return this.inetAddress.toString();\r\n}","code_comment":null,"code_no_comment":"public String getInetAdress() {\r\n    return this.inetAddress.toString();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.4166666667,"r":1.1052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2430_be3a9114","label":1,"code":"@Override\r\npublic boolean propertyDeleted(PropertyState before) {\r\n    if (!loader.isRunning()) {\r\n        return false;\r\n    }\r\n    builder.removeProperty(before.getName());\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean propertyDeleted(PropertyState before) {\r\n    if (!loader.isRunning()) {\r\n        return false;\r\n    }\r\n    builder.removeProperty(before.getName());\r\n    return true;\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.4365045807,"fo":-0.25,"r":0.2105263158,"e":-0.1627934049}
{"project_name":"Closure","project_version":"163","label":1,"code":"\/**\r\n * Move methods deeper in the module graph when possible.\r\n *\/\r\nprivate void moveMethods(Collection<NameInfo> allNameInfo) {\r\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\r\n    for (NameInfo nameInfo : allNameInfo) {\r\n        if (!nameInfo.isReferenced()) {\r\n            \/\/ deepestCommonModuleRef is null.\r\n            continue;\r\n        }\r\n        if (nameInfo.readsClosureVariables()) {\r\n            continue;\r\n        }\r\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\r\n        if (deepestCommonModuleRef == null) {\r\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\r\n            continue;\r\n        }\r\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\r\n        while (declarations.hasNext()) {\r\n            Symbol symbol = declarations.next();\r\n            if (!(symbol instanceof Property)) {\r\n                continue;\r\n            }\r\n            Property prop = (Property) symbol;\r\n            \/\/ We should only move a property across modules if:\r\n            \/\/ 1) We can move it deeper in the module graph, and\r\n            \/\/ 2) it's a function, and\r\n            \/\/ 3) it is not a get or a set, and\r\n            \/\/ 4) the class is available in the global scope.\r\n            \/\/ \r\n            \/\/ #1 should be obvious. #2 is more subtle. It's possible\r\n            \/\/ to copy off of a prototype, as in the code:\r\n            \/\/ for (var k in Foo.prototype) {\r\n            \/\/ doSomethingWith(Foo.prototype[k]);\r\n            \/\/ }\r\n            \/\/ This is a common way to implement pseudo-multiple inheritance in JS.\r\n            \/\/ \r\n            \/\/ So if we move a prototype method into a deeper module, we must\r\n            \/\/ replace it with a stub function so that it preserves its original\r\n            \/\/ behavior.\r\n            Node value = prop.getValue();\r\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\r\n                Node valueParent = value.getParent();\r\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\r\n                    \/\/ of a GET instead of the function itself.\r\n                    continue;\r\n                }\r\n                Node proto = prop.getPrototype();\r\n                int stubId = idGenerator.newId();\r\n                \/\/ example: JSCompiler_stubMethod(id);\r\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\r\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\r\n                \/\/ stub out the method in the original module\r\n                \/\/ A.prototype.b = JSCompiler_stubMethod(id);\r\n                valueParent.replaceChild(value, stubCall);\r\n                \/\/ unstub the function body in the deeper module\r\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\r\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\r\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\r\n                unstubParent.addChildToFront(\/\/ A.prototype.b = JSCompiler_unstubMethod(id, body);\r\n                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\r\n                compiler.reportCodeChange();\r\n            }\r\n        }\r\n    }\r\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\r\n        \/\/ Declare stub functions in the top-most module.\r\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\r\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\r\n    }\r\n}","code_comment":"\/**\r\n * Move methods deeper in the module graph when possible.\r\n *\/\r\n","code_no_comment":"private void moveMethods(Collection<NameInfo> allNameInfo) {\r\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\r\n    for (NameInfo nameInfo : allNameInfo) {\r\n        if (!nameInfo.isReferenced()) {\r\n                        continue;\r\n        }\r\n        if (nameInfo.readsClosureVariables()) {\r\n            continue;\r\n        }\r\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\r\n        if (deepestCommonModuleRef == null) {\r\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\r\n            continue;\r\n        }\r\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\r\n        while (declarations.hasNext()) {\r\n            Symbol symbol = declarations.next();\r\n            if (!(symbol instanceof Property)) {\r\n                continue;\r\n            }\r\n            Property prop = (Property) symbol;\r\n                                                                                                                                                                                                            Node value = prop.getValue();\r\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\r\n                Node valueParent = value.getParent();\r\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\r\n                                        continue;\r\n                }\r\n                Node proto = prop.getPrototype();\r\n                int stubId = idGenerator.newId();\r\n                                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\r\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\r\n                                                valueParent.replaceChild(value, stubCall);\r\n                                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\r\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\r\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\r\n                unstubParent.addChildToFront(                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\r\n                compiler.reportCodeChange();\r\n            }\r\n        }\r\n    }\r\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\r\n                Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\r\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\r\n    }\r\n}","lc":1.4545454545,"pi":0.8660287081,"ma":2.2,"nbd":1.0,"ml":1.5,"d":0.4444444444,"mi":-0.8849894292,"fo":3.0833333333,"r":-0.0263157895,"e":1.7785054431}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-414_ebf22df0","label":1,"code":"\/**\r\n * Returns top key. Can be called 0 or more times without affecting behavior of next() or hasTop().\r\n *\r\n * @return <tt>K<\/tt>\r\n * @exception IllegalStateException\r\n *              if called before seek.\r\n * @exception NoSuchElementException\r\n *              if top element doesn't exist.\r\n *\/\r\nK getTopKey();","code_comment":"\/**\r\n * Returns top key. Can be called 0 or more times without affecting behavior of next() or hasTop().\r\n *\r\n * @return <tt>K<\/tt>\r\n * @exception IllegalStateException\r\n *              if called before seek.\r\n * @exception NoSuchElementException\r\n *              if top element doesn't exist.\r\n *\/\r\n","code_no_comment":"K getTopKey();","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.7424947146,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3342_8e3e2f8f","label":1,"code":"@Override\r\npublic void onCompletedCheckpoint(CompletedCheckpoint checkpoint) {\r\n    \/\/ Sanity check\r\n    if (taskParallelism.isEmpty()) {\r\n        return;\r\n    }\r\n    synchronized (statsLock) {\r\n        int overallStateSize = 0;\r\n        \/\/ Operator stats\r\n        Map<JobVertexID, long[][]> statsForSubTasks = new HashMap<>();\r\n        for (StateForTask state : checkpoint.getStates()) {\r\n            \/\/ Job-level checkpoint size is sum of all state sizes\r\n            overallStateSize += state.getStateSize();\r\n            \/\/ Subtask stats\r\n            JobVertexID opId = state.getOperatorId();\r\n            long[][] statsPerSubtask = statsForSubTasks.get(opId);\r\n            if (statsPerSubtask == null) {\r\n                int parallelism = taskParallelism.get(opId);\r\n                statsPerSubtask = new long[parallelism][2];\r\n                statsForSubTasks.put(opId, statsPerSubtask);\r\n            }\r\n            int subTaskIndex = state.getSubtask();\r\n            if (subTaskIndex < statsPerSubtask.length) {\r\n                statsPerSubtask[subTaskIndex][0] = state.getDuration();\r\n                statsPerSubtask[subTaskIndex][1] = state.getStateSize();\r\n            }\r\n        }\r\n        \/\/ It is possible that completed checkpoints are added out of\r\n        \/\/ order. Make sure that in this case the last completed\r\n        \/\/ checkpoint is not updated.\r\n        boolean isInOrder = latestCompletedCheckpoint != null && checkpoint.getCheckpointID() > latestCompletedCheckpoint.getCheckpointID();\r\n        \/\/ Clear this in each case\r\n        lastJobStats = null;\r\n        if (overallCount == 0 || isInOrder) {\r\n            latestCompletedCheckpoint = checkpoint;\r\n            \/\/ Clear cached stats\r\n            operatorStatsCache.clear();\r\n            \/\/ Update the stats per sub task\r\n            subTaskStats = statsForSubTasks;\r\n        }\r\n        long checkpointId = checkpoint.getCheckpointID();\r\n        long checkpointTriggerTimestamp = checkpoint.getTimestamp();\r\n        long checkpointDuration = checkpoint.getDuration();\r\n        overallCount++;\r\n        \/\/ Duration stats\r\n        if (checkpointDuration > overallMaxDuration) {\r\n            overallMaxDuration = checkpointDuration;\r\n        }\r\n        if (checkpointDuration < overallMinDuration) {\r\n            overallMinDuration = checkpointDuration;\r\n        }\r\n        overallTotalDuration += checkpointDuration;\r\n        \/\/ State size stats\r\n        if (overallStateSize < overallMinStateSize) {\r\n            overallMinStateSize = overallStateSize;\r\n        }\r\n        if (overallStateSize > overallMaxStateSize) {\r\n            overallMaxStateSize = overallStateSize;\r\n        }\r\n        this.overallTotalStateSize += overallStateSize;\r\n        \/\/ Recent history\r\n        if (historySize > 0) {\r\n            CheckpointStats stats = new CheckpointStats(checkpointId, checkpointTriggerTimestamp, checkpointDuration, overallStateSize);\r\n            if (isInOrder) {\r\n                if (history.size() == historySize) {\r\n                    history.remove(0);\r\n                }\r\n                history.add(stats);\r\n            } else {\r\n                final int size = history.size();\r\n                \/\/ Only remove it if it the new checkpoint is not too old\r\n                if (size == historySize) {\r\n                    if (checkpointId > history.get(0).getCheckpointId()) {\r\n                        history.remove(0);\r\n                    }\r\n                }\r\n                int pos = 0;\r\n                \/\/ Find position\r\n                for (int i = 0; i < size; i++) {\r\n                    pos = i;\r\n                    if (checkpointId < history.get(i).getCheckpointId()) {\r\n                        break;\r\n                    }\r\n                }\r\n                history.add(pos, stats);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void onCompletedCheckpoint(CompletedCheckpoint checkpoint) {\r\n        if (taskParallelism.isEmpty()) {\r\n        return;\r\n    }\r\n    synchronized (statsLock) {\r\n        int overallStateSize = 0;\r\n                Map<JobVertexID, long[][]> statsForSubTasks = new HashMap<>();\r\n        for (StateForTask state : checkpoint.getStates()) {\r\n                        overallStateSize += state.getStateSize();\r\n                        JobVertexID opId = state.getOperatorId();\r\n            long[][] statsPerSubtask = statsForSubTasks.get(opId);\r\n            if (statsPerSubtask == null) {\r\n                int parallelism = taskParallelism.get(opId);\r\n                statsPerSubtask = new long[parallelism][2];\r\n                statsForSubTasks.put(opId, statsPerSubtask);\r\n            }\r\n            int subTaskIndex = state.getSubtask();\r\n            if (subTaskIndex < statsPerSubtask.length) {\r\n                statsPerSubtask[subTaskIndex][0] = state.getDuration();\r\n                statsPerSubtask[subTaskIndex][1] = state.getStateSize();\r\n            }\r\n        }\r\n                                boolean isInOrder = latestCompletedCheckpoint != null && checkpoint.getCheckpointID() > latestCompletedCheckpoint.getCheckpointID();\r\n                lastJobStats = null;\r\n        if (overallCount == 0 || isInOrder) {\r\n            latestCompletedCheckpoint = checkpoint;\r\n                        operatorStatsCache.clear();\r\n                        subTaskStats = statsForSubTasks;\r\n        }\r\n        long checkpointId = checkpoint.getCheckpointID();\r\n        long checkpointTriggerTimestamp = checkpoint.getTimestamp();\r\n        long checkpointDuration = checkpoint.getDuration();\r\n        overallCount++;\r\n                if (checkpointDuration > overallMaxDuration) {\r\n            overallMaxDuration = checkpointDuration;\r\n        }\r\n        if (checkpointDuration < overallMinDuration) {\r\n            overallMinDuration = checkpointDuration;\r\n        }\r\n        overallTotalDuration += checkpointDuration;\r\n                if (overallStateSize < overallMinStateSize) {\r\n            overallMinStateSize = overallStateSize;\r\n        }\r\n        if (overallStateSize > overallMaxStateSize) {\r\n            overallMaxStateSize = overallStateSize;\r\n        }\r\n        this.overallTotalStateSize += overallStateSize;\r\n                if (historySize > 0) {\r\n            CheckpointStats stats = new CheckpointStats(checkpointId, checkpointTriggerTimestamp, checkpointDuration, overallStateSize);\r\n            if (isInOrder) {\r\n                if (history.size() == historySize) {\r\n                    history.remove(0);\r\n                }\r\n                history.add(stats);\r\n            } else {\r\n                final int size = history.size();\r\n                                if (size == historySize) {\r\n                    if (checkpointId > history.get(0).getCheckpointId()) {\r\n                        history.remove(0);\r\n                    }\r\n                }\r\n                int pos = 0;\r\n                                for (int i = 0; i < size; i++) {\r\n                    pos = i;\r\n                    if (checkpointId < history.get(i).getCheckpointId()) {\r\n                        break;\r\n                    }\r\n                }\r\n                history.add(pos, stats);\r\n            }\r\n        }\r\n    }\r\n}","lc":2.7272727273,"pi":1.04784689,"ma":2.8,"nbd":1.5,"ml":2.5,"d":1.7341269841,"mi":-1.148273432,"fo":1.6666666667,"r":-0.0263157895,"e":5.8627732347}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-102_7f391872","label":0,"code":"\/**\r\n * Returns the priority value based on the Facility and Log Level.\r\n * @param facility The Facility.\r\n * @param level The Level.\r\n * @return The integer value of the priority.\r\n *\/\r\npublic static int getPriority(Facility facility, Level level) {\r\n    return facility.getCode() << 3 + Severity.getSeverity(level).getCode();\r\n}","code_comment":"\/**\r\n * Returns the priority value based on the Facility and Log Level.\r\n * @param facility The Facility.\r\n * @param level The Level.\r\n * @return The integer value of the priority.\r\n *\/\r\n","code_no_comment":"public static int getPriority(Facility facility, Level level) {\r\n    return facility.getCode() << 3 + Severity.getSeverity(level).getCode();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.1071428571,"mi":0.8852713178,"fo":-0.25,"r":2.4210526316,"e":-0.1305625191}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-640_98556fed","label":1,"code":"\/**\r\n * Returns the next pseudorandom, uniformly distributed {@code long}\r\n * value from this random number generator's sequence.  All\r\n * 2<font size=\"-1\"><sup>64<\/sup><\/font> possible {@code long} values\r\n * should be produced with (approximately) equal probability.\r\n * <p>\r\n * The default implementation returns\r\n * <pre>\r\n * <code>(long) (nextDouble() * Long.MAX_VALUE)<\/code>\r\n * <\/pre><\/p>\r\n *\r\n * @return  the next pseudorandom, uniformly distributed {@code long}\r\n *value from this random number generator's sequence\r\n *\/\r\npublic long nextLong() {\r\n    return (long) (nextDouble() * Long.MAX_VALUE);\r\n}","code_comment":"\/**\r\n * Returns the next pseudorandom, uniformly distributed {@code long}\r\n * value from this random number generator's sequence.  All\r\n * 2<font size=\"-1\"><sup>64<\/sup><\/font> possible {@code long} values\r\n * should be produced with (approximately) equal probability.\r\n * <p>\r\n * The default implementation returns\r\n * <pre>\r\n * <code>(long) (nextDouble() * Long.MAX_VALUE)<\/code>\r\n * <\/pre><\/p>\r\n *\r\n * @return  the next pseudorandom, uniformly distributed {@code long}\r\n *value from this random number generator's sequence\r\n *\/\r\n","code_no_comment":"public long nextLong() {\r\n    return (long) (nextDouble() * Long.MAX_VALUE);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.067653277,"fo":-0.4166666667,"r":2.0526315789,"e":-0.1627934049}
{"project_name":"JxPath","project_version":"7","label":1,"code":"public Object computeValue(EvalContext context) {\r\n    double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\r\n    double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\r\n    return l < r ? Boolean.TRUE : Boolean.FALSE;\r\n}","code_comment":null,"code_no_comment":"public Object computeValue(EvalContext context) {\r\n    double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\r\n    double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\r\n    return l < r ? Boolean.TRUE : Boolean.FALSE;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.4,"nbd":-1.0,"ml":-0.1666666667,"d":-0.0337301587,"mi":0.5348837209,"fo":-0.1666666667,"r":0.1315789474,"e":-0.0748511725}
{"project_name":"JxPath","project_version":"13","label":1,"code":"public NodePointer createAttribute(JXPathContext context, QName name) {\r\n    if (!(node instanceof Element)) {\r\n        return super.createAttribute(context, name);\r\n    }\r\n    Element element = (Element) node;\r\n    String prefix = name.getPrefix();\r\n    if (prefix != null) {\r\n        String ns = getNamespaceURI(prefix);\r\n        if (ns == null) {\r\n            throw new JXPathException(\"Unknown namespace prefix: \" + prefix);\r\n        }\r\n        element.setAttributeNS(ns, name.toString(), \"\");\r\n    } else {\r\n        if (!element.hasAttribute(name.getName())) {\r\n            element.setAttribute(name.getName(), \"\");\r\n        }\r\n    }\r\n    NodeIterator it = attributeIterator(name);\r\n    it.setPosition(1);\r\n    return it.getNodePointer();\r\n}","code_comment":null,"code_no_comment":"public NodePointer createAttribute(JXPathContext context, QName name) {\r\n    if (!(node instanceof Element)) {\r\n        return super.createAttribute(context, name);\r\n    }\r\n    Element element = (Element) node;\r\n    String prefix = name.getPrefix();\r\n    if (prefix != null) {\r\n        String ns = getNamespaceURI(prefix);\r\n        if (ns == null) {\r\n            throw new JXPathException(\"Unknown namespace prefix: \" + prefix);\r\n        }\r\n        element.setAttributeNS(ns, name.toString(), \"\");\r\n    } else {\r\n        if (!element.hasAttribute(name.getName())) {\r\n            element.setAttribute(name.getName(), \"\");\r\n        }\r\n    }\r\n    NodeIterator it = attributeIterator(name);\r\n    it.setPosition(1);\r\n    return it.getNodePointer();\r\n}","lc":0.3181818182,"pi":0.0813397129,"ma":0.4,"nbd":0.0,"ml":0.3333333333,"d":0.3630952381,"mi":-0.3009161381,"fo":0.5,"r":-0.0263157895,"e":0.3921393706}
{"project_name":"Lang","project_version":"50","label":1,"code":"\/**\r\n * <p>Gets a date\/time formatter instance using the specified style,\r\n * time zone and locale.<\/p>\r\n *\r\n * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\r\n * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\r\n * @param timeZone  optional time zone, overrides time zone of\r\n *  formatted date\r\n * @param locale  optional locale, overrides system locale\r\n * @return a localized standard date\/time formatter\r\n * @throws IllegalArgumentException if the Locale has no date\/time\r\n *  pattern defined\r\n *\/\r\npublic static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {\r\n    Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));\r\n    if (timeZone != null) {\r\n        key = new Pair(key, timeZone);\r\n    }\r\n    if (locale != null) {\r\n        key = new Pair(key, locale);\r\n    }\r\n    FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\r\n    if (format == null) {\r\n        if (locale == null) {\r\n            locale = Locale.getDefault();\r\n        }\r\n        try {\r\n            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);\r\n            String pattern = formatter.toPattern();\r\n            format = getInstance(pattern, timeZone, locale);\r\n            cDateTimeInstanceCache.put(key, format);\r\n        } catch (ClassCastException ex) {\r\n            throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\r\n        }\r\n    }\r\n    return format;\r\n}","code_comment":"\/**\r\n * <p>Gets a date\/time formatter instance using the specified style,\r\n * time zone and locale.<\/p>\r\n *\r\n * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\r\n * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\r\n * @param timeZone  optional time zone, overrides time zone of\r\n *  formatted date\r\n * @param locale  optional locale, overrides system locale\r\n * @return a localized standard date\/time formatter\r\n * @throws IllegalArgumentException if the Locale has no date\/time\r\n *  pattern defined\r\n *\/\r\n","code_no_comment":"public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {\r\n    Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));\r\n    if (timeZone != null) {\r\n        key = new Pair(key, timeZone);\r\n    }\r\n    if (locale != null) {\r\n        key = new Pair(key, locale);\r\n    }\r\n    FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\r\n    if (format == null) {\r\n        if (locale == null) {\r\n            locale = Locale.getDefault();\r\n        }\r\n        try {\r\n            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);\r\n            String pattern = formatter.toPattern();\r\n            format = getInstance(pattern, timeZone, locale);\r\n            cDateTimeInstanceCache.put(key, format);\r\n        } catch (ClassCastException ex) {\r\n            throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\r\n        }\r\n    }\r\n    return format;\r\n}","lc":0.4545454545,"pi":0.3588516746,"ma":0.6,"nbd":0.0,"ml":0.1666666667,"d":0.5337301587,"mi":-0.4015503876,"fo":0.0,"r":-0.0263157895,"e":0.6984734012}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3377_00b9bc52","label":1,"code":"FullTextExpression parseTerm() throws ParseException {\r\n    if (parseIndex >= text.length()) {\r\n        throw getSyntaxError(\"term\");\r\n    }\r\n    boolean not = false;\r\n    StringBuilder buff = new StringBuilder();\r\n    char c = text.charAt(parseIndex);\r\n    if (c == '-') {\r\n        if (++parseIndex >= text.length()) {\r\n            throw getSyntaxError(\"term\");\r\n        }\r\n        not = true;\r\n    }\r\n    boolean escaped = false;\r\n    String boost = null;\r\n    if (c == '\\\"') {\r\n        parseIndex++;\r\n        while (true) {\r\n            if (parseIndex >= text.length()) {\r\n                throw getSyntaxError(\"double quote\");\r\n            }\r\n            c = text.charAt(parseIndex++);\r\n            if (c == '\\\\') {\r\n                escaped = true;\r\n                if (parseIndex >= text.length()) {\r\n                    throw getSyntaxError(\"escaped char\");\r\n                }\r\n                c = text.charAt(parseIndex++);\r\n                buff.append(c);\r\n            } else if (c == '\\\"') {\r\n                if (parseIndex < text.length()) {\r\n                    if (text.charAt(parseIndex) == '^') {\r\n                        boost = \"\";\r\n                    } else if (text.charAt(parseIndex) != ' ') {\r\n                        throw getSyntaxError(\"space\");\r\n                    }\r\n                }\r\n                parseIndex++;\r\n                break;\r\n            } else {\r\n                buff.append(c);\r\n            }\r\n        }\r\n    } else if (c == '\\'' && FullTextSearchImpl.JACKRABBIT_2_SINGLE_QUOTED_PHRASE) {\r\n        \/\/ basically the same as double quote\r\n        parseIndex++;\r\n        while (true) {\r\n            if (parseIndex >= text.length()) {\r\n                throw getSyntaxError(\"single quote\");\r\n            }\r\n            c = text.charAt(parseIndex++);\r\n            if (c == '\\\\') {\r\n                escaped = true;\r\n                if (parseIndex >= text.length()) {\r\n                    throw getSyntaxError(\"escaped char\");\r\n                }\r\n                c = text.charAt(parseIndex++);\r\n                buff.append(c);\r\n            } else if (c == '\\'') {\r\n                if (parseIndex < text.length()) {\r\n                    if (text.charAt(parseIndex) == '^') {\r\n                        boost = \"\";\r\n                    } else if (text.charAt(parseIndex) != ' ') {\r\n                        throw getSyntaxError(\"space\");\r\n                    }\r\n                }\r\n                parseIndex++;\r\n                break;\r\n            } else {\r\n                buff.append(c);\r\n            }\r\n        }\r\n    } else {\r\n        do {\r\n            c = text.charAt(parseIndex++);\r\n            if (c == '\\\\') {\r\n                escaped = true;\r\n                if (parseIndex >= text.length()) {\r\n                    throw getSyntaxError(\"escaped char\");\r\n                }\r\n                c = text.charAt(parseIndex++);\r\n                buff.append(c);\r\n            } else if (c == '^') {\r\n                boost = \"\";\r\n                break;\r\n            } else if (c == ' ') {\r\n                break;\r\n            } else {\r\n                buff.append(c);\r\n            }\r\n        } while (parseIndex < text.length());\r\n    }\r\n    if (boost != null) {\r\n        StringBuilder b = new StringBuilder();\r\n        while (parseIndex < text.length()) {\r\n            c = text.charAt(parseIndex++);\r\n            if ((c < '0' || c > '9') && c != '.') {\r\n                break;\r\n            }\r\n            b.append(c);\r\n        }\r\n        boost = b.toString();\r\n    }\r\n    if (buff.length() == 0) {\r\n        throw getSyntaxError(\"term\");\r\n    }\r\n    String text = buff.toString();\r\n    FullTextTerm term = new FullTextTerm(propertyName, text, not, escaped, boost);\r\n    return term.simplify();\r\n}","code_comment":null,"code_no_comment":"FullTextExpression parseTerm() throws ParseException {\r\n    if (parseIndex >= text.length()) {\r\n        throw getSyntaxError(\"term\");\r\n    }\r\n    boolean not = false;\r\n    StringBuilder buff = new StringBuilder();\r\n    char c = text.charAt(parseIndex);\r\n    if (c == '-') {\r\n        if (++parseIndex >= text.length()) {\r\n            throw getSyntaxError(\"term\");\r\n        }\r\n        not = true;\r\n    }\r\n    boolean escaped = false;\r\n    String boost = null;\r\n    if (c == '\\\"') {\r\n        parseIndex++;\r\n        while (true) {\r\n            if (parseIndex >= text.length()) {\r\n                throw getSyntaxError(\"double quote\");\r\n            }\r\n            c = text.charAt(parseIndex++);\r\n            if (c == '\\\\') {\r\n                escaped = true;\r\n                if (parseIndex >= text.length()) {\r\n                    throw getSyntaxError(\"escaped char\");\r\n                }\r\n                c = text.charAt(parseIndex++);\r\n                buff.append(c);\r\n            } else if (c == '\\\"') {\r\n                if (parseIndex < text.length()) {\r\n                    if (text.charAt(parseIndex) == '^') {\r\n                        boost = \"\";\r\n                    } else if (text.charAt(parseIndex) != ' ') {\r\n                        throw getSyntaxError(\"space\");\r\n                    }\r\n                }\r\n                parseIndex++;\r\n                break;\r\n            } else {\r\n                buff.append(c);\r\n            }\r\n        }\r\n    } else if (c == '\\'' && FullTextSearchImpl.JACKRABBIT_2_SINGLE_QUOTED_PHRASE) {\r\n                parseIndex++;\r\n        while (true) {\r\n            if (parseIndex >= text.length()) {\r\n                throw getSyntaxError(\"single quote\");\r\n            }\r\n            c = text.charAt(parseIndex++);\r\n            if (c == '\\\\') {\r\n                escaped = true;\r\n                if (parseIndex >= text.length()) {\r\n                    throw getSyntaxError(\"escaped char\");\r\n                }\r\n                c = text.charAt(parseIndex++);\r\n                buff.append(c);\r\n            } else if (c == '\\'') {\r\n                if (parseIndex < text.length()) {\r\n                    if (text.charAt(parseIndex) == '^') {\r\n                        boost = \"\";\r\n                    } else if (text.charAt(parseIndex) != ' ') {\r\n                        throw getSyntaxError(\"space\");\r\n                    }\r\n                }\r\n                parseIndex++;\r\n                break;\r\n            } else {\r\n                buff.append(c);\r\n            }\r\n        }\r\n    } else {\r\n        do {\r\n            c = text.charAt(parseIndex++);\r\n            if (c == '\\\\') {\r\n                escaped = true;\r\n                if (parseIndex >= text.length()) {\r\n                    throw getSyntaxError(\"escaped char\");\r\n                }\r\n                c = text.charAt(parseIndex++);\r\n                buff.append(c);\r\n            } else if (c == '^') {\r\n                boost = \"\";\r\n                break;\r\n            } else if (c == ' ') {\r\n                break;\r\n            } else {\r\n                buff.append(c);\r\n            }\r\n        } while (parseIndex < text.length());\r\n    }\r\n    if (boost != null) {\r\n        StringBuilder b = new StringBuilder();\r\n        while (parseIndex < text.length()) {\r\n            c = text.charAt(parseIndex++);\r\n            if ((c < '0' || c > '9') && c != '.') {\r\n                break;\r\n            }\r\n            b.append(c);\r\n        }\r\n        boost = b.toString();\r\n    }\r\n    if (buff.length() == 0) {\r\n        throw getSyntaxError(\"term\");\r\n    }\r\n    String text = buff.toString();\r\n    FullTextTerm term = new FullTextTerm(propertyName, text, not, escaped, boost);\r\n    return term.simplify();\r\n}","lc":4.3181818182,"pi":1.2822966507,"ma":8.4,"nbd":3.0,"ml":2.8333333333,"d":3.5833333333,"mi":-1.541789993,"fo":3.1666666667,"r":-0.0263157895,"e":14.2563164537}
{"project_name":"Closure","project_version":"138","label":2,"code":"private FlowScope traverseName(Node n, FlowScope scope) {\r\n    String varName = n.getString();\r\n    Node value = n.getFirstChild();\r\n    JSType type = n.getJSType();\r\n    if (value != null) {\r\n        scope = traverse(value, scope);\r\n        updateScopeForTypeChange(scope, n, n.getJSType(), \/* could be null *\/\r\n        getJSType(value));\r\n        return scope;\r\n    } else {\r\n        StaticSlot<JSType> var = scope.getSlot(varName);\r\n        if (var != null && !(var.isTypeInferred() && unflowableVarNames.contains(varName))) {\r\n            \/\/ There are two situations where we don't want to use type information\r\n            \/\/ from the scope, even if we have it.\r\n            \/\/ 1) The var is escaped in a weird way, e.g.,\r\n            \/\/ function f() { var x = 3; function g() { x = null } (x); }\r\n            \/\/ 2) We're reading type information from another scope for an\r\n            \/\/ inferred variable.\r\n            \/\/ var t = null; function f() { (t); }\r\n            type = var.getType();\r\n            if (type == null) {\r\n                type = getNativeType(UNKNOWN_TYPE);\r\n            }\r\n        }\r\n    }\r\n    n.setJSType(type);\r\n    return scope;\r\n}","code_comment":null,"code_no_comment":"private FlowScope traverseName(Node n, FlowScope scope) {\r\n    String varName = n.getString();\r\n    Node value = n.getFirstChild();\r\n    JSType type = n.getJSType();\r\n    if (value != null) {\r\n        scope = traverse(value, scope);\r\n        updateScopeForTypeChange(scope, n, n.getJSType(),         getJSType(value));\r\n        return scope;\r\n    } else {\r\n        StaticSlot<JSType> var = scope.getSlot(varName);\r\n        if (var != null && !(var.isTypeInferred() && unflowableVarNames.contains(varName))) {\r\n                                                                                                type = var.getType();\r\n            if (type == null) {\r\n                type = getNativeType(UNKNOWN_TYPE);\r\n            }\r\n        }\r\n    }\r\n    n.setJSType(type);\r\n    return scope;\r\n}","lc":0.3181818182,"pi":0.4688995215,"ma":0.0,"nbd":0.5,"ml":0.5,"d":0.4880952381,"mi":-0.2995066949,"fo":0.5833333333,"r":-0.0263157895,"e":0.5403710171}
{"project_name":"Compress","project_version":"9","label":1,"code":"\/**\r\n * Writes bytes to the current tar archive entry. This method\r\n * is aware of the current entry and will throw an exception if\r\n * you attempt to write bytes past the length specified for the\r\n * current entry. The method is also (painfully) aware of the\r\n * record buffering required by TarBuffer, and manages buffers\r\n * that are not a multiple of recordsize in length, including\r\n * assembling records from small buffers.\r\n *\r\n * @param wBuf The buffer to write to the archive.\r\n * @param wOffset The offset in the buffer from which to get bytes.\r\n * @param numToWrite The number of bytes to write.\r\n * @throws IOException on error\r\n *\/\r\n@Override\r\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\r\n    if ((currBytes + numToWrite) > currSize) {\r\n        throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\r\n    \/\/ \r\n    \/\/ We have to deal with assembly!!!\r\n    \/\/ The programmer can be writing little 32 byte chunks for all\r\n    \/\/ we know, and we must assemble complete records for writing.\r\n    \/\/ REVIEW Maybe this should be in TarBuffer? Could that help to\r\n    \/\/ eliminate some of the buffer copying.\r\n    \/\/ \r\n    }\r\n    if (assemLen > 0) {\r\n        if ((assemLen + numToWrite) >= recordBuf.length) {\r\n            int aLen = recordBuf.length - assemLen;\r\n            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\r\n            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\r\n            buffer.writeRecord(recordBuf);\r\n            currBytes += recordBuf.length;\r\n            wOffset += aLen;\r\n            numToWrite -= aLen;\r\n            assemLen = 0;\r\n        } else {\r\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\r\n            wOffset += numToWrite;\r\n            assemLen += numToWrite;\r\n            numToWrite = 0;\r\n        }\r\n    }\r\n    \/\/ \r\n    while (numToWrite > 0) {\r\n        if (numToWrite < recordBuf.length) {\r\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\r\n            assemLen += numToWrite;\r\n            break;\r\n        }\r\n        buffer.writeRecord(wBuf, wOffset);\r\n        int num = recordBuf.length;\r\n        currBytes += num;\r\n        numToWrite -= num;\r\n        wOffset += num;\r\n    }\r\n    count(numToWrite);\r\n}","code_comment":"\/**\r\n * Writes bytes to the current tar archive entry. This method\r\n * is aware of the current entry and will throw an exception if\r\n * you attempt to write bytes past the length specified for the\r\n * current entry. The method is also (painfully) aware of the\r\n * record buffering required by TarBuffer, and manages buffers\r\n * that are not a multiple of recordsize in length, including\r\n * assembling records from small buffers.\r\n *\r\n * @param wBuf The buffer to write to the archive.\r\n * @param wOffset The offset in the buffer from which to get bytes.\r\n * @param numToWrite The number of bytes to write.\r\n * @throws IOException on error\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\r\n    if ((currBytes + numToWrite) > currSize) {\r\n        throw new IOException(\"request to write '\" + numToWrite + \"' bytes exceeds size in header of '\" + currSize + \"' bytes for entry '\" + currName + \"'\");\r\n                                }\r\n    if (assemLen > 0) {\r\n        if ((assemLen + numToWrite) >= recordBuf.length) {\r\n            int aLen = recordBuf.length - assemLen;\r\n            System.arraycopy(assemBuf, 0, recordBuf, 0, assemLen);\r\n            System.arraycopy(wBuf, wOffset, recordBuf, assemLen, aLen);\r\n            buffer.writeRecord(recordBuf);\r\n            currBytes += recordBuf.length;\r\n            wOffset += aLen;\r\n            numToWrite -= aLen;\r\n            assemLen = 0;\r\n        } else {\r\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\r\n            wOffset += numToWrite;\r\n            assemLen += numToWrite;\r\n            numToWrite = 0;\r\n        }\r\n    }\r\n        while (numToWrite > 0) {\r\n        if (numToWrite < recordBuf.length) {\r\n            System.arraycopy(wBuf, wOffset, assemBuf, assemLen, numToWrite);\r\n            assemLen += numToWrite;\r\n            break;\r\n        }\r\n        buffer.writeRecord(wBuf, wOffset);\r\n        int num = recordBuf.length;\r\n        currBytes += num;\r\n        numToWrite -= num;\r\n        wOffset += num;\r\n    }\r\n    count(numToWrite);\r\n}","lc":1.0,"pi":0.4258373206,"ma":0.8,"nbd":0.0,"ml":0.4166666667,"d":2.5654761905,"mi":-0.6484848485,"fo":0.0833333333,"r":-0.0263157895,"e":3.9248583761}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4358_74cbba24","label":1,"code":"\/**\r\n * Get the revision of the latest change made to this node. At the same\r\n * time this method collects all collisions that happened for the given\r\n * {@code changeRev}. The reported latest change takes branches into\r\n * account. This means, if {@code changeRev} is on a branch, the latest\r\n * change is either a change that was done by a preceding branch commit or\r\n * a change that happened before the base of the branch. Changes done after\r\n * the branch base on trunk are not considered in this case. For a trunk\r\n * commit the latest change is reported similarly. In this case, unmerged\r\n * branch commits are not considered as latest change. Only commits to trunk\r\n * are considered.\r\n *\r\n * Collisions include the following cases:\r\n * <ul>\r\n *     <li>The other change is not yet committed<\/li>\r\n *     <li>The other change is a branch commit and not yet merged<\/li>\r\n *     <li>The {@code changeRev} is a branch commit and the other change\r\n *       happened after the base revision of the branch<\/li>\r\n *     <li>The other change is from another cluster node and not yet\r\n *       visible<\/li>\r\n * <\/ul>\r\n *\r\n * @param context the revision context.\r\n * @param baseRev the base revision of the current change.\r\n * @param changeRev the revision of the current change.\r\n * @param branch the branch associated with the current change or\r\n *              {@code null} if {@code changeRev} is not a branch commit.\r\n * @param collisions changes that happened after {@code baseRev}.\r\n *\/\r\n@CheckForNull\r\nRevision getNewestRevision(final RevisionContext context, final RevisionVector baseRev, final Revision changeRev, final Branch branch, final Set<Revision> collisions) {\r\n    checkArgument(!baseRev.isBranch() || branch != null, \"Branch must be non-null if baseRev is a branch revision\");\r\n    RevisionVector head = context.getHeadRevision();\r\n    RevisionVector lower = branch != null ? branch.getBase() : baseRev;\r\n    \/\/ the clusterIds to check when walking the changes\r\n    Set<Integer> clusterIds = Collections.emptySet();\r\n    if (!getPreviousRanges().isEmpty()) {\r\n        clusterIds = Sets.newHashSet();\r\n        for (Revision prevRev : getPreviousRanges().keySet()) {\r\n            if (lower.isRevisionNewer(prevRev) || equal(prevRev, lower.getRevision(prevRev.getClusterId()))) {\r\n                clusterIds.add(prevRev.getClusterId());\r\n            }\r\n        }\r\n        if (!clusterIds.isEmpty()) {\r\n            \/\/ add clusterIds of local changes as well\r\n            for (Revision r : getLocalCommitRoot().keySet()) {\r\n                clusterIds.add(r.getClusterId());\r\n            }\r\n            for (Revision r : getLocalRevisions().keySet()) {\r\n                clusterIds.add(r.getClusterId());\r\n            }\r\n        }\r\n    }\r\n    \/\/ if we don't have clusterIds, we can use the local changes only\r\n    boolean fullScan = true;\r\n    Iterable<Revision> changes;\r\n    if (clusterIds.isEmpty()) {\r\n        \/\/ baseRev is newer than all previous documents\r\n        changes = Iterables.mergeSorted(ImmutableList.of(getLocalRevisions().keySet(), getLocalCommitRoot().keySet()), getLocalRevisions().comparator());\r\n    } else {\r\n        \/\/ include previous documents as well (only needed in rare cases)\r\n        fullScan = false;\r\n        changes = getAllChanges();\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"getNewestRevision() with changeRev {} on {}, \" + \"_revisions {}, _commitRoot {}\", changeRev, getId(), getLocalRevisions(), getLocalCommitRoot());\r\n        }\r\n    }\r\n    Map<Integer, Revision> newestRevs = Maps.newHashMap();\r\n    Map<Revision, String> validRevisions = Maps.newHashMap();\r\n    for (Revision r : changes) {\r\n        if (r.equals(changeRev)) {\r\n            continue;\r\n        }\r\n        if (!fullScan) {\r\n            \/\/ check if we can stop going through changes\r\n            if (clusterIds.contains(r.getClusterId()) && !lower.isRevisionNewer(r) && newestRevs.containsKey(r.getClusterId())) {\r\n                clusterIds.remove(r.getClusterId());\r\n                if (clusterIds.isEmpty()) {\r\n                    \/\/ the lower bound\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (newestRevs.containsKey(r.getClusterId())) {\r\n            \/\/ of the branch if this is for a commit on a branch\r\n            if (branch != null && !branch.containsCommit(r)) {\r\n                \/\/ change does not belong to the branch\r\n                if (branch.getBase(changeRev).isRevisionNewer(r)) {\r\n                    \/\/ and happened after the base of the branch\r\n                    collisions.add(r);\r\n                }\r\n            }\r\n        } else {\r\n            \/\/ check if change is visible from baseRev\r\n            if (isValidRevision(context, r, null, baseRev, validRevisions)) {\r\n                \/\/ consider for newestRev\r\n                newestRevs.put(r.getClusterId(), r);\r\n            } else {\r\n                \/\/ not valid means:\r\n                \/\/ 1) 'r' is not committed -> collision\r\n                \/\/ 2) 'r' is on a branch, but not the same as\r\n                \/\/ changeRev -> collisions\r\n                \/\/ 3) changeRev is on a branch and 'r' is newer than\r\n                \/\/ the base of the branch -> collision\r\n                \/\/ 4) 'r' is committed but not yet visible to current\r\n                \/\/ cluster node -> collisions\r\n                \/\/ 5) changeRev is not on a branch, 'r' is committed and\r\n                \/\/ newer than baseRev -> newestRev\r\n                NodeDocument commitRoot = getCommitRoot(r);\r\n                Revision commitRevision = null;\r\n                if (commitRoot != null) {\r\n                    commitRevision = commitRoot.getCommitRevision(r);\r\n                }\r\n                if (\/\/ committed but not yet visible\r\n                commitRevision != null && head.isRevisionNewer(commitRevision)) {\r\n                    \/\/ case 4)\r\n                    collisions.add(r);\r\n                } else if (\/\/ committed\r\n                commitRevision != null && \/\/ changeRev not on branch\r\n                branch == null && baseRev.isRevisionNewer(r)) {\r\n                    \/\/ case 5)\r\n                    newestRevs.put(r.getClusterId(), r);\r\n                } else {\r\n                    \/\/ remaining cases 1), 2) and 3)\r\n                    collisions.add(r);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \/\/ select the newest committed change\r\n    Revision newestRev = null;\r\n    for (Revision r : newestRevs.values()) {\r\n        newestRev = Utils.max(newestRev, r, StableRevisionComparator.INSTANCE);\r\n    }\r\n    if (newestRev == null) {\r\n        return null;\r\n    }\r\n    \/\/ the local deleted map contains the most recent revisions\r\n    SortedMap<Revision, String> deleted = getLocalDeleted();\r\n    String value = deleted.get(newestRev);\r\n    if (value == null && deleted.headMap(newestRev).isEmpty()) {\r\n        \/\/ no need to check previous docs\r\n        return newestRev;\r\n    }\r\n    if (value == null) {\r\n        \/\/ get from complete map\r\n        value = getDeleted().get(newestRev);\r\n    }\r\n    if (\"true\".equals(value)) {\r\n        \/\/ deleted in the newest revision\r\n        return null;\r\n    }\r\n    return newestRev;\r\n}","code_comment":"\/**\r\n * Get the revision of the latest change made to this node. At the same\r\n * time this method collects all collisions that happened for the given\r\n * {@code changeRev}. The reported latest change takes branches into\r\n * account. This means, if {@code changeRev} is on a branch, the latest\r\n * change is either a change that was done by a preceding branch commit or\r\n * a change that happened before the base of the branch. Changes done after\r\n * the branch base on trunk are not considered in this case. For a trunk\r\n * commit the latest change is reported similarly. In this case, unmerged\r\n * branch commits are not considered as latest change. Only commits to trunk\r\n * are considered.\r\n *\r\n * Collisions include the following cases:\r\n * <ul>\r\n *     <li>The other change is not yet committed<\/li>\r\n *     <li>The other change is a branch commit and not yet merged<\/li>\r\n *     <li>The {@code changeRev} is a branch commit and the other change\r\n *       happened after the base revision of the branch<\/li>\r\n *     <li>The other change is from another cluster node and not yet\r\n *       visible<\/li>\r\n * <\/ul>\r\n *\r\n * @param context the revision context.\r\n * @param baseRev the base revision of the current change.\r\n * @param changeRev the revision of the current change.\r\n * @param branch the branch associated with the current change or\r\n *              {@code null} if {@code changeRev} is not a branch commit.\r\n * @param collisions changes that happened after {@code baseRev}.\r\n *\/\r\n","code_no_comment":"@CheckForNull\r\nRevision getNewestRevision(final RevisionContext context, final RevisionVector baseRev, final Revision changeRev, final Branch branch, final Set<Revision> collisions) {\r\n    checkArgument(!baseRev.isBranch() || branch != null, \"Branch must be non-null if baseRev is a branch revision\");\r\n    RevisionVector head = context.getHeadRevision();\r\n    RevisionVector lower = branch != null ? branch.getBase() : baseRev;\r\n        Set<Integer> clusterIds = Collections.emptySet();\r\n    if (!getPreviousRanges().isEmpty()) {\r\n        clusterIds = Sets.newHashSet();\r\n        for (Revision prevRev : getPreviousRanges().keySet()) {\r\n            if (lower.isRevisionNewer(prevRev) || equal(prevRev, lower.getRevision(prevRev.getClusterId()))) {\r\n                clusterIds.add(prevRev.getClusterId());\r\n            }\r\n        }\r\n        if (!clusterIds.isEmpty()) {\r\n                        for (Revision r : getLocalCommitRoot().keySet()) {\r\n                clusterIds.add(r.getClusterId());\r\n            }\r\n            for (Revision r : getLocalRevisions().keySet()) {\r\n                clusterIds.add(r.getClusterId());\r\n            }\r\n        }\r\n    }\r\n        boolean fullScan = true;\r\n    Iterable<Revision> changes;\r\n    if (clusterIds.isEmpty()) {\r\n                changes = Iterables.mergeSorted(ImmutableList.of(getLocalRevisions().keySet(), getLocalCommitRoot().keySet()), getLocalRevisions().comparator());\r\n    } else {\r\n                fullScan = false;\r\n        changes = getAllChanges();\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"getNewestRevision() with changeRev {} on {}, \" + \"_revisions {}, _commitRoot {}\", changeRev, getId(), getLocalRevisions(), getLocalCommitRoot());\r\n        }\r\n    }\r\n    Map<Integer, Revision> newestRevs = Maps.newHashMap();\r\n    Map<Revision, String> validRevisions = Maps.newHashMap();\r\n    for (Revision r : changes) {\r\n        if (r.equals(changeRev)) {\r\n            continue;\r\n        }\r\n        if (!fullScan) {\r\n                        if (clusterIds.contains(r.getClusterId()) && !lower.isRevisionNewer(r) && newestRevs.containsKey(r.getClusterId())) {\r\n                clusterIds.remove(r.getClusterId());\r\n                if (clusterIds.isEmpty()) {\r\n                                        break;\r\n                }\r\n            }\r\n        }\r\n        if (newestRevs.containsKey(r.getClusterId())) {\r\n                        if (branch != null && !branch.containsCommit(r)) {\r\n                                if (branch.getBase(changeRev).isRevisionNewer(r)) {\r\n                                        collisions.add(r);\r\n                }\r\n            }\r\n        } else {\r\n                        if (isValidRevision(context, r, null, baseRev, validRevisions)) {\r\n                                newestRevs.put(r.getClusterId(), r);\r\n            } else {\r\n                                                                                                                                                                                NodeDocument commitRoot = getCommitRoot(r);\r\n                Revision commitRevision = null;\r\n                if (commitRoot != null) {\r\n                    commitRevision = commitRoot.getCommitRevision(r);\r\n                }\r\n                if (                commitRevision != null && head.isRevisionNewer(commitRevision)) {\r\n                                        collisions.add(r);\r\n                } else if (                commitRevision != null &&                 branch == null && baseRev.isRevisionNewer(r)) {\r\n                                        newestRevs.put(r.getClusterId(), r);\r\n                } else {\r\n                                        collisions.add(r);\r\n                }\r\n            }\r\n        }\r\n    }\r\n        Revision newestRev = null;\r\n    for (Revision r : newestRevs.values()) {\r\n        newestRev = Utils.max(newestRev, r, StableRevisionComparator.INSTANCE);\r\n    }\r\n    if (newestRev == null) {\r\n        return null;\r\n    }\r\n        SortedMap<Revision, String> deleted = getLocalDeleted();\r\n    String value = deleted.get(newestRev);\r\n    if (value == null && deleted.headMap(newestRev).isEmpty()) {\r\n                return newestRev;\r\n    }\r\n    if (value == null) {\r\n                value = getDeleted().get(newestRev);\r\n    }\r\n    if (\"true\".equals(value)) {\r\n                return null;\r\n    }\r\n    return newestRev;\r\n}","lc":3.6818181818,"pi":1.1674641148,"ma":5.0,"nbd":1.5,"ml":4.5833333333,"d":1.373015873,"mi":-1.4002818887,"fo":5.9166666667,"r":-0.0263157895,"e":7.6980757594}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-43_668f08f2","label":1,"code":"public void setProperty(String nodePath, String propName, String propValue) throws Exception {\r\n    MutableNode node = getOrCreateStagedNode(nodePath);\r\n    Map<String, String> properties = node.getProperties();\r\n    if (propValue == null) {\r\n        properties.remove(propName);\r\n    } else {\r\n        properties.put(propName, propValue);\r\n    }\r\n    \/\/ update change log\r\n    changeLog.add(new SetProperty(nodePath, propName, propValue));\r\n}","code_comment":null,"code_no_comment":"public void setProperty(String nodePath, String propName, String propValue) throws Exception {\r\n    MutableNode node = getOrCreateStagedNode(nodePath);\r\n    Map<String, String> properties = node.getProperties();\r\n    if (propValue == null) {\r\n        properties.remove(propName);\r\n    } else {\r\n        properties.put(propName, propValue);\r\n    }\r\n        changeLog.add(new SetProperty(nodePath, propName, propValue));\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0099206349,"mi":0.1670190275,"fo":-0.0833333333,"r":0.0,"e":-0.0287155017}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-4512_8cb04253","label":1,"code":"private static int getRelationOrder(String value, RangeValue rangeValue, boolean isLeft) {\r\n    if (rangeValue.value.length() <= 0) {\r\n        return isLeft ? 1 : -1;\r\n    }\r\n    List<String> valueTokens = new ArrayList<String>(Arrays.asList(value.split(\"\\\\.\")));\r\n    List<String> rangeValueTokens = new ArrayList<String>(Arrays.asList(rangeValue.value.split(\"\\\\.\")));\r\n    int max = Math.max(valueTokens.size(), rangeValueTokens.size());\r\n    addZeroTokens(valueTokens, max);\r\n    addZeroTokens(rangeValueTokens, max);\r\n    if (value.equals(rangeValue.getValue())) {\r\n        if (!rangeValue.isClosed()) {\r\n            return isLeft ? -1 : 1;\r\n        }\r\n        return 0;\r\n    }\r\n    for (int i = 0; i < valueTokens.size(); i++) {\r\n        int x = Integer.parseInt(valueTokens.get(i));\r\n        int y = Integer.parseInt(rangeValueTokens.get(i));\r\n        if (x < y) {\r\n            return -1;\r\n        } else if (x > y) {\r\n            return 1;\r\n        }\r\n    }\r\n    if (!rangeValue.isClosed()) {\r\n        return isLeft ? -1 : 1;\r\n    }\r\n    return 0;\r\n}","code_comment":null,"code_no_comment":"private static int getRelationOrder(String value, RangeValue rangeValue, boolean isLeft) {\r\n    if (rangeValue.value.length() <= 0) {\r\n        return isLeft ? 1 : -1;\r\n    }\r\n    List<String> valueTokens = new ArrayList<String>(Arrays.asList(value.split(\"\\\\.\")));\r\n    List<String> rangeValueTokens = new ArrayList<String>(Arrays.asList(rangeValue.value.split(\"\\\\.\")));\r\n    int max = Math.max(valueTokens.size(), rangeValueTokens.size());\r\n    addZeroTokens(valueTokens, max);\r\n    addZeroTokens(rangeValueTokens, max);\r\n    if (value.equals(rangeValue.getValue())) {\r\n        if (!rangeValue.isClosed()) {\r\n            return isLeft ? -1 : 1;\r\n        }\r\n        return 0;\r\n    }\r\n    for (int i = 0; i < valueTokens.size(); i++) {\r\n        int x = Integer.parseInt(valueTokens.get(i));\r\n        int y = Integer.parseInt(rangeValueTokens.get(i));\r\n        if (x < y) {\r\n            return -1;\r\n        } else if (x > y) {\r\n            return 1;\r\n        }\r\n    }\r\n    if (!rangeValue.isClosed()) {\r\n        return isLeft ? -1 : 1;\r\n    }\r\n    return 0;\r\n}","lc":0.6818181818,"pi":0.043062201,"ma":1.4,"nbd":0.5,"ml":1.1666666667,"d":1.3253968254,"mi":-0.5565891473,"fo":1.0833333333,"r":-0.0263157895,"e":2.0006823303}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4138_50db442b","label":1,"code":"@Override\r\npublic Options getOptions() {\r\n    final Options o = new Options();\r\n    forceOpt = new Option(\"f\", \"force\", false, \"delete data even if start or end are not specified\");\r\n    startRowOptExclusive = new Option(OptUtil.START_ROW_OPT, \"begin-row\", true, \"begin row (exclusive)\");\r\n    startRowOptExclusive.setArgName(\"begin-row\");\r\n    o.addOption(startRowOptExclusive);\r\n    o.addOption(OptUtil.endRowOpt());\r\n    o.addOption(OptUtil.tableOpt(\"table to delete a row range from\"));\r\n    o.addOption(forceOpt);\r\n    return o;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Options getOptions() {\r\n    final Options o = new Options();\r\n    forceOpt = new Option(\"f\", \"force\", false, \"delete data even if start or end are not specified\");\r\n    startRowOptExclusive = new Option(OptUtil.START_ROW_OPT, \"begin-row\", true, \"begin row (exclusive)\");\r\n    startRowOptExclusive.setArgName(\"begin-row\");\r\n    o.addOption(startRowOptExclusive);\r\n    o.addOption(OptUtil.endRowOpt());\r\n    o.addOption(OptUtil.tableOpt(\"table to delete a row range from\"));\r\n    o.addOption(forceOpt);\r\n    return o;\r\n}","lc":-0.0909090909,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.067230444,"fo":0.0833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1429_c2f5ca6c","label":1,"code":"@Override\r\npublic String getNodes(String path, String revisionId, int depth, long offset, int maxChildNodes, String filter) throws MicroKernelException {\r\n    if (depth != 0) {\r\n        throw new MicroKernelException(\"Only depth 0 is supported, depth is \" + depth);\r\n    }\r\n    revisionId = revisionId != null ? revisionId : nodeStore.getHeadRevision().toString();\r\n    Revision rev = Revision.fromString(revisionId);\r\n    DocumentNodeState n = nodeStore.getNode(path, rev);\r\n    if (n == null) {\r\n        return null;\r\n    }\r\n    JsopStream json = new JsopStream();\r\n    boolean includeId = filter != null && filter.contains(\":id\");\r\n    includeId |= filter != null && filter.contains(\":hash\");\r\n    json.object();\r\n    n.append(json, includeId);\r\n    int max;\r\n    if (maxChildNodes == -1) {\r\n        max = Integer.MAX_VALUE;\r\n        maxChildNodes = Integer.MAX_VALUE;\r\n    } else {\r\n        \/\/ use long to avoid overflows\r\n        long m = ((long) maxChildNodes) + offset;\r\n        max = (int) Math.min(m, Integer.MAX_VALUE);\r\n    }\r\n    Children c = nodeStore.getChildren(n, null, max);\r\n    for (long i = offset; i < c.children.size(); i++) {\r\n        if (maxChildNodes-- <= 0) {\r\n            break;\r\n        }\r\n        String name = PathUtils.getName(c.children.get((int) i));\r\n        json.key(name).object().endObject();\r\n    }\r\n    if (c.hasMore) {\r\n        \/\/ TODO use a better way to notify there are more children\r\n        json.key(\":childNodeCount\").value(Long.MAX_VALUE);\r\n    } else {\r\n        json.key(\":childNodeCount\").value(c.children.size());\r\n    }\r\n    json.endObject();\r\n    return json.toString();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String getNodes(String path, String revisionId, int depth, long offset, int maxChildNodes, String filter) throws MicroKernelException {\r\n    if (depth != 0) {\r\n        throw new MicroKernelException(\"Only depth 0 is supported, depth is \" + depth);\r\n    }\r\n    revisionId = revisionId != null ? revisionId : nodeStore.getHeadRevision().toString();\r\n    Revision rev = Revision.fromString(revisionId);\r\n    DocumentNodeState n = nodeStore.getNode(path, rev);\r\n    if (n == null) {\r\n        return null;\r\n    }\r\n    JsopStream json = new JsopStream();\r\n    boolean includeId = filter != null && filter.contains(\":id\");\r\n    includeId |= filter != null && filter.contains(\":hash\");\r\n    json.object();\r\n    n.append(json, includeId);\r\n    int max;\r\n    if (maxChildNodes == -1) {\r\n        max = Integer.MAX_VALUE;\r\n        maxChildNodes = Integer.MAX_VALUE;\r\n    } else {\r\n                long m = ((long) maxChildNodes) + offset;\r\n        max = (int) Math.min(m, Integer.MAX_VALUE);\r\n    }\r\n    Children c = nodeStore.getChildren(n, null, max);\r\n    for (long i = offset; i < c.children.size(); i++) {\r\n        if (maxChildNodes-- <= 0) {\r\n            break;\r\n        }\r\n        String name = PathUtils.getName(c.children.get((int) i));\r\n        json.key(name).object().endObject();\r\n    }\r\n    if (c.hasMore) {\r\n                json.key(\":childNodeCount\").value(Long.MAX_VALUE);\r\n    } else {\r\n        json.key(\":childNodeCount\").value(c.children.size());\r\n    }\r\n    json.endObject();\r\n    return json.toString();\r\n}","lc":1.1818181818,"pi":-0.2200956938,"ma":1.2,"nbd":0.0,"ml":0.75,"d":1.9682539683,"mi":-0.7742071882,"fo":1.4166666667,"r":-0.0263157895,"e":4.897921313}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4256_09166ea8","label":1,"code":"\/**\r\n *\/\r\nprivate final void internalBeforeRender() {\r\n    configure();\r\n    if ((determineVisibility()) && !getFlag(FLAG_RENDERING) && !getFlag(FLAG_PREPARED_FOR_RENDER)) {\r\n        setRequestFlag(RFLAG_BEFORE_RENDER_SUPER_CALL_VERIFIED, false);\r\n        getApplication().getComponentPreOnBeforeRenderListeners().onBeforeRender(this);\r\n        onBeforeRender();\r\n        getApplication().getComponentPostOnBeforeRenderListeners().onBeforeRender(this);\r\n        if (!getRequestFlag(RFLAG_BEFORE_RENDER_SUPER_CALL_VERIFIED)) {\r\n            throw new IllegalStateException(Component.class.getName() + \" has not been properly rendered. Something in the hierarchy of \" + getClass().getName() + \" has not called super.onBeforeRender() in the override of onBeforeRender() method\");\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *\/\r\n","code_no_comment":"private final void internalBeforeRender() {\r\n    configure();\r\n    if ((determineVisibility()) && !getFlag(FLAG_RENDERING) && !getFlag(FLAG_PREPARED_FOR_RENDER)) {\r\n        setRequestFlag(RFLAG_BEFORE_RENDER_SUPER_CALL_VERIFIED, false);\r\n        getApplication().getComponentPreOnBeforeRenderListeners().onBeforeRender(this);\r\n        onBeforeRender();\r\n        getApplication().getComponentPostOnBeforeRenderListeners().onBeforeRender(this);\r\n        if (!getRequestFlag(RFLAG_BEFORE_RENDER_SUPER_CALL_VERIFIED)) {\r\n            throw new IllegalStateException(Component.class.getName() + \" has not been properly rendered. Something in the hierarchy of \" + getClass().getName() + \" has not called super.onBeforeRender() in the override of onBeforeRender() method\");\r\n        }\r\n    }\r\n}","lc":-0.0909090909,"pi":0.2248803828,"ma":0.0,"nbd":0.0,"ml":0.25,"d":-0.1091269841,"mi":0.0855532065,"fo":0.8333333333,"r":-0.0263157895,"e":-0.0758239542}
{"project_name":"Codec","project_version":"13","label":1,"code":"\/**\r\n * Check if the Double Metaphone values of two <code>String<\/code> values\r\n * are equal, optionally using the alternate value.\r\n *\r\n * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\r\n * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\r\n * @param alternate use the alternate value if {@code true}.\r\n * @return {@code true} if the encoded <code>String<\/code>s are equal;\r\n *          {@code false} otherwise.\r\n *\/\r\npublic boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\r\n    return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));\r\n}","code_comment":"\/**\r\n * Check if the Double Metaphone values of two <code>String<\/code> values\r\n * are equal, optionally using the alternate value.\r\n *\r\n * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\r\n * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\r\n * @param alternate use the alternate value if {@code true}.\r\n * @return {@code true} if the encoded <code>String<\/code>s are equal;\r\n *          {@code false} otherwise.\r\n *\/\r\n","code_no_comment":"public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {\r\n    return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9216349542,"fo":-0.25,"r":0.4736842105,"e":-0.1627934049}
{"project_name":"Closure","project_version":"137","label":2,"code":"\/**\r\n * Prepare a set for the new scope.\r\n *\/\r\nprivate static String getNameSuffix(String name, int index) {\r\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\r\n}","code_comment":"\/**\r\n * Prepare a set for the new scope.\r\n *\/\r\n","code_no_comment":"private static String getNameSuffix(String name, int index) {\r\n    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.896546864,"fo":-0.25,"r":1.5263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5359_61122bab","label":3,"code":"\/**\r\n *  Convert to enum, returning null if text is null or empty.\r\n *\r\n *  @param eClass\r\n *             enum type\r\n *\r\n *  @return converted\r\n *  @throws StringValueConversionException\r\n *\/\r\npublic final <T extends Enum<T>> T toOptionalEnum(Class<T> eClass) throws StringValueConversionException {\r\n    return Strings.isEmpty(text) ? null : toEnum(eClass);\r\n}","code_comment":"\/**\r\n *  Convert to enum, returning null if text is null or empty.\r\n *\r\n *  @param eClass\r\n *             enum type\r\n *\r\n *  @return converted\r\n *  @throws StringValueConversionException\r\n *\/\r\n","code_no_comment":"public final <T extends Enum<T>> T toOptionalEnum(Class<T> eClass) throws StringValueConversionException {\r\n    return Strings.isEmpty(text) ? null : toEnum(eClass);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.8694855532,"fo":-0.3333333333,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3256_44061882","label":0,"code":"public void restart() {\r\n    try {\r\n        synchronized (progressLock) {\r\n            JobStatus current = state;\r\n            if (current == JobStatus.CANCELED) {\r\n                LOG.info(\"Canceled job during restart. Aborting restart.\");\r\n                return;\r\n            } else if (current != JobStatus.RESTARTING) {\r\n                throw new IllegalStateException(\"Can only restart job from state restarting.\");\r\n            }\r\n            if (scheduler == null) {\r\n                throw new IllegalStateException(\"The execution graph has not been scheduled before - scheduler is null.\");\r\n            }\r\n            this.currentExecutions.clear();\r\n            for (ExecutionJobVertex jv : this.verticesInCreationOrder) {\r\n                jv.resetForNewExecution();\r\n            }\r\n            for (int i = 0; i < stateTimestamps.length; i++) {\r\n                stateTimestamps[i] = 0;\r\n            }\r\n            numFinishedJobVertices = 0;\r\n            transitionState(JobStatus.RESTARTING, JobStatus.CREATED);\r\n            \/\/ if we have checkpointed state, reload it into the executions\r\n            if (checkpointCoordinator != null) {\r\n                checkpointCoordinator.restoreLatestCheckpointedState(getAllVertices(), false, false);\r\n            }\r\n        }\r\n        scheduleForExecution(scheduler);\r\n    } catch (Throwable t) {\r\n        fail(t);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void restart() {\r\n    try {\r\n        synchronized (progressLock) {\r\n            JobStatus current = state;\r\n            if (current == JobStatus.CANCELED) {\r\n                LOG.info(\"Canceled job during restart. Aborting restart.\");\r\n                return;\r\n            } else if (current != JobStatus.RESTARTING) {\r\n                throw new IllegalStateException(\"Can only restart job from state restarting.\");\r\n            }\r\n            if (scheduler == null) {\r\n                throw new IllegalStateException(\"The execution graph has not been scheduled before - scheduler is null.\");\r\n            }\r\n            this.currentExecutions.clear();\r\n            for (ExecutionJobVertex jv : this.verticesInCreationOrder) {\r\n                jv.resetForNewExecution();\r\n            }\r\n            for (int i = 0; i < stateTimestamps.length; i++) {\r\n                stateTimestamps[i] = 0;\r\n            }\r\n            numFinishedJobVertices = 0;\r\n            transitionState(JobStatus.RESTARTING, JobStatus.CREATED);\r\n                        if (checkpointCoordinator != null) {\r\n                checkpointCoordinator.restoreLatestCheckpointedState(getAllVertices(), false, false);\r\n            }\r\n        }\r\n        scheduleForExecution(scheduler);\r\n    } catch (Throwable t) {\r\n        fail(t);\r\n    }\r\n}","lc":0.7727272727,"pi":0.6985645933,"ma":1.2,"nbd":1.0,"ml":0.4166666667,"d":0.246031746,"mi":-0.5188160677,"fo":0.1666666667,"r":-0.0263157895,"e":0.3504065743}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2799_3979fa8d","label":1,"code":"@Override\r\npublic byte readByte() throws IOException {\r\n    byte[] b = new byte[1];\r\n    readBytes(b, 0, 1);\r\n    return b[0];\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic byte readByte() throws IOException {\r\n    byte[] b = new byte[1];\r\n    readBytes(b, 0, 1);\r\n    return b[0];\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6078928823,"fo":-0.4166666667,"r":0.4210526316,"e":-0.1627934049}
{"project_name":"Lang","project_version":"37","label":1,"code":"\/**\r\n * <p>Adds all the elements of the given arrays into a new array.<\/p>\r\n * <p>The new array contains all of the element of <code>array1<\/code> followed\r\n * by all of the elements <code>array2<\/code>. When an array is returned, it is always\r\n * a new array.<\/p>\r\n *\r\n * <pre>\r\n * ArrayUtils.addAll(null, null)     = null\r\n * ArrayUtils.addAll(array1, null)   = cloned copy of array1\r\n * ArrayUtils.addAll(null, array2)   = cloned copy of array2\r\n * ArrayUtils.addAll([], [])         = []\r\n * ArrayUtils.addAll([null], [null]) = [null, null]\r\n * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\r\n * <\/pre>\r\n *\r\n * @param array1  the first array whose elements are added to the new array, may be <code>null<\/code>\r\n * @param array2  the second array whose elements are added to the new array, may be <code>null<\/code>\r\n * @return The new array, <code>null<\/code> if both arrays are <code>null<\/code>.\r\n *      The type of the new array is the type of the first array,\r\n *      unless the first array is null, in which case the type is the same as the second array.\r\n * @since 2.1\r\n *\/\r\n@SuppressWarnings(\"unchecked\")\r\npublic static <T> T[] addAll(T[] array1, T... array2) {\r\n    if (array1 == null) {\r\n        return clone(array2);\r\n    } else if (array2 == null) {\r\n        return clone(array1);\r\n    }\r\n    final Class<?> type1 = array1.getClass().getComponentType();\r\n    T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\r\n    System.arraycopy(array1, 0, joinedArray, 0, array1.length);\r\n    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\r\n    \/\/ Check if problem is incompatible types\r\n    return joinedArray;\r\n}","code_comment":"\/**\r\n * <p>Adds all the elements of the given arrays into a new array.<\/p>\r\n * <p>The new array contains all of the element of <code>array1<\/code> followed\r\n * by all of the elements <code>array2<\/code>. When an array is returned, it is always\r\n * a new array.<\/p>\r\n *\r\n * <pre>\r\n * ArrayUtils.addAll(null, null)     = null\r\n * ArrayUtils.addAll(array1, null)   = cloned copy of array1\r\n * ArrayUtils.addAll(null, array2)   = cloned copy of array2\r\n * ArrayUtils.addAll([], [])         = []\r\n * ArrayUtils.addAll([null], [null]) = [null, null]\r\n * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\r\n * <\/pre>\r\n *\r\n * @param array1  the first array whose elements are added to the new array, may be <code>null<\/code>\r\n * @param array2  the second array whose elements are added to the new array, may be <code>null<\/code>\r\n * @return The new array, <code>null<\/code> if both arrays are <code>null<\/code>.\r\n *      The type of the new array is the type of the first array,\r\n *      unless the first array is null, in which case the type is the same as the second array.\r\n * @since 2.1\r\n *\/\r\n","code_no_comment":"@SuppressWarnings(\"unchecked\")\r\npublic static <T> T[] addAll(T[] array1, T... array2) {\r\n    if (array1 == null) {\r\n        return clone(array2);\r\n    } else if (array2 == null) {\r\n        return clone(array1);\r\n    }\r\n    final Class<?> type1 = array1.getClass().getComponentType();\r\n    T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\r\n    System.arraycopy(array1, 0, joinedArray, 0, array1.length);\r\n    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\r\n        return joinedArray;\r\n}","lc":-0.0454545455,"pi":-0.2535885167,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":0.1408730159,"mi":-0.0243833686,"fo":0.0833333333,"r":-0.0263157895,"e":0.1350161074}
{"project_name":"Closure","project_version":"129","label":2,"code":"\/**\r\n * There are two types of calls we are interested in calls without explicit\r\n * \"this\" values (what we are call \"free\" calls) and direct call to eval.\r\n *\/\r\nprivate void annotateCalls(Node n) {\r\n    Preconditions.checkState(n.isCall());\r\n    \/\/ Keep track of of the \"this\" context of a call.  A call without an\r\n    \/\/ explicit \"this\" is a free call.\r\n    Node first = n.getFirstChild();\r\n    if (!NodeUtil.isGet(first)) {\r\n        n.putBooleanProp(Node.FREE_CALL, true);\r\n    }\r\n    \/\/ to distinguish between \"(0, eval)()\" and \"eval()\".\r\n    if (first.isName() && \"eval\".equals(first.getString())) {\r\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\r\n    }\r\n}","code_comment":"\/**\r\n * There are two types of calls we are interested in calls without explicit\r\n * \"this\" values (what we are call \"free\" calls) and direct call to eval.\r\n *\/\r\n","code_no_comment":"private void annotateCalls(Node n) {\r\n    Preconditions.checkState(n.isCall());\r\n            Node first = n.getFirstChild();\r\n    if (!NodeUtil.isGet(first)) {\r\n        n.putBooleanProp(Node.FREE_CALL, true);\r\n    }\r\n        if (first.isName() && \"eval\".equals(first.getString())) {\r\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\r\n    }\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":-0.2,"nbd":-0.5,"ml":0.25,"d":-0.0416666667,"mi":0.17068358,"fo":0.25,"r":0.2894736842,"e":-0.048742818}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"@Override\r\npublic NodeStateBuilder addNode(String name, NodeState nodeState) {\r\n    if (hasChild(name)) {\r\n        return null;\r\n    } else {\r\n        String targetPath = PathUtils.concat(path, name);\r\n        context.addNode(nodeState, targetPath);\r\n        return new KernelNodeStateBuilder(context, targetPath);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic NodeStateBuilder addNode(String name, NodeState nodeState) {\r\n    if (hasChild(name)) {\r\n        return null;\r\n    } else {\r\n        String targetPath = PathUtils.concat(path, name);\r\n        context.addNode(nodeState, targetPath);\r\n        return new KernelNodeStateBuilder(context, targetPath);\r\n    }\r\n}","lc":-0.1818181818,"pi":0.1578947368,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.2349541931,"fo":-0.25,"r":0.1842105263,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7429_43956f93","label":1,"code":"private String takeOffNestTokes(String uri, String prefixToken, String suffixToken) {\r\n    int start = prefixToken.length();\r\n    int end = uri.length() - suffixToken.length();\r\n    return uri.substring(start, end);\r\n}","code_comment":null,"code_no_comment":"private String takeOffNestTokes(String uri, String prefixToken, String suffixToken) {\r\n    int start = prefixToken.length();\r\n    int end = uri.length() - suffixToken.length();\r\n    return uri.substring(start, end);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":0.0515873016,"mi":0.5830866808,"fo":-0.1666666667,"r":0.0263157895,"e":-0.0794937847}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2763_af477563","label":1,"code":"\/\/ --------------------------------------------------------------------------------------------\r\n\/\/ Memory Handling\r\n\/\/ --------------------------------------------------------------------------------------------\r\n\/**\r\n *  Selects a partition and spills it. The number of the spilled partition is returned.\r\n *\r\n *  @return The number of the spilled partition.\r\n *\/\r\nprotected int spillPartition() throws IOException {\r\n    \/\/ find the largest partition\r\n    ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt;\r\n    int largestNumBlocks = 0;\r\n    int largestPartNum = -1;\r\n    for (int i = 0; i < partitions.size(); i++) {\r\n        HashPartition<BT, PT> p = partitions.get(i);\r\n        if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {\r\n            largestNumBlocks = p.getBuildSideBlockCount();\r\n            largestPartNum = i;\r\n        }\r\n    }\r\n    final HashPartition<BT, PT> p = partitions.get(largestPartNum);\r\n    if (useBloomFilters) {\r\n        buildBloomFilterForBucketsInPartition(largestPartNum, p);\r\n    }\r\n    \/\/ spill the partition\r\n    int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, this.currentEnumerator.next(), this.writeBehindBuffers);\r\n    this.writeBehindBuffersAvailable += numBuffersFreed;\r\n    \/\/ grab as many buffers as are available directly\r\n    MemorySegment currBuff;\r\n    while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {\r\n        this.availableMemory.add(currBuff);\r\n        this.writeBehindBuffersAvailable--;\r\n    }\r\n    return largestPartNum;\r\n}","code_comment":"\/**\r\n *  Selects a partition and spills it. The number of the spilled partition is returned.\r\n *\r\n *  @return The number of the spilled partition.\r\n *\/\r\n","code_no_comment":"protected int spillPartition() throws IOException {\r\n        ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt;\r\n    int largestNumBlocks = 0;\r\n    int largestPartNum = -1;\r\n    for (int i = 0; i < partitions.size(); i++) {\r\n        HashPartition<BT, PT> p = partitions.get(i);\r\n        if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {\r\n            largestNumBlocks = p.getBuildSideBlockCount();\r\n            largestPartNum = i;\r\n        }\r\n    }\r\n    final HashPartition<BT, PT> p = partitions.get(largestPartNum);\r\n    if (useBloomFilters) {\r\n        buildBloomFilterForBucketsInPartition(largestPartNum, p);\r\n    }\r\n        int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, this.currentEnumerator.next(), this.writeBehindBuffers);\r\n    this.writeBehindBuffersAvailable += numBuffersFreed;\r\n        MemorySegment currBuff;\r\n    while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {\r\n        this.availableMemory.add(currBuff);\r\n        this.writeBehindBuffersAvailable--;\r\n    }\r\n    return largestPartNum;\r\n}","lc":0.4545454545,"pi":-0.004784689,"ma":0.2,"nbd":0.0,"ml":0.6666666667,"d":1.3174603175,"mi":-0.4128259338,"fo":0.4166666667,"r":-0.0263157895,"e":1.7356385033}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"\/\/ ------------------------------------------------------------< private >---\r\nprivate TreeImpl internalGetChild(String childName) {\r\n    return getNodeBuilder().hasChildNode(childName) ? new TreeImpl(root, this, childName) : null;\r\n}","code_comment":null,"code_no_comment":"private TreeImpl internalGetChild(String childName) {\r\n    return getNodeBuilder().hasChildNode(childName) ? new TreeImpl(root, this, childName) : null;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.9295278365,"fo":-0.3333333333,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3110_d10362c0","label":1,"code":"public Directory wrapForWrite(IndexDefinition definition, Directory remote, boolean reindexMode) throws IOException {\r\n    Directory local = createLocalDirForIndexWriter(definition);\r\n    return new CopyOnWriteDirectory(remote, local, reindexMode, getIndexPathForLogging(definition));\r\n}","code_comment":null,"code_no_comment":"public Directory wrapForWrite(IndexDefinition definition, Directory remote, boolean reindexMode) throws IOException {\r\n    Directory local = createLocalDirForIndexWriter(definition);\r\n    return new CopyOnWriteDirectory(remote, local, reindexMode, getIndexPathForLogging(definition));\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7071176885,"fo":-0.3333333333,"r":0.0526315789,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3314_4badd9c5","label":1,"code":"\/**\r\n * Creates the processor and wraps it in any necessary interceptors and error handlers\r\n *\/\r\nprotected Processor makeProcessor(RouteContext routeContext) throws Exception {\r\n    Processor processor = null;\r\n    \/\/ resolve properties before we create the processor\r\n    resolvePropertyPlaceholders(routeContext);\r\n    \/\/ at first use custom factory\r\n    if (routeContext.getCamelContext().getProcessorFactory() != null) {\r\n        processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, this);\r\n    }\r\n    \/\/ fallback to default implementation if factory did not create the processor\r\n    if (processor == null) {\r\n        processor = createProcessor(routeContext);\r\n    }\r\n    if (processor == null) {\r\n        \/\/ no processor to make\r\n        return null;\r\n    }\r\n    return wrapProcessor(routeContext, processor);\r\n}","code_comment":"\/**\r\n * Creates the processor and wraps it in any necessary interceptors and error handlers\r\n *\/\r\n","code_no_comment":"protected Processor makeProcessor(RouteContext routeContext) throws Exception {\r\n    Processor processor = null;\r\n        resolvePropertyPlaceholders(routeContext);\r\n        if (routeContext.getCamelContext().getProcessorFactory() != null) {\r\n        processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, this);\r\n    }\r\n        if (processor == null) {\r\n        processor = createProcessor(routeContext);\r\n    }\r\n    if (processor == null) {\r\n                return null;\r\n    }\r\n    return wrapProcessor(routeContext, processor);\r\n}","lc":0.0,"pi":-0.2966507177,"ma":0.0,"nbd":-0.5,"ml":0.0,"d":0.123015873,"mi":0.0100070472,"fo":0.1666666667,"r":0.0263157895,"e":0.0097024602}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1820_39d526e6","label":0,"code":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, DoubleValue reusable) {\r\n    int i = startPos;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    while (i < limit) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            break;\r\n        }\r\n        i++;\r\n    }\r\n    String str = new String(bytes, startPos, i - startPos);\r\n    try {\r\n        double value = Double.parseDouble(str);\r\n        reusable.setValue(value);\r\n        this.result = reusable;\r\n        return (i == limit) ? limit : i + delimiter.length;\r\n    } catch (NumberFormatException e) {\r\n        setErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);\r\n        return -1;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, DoubleValue reusable) {\r\n    int i = startPos;\r\n    final int delimLimit = limit - delimiter.length + 1;\r\n    while (i < limit) {\r\n        if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\r\n            break;\r\n        }\r\n        i++;\r\n    }\r\n    String str = new String(bytes, startPos, i - startPos);\r\n    try {\r\n        double value = Double.parseDouble(str);\r\n        reusable.setValue(value);\r\n        this.result = reusable;\r\n        return (i == limit) ? limit : i + delimiter.length;\r\n    } catch (NumberFormatException e) {\r\n        setErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);\r\n        return -1;\r\n    }\r\n}","lc":0.3181818182,"pi":0.0717703349,"ma":0.4,"nbd":0.0,"ml":0.4166666667,"d":0.8492063492,"mi":-0.3073995772,"fo":-0.1666666667,"r":0.0,"e":0.8043129729}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-3131_f6f4ef5e","label":1,"code":"private static void decomposeParameterIntoUserInstructions(MojoDescriptor mojo, Parameter param, StringBuilder messageBuffer) {\r\n    String expression = param.getExpression();\r\n    if (param.isEditable()) {\r\n        boolean isArray = param.getType().endsWith(\"[]\");\r\n        boolean isCollection = false;\r\n        boolean isMap = false;\r\n        if (!isArray) {\r\n            try {\r\n                \/\/ assuming Type is available in current ClassLoader\r\n                isCollection = Collection.class.isAssignableFrom(Class.forName(param.getType()));\r\n                isMap = Map.class.isAssignableFrom(Class.forName(param.getType()));\r\n            } catch (ClassNotFoundException e) {\r\n            \/\/ assume it is not assignable from Collection or Map\r\n            }\r\n        }\r\n        messageBuffer.append(\"Inside the definition for plugin \\'\");\r\n        messageBuffer.append(mojo.getPluginDescriptor().getArtifactId());\r\n        messageBuffer.append(\"\\', specify the following:\\n\\n<configuration>\\n  ...\\n\");\r\n        messageBuffer.append(\"  <\").append(param.getName()).append('>');\r\n        if (isArray || isCollection) {\r\n            messageBuffer.append('\\n');\r\n            messageBuffer.append(\"    <item>\");\r\n        } else if (isMap) {\r\n            messageBuffer.append('\\n');\r\n            messageBuffer.append(\"    <KEY>\");\r\n        }\r\n        messageBuffer.append(\"VALUE\");\r\n        if (isArray || isCollection) {\r\n            messageBuffer.append(\"<\/item>\\n\");\r\n            messageBuffer.append(\"  \");\r\n        } else if (isMap) {\r\n            messageBuffer.append(\"<\/KEY>\\n\");\r\n            messageBuffer.append(\"  \");\r\n        }\r\n        messageBuffer.append(\"<\/\").append(param.getName()).append(\">\\n\");\r\n        messageBuffer.append(\"<\/configuration>\");\r\n        String alias = param.getAlias();\r\n        if (StringUtils.isNotEmpty(alias) && !alias.equals(param.getName())) {\r\n            messageBuffer.append(\"\\n\\n-OR-\\n\\n<configuration>\\n  ...\\n  <\" + alias + \">VALUE<\/\" + alias + \">\\n<\/configuration>\\n\");\r\n        }\r\n    }\r\n    if (StringUtils.isEmpty(expression)) {\r\n        messageBuffer.append(\".\");\r\n    } else {\r\n        if (param.isEditable()) {\r\n            messageBuffer.append(\"\\n\\n-OR-\\n\\n\");\r\n        }\r\n    \/\/ addParameterUsageInfo( expression, messageBuffer );\r\n    }\r\n}","code_comment":null,"code_no_comment":"private static void decomposeParameterIntoUserInstructions(MojoDescriptor mojo, Parameter param, StringBuilder messageBuffer) {\r\n    String expression = param.getExpression();\r\n    if (param.isEditable()) {\r\n        boolean isArray = param.getType().endsWith(\"[]\");\r\n        boolean isCollection = false;\r\n        boolean isMap = false;\r\n        if (!isArray) {\r\n            try {\r\n                                isCollection = Collection.class.isAssignableFrom(Class.forName(param.getType()));\r\n                isMap = Map.class.isAssignableFrom(Class.forName(param.getType()));\r\n            } catch (ClassNotFoundException e) {\r\n                        }\r\n        }\r\n        messageBuffer.append(\"Inside the definition for plugin \\'\");\r\n        messageBuffer.append(mojo.getPluginDescriptor().getArtifactId());\r\n        messageBuffer.append(\"\\', specify the following:\\n\\n<configuration>\\n  ...\\n\");\r\n        messageBuffer.append(\"  <\").append(param.getName()).append('>');\r\n        if (isArray || isCollection) {\r\n            messageBuffer.append('\\n');\r\n            messageBuffer.append(\"    <item>\");\r\n        } else if (isMap) {\r\n            messageBuffer.append('\\n');\r\n            messageBuffer.append(\"    <KEY>\");\r\n        }\r\n        messageBuffer.append(\"VALUE\");\r\n        if (isArray || isCollection) {\r\n            messageBuffer.append(\"<\/item>\\n\");\r\n            messageBuffer.append(\"  \");\r\n        } else if (isMap) {\r\n            messageBuffer.append(\"<\/KEY>\\n\");\r\n            messageBuffer.append(\"  \");\r\n        }\r\n        messageBuffer.append(\"<\/\").append(param.getName()).append(\">\\n\");\r\n        messageBuffer.append(\"<\/configuration>\");\r\n        String alias = param.getAlias();\r\n        if (StringUtils.isNotEmpty(alias) && !alias.equals(param.getName())) {\r\n            messageBuffer.append(\"\\n\\n-OR-\\n\\n<configuration>\\n  ...\\n  <\" + alias + \">VALUE<\/\" + alias + \">\\n<\/configuration>\\n\");\r\n        }\r\n    }\r\n    if (StringUtils.isEmpty(expression)) {\r\n        messageBuffer.append(\".\");\r\n    } else {\r\n        if (param.isEditable()) {\r\n            messageBuffer.append(\"\\n\\n-OR-\\n\\n\");\r\n        }\r\n        }\r\n}","lc":1.5,"pi":0.1961722488,"ma":1.4,"nbd":0.5,"ml":1.4166666667,"d":0.5873015873,"mi":-0.8418604651,"fo":3.0,"r":-0.0263157895,"e":1.73260951}
{"project_name":"Closure","project_version":"84","label":2,"code":"@Override\r\nNode processUnaryExpression(UnaryExpression exprNode) {\r\n    int type = transformTokenType(exprNode.getType());\r\n    Node operand = transform(exprNode.getOperand());\r\n    if (type == Token.NEG && operand.getType() == Token.NUMBER) {\r\n        operand.setDouble(-operand.getDouble());\r\n        return operand;\r\n    } else {\r\n        Node node = newNode(type, operand);\r\n        if (exprNode.isPostfix()) {\r\n            node.putBooleanProp(Node.INCRDECR_PROP, true);\r\n        }\r\n        return node;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\nNode processUnaryExpression(UnaryExpression exprNode) {\r\n    int type = transformTokenType(exprNode.getType());\r\n    Node operand = transform(exprNode.getOperand());\r\n    if (type == Token.NEG && operand.getType() == Token.NUMBER) {\r\n        operand.setDouble(-operand.getDouble());\r\n        return operand;\r\n    } else {\r\n        Node node = newNode(type, operand);\r\n        if (exprNode.isPostfix()) {\r\n            node.putBooleanProp(Node.INCRDECR_PROP, true);\r\n        }\r\n        return node;\r\n    }\r\n}","lc":0.0454545455,"pi":0.2344497608,"ma":-0.2,"nbd":0.0,"ml":0.0833333333,"d":0.3253968254,"mi":-0.0714587738,"fo":0.3333333333,"r":-0.0263157895,"e":0.1955775315}
{"project_name":"Lang","project_version":"53","label":1,"code":"\/\/ -----------------------------------------------------------------------\r\n\/**\r\n * <p>Internal calculation method.<\/p>\r\n *\r\n * @param val  the calendar\r\n * @param field  the field constant\r\n * @param round  true to round, false to truncate\r\n * @throws ArithmeticException if the year is over 280 million\r\n *\/\r\nprivate static void modify(Calendar val, int field, boolean round) {\r\n    if (val.get(Calendar.YEAR) > 280000000) {\r\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\r\n    }\r\n    if (field == Calendar.MILLISECOND) {\r\n        return;\r\n    }\r\n    \/\/ ----------------- Fix for LANG-59 ---------------------- START ---------------\r\n    \/\/ see http:\/\/issues.apache.org\/jira\/browse\/LANG-59\r\n    \/\/ \r\n    \/\/ Manually truncate milliseconds, seconds and minutes, rather than using\r\n    \/\/ Calendar methods.\r\n    Date date = val.getTime();\r\n    long time = date.getTime();\r\n    boolean done = false;\r\n    \/\/ truncate milliseconds\r\n    int millisecs = val.get(Calendar.MILLISECOND);\r\n    if (!round || millisecs < 500) {\r\n        time = time - millisecs;\r\n        if (field == Calendar.SECOND) {\r\n            done = true;\r\n        }\r\n    }\r\n    \/\/ truncate seconds\r\n    int seconds = val.get(Calendar.SECOND);\r\n    if (!done && (!round || seconds < 30)) {\r\n        time = time - (seconds * 1000L);\r\n        if (field == Calendar.MINUTE) {\r\n            done = true;\r\n        }\r\n    }\r\n    \/\/ truncate minutes\r\n    int minutes = val.get(Calendar.MINUTE);\r\n    if (!done && (!round || minutes < 30)) {\r\n        time = time - (minutes * 60000L);\r\n    }\r\n    \/\/ reset time\r\n    if (date.getTime() != time) {\r\n        date.setTime(time);\r\n        val.setTime(date);\r\n    }\r\n    \/\/ ----------------- Fix for LANG-59 ----------------------- END ----------------\r\n    boolean roundUp = false;\r\n    for (int i = 0; i < fields.length; i++) {\r\n        for (int j = 0; j < fields[i].length; j++) {\r\n            if (fields[i][j] == field) {\r\n                \/\/ This is our field... we stop looping\r\n                if (round && roundUp) {\r\n                    if (field == DateUtils.SEMI_MONTH) {\r\n                        \/\/ we subtract 15 days and add 1 month\r\n                        if (val.get(Calendar.DATE) == 1) {\r\n                            val.add(Calendar.DATE, 15);\r\n                        } else {\r\n                            val.add(Calendar.DATE, -15);\r\n                            val.add(Calendar.MONTH, 1);\r\n                        }\r\n                    } else {\r\n                        \/\/ We need at add one to this field since the\r\n                        \/\/ last number causes us to round up\r\n                        val.add(fields[i][0], 1);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        \/\/ We have various fields that are not easy roundings\r\n        int offset = 0;\r\n        boolean offsetSet = false;\r\n        \/\/ These are special types of fields that require different rounding rules\r\n        switch(field) {\r\n            case DateUtils.SEMI_MONTH:\r\n                if (fields[i][0] == Calendar.DATE) {\r\n                    \/\/ If we're going to drop the DATE field's value,\r\n                    \/\/ we want to do this our own way.\r\n                    \/\/ We need to subtrace 1 since the date has a minimum of 1\r\n                    offset = val.get(Calendar.DATE) - 1;\r\n                    \/\/ bottom half of the month and should stay accordingly.\r\n                    if (offset >= 15) {\r\n                        offset -= 15;\r\n                    }\r\n                    \/\/ Record whether we're in the top or bottom half of that range\r\n                    roundUp = offset > 7;\r\n                    offsetSet = true;\r\n                }\r\n                break;\r\n            case Calendar.AM_PM:\r\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\r\n                    \/\/ If we're going to drop the HOUR field's value,\r\n                    \/\/ we want to do this our own way.\r\n                    offset = val.get(Calendar.HOUR_OF_DAY);\r\n                    if (offset >= 12) {\r\n                        offset -= 12;\r\n                    }\r\n                    roundUp = offset > 6;\r\n                    offsetSet = true;\r\n                }\r\n                break;\r\n        }\r\n        if (!offsetSet) {\r\n            int min = val.getActualMinimum(fields[i][0]);\r\n            int max = val.getActualMaximum(fields[i][0]);\r\n            \/\/ Calculate the offset from the minimum allowed value\r\n            offset = val.get(fields[i][0]) - min;\r\n            \/\/ Set roundUp if this is more than half way between the minimum and maximum\r\n            roundUp = offset > ((max - min) \/ 2);\r\n        }\r\n        \/\/ We need to remove this field\r\n        if (offset != 0) {\r\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\r\n}","code_comment":"\/**\r\n * <p>Internal calculation method.<\/p>\r\n *\r\n * @param val  the calendar\r\n * @param field  the field constant\r\n * @param round  true to round, false to truncate\r\n * @throws ArithmeticException if the year is over 280 million\r\n *\/\r\n","code_no_comment":"private static void modify(Calendar val, int field, boolean round) {\r\n    if (val.get(Calendar.YEAR) > 280000000) {\r\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\r\n    }\r\n    if (field == Calendar.MILLISECOND) {\r\n        return;\r\n    }\r\n                        Date date = val.getTime();\r\n    long time = date.getTime();\r\n    boolean done = false;\r\n        int millisecs = val.get(Calendar.MILLISECOND);\r\n    if (!round || millisecs < 500) {\r\n        time = time - millisecs;\r\n        if (field == Calendar.SECOND) {\r\n            done = true;\r\n        }\r\n    }\r\n        int seconds = val.get(Calendar.SECOND);\r\n    if (!done && (!round || seconds < 30)) {\r\n        time = time - (seconds * 1000L);\r\n        if (field == Calendar.MINUTE) {\r\n            done = true;\r\n        }\r\n    }\r\n        int minutes = val.get(Calendar.MINUTE);\r\n    if (!done && (!round || minutes < 30)) {\r\n        time = time - (minutes * 60000L);\r\n    }\r\n        if (date.getTime() != time) {\r\n        date.setTime(time);\r\n        val.setTime(date);\r\n    }\r\n        boolean roundUp = false;\r\n    for (int i = 0; i < fields.length; i++) {\r\n        for (int j = 0; j < fields[i].length; j++) {\r\n            if (fields[i][j] == field) {\r\n                                if (round && roundUp) {\r\n                    if (field == DateUtils.SEMI_MONTH) {\r\n                                                if (val.get(Calendar.DATE) == 1) {\r\n                            val.add(Calendar.DATE, 15);\r\n                        } else {\r\n                            val.add(Calendar.DATE, -15);\r\n                            val.add(Calendar.MONTH, 1);\r\n                        }\r\n                    } else {\r\n                                                                        val.add(fields[i][0], 1);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n        }\r\n                int offset = 0;\r\n        boolean offsetSet = false;\r\n                switch(field) {\r\n            case DateUtils.SEMI_MONTH:\r\n                if (fields[i][0] == Calendar.DATE) {\r\n                                                                                offset = val.get(Calendar.DATE) - 1;\r\n                                        if (offset >= 15) {\r\n                        offset -= 15;\r\n                    }\r\n                                        roundUp = offset > 7;\r\n                    offsetSet = true;\r\n                }\r\n                break;\r\n            case Calendar.AM_PM:\r\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\r\n                                                            offset = val.get(Calendar.HOUR_OF_DAY);\r\n                    if (offset >= 12) {\r\n                        offset -= 12;\r\n                    }\r\n                    roundUp = offset > 6;\r\n                    offsetSet = true;\r\n                }\r\n                break;\r\n        }\r\n        if (!offsetSet) {\r\n            int min = val.getActualMinimum(fields[i][0]);\r\n            int max = val.getActualMaximum(fields[i][0]);\r\n                        offset = val.get(fields[i][0]) - min;\r\n                        roundUp = offset > ((max - min) \/ 2);\r\n        }\r\n                if (offset != 0) {\r\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\r\n}","lc":3.3181818182,"pi":2.0622009569,"ma":4.6,"nbd":2.0,"ml":3.3333333333,"d":4.9265873016,"mi":-1.3382663848,"fo":1.25,"r":-0.0263157895,"e":22.3674210335}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-579_7d72e6ed","label":3,"code":"@Override\r\npublic void restrict(FilterImpl f) {\r\n    if (f.getSelector() == parentSelector) {\r\n        String c = childSelector.currentPath();\r\n        if (c != null) {\r\n            f.restrictPath(PathUtils.getParentPath(c), Filter.PathRestriction.EXACT);\r\n        }\r\n    }\r\n    if (f.getSelector() == childSelector) {\r\n        String p = parentSelector.currentPath();\r\n        if (p != null) {\r\n            f.restrictPath(p, Filter.PathRestriction.DIRECT_CHILDREN);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void restrict(FilterImpl f) {\r\n    if (f.getSelector() == parentSelector) {\r\n        String c = childSelector.currentPath();\r\n        if (c != null) {\r\n            f.restrictPath(PathUtils.getParentPath(c), Filter.PathRestriction.EXACT);\r\n        }\r\n    }\r\n    if (f.getSelector() == childSelector) {\r\n        String p = parentSelector.currentPath();\r\n        if (p != null) {\r\n            f.restrictPath(p, Filter.PathRestriction.DIRECT_CHILDREN);\r\n        }\r\n    }\r\n}","lc":0.0454545455,"pi":0.4019138756,"ma":0.2,"nbd":0.0,"ml":0.3333333333,"d":0.001984127,"mi":-0.0641296688,"fo":0.0833333333,"r":0.0789473684,"e":0.0031096742}
{"project_name":"Closure","project_version":"26","label":2,"code":"\/**\r\n * Rewrite module.exports to moduleName.module$exports.\r\n *\/\r\nprivate void visitModuleExports(Node prop) {\r\n    String moduleName = guessCJSModuleName(prop.getSourceFileName());\r\n    Node module = prop.getChildAtIndex(0);\r\n    module.putProp(Node.ORIGINALNAME_PROP, \"module\");\r\n    module.setString(moduleName);\r\n    Node exports = prop.getChildAtIndex(1);\r\n    exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\r\n    exports.setString(\"module$exports\");\r\n}","code_comment":"\/**\r\n * Rewrite module.exports to moduleName.module$exports.\r\n *\/\r\n","code_no_comment":"private void visitModuleExports(Node prop) {\r\n    String moduleName = guessCJSModuleName(prop.getSourceFileName());\r\n    Node module = prop.getChildAtIndex(0);\r\n    module.putProp(Node.ORIGINALNAME_PROP, \"module\");\r\n    module.setString(moduleName);\r\n    Node exports = prop.getChildAtIndex(1);\r\n    exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\r\n    exports.setString(\"module$exports\");\r\n}","lc":-0.2272727273,"pi":-0.6363636364,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.2250880902,"fo":0.1666666667,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_46f62443","label":1,"code":"@Override\r\npublic void rename(String oldTableName, String newTableName) throws AccumuloSecurityException, TableNotFoundException, AccumuloException, TableExistsException {\r\n    MockTable t = acu.tables.remove(oldTableName);\r\n    acu.tables.put(newTableName, t);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void rename(String oldTableName, String newTableName) throws AccumuloSecurityException, TableNotFoundException, AccumuloException, TableExistsException {\r\n    MockTable t = acu.tables.remove(oldTableName);\r\n    acu.tables.put(newTableName, t);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5701198027,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-151_b007b22e","label":1,"code":"\/*\r\n   * Sets the topKey and topValue based on the top key of the source. If the column of the source top key is in the set of combiners, or if there are no columns\r\n   * in the set of combiners, topKey will be the top key of the source and topValue will be the result of the reduce method. Otherwise, topKey and topValue will\r\n   * be null.\r\n   *\/\r\nprivate void findTop() throws IOException {\r\n    \/\/ check if aggregation is needed\r\n    if (super.hasTop()) {\r\n        workKey.set(super.getTopKey());\r\n        if (combiners.isEmpty() || combiners.contains(workKey)) {\r\n            if (workKey.isDeleted())\r\n                return;\r\n            topKey = workKey;\r\n            Iterator<Value> viter = new ValueIterator(getSource());\r\n            topValue = reduce(topKey, viter);\r\n            while (viter.hasNext()) viter.next();\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void findTop() throws IOException {\r\n        if (super.hasTop()) {\r\n        workKey.set(super.getTopKey());\r\n        if (combiners.isEmpty() || combiners.contains(workKey)) {\r\n            if (workKey.isDeleted())\r\n                return;\r\n            topKey = workKey;\r\n            Iterator<Value> viter = new ValueIterator(getSource());\r\n            topValue = reduce(topKey, viter);\r\n            while (viter.hasNext()) viter.next();\r\n        }\r\n    }\r\n}","lc":-0.0454545455,"pi":0.8803827751,"ma":0.2,"nbd":0.0,"ml":0.5,"d":-0.0912698413,"mi":0.0401691332,"fo":0.3333333333,"r":-0.0263157895,"e":-0.0677512491}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5565_204849bc","label":1,"code":"\/**\r\n *  @see AbstractBookmarkableMapper#getCompatibilityScore(org.apache.wicket.request.Request)\r\n *\/\r\n@Override\r\npublic int getCompatibilityScore(Request request) {\r\n    if (urlStartsWith(request.getUrl(), mountSegments)) {\r\n        \/* see WICKET-5056 - alter score with pathSegment type *\/\r\n        int countOptional = 0;\r\n        int fixedSegments = 0;\r\n        for (MountPathSegment pathSegment : pathSegments) {\r\n            fixedSegments += pathSegment.getFixedPartSize();\r\n            countOptional += pathSegment.getOptionalParameters();\r\n        }\r\n        return mountSegments.length - countOptional + fixedSegments;\r\n    } else {\r\n        return 0;\r\n    }\r\n}","code_comment":"\/**\r\n *  @see AbstractBookmarkableMapper#getCompatibilityScore(org.apache.wicket.request.Request)\r\n *\/\r\n","code_no_comment":"@Override\r\npublic int getCompatibilityScore(Request request) {\r\n    if (urlStartsWith(request.getUrl(), mountSegments)) {\r\n                int countOptional = 0;\r\n        int fixedSegments = 0;\r\n        for (MountPathSegment pathSegment : pathSegments) {\r\n            fixedSegments += pathSegment.getFixedPartSize();\r\n            countOptional += pathSegment.getOptionalParameters();\r\n        }\r\n        return mountSegments.length - countOptional + fixedSegments;\r\n    } else {\r\n        return 0;\r\n    }\r\n}","lc":0.0,"pi":0.4497607656,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":0.2658730159,"mi":0.0235377026,"fo":-0.1666666667,"r":0.2894736842,"e":0.049475862}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4072_7d5b8645","label":1,"code":"\/**\r\n *  Makes this url the result of resolving the {@code relative} url against this url.\r\n *  <p>\r\n *  Segments will be properly resolved, handling any {@code ..} references, while the query\r\n *  parameters will be completely replaced with {@code relative}'s query parameters.\r\n *  <\/p>\r\n *  <p>\r\n *  For example:\r\n *\r\n *  <pre>\r\n *  wicket\/page\/render?foo=bar\r\n *  <\/pre>\r\n *\r\n *  resolved with\r\n *\r\n *  <pre>\r\n *  ..\/component\/render?a=b\r\n *  <\/pre>\r\n *\r\n *  will become\r\n *\r\n *  <pre>\r\n *  wicket\/component\/render?a=b\r\n *  <\/pre>\r\n *\r\n *  <\/p>\r\n *\r\n *  @param relative\r\n *             relative url\r\n *\/\r\npublic void resolveRelative(final Url relative) {\r\n    \/\/ strip the first non-folder segment\r\n    getSegments().remove(getSegments().size() - 1);\r\n    \/\/ remove all '.\/' (current folder) from the relative url\r\n    if (!relative.getSegments().isEmpty() && \".\".equals(relative.getSegments().get(0))) {\r\n        relative.getSegments().remove(0);\r\n    }\r\n    \/\/ process any ..\/ segments in the relative url\r\n    while (!relative.getSegments().isEmpty() && \"..\".equals(relative.getSegments().get(0))) {\r\n        relative.getSegments().remove(0);\r\n        getSegments().remove(getSegments().size() - 1);\r\n    }\r\n    \/\/ append the remaining relative segments\r\n    getSegments().addAll(relative.getSegments());\r\n    \/\/ replace query params with the ones from relative\r\n    parameters.clear();\r\n    parameters.addAll(relative.getQueryParameters());\r\n}","code_comment":"\/**\r\n *  Makes this url the result of resolving the {@code relative} url against this url.\r\n *  <p>\r\n *  Segments will be properly resolved, handling any {@code ..} references, while the query\r\n *  parameters will be completely replaced with {@code relative}'s query parameters.\r\n *  <\/p>\r\n *  <p>\r\n *  For example:\r\n *\r\n *  <pre>\r\n *  wicket\/page\/render?foo=bar\r\n *  <\/pre>\r\n *\r\n *  resolved with\r\n *\r\n *  <pre>\r\n *  ..\/component\/render?a=b\r\n *  <\/pre>\r\n *\r\n *  will become\r\n *\r\n *  <pre>\r\n *  wicket\/component\/render?a=b\r\n *  <\/pre>\r\n *\r\n *  <\/p>\r\n *\r\n *  @param relative\r\n *             relative url\r\n *\/\r\n","code_no_comment":"public void resolveRelative(final Url relative) {\r\n        getSegments().remove(getSegments().size() - 1);\r\n        if (!relative.getSegments().isEmpty() && \".\".equals(relative.getSegments().get(0))) {\r\n        relative.getSegments().remove(0);\r\n    }\r\n        while (!relative.getSegments().isEmpty() && \"..\".equals(relative.getSegments().get(0))) {\r\n        relative.getSegments().remove(0);\r\n        getSegments().remove(getSegments().size() - 1);\r\n    }\r\n        getSegments().addAll(relative.getSegments());\r\n        parameters.clear();\r\n    parameters.addAll(relative.getQueryParameters());\r\n}","lc":-0.0454545455,"pi":-0.2535885167,"ma":-0.2,"nbd":-0.5,"ml":0.25,"d":0.1865079365,"mi":-0.0201550388,"fo":1.8333333333,"r":-0.0263157895,"e":0.1522080646}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-498_f2a2edec","label":1,"code":"@Override\r\npublic boolean name(String name, int index) {\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean name(String name, int index) {\r\n    return true;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9134601832,"fo":-0.5,"r":1.6842105263,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-412_be2fdba7","label":1,"code":"public void run() {\r\n    List<TabletLocation> tabletsToAssignMapFileTo = Collections.emptyList();\r\n    try {\r\n        tabletsToAssignMapFileTo = findOverlappingTablets(instance.getConfiguration(), fs, locator, mapFile);\r\n    } catch (Exception ex) {\r\n        log.warn(\"Unable to find tablets that overlap file \" + mapFile.toString());\r\n    }\r\n    if (tabletsToAssignMapFileTo.size() == 0) {\r\n        List<KeyExtent> empty = Collections.emptyList();\r\n        completeFailures.put(mapFile, empty);\r\n    } else\r\n        assignments.put(mapFile, tabletsToAssignMapFileTo);\r\n}","code_comment":null,"code_no_comment":"public void run() {\r\n    List<TabletLocation> tabletsToAssignMapFileTo = Collections.emptyList();\r\n    try {\r\n        tabletsToAssignMapFileTo = findOverlappingTablets(instance.getConfiguration(), fs, locator, mapFile);\r\n    } catch (Exception ex) {\r\n        log.warn(\"Unable to find tablets that overlap file \" + mapFile.toString());\r\n    }\r\n    if (tabletsToAssignMapFileTo.size() == 0) {\r\n        List<KeyExtent> empty = Collections.emptyList();\r\n        completeFailures.put(mapFile, empty);\r\n    } else\r\n        assignments.put(mapFile, tabletsToAssignMapFileTo);\r\n}","lc":-0.0454545455,"pi":-0.0956937799,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0833333333,"mi":0.0071881607,"fo":0.25,"r":0.0,"e":-0.0289275773}
{"project_name":"Cli","project_version":"34","label":3,"code":"\/**\r\n * Resets the member variables to their default values.\r\n *\/\r\nprivate static void reset() {\r\n    description = null;\r\n    argName = null;\r\n    longopt = null;\r\n    type = null;\r\n    required = false;\r\n    numberOfArgs = Option.UNINITIALIZED;\r\n    optionalArg = false;\r\n    valuesep = (char) 0;\r\n}","code_comment":"\/**\r\n * Resets the member variables to their default values.\r\n *\/\r\n","code_no_comment":"private static void reset() {\r\n    description = null;\r\n    argName = null;\r\n    longopt = null;\r\n    type = null;\r\n    required = false;\r\n    numberOfArgs = Option.UNINITIALIZED;\r\n    optionalArg = false;\r\n    valuesep = (char) 0;\r\n}","lc":-0.1818181818,"pi":-0.6650717703,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.2332628612,"fo":-0.5,"r":2.4473684211,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2520_a64151e6","label":0,"code":"private SortedMap<String, String> makeRelative(Collection<String> candidates) {\r\n    SortedMap<String, String> ret = new TreeMap<String, String>();\r\n    for (String candidate : candidates) {\r\n        String relPath = makeRelative(candidate, 0);\r\n        ret.put(relPath, candidate);\r\n    }\r\n    return ret;\r\n}","code_comment":null,"code_no_comment":"private SortedMap<String, String> makeRelative(Collection<String> candidates) {\r\n    SortedMap<String, String> ret = new TreeMap<String, String>();\r\n    for (String candidate : candidates) {\r\n        String relPath = makeRelative(candidate, 0);\r\n        ret.put(relPath, candidate);\r\n    }\r\n    return ret;\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.3245947851,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Closure","project_version":"134","label":2,"code":"public void process(Node externs, Node root) {\r\n    NodeTraversal.traverse(compiler, externs, new ProcessExterns());\r\n    NodeTraversal.traverse(compiler, root, new ProcessProperties());\r\n    Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size());\r\n    reservedNames.addAll(externedNames);\r\n    reservedNames.addAll(quotedNames);\r\n    int numRenamedPropertyNames = 0;\r\n    int numSkippedPropertyNames = 0;\r\n    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);\r\n    for (Property p : propertyMap.values()) {\r\n        if (!p.skipAmbiguating) {\r\n            ++numRenamedPropertyNames;\r\n            computeRelatedTypes(p.type);\r\n            propsByFreq.add(p);\r\n        } else {\r\n            ++numSkippedPropertyNames;\r\n            reservedNames.add(p.oldName);\r\n        }\r\n    }\r\n    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));\r\n    GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);\r\n    int numNewPropertyNames = coloring.color();\r\n    NameGenerator nameGen = new NameGenerator(reservedNames, \"\", reservedCharacters);\r\n    for (int i = 0; i < numNewPropertyNames; ++i) {\r\n        colorMap.put(i, nameGen.generateNextName());\r\n    }\r\n    for (GraphNode<Property, Void> node : graph.getNodes()) {\r\n        node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());\r\n        renamingMap.put(node.getValue().oldName, node.getValue().newName);\r\n    }\r\n    \/\/ Update the string nodes.\r\n    for (Node n : stringNodesToRename) {\r\n        String oldName = n.getString();\r\n        Property p = propertyMap.get(oldName);\r\n        if (p != null && p.newName != null) {\r\n            Preconditions.checkState(oldName.equals(p.oldName));\r\n            if (!p.newName.equals(oldName)) {\r\n                n.setString(p.newName);\r\n                compiler.reportCodeChange();\r\n            }\r\n        }\r\n    }\r\n    logger.info(\"Collapsed \" + numRenamedPropertyNames + \" properties into \" + numNewPropertyNames + \" and skipped renaming \" + numSkippedPropertyNames + \" properties.\");\r\n}","code_comment":null,"code_no_comment":"public void process(Node externs, Node root) {\r\n    NodeTraversal.traverse(compiler, externs, new ProcessExterns());\r\n    NodeTraversal.traverse(compiler, root, new ProcessProperties());\r\n    Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size());\r\n    reservedNames.addAll(externedNames);\r\n    reservedNames.addAll(quotedNames);\r\n    int numRenamedPropertyNames = 0;\r\n    int numSkippedPropertyNames = 0;\r\n    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);\r\n    for (Property p : propertyMap.values()) {\r\n        if (!p.skipAmbiguating) {\r\n            ++numRenamedPropertyNames;\r\n            computeRelatedTypes(p.type);\r\n            propsByFreq.add(p);\r\n        } else {\r\n            ++numSkippedPropertyNames;\r\n            reservedNames.add(p.oldName);\r\n        }\r\n    }\r\n    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));\r\n    GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);\r\n    int numNewPropertyNames = coloring.color();\r\n    NameGenerator nameGen = new NameGenerator(reservedNames, \"\", reservedCharacters);\r\n    for (int i = 0; i < numNewPropertyNames; ++i) {\r\n        colorMap.put(i, nameGen.generateNextName());\r\n    }\r\n    for (GraphNode<Property, Void> node : graph.getNodes()) {\r\n        node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());\r\n        renamingMap.put(node.getValue().oldName, node.getValue().newName);\r\n    }\r\n        for (Node n : stringNodesToRename) {\r\n        String oldName = n.getString();\r\n        Property p = propertyMap.get(oldName);\r\n        if (p != null && p.newName != null) {\r\n            Preconditions.checkState(oldName.equals(p.oldName));\r\n            if (!p.newName.equals(oldName)) {\r\n                n.setString(p.newName);\r\n                compiler.reportCodeChange();\r\n            }\r\n        }\r\n    }\r\n    logger.info(\"Collapsed \" + numRenamedPropertyNames + \" properties into \" + numNewPropertyNames + \" and skipped renaming \" + numSkippedPropertyNames + \" properties.\");\r\n}","lc":1.3181818182,"pi":0.4401913876,"ma":0.8,"nbd":0.5,"ml":0.5833333333,"d":0.880952381,"mi":-0.8241014799,"fo":2.0,"r":-0.0263157895,"e":3.1504642036}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1133_02c08456","label":1,"code":"private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> returnTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {\r\n    TypeInformation<?> info = null;\r\n    \/\/ the input is a type variable\r\n    if (inType instanceof TypeVariable) {\r\n        inType = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) inType);\r\n        info = findCorrespondingInfo(returnTypeVar, inType, inTypeInfo);\r\n    } else \/\/ the input is a tuple that may contains type variables\r\n    if (inType instanceof ParameterizedType && Tuple.class.isAssignableFrom(((Class<?>) ((ParameterizedType) inType).getRawType()))) {\r\n        Type[] tupleElements = ((ParameterizedType) inType).getActualTypeArguments();\r\n        \/\/ go thru all tuple elements and search for type variables\r\n        for (int i = 0; i < tupleElements.length; i++) {\r\n            if (tupleElements[i] instanceof TypeVariable) {\r\n                inType = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) tupleElements[i]);\r\n                info = findCorrespondingInfo(returnTypeVar, inType, ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i));\r\n                if (info != null) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return info;\r\n}","code_comment":null,"code_no_comment":"private <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> returnTypeHierarchy, Type inType, TypeInformation<IN1> inTypeInfo) {\r\n    TypeInformation<?> info = null;\r\n        if (inType instanceof TypeVariable) {\r\n        inType = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) inType);\r\n        info = findCorrespondingInfo(returnTypeVar, inType, inTypeInfo);\r\n    } else     if (inType instanceof ParameterizedType && Tuple.class.isAssignableFrom(((Class<?>) ((ParameterizedType) inType).getRawType()))) {\r\n        Type[] tupleElements = ((ParameterizedType) inType).getActualTypeArguments();\r\n                for (int i = 0; i < tupleElements.length; i++) {\r\n            if (tupleElements[i] instanceof TypeVariable) {\r\n                inType = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) tupleElements[i]);\r\n                info = findCorrespondingInfo(returnTypeVar, inType, ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i));\r\n                if (info != null) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return info;\r\n}","lc":0.2727272727,"pi":1.2966507177,"ma":0.6,"nbd":1.5,"ml":0.5,"d":0.6349206349,"mi":-0.3121916843,"fo":0.1666666667,"r":-0.0263157895,"e":0.7544936406}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3617_02626724","label":1,"code":"\/**\r\n * Creates a new GenericFile<File> based on the given file.\r\n *\r\n * @param endpointPath the starting directory the endpoint was configured with\r\n * @param file the source file\r\n * @return wrapped as a GenericFile\r\n *\/\r\npublic static GenericFile<File> asGenericFile(String endpointPath, File file) {\r\n    GenericFile<File> answer = new GenericFile<File>();\r\n    \/\/ use file specific binding\r\n    answer.setBinding(new FileBinding());\r\n    answer.setEndpointPath(endpointPath);\r\n    answer.setFile(file);\r\n    answer.setFileNameOnly(file.getName());\r\n    answer.setFileLength(file.length());\r\n    \/\/ must use FileUtil.isAbsolute to have consistent check for whether the file is\r\n    \/\/ absolute or not. As windows do not consider \\ paths as absolute where as all\r\n    \/\/ other OS platforms will consider \\ as absolute. The logic in Camel mandates\r\n    \/\/ that we align this for all OS. That is why we must use FileUtil.isAbsolute\r\n    \/\/ to return a consistent answer for all OS platforms.\r\n    answer.setAbsolute(FileUtil.isAbsolute(file));\r\n    answer.setAbsoluteFilePath(file.getAbsolutePath());\r\n    answer.setLastModified(file.lastModified());\r\n    if (answer.isAbsolute()) {\r\n        \/\/ use absolute path as relative\r\n        answer.setRelativeFilePath(file.getAbsolutePath());\r\n    } else {\r\n        File path;\r\n        String endpointNormalized = FileUtil.normalizePath(endpointPath);\r\n        if (file.getPath().startsWith(endpointNormalized)) {\r\n            \/\/ skip duplicate endpoint path\r\n            path = new File(ObjectHelper.after(file.getPath(), endpointNormalized + File.separator));\r\n        } else {\r\n            path = new File(file.getPath());\r\n        }\r\n        if (path.getParent() != null) {\r\n            answer.setRelativeFilePath(path.getParent() + File.separator + file.getName());\r\n        } else {\r\n            answer.setRelativeFilePath(path.getName());\r\n        }\r\n    }\r\n    \/\/ the file name should be the relative path\r\n    answer.setFileName(answer.getRelativeFilePath());\r\n    \/\/ use file as body as we have converters if needed as stream\r\n    answer.setBody(file);\r\n    return answer;\r\n}","code_comment":"\/**\r\n * Creates a new GenericFile<File> based on the given file.\r\n *\r\n * @param endpointPath the starting directory the endpoint was configured with\r\n * @param file the source file\r\n * @return wrapped as a GenericFile\r\n *\/\r\n","code_no_comment":"public static GenericFile<File> asGenericFile(String endpointPath, File file) {\r\n    GenericFile<File> answer = new GenericFile<File>();\r\n        answer.setBinding(new FileBinding());\r\n    answer.setEndpointPath(endpointPath);\r\n    answer.setFile(file);\r\n    answer.setFileNameOnly(file.getName());\r\n    answer.setFileLength(file.length());\r\n                        answer.setAbsolute(FileUtil.isAbsolute(file));\r\n    answer.setAbsoluteFilePath(file.getAbsolutePath());\r\n    answer.setLastModified(file.lastModified());\r\n    if (answer.isAbsolute()) {\r\n                answer.setRelativeFilePath(file.getAbsolutePath());\r\n    } else {\r\n        File path;\r\n        String endpointNormalized = FileUtil.normalizePath(endpointPath);\r\n        if (file.getPath().startsWith(endpointNormalized)) {\r\n                        path = new File(ObjectHelper.after(file.getPath(), endpointNormalized + File.separator));\r\n        } else {\r\n            path = new File(file.getPath());\r\n        }\r\n        if (path.getParent() != null) {\r\n            answer.setRelativeFilePath(path.getParent() + File.separator + file.getName());\r\n        } else {\r\n            answer.setRelativeFilePath(path.getName());\r\n        }\r\n    }\r\n        answer.setFileName(answer.getRelativeFilePath());\r\n        answer.setBody(file);\r\n    return answer;\r\n}","lc":0.7272727273,"pi":0.1100478469,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":0.1488095238,"mi":-0.525863284,"fo":2.0833333333,"r":-0.0263157895,"e":0.4929121788}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-846_7acb091a","label":3,"code":"\/**\r\n * Get the revision of the latest change made to this node.\r\n *\r\n * @param nodeMap the document\r\n * @param changeRev the revision of the current change\r\n * @param handler the conflict handler, which is called for un-committed revisions\r\n *                preceding <code>before<\/code>.\r\n * @return the revision, or null if deleted\r\n *\/\r\n@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nRevision getNewestRevision(Map<String, Object> nodeMap, Revision changeRev, CollisionHandler handler) {\r\n    if (nodeMap == null) {\r\n        return null;\r\n    }\r\n    SortedSet<String> revisions = new TreeSet<String>(Collections.reverseOrder());\r\n    if (nodeMap.containsKey(UpdateOp.REVISIONS)) {\r\n        revisions.addAll(((Map<String, String>) nodeMap.get(UpdateOp.REVISIONS)).keySet());\r\n    }\r\n    if (nodeMap.containsKey(UpdateOp.COMMIT_ROOT)) {\r\n        revisions.addAll(((Map<String, Integer>) nodeMap.get(UpdateOp.COMMIT_ROOT)).keySet());\r\n    }\r\n    Map<String, String> deletedMap = (Map<String, String>) nodeMap.get(UpdateOp.DELETED);\r\n    if (deletedMap != null) {\r\n        revisions.addAll(deletedMap.keySet());\r\n    }\r\n    Revision newestRev = null;\r\n    for (String r : revisions) {\r\n        Revision propRev = Revision.fromString(r);\r\n        if (isRevisionNewer(propRev, changeRev)) {\r\n            \/\/ we have seen a previous change from another cluster node\r\n            \/\/ (which might be conflicting or not) - we need to make\r\n            \/\/ sure this change is visible from now on\r\n            publishRevision(propRev, changeRev);\r\n        }\r\n        if (newestRev == null || isRevisionNewer(propRev, newestRev)) {\r\n            if (!propRev.equals(changeRev)) {\r\n                if (!isValidRevision(propRev, changeRev, nodeMap, new HashSet<Revision>())) {\r\n                    handler.uncommittedModification(propRev);\r\n                } else {\r\n                    newestRev = propRev;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (newestRev == null) {\r\n        return null;\r\n    }\r\n    if (deletedMap != null) {\r\n        String value = deletedMap.get(newestRev.toString());\r\n        if (\"true\".equals(value)) {\r\n            \/\/ deleted in the newest revision\r\n            return null;\r\n        }\r\n    }\r\n    return newestRev;\r\n}","code_comment":"\/**\r\n * Get the revision of the latest change made to this node.\r\n *\r\n * @param nodeMap the document\r\n * @param changeRev the revision of the current change\r\n * @param handler the conflict handler, which is called for un-committed revisions\r\n *                preceding <code>before<\/code>.\r\n * @return the revision, or null if deleted\r\n *\/\r\n","code_no_comment":"@SuppressWarnings(\"unchecked\")\r\n@Nullable\r\nRevision getNewestRevision(Map<String, Object> nodeMap, Revision changeRev, CollisionHandler handler) {\r\n    if (nodeMap == null) {\r\n        return null;\r\n    }\r\n    SortedSet<String> revisions = new TreeSet<String>(Collections.reverseOrder());\r\n    if (nodeMap.containsKey(UpdateOp.REVISIONS)) {\r\n        revisions.addAll(((Map<String, String>) nodeMap.get(UpdateOp.REVISIONS)).keySet());\r\n    }\r\n    if (nodeMap.containsKey(UpdateOp.COMMIT_ROOT)) {\r\n        revisions.addAll(((Map<String, Integer>) nodeMap.get(UpdateOp.COMMIT_ROOT)).keySet());\r\n    }\r\n    Map<String, String> deletedMap = (Map<String, String>) nodeMap.get(UpdateOp.DELETED);\r\n    if (deletedMap != null) {\r\n        revisions.addAll(deletedMap.keySet());\r\n    }\r\n    Revision newestRev = null;\r\n    for (String r : revisions) {\r\n        Revision propRev = Revision.fromString(r);\r\n        if (isRevisionNewer(propRev, changeRev)) {\r\n                                                publishRevision(propRev, changeRev);\r\n        }\r\n        if (newestRev == null || isRevisionNewer(propRev, newestRev)) {\r\n            if (!propRev.equals(changeRev)) {\r\n                if (!isValidRevision(propRev, changeRev, nodeMap, new HashSet<Revision>())) {\r\n                    handler.uncommittedModification(propRev);\r\n                } else {\r\n                    newestRev = propRev;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (newestRev == null) {\r\n        return null;\r\n    }\r\n    if (deletedMap != null) {\r\n        String value = deletedMap.get(newestRev.toString());\r\n        if (\"true\".equals(value)) {\r\n                        return null;\r\n        }\r\n    }\r\n    return newestRev;\r\n}","lc":1.3636363636,"pi":0.9090909091,"ma":1.8,"nbd":1.0,"ml":1.6666666667,"d":0.7777777778,"mi":-0.8052149401,"fo":1.3333333333,"r":-0.0263157895,"e":1.8291869089}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1148_4080feff","label":1,"code":"\/**\r\n * Checks whether the given hull vertices form a convex hull.\r\n * @param hullVertices the hull vertices\r\n * @return {@code true} if the vertices form a convex hull, {@code false} otherwise\r\n *\/\r\nprivate boolean isConvex(final Vector2D[] hullVertices) {\r\n    if (hullVertices.length < 3) {\r\n        return true;\r\n    }\r\n    double sign = 0.0;\r\n    for (int i = 0; i < hullVertices.length; i++) {\r\n        final Vector2D p1 = hullVertices[i == 0 ? hullVertices.length - 1 : i - 1];\r\n        final Vector2D p2 = hullVertices[i];\r\n        final Vector2D p3 = hullVertices[i == hullVertices.length - 1 ? 0 : i + 1];\r\n        final Vector2D d1 = p2.subtract(p1);\r\n        final Vector2D d2 = p3.subtract(p2);\r\n        final double cross = FastMath.signum(MathArrays.linearCombination(d1.getX(), d2.getY(), -d1.getY(), d2.getX()));\r\n        \/\/ in case of collinear points the cross product will be zero\r\n        if (cross != 0.0) {\r\n            if (sign != 0.0 && cross != sign) {\r\n                return false;\r\n            }\r\n            sign = cross;\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n * Checks whether the given hull vertices form a convex hull.\r\n * @param hullVertices the hull vertices\r\n * @return {@code true} if the vertices form a convex hull, {@code false} otherwise\r\n *\/\r\n","code_no_comment":"private boolean isConvex(final Vector2D[] hullVertices) {\r\n    if (hullVertices.length < 3) {\r\n        return true;\r\n    }\r\n    double sign = 0.0;\r\n    for (int i = 0; i < hullVertices.length; i++) {\r\n        final Vector2D p1 = hullVertices[i == 0 ? hullVertices.length - 1 : i - 1];\r\n        final Vector2D p2 = hullVertices[i];\r\n        final Vector2D p3 = hullVertices[i == hullVertices.length - 1 ? 0 : i + 1];\r\n        final Vector2D d1 = p2.subtract(p1);\r\n        final Vector2D d2 = p3.subtract(p2);\r\n        final double cross = FastMath.signum(MathArrays.linearCombination(d1.getX(), d2.getY(), -d1.getY(), d2.getX()));\r\n                if (cross != 0.0) {\r\n            if (sign != 0.0 && cross != sign) {\r\n                return false;\r\n            }\r\n            sign = cross;\r\n        }\r\n    }\r\n    return true;\r\n}","lc":0.3181818182,"pi":0.4258373206,"ma":0.6,"nbd":0.5,"ml":0.5,"d":1.8630952381,"mi":-0.3657505285,"fo":0.1666666667,"r":-0.0263157895,"e":2.3660102695}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5265_0eb596df","label":1,"code":"@Override\r\nprotected FeedbackMessagesModel newFeedbackMessagesModel() {\r\n    return new FeedbackMessagesModel(this) {\r\n\r\n        private static final long serialVersionUID = 1L;\r\n\r\n        @Override\r\n        protected List<FeedbackMessage> collectMessages(Component panel, IFeedbackMessageFilter filter) {\r\n            if (fence == null) {\r\n                return new FeedbackCollector(panel.getPage()) {\r\n\r\n                    @Override\r\n                    protected boolean shouldRecurseInto(Component component) {\r\n                        return component.getMetaData(FENCE_KEY) == null;\r\n                    }\r\n                }.collect(filter);\r\n            } else {\r\n                return new FeedbackCollector(fence) {\r\n\r\n                    @Override\r\n                    protected boolean shouldRecurseInto(Component component) {\r\n                        return component.getMetaData(FENCE_KEY) == null;\r\n                    }\r\n                }.setIncludeSession(false).collect(filter);\r\n            }\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected FeedbackMessagesModel newFeedbackMessagesModel() {\r\n    return new FeedbackMessagesModel(this) {\r\n\r\n        private static final long serialVersionUID = 1L;\r\n\r\n        @Override\r\n        protected List<FeedbackMessage> collectMessages(Component panel, IFeedbackMessageFilter filter) {\r\n            if (fence == null) {\r\n                return new FeedbackCollector(panel.getPage()) {\r\n\r\n                    @Override\r\n                    protected boolean shouldRecurseInto(Component component) {\r\n                        return component.getMetaData(FENCE_KEY) == null;\r\n                    }\r\n                }.collect(filter);\r\n            } else {\r\n                return new FeedbackCollector(fence) {\r\n\r\n                    @Override\r\n                    protected boolean shouldRecurseInto(Component component) {\r\n                        return component.getMetaData(FENCE_KEY) == null;\r\n                    }\r\n                }.setIncludeSession(false).collect(filter);\r\n            }\r\n        }\r\n    };\r\n}","lc":0.4545454545,"pi":2.1483253589,"ma":-0.4,"nbd":0.5,"ml":-0.25,"d":-0.001984127,"mi":-0.2809020437,"fo":0.0,"r":0.0,"e":0.0279086922}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2621_c849f986","label":1,"code":"\/**\r\n *  @see org.apache.wicket.Component#onBeforeRender()\r\n *\/\r\n@Override\r\nprotected void onBeforeRender() {\r\n    super.onBeforeRender();\r\n    \/\/ auto toggle form's multipart property\r\n    Form<?> form = findParent(Form.class);\r\n    if (form == null) {\r\n        \/\/ woops\r\n        throw new IllegalStateException(\"Component \" + getClass().getName() + \" must have a \" + Form.class.getName() + \" component above in the hierarchy\");\r\n    }\r\n    form.setMultiPart(true);\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.Component#onBeforeRender()\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void onBeforeRender() {\r\n    super.onBeforeRender();\r\n        Form<?> form = findParent(Form.class);\r\n    if (form == null) {\r\n                throw new IllegalStateException(\"Component \" + getClass().getName() + \" must have a \" + Form.class.getName() + \" component above in the hierarchy\");\r\n    }\r\n    form.setMultiPart(true);\r\n}","lc":-0.2272727273,"pi":-0.2296650718,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0873015873,"mi":0.2794926004,"fo":0.0,"r":0.2631578947,"e":-0.0981979334}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1287_14849e22","label":1,"code":"private synchronized RecordId writeListBucket(List<RecordId> bucket) {\r\n    RecordId bucketId = prepare(RecordType.BUCKET, 0, bucket);\r\n    for (RecordId id : bucket) {\r\n        writeRecordId(id);\r\n    }\r\n    return bucketId;\r\n}","code_comment":null,"code_no_comment":"private synchronized RecordId writeListBucket(List<RecordId> bucket) {\r\n    RecordId bucketId = prepare(RecordType.BUCKET, 0, bucket);\r\n    for (RecordId id : bucket) {\r\n        writeRecordId(id);\r\n    }\r\n    return bucketId;\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4449612403,"fo":-0.3333333333,"r":0.1052631579,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5687_3d2d8619","label":1,"code":"public List<MavenProject> getDownstreamProjects(MavenProject project, boolean transitive) {\r\n    if (project == null) {\r\n        throw new IllegalArgumentException(\"project missing\");\r\n    }\r\n    Collection<String> projectIds = new HashSet<String>();\r\n    getDownstreamProjects(ProjectSorter.getId(project), projectIds, transitive);\r\n    return getProjects(projectIds);\r\n}","code_comment":null,"code_no_comment":"public List<MavenProject> getDownstreamProjects(MavenProject project, boolean transitive) {\r\n    if (project == null) {\r\n        throw new IllegalArgumentException(\"project missing\");\r\n    }\r\n    Collection<String> projectIds = new HashSet<String>();\r\n    getDownstreamProjects(ProjectSorter.getId(project), projectIds, transitive);\r\n    return getProjects(projectIds);\r\n}","lc":-0.2727272727,"pi":-0.2822966507,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0674603175,"mi":0.3217758985,"fo":-0.25,"r":0.1052631579,"e":-0.0878154481}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"public void write(org.apache.thrift.protocol.TProtocol oprot, setTableProperty_result struct) throws org.apache.thrift.TException {\r\n    struct.validate();\r\n    oprot.writeStructBegin(STRUCT_DESC);\r\n    if (struct.ouch1 != null) {\r\n        oprot.writeFieldBegin(OUCH1_FIELD_DESC);\r\n        struct.ouch1.write(oprot);\r\n        oprot.writeFieldEnd();\r\n    }\r\n    if (struct.ouch2 != null) {\r\n        oprot.writeFieldBegin(OUCH2_FIELD_DESC);\r\n        struct.ouch2.write(oprot);\r\n        oprot.writeFieldEnd();\r\n    }\r\n    oprot.writeFieldStop();\r\n    oprot.writeStructEnd();\r\n}","code_comment":null,"code_no_comment":"public void write(org.apache.thrift.protocol.TProtocol oprot, setTableProperty_result struct) throws org.apache.thrift.TException {\r\n    struct.validate();\r\n    oprot.writeStructBegin(STRUCT_DESC);\r\n    if (struct.ouch1 != null) {\r\n        oprot.writeFieldBegin(OUCH1_FIELD_DESC);\r\n        struct.ouch1.write(oprot);\r\n        oprot.writeFieldEnd();\r\n    }\r\n    if (struct.ouch2 != null) {\r\n        oprot.writeFieldBegin(OUCH2_FIELD_DESC);\r\n        struct.ouch2.write(oprot);\r\n        oprot.writeFieldEnd();\r\n    }\r\n    oprot.writeFieldStop();\r\n    oprot.writeStructEnd();\r\n}","lc":0.0909090909,"pi":-0.1626794258,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":-0.1016208598,"fo":0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-1677_01a3dd66","label":1,"code":"\/**\r\n *  @see Component#onComponentTag(ComponentTag)\r\n *  @param tag\r\n *             the abstraction representing html tag of this component\r\n *\/\r\n@Override\r\nprotected void onComponentTag(final ComponentTag tag) {\r\n    \/\/ Default handling for component tag\r\n    super.onComponentTag(tag);\r\n    \/\/ must be attached to <input type=\"checkbox\" ...\/> tag\r\n    checkComponentTag(tag, \"input\");\r\n    checkComponentTagAttribute(tag, \"type\", \"checkbox\");\r\n    CheckGroup<?> group = this.group;\r\n    if (group == null) {\r\n        group = findParent(CheckGroup.class);\r\n        if (group == null) {\r\n            throw new WicketRuntimeException(\"Check component [\" + getPath() + \"] cannot find its parent CheckGroup\");\r\n        }\r\n    }\r\n    final String uuid = getValue();\r\n    \/\/ assign name and value\r\n    tag.put(\"name\", group.getInputName());\r\n    tag.put(\"value\", uuid);\r\n    \/\/ check if the model collection of the group contains the model object.\r\n    \/\/ if it does check the check box.\r\n    Collection<?> collection = (Collection<?>) group.getDefaultModelObject();\r\n    \/\/ check for npe in group's model object\r\n    if (collection == null) {\r\n        throw new WicketRuntimeException(\"CheckGroup [\" + group.getPath() + \"] contains a null model object, must be an object of type java.util.Collection\");\r\n    }\r\n    if (group.hasRawInput()) {\r\n        final String[] input = group.getInputAsArray();\r\n        if (input != null) {\r\n            for (int i = 0; i < input.length; i++) {\r\n                if (uuid.equals(input[i])) {\r\n                    tag.put(\"checked\", \"checked\");\r\n                }\r\n            }\r\n        }\r\n    } else if (collection.contains(getDefaultModelObject())) {\r\n        tag.put(\"checked\", \"checked\");\r\n    }\r\n    if (group.wantOnSelectionChangedNotifications()) {\r\n        \/\/ url that points to this components IOnChangeListener method\r\n        CharSequence url = group.urlFor(IOnChangeListener.INTERFACE);\r\n        Form<?> form = group.findParent(Form.class);\r\n        if (form != null) {\r\n            RequestContext rc = RequestContext.get();\r\n            if (rc.isPortletRequest()) {\r\n                \/\/ restore url back to real wicket path as its going to be interpreted by the\r\n                \/\/ form itself\r\n                url = ((PortletRequestContext) rc).getLastEncodedPath();\r\n            }\r\n            tag.put(\"onclick\", form.getJsForInterfaceUrl(url));\r\n        } else {\r\n            \/\/ TODO: following doesn't work with portlets, should be posted to a dynamic hidden\r\n            \/\/ form\r\n            \/\/ with an ActionURL or something\r\n            \/\/ NOTE: do not encode the url as that would give invalid\r\n            \/\/ JavaScript\r\n            tag.put(\"onclick\", \"window.location.href='\" + url + (url.toString().indexOf('?') > -1 ? \"&amp;\" : \"?\") + group.getInputName() + \"=' + this.value;\");\r\n        }\r\n    }\r\n    if (!isActionAuthorized(ENABLE) || !isEnabled() || !group.isEnabled()) {\r\n        tag.put(ATTR_DISABLED, ATTR_DISABLED);\r\n    }\r\n}","code_comment":"\/**\r\n *  @see Component#onComponentTag(ComponentTag)\r\n *  @param tag\r\n *             the abstraction representing html tag of this component\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void onComponentTag(final ComponentTag tag) {\r\n        super.onComponentTag(tag);\r\n        checkComponentTag(tag, \"input\");\r\n    checkComponentTagAttribute(tag, \"type\", \"checkbox\");\r\n    CheckGroup<?> group = this.group;\r\n    if (group == null) {\r\n        group = findParent(CheckGroup.class);\r\n        if (group == null) {\r\n            throw new WicketRuntimeException(\"Check component [\" + getPath() + \"] cannot find its parent CheckGroup\");\r\n        }\r\n    }\r\n    final String uuid = getValue();\r\n        tag.put(\"name\", group.getInputName());\r\n    tag.put(\"value\", uuid);\r\n            Collection<?> collection = (Collection<?>) group.getDefaultModelObject();\r\n        if (collection == null) {\r\n        throw new WicketRuntimeException(\"CheckGroup [\" + group.getPath() + \"] contains a null model object, must be an object of type java.util.Collection\");\r\n    }\r\n    if (group.hasRawInput()) {\r\n        final String[] input = group.getInputAsArray();\r\n        if (input != null) {\r\n            for (int i = 0; i < input.length; i++) {\r\n                if (uuid.equals(input[i])) {\r\n                    tag.put(\"checked\", \"checked\");\r\n                }\r\n            }\r\n        }\r\n    } else if (collection.contains(getDefaultModelObject())) {\r\n        tag.put(\"checked\", \"checked\");\r\n    }\r\n    if (group.wantOnSelectionChangedNotifications()) {\r\n                CharSequence url = group.urlFor(IOnChangeListener.INTERFACE);\r\n        Form<?> form = group.findParent(Form.class);\r\n        if (form != null) {\r\n            RequestContext rc = RequestContext.get();\r\n            if (rc.isPortletRequest()) {\r\n                                                url = ((PortletRequestContext) rc).getLastEncodedPath();\r\n            }\r\n            tag.put(\"onclick\", form.getJsForInterfaceUrl(url));\r\n        } else {\r\n                                                                        tag.put(\"onclick\", \"window.location.href='\" + url + (url.toString().indexOf('?') > -1 ? \"&amp;\" : \"?\") + group.getInputName() + \"=' + this.value;\");\r\n        }\r\n    }\r\n    if (!isActionAuthorized(ENABLE) || !isEnabled() || !group.isEnabled()) {\r\n        tag.put(ATTR_DISABLED, ATTR_DISABLED);\r\n    }\r\n}","lc":1.5454545455,"pi":0.6842105263,"ma":2.4,"nbd":1.0,"ml":2.1666666667,"d":1.7103174603,"mi":-0.9078224101,"fo":2.3333333333,"r":-0.0263157895,"e":4.7040703538}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-392_731c84b5","label":1,"code":"\/**\r\n * Initialize the configuration.\r\n *\/\r\n@Override\r\npublic void start() {\r\n    LOGGER.debug(\"Starting configuration {}\", this);\r\n    this.setStarting();\r\n    pluginManager.collectPlugins();\r\n    final PluginManager levelPlugins = new PluginManager(\"Level\");\r\n    levelPlugins.collectPlugins();\r\n    final Map<String, PluginType<?>> plugins = levelPlugins.getPlugins();\r\n    if (plugins != null) {\r\n        for (final PluginType<?> type : plugins.values()) {\r\n            try {\r\n                \/\/ Cause the class to be initialized if it isn't already.\r\n                Loader.initializeClass(type.getPluginClass().getName(), type.getPluginClass().getClassLoader());\r\n            } catch (final Exception ex) {\r\n                LOGGER.error(\"Unable to initialize {} due to {}: {}\", type.getPluginClass().getName(), ex.getClass().getSimpleName(), ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n    setup();\r\n    setupAdvertisement();\r\n    doConfigure();\r\n    for (final LoggerConfig logger : loggers.values()) {\r\n        logger.start();\r\n    }\r\n    for (final Appender appender : appenders.values()) {\r\n        appender.start();\r\n    }\r\n    \/\/ LOG4J2-336\r\n    root.start();\r\n    super.start();\r\n    LOGGER.debug(\"Started configuration {} OK.\", this);\r\n}","code_comment":"\/**\r\n * Initialize the configuration.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void start() {\r\n    LOGGER.debug(\"Starting configuration {}\", this);\r\n    this.setStarting();\r\n    pluginManager.collectPlugins();\r\n    final PluginManager levelPlugins = new PluginManager(\"Level\");\r\n    levelPlugins.collectPlugins();\r\n    final Map<String, PluginType<?>> plugins = levelPlugins.getPlugins();\r\n    if (plugins != null) {\r\n        for (final PluginType<?> type : plugins.values()) {\r\n            try {\r\n                                Loader.initializeClass(type.getPluginClass().getName(), type.getPluginClass().getClassLoader());\r\n            } catch (final Exception ex) {\r\n                LOGGER.error(\"Unable to initialize {} due to {}: {}\", type.getPluginClass().getName(), ex.getClass().getSimpleName(), ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n    setup();\r\n    setupAdvertisement();\r\n    doConfigure();\r\n    for (final LoggerConfig logger : loggers.values()) {\r\n        logger.start();\r\n    }\r\n    for (final Appender appender : appenders.values()) {\r\n        appender.start();\r\n    }\r\n        root.start();\r\n    super.start();\r\n    LOGGER.debug(\"Started configuration {} OK.\", this);\r\n}","lc":0.7272727273,"pi":0.5263157895,"ma":0.4,"nbd":0.5,"ml":-0.25,"d":-0.0476190476,"mi":-0.4911909796,"fo":1.75,"r":-0.0263157895,"e":0.1297326579}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-1856_faa5cf27","label":3,"code":"private void assembleDistributionManagementInheritance(Model child, Model parent) {\r\n    DistributionManagement cDistMgmt = child.getDistributionManagement();\r\n    DistributionManagement pDistMgmt = parent.getDistributionManagement();\r\n    if (cDistMgmt == null) {\r\n        child.setDistributionManagement(pDistMgmt);\r\n    } else if (pDistMgmt != null) {\r\n        if (cDistMgmt.getRepository() == null) {\r\n            cDistMgmt.setRepository(pDistMgmt.getRepository());\r\n        }\r\n        if (cDistMgmt.getSnapshotRepository() == null) {\r\n            cDistMgmt.setSnapshotRepository(pDistMgmt.getSnapshotRepository());\r\n        }\r\n        if (StringUtils.isEmpty(cDistMgmt.getDownloadUrl())) {\r\n            cDistMgmt.setDownloadUrl(pDistMgmt.getDownloadUrl());\r\n        }\r\n        if (cDistMgmt.getRelocation() == null) {\r\n            cDistMgmt.setRelocation(pDistMgmt.getRelocation());\r\n        }\r\n        if (cDistMgmt.getSite() == null) {\r\n            cDistMgmt.setSite(pDistMgmt.getSite());\r\n        }\r\n    \/\/ NOTE: We SHOULD NOT be inheriting status, since this is an assessment of the POM quality.\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void assembleDistributionManagementInheritance(Model child, Model parent) {\r\n    DistributionManagement cDistMgmt = child.getDistributionManagement();\r\n    DistributionManagement pDistMgmt = parent.getDistributionManagement();\r\n    if (cDistMgmt == null) {\r\n        child.setDistributionManagement(pDistMgmt);\r\n    } else if (pDistMgmt != null) {\r\n        if (cDistMgmt.getRepository() == null) {\r\n            cDistMgmt.setRepository(pDistMgmt.getRepository());\r\n        }\r\n        if (cDistMgmt.getSnapshotRepository() == null) {\r\n            cDistMgmt.setSnapshotRepository(pDistMgmt.getSnapshotRepository());\r\n        }\r\n        if (StringUtils.isEmpty(cDistMgmt.getDownloadUrl())) {\r\n            cDistMgmt.setDownloadUrl(pDistMgmt.getDownloadUrl());\r\n        }\r\n        if (cDistMgmt.getRelocation() == null) {\r\n            cDistMgmt.setRelocation(pDistMgmt.getRelocation());\r\n        }\r\n        if (cDistMgmt.getSite() == null) {\r\n            cDistMgmt.setSite(pDistMgmt.getSite());\r\n        }\r\n        }\r\n}","lc":0.4090909091,"pi":0.2296650718,"ma":0.8,"nbd":0.5,"ml":0.8333333333,"d":0.126984127,"mi":-0.3448907681,"fo":1.0833333333,"r":-0.0263157895,"e":0.1862923071}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5500_825da305","label":1,"code":"@Override\r\nprotected UrlInfo parseRequest(Request request) {\r\n    Url url = request.getUrl();\r\n    if (url.getSegments().size() > mountSegments.length) {\r\n        \/\/ try to extract page and component information from URL\r\n        PageComponentInfo info = getPageComponentInfo(url);\r\n        \/\/ load the page class\r\n        String className = url.getSegments().get(mountSegments.length);\r\n        if (isValidClassName(className) == false) {\r\n            return null;\r\n        }\r\n        className = transformFromUrl(className);\r\n        String fullyQualifiedClassName = packageName.getName() + '.' + className;\r\n        Class<? extends IRequestablePage> pageClass = getPageClass(fullyQualifiedClassName);\r\n        if (pageClass != null && Modifier.isAbstract(pageClass.getModifiers()) == false && IRequestablePage.class.isAssignableFrom(pageClass)) {\r\n            \/\/ extract the PageParameters from URL if there are any\r\n            Url urlWithoutPageSegment = new Url(url);\r\n            urlWithoutPageSegment.getSegments().remove(mountSegments.length);\r\n            Request requestWithoutPageSegment = request.cloneWithUrl(urlWithoutPageSegment);\r\n            PageParameters pageParameters = extractPageParameters(requestWithoutPageSegment, urlWithoutPageSegment);\r\n            return new UrlInfo(info, pageClass, pageParameters);\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected UrlInfo parseRequest(Request request) {\r\n    Url url = request.getUrl();\r\n    if (url.getSegments().size() > mountSegments.length) {\r\n                PageComponentInfo info = getPageComponentInfo(url);\r\n                String className = url.getSegments().get(mountSegments.length);\r\n        if (isValidClassName(className) == false) {\r\n            return null;\r\n        }\r\n        className = transformFromUrl(className);\r\n        String fullyQualifiedClassName = packageName.getName() + '.' + className;\r\n        Class<? extends IRequestablePage> pageClass = getPageClass(fullyQualifiedClassName);\r\n        if (pageClass != null && Modifier.isAbstract(pageClass.getModifiers()) == false && IRequestablePage.class.isAssignableFrom(pageClass)) {\r\n                        Url urlWithoutPageSegment = new Url(url);\r\n            urlWithoutPageSegment.getSegments().remove(mountSegments.length);\r\n            Request requestWithoutPageSegment = request.cloneWithUrl(urlWithoutPageSegment);\r\n            PageParameters pageParameters = extractPageParameters(requestWithoutPageSegment, urlWithoutPageSegment);\r\n            return new UrlInfo(info, pageClass, pageParameters);\r\n        }\r\n    }\r\n    return null;\r\n}","lc":0.3636363636,"pi":0.4497607656,"ma":0.0,"nbd":0.0,"ml":0.6666666667,"d":0.7400793651,"mi":-0.3778717407,"fo":0.9166666667,"r":-0.0263157895,"e":1.1856941155}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1235_1beb2a50","label":1,"code":"\/**\r\n * Copies the registered namespaces to the target repository, and returns\r\n * the internal namespace index mapping used in bundle serialization.\r\n *\r\n * @param root root builder\r\n * @return index to prefix mapping\r\n * @throws RepositoryException\r\n *\/\r\nprivate Map<Integer, String> copyNamespaces(NodeBuilder root) throws RepositoryException {\r\n    Map<Integer, String> idxToPrefix = newHashMap();\r\n    NodeBuilder system = root.child(JCR_SYSTEM);\r\n    NodeBuilder namespaces = Namespaces.createStandardMappings(system);\r\n    Properties registry = loadProperties(\"\/namespaces\/ns_reg.properties\");\r\n    Properties indexes = loadProperties(\"\/namespaces\/ns_idx.properties\");\r\n    for (String prefixHint : registry.stringPropertyNames()) {\r\n        String uri = registry.getProperty(prefixHint);\r\n        if (\".empty.key\".equals(prefixHint)) {\r\n            prefixHint = \"\";\r\n        }\r\n        String prefix = Namespaces.addCustomMapping(namespaces, uri, prefixHint);\r\n        String index = null;\r\n        if (uri.isEmpty()) {\r\n            index = indexes.getProperty(\".empty.key\");\r\n        }\r\n        if (index == null) {\r\n            index = indexes.getProperty(uri);\r\n        }\r\n        Integer idx;\r\n        if (index != null) {\r\n            idx = Integer.decode(index);\r\n        } else {\r\n            int i = 0;\r\n            do {\r\n                idx = (uri.hashCode() + i++) & 0x00ffffff;\r\n            } while (idxToPrefix.containsKey(idx));\r\n        }\r\n        checkState(idxToPrefix.put(idx, prefix) == null);\r\n    }\r\n    Namespaces.buildIndexNode(namespaces);\r\n    return idxToPrefix;\r\n}","code_comment":"\/**\r\n * Copies the registered namespaces to the target repository, and returns\r\n * the internal namespace index mapping used in bundle serialization.\r\n *\r\n * @param root root builder\r\n * @return index to prefix mapping\r\n * @throws RepositoryException\r\n *\/\r\n","code_no_comment":"private Map<Integer, String> copyNamespaces(NodeBuilder root) throws RepositoryException {\r\n    Map<Integer, String> idxToPrefix = newHashMap();\r\n    NodeBuilder system = root.child(JCR_SYSTEM);\r\n    NodeBuilder namespaces = Namespaces.createStandardMappings(system);\r\n    Properties registry = loadProperties(\"\/namespaces\/ns_reg.properties\");\r\n    Properties indexes = loadProperties(\"\/namespaces\/ns_idx.properties\");\r\n    for (String prefixHint : registry.stringPropertyNames()) {\r\n        String uri = registry.getProperty(prefixHint);\r\n        if (\".empty.key\".equals(prefixHint)) {\r\n            prefixHint = \"\";\r\n        }\r\n        String prefix = Namespaces.addCustomMapping(namespaces, uri, prefixHint);\r\n        String index = null;\r\n        if (uri.isEmpty()) {\r\n            index = indexes.getProperty(\".empty.key\");\r\n        }\r\n        if (index == null) {\r\n            index = indexes.getProperty(uri);\r\n        }\r\n        Integer idx;\r\n        if (index != null) {\r\n            idx = Integer.decode(index);\r\n        } else {\r\n            int i = 0;\r\n            do {\r\n                idx = (uri.hashCode() + i++) & 0x00ffffff;\r\n            } while (idxToPrefix.containsKey(idx));\r\n        }\r\n        checkState(idxToPrefix.put(idx, prefix) == null);\r\n    }\r\n    Namespaces.buildIndexNode(namespaces);\r\n    return idxToPrefix;\r\n}","lc":0.8636363636,"pi":0.3157894737,"ma":0.6,"nbd":0.5,"ml":0.5,"d":0.9206349206,"mi":-0.613812544,"fo":1.0,"r":-0.0263157895,"e":1.7754072947}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1199_813109d7","label":3,"code":"@Override\r\npublic String toString() {\r\n    StringBuilder sb = new StringBuilder(\"removeConstraint_result(\");\r\n    boolean first = true;\r\n    sb.append(\"ouch1:\");\r\n    if (this.ouch1 == null) {\r\n        sb.append(\"null\");\r\n    } else {\r\n        sb.append(this.ouch1);\r\n    }\r\n    first = false;\r\n    if (!first)\r\n        sb.append(\", \");\r\n    sb.append(\"ouch2:\");\r\n    if (this.ouch2 == null) {\r\n        sb.append(\"null\");\r\n    } else {\r\n        sb.append(this.ouch2);\r\n    }\r\n    first = false;\r\n    sb.append(\")\");\r\n    return sb.toString();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String toString() {\r\n    StringBuilder sb = new StringBuilder(\"removeConstraint_result(\");\r\n    boolean first = true;\r\n    sb.append(\"ouch1:\");\r\n    if (this.ouch1 == null) {\r\n        sb.append(\"null\");\r\n    } else {\r\n        sb.append(this.ouch1);\r\n    }\r\n    first = false;\r\n    if (!first)\r\n        sb.append(\", \");\r\n    sb.append(\"ouch2:\");\r\n    if (this.ouch2 == null) {\r\n        sb.append(\"null\");\r\n    } else {\r\n        sb.append(this.ouch2);\r\n    }\r\n    first = false;\r\n    sb.append(\")\");\r\n    return sb.toString();\r\n}","lc":0.4090909091,"pi":-0.3157894737,"ma":0.0,"nbd":-0.5,"ml":0.0833333333,"d":0.130952381,"mi":-0.2763918252,"fo":0.25,"r":0.0,"e":0.1004569999}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4260_925cae5c","label":1,"code":"@Override\r\npublic void sendRedirect(String url) {\r\n    try {\r\n        redirect = true;\r\n        url = encodeRedirectURL(url);\r\n        \/\/ wicket redirects should never be cached\r\n        disableCaching();\r\n        if (webRequest.isAjax()) {\r\n            httpServletResponse.addHeader(\"Ajax-Location\", url);\r\n            \/*\r\n\t\t\t\t * usually the Ajax-Location header is enough and we do not need to the redirect url\r\n\t\t\t\t * into the response, but sometimes the response is processed via an iframe (eg\r\n\t\t\t\t * using multipart ajax handling) and the headers are not available because XHR is\r\n\t\t\t\t * not used and that is the only way javascript has access to response headers.\r\n\t\t\t\t *\/\r\n            httpServletResponse.getWriter().write(\"<ajax-response><redirect><![CDATA[\" + url + \"]]><\/redirect><\/ajax-response>\");\r\n            setContentType(\"text\/xml;charset=\" + webRequest.getContainerRequest().getCharacterEncoding());\r\n            disableCaching();\r\n        } else {\r\n            httpServletResponse.sendRedirect(url);\r\n        }\r\n    } catch (IOException e) {\r\n        throw new WicketRuntimeException(e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void sendRedirect(String url) {\r\n    try {\r\n        redirect = true;\r\n        url = encodeRedirectURL(url);\r\n                disableCaching();\r\n        if (webRequest.isAjax()) {\r\n            httpServletResponse.addHeader(\"Ajax-Location\", url);\r\n                        httpServletResponse.getWriter().write(\"<ajax-response><redirect><![CDATA[\" + url + \"]]><\/redirect><\/ajax-response>\");\r\n            setContentType(\"text\/xml;charset=\" + webRequest.getContainerRequest().getCharacterEncoding());\r\n            disableCaching();\r\n        } else {\r\n            httpServletResponse.sendRedirect(url);\r\n        }\r\n    } catch (IOException e) {\r\n        throw new WicketRuntimeException(e);\r\n    }\r\n}","lc":0.1818181818,"pi":0.5406698565,"ma":0.0,"nbd":0.0,"ml":-0.25,"d":-0.0793650794,"mi":-0.1374207188,"fo":0.4166666667,"r":0.0,"e":-0.0365254174}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3105_311e8b33","label":0,"code":"\/**\r\n * Write a reference to an external blob.\r\n *\r\n * @param reference reference\r\n * @return record id\r\n *\/\r\nprivate synchronized RecordId writeValueRecord(String reference) {\r\n    byte[] data = reference.getBytes(Charsets.UTF_8);\r\n    int length = data.length;\r\n    checkArgument(length < 8192);\r\n    RecordId id = prepare(RecordType.VALUE, 2 + length);\r\n    int len = length | 0xE000;\r\n    buffer[position++] = (byte) (len >> 8);\r\n    buffer[position++] = (byte) len;\r\n    System.arraycopy(data, 0, buffer, position, length);\r\n    position += length;\r\n    blobrefs.add(id);\r\n    return id;\r\n}","code_comment":"\/**\r\n * Write a reference to an external blob.\r\n *\r\n * @param reference reference\r\n * @return record id\r\n *\/\r\n","code_no_comment":"private synchronized RecordId writeValueRecord(String reference) {\r\n    byte[] data = reference.getBytes(Charsets.UTF_8);\r\n    int length = data.length;\r\n    checkArgument(length < 8192);\r\n    RecordId id = prepare(RecordType.VALUE, 2 + length);\r\n    int len = length | 0xE000;\r\n    buffer[position++] = (byte) (len >> 8);\r\n    buffer[position++] = (byte) len;\r\n    System.arraycopy(data, 0, buffer, position, length);\r\n    position += length;\r\n    blobrefs.add(id);\r\n    return id;\r\n}","lc":-0.0454545455,"pi":-0.7416267943,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":0.6488095238,"mi":-0.036222692,"fo":-0.0833333333,"r":0.1052631579,"e":0.5445018816}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-293_59a0da9c","label":1,"code":"\/**\r\n * Get the current solution.\r\n *\r\n * @return current solution\r\n *\/\r\nprotected RealPointValuePair getSolution() {\r\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\r\n    Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());\r\n    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\r\n    Set<Integer> basicRows = new HashSet<Integer>();\r\n    for (int i = 0; i < coefficients.length; i++) {\r\n        Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);\r\n        if (basicRows.contains(basicRow)) {\r\n            \/\/ if multiple variables can take a given value\r\n            \/\/ then we choose the first and set the rest equal to 0\r\n            coefficients[i] = 0;\r\n        } else {\r\n            basicRows.add(basicRow);\r\n            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\r\n        }\r\n    }\r\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\r\n}","code_comment":"\/**\r\n * Get the current solution.\r\n *\r\n * @return current solution\r\n *\/\r\n","code_no_comment":"protected RealPointValuePair getSolution() {\r\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\r\n    Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());\r\n    double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\r\n    Set<Integer> basicRows = new HashSet<Integer>();\r\n    for (int i = 0; i < coefficients.length; i++) {\r\n        Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);\r\n        if (basicRows.contains(basicRow)) {\r\n                                    coefficients[i] = 0;\r\n        } else {\r\n            basicRows.add(basicRow);\r\n            coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);\r\n        }\r\n    }\r\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\r\n}","lc":0.0909090909,"pi":0.3588516746,"ma":0.4,"nbd":0.0,"ml":0.5,"d":0.9404761905,"mi":-0.1881606765,"fo":0.5,"r":0.1578947368,"e":0.9136333512}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-395_962315ba","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.0218253968,"mi":0.8204369274,"fo":-0.4166666667,"r":0.8421052632,"e":-0.0960910081}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-727_69273dca","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException {\r\n    sanityChecks(equations, t);\r\n    setEquations(equations);\r\n    final boolean forward = t > equations.getTime();\r\n    \/\/ create some internal working arrays\r\n    final double[] y0 = equations.getCompleteState();\r\n    final double[] y = y0.clone();\r\n    final int stages = c.length + 1;\r\n    final double[][] yDotK = new double[stages][];\r\n    for (int i = 0; i < stages; ++i) {\r\n        yDotK[i] = new double[y0.length];\r\n    }\r\n    final double[] yTmp = y0.clone();\r\n    final double[] yDotTmp = new double[y0.length];\r\n    \/\/ set up an interpolator sharing the integrator arrays\r\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\r\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\r\n    interpolator.storeTime(equations.getTime());\r\n    \/\/ set up integration control objects\r\n    stepStart = equations.getTime();\r\n    stepSize = forward ? step : -step;\r\n    initIntegration(equations.getTime(), y0, t);\r\n    \/\/ main integration loop\r\n    isLastStep = false;\r\n    do {\r\n        interpolator.shift();\r\n        \/\/ first stage\r\n        computeDerivatives(stepStart, y, yDotK[0]);\r\n        \/\/ next stages\r\n        for (int k = 1; k < stages; ++k) {\r\n            for (int j = 0; j < y0.length; ++j) {\r\n                double sum = a[k - 1][0] * yDotK[0][j];\r\n                for (int l = 1; l < k; ++l) {\r\n                    sum += a[k - 1][l] * yDotK[l][j];\r\n                }\r\n                yTmp[j] = y[j] + stepSize * sum;\r\n            }\r\n            computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\r\n        }\r\n        \/\/ estimate the state at the end of the step\r\n        for (int j = 0; j < y0.length; ++j) {\r\n            double sum = b[0] * yDotK[0][j];\r\n            for (int l = 1; l < stages; ++l) {\r\n                sum += b[l] * yDotK[l][j];\r\n            }\r\n            yTmp[j] = y[j] + stepSize * sum;\r\n        }\r\n        \/\/ discrete events handling\r\n        interpolator.storeTime(stepStart + stepSize);\r\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\r\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\r\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\r\n        if (!isLastStep) {\r\n            \/\/ prepare next step\r\n            interpolator.storeTime(stepStart);\r\n            \/\/ stepsize control for next step\r\n            final double nextT = stepStart + stepSize;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            if (nextIsLast) {\r\n                stepSize = t - stepStart;\r\n            }\r\n        }\r\n    } while (!isLastStep);\r\n    \/\/ dispatch results\r\n    equations.setTime(stepStart);\r\n    equations.setCompleteState(y);\r\n    stepStart = Double.NaN;\r\n    stepSize = Double.NaN;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException {\r\n    sanityChecks(equations, t);\r\n    setEquations(equations);\r\n    final boolean forward = t > equations.getTime();\r\n        final double[] y0 = equations.getCompleteState();\r\n    final double[] y = y0.clone();\r\n    final int stages = c.length + 1;\r\n    final double[][] yDotK = new double[stages][];\r\n    for (int i = 0; i < stages; ++i) {\r\n        yDotK[i] = new double[y0.length];\r\n    }\r\n    final double[] yTmp = y0.clone();\r\n    final double[] yDotTmp = new double[y0.length];\r\n        final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\r\n    interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers());\r\n    interpolator.storeTime(equations.getTime());\r\n        stepStart = equations.getTime();\r\n    stepSize = forward ? step : -step;\r\n    initIntegration(equations.getTime(), y0, t);\r\n        isLastStep = false;\r\n    do {\r\n        interpolator.shift();\r\n                computeDerivatives(stepStart, y, yDotK[0]);\r\n                for (int k = 1; k < stages; ++k) {\r\n            for (int j = 0; j < y0.length; ++j) {\r\n                double sum = a[k - 1][0] * yDotK[0][j];\r\n                for (int l = 1; l < k; ++l) {\r\n                    sum += a[k - 1][l] * yDotK[l][j];\r\n                }\r\n                yTmp[j] = y[j] + stepSize * sum;\r\n            }\r\n            computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\r\n        }\r\n                for (int j = 0; j < y0.length; ++j) {\r\n            double sum = b[0] * yDotK[0][j];\r\n            for (int l = 1; l < stages; ++l) {\r\n                sum += b[l] * yDotK[l][j];\r\n            }\r\n            yTmp[j] = y[j] + stepSize * sum;\r\n        }\r\n                interpolator.storeTime(stepStart + stepSize);\r\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\r\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\r\n        stepStart = acceptStep(interpolator, y, yDotTmp, t);\r\n        if (!isLastStep) {\r\n                        interpolator.storeTime(stepStart);\r\n                        final double nextT = stepStart + stepSize;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            if (nextIsLast) {\r\n                stepSize = t - stepStart;\r\n            }\r\n        }\r\n    } while (!isLastStep);\r\n        equations.setTime(stepStart);\r\n    equations.setCompleteState(y);\r\n    stepStart = Double.NaN;\r\n    stepSize = Double.NaN;\r\n}","lc":2.0454545455,"pi":0.8086124402,"ma":1.6,"nbd":1.0,"ml":1.25,"d":3.380952381,"mi":-1.0560958421,"fo":1.5833333333,"r":-0.0263157895,"e":14.9902641148}
{"project_name":"Closure","project_version":"137","label":2,"code":"\/**\r\n * Adds a name to the map of names declared in this scope.\r\n *\/\r\n@Override\r\npublic void addDeclaredName(String name) {\r\n    if (global) {\r\n        reserveName(name);\r\n    } else {\r\n        \/\/ It hasn't been declared locally yet, so increment the count.\r\n        if (!declarations.containsKey(name)) {\r\n            int id = incrementNameCount(name);\r\n            String newName = null;\r\n            if (id != 0) {\r\n                newName = getUniqueName(name, id);\r\n            }\r\n            declarations.put(name, newName);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Adds a name to the map of names declared in this scope.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void addDeclaredName(String name) {\r\n    if (global) {\r\n        reserveName(name);\r\n    } else {\r\n                if (!declarations.containsKey(name)) {\r\n            int id = incrementNameCount(name);\r\n            String newName = null;\r\n            if (id != 0) {\r\n                newName = getUniqueName(name, id);\r\n            }\r\n            declarations.put(name, newName);\r\n        }\r\n    }\r\n}","lc":0.0454545455,"pi":0.976076555,"ma":0.0,"nbd":0.5,"ml":0.1666666667,"d":-0.0297619048,"mi":-0.0049330514,"fo":-0.0833333333,"r":0.2631578947,"e":-0.0570368193}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-412_5594b2e0","label":1,"code":"public static List<TabletLocation> findOverlappingTablets(AccumuloConfiguration acuConf, FileSystem fs, TabletLocator locator, Path file, Text startRow, Text endRow) throws Exception {\r\n    List<TabletLocation> result = new ArrayList<TabletLocation>();\r\n    Collection<ByteSequence> columnFamilies = Collections.emptyList();\r\n    FileSKVIterator reader = FileOperations.getInstance().openReader(file.toString(), true, fs, fs.getConf(), acuConf);\r\n    try {\r\n        Text row = startRow;\r\n        if (row == null)\r\n            row = new Text();\r\n        while (true) {\r\n            reader.seek(new Range(row, null), columnFamilies, false);\r\n            if (!reader.hasTop())\r\n                break;\r\n            row = reader.getTopKey().getRow();\r\n            TabletLocation tabletLocation = locator.locateTablet(row, false, true);\r\n            result.add(tabletLocation);\r\n            row = tabletLocation.tablet_extent.getEndRow();\r\n            if (row != null && (endRow == null || row.compareTo(endRow) < 0))\r\n                row = Range.followingPrefix(row);\r\n            else\r\n                break;\r\n        }\r\n    } finally {\r\n        reader.close();\r\n    }\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"public static List<TabletLocation> findOverlappingTablets(AccumuloConfiguration acuConf, FileSystem fs, TabletLocator locator, Path file, Text startRow, Text endRow) throws Exception {\r\n    List<TabletLocation> result = new ArrayList<TabletLocation>();\r\n    Collection<ByteSequence> columnFamilies = Collections.emptyList();\r\n    FileSKVIterator reader = FileOperations.getInstance().openReader(file.toString(), true, fs, fs.getConf(), acuConf);\r\n    try {\r\n        Text row = startRow;\r\n        if (row == null)\r\n            row = new Text();\r\n        while (true) {\r\n            reader.seek(new Range(row, null), columnFamilies, false);\r\n            if (!reader.hasTop())\r\n                break;\r\n            row = reader.getTopKey().getRow();\r\n            TabletLocation tabletLocation = locator.locateTablet(row, false, true);\r\n            result.add(tabletLocation);\r\n            row = tabletLocation.tablet_extent.getEndRow();\r\n            if (row != null && (endRow == null || row.compareTo(endRow) < 0))\r\n                row = Range.followingPrefix(row);\r\n            else\r\n                break;\r\n        }\r\n    } finally {\r\n        reader.close();\r\n    }\r\n    return result;\r\n}","lc":0.5454545455,"pi":0.8038277512,"ma":0.6,"nbd":0.0,"ml":0.4166666667,"d":0.7380952381,"mi":-0.4951374207,"fo":0.75,"r":-0.0263157895,"e":1.3939708281}
{"project_name":"Closure","project_version":"135","label":2,"code":"@Override\r\nboolean defineProperty(String name, JSType type, boolean inferred, boolean inExterns) {\r\n    if (\"prototype\".equals(name)) {\r\n        ObjectType objType = type.toObjectType();\r\n        if (objType != null) {\r\n            return setPrototype(new FunctionPrototypeType(registry, this, objType, isNativeObjectType()));\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return super.defineProperty(name, type, inferred, inExterns);\r\n}","code_comment":null,"code_no_comment":"@Override\r\nboolean defineProperty(String name, JSType type, boolean inferred, boolean inExterns) {\r\n    if (\"prototype\".equals(name)) {\r\n        ObjectType objType = type.toObjectType();\r\n        if (objType != null) {\r\n            return setPrototype(new FunctionPrototypeType(registry, this, objType, isNativeObjectType()));\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return super.defineProperty(name, type, inferred, inExterns);\r\n}","lc":-0.0909090909,"pi":0.5550239234,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":-0.0773809524,"mi":0.1007751938,"fo":-0.0833333333,"r":0.0,"e":-0.0703791428}
{"project_name":"Lang","project_version":"46","label":0,"code":"\/**\r\n * <p>Worker method for the {@link #escapeJavaScript(String)} method.<\/p>\r\n *\r\n * @param out write to receieve the escaped string\r\n * @param str String to escape values in, may be null\r\n * @param escapeSingleQuote escapes single quotes if <code>true<\/code>\r\n * @param escapeForwardSlash TODO\r\n * @throws IOException if an IOException occurs\r\n *\/\r\nprivate static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\r\n    if (out == null) {\r\n        throw new IllegalArgumentException(\"The Writer must not be null\");\r\n    }\r\n    if (str == null) {\r\n        return;\r\n    }\r\n    int sz;\r\n    sz = str.length();\r\n    for (int i = 0; i < sz; i++) {\r\n        char ch = str.charAt(i);\r\n        \/\/ handle unicode\r\n        if (ch > 0xfff) {\r\n            out.write(\"\\\\u\" + hex(ch));\r\n        } else if (ch > 0xff) {\r\n            out.write(\"\\\\u0\" + hex(ch));\r\n        } else if (ch > 0x7f) {\r\n            out.write(\"\\\\u00\" + hex(ch));\r\n        } else if (ch < 32) {\r\n            switch(ch) {\r\n                case '\\b':\r\n                    out.write('\\\\');\r\n                    out.write('b');\r\n                    break;\r\n                case '\\n':\r\n                    out.write('\\\\');\r\n                    out.write('n');\r\n                    break;\r\n                case '\\t':\r\n                    out.write('\\\\');\r\n                    out.write('t');\r\n                    break;\r\n                case '\\f':\r\n                    out.write('\\\\');\r\n                    out.write('f');\r\n                    break;\r\n                case '\\r':\r\n                    out.write('\\\\');\r\n                    out.write('r');\r\n                    break;\r\n                default:\r\n                    if (ch > 0xf) {\r\n                        out.write(\"\\\\u00\" + hex(ch));\r\n                    } else {\r\n                        out.write(\"\\\\u000\" + hex(ch));\r\n                    }\r\n                    break;\r\n            }\r\n        } else {\r\n            switch(ch) {\r\n                case '\\'':\r\n                    if (escapeSingleQuote) {\r\n                        out.write('\\\\');\r\n                    }\r\n                    out.write('\\'');\r\n                    break;\r\n                case '\"':\r\n                    out.write('\\\\');\r\n                    out.write('\"');\r\n                    break;\r\n                case '\\\\':\r\n                    out.write('\\\\');\r\n                    out.write('\\\\');\r\n                    break;\r\n                case '\/':\r\n                    out.write('\\\\');\r\n                    out.write('\/');\r\n                    break;\r\n                default:\r\n                    out.write(ch);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * <p>Worker method for the {@link #escapeJavaScript(String)} method.<\/p>\r\n *\r\n * @param out write to receieve the escaped string\r\n * @param str String to escape values in, may be null\r\n * @param escapeSingleQuote escapes single quotes if <code>true<\/code>\r\n * @param escapeForwardSlash TODO\r\n * @throws IOException if an IOException occurs\r\n *\/\r\n","code_no_comment":"private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\r\n    if (out == null) {\r\n        throw new IllegalArgumentException(\"The Writer must not be null\");\r\n    }\r\n    if (str == null) {\r\n        return;\r\n    }\r\n    int sz;\r\n    sz = str.length();\r\n    for (int i = 0; i < sz; i++) {\r\n        char ch = str.charAt(i);\r\n                if (ch > 0xfff) {\r\n            out.write(\"\\\\u\" + hex(ch));\r\n        } else if (ch > 0xff) {\r\n            out.write(\"\\\\u0\" + hex(ch));\r\n        } else if (ch > 0x7f) {\r\n            out.write(\"\\\\u00\" + hex(ch));\r\n        } else if (ch < 32) {\r\n            switch(ch) {\r\n                case '\\b':\r\n                    out.write('\\\\');\r\n                    out.write('b');\r\n                    break;\r\n                case '\\n':\r\n                    out.write('\\\\');\r\n                    out.write('n');\r\n                    break;\r\n                case '\\t':\r\n                    out.write('\\\\');\r\n                    out.write('t');\r\n                    break;\r\n                case '\\f':\r\n                    out.write('\\\\');\r\n                    out.write('f');\r\n                    break;\r\n                case '\\r':\r\n                    out.write('\\\\');\r\n                    out.write('r');\r\n                    break;\r\n                default:\r\n                    if (ch > 0xf) {\r\n                        out.write(\"\\\\u00\" + hex(ch));\r\n                    } else {\r\n                        out.write(\"\\\\u000\" + hex(ch));\r\n                    }\r\n                    break;\r\n            }\r\n        } else {\r\n            switch(ch) {\r\n                case '\\'':\r\n                    if (escapeSingleQuote) {\r\n                        out.write('\\\\');\r\n                    }\r\n                    out.write('\\'');\r\n                    break;\r\n                case '\"':\r\n                    out.write('\\\\');\r\n                    out.write('\"');\r\n                    break;\r\n                case '\\\\':\r\n                    out.write('\\\\');\r\n                    out.write('\\\\');\r\n                    break;\r\n                case '\/':\r\n                    out.write('\\\\');\r\n                    out.write('\/');\r\n                    break;\r\n                default:\r\n                    out.write(ch);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}","lc":2.7272727273,"pi":1.6267942584,"ma":5.8,"nbd":3.0,"ml":1.5833333333,"d":1.4920634921,"mi":-1.1866102889,"fo":2.0833333333,"r":-0.0263157895,"e":3.40301862}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4038_557eec4f","label":1,"code":"private Set<String> findMultiProperty(OrImpl or) {\r\n    Set<String> values = newLinkedHashSet();\r\n    for (ConstraintImpl constraint : or.getConstraints()) {\r\n        if (constraint instanceof ComparisonImpl) {\r\n            ComparisonImpl comparison = (ComparisonImpl) constraint;\r\n            if (isIndexed(comparison.getOperand1()) && comparison.getOperator() == Operator.EQUAL) {\r\n                values.addAll(encode(comparison.getOperand2().currentValue()));\r\n            } else {\r\n                return null;\r\n            }\r\n        } else if (constraint instanceof InImpl) {\r\n            InImpl in = (InImpl) constraint;\r\n            if (isIndexed(in.getOperand1())) {\r\n                for (StaticOperandImpl operand : in.getOperand2()) {\r\n                    values.addAll(encode(operand.currentValue()));\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    return values;\r\n}","code_comment":null,"code_no_comment":"private Set<String> findMultiProperty(OrImpl or) {\r\n    Set<String> values = newLinkedHashSet();\r\n    for (ConstraintImpl constraint : or.getConstraints()) {\r\n        if (constraint instanceof ComparisonImpl) {\r\n            ComparisonImpl comparison = (ComparisonImpl) constraint;\r\n            if (isIndexed(comparison.getOperand1()) && comparison.getOperator() == Operator.EQUAL) {\r\n                values.addAll(encode(comparison.getOperand2().currentValue()));\r\n            } else {\r\n                return null;\r\n            }\r\n        } else if (constraint instanceof InImpl) {\r\n            InImpl in = (InImpl) constraint;\r\n            if (isIndexed(in.getOperand1())) {\r\n                for (StaticOperandImpl operand : in.getOperand2()) {\r\n                    values.addAll(encode(operand.currentValue()));\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    return values;\r\n}","lc":0.5,"pi":1.0526315789,"ma":0.6,"nbd":1.5,"ml":0.5,"d":0.0396825397,"mi":-0.371106413,"fo":0.75,"r":0.0263157895,"e":0.1137025063}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1822_3e83a4c1","label":1,"code":"\/**\r\n * Creates a MongoDB update object from the given UpdateOp.\r\n *\r\n * @param updateOp the update op.\r\n * @return the DBObject.\r\n *\/\r\n@Nonnull\r\nprivate static DBObject createUpdate(UpdateOp updateOp) {\r\n    BasicDBObject setUpdates = new BasicDBObject();\r\n    BasicDBObject incUpdates = new BasicDBObject();\r\n    BasicDBObject unsetUpdates = new BasicDBObject();\r\n    \/\/ always increment modCount\r\n    updateOp.increment(Document.MOD_COUNT, 1);\r\n    \/\/ other updates\r\n    for (Entry<Key, Operation> entry : updateOp.getChanges().entrySet()) {\r\n        Key k = entry.getKey();\r\n        if (k.getName().equals(Document.ID)) {\r\n            \/\/ avoid exception \"Mod on _id not allowed\"\r\n            continue;\r\n        }\r\n        Operation op = entry.getValue();\r\n        switch(op.type) {\r\n            case SET:\r\n                {\r\n                    setUpdates.append(k.toString(), op.value);\r\n                    break;\r\n                }\r\n            case INCREMENT:\r\n                {\r\n                    incUpdates.append(k.toString(), op.value);\r\n                    break;\r\n                }\r\n            case SET_MAP_ENTRY:\r\n                {\r\n                    setUpdates.append(k.toString(), op.value);\r\n                    break;\r\n                }\r\n            case REMOVE_MAP_ENTRY:\r\n                {\r\n                    unsetUpdates.append(k.toString(), \"1\");\r\n                    break;\r\n                }\r\n        }\r\n    }\r\n    BasicDBObject update = new BasicDBObject();\r\n    if (!setUpdates.isEmpty()) {\r\n        update.append(\"$set\", setUpdates);\r\n    }\r\n    if (!incUpdates.isEmpty()) {\r\n        update.append(\"$inc\", incUpdates);\r\n    }\r\n    if (!unsetUpdates.isEmpty()) {\r\n        update.append(\"$unset\", unsetUpdates);\r\n    }\r\n    return update;\r\n}","code_comment":"\/**\r\n * Creates a MongoDB update object from the given UpdateOp.\r\n *\r\n * @param updateOp the update op.\r\n * @return the DBObject.\r\n *\/\r\n","code_no_comment":"@Nonnull\r\nprivate static DBObject createUpdate(UpdateOp updateOp) {\r\n    BasicDBObject setUpdates = new BasicDBObject();\r\n    BasicDBObject incUpdates = new BasicDBObject();\r\n    BasicDBObject unsetUpdates = new BasicDBObject();\r\n        updateOp.increment(Document.MOD_COUNT, 1);\r\n        for (Entry<Key, Operation> entry : updateOp.getChanges().entrySet()) {\r\n        Key k = entry.getKey();\r\n        if (k.getName().equals(Document.ID)) {\r\n                        continue;\r\n        }\r\n        Operation op = entry.getValue();\r\n        switch(op.type) {\r\n            case SET:\r\n                {\r\n                    setUpdates.append(k.toString(), op.value);\r\n                    break;\r\n                }\r\n            case INCREMENT:\r\n                {\r\n                    incUpdates.append(k.toString(), op.value);\r\n                    break;\r\n                }\r\n            case SET_MAP_ENTRY:\r\n                {\r\n                    setUpdates.append(k.toString(), op.value);\r\n                    break;\r\n                }\r\n            case REMOVE_MAP_ENTRY:\r\n                {\r\n                    unsetUpdates.append(k.toString(), \"1\");\r\n                    break;\r\n                }\r\n        }\r\n    }\r\n    BasicDBObject update = new BasicDBObject();\r\n    if (!setUpdates.isEmpty()) {\r\n        update.append(\"$set\", setUpdates);\r\n    }\r\n    if (!incUpdates.isEmpty()) {\r\n        update.append(\"$inc\", incUpdates);\r\n    }\r\n    if (!unsetUpdates.isEmpty()) {\r\n        update.append(\"$unset\", unsetUpdates);\r\n    }\r\n    return update;\r\n}","lc":1.5,"pi":1.6507177033,"ma":2.2,"nbd":0.5,"ml":0.6666666667,"d":0.0853174603,"mi":-0.7998590557,"fo":1.25,"r":-0.0263157895,"e":0.4027800349}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-434_133cbc2d","label":1,"code":"\/**\r\n * Removes the phase 1 objective function, positive cost non-artificial variables,\r\n * and the non-basic artificial variables from this tableau.\r\n *\/\r\nprotected void dropPhase1Objective() {\r\n    if (getNumObjectiveFunctions() == 1) {\r\n        return;\r\n    }\r\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\r\n    columnsToDrop.add(0);\r\n    \/\/ positive cost non-artificial variables\r\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\r\n        if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) > 0) {\r\n            columnsToDrop.add(i);\r\n        }\r\n    }\r\n    \/\/ non-basic artificial variables\r\n    for (int i = 0; i < getNumArtificialVariables(); i++) {\r\n        int col = i + getArtificialVariableOffset();\r\n        if (getBasicRow(col) == null) {\r\n            columnsToDrop.add(col);\r\n        }\r\n    }\r\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\r\n    for (int i = 1; i < getHeight(); i++) {\r\n        int col = 0;\r\n        for (int j = 0; j < getWidth(); j++) {\r\n            if (!columnsToDrop.contains(j)) {\r\n                matrix[i - 1][col++] = tableau.getEntry(i, j);\r\n            }\r\n        }\r\n    }\r\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\r\n        columnLabels.remove((int) columnsToDrop.get(i));\r\n    }\r\n    this.tableau = new Array2DRowRealMatrix(matrix);\r\n    this.numArtificialVariables = 0;\r\n}","code_comment":"\/**\r\n * Removes the phase 1 objective function, positive cost non-artificial variables,\r\n * and the non-basic artificial variables from this tableau.\r\n *\/\r\n","code_no_comment":"protected void dropPhase1Objective() {\r\n    if (getNumObjectiveFunctions() == 1) {\r\n        return;\r\n    }\r\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\r\n    columnsToDrop.add(0);\r\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\r\n        if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) > 0) {\r\n            columnsToDrop.add(i);\r\n        }\r\n    }\r\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\r\n        int col = i + getArtificialVariableOffset();\r\n        if (getBasicRow(col) == null) {\r\n            columnsToDrop.add(col);\r\n        }\r\n    }\r\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\r\n    for (int i = 1; i < getHeight(); i++) {\r\n        int col = 0;\r\n        for (int j = 0; j < getWidth(); j++) {\r\n            if (!columnsToDrop.contains(j)) {\r\n                matrix[i - 1][col++] = tableau.getEntry(i, j);\r\n            }\r\n        }\r\n    }\r\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\r\n        columnLabels.remove((int) columnsToDrop.get(i));\r\n    }\r\n    this.tableau = new Array2DRowRealMatrix(matrix);\r\n    this.numArtificialVariables = 0;\r\n}","lc":0.8181818182,"pi":0.2870813397,"ma":1.2,"nbd":0.5,"ml":1.4166666667,"d":2.3948412698,"mi":-0.6197322058,"fo":1.25,"r":-0.0263157895,"e":4.0203615659}
{"project_name":"Math","project_version":"66","label":1,"code":"public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\r\n}","code_comment":null,"code_no_comment":"public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\r\n    return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.0218253968,"mi":0.8204369274,"fo":-0.4166666667,"r":-0.0263157895,"e":-0.0960910081}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3260_6968a57a","label":0,"code":"private boolean transitionState(ExecutionState currentState, ExecutionState targetState, Throwable error) {\r\n    if (STATE_UPDATER.compareAndSet(this, currentState, targetState)) {\r\n        markTimestamp(targetState);\r\n        LOG.info(getVertex().getTaskNameWithSubtaskIndex() + \" (\" + getAttemptId() + \") switched from \" + currentState + \" to \" + targetState);\r\n        \/\/ potential errors (in listeners may not affect the main logic)\r\n        try {\r\n            vertex.notifyStateTransition(attemptId, targetState, error);\r\n        } catch (Throwable t) {\r\n            LOG.error(\"Error while notifying execution graph of execution state transition.\", t);\r\n        }\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}","code_comment":null,"code_no_comment":"private boolean transitionState(ExecutionState currentState, ExecutionState targetState, Throwable error) {\r\n    if (STATE_UPDATER.compareAndSet(this, currentState, targetState)) {\r\n        markTimestamp(targetState);\r\n        LOG.info(getVertex().getTaskNameWithSubtaskIndex() + \" (\" + getAttemptId() + \") switched from \" + currentState + \" to \" + targetState);\r\n                try {\r\n            vertex.notifyStateTransition(attemptId, targetState, error);\r\n        } catch (Throwable t) {\r\n            LOG.error(\"Error while notifying execution graph of execution state transition.\", t);\r\n        }\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}","lc":0.0,"pi":0.2822966507,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":-0.0071881607,"fo":0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1899_df59fb45","label":1,"code":"@Override\r\nvoid prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final String key) {\r\n    for (NodeBuilder node : builders) {\r\n        if (node.hasProperty(\"match\") || node.getChildNodeCount(1) > 0) {\r\n            return;\r\n        } else if (node.exists()) {\r\n            if (node.hasProperty(NEXT)) {\r\n                ChildNodeEntry[] walkedLanes = new ChildNodeEntry[OrderedIndex.LANES];\r\n                ChildNodeEntry entry;\r\n                String lane0Next, prevNext, currNext;\r\n                \/\/ to keep searching and update\r\n                do {\r\n                    entry = seek(index.getNodeState(), new PredicateEquals(key), walkedLanes);\r\n                    lane0Next = getPropertyNext(walkedLanes[0]);\r\n                    for (int lane = walkedLanes.length - 1; lane >= 0; lane--) {\r\n                        prevNext = getPropertyNext(walkedLanes[lane], lane);\r\n                        if (key.equals(prevNext)) {\r\n                            \/\/ if it's actually pointing to us let's deal with it\r\n                            currNext = getPropertyNext(node, lane);\r\n                            setPropertyNext(index.getChildNode(walkedLanes[lane].getName()), currNext, lane);\r\n                        }\r\n                    }\r\n                } while (entry != null && !key.equals(lane0Next));\r\n            }\r\n            node.remove();\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\nvoid prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final String key) {\r\n    for (NodeBuilder node : builders) {\r\n        if (node.hasProperty(\"match\") || node.getChildNodeCount(1) > 0) {\r\n            return;\r\n        } else if (node.exists()) {\r\n            if (node.hasProperty(NEXT)) {\r\n                ChildNodeEntry[] walkedLanes = new ChildNodeEntry[OrderedIndex.LANES];\r\n                ChildNodeEntry entry;\r\n                String lane0Next, prevNext, currNext;\r\n                                do {\r\n                    entry = seek(index.getNodeState(), new PredicateEquals(key), walkedLanes);\r\n                    lane0Next = getPropertyNext(walkedLanes[0]);\r\n                    for (int lane = walkedLanes.length - 1; lane >= 0; lane--) {\r\n                        prevNext = getPropertyNext(walkedLanes[lane], lane);\r\n                        if (key.equals(prevNext)) {\r\n                                                        currNext = getPropertyNext(node, lane);\r\n                            setPropertyNext(index.getChildNode(walkedLanes[lane].getName()), currNext, lane);\r\n                        }\r\n                    }\r\n                } while (entry != null && !key.equals(lane0Next));\r\n            }\r\n            node.remove();\r\n        }\r\n    }\r\n}","lc":0.5454545455,"pi":2.5119617225,"ma":0.8,"nbd":2.5,"ml":1.0833333333,"d":1.373015873,"mi":-0.4801973221,"fo":0.75,"r":-0.0263157895,"e":1.9556623618}
{"project_name":"Lang","project_version":"47","label":1,"code":"\/\/ -----------------------------------------------------------------------\r\n\/**\r\n * Appends an object to the builder padding on the left to a fixed width.\r\n * The <code>toString<\/code> of the object is used.\r\n * If the object is larger than the length, the left hand side is lost.\r\n * If the object is null, the null text value is used.\r\n *\r\n * @param obj  the object to append, null uses null text\r\n * @param width  the fixed field width, zero or negative has no effect\r\n * @param padChar  the pad character to use\r\n * @return this, to enable chaining\r\n *\/\r\npublic StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\r\n    if (width > 0) {\r\n        ensureCapacity(size + width);\r\n        String str = (obj == null ? getNullText() : obj.toString());\r\n        int strLen = str.length();\r\n        if (strLen >= width) {\r\n            str.getChars(strLen - width, strLen, buffer, size);\r\n        } else {\r\n            int padLen = width - strLen;\r\n            for (int i = 0; i < padLen; i++) {\r\n                buffer[size + i] = padChar;\r\n            }\r\n            str.getChars(0, strLen, buffer, size + padLen);\r\n        }\r\n        size += width;\r\n    }\r\n    return this;\r\n}","code_comment":"\/**\r\n * Appends an object to the builder padding on the left to a fixed width.\r\n * The <code>toString<\/code> of the object is used.\r\n * If the object is larger than the length, the left hand side is lost.\r\n * If the object is null, the null text value is used.\r\n *\r\n * @param obj  the object to append, null uses null text\r\n * @param width  the fixed field width, zero or negative has no effect\r\n * @param padChar  the pad character to use\r\n * @return this, to enable chaining\r\n *\/\r\n","code_no_comment":"public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\r\n    if (width > 0) {\r\n        ensureCapacity(size + width);\r\n        String str = (obj == null ? getNullText() : obj.toString());\r\n        int strLen = str.length();\r\n        if (strLen >= width) {\r\n            str.getChars(strLen - width, strLen, buffer, size);\r\n        } else {\r\n            int padLen = width - strLen;\r\n            for (int i = 0; i < padLen; i++) {\r\n                buffer[size + i] = padChar;\r\n            }\r\n            str.getChars(0, strLen, buffer, size + padLen);\r\n        }\r\n        size += width;\r\n    }\r\n    return this;\r\n}","lc":0.1818181818,"pi":0.5885167464,"ma":0.2,"nbd":0.5,"ml":0.3333333333,"d":1.5992063492,"mi":-0.2264975335,"fo":0.0,"r":0.0,"e":1.360882419}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-276_1bf5c550","label":1,"code":"Id readHead() throws Exception;","code_comment":null,"code_no_comment":"Id readHead() throws Exception;","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.666384778,"fo":-0.5,"r":2.5,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1933_2e16a983","label":1,"code":"\/**\r\n * The estimated number of entries. This value does not have to be\r\n * accurate.\r\n *\r\n * @return the estimated number of entries\r\n *\/\r\nlong getEstimatedEntryCount();","code_comment":"\/**\r\n * The estimated number of entries. This value does not have to be\r\n * accurate.\r\n *\r\n * @return the estimated number of entries\r\n *\/\r\n","code_no_comment":"long getEstimatedEntryCount();","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.8696264975,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"Closure","project_version":"94","label":2,"code":"\/**\r\n * Determines whether the given value may be assigned to a define.\r\n *\r\n * @param val The value being assigned.\r\n * @param defines The list of names of existing defines.\r\n *\/\r\nstatic boolean isValidDefineValue(Node val, Set<String> defines) {\r\n    switch(val.getType()) {\r\n        case Token.STRING:\r\n        case Token.NUMBER:\r\n        case Token.TRUE:\r\n        case Token.FALSE:\r\n            return true;\r\n        \/\/ Binary operators are only valid if both children are valid.\r\n        case Token.BITAND:\r\n        case Token.BITNOT:\r\n        case Token.BITOR:\r\n        case Token.BITXOR:\r\n        \/\/ Uniary operators are valid if the child is valid.\r\n        case Token.NOT:\r\n        case Token.NEG:\r\n            return isValidDefineValue(val.getFirstChild(), defines);\r\n        \/\/ Names are valid if and only if they are defines themselves.\r\n        case Token.NAME:\r\n        case Token.GETPROP:\r\n            if (val.isQualifiedName()) {\r\n                return defines.contains(val.getQualifiedName());\r\n            }\r\n    }\r\n    return false;\r\n}","code_comment":"\/**\r\n * Determines whether the given value may be assigned to a define.\r\n *\r\n * @param val The value being assigned.\r\n * @param defines The list of names of existing defines.\r\n *\/\r\n","code_no_comment":"static boolean isValidDefineValue(Node val, Set<String> defines) {\r\n    switch(val.getType()) {\r\n        case Token.STRING:\r\n        case Token.NUMBER:\r\n        case Token.TRUE:\r\n        case Token.FALSE:\r\n            return true;\r\n                case Token.BITAND:\r\n        case Token.BITNOT:\r\n        case Token.BITOR:\r\n        case Token.BITXOR:\r\n                case Token.NOT:\r\n        case Token.NEG:\r\n            return isValidDefineValue(val.getFirstChild(), defines);\r\n                case Token.NAME:\r\n        case Token.GETPROP:\r\n            if (val.isQualifiedName()) {\r\n                return defines.contains(val.getQualifiedName());\r\n            }\r\n    }\r\n    return false;\r\n}","lc":0.3636363636,"pi":0.3444976077,"ma":2.0,"nbd":0.5,"ml":0.8333333333,"d":-0.3650793651,"mi":-0.3113460183,"fo":0.0,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2882_ebe56869","label":1,"code":"\/**\r\n *  Adds a child component to this container.\r\n *\r\n *  @param childs\r\n *             The child(s)\r\n *  @throws IllegalArgumentException\r\n *              Thrown if a child with the same id is replaced by the add operation.\r\n *  @return This\r\n *\/\r\npublic MarkupContainer add(final Component... childs) {\r\n    for (Component child : childs) {\r\n        if (child == null) {\r\n            throw new IllegalArgumentException(\"argument child may not be null\");\r\n        }\r\n        checkHierarchyChange(child);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Add \" + child.getId() + \" to \" + this);\r\n        }\r\n        \/\/ Add to map\r\n        addedComponent(child);\r\n        if (put(child) != null) {\r\n            throw new IllegalArgumentException(exceptionMessage(\"A child with id '\" + child.getId() + \"' already exists\"));\r\n        }\r\n        \/\/ Check if the markup is available after the child has been added to the parent\r\n        try {\r\n            \/\/ If not yet triggered, than do now (e.g. Pages)\r\n            if (getMarkup() != null) {\r\n                internalOnMarkupAttached();\r\n            }\r\n            if (child.getMarkup() != null) {\r\n                child.internalOnMarkupAttached();\r\n                \/\/ Tell all children of \"component\" as well\r\n                if (child instanceof MarkupContainer) {\r\n                    MarkupContainer container = (MarkupContainer) child;\r\n                    container.visitChildren(new IVisitor<Component, Void>() {\r\n\r\n                        public void component(final Component component, final IVisit<Void> visit) {\r\n                            if (component.internalOnMarkupAttached()) {\r\n                                visit.dontGoDeeper();\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        } catch (WicketRuntimeException exception) {\r\n        \/\/ ignore\r\n        }\r\n    }\r\n    return this;\r\n}","code_comment":"\/**\r\n *  Adds a child component to this container.\r\n *\r\n *  @param childs\r\n *             The child(s)\r\n *  @throws IllegalArgumentException\r\n *              Thrown if a child with the same id is replaced by the add operation.\r\n *  @return This\r\n *\/\r\n","code_no_comment":"public MarkupContainer add(final Component... childs) {\r\n    for (Component child : childs) {\r\n        if (child == null) {\r\n            throw new IllegalArgumentException(\"argument child may not be null\");\r\n        }\r\n        checkHierarchyChange(child);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Add \" + child.getId() + \" to \" + this);\r\n        }\r\n                addedComponent(child);\r\n        if (put(child) != null) {\r\n            throw new IllegalArgumentException(exceptionMessage(\"A child with id '\" + child.getId() + \"' already exists\"));\r\n        }\r\n                try {\r\n                        if (getMarkup() != null) {\r\n                internalOnMarkupAttached();\r\n            }\r\n            if (child.getMarkup() != null) {\r\n                child.internalOnMarkupAttached();\r\n                                if (child instanceof MarkupContainer) {\r\n                    MarkupContainer container = (MarkupContainer) child;\r\n                    container.visitChildren(new IVisitor<Component, Void>() {\r\n\r\n                        public void component(final Component component, final IVisit<Void> visit) {\r\n                            if (component.internalOnMarkupAttached()) {\r\n                                visit.dontGoDeeper();\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        } catch (WicketRuntimeException exception) {\r\n                }\r\n    }\r\n    return this;\r\n}","lc":0.9545454545,"pi":2.2727272727,"ma":1.6,"nbd":2.0,"ml":0.6666666667,"d":0.4047619048,"mi":-0.5906976744,"fo":0.75,"r":-0.0263157895,"e":0.4986290002}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2933_44585b0c","label":1,"code":"private Validator visibleValidator(@Nonnull Tree source, @Nonnull Tree dest) {\r\n    \/\/ TODO improve: avoid calculating the 'before' permissions in case the current parent permissions already point to the correct tree.\r\n    ImmutableTree parent = (ImmutableTree) moveCtx.rootBefore.getTree(\"\/\");\r\n    TreePermission tp = getPermissionProvider().getTreePermission(parent, TreePermission.EMPTY);\r\n    for (String n : PathUtils.elements(source.getPath())) {\r\n        tp = tp.getChildPermission(n, parent.getChild(n).getNodeState());\r\n    }\r\n    Validator validator = createValidator(source, dest, tp, this);\r\n    return new VisibleValidator(validator, true, false);\r\n}","code_comment":null,"code_no_comment":"private Validator visibleValidator(@Nonnull Tree source, @Nonnull Tree dest) {\r\n        ImmutableTree parent = (ImmutableTree) moveCtx.rootBefore.getTree(\"\/\");\r\n    TreePermission tp = getPermissionProvider().getTreePermission(parent, TreePermission.EMPTY);\r\n    for (String n : PathUtils.elements(source.getPath())) {\r\n        tp = tp.getChildPermission(n, parent.getChild(n).getNodeState());\r\n    }\r\n    Validator validator = createValidator(source, dest, tp, this);\r\n    return new VisibleValidator(validator, true, false);\r\n}","lc":-0.2272727273,"pi":-0.3444976077,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.1489781536,"fo":0.25,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Compress","project_version":"42","label":1,"code":"\/**\r\n * Returns true if this entry represents a unix symlink,\r\n * in which case the entry's content contains the target path\r\n * for the symlink.\r\n *\r\n * @since 1.5\r\n * @return true if the entry represents a unix symlink, false otherwise.\r\n *\/\r\npublic boolean isUnixSymlink() {\r\n    return (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG;\r\n}","code_comment":"\/**\r\n * Returns true if this entry represents a unix symlink,\r\n * in which case the entry's content contains the target path\r\n * for the symlink.\r\n *\r\n * @since 1.5\r\n * @return true if the entry represents a unix symlink, false otherwise.\r\n *\/\r\n","code_no_comment":"public boolean isUnixSymlink() {\r\n    return (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.0873015873,"mi":0.9960535588,"fo":-0.4166666667,"r":2.5263157895,"e":-0.1464866329}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1096_19c1c3bb","label":0,"code":"\/**\r\n * Compute a dimension 3 minor, when 3<sup>d<\/sup> column is known to be filled with 1.0.\r\n * <p>\r\n * The computation is performed using {@link MathArrays#linearCombination(double[], double[])\r\n * high accuracy sum of products}, trying to avoid cancellations effect. This should reduce\r\n * risks in case of near co-planar points.\r\n * <\/p>\r\n * @param c1 first column\r\n * @param c2 second column\r\n * @return value of the minor computed to high accuracy\r\n *\/\r\nprivate double minor(final double[] c1, final double[] c2) {\r\n    return MathArrays.linearCombination(new double[] { c1[0], c1[2], c1[1], -c1[2], -c1[0], -c1[1] }, new double[] { c2[1], c2[0], c2[2], c2[1], c2[2], c2[0] });\r\n}","code_comment":"\/**\r\n * Compute a dimension 3 minor, when 3<sup>d<\/sup> column is known to be filled with 1.0.\r\n * <p>\r\n * The computation is performed using {@link MathArrays#linearCombination(double[], double[])\r\n * high accuracy sum of products}, trying to avoid cancellations effect. This should reduce\r\n * risks in case of near co-planar points.\r\n * <\/p>\r\n * @param c1 first column\r\n * @param c2 second column\r\n * @return value of the minor computed to high accuracy\r\n *\/\r\n","code_no_comment":"private double minor(final double[] c1, final double[] c2) {\r\n    return MathArrays.linearCombination(new double[] { c1[0], c1[2], c1[1], -c1[2], -c1[0], -c1[1] }, new double[] { c2[1], c2[0], c2[2], c2[1], c2[2], c2[0] });\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7809725159,"fo":-0.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-705_645d642b","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic void writeExternal(final ObjectOutput out) throws IOException {\r\n    \/\/ save the state of the base class\r\n    writeBaseExternal(out);\r\n    \/\/ save the local attributes\r\n    final int n = (currentState == null) ? -1 : currentState.length;\r\n    final int kMax = (yDotK == null) ? -1 : yDotK.length;\r\n    out.writeInt(kMax);\r\n    for (int k = 0; k < kMax; ++k) {\r\n        for (int i = 0; i < n; ++i) {\r\n            out.writeDouble(yDotK[k][i]);\r\n        }\r\n    }\r\n\/\/ we do not save any reference to the equations\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void writeExternal(final ObjectOutput out) throws IOException {\r\n        writeBaseExternal(out);\r\n        final int n = (currentState == null) ? -1 : currentState.length;\r\n    final int kMax = (yDotK == null) ? -1 : yDotK.length;\r\n    out.writeInt(kMax);\r\n    for (int k = 0; k < kMax; ++k) {\r\n        for (int i = 0; i < n; ++i) {\r\n            out.writeDouble(yDotK[k][i]);\r\n        }\r\n    }\r\n}","lc":-0.0909090909,"pi":0.2200956938,"ma":0.2,"nbd":0.0,"ml":0.4166666667,"d":0.4285714286,"mi":0.0136715997,"fo":-0.25,"r":1.9736842105,"e":0.259970148}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3166_4d7f7359","label":1,"code":"\/**\r\n *  Checks if the component itself and all its parents are visible.\r\n *\r\n *  @return true if the component and all its parents are visible.\r\n *\/\r\npublic final boolean isVisibleInHierarchy() {\r\n    Boolean state = getMetaData(VISIBLE_IN_HIERARCHY_CACHE_KEY);\r\n    if (state == null) {\r\n        Component parent = getParent();\r\n        if (parent != null && !parent.isVisibleInHierarchy()) {\r\n            state = false;\r\n        } else {\r\n            state = determineVisibility();\r\n        }\r\n        setMetaData(VISIBLE_IN_HIERARCHY_CACHE_KEY, state);\r\n    }\r\n    return state;\r\n}","code_comment":"\/**\r\n *  Checks if the component itself and all its parents are visible.\r\n *\r\n *  @return true if the component and all its parents are visible.\r\n *\/\r\n","code_no_comment":"public final boolean isVisibleInHierarchy() {\r\n    Boolean state = getMetaData(VISIBLE_IN_HIERARCHY_CACHE_KEY);\r\n    if (state == null) {\r\n        Component parent = getParent();\r\n        if (parent != null && !parent.isVisibleInHierarchy()) {\r\n            state = false;\r\n        } else {\r\n            state = determineVisibility();\r\n        }\r\n        setMetaData(VISIBLE_IN_HIERARCHY_CACHE_KEY, state);\r\n    }\r\n    return state;\r\n}","lc":-0.0454545455,"pi":0.3492822967,"ma":-0.2,"nbd":0.0,"ml":0.0833333333,"d":0.3373015873,"mi":0.0742776603,"fo":-0.0833333333,"r":1.6052631579,"e":0.0480881497}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3762_dc78a747","label":1,"code":"private void checkKryoInitialized() {\r\n    if (this.kryo == null) {\r\n        this.kryo = getKryoInstance();\r\n        \/\/ disable reference tracking. reference tracking is costly, usually unnecessary, and\r\n        \/\/ inconsistent with Flink's own serialization (which does not do reference tracking)\r\n        kryo.setReferences(false);\r\n        \/\/ Throwable and all subclasses should be serialized via java serialization\r\n        kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\r\n        \/\/ are registered with a default serializer\r\n        for (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> entry : defaultSerializers.entrySet()) {\r\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\r\n        }\r\n        for (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry : defaultSerializerClasses.entrySet()) {\r\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue());\r\n        }\r\n        \/\/ register the type of our class\r\n        kryo.register(type);\r\n        \/\/ more specific serializer overrides this\r\n        for (Class<?> type : registeredTypes) {\r\n            kryo.register(type);\r\n        }\r\n        \/\/ register given serializer classes\r\n        for (Map.Entry<Class<?>, Class<? extends Serializer<?>>> e : registeredTypesWithSerializerClasses.entrySet()) {\r\n            Class<?> typeClass = e.getKey();\r\n            Class<? extends Serializer<?>> serializerClass = e.getValue();\r\n            Serializer<?> serializer = ReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\r\n            kryo.register(typeClass, serializer);\r\n        }\r\n        \/\/ register given serializers\r\n        for (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> e : registeredTypesWithSerializers.entrySet()) {\r\n            kryo.register(e.getKey(), e.getValue().getSerializer());\r\n        }\r\n        \/\/ this is needed for Avro but can not be added on demand.\r\n        kryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\r\n        kryo.setRegistrationRequired(false);\r\n        kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void checkKryoInitialized() {\r\n    if (this.kryo == null) {\r\n        this.kryo = getKryoInstance();\r\n                        kryo.setReferences(false);\r\n                kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\r\n                for (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> entry : defaultSerializers.entrySet()) {\r\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue().getSerializer());\r\n        }\r\n        for (Map.Entry<Class<?>, Class<? extends Serializer<?>>> entry : defaultSerializerClasses.entrySet()) {\r\n            kryo.addDefaultSerializer(entry.getKey(), entry.getValue());\r\n        }\r\n                kryo.register(type);\r\n                for (Class<?> type : registeredTypes) {\r\n            kryo.register(type);\r\n        }\r\n                for (Map.Entry<Class<?>, Class<? extends Serializer<?>>> e : registeredTypesWithSerializerClasses.entrySet()) {\r\n            Class<?> typeClass = e.getKey();\r\n            Class<? extends Serializer<?>> serializerClass = e.getValue();\r\n            Serializer<?> serializer = ReflectionSerializerFactory.makeSerializer(kryo, serializerClass, typeClass);\r\n            kryo.register(typeClass, serializer);\r\n        }\r\n                for (Map.Entry<Class<?>, ExecutionConfig.SerializableSerializer<?>> e : registeredTypesWithSerializers.entrySet()) {\r\n            kryo.register(e.getKey(), e.getValue().getSerializer());\r\n        }\r\n                kryo.register(GenericData.Array.class, new SpecificInstanceCollectionSerializerForArrayList());\r\n        kryo.setRegistrationRequired(false);\r\n        kryo.setClassLoader(Thread.currentThread().getContextClassLoader());\r\n    }\r\n}","lc":0.6818181818,"pi":0.0717703349,"ma":0.6,"nbd":0.0,"ml":-0.25,"d":0.1408730159,"mi":-0.5458773784,"fo":1.9166666667,"r":-0.0263157895,"e":0.555386894}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1045_c979a6f0","label":3,"code":"\/**\r\n * Checks whether the decomposed matrix is non-singular.\r\n *\r\n * @return true if the decomposed matrix is non-singular.\r\n *\/\r\npublic boolean isNonSingular() {\r\n    \/\/ The eigenvalues are sorted by size, descending\r\n    double largestEigenvalueNorm = eigenvalueNorm(0);\r\n    \/\/ Corner case: zero matrix, all exactly 0 eigenvalues\r\n    if (largestEigenvalueNorm == 0.0) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < realEigenvalues.length; ++i) {\r\n        \/\/ than the largest eigenvalue to be effectively 0.\r\n        if (Precision.equals(eigenvalueNorm(i) \/ largestEigenvalueNorm, 0, EPSILON)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n * Checks whether the decomposed matrix is non-singular.\r\n *\r\n * @return true if the decomposed matrix is non-singular.\r\n *\/\r\n","code_no_comment":"public boolean isNonSingular() {\r\n        double largestEigenvalueNorm = eigenvalueNorm(0);\r\n        if (largestEigenvalueNorm == 0.0) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < realEigenvalues.length; ++i) {\r\n                if (Precision.equals(eigenvalueNorm(i) \/ largestEigenvalueNorm, 0, EPSILON)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}","lc":-0.0909090909,"pi":0.1578947368,"ma":0.0,"nbd":0.0,"ml":0.25,"d":0.2876984127,"mi":0.111205074,"fo":-0.25,"r":0.6578947368,"e":0.0238193208}
{"project_name":"Cli","project_version":"38","label":1,"code":"\/**\r\n * Tells if the token looks like a short option.\r\n *\r\n * @param token\r\n *\/\r\nprivate boolean isShortOption(String token) {\r\n    \/\/ short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\r\n    if (!token.startsWith(\"-\") || token.length() == 1) {\r\n        return false;\r\n    }\r\n    \/\/ remove leading \"-\" and \"=value\"\r\n    int pos = token.indexOf(\"=\");\r\n    String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\r\n    return options.hasShortOption(optName);\r\n\/\/ check for several concatenated short options\r\n}","code_comment":"\/**\r\n * Tells if the token looks like a short option.\r\n *\r\n * @param token\r\n *\/\r\n","code_no_comment":"private boolean isShortOption(String token) {\r\n        if (!token.startsWith(\"-\") || token.length() == 1) {\r\n        return false;\r\n    }\r\n        int pos = token.indexOf(\"=\");\r\n    String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\r\n    return options.hasShortOption(optName);\r\n}","lc":-0.2727272727,"pi":-0.2822966507,"ma":-0.2,"nbd":-0.5,"ml":0.0833333333,"d":0.3531746032,"mi":0.2662438337,"fo":0.0,"r":0.8947368421,"e":0.1014712747}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2249_6dde8e9d","label":1,"code":"@Override\r\npublic void restrict(FilterImpl f) {\r\n    if (propertyName != null) {\r\n        if (f.getSelector().equals(selector)) {\r\n            String pn = normalizePropertyName(propertyName);\r\n            f.restrictProperty(pn, Operator.NOT_EQUAL, null);\r\n        }\r\n    }\r\n    f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void restrict(FilterImpl f) {\r\n    if (propertyName != null) {\r\n        if (f.getSelector().equals(selector)) {\r\n            String pn = normalizePropertyName(propertyName);\r\n            f.restrictProperty(pn, Operator.NOT_EQUAL, null);\r\n        }\r\n    }\r\n    f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));\r\n}","lc":-0.1818181818,"pi":0.6746411483,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":-0.1130952381,"mi":0.1847780127,"fo":0.0833333333,"r":0.1842105263,"e":-0.0820847957}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5916_def03add","label":1,"code":"\/**\r\n *  Manually loads the model with the specified object. Subsequent calls to {@link #getObject()}\r\n *  will return {@code object} until {@link #detach()} is called.\r\n *\r\n *  @param object\r\n *             The object to set into the model\r\n *\/\r\n@Override\r\npublic void setObject(final T object) {\r\n    attached = true;\r\n    transientModelObject = object;\r\n}","code_comment":"\/**\r\n *  Manually loads the model with the specified object. Subsequent calls to {@link #getObject()}\r\n *  will return {@code object} until {@link #detach()} is called.\r\n *\r\n *  @param object\r\n *             The object to set into the model\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void setObject(final T object) {\r\n    attached = true;\r\n    transientModelObject = object;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7155743481,"fo":-0.5,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2999_3bf07779","label":1,"code":"@Override\r\npublic void propertyChanged(PropertyState before, PropertyState after) {\r\n    markPropertyChanged(before.getName());\r\n    checkAggregates(before.getName());\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void propertyChanged(PropertyState before, PropertyState after) {\r\n    markPropertyChanged(before.getName());\r\n    checkAggregates(before.getName());\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6910500352,"fo":-0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1460_f1ba7a42","label":1,"code":"private static void merge(NodeBuilder parent, PropertyState ours, PropertyState theirs) {\r\n    Set<String> theirOrder = Sets.newHashSet(theirs.getValue(Type.STRINGS));\r\n    PropertyBuilder<String> merged = PropertyBuilder.array(Type.STRING).assignFrom(theirs);\r\n    \/\/ Append child node names from ours that are not in theirs\r\n    for (String ourChild : ours.getValue(Type.STRINGS)) {\r\n        if (!theirOrder.contains(ourChild)) {\r\n            merged.addValue(ourChild);\r\n        }\r\n    }\r\n    \/\/ Remove child node names of nodes that have been removed\r\n    for (String child : merged.getValues()) {\r\n        if (!parent.hasChildNode(child)) {\r\n            merged.removeValue(child);\r\n        }\r\n    }\r\n    parent.setProperty(merged.getPropertyState());\r\n}","code_comment":null,"code_no_comment":"private static void merge(NodeBuilder parent, PropertyState ours, PropertyState theirs) {\r\n    Set<String> theirOrder = Sets.newHashSet(theirs.getValue(Type.STRINGS));\r\n    PropertyBuilder<String> merged = PropertyBuilder.array(Type.STRING).assignFrom(theirs);\r\n        for (String ourChild : ours.getValue(Type.STRINGS)) {\r\n        if (!theirOrder.contains(ourChild)) {\r\n            merged.addValue(ourChild);\r\n        }\r\n    }\r\n        for (String child : merged.getValues()) {\r\n        if (!parent.hasChildNode(child)) {\r\n            merged.removeValue(child);\r\n        }\r\n    }\r\n    parent.setProperty(merged.getPropertyState());\r\n}","lc":0.0454545455,"pi":0.2535885167,"ma":0.2,"nbd":0.0,"ml":0.0833333333,"d":-0.0099206349,"mi":-0.1159971811,"fo":0.5,"r":-0.0263157895,"e":0.0665571711}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2999_3bf07779","label":1,"code":"@Override\r\npublic void propertyDeleted(PropertyState before) {\r\n    markPropertyChanged(before.getName());\r\n    checkAggregates(before.getName());\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void propertyDeleted(PropertyState before) {\r\n    markPropertyChanged(before.getName());\r\n    checkAggregates(before.getName());\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7237491191,"fo":-0.1666666667,"r":0.0,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3314_4badd9c5","label":1,"code":"\/**\r\n * Inspects this processor definition and resolves any property placeholders from its properties.\r\n * <p\/>\r\n * This implementation will check all the getter\/setter pairs on this instance and for all the values\r\n * (which is a String type) will be property placeholder resolved.\r\n *\r\n * @param routeContext the route context\r\n * @throws Exception is thrown if property placeholders was used and there was an error resolving them\r\n * @see org.apache.camel.CamelContext#resolvePropertyPlaceholders(String)\r\n * @see org.apache.camel.component.properties.PropertiesComponent\r\n *\/\r\nprotected void resolvePropertyPlaceholders(RouteContext routeContext) throws Exception {\r\n    if (log.isTraceEnabled()) {\r\n        log.trace(\"Resolving property placeholders for: \" + this);\r\n    }\r\n    \/\/ find all String getter\/setter\r\n    Map<Object, Object> properties = new HashMap<Object, Object>();\r\n    IntrospectionSupport.getProperties(this, properties, null);\r\n    if (!properties.isEmpty()) {\r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"There are \" + properties.size() + \" properties on: \" + this);\r\n        }\r\n        \/\/ lookup and resolve properties for String based properties\r\n        for (Map.Entry entry : properties.entrySet()) {\r\n            \/\/ the name is always a String\r\n            String name = (String) entry.getKey();\r\n            Object value = entry.getValue();\r\n            if (value instanceof String) {\r\n                \/\/ we can only resolve String typed values\r\n                String text = (String) value;\r\n                text = routeContext.getCamelContext().resolvePropertyPlaceholders(text);\r\n                if (text != value) {\r\n                    \/\/ invoke setter as the text has changed\r\n                    IntrospectionSupport.setProperty(this, name, text);\r\n                    if (log.isDebugEnabled()) {\r\n                        log.debug(\"Changed property [\" + name + \"] from: \" + value + \" to: \" + text);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Inspects this processor definition and resolves any property placeholders from its properties.\r\n * <p\/>\r\n * This implementation will check all the getter\/setter pairs on this instance and for all the values\r\n * (which is a String type) will be property placeholder resolved.\r\n *\r\n * @param routeContext the route context\r\n * @throws Exception is thrown if property placeholders was used and there was an error resolving them\r\n * @see org.apache.camel.CamelContext#resolvePropertyPlaceholders(String)\r\n * @see org.apache.camel.component.properties.PropertiesComponent\r\n *\/\r\n","code_no_comment":"protected void resolvePropertyPlaceholders(RouteContext routeContext) throws Exception {\r\n    if (log.isTraceEnabled()) {\r\n        log.trace(\"Resolving property placeholders for: \" + this);\r\n    }\r\n        Map<Object, Object> properties = new HashMap<Object, Object>();\r\n    IntrospectionSupport.getProperties(this, properties, null);\r\n    if (!properties.isEmpty()) {\r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"There are \" + properties.size() + \" properties on: \" + this);\r\n        }\r\n                for (Map.Entry entry : properties.entrySet()) {\r\n                        String name = (String) entry.getKey();\r\n            Object value = entry.getValue();\r\n            if (value instanceof String) {\r\n                                String text = (String) value;\r\n                text = routeContext.getCamelContext().resolvePropertyPlaceholders(text);\r\n                if (text != value) {\r\n                                        IntrospectionSupport.setProperty(this, name, text);\r\n                    if (log.isDebugEnabled()) {\r\n                        log.debug(\"Changed property [\" + name + \"] from: \" + value + \" to: \" + text);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","lc":0.5454545455,"pi":1.6698564593,"ma":0.8,"nbd":1.5,"ml":0.5,"d":0.4285714286,"mi":-0.4531360113,"fo":0.75,"r":-0.0263157895,"e":0.6419829072}
{"project_name":"Math","project_version":"25","label":3,"code":"\/**\r\n * Estimate a first guess of the amplitude and angular frequency.\r\n * This method assumes that the {@link #sortObservations()} method\r\n * has been called previously.\r\n *\r\n * @throws ZeroException if the abscissa range is zero.\r\n * @throws MathIllegalStateException when the guessing procedure cannot\r\n * produce sensible results.\r\n *\/\r\nprivate void guessAOmega() {\r\n    \/\/ initialize the sums for the linear model between the two integrals\r\n    double sx2 = 0;\r\n    double sy2 = 0;\r\n    double sxy = 0;\r\n    double sxz = 0;\r\n    double syz = 0;\r\n    double currentX = observations[0].getX();\r\n    double currentY = observations[0].getY();\r\n    double f2Integral = 0;\r\n    double fPrime2Integral = 0;\r\n    final double startX = currentX;\r\n    for (int i = 1; i < observations.length; ++i) {\r\n        \/\/ one step forward\r\n        final double previousX = currentX;\r\n        final double previousY = currentY;\r\n        currentX = observations[i].getX();\r\n        currentY = observations[i].getY();\r\n        \/\/ update the integrals of f<sup>2<\/sup> and f'<sup>2<\/sup>\r\n        \/\/ considering a linear model for f (and therefore constant f')\r\n        final double dx = currentX - previousX;\r\n        final double dy = currentY - previousY;\r\n        final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) \/ 3;\r\n        final double fPrime2StepIntegral = dy * dy \/ dx;\r\n        final double x = currentX - startX;\r\n        f2Integral += f2StepIntegral;\r\n        fPrime2Integral += fPrime2StepIntegral;\r\n        sx2 += x * x;\r\n        sy2 += f2Integral * f2Integral;\r\n        sxy += x * f2Integral;\r\n        sxz += x * fPrime2Integral;\r\n        syz += f2Integral * fPrime2Integral;\r\n    }\r\n    \/\/ compute the amplitude and pulsation coefficients\r\n    double c1 = sy2 * sxz - sxy * syz;\r\n    double c2 = sxy * sxz - sx2 * syz;\r\n    double c3 = sx2 * sy2 - sxy * sxy;\r\n    if ((c1 \/ c2 < 0) || (c2 \/ c3 < 0)) {\r\n        final int last = observations.length - 1;\r\n        \/\/ Range of the observations, assuming that the\r\n        \/\/ observations are sorted.\r\n        final double xRange = observations[last].getX() - observations[0].getX();\r\n        if (xRange == 0) {\r\n            throw new ZeroException();\r\n        }\r\n        omega = 2 * Math.PI \/ xRange;\r\n        double yMin = Double.POSITIVE_INFINITY;\r\n        double yMax = Double.NEGATIVE_INFINITY;\r\n        for (int i = 1; i < observations.length; ++i) {\r\n            final double y = observations[i].getY();\r\n            if (y < yMin) {\r\n                yMin = y;\r\n            }\r\n            if (y > yMax) {\r\n                yMax = y;\r\n            }\r\n        }\r\n        a = 0.5 * (yMax - yMin);\r\n    } else {\r\n        \/\/ In some ill-conditioned cases (cf. MATH-844), the guesser\r\n        \/\/ procedure cannot produce sensible results.\r\n        a = FastMath.sqrt(c1 \/ c2);\r\n        omega = FastMath.sqrt(c2 \/ c3);\r\n    }\r\n}","code_comment":"\/**\r\n * Estimate a first guess of the amplitude and angular frequency.\r\n * This method assumes that the {@link #sortObservations()} method\r\n * has been called previously.\r\n *\r\n * @throws ZeroException if the abscissa range is zero.\r\n * @throws MathIllegalStateException when the guessing procedure cannot\r\n * produce sensible results.\r\n *\/\r\n","code_no_comment":"private void guessAOmega() {\r\n        double sx2 = 0;\r\n    double sy2 = 0;\r\n    double sxy = 0;\r\n    double sxz = 0;\r\n    double syz = 0;\r\n    double currentX = observations[0].getX();\r\n    double currentY = observations[0].getY();\r\n    double f2Integral = 0;\r\n    double fPrime2Integral = 0;\r\n    final double startX = currentX;\r\n    for (int i = 1; i < observations.length; ++i) {\r\n                final double previousX = currentX;\r\n        final double previousY = currentY;\r\n        currentX = observations[i].getX();\r\n        currentY = observations[i].getY();\r\n                        final double dx = currentX - previousX;\r\n        final double dy = currentY - previousY;\r\n        final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) \/ 3;\r\n        final double fPrime2StepIntegral = dy * dy \/ dx;\r\n        final double x = currentX - startX;\r\n        f2Integral += f2StepIntegral;\r\n        fPrime2Integral += fPrime2StepIntegral;\r\n        sx2 += x * x;\r\n        sy2 += f2Integral * f2Integral;\r\n        sxy += x * f2Integral;\r\n        sxz += x * fPrime2Integral;\r\n        syz += f2Integral * fPrime2Integral;\r\n    }\r\n        double c1 = sy2 * sxz - sxy * syz;\r\n    double c2 = sxy * sxz - sx2 * syz;\r\n    double c3 = sx2 * sy2 - sxy * sxy;\r\n    if ((c1 \/ c2 < 0) || (c2 \/ c3 < 0)) {\r\n        final int last = observations.length - 1;\r\n                        final double xRange = observations[last].getX() - observations[0].getX();\r\n        if (xRange == 0) {\r\n            throw new ZeroException();\r\n        }\r\n        omega = 2 * Math.PI \/ xRange;\r\n        double yMin = Double.POSITIVE_INFINITY;\r\n        double yMax = Double.NEGATIVE_INFINITY;\r\n        for (int i = 1; i < observations.length; ++i) {\r\n            final double y = observations[i].getY();\r\n            if (y < yMin) {\r\n                yMin = y;\r\n            }\r\n            if (y > yMax) {\r\n                yMax = y;\r\n            }\r\n        }\r\n        a = 0.5 * (yMax - yMin);\r\n    } else {\r\n                        a = FastMath.sqrt(c1 \/ c2);\r\n        omega = FastMath.sqrt(c2 \/ c3);\r\n    }\r\n}","lc":1.9090909091,"pi":0.1339712919,"ma":0.8,"nbd":0.5,"ml":0.9166666667,"d":3.0753968254,"mi":-0.9816772375,"fo":0.25,"r":-0.0263157895,"e":11.591982619}
{"project_name":"Closure","project_version":"74","label":2,"code":"\/**\r\n * Try to fold comparison nodes, e.g ==\r\n *\/\r\n@SuppressWarnings(\"fallthrough\")\r\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\r\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\r\n        \/\/ We only handle non-literal operands for LT and GT.\r\n        if (n.getType() != Token.GT && n.getType() != Token.LT) {\r\n            return n;\r\n        }\r\n    }\r\n    int op = n.getType();\r\n    boolean result;\r\n    \/\/ TODO(johnlenz): Use the JSType to compare nodes of different types.\r\n    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\r\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\r\n    int lhType = left.getType();\r\n    int rhType = right.getType();\r\n    switch(lhType) {\r\n        case Token.VOID:\r\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\r\n                return n;\r\n            } else if (!rightLiteral) {\r\n                return n;\r\n            } else {\r\n                result = compareToUndefined(right, op);\r\n            }\r\n            break;\r\n        case Token.NULL:\r\n        case Token.TRUE:\r\n        case Token.FALSE:\r\n            if (undefinedRight) {\r\n                result = compareToUndefined(left, op);\r\n                break;\r\n            }\r\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\r\n                return n;\r\n            }\r\n            switch(op) {\r\n                case Token.SHEQ:\r\n                case Token.EQ:\r\n                    result = lhType == rhType;\r\n                    break;\r\n                case Token.SHNE:\r\n                case Token.NE:\r\n                    result = lhType != rhType;\r\n                    break;\r\n                case Token.GE:\r\n                case Token.LE:\r\n                case Token.GT:\r\n                case Token.LT:\r\n                    Boolean compareResult = compareAsNumbers(op, left, right);\r\n                    if (compareResult != null) {\r\n                        result = compareResult;\r\n                    } else {\r\n                        return n;\r\n                    }\r\n                    break;\r\n                default:\r\n                    \/\/ we only handle == and != here\r\n                    return n;\r\n            }\r\n            break;\r\n        case Token.THIS:\r\n            if (right.getType() != Token.THIS) {\r\n                return n;\r\n            }\r\n            switch(op) {\r\n                case Token.SHEQ:\r\n                case Token.EQ:\r\n                    result = true;\r\n                    break;\r\n                case Token.SHNE:\r\n                case Token.NE:\r\n                    result = false;\r\n                    break;\r\n                \/\/ whether it is a string, NaN or other number value.\r\n                default:\r\n                    return n;\r\n            }\r\n            break;\r\n        case Token.STRING:\r\n            if (undefinedRight) {\r\n                result = compareToUndefined(left, op);\r\n                break;\r\n            }\r\n            if (Token.STRING != right.getType()) {\r\n                \/\/ Only eval if they are the same type\r\n                return n;\r\n            }\r\n            switch(op) {\r\n                case Token.SHEQ:\r\n                case Token.EQ:\r\n                    result = left.getString().equals(right.getString());\r\n                    break;\r\n                case Token.SHNE:\r\n                case Token.NE:\r\n                    result = !left.getString().equals(right.getString());\r\n                    break;\r\n                default:\r\n                    \/\/ we only handle == and != here\r\n                    return n;\r\n            }\r\n            break;\r\n        case Token.NUMBER:\r\n            if (undefinedRight) {\r\n                result = compareToUndefined(left, op);\r\n                break;\r\n            }\r\n            if (Token.NUMBER != right.getType()) {\r\n                \/\/ Only eval if they are the same type\r\n                return n;\r\n            }\r\n            Boolean compareResult = compareAsNumbers(op, left, right);\r\n            if (compareResult != null) {\r\n                result = compareResult;\r\n            } else {\r\n                return null;\r\n            }\r\n            break;\r\n        case Token.NAME:\r\n            if (undefinedRight) {\r\n                result = compareToUndefined(left, op);\r\n                break;\r\n            }\r\n            if (rightLiteral) {\r\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\r\n                if (undefinedLeft) {\r\n                    result = compareToUndefined(right, op);\r\n                    break;\r\n                }\r\n            }\r\n            if (Token.NAME != right.getType()) {\r\n                \/\/ Only eval if they are the same type\r\n                return n;\r\n            }\r\n            String ln = left.getString();\r\n            String rn = right.getString();\r\n            if (!ln.equals(rn)) {\r\n                \/\/ Not the same value name.\r\n                return n;\r\n            }\r\n            switch(op) {\r\n                \/\/ to handle EQ,NE,LE,GE,SHEQ, and SHNE.\r\n                case Token.LT:\r\n                case Token.GT:\r\n                    result = false;\r\n                    break;\r\n                default:\r\n                    \/\/ don't handle that op\r\n                    return n;\r\n            }\r\n            break;\r\n        default:\r\n            \/\/ assert, this should cover all consts\r\n            return n;\r\n    }\r\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\r\n    n.getParent().replaceChild(n, newNode);\r\n    reportCodeChange();\r\n    return newNode;\r\n}","code_comment":"\/**\r\n * Try to fold comparison nodes, e.g ==\r\n *\/\r\n","code_no_comment":"@SuppressWarnings(\"fallthrough\")\r\nprivate Node tryFoldComparison(Node n, Node left, Node right) {\r\n    if (!NodeUtil.isLiteralValue(left, false) || !NodeUtil.isLiteralValue(right, false)) {\r\n                if (n.getType() != Token.GT && n.getType() != Token.LT) {\r\n            return n;\r\n        }\r\n    }\r\n    int op = n.getType();\r\n    boolean result;\r\n        boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\r\n    boolean undefinedRight = ((Token.NAME == right.getType() && right.getString().equals(\"undefined\")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\r\n    int lhType = left.getType();\r\n    int rhType = right.getType();\r\n    switch(lhType) {\r\n        case Token.VOID:\r\n            if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\r\n                return n;\r\n            } else if (!rightLiteral) {\r\n                return n;\r\n            } else {\r\n                result = compareToUndefined(right, op);\r\n            }\r\n            break;\r\n        case Token.NULL:\r\n        case Token.TRUE:\r\n        case Token.FALSE:\r\n            if (undefinedRight) {\r\n                result = compareToUndefined(left, op);\r\n                break;\r\n            }\r\n            if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {\r\n                return n;\r\n            }\r\n            switch(op) {\r\n                case Token.SHEQ:\r\n                case Token.EQ:\r\n                    result = lhType == rhType;\r\n                    break;\r\n                case Token.SHNE:\r\n                case Token.NE:\r\n                    result = lhType != rhType;\r\n                    break;\r\n                case Token.GE:\r\n                case Token.LE:\r\n                case Token.GT:\r\n                case Token.LT:\r\n                    Boolean compareResult = compareAsNumbers(op, left, right);\r\n                    if (compareResult != null) {\r\n                        result = compareResult;\r\n                    } else {\r\n                        return n;\r\n                    }\r\n                    break;\r\n                default:\r\n                                        return n;\r\n            }\r\n            break;\r\n        case Token.THIS:\r\n            if (right.getType() != Token.THIS) {\r\n                return n;\r\n            }\r\n            switch(op) {\r\n                case Token.SHEQ:\r\n                case Token.EQ:\r\n                    result = true;\r\n                    break;\r\n                case Token.SHNE:\r\n                case Token.NE:\r\n                    result = false;\r\n                    break;\r\n                                default:\r\n                    return n;\r\n            }\r\n            break;\r\n        case Token.STRING:\r\n            if (undefinedRight) {\r\n                result = compareToUndefined(left, op);\r\n                break;\r\n            }\r\n            if (Token.STRING != right.getType()) {\r\n                                return n;\r\n            }\r\n            switch(op) {\r\n                case Token.SHEQ:\r\n                case Token.EQ:\r\n                    result = left.getString().equals(right.getString());\r\n                    break;\r\n                case Token.SHNE:\r\n                case Token.NE:\r\n                    result = !left.getString().equals(right.getString());\r\n                    break;\r\n                default:\r\n                                        return n;\r\n            }\r\n            break;\r\n        case Token.NUMBER:\r\n            if (undefinedRight) {\r\n                result = compareToUndefined(left, op);\r\n                break;\r\n            }\r\n            if (Token.NUMBER != right.getType()) {\r\n                                return n;\r\n            }\r\n            Boolean compareResult = compareAsNumbers(op, left, right);\r\n            if (compareResult != null) {\r\n                result = compareResult;\r\n            } else {\r\n                return null;\r\n            }\r\n            break;\r\n        case Token.NAME:\r\n            if (undefinedRight) {\r\n                result = compareToUndefined(left, op);\r\n                break;\r\n            }\r\n            if (rightLiteral) {\r\n                boolean undefinedLeft = (left.getString().equals(\"undefined\"));\r\n                if (undefinedLeft) {\r\n                    result = compareToUndefined(right, op);\r\n                    break;\r\n                }\r\n            }\r\n            if (Token.NAME != right.getType()) {\r\n                                return n;\r\n            }\r\n            String ln = left.getString();\r\n            String rn = right.getString();\r\n            if (!ln.equals(rn)) {\r\n                                return n;\r\n            }\r\n            switch(op) {\r\n                                case Token.LT:\r\n                case Token.GT:\r\n                    result = false;\r\n                    break;\r\n                default:\r\n                                        return n;\r\n            }\r\n            break;\r\n        default:\r\n                        return n;\r\n    }\r\n    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\r\n    n.getParent().replaceChild(n, newNode);\r\n    reportCodeChange();\r\n    return newNode;\r\n}","lc":6.0454545455,"pi":1.004784689,"ma":13.2,"nbd":1.5,"ml":5.1666666667,"d":2.6567460317,"mi":-1.8617336152,"fo":3.0,"r":-0.0263157895,"e":13.1756666263}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-428_d906576c","label":3,"code":"\/**\r\n *  @see java.util.Map#values()\r\n *\/\r\npublic Collection values() {\r\n    return new AbstractList() {\r\n\r\n        public Object get(final int index) {\r\n            return value;\r\n        }\r\n\r\n        public int size() {\r\n            return MicroMap.this.size();\r\n        }\r\n    };\r\n}","code_comment":"\/**\r\n *  @see java.util.Map#values()\r\n *\/\r\n","code_no_comment":"public Collection values() {\r\n    return new AbstractList() {\r\n\r\n        public Object get(final int index) {\r\n            return value;\r\n        }\r\n\r\n        public int size() {\r\n            return MicroMap.this.size();\r\n        }\r\n    };\r\n}","lc":-0.1818181818,"pi":0.5215311005,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.392248062,"fo":-0.4166666667,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-523_837dcd89","label":1,"code":"private void writeObject(final ObjectOutputStream out) throws IOException {\r\n    out.defaultWriteObject();\r\n    getFormattedMessage();\r\n    out.writeUTF(formattedMessage);\r\n    out.writeUTF(messagePattern);\r\n    out.writeUTF(baseName);\r\n    out.writeInt(argArray.length);\r\n    stringArgs = new String[argArray.length];\r\n    int i = 0;\r\n    for (final Object obj : argArray) {\r\n        stringArgs[i] = obj.toString();\r\n        ++i;\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void writeObject(final ObjectOutputStream out) throws IOException {\r\n    out.defaultWriteObject();\r\n    getFormattedMessage();\r\n    out.writeUTF(formattedMessage);\r\n    out.writeUTF(messagePattern);\r\n    out.writeUTF(baseName);\r\n    out.writeInt(argArray.length);\r\n    stringArgs = new String[argArray.length];\r\n    int i = 0;\r\n    for (final Object obj : argArray) {\r\n        stringArgs[i] = obj.toString();\r\n        ++i;\r\n    }\r\n}","lc":0.0,"pi":-0.4066985646,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.0337301587,"mi":0.0012684989,"fo":0.0833333333,"r":0.0,"e":-0.0272355826}
{"project_name":"Math","project_version":"5","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic Complex reciprocal() {\r\n    if (isNaN) {\r\n        return NaN;\r\n    }\r\n    if (real == 0.0 && imaginary == 0.0) {\r\n        return NaN;\r\n    }\r\n    if (isInfinite) {\r\n        return ZERO;\r\n    }\r\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\r\n        double q = real \/ imaginary;\r\n        double scale = 1. \/ (real * q + imaginary);\r\n        return createComplex(scale * q, -scale);\r\n    } else {\r\n        double q = imaginary \/ real;\r\n        double scale = 1. \/ (imaginary * q + real);\r\n        return createComplex(scale, -scale * q);\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public Complex reciprocal() {\r\n    if (isNaN) {\r\n        return NaN;\r\n    }\r\n    if (real == 0.0 && imaginary == 0.0) {\r\n        return NaN;\r\n    }\r\n    if (isInfinite) {\r\n        return ZERO;\r\n    }\r\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\r\n        double q = real \/ imaginary;\r\n        double scale = 1. \/ (real * q + imaginary);\r\n        return createComplex(scale * q, -scale);\r\n    } else {\r\n        double q = imaginary \/ real;\r\n        double scale = 1. \/ (imaginary * q + real);\r\n        return createComplex(scale, -scale * q);\r\n    }\r\n}","lc":0.2727272727,"pi":-0.1770334928,"ma":0.2,"nbd":-0.5,"ml":0.5,"d":1.7182539683,"mi":-0.2510218464,"fo":-0.1666666667,"r":0.4473684211,"e":1.2133054408}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-678_6c54045d","label":1,"code":"@Nonnull\r\nprivate MutableNodeState write(long newRevision, boolean reconnect) {\r\n    \/\/ make sure that all revision numbers up to the root gets updated\r\n    if (!isRoot()) {\r\n        checkState(reconnect || exists(), \"This node has been removed\");\r\n        parent.write(newRevision, reconnect);\r\n    }\r\n    if (writeState == null || revision != root.revision) {\r\n        \/\/ root never gets here since revision == root.revision\r\n        assert (!isRoot());\r\n        \/\/ The builder could have been reset, need to re-get base state\r\n        baseState = parent.getBaseState(name);\r\n        writeState = parent.getWriteState(name);\r\n        if (writeState == null) {\r\n            if (exists()) {\r\n                assert baseState != null;\r\n                writeState = new MutableNodeState(baseState);\r\n            } else {\r\n                writeState = new MutableNodeState(null);\r\n            }\r\n            \/\/ guaranteed by called parent.write()\r\n            assert parent.writeState != null;\r\n            parent.writeState.nodes.put(name, writeState);\r\n        }\r\n    }\r\n    revision = newRevision;\r\n    assert classInvariants();\r\n    assert writeState != null;\r\n    return writeState;\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\nprivate MutableNodeState write(long newRevision, boolean reconnect) {\r\n        if (!isRoot()) {\r\n        checkState(reconnect || exists(), \"This node has been removed\");\r\n        parent.write(newRevision, reconnect);\r\n    }\r\n    if (writeState == null || revision != root.revision) {\r\n                assert (!isRoot());\r\n                baseState = parent.getBaseState(name);\r\n        writeState = parent.getWriteState(name);\r\n        if (writeState == null) {\r\n            if (exists()) {\r\n                assert baseState != null;\r\n                writeState = new MutableNodeState(baseState);\r\n            } else {\r\n                writeState = new MutableNodeState(null);\r\n            }\r\n                        assert parent.writeState != null;\r\n            parent.writeState.nodes.put(name, writeState);\r\n        }\r\n    }\r\n    revision = newRevision;\r\n    assert classInvariants();\r\n    assert writeState != null;\r\n    return writeState;\r\n}","lc":0.5454545455,"pi":0.8421052632,"ma":0.2,"nbd":0.5,"ml":0.4166666667,"d":-0.3650793651,"mi":0.0553911205,"fo":0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5712_145da021","label":3,"code":"@Override\r\nprotected UrlInfo parseRequest(Request request) {\r\n    if (matches(request)) {\r\n        Url url = request.getUrl();\r\n        \/\/ try to extract page and component information from URL\r\n        PageComponentInfo info = getPageComponentInfo(url);\r\n        List<String> segments = url.getSegments();\r\n        \/\/ load the page class\r\n        String className;\r\n        if (segments.size() >= 3) {\r\n            className = segments.get(2);\r\n        } else {\r\n            className = segments.get(1);\r\n        }\r\n        Class<? extends IRequestablePage> pageClass = getPageClass(className);\r\n        if (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass)) {\r\n            if (Application.exists()) {\r\n                Application application = Application.get();\r\n                if (application.getSecuritySettings().getEnforceMounts()) {\r\n                    \/\/ we make an exception if the homepage itself was mounted, see WICKET-1898\r\n                    if (!pageClass.equals(application.getHomePage())) {\r\n                        \/\/ WICKET-5094 only enforce mount if page is mounted\r\n                        if (isPageMounted(pageClass, application)) {\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \/\/ extract the PageParameters from URL if there are any\r\n            PageParameters pageParameters = extractPageParameters(request, 3, pageParametersEncoder);\r\n            return new UrlInfo(info, pageClass, pageParameters);\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected UrlInfo parseRequest(Request request) {\r\n    if (matches(request)) {\r\n        Url url = request.getUrl();\r\n                PageComponentInfo info = getPageComponentInfo(url);\r\n        List<String> segments = url.getSegments();\r\n                String className;\r\n        if (segments.size() >= 3) {\r\n            className = segments.get(2);\r\n        } else {\r\n            className = segments.get(1);\r\n        }\r\n        Class<? extends IRequestablePage> pageClass = getPageClass(className);\r\n        if (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass)) {\r\n            if (Application.exists()) {\r\n                Application application = Application.get();\r\n                if (application.getSecuritySettings().getEnforceMounts()) {\r\n                                        if (!pageClass.equals(application.getHomePage())) {\r\n                                                if (isPageMounted(pageClass, application)) {\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n                        PageParameters pageParameters = extractPageParameters(request, 3, pageParametersEncoder);\r\n            return new UrlInfo(info, pageClass, pageParameters);\r\n        }\r\n    }\r\n    return null;\r\n}","lc":0.7272727273,"pi":1.9186602871,"ma":0.8,"nbd":2.0,"ml":1.1666666667,"d":0.3313492063,"mi":-0.5275546159,"fo":0.9166666667,"r":-0.0263157895,"e":0.588502965}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3566_434e88fd","label":1,"code":"@SuppressWarnings(\"unchecked\")\r\nprivate static void validateInfo(ArrayList<Type> typeHierarchy, Type type, TypeInformation<?> typeInfo) {\r\n    if (type == null) {\r\n        throw new InvalidTypesException(\"Unknown Error. Type is null.\");\r\n    }\r\n    if (typeInfo == null) {\r\n        throw new InvalidTypesException(\"Unknown Error. TypeInformation is null.\");\r\n    }\r\n    if (!(type instanceof TypeVariable<?>)) {\r\n        \/\/ check for basic type\r\n        if (typeInfo.isBasicType()) {\r\n            TypeInformation<?> actual;\r\n            \/\/ check if basic type at all\r\n            if (!(type instanceof Class<?>) || (actual = BasicTypeInfo.getInfoFor((Class<?>) type)) == null) {\r\n                throw new InvalidTypesException(\"Basic type expected.\");\r\n            }\r\n            \/\/ check if correct basic type\r\n            if (!typeInfo.equals(actual)) {\r\n                throw new InvalidTypesException(\"Basic type '\" + typeInfo + \"' expected but was '\" + actual + \"'.\");\r\n            }\r\n        } else \/\/ check for tuple\r\n        if (typeInfo.isTupleType()) {\r\n            \/\/ check if tuple at all\r\n            if (!(isClassType(type) && Tuple.class.isAssignableFrom(typeToClass(type)))) {\r\n                throw new InvalidTypesException(\"Tuple type expected.\");\r\n            }\r\n            \/\/ do not allow usage of Tuple as type\r\n            if (isClassType(type) && typeToClass(type).equals(Tuple.class)) {\r\n                throw new InvalidTypesException(\"Concrete subclass of Tuple expected.\");\r\n            }\r\n            \/\/ go up the hierarchy until we reach immediate child of Tuple (with or without generics)\r\n            while (!(isClassType(type) && typeToClass(type).getSuperclass().equals(Tuple.class))) {\r\n                typeHierarchy.add(type);\r\n                type = typeToClass(type).getGenericSuperclass();\r\n            }\r\n            if (type == Tuple0.class) {\r\n                return;\r\n            }\r\n            \/\/ check if immediate child of Tuple has generics\r\n            if (type instanceof Class<?>) {\r\n                throw new InvalidTypesException(\"Parameterized Tuple type expected.\");\r\n            }\r\n            TupleTypeInfo<?> tti = (TupleTypeInfo<?>) typeInfo;\r\n            Type[] subTypes = ((ParameterizedType) type).getActualTypeArguments();\r\n            if (subTypes.length != tti.getArity()) {\r\n                throw new InvalidTypesException(\"Tuple arity '\" + tti.getArity() + \"' expected but was '\" + subTypes.length + \"'.\");\r\n            }\r\n            for (int i = 0; i < subTypes.length; i++) {\r\n                validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[i], tti.getTypeAt(i));\r\n            }\r\n        } else \/\/ check for Either\r\n        if (typeInfo instanceof EitherTypeInfo) {\r\n            \/\/ check if Either at all\r\n            if (!(isClassType(type) && Either.class.isAssignableFrom(typeToClass(type)))) {\r\n                throw new InvalidTypesException(\"Either type expected.\");\r\n            }\r\n            \/\/ go up the hierarchy until we reach Either (with or without generics)\r\n            while (!(isClassType(type) && typeToClass(type).equals(Either.class))) {\r\n                typeHierarchy.add(type);\r\n                type = typeToClass(type).getGenericSuperclass();\r\n            }\r\n            \/\/ check if Either has generics\r\n            if (type instanceof Class<?>) {\r\n                throw new InvalidTypesException(\"Parameterized Either type expected.\");\r\n            }\r\n            EitherTypeInfo<?, ?> eti = (EitherTypeInfo<?, ?>) typeInfo;\r\n            Type[] subTypes = ((ParameterizedType) type).getActualTypeArguments();\r\n            validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[0], eti.getLeftType());\r\n            validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[1], eti.getRightType());\r\n        } else \/\/ check for Writable\r\n        if (typeInfo instanceof WritableTypeInfo<?>) {\r\n            \/\/ check if writable at all\r\n            if (!(type instanceof Class<?> && Writable.class.isAssignableFrom((Class<?>) type))) {\r\n                throw new InvalidTypesException(\"Writable type expected.\");\r\n            }\r\n            \/\/ check writable type contents\r\n            Class<?> clazz;\r\n            if (((WritableTypeInfo<?>) typeInfo).getTypeClass() != (clazz = (Class<?>) type)) {\r\n                throw new InvalidTypesException(\"Writable type '\" + ((WritableTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + \"' expected but was '\" + clazz.getCanonicalName() + \"'.\");\r\n            }\r\n        } else \/\/ check for primitive array\r\n        if (typeInfo instanceof PrimitiveArrayTypeInfo) {\r\n            Type component;\r\n            \/\/ check if array at all\r\n            if (!(type instanceof Class<?> && ((Class<?>) type).isArray() && (component = ((Class<?>) type).getComponentType()) != null) && !(type instanceof GenericArrayType && (component = ((GenericArrayType) type).getGenericComponentType()) != null)) {\r\n                throw new InvalidTypesException(\"Array type expected.\");\r\n            }\r\n            if (component instanceof TypeVariable<?>) {\r\n                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);\r\n                if (component instanceof TypeVariable) {\r\n                    return;\r\n                }\r\n            }\r\n            if (!(component instanceof Class<?> && ((Class<?>) component).isPrimitive())) {\r\n                throw new InvalidTypesException(\"Primitive component expected.\");\r\n            }\r\n        } else \/\/ check for basic array\r\n        if (typeInfo instanceof BasicArrayTypeInfo<?, ?>) {\r\n            Type component;\r\n            \/\/ check if array at all\r\n            if (!(type instanceof Class<?> && ((Class<?>) type).isArray() && (component = ((Class<?>) type).getComponentType()) != null) && !(type instanceof GenericArrayType && (component = ((GenericArrayType) type).getGenericComponentType()) != null)) {\r\n                throw new InvalidTypesException(\"Array type expected.\");\r\n            }\r\n            if (component instanceof TypeVariable<?>) {\r\n                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);\r\n                if (component instanceof TypeVariable) {\r\n                    return;\r\n                }\r\n            }\r\n            validateInfo(typeHierarchy, component, ((BasicArrayTypeInfo<?, ?>) typeInfo).getComponentInfo());\r\n        } else \/\/ check for object array\r\n        if (typeInfo instanceof ObjectArrayTypeInfo<?, ?>) {\r\n            \/\/ check if array at all\r\n            if (!(type instanceof Class<?> && ((Class<?>) type).isArray()) && !(type instanceof GenericArrayType)) {\r\n                throw new InvalidTypesException(\"Object array type expected.\");\r\n            }\r\n            \/\/ check component\r\n            Type component;\r\n            if (type instanceof Class<?>) {\r\n                component = ((Class<?>) type).getComponentType();\r\n            } else {\r\n                component = ((GenericArrayType) type).getGenericComponentType();\r\n            }\r\n            if (component instanceof TypeVariable<?>) {\r\n                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);\r\n                if (component instanceof TypeVariable) {\r\n                    return;\r\n                }\r\n            }\r\n            validateInfo(typeHierarchy, component, ((ObjectArrayTypeInfo<?, ?>) typeInfo).getComponentInfo());\r\n        } else \/\/ check for value\r\n        if (typeInfo instanceof ValueTypeInfo<?>) {\r\n            \/\/ check if value at all\r\n            if (!(type instanceof Class<?> && Value.class.isAssignableFrom((Class<?>) type))) {\r\n                throw new InvalidTypesException(\"Value type expected.\");\r\n            }\r\n            TypeInformation<?> actual;\r\n            \/\/ check value type contents\r\n            if (!((ValueTypeInfo<?>) typeInfo).equals(actual = ValueTypeInfo.getValueTypeInfo((Class<? extends Value>) type))) {\r\n                throw new InvalidTypesException(\"Value type '\" + typeInfo + \"' expected but was '\" + actual + \"'.\");\r\n            }\r\n        } else \/\/ check for POJO\r\n        if (typeInfo instanceof PojoTypeInfo) {\r\n            Class<?> clazz = null;\r\n            if (!(isClassType(type) && ((PojoTypeInfo<?>) typeInfo).getTypeClass() == (clazz = typeToClass(type)))) {\r\n                throw new InvalidTypesException(\"POJO type '\" + ((PojoTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + \"' expected but was '\" + clazz.getCanonicalName() + \"'.\");\r\n            }\r\n        } else \/\/ check for Enum\r\n        if (typeInfo instanceof EnumTypeInfo) {\r\n            if (!(type instanceof Class<?> && Enum.class.isAssignableFrom((Class<?>) type))) {\r\n                throw new InvalidTypesException(\"Enum type expected.\");\r\n            }\r\n            \/\/ check enum type contents\r\n            if (!(typeInfo.getTypeClass() == type)) {\r\n                throw new InvalidTypesException(\"Enum type '\" + typeInfo.getTypeClass().getCanonicalName() + \"' expected but was '\" + typeToClass(type).getCanonicalName() + \"'.\");\r\n            }\r\n        } else \/\/ check for generic object\r\n        if (typeInfo instanceof GenericTypeInfo<?>) {\r\n            Class<?> clazz = null;\r\n            if (!(isClassType(type) && ((GenericTypeInfo<?>) typeInfo).getTypeClass() == (clazz = typeToClass(type)))) {\r\n                throw new InvalidTypesException(\"Generic object type '\" + ((GenericTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + \"' expected but was '\" + clazz.getCanonicalName() + \"'.\");\r\n            }\r\n        }\r\n    } else {\r\n        type = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) type);\r\n        if (!(type instanceof TypeVariable)) {\r\n            validateInfo(typeHierarchy, type, typeInfo);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings(\"unchecked\")\r\nprivate static void validateInfo(ArrayList<Type> typeHierarchy, Type type, TypeInformation<?> typeInfo) {\r\n    if (type == null) {\r\n        throw new InvalidTypesException(\"Unknown Error. Type is null.\");\r\n    }\r\n    if (typeInfo == null) {\r\n        throw new InvalidTypesException(\"Unknown Error. TypeInformation is null.\");\r\n    }\r\n    if (!(type instanceof TypeVariable<?>)) {\r\n                if (typeInfo.isBasicType()) {\r\n            TypeInformation<?> actual;\r\n                        if (!(type instanceof Class<?>) || (actual = BasicTypeInfo.getInfoFor((Class<?>) type)) == null) {\r\n                throw new InvalidTypesException(\"Basic type expected.\");\r\n            }\r\n                        if (!typeInfo.equals(actual)) {\r\n                throw new InvalidTypesException(\"Basic type '\" + typeInfo + \"' expected but was '\" + actual + \"'.\");\r\n            }\r\n        } else         if (typeInfo.isTupleType()) {\r\n                        if (!(isClassType(type) && Tuple.class.isAssignableFrom(typeToClass(type)))) {\r\n                throw new InvalidTypesException(\"Tuple type expected.\");\r\n            }\r\n                        if (isClassType(type) && typeToClass(type).equals(Tuple.class)) {\r\n                throw new InvalidTypesException(\"Concrete subclass of Tuple expected.\");\r\n            }\r\n                        while (!(isClassType(type) && typeToClass(type).getSuperclass().equals(Tuple.class))) {\r\n                typeHierarchy.add(type);\r\n                type = typeToClass(type).getGenericSuperclass();\r\n            }\r\n            if (type == Tuple0.class) {\r\n                return;\r\n            }\r\n                        if (type instanceof Class<?>) {\r\n                throw new InvalidTypesException(\"Parameterized Tuple type expected.\");\r\n            }\r\n            TupleTypeInfo<?> tti = (TupleTypeInfo<?>) typeInfo;\r\n            Type[] subTypes = ((ParameterizedType) type).getActualTypeArguments();\r\n            if (subTypes.length != tti.getArity()) {\r\n                throw new InvalidTypesException(\"Tuple arity '\" + tti.getArity() + \"' expected but was '\" + subTypes.length + \"'.\");\r\n            }\r\n            for (int i = 0; i < subTypes.length; i++) {\r\n                validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[i], tti.getTypeAt(i));\r\n            }\r\n        } else         if (typeInfo instanceof EitherTypeInfo) {\r\n                        if (!(isClassType(type) && Either.class.isAssignableFrom(typeToClass(type)))) {\r\n                throw new InvalidTypesException(\"Either type expected.\");\r\n            }\r\n                        while (!(isClassType(type) && typeToClass(type).equals(Either.class))) {\r\n                typeHierarchy.add(type);\r\n                type = typeToClass(type).getGenericSuperclass();\r\n            }\r\n                        if (type instanceof Class<?>) {\r\n                throw new InvalidTypesException(\"Parameterized Either type expected.\");\r\n            }\r\n            EitherTypeInfo<?, ?> eti = (EitherTypeInfo<?, ?>) typeInfo;\r\n            Type[] subTypes = ((ParameterizedType) type).getActualTypeArguments();\r\n            validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[0], eti.getLeftType());\r\n            validateInfo(new ArrayList<Type>(typeHierarchy), subTypes[1], eti.getRightType());\r\n        } else         if (typeInfo instanceof WritableTypeInfo<?>) {\r\n                        if (!(type instanceof Class<?> && Writable.class.isAssignableFrom((Class<?>) type))) {\r\n                throw new InvalidTypesException(\"Writable type expected.\");\r\n            }\r\n                        Class<?> clazz;\r\n            if (((WritableTypeInfo<?>) typeInfo).getTypeClass() != (clazz = (Class<?>) type)) {\r\n                throw new InvalidTypesException(\"Writable type '\" + ((WritableTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + \"' expected but was '\" + clazz.getCanonicalName() + \"'.\");\r\n            }\r\n        } else         if (typeInfo instanceof PrimitiveArrayTypeInfo) {\r\n            Type component;\r\n                        if (!(type instanceof Class<?> && ((Class<?>) type).isArray() && (component = ((Class<?>) type).getComponentType()) != null) && !(type instanceof GenericArrayType && (component = ((GenericArrayType) type).getGenericComponentType()) != null)) {\r\n                throw new InvalidTypesException(\"Array type expected.\");\r\n            }\r\n            if (component instanceof TypeVariable<?>) {\r\n                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);\r\n                if (component instanceof TypeVariable) {\r\n                    return;\r\n                }\r\n            }\r\n            if (!(component instanceof Class<?> && ((Class<?>) component).isPrimitive())) {\r\n                throw new InvalidTypesException(\"Primitive component expected.\");\r\n            }\r\n        } else         if (typeInfo instanceof BasicArrayTypeInfo<?, ?>) {\r\n            Type component;\r\n                        if (!(type instanceof Class<?> && ((Class<?>) type).isArray() && (component = ((Class<?>) type).getComponentType()) != null) && !(type instanceof GenericArrayType && (component = ((GenericArrayType) type).getGenericComponentType()) != null)) {\r\n                throw new InvalidTypesException(\"Array type expected.\");\r\n            }\r\n            if (component instanceof TypeVariable<?>) {\r\n                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);\r\n                if (component instanceof TypeVariable) {\r\n                    return;\r\n                }\r\n            }\r\n            validateInfo(typeHierarchy, component, ((BasicArrayTypeInfo<?, ?>) typeInfo).getComponentInfo());\r\n        } else         if (typeInfo instanceof ObjectArrayTypeInfo<?, ?>) {\r\n                        if (!(type instanceof Class<?> && ((Class<?>) type).isArray()) && !(type instanceof GenericArrayType)) {\r\n                throw new InvalidTypesException(\"Object array type expected.\");\r\n            }\r\n                        Type component;\r\n            if (type instanceof Class<?>) {\r\n                component = ((Class<?>) type).getComponentType();\r\n            } else {\r\n                component = ((GenericArrayType) type).getGenericComponentType();\r\n            }\r\n            if (component instanceof TypeVariable<?>) {\r\n                component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);\r\n                if (component instanceof TypeVariable) {\r\n                    return;\r\n                }\r\n            }\r\n            validateInfo(typeHierarchy, component, ((ObjectArrayTypeInfo<?, ?>) typeInfo).getComponentInfo());\r\n        } else         if (typeInfo instanceof ValueTypeInfo<?>) {\r\n                        if (!(type instanceof Class<?> && Value.class.isAssignableFrom((Class<?>) type))) {\r\n                throw new InvalidTypesException(\"Value type expected.\");\r\n            }\r\n            TypeInformation<?> actual;\r\n                        if (!((ValueTypeInfo<?>) typeInfo).equals(actual = ValueTypeInfo.getValueTypeInfo((Class<? extends Value>) type))) {\r\n                throw new InvalidTypesException(\"Value type '\" + typeInfo + \"' expected but was '\" + actual + \"'.\");\r\n            }\r\n        } else         if (typeInfo instanceof PojoTypeInfo) {\r\n            Class<?> clazz = null;\r\n            if (!(isClassType(type) && ((PojoTypeInfo<?>) typeInfo).getTypeClass() == (clazz = typeToClass(type)))) {\r\n                throw new InvalidTypesException(\"POJO type '\" + ((PojoTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + \"' expected but was '\" + clazz.getCanonicalName() + \"'.\");\r\n            }\r\n        } else         if (typeInfo instanceof EnumTypeInfo) {\r\n            if (!(type instanceof Class<?> && Enum.class.isAssignableFrom((Class<?>) type))) {\r\n                throw new InvalidTypesException(\"Enum type expected.\");\r\n            }\r\n                        if (!(typeInfo.getTypeClass() == type)) {\r\n                throw new InvalidTypesException(\"Enum type '\" + typeInfo.getTypeClass().getCanonicalName() + \"' expected but was '\" + typeToClass(type).getCanonicalName() + \"'.\");\r\n            }\r\n        } else         if (typeInfo instanceof GenericTypeInfo<?>) {\r\n            Class<?> clazz = null;\r\n            if (!(isClassType(type) && ((GenericTypeInfo<?>) typeInfo).getTypeClass() == (clazz = typeToClass(type)))) {\r\n                throw new InvalidTypesException(\"Generic object type '\" + ((GenericTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + \"' expected but was '\" + clazz.getCanonicalName() + \"'.\");\r\n            }\r\n        }\r\n    } else {\r\n        type = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) type);\r\n        if (!(type instanceof TypeVariable)) {\r\n            validateInfo(typeHierarchy, type, typeInfo);\r\n        }\r\n    }\r\n}","lc":6.2272727273,"pi":0.3492822967,"ma":13.0,"nbd":5.5,"ml":7.5,"d":3.3392857143,"mi":-1.9513742072,"fo":6.25,"r":-0.0263157895,"e":28.8196377425}
{"project_name":"Codec","project_version":"15","label":1,"code":"\/**\r\n * Used internally by the Soundex algorithm.\r\n *\r\n * Consonants from the same code group separated by W or H are treated as one.\r\n *\r\n * @param str\r\n *                  the cleaned working string to encode (in upper case).\r\n * @param index\r\n *                  the character position to encode\r\n * @return Mapping code for a particular character\r\n * @throws IllegalArgumentException\r\n *                  if the character is not mapped\r\n *\/\r\nprivate char getMappingCode(final String str, final int index) {\r\n    \/\/ map() throws IllegalArgumentException\r\n    final char mappedChar = this.map(str.charAt(index));\r\n    \/\/ HW rule check\r\n    if (index > 1 && mappedChar != '0') {\r\n        final char hwChar = str.charAt(index - 1);\r\n        if ('H' == hwChar || 'W' == hwChar) {\r\n            final char preHWChar = str.charAt(index - 2);\r\n            final char firstCode = this.map(preHWChar);\r\n            if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\r\n                return 0;\r\n            }\r\n        }\r\n    }\r\n    return mappedChar;\r\n}","code_comment":"\/**\r\n * Used internally by the Soundex algorithm.\r\n *\r\n * Consonants from the same code group separated by W or H are treated as one.\r\n *\r\n * @param str\r\n *                  the cleaned working string to encode (in upper case).\r\n * @param index\r\n *                  the character position to encode\r\n * @return Mapping code for a particular character\r\n * @throws IllegalArgumentException\r\n *                  if the character is not mapped\r\n *\/\r\n","code_no_comment":"private char getMappingCode(final String str, final int index) {\r\n        final char mappedChar = this.map(str.charAt(index));\r\n        if (index > 1 && mappedChar != '0') {\r\n        final char hwChar = str.charAt(index - 1);\r\n        if ('H' == hwChar || 'W' == hwChar) {\r\n            final char preHWChar = str.charAt(index - 2);\r\n            final char firstCode = this.map(preHWChar);\r\n            if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\r\n                return 0;\r\n            }\r\n        }\r\n    }\r\n    return mappedChar;\r\n}","lc":0.0,"pi":0.8421052632,"ma":0.0,"nbd":0.5,"ml":0.5833333333,"d":1.0853174603,"mi":-0.0646934461,"fo":-0.0833333333,"r":1.9736842105,"e":0.691225947}
{"project_name":"Time","project_version":"19","label":2,"code":"\/**\r\n * Gets the millisecond offset to subtract from local time to get UTC time.\r\n * This offset can be used to undo adding the offset obtained by getOffset.\r\n *\r\n * <pre>\r\n * millisLocal == millisUTC   + getOffset(millisUTC)\r\n * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\r\n * <\/pre>\r\n *\r\n * NOTE: After calculating millisLocal, some error may be introduced. At\r\n * offset transitions (due to DST or other historical changes), ranges of\r\n * local times may map to different UTC times.\r\n * <p>\r\n * This method will return an offset suitable for calculating an instant\r\n * after any DST gap. For example, consider a zone with a cutover\r\n * from 01:00 to 01:59:<br \/>\r\n * Input: 00:00  Output: 00:00<br \/>\r\n * Input: 00:30  Output: 00:30<br \/>\r\n * Input: 01:00  Output: 02:00<br \/>\r\n * Input: 01:30  Output: 02:30<br \/>\r\n * Input: 02:00  Output: 02:00<br \/>\r\n * Input: 02:30  Output: 02:30<br \/>\r\n * <p>\r\n * During a DST overlap (where the local time is ambiguous) this method will return\r\n * the earlier instant. The combination of these two rules is to always favour\r\n * daylight (summer) time over standard (winter) time.\r\n * <p>\r\n * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\r\n * Prior to v1.5, the DST gap behaviour was also not defined.\r\n *\r\n * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\r\n * @return the millisecond offset to subtract from local time to get UTC time\r\n *\/\r\npublic int getOffsetFromLocal(long instantLocal) {\r\n    \/\/ get the offset at instantLocal (first estimate)\r\n    final int offsetLocal = getOffset(instantLocal);\r\n    \/\/ adjust instantLocal using the estimate and recalc the offset\r\n    final long instantAdjusted = instantLocal - offsetLocal;\r\n    final int offsetAdjusted = getOffset(instantAdjusted);\r\n    \/\/ if the offsets differ, we must be near a DST boundary\r\n    if (offsetLocal != offsetAdjusted) {\r\n        \/\/ this happens naturally for positive offsets, but not for negative\r\n        if ((offsetLocal - offsetAdjusted) < 0) {\r\n            \/\/ if we just return offsetAdjusted then the time is pushed\r\n            \/\/ back before the transition, whereas it should be\r\n            \/\/ on or after the transition\r\n            long nextLocal = nextTransition(instantAdjusted);\r\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\r\n            if (nextLocal != nextAdjusted) {\r\n                return offsetLocal;\r\n            }\r\n        }\r\n    } else if (offsetLocal > 0) {\r\n        long prev = previousTransition(instantAdjusted);\r\n        if (prev < instantAdjusted) {\r\n            int offsetPrev = getOffset(prev);\r\n            int diff = offsetPrev - offsetLocal;\r\n            if (instantAdjusted - prev <= diff) {\r\n                return offsetPrev;\r\n            }\r\n        }\r\n    }\r\n    return offsetAdjusted;\r\n}","code_comment":"\/**\r\n * Gets the millisecond offset to subtract from local time to get UTC time.\r\n * This offset can be used to undo adding the offset obtained by getOffset.\r\n *\r\n * <pre>\r\n * millisLocal == millisUTC   + getOffset(millisUTC)\r\n * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\r\n * <\/pre>\r\n *\r\n * NOTE: After calculating millisLocal, some error may be introduced. At\r\n * offset transitions (due to DST or other historical changes), ranges of\r\n * local times may map to different UTC times.\r\n * <p>\r\n * This method will return an offset suitable for calculating an instant\r\n * after any DST gap. For example, consider a zone with a cutover\r\n * from 01:00 to 01:59:<br \/>\r\n * Input: 00:00  Output: 00:00<br \/>\r\n * Input: 00:30  Output: 00:30<br \/>\r\n * Input: 01:00  Output: 02:00<br \/>\r\n * Input: 01:30  Output: 02:30<br \/>\r\n * Input: 02:00  Output: 02:00<br \/>\r\n * Input: 02:30  Output: 02:30<br \/>\r\n * <p>\r\n * During a DST overlap (where the local time is ambiguous) this method will return\r\n * the earlier instant. The combination of these two rules is to always favour\r\n * daylight (summer) time over standard (winter) time.\r\n * <p>\r\n * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\r\n * Prior to v1.5, the DST gap behaviour was also not defined.\r\n *\r\n * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\r\n * @return the millisecond offset to subtract from local time to get UTC time\r\n *\/\r\n","code_no_comment":"public int getOffsetFromLocal(long instantLocal) {\r\n        final int offsetLocal = getOffset(instantLocal);\r\n        final long instantAdjusted = instantLocal - offsetLocal;\r\n    final int offsetAdjusted = getOffset(instantAdjusted);\r\n        if (offsetLocal != offsetAdjusted) {\r\n                if ((offsetLocal - offsetAdjusted) < 0) {\r\n                                                long nextLocal = nextTransition(instantAdjusted);\r\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\r\n            if (nextLocal != nextAdjusted) {\r\n                return offsetLocal;\r\n            }\r\n        }\r\n    } else if (offsetLocal > 0) {\r\n        long prev = previousTransition(instantAdjusted);\r\n        if (prev < instantAdjusted) {\r\n            int offsetPrev = getOffset(prev);\r\n            int diff = offsetPrev - offsetLocal;\r\n            if (instantAdjusted - prev <= diff) {\r\n                return offsetPrev;\r\n            }\r\n        }\r\n    }\r\n    return offsetAdjusted;\r\n}","lc":0.4545454545,"pi":0.7416267943,"ma":0.6,"nbd":1.0,"ml":0.6666666667,"d":1.4206349206,"mi":-0.3457364341,"fo":0.0,"r":-0.0263157895,"e":1.0036087435}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1739_8188ef54","label":1,"code":"@Override\r\npublic boolean evaluate() {\r\n    \/\/ JCR 2.0 spec, 6.7.16 Comparison:\r\n    \/\/ \"operand1 may evaluate to an array of values\"\r\n    PropertyValue p1 = operand1.currentProperty();\r\n    if (p1 == null) {\r\n        return false;\r\n    }\r\n    PropertyValue p2 = operand2.currentValue();\r\n    if (p2 == null) {\r\n        \/\/ even for \"null <> 'x'\" (same as in SQL)\r\n        return false;\r\n    }\r\n    \/\/ property type of the value of operand1\"\r\n    try {\r\n        p2 = convertValueToType(p2, p1);\r\n    } catch (IllegalArgumentException ex) {\r\n        \/\/ unable to convert, just skip this node\r\n        return false;\r\n    }\r\n    return evaluate(p1, p2);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean evaluate() {\r\n            PropertyValue p1 = operand1.currentProperty();\r\n    if (p1 == null) {\r\n        return false;\r\n    }\r\n    PropertyValue p2 = operand2.currentValue();\r\n    if (p2 == null) {\r\n                return false;\r\n    }\r\n        try {\r\n        p2 = convertValueToType(p2, p1);\r\n    } catch (IllegalArgumentException ex) {\r\n                return false;\r\n    }\r\n    return evaluate(p1, p2);\r\n}","lc":0.1363636364,"pi":-0.2057416268,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0079365079,"mi":-0.0565186751,"fo":-0.1666666667,"r":0.4473684211,"e":-0.0542475637}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1108_a8c925e0","label":1,"code":"public void restrictProperty(String propertyName, Operator op, PropertyValue v) {\r\n    PropertyRestriction x = addRestricition(propertyName);\r\n    PropertyValue oldFirst = x.first;\r\n    PropertyValue oldLast = x.last;\r\n    switch(op) {\r\n        case EQUAL:\r\n            x.first = maxValue(oldFirst, v);\r\n            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\r\n            x.last = minValue(oldLast, v);\r\n            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\r\n            break;\r\n        case NOT_EQUAL:\r\n            if (v != null) {\r\n                throw new IllegalArgumentException(\"NOT_EQUAL only supported for NOT_EQUAL NULL\");\r\n            }\r\n            break;\r\n        case GREATER_THAN:\r\n            x.first = maxValue(oldFirst, v);\r\n            x.firstIncluding = false;\r\n            break;\r\n        case GREATER_OR_EQUAL:\r\n            x.first = maxValue(oldFirst, v);\r\n            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\r\n            break;\r\n        case LESS_THAN:\r\n            x.last = minValue(oldLast, v);\r\n            x.lastIncluding = false;\r\n            break;\r\n        case LESS_OR_EQUAL:\r\n            x.last = minValue(oldLast, v);\r\n            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\r\n            break;\r\n        case LIKE:\r\n            \/\/ LIKE is handled in the fulltext index\r\n            x.isLike = true;\r\n            x.first = v;\r\n            break;\r\n        case IN:\r\n    }\r\n    if (x.first != null && x.last != null) {\r\n        if (x.first.compareTo(x.last) > 0) {\r\n            setAlwaysFalse();\r\n        } else if (x.first.compareTo(x.last) == 0 && (!x.firstIncluding || !x.lastIncluding)) {\r\n            setAlwaysFalse();\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void restrictProperty(String propertyName, Operator op, PropertyValue v) {\r\n    PropertyRestriction x = addRestricition(propertyName);\r\n    PropertyValue oldFirst = x.first;\r\n    PropertyValue oldLast = x.last;\r\n    switch(op) {\r\n        case EQUAL:\r\n            x.first = maxValue(oldFirst, v);\r\n            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\r\n            x.last = minValue(oldLast, v);\r\n            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\r\n            break;\r\n        case NOT_EQUAL:\r\n            if (v != null) {\r\n                throw new IllegalArgumentException(\"NOT_EQUAL only supported for NOT_EQUAL NULL\");\r\n            }\r\n            break;\r\n        case GREATER_THAN:\r\n            x.first = maxValue(oldFirst, v);\r\n            x.firstIncluding = false;\r\n            break;\r\n        case GREATER_OR_EQUAL:\r\n            x.first = maxValue(oldFirst, v);\r\n            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\r\n            break;\r\n        case LESS_THAN:\r\n            x.last = minValue(oldLast, v);\r\n            x.lastIncluding = false;\r\n            break;\r\n        case LESS_OR_EQUAL:\r\n            x.last = minValue(oldLast, v);\r\n            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\r\n            break;\r\n        case LIKE:\r\n                        x.isLike = true;\r\n            x.first = v;\r\n            break;\r\n        case IN:\r\n    }\r\n    if (x.first != null && x.last != null) {\r\n        if (x.first.compareTo(x.last) > 0) {\r\n            setAlwaysFalse();\r\n        } else if (x.first.compareTo(x.last) == 0 && (!x.firstIncluding || !x.lastIncluding)) {\r\n            setAlwaysFalse();\r\n        }\r\n    }\r\n}","lc":1.4545454545,"pi":0.3205741627,"ma":4.2,"nbd":0.5,"ml":1.9166666667,"d":1.8015873016,"mi":-0.9264270613,"fo":0.4166666667,"r":-0.0263157895,"e":4.2614500671}
{"project_name":"Chart","project_version":"17","label":2,"code":"\/**\r\n * Returns a clone of the time series.\r\n * <P>\r\n * Notes:\r\n * <ul>\r\n *   <li>no need to clone the domain and range descriptions, since String\r\n *     object is immutable;<\/li>\r\n *   <li>we pass over to the more general method clone(start, end).<\/li>\r\n * <\/ul>\r\n *\r\n * @return A clone of the time series.\r\n *\r\n * @throws CloneNotSupportedException not thrown by this class, but\r\n *         subclasses may differ.\r\n *\/\r\npublic Object clone() throws CloneNotSupportedException {\r\n    Object clone = createCopy(0, getItemCount() - 1);\r\n    return clone;\r\n}","code_comment":"\/**\r\n * Returns a clone of the time series.\r\n * <P>\r\n * Notes:\r\n * <ul>\r\n *   <li>no need to clone the domain and range descriptions, since String\r\n *     object is immutable;<\/li>\r\n *   <li>we pass over to the more general method clone(start, end).<\/li>\r\n * <\/ul>\r\n *\r\n * @return A clone of the time series.\r\n *\r\n * @throws CloneNotSupportedException not thrown by this class, but\r\n *         subclasses may differ.\r\n *\/\r\n","code_no_comment":"public Object clone() throws CloneNotSupportedException {\r\n    Object clone = createCopy(0, getItemCount() - 1);\r\n    return clone;\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.0912698413,"mi":0.7860465116,"fo":-0.3333333333,"r":2.1578947368,"e":-0.1354172069}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-4370_7345fefc","label":1,"code":"\/**\r\n * Bind this GenericFile to an Exchange\r\n *\/\r\npublic void bindToExchange(Exchange exchange) {\r\n    exchange.setProperty(FileComponent.FILE_EXCHANGE_FILE, this);\r\n    GenericFileMessage<T> in = new GenericFileMessage<T>(this);\r\n    exchange.setIn(in);\r\n    populateHeaders(in);\r\n}","code_comment":"\/**\r\n * Bind this GenericFile to an Exchange\r\n *\/\r\n","code_no_comment":"public void bindToExchange(Exchange exchange) {\r\n    exchange.setProperty(FileComponent.FILE_EXCHANGE_FILE, this);\r\n    GenericFileMessage<T> in = new GenericFileMessage<T>(this);\r\n    exchange.setIn(in);\r\n    populateHeaders(in);\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5295278365,"fo":-0.25,"r":2.0,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-43_668f08f2","label":1,"code":"void apply() throws Exception {\r\n    setProperties(nodePath, properties);\r\n}","code_comment":null,"code_no_comment":"void apply() throws Exception {\r\n    setProperties(nodePath, properties);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.067653277,"fo":-0.4166666667,"r":1.5263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-447_00df38d2","label":1,"code":"@Override\r\npublic NodeBuilder child(String name) {\r\n    \/\/ shortcut when dealing with a read-only child node\r\n    read();\r\n    if (baseState != null && baseState.hasChildNode(name) && (writeState == null || !writeState.nodes.containsKey(name))) {\r\n        return createChildBuilder(name);\r\n    }\r\n    \/\/ no read-only child node found, switch to write mode\r\n    write();\r\n    \/\/ guaranteed by write()\r\n    assert writeState != null;\r\n    NodeState childBase = null;\r\n    if (baseState != null) {\r\n        childBase = baseState.getChildNode(name);\r\n    }\r\n    if (writeState.nodes.get(name) == null) {\r\n        if (writeState.nodes.containsKey(name)) {\r\n            \/\/ The child node was removed earlier and we're creating\r\n            \/\/ a new child with the same name. Use the null state to\r\n            \/\/ prevent the previous child state from re-surfacing.\r\n            childBase = null;\r\n        }\r\n        writeState.nodes.put(name, new MutableNodeState(childBase));\r\n    }\r\n    MemoryNodeBuilder builder = createChildBuilder(name);\r\n    builder.write();\r\n    return builder;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic NodeBuilder child(String name) {\r\n        read();\r\n    if (baseState != null && baseState.hasChildNode(name) && (writeState == null || !writeState.nodes.containsKey(name))) {\r\n        return createChildBuilder(name);\r\n    }\r\n        write();\r\n        assert writeState != null;\r\n    NodeState childBase = null;\r\n    if (baseState != null) {\r\n        childBase = baseState.getChildNode(name);\r\n    }\r\n    if (writeState.nodes.get(name) == null) {\r\n        if (writeState.nodes.containsKey(name)) {\r\n                                                childBase = null;\r\n        }\r\n        writeState.nodes.put(name, new MutableNodeState(childBase));\r\n    }\r\n    MemoryNodeBuilder builder = createChildBuilder(name);\r\n    builder.write();\r\n    return builder;\r\n}","lc":0.3636363636,"pi":-0.0622009569,"ma":0.2,"nbd":0.0,"ml":0.6666666667,"d":-0.3650793651,"mi":0.1317829457,"fo":0.4166666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2334_96330447","label":1,"code":"private static void registerStandardContributors() {\r\n    registerContributor(VersionDebugContributor.DEBUG_BAR_CONTRIB);\r\n    registerContributor(InspectorDebugPanel.DEBUG_BAR_CONTRIB);\r\n    registerContributor(SessionSizeDebugPanel.DEBUG_BAR_CONTRIB);\r\n}","code_comment":null,"code_no_comment":"private static void registerStandardContributors() {\r\n    registerContributor(VersionDebugContributor.DEBUG_BAR_CONTRIB);\r\n    registerContributor(InspectorDebugPanel.DEBUG_BAR_CONTRIB);\r\n    registerContributor(SessionSizeDebugPanel.DEBUG_BAR_CONTRIB);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7333333333,"fo":-0.25,"r":1.2105263158,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  @see wicket.feedback.IFeedback#updateFeedback()\r\n *\/\r\npublic void updateFeedback() {\r\n    \/\/ Get the messages for the current page\r\n    visible = getPage().getFeedbackMessages().messages(getMessagesFilter()).size() != 0;\r\n}","code_comment":"\/**\r\n *  @see wicket.feedback.IFeedback#updateFeedback()\r\n *\/\r\n","code_no_comment":"public void updateFeedback() {\r\n        visible = getPage().getFeedbackMessages().messages(getMessagesFilter()).size() != 0;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.1666666667,"mi":0.9360112755,"fo":-0.0833333333,"r":2.5263157895,"e":-0.1452510618}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3324_5f863af6","label":1,"code":"@Nonnull\r\nprivate Iterator<PermissionEntry> getEntryIterator(@Nonnull Tree tree, @Nullable PropertyState property, long permissions) {\r\n    return getEntryIterator(new EntryPredicate(tree, property, Permissions.respectParentPermissions(permissions)));\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\nprivate Iterator<PermissionEntry> getEntryIterator(@Nonnull Tree tree, @Nullable PropertyState property, long permissions) {\r\n    return getEntryIterator(new EntryPredicate(tree, property, Permissions.respectParentPermissions(permissions)));\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7105003524,"fo":-0.3333333333,"r":0.0,"e":-0.1627934049}
{"project_name":"Chart","project_version":"5","label":3,"code":"\/**\r\n * Adds or updates an item in the series and sends a\r\n * {@link SeriesChangeEvent} to all registered listeners.\r\n *\r\n * @param x  the x-value (<code>null<\/code> not permitted).\r\n * @param y  the y-value (<code>null<\/code> permitted).\r\n *\r\n * @return A copy of the overwritten data item, or <code>null<\/code> if no\r\n *         item was overwritten.\r\n *\/\r\npublic XYDataItem addOrUpdate(Number x, Number y) {\r\n    if (x == null) {\r\n        throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n    }\r\n    \/\/ if we get to here, we know that duplicate X values are not permitted\r\n    XYDataItem overwritten = null;\r\n    int index = indexOf(x);\r\n    if (index >= 0 && !this.allowDuplicateXValues) {\r\n        XYDataItem existing = (XYDataItem) this.data.get(index);\r\n        try {\r\n            overwritten = (XYDataItem) existing.clone();\r\n        } catch (CloneNotSupportedException e) {\r\n            throw new SeriesException(\"Couldn't clone XYDataItem!\");\r\n        }\r\n        existing.setY(y);\r\n    } else {\r\n        \/\/ append the value to the list...\r\n        if (this.autoSort) {\r\n            this.data.add(-index - 1, new XYDataItem(x, y));\r\n        } else {\r\n            this.data.add(new XYDataItem(x, y));\r\n        }\r\n        \/\/ check if this addition will exceed the maximum item count...\r\n        if (getItemCount() > this.maximumItemCount) {\r\n            this.data.remove(0);\r\n        }\r\n    }\r\n    fireSeriesChanged();\r\n    return overwritten;\r\n}","code_comment":"\/**\r\n * Adds or updates an item in the series and sends a\r\n * {@link SeriesChangeEvent} to all registered listeners.\r\n *\r\n * @param x  the x-value (<code>null<\/code> not permitted).\r\n * @param y  the y-value (<code>null<\/code> permitted).\r\n *\r\n * @return A copy of the overwritten data item, or <code>null<\/code> if no\r\n *         item was overwritten.\r\n *\/\r\n","code_no_comment":"public XYDataItem addOrUpdate(Number x, Number y) {\r\n    if (x == null) {\r\n        throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n    }\r\n        XYDataItem overwritten = null;\r\n    int index = indexOf(x);\r\n    if (index >= 0 && !this.allowDuplicateXValues) {\r\n        XYDataItem existing = (XYDataItem) this.data.get(index);\r\n        try {\r\n            overwritten = (XYDataItem) existing.clone();\r\n        } catch (CloneNotSupportedException e) {\r\n            throw new SeriesException(\"Couldn't clone XYDataItem!\");\r\n        }\r\n        existing.setY(y);\r\n    } else {\r\n                if (this.autoSort) {\r\n            this.data.add(-index - 1, new XYDataItem(x, y));\r\n        } else {\r\n            this.data.add(new XYDataItem(x, y));\r\n        }\r\n                if (getItemCount() > this.maximumItemCount) {\r\n            this.data.remove(0);\r\n        }\r\n    }\r\n    fireSeriesChanged();\r\n    return overwritten;\r\n}","lc":0.5909090909,"pi":0.2009569378,"ma":0.8,"nbd":0.0,"ml":0.5,"d":0.7658730159,"mi":-0.4398872445,"fo":0.25,"r":-0.0263157895,"e":0.7681171948}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1076_9238264d","label":3,"code":"private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String oakPropertyName, Integer propertyType) {\r\n    while (true) {\r\n        if (t == null || !t.exists()) {\r\n            return;\r\n        }\r\n        int slash = oakPropertyName.indexOf('\/');\r\n        if (slash < 0) {\r\n            break;\r\n        }\r\n        String parent = oakPropertyName.substring(0, slash);\r\n        oakPropertyName = oakPropertyName.substring(slash + 1);\r\n        if (parent.equals(\"..\")) {\r\n            t = t.isRoot() ? null : t.getParent();\r\n        } else if (parent.equals(\".\")) {\r\n        \/\/ same node\r\n        } else if (parent.equals(\"*\")) {\r\n            for (Tree child : t.getChildren()) {\r\n                readOakProperties(target, child, oakPropertyName, propertyType);\r\n            }\r\n        } else {\r\n            t = t.getChild(parent);\r\n        }\r\n    }\r\n    if (!\"*\".equals(oakPropertyName)) {\r\n        PropertyValue value = currentOakProperty(t, oakPropertyName, propertyType);\r\n        if (value != null) {\r\n            target.add(value);\r\n        }\r\n        return;\r\n    }\r\n    for (PropertyState p : t.getProperties()) {\r\n        if (propertyType == null || p.getType().tag() == propertyType) {\r\n            PropertyValue v = PropertyValues.create(p);\r\n            target.add(v);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String oakPropertyName, Integer propertyType) {\r\n    while (true) {\r\n        if (t == null || !t.exists()) {\r\n            return;\r\n        }\r\n        int slash = oakPropertyName.indexOf('\/');\r\n        if (slash < 0) {\r\n            break;\r\n        }\r\n        String parent = oakPropertyName.substring(0, slash);\r\n        oakPropertyName = oakPropertyName.substring(slash + 1);\r\n        if (parent.equals(\"..\")) {\r\n            t = t.isRoot() ? null : t.getParent();\r\n        } else if (parent.equals(\".\")) {\r\n                } else if (parent.equals(\"*\")) {\r\n            for (Tree child : t.getChildren()) {\r\n                readOakProperties(target, child, oakPropertyName, propertyType);\r\n            }\r\n        } else {\r\n            t = t.getChild(parent);\r\n        }\r\n    }\r\n    if (!\"*\".equals(oakPropertyName)) {\r\n        PropertyValue value = currentOakProperty(t, oakPropertyName, propertyType);\r\n        if (value != null) {\r\n            target.add(value);\r\n        }\r\n        return;\r\n    }\r\n    for (PropertyState p : t.getProperties()) {\r\n        if (propertyType == null || p.getType().tag() == propertyType) {\r\n            PropertyValue v = PropertyValues.create(p);\r\n            target.add(v);\r\n        }\r\n    }\r\n}","lc":1.0,"pi":0.2248803828,"ma":2.0,"nbd":1.5,"ml":1.5833333333,"d":0.9841269841,"mi":-0.6907681466,"fo":1.1666666667,"r":-0.0263157895,"e":1.7645822168}
{"project_name":"Cli","project_version":"30","label":3,"code":"\/**\r\n * Sets the values of Options using the values in <code>properties<\/code>.\r\n *\r\n * @param properties The value properties to be processed.\r\n *\/\r\nprotected void processProperties(Properties properties) throws ParseException {\r\n    if (properties == null) {\r\n        return;\r\n    }\r\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements(); ) {\r\n        String option = e.nextElement().toString();\r\n        if (!cmd.hasOption(option)) {\r\n            Option opt = getOptions().getOption(option);\r\n            \/\/ if the option is part of a group, check if another option of the group has been selected\r\n            \/\/ get the value from the properties instance\r\n            String value = properties.getProperty(option);\r\n            if (opt.hasArg()) {\r\n                if (opt.getValues() == null || opt.getValues().length == 0) {\r\n                    try {\r\n                        opt.addValueForProcessing(value);\r\n                    } catch (RuntimeException exp) {\r\n                    \/\/ if we cannot add the value don't worry about it\r\n                    }\r\n                }\r\n            } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\r\n                \/\/ option to the CommandLine\r\n                continue;\r\n            }\r\n            cmd.addOption(opt);\r\n            updateRequiredOptions(opt);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Sets the values of Options using the values in <code>properties<\/code>.\r\n *\r\n * @param properties The value properties to be processed.\r\n *\/\r\n","code_no_comment":"protected void processProperties(Properties properties) throws ParseException {\r\n    if (properties == null) {\r\n        return;\r\n    }\r\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements(); ) {\r\n        String option = e.nextElement().toString();\r\n        if (!cmd.hasOption(option)) {\r\n            Option opt = getOptions().getOption(option);\r\n                                    String value = properties.getProperty(option);\r\n            if (opt.hasArg()) {\r\n                if (opt.getValues() == null || opt.getValues().length == 0) {\r\n                    try {\r\n                        opt.addValueForProcessing(value);\r\n                    } catch (RuntimeException exp) {\r\n                                        }\r\n                }\r\n            } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\r\n                                continue;\r\n            }\r\n            cmd.addOption(opt);\r\n            updateRequiredOptions(opt);\r\n        }\r\n    }\r\n}","lc":0.4545454545,"pi":1.6076555024,"ma":1.0,"nbd":1.5,"ml":1.25,"d":0.3035714286,"mi":-0.3987315011,"fo":0.9166666667,"r":-0.0263157895,"e":0.412277335}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3104_38f5ef13","label":3,"code":"private void rollback(List<UpdateOp> newDocuments, List<UpdateOp> changed, UpdateOp commitRoot) {\r\n    DocumentStore store = nodeStore.getDocumentStore();\r\n    for (UpdateOp op : changed) {\r\n        UpdateOp reverse = op.getReverseOperation();\r\n        store.findAndUpdate(NODES, reverse);\r\n    }\r\n    for (UpdateOp op : newDocuments) {\r\n        UpdateOp reverse = op.getReverseOperation();\r\n        store.findAndUpdate(NODES, reverse);\r\n    }\r\n    UpdateOp removeCollision = new UpdateOp(commitRoot.getId(), false);\r\n    NodeDocument.removeCollision(removeCollision, revision);\r\n    store.findAndUpdate(NODES, removeCollision);\r\n}","code_comment":null,"code_no_comment":"private void rollback(List<UpdateOp> newDocuments, List<UpdateOp> changed, UpdateOp commitRoot) {\r\n    DocumentStore store = nodeStore.getDocumentStore();\r\n    for (UpdateOp op : changed) {\r\n        UpdateOp reverse = op.getReverseOperation();\r\n        store.findAndUpdate(NODES, reverse);\r\n    }\r\n    for (UpdateOp op : newDocuments) {\r\n        UpdateOp reverse = op.getReverseOperation();\r\n        store.findAndUpdate(NODES, reverse);\r\n    }\r\n    UpdateOp removeCollision = new UpdateOp(commitRoot.getId(), false);\r\n    NodeDocument.removeCollision(removeCollision, revision);\r\n    store.findAndUpdate(NODES, removeCollision);\r\n}","lc":0.0,"pi":-0.2057416268,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.050880902,"fo":0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2658_ce68cbd9","label":1,"code":"\/**\r\n *  Creates a Flink program that uses the specified spouts and bolts.\r\n *\/\r\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\npublic FlinkTopology createTopology() {\r\n    final StormTopology stormTopolgoy = this.stormBuilder.createTopology();\r\n    final FlinkTopology env = new FlinkTopology(stormTopolgoy);\r\n    env.setParallelism(1);\r\n    final HashMap<String, HashMap<String, DataStream>> availableInputs = new HashMap<String, HashMap<String, DataStream>>();\r\n    for (final Entry<String, IRichSpout> spout : this.spouts.entrySet()) {\r\n        final String spoutId = spout.getKey();\r\n        final IRichSpout userSpout = spout.getValue();\r\n        final FlinkOutputFieldsDeclarer declarer = new FlinkOutputFieldsDeclarer();\r\n        userSpout.declareOutputFields(declarer);\r\n        final HashMap<String, Fields> sourceStreams = declarer.outputStreams;\r\n        this.outputStreams.put(spoutId, sourceStreams);\r\n        declarers.put(spoutId, declarer);\r\n        AbstractStormSpoutWrapper spoutWrapper;\r\n        if (userSpout instanceof FiniteStormSpout) {\r\n            spoutWrapper = new FiniteStormSpoutWrapper((FiniteStormSpout) userSpout);\r\n        } else {\r\n            spoutWrapper = new StormSpoutWrapper(userSpout);\r\n        }\r\n        DataStreamSource source;\r\n        HashMap<String, DataStream> outputStreams = new HashMap<String, DataStream>();\r\n        if (sourceStreams.size() == 1) {\r\n            final String outputStreamId = (String) sourceStreams.keySet().toArray()[0];\r\n            source = env.addSource(spoutWrapper, spoutId, declarer.getOutputType(outputStreamId));\r\n            outputStreams.put(outputStreamId, source);\r\n        } else {\r\n            source = env.addSource(spoutWrapper, spoutId, TypeExtractor.getForClass(SplitStreamType.class));\r\n            SplitDataStream splitSource = source.split(new FlinkStormStreamSelector());\r\n            for (String streamId : sourceStreams.keySet()) {\r\n                outputStreams.put(streamId, splitSource.select(streamId));\r\n            }\r\n        }\r\n        availableInputs.put(spoutId, outputStreams);\r\n        int dop = 1;\r\n        final ComponentCommon common = stormTopolgoy.get_spouts().get(spoutId).get_common();\r\n        if (common.is_set_parallelism_hint()) {\r\n            dop = common.get_parallelism_hint();\r\n            source.setParallelism(dop);\r\n        }\r\n        env.increaseNumberOfTasks(dop);\r\n    }\r\n    final HashMap<String, IRichBolt> unprocessedBolts = new HashMap<String, IRichBolt>();\r\n    unprocessedBolts.putAll(this.bolts);\r\n    final HashMap<String, Set<Entry<GlobalStreamId, Grouping>>> unprocessdInputsPerBolt = new HashMap<String, Set<Entry<GlobalStreamId, Grouping>>>();\r\n    \/* Because we do not know the order in which an iterator steps over a set, we might process a consumer before\r\n\t\t * its producer\r\n\t\t * ->thus, we might need to repeat multiple times\r\n\t\t *\/\r\n    boolean makeProgress = true;\r\n    while (unprocessedBolts.size() > 0) {\r\n        if (!makeProgress) {\r\n            throw new RuntimeException(\"Unable to build Topology. Could not connect the following bolts: \" + unprocessedBolts.keySet());\r\n        }\r\n        makeProgress = false;\r\n        final Iterator<Entry<String, IRichBolt>> boltsIterator = unprocessedBolts.entrySet().iterator();\r\n        while (boltsIterator.hasNext()) {\r\n            final Entry<String, IRichBolt> bolt = boltsIterator.next();\r\n            final String boltId = bolt.getKey();\r\n            final IRichBolt userBolt = bolt.getValue();\r\n            final ComponentCommon common = stormTopolgoy.get_bolts().get(boltId).get_common();\r\n            Set<Entry<GlobalStreamId, Grouping>> unprocessedInputs = unprocessdInputsPerBolt.get(boltId);\r\n            if (unprocessedInputs == null) {\r\n                unprocessedInputs = new HashSet<Entry<GlobalStreamId, Grouping>>();\r\n                unprocessedInputs.addAll(common.get_inputs().entrySet());\r\n                unprocessdInputsPerBolt.put(boltId, unprocessedInputs);\r\n            }\r\n            \/\/ connect each available producer to the current bolt\r\n            final Iterator<Entry<GlobalStreamId, Grouping>> inputStreamsIterator = unprocessedInputs.iterator();\r\n            while (inputStreamsIterator.hasNext()) {\r\n                final Entry<GlobalStreamId, Grouping> stormInputStream = inputStreamsIterator.next();\r\n                final String producerId = stormInputStream.getKey().get_componentId();\r\n                final String inputStreamId = stormInputStream.getKey().get_streamId();\r\n                HashMap<String, DataStream> producer = availableInputs.get(producerId);\r\n                if (producer != null) {\r\n                    makeProgress = true;\r\n                    DataStream inputStream = producer.get(inputStreamId);\r\n                    if (inputStream != null) {\r\n                        final FlinkOutputFieldsDeclarer declarer = new FlinkOutputFieldsDeclarer();\r\n                        userBolt.declareOutputFields(declarer);\r\n                        final HashMap<String, Fields> boltOutputStreams = declarer.outputStreams;\r\n                        this.outputStreams.put(boltId, boltOutputStreams);\r\n                        this.declarers.put(boltId, declarer);\r\n                        \/\/ if producer was processed already\r\n                        final Grouping grouping = stormInputStream.getValue();\r\n                        if (grouping.is_set_shuffle()) {\r\n                            \/\/ Storm uses a round-robin shuffle strategy\r\n                            inputStream = inputStream.rebalance();\r\n                        } else if (grouping.is_set_fields()) {\r\n                            \/\/ global grouping is emulated in Storm via an empty fields grouping list\r\n                            final List<String> fields = grouping.get_fields();\r\n                            if (fields.size() > 0) {\r\n                                FlinkOutputFieldsDeclarer prodDeclarer = this.declarers.get(producerId);\r\n                                inputStream = inputStream.groupBy(prodDeclarer.getGroupingFieldIndexes(inputStreamId, grouping.get_fields()));\r\n                            } else {\r\n                                inputStream = inputStream.global();\r\n                            }\r\n                        } else if (grouping.is_set_all()) {\r\n                            inputStream = inputStream.broadcast();\r\n                        } else if (!grouping.is_set_local_or_shuffle()) {\r\n                            throw new UnsupportedOperationException(\"Flink only supports (local-or-)shuffle, fields, all, and global grouping\");\r\n                        }\r\n                        SingleOutputStreamOperator outputStream;\r\n                        if (boltOutputStreams.size() < 2) {\r\n                            \/\/ single output stream or sink\r\n                            String outputStreamId = null;\r\n                            if (boltOutputStreams.size() == 1) {\r\n                                outputStreamId = (String) boltOutputStreams.keySet().toArray()[0];\r\n                            }\r\n                            final TypeInformation<?> outType = declarer.getOutputType(outputStreamId);\r\n                            outputStream = inputStream.transform(boltId, outType, new StormBoltWrapper(userBolt, this.outputStreams.get(producerId).get(inputStreamId)));\r\n                            if (outType != null) {\r\n                                \/\/ only for non-sink nodes\r\n                                HashMap<String, DataStream> op = new HashMap<String, DataStream>();\r\n                                op.put(outputStreamId, outputStream);\r\n                                availableInputs.put(boltId, op);\r\n                            }\r\n                        } else {\r\n                            final TypeInformation<?> outType = TypeExtractor.getForClass(SplitStreamType.class);\r\n                            outputStream = inputStream.transform(boltId, outType, new StormBoltWrapper(userBolt, this.outputStreams.get(producerId).get(inputStreamId)));\r\n                            SplitDataStream splitStreams = outputStream.split(new FlinkStormStreamSelector());\r\n                            HashMap<String, DataStream> op = new HashMap<String, DataStream>();\r\n                            for (String outputStreamId : boltOutputStreams.keySet()) {\r\n                                op.put(outputStreamId, splitStreams.select(outputStreamId));\r\n                            }\r\n                            availableInputs.put(boltId, op);\r\n                        }\r\n                        int dop = 1;\r\n                        if (common.is_set_parallelism_hint()) {\r\n                            dop = common.get_parallelism_hint();\r\n                            outputStream.setParallelism(dop);\r\n                        }\r\n                        env.increaseNumberOfTasks(dop);\r\n                        inputStreamsIterator.remove();\r\n                    } else {\r\n                        throw new RuntimeException(\"Cannot connect '\" + boltId + \"' to '\" + producerId + \"'. Stream '\" + inputStreamId + \"' not found.\");\r\n                    }\r\n                }\r\n            }\r\n            if (unprocessedInputs.size() == 0) {\r\n                \/\/ all inputs are connected; processing bolt completed\r\n                boltsIterator.remove();\r\n            }\r\n        }\r\n    }\r\n    return env;\r\n}","code_comment":"\/**\r\n *  Creates a Flink program that uses the specified spouts and bolts.\r\n *\/\r\n","code_no_comment":"@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\r\npublic FlinkTopology createTopology() {\r\n    final StormTopology stormTopolgoy = this.stormBuilder.createTopology();\r\n    final FlinkTopology env = new FlinkTopology(stormTopolgoy);\r\n    env.setParallelism(1);\r\n    final HashMap<String, HashMap<String, DataStream>> availableInputs = new HashMap<String, HashMap<String, DataStream>>();\r\n    for (final Entry<String, IRichSpout> spout : this.spouts.entrySet()) {\r\n        final String spoutId = spout.getKey();\r\n        final IRichSpout userSpout = spout.getValue();\r\n        final FlinkOutputFieldsDeclarer declarer = new FlinkOutputFieldsDeclarer();\r\n        userSpout.declareOutputFields(declarer);\r\n        final HashMap<String, Fields> sourceStreams = declarer.outputStreams;\r\n        this.outputStreams.put(spoutId, sourceStreams);\r\n        declarers.put(spoutId, declarer);\r\n        AbstractStormSpoutWrapper spoutWrapper;\r\n        if (userSpout instanceof FiniteStormSpout) {\r\n            spoutWrapper = new FiniteStormSpoutWrapper((FiniteStormSpout) userSpout);\r\n        } else {\r\n            spoutWrapper = new StormSpoutWrapper(userSpout);\r\n        }\r\n        DataStreamSource source;\r\n        HashMap<String, DataStream> outputStreams = new HashMap<String, DataStream>();\r\n        if (sourceStreams.size() == 1) {\r\n            final String outputStreamId = (String) sourceStreams.keySet().toArray()[0];\r\n            source = env.addSource(spoutWrapper, spoutId, declarer.getOutputType(outputStreamId));\r\n            outputStreams.put(outputStreamId, source);\r\n        } else {\r\n            source = env.addSource(spoutWrapper, spoutId, TypeExtractor.getForClass(SplitStreamType.class));\r\n            SplitDataStream splitSource = source.split(new FlinkStormStreamSelector());\r\n            for (String streamId : sourceStreams.keySet()) {\r\n                outputStreams.put(streamId, splitSource.select(streamId));\r\n            }\r\n        }\r\n        availableInputs.put(spoutId, outputStreams);\r\n        int dop = 1;\r\n        final ComponentCommon common = stormTopolgoy.get_spouts().get(spoutId).get_common();\r\n        if (common.is_set_parallelism_hint()) {\r\n            dop = common.get_parallelism_hint();\r\n            source.setParallelism(dop);\r\n        }\r\n        env.increaseNumberOfTasks(dop);\r\n    }\r\n    final HashMap<String, IRichBolt> unprocessedBolts = new HashMap<String, IRichBolt>();\r\n    unprocessedBolts.putAll(this.bolts);\r\n    final HashMap<String, Set<Entry<GlobalStreamId, Grouping>>> unprocessdInputsPerBolt = new HashMap<String, Set<Entry<GlobalStreamId, Grouping>>>();\r\n        boolean makeProgress = true;\r\n    while (unprocessedBolts.size() > 0) {\r\n        if (!makeProgress) {\r\n            throw new RuntimeException(\"Unable to build Topology. Could not connect the following bolts: \" + unprocessedBolts.keySet());\r\n        }\r\n        makeProgress = false;\r\n        final Iterator<Entry<String, IRichBolt>> boltsIterator = unprocessedBolts.entrySet().iterator();\r\n        while (boltsIterator.hasNext()) {\r\n            final Entry<String, IRichBolt> bolt = boltsIterator.next();\r\n            final String boltId = bolt.getKey();\r\n            final IRichBolt userBolt = bolt.getValue();\r\n            final ComponentCommon common = stormTopolgoy.get_bolts().get(boltId).get_common();\r\n            Set<Entry<GlobalStreamId, Grouping>> unprocessedInputs = unprocessdInputsPerBolt.get(boltId);\r\n            if (unprocessedInputs == null) {\r\n                unprocessedInputs = new HashSet<Entry<GlobalStreamId, Grouping>>();\r\n                unprocessedInputs.addAll(common.get_inputs().entrySet());\r\n                unprocessdInputsPerBolt.put(boltId, unprocessedInputs);\r\n            }\r\n                        final Iterator<Entry<GlobalStreamId, Grouping>> inputStreamsIterator = unprocessedInputs.iterator();\r\n            while (inputStreamsIterator.hasNext()) {\r\n                final Entry<GlobalStreamId, Grouping> stormInputStream = inputStreamsIterator.next();\r\n                final String producerId = stormInputStream.getKey().get_componentId();\r\n                final String inputStreamId = stormInputStream.getKey().get_streamId();\r\n                HashMap<String, DataStream> producer = availableInputs.get(producerId);\r\n                if (producer != null) {\r\n                    makeProgress = true;\r\n                    DataStream inputStream = producer.get(inputStreamId);\r\n                    if (inputStream != null) {\r\n                        final FlinkOutputFieldsDeclarer declarer = new FlinkOutputFieldsDeclarer();\r\n                        userBolt.declareOutputFields(declarer);\r\n                        final HashMap<String, Fields> boltOutputStreams = declarer.outputStreams;\r\n                        this.outputStreams.put(boltId, boltOutputStreams);\r\n                        this.declarers.put(boltId, declarer);\r\n                                                final Grouping grouping = stormInputStream.getValue();\r\n                        if (grouping.is_set_shuffle()) {\r\n                                                        inputStream = inputStream.rebalance();\r\n                        } else if (grouping.is_set_fields()) {\r\n                                                        final List<String> fields = grouping.get_fields();\r\n                            if (fields.size() > 0) {\r\n                                FlinkOutputFieldsDeclarer prodDeclarer = this.declarers.get(producerId);\r\n                                inputStream = inputStream.groupBy(prodDeclarer.getGroupingFieldIndexes(inputStreamId, grouping.get_fields()));\r\n                            } else {\r\n                                inputStream = inputStream.global();\r\n                            }\r\n                        } else if (grouping.is_set_all()) {\r\n                            inputStream = inputStream.broadcast();\r\n                        } else if (!grouping.is_set_local_or_shuffle()) {\r\n                            throw new UnsupportedOperationException(\"Flink only supports (local-or-)shuffle, fields, all, and global grouping\");\r\n                        }\r\n                        SingleOutputStreamOperator outputStream;\r\n                        if (boltOutputStreams.size() < 2) {\r\n                                                        String outputStreamId = null;\r\n                            if (boltOutputStreams.size() == 1) {\r\n                                outputStreamId = (String) boltOutputStreams.keySet().toArray()[0];\r\n                            }\r\n                            final TypeInformation<?> outType = declarer.getOutputType(outputStreamId);\r\n                            outputStream = inputStream.transform(boltId, outType, new StormBoltWrapper(userBolt, this.outputStreams.get(producerId).get(inputStreamId)));\r\n                            if (outType != null) {\r\n                                                                HashMap<String, DataStream> op = new HashMap<String, DataStream>();\r\n                                op.put(outputStreamId, outputStream);\r\n                                availableInputs.put(boltId, op);\r\n                            }\r\n                        } else {\r\n                            final TypeInformation<?> outType = TypeExtractor.getForClass(SplitStreamType.class);\r\n                            outputStream = inputStream.transform(boltId, outType, new StormBoltWrapper(userBolt, this.outputStreams.get(producerId).get(inputStreamId)));\r\n                            SplitDataStream splitStreams = outputStream.split(new FlinkStormStreamSelector());\r\n                            HashMap<String, DataStream> op = new HashMap<String, DataStream>();\r\n                            for (String outputStreamId : boltOutputStreams.keySet()) {\r\n                                op.put(outputStreamId, splitStreams.select(outputStreamId));\r\n                            }\r\n                            availableInputs.put(boltId, op);\r\n                        }\r\n                        int dop = 1;\r\n                        if (common.is_set_parallelism_hint()) {\r\n                            dop = common.get_parallelism_hint();\r\n                            outputStream.setParallelism(dop);\r\n                        }\r\n                        env.increaseNumberOfTasks(dop);\r\n                        inputStreamsIterator.remove();\r\n                    } else {\r\n                        throw new RuntimeException(\"Cannot connect '\" + boltId + \"' to '\" + producerId + \"'. Stream '\" + inputStreamId + \"' not found.\");\r\n                    }\r\n                }\r\n            }\r\n            if (unprocessedInputs.size() == 0) {\r\n                                boltsIterator.remove();\r\n            }\r\n        }\r\n    }\r\n    return env;\r\n}","lc":5.5454545455,"pi":2.980861244,"ma":4.6,"nbd":3.5,"ml":2.75,"d":1.7757936508,"mi":-1.6505990134,"fo":7.5833333333,"r":-0.0263157895,"e":18.9259360431}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2062_5c4589bd","label":1,"code":"private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String oakPropertyName, Integer propertyType) {\r\n    boolean skipCurrentNode = false;\r\n    while (true) {\r\n        if (t == null || !t.exists()) {\r\n            return;\r\n        }\r\n        int slash = oakPropertyName.indexOf('\/');\r\n        if (slash < 0) {\r\n            break;\r\n        }\r\n        String parent = oakPropertyName.substring(0, slash);\r\n        oakPropertyName = oakPropertyName.substring(slash + 1);\r\n        if (parent.equals(\"..\")) {\r\n            t = t.isRoot() ? null : t.getParent();\r\n        } else if (parent.equals(\".\")) {\r\n        \/\/ same node\r\n        } else if (parent.equals(\"*\")) {\r\n            for (Tree child : t.getChildren()) {\r\n                readOakProperties(target, child, oakPropertyName, propertyType);\r\n            }\r\n            skipCurrentNode = true;\r\n        } else {\r\n            t = t.getChild(parent);\r\n        }\r\n    }\r\n    if (skipCurrentNode) {\r\n        return;\r\n    }\r\n    if (!\"*\".equals(oakPropertyName)) {\r\n        PropertyValue value = currentOakProperty(t, oakPropertyName, propertyType);\r\n        if (value != null) {\r\n            target.add(value);\r\n        }\r\n        return;\r\n    }\r\n    for (PropertyState p : t.getProperties()) {\r\n        if (propertyType == null || p.getType().tag() == propertyType) {\r\n            PropertyValue v = PropertyValues.create(p);\r\n            target.add(v);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String oakPropertyName, Integer propertyType) {\r\n    boolean skipCurrentNode = false;\r\n    while (true) {\r\n        if (t == null || !t.exists()) {\r\n            return;\r\n        }\r\n        int slash = oakPropertyName.indexOf('\/');\r\n        if (slash < 0) {\r\n            break;\r\n        }\r\n        String parent = oakPropertyName.substring(0, slash);\r\n        oakPropertyName = oakPropertyName.substring(slash + 1);\r\n        if (parent.equals(\"..\")) {\r\n            t = t.isRoot() ? null : t.getParent();\r\n        } else if (parent.equals(\".\")) {\r\n                } else if (parent.equals(\"*\")) {\r\n            for (Tree child : t.getChildren()) {\r\n                readOakProperties(target, child, oakPropertyName, propertyType);\r\n            }\r\n            skipCurrentNode = true;\r\n        } else {\r\n            t = t.getChild(parent);\r\n        }\r\n    }\r\n    if (skipCurrentNode) {\r\n        return;\r\n    }\r\n    if (!\"*\".equals(oakPropertyName)) {\r\n        PropertyValue value = currentOakProperty(t, oakPropertyName, propertyType);\r\n        if (value != null) {\r\n            target.add(value);\r\n        }\r\n        return;\r\n    }\r\n    for (PropertyState p : t.getProperties()) {\r\n        if (propertyType == null || p.getType().tag() == propertyType) {\r\n            PropertyValue v = PropertyValues.create(p);\r\n            target.add(v);\r\n        }\r\n    }\r\n}","lc":1.2272727273,"pi":0.2344497608,"ma":2.2,"nbd":1.5,"ml":1.75,"d":0.9920634921,"mi":-0.7671599718,"fo":1.1666666667,"r":-0.0263157895,"e":1.9186920466}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2172_ea4a3f8a","label":3,"code":"\/**\r\n *  @see java.util.Map#putAll(java.util.Map)\r\n *\/\r\n@Override\r\npublic void putAll(final Map map) {\r\n    checkMutability();\r\n    super.putAll(map);\r\n}","code_comment":"\/**\r\n *  @see java.util.Map#putAll(java.util.Map)\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void putAll(final Map map) {\r\n    checkMutability();\r\n    super.putAll(map);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.792248062,"fo":-0.3333333333,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  Gets the converter instance. This method returns the cached converter for\r\n *  the current locale. Whenever the locale is changed, the cached value is\r\n *  cleared and the converter will be recreated for the new locale on a next\r\n *  request.\r\n *\r\n *  @param type\r\n *             TODO\r\n *\r\n *  @return the converter\r\n *\/\r\npublic final IConverter getConverter(Class type) {\r\n    if (converterSupplier == null) {\r\n        \/\/ Let the factory create a new converter\r\n        converterSupplier = getApplication().getApplicationSettings().getConverterLocatorFactory().newConverterLocator();\r\n    }\r\n    return converterSupplier.getConverter(type);\r\n}","code_comment":"\/**\r\n *  Gets the converter instance. This method returns the cached converter for\r\n *  the current locale. Whenever the locale is changed, the cached value is\r\n *  cleared and the converter will be recreated for the new locale on a next\r\n *  request.\r\n *\r\n *  @param type\r\n *             TODO\r\n *\r\n *  @return the converter\r\n *\/\r\n","code_no_comment":"public final IConverter getConverter(Class type) {\r\n    if (converterSupplier == null) {\r\n                converterSupplier = getApplication().getApplicationSettings().getConverterLocatorFactory().newConverterLocator();\r\n    }\r\n    return converterSupplier.getConverter(type);\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0952380952,"mi":0.5393939394,"fo":-0.0833333333,"r":0.6578947368,"e":-0.1232459098}
{"project_name":"JxPath","project_version":"15","label":1,"code":"public boolean setPosition(int position) {\r\n    if (!prepared) {\r\n        prepared = true;\r\n        BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet();\r\n        ArrayList pointers = new ArrayList();\r\n        for (int i = 0; i < contexts.length; i++) {\r\n            EvalContext ctx = (EvalContext) contexts[i];\r\n            while (ctx.nextSet()) {\r\n                while (ctx.nextNode()) {\r\n                    NodePointer ptr = ctx.getCurrentNodePointer();\r\n                    if (!pointers.contains(ptr)) {\r\n                        nodeSet.add(ptr);\r\n                        pointers.add(ptr);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return super.setPosition(position);\r\n}","code_comment":null,"code_no_comment":"public boolean setPosition(int position) {\r\n    if (!prepared) {\r\n        prepared = true;\r\n        BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet();\r\n        ArrayList pointers = new ArrayList();\r\n        for (int i = 0; i < contexts.length; i++) {\r\n            EvalContext ctx = (EvalContext) contexts[i];\r\n            while (ctx.nextSet()) {\r\n                while (ctx.nextNode()) {\r\n                    NodePointer ptr = ctx.getCurrentNodePointer();\r\n                    if (!pointers.contains(ptr)) {\r\n                        nodeSet.add(ptr);\r\n                        pointers.add(ptr);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return super.setPosition(position);\r\n}","lc":0.2727272727,"pi":2.0622009569,"ma":0.4,"nbd":1.5,"ml":0.5833333333,"d":0.376984127,"mi":-0.2397463002,"fo":0.1666666667,"r":0.1315789474,"e":0.2716343078}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5662_9aec4f33","label":1,"code":"\/**\r\n *  Looks up a bean by its name and class. Throws IllegalState exception if bean not found.\r\n *\r\n *  @param ctx\r\n *             spring application context\r\n *\r\n *  @param name\r\n *             bean name\r\n *  @param clazz\r\n *             bean class\r\n *  @throws IllegalStateException\r\n *  @return found bean\r\n *\/\r\nprivate static Object lookupSpringBean(final ApplicationContext ctx, final String name, final Class<?> clazz) {\r\n    try {\r\n        if (name == null) {\r\n            return ctx.getBean(clazz);\r\n        } else {\r\n            return ctx.getBean(name, clazz);\r\n        }\r\n    } catch (NoSuchBeanDefinitionException e) {\r\n        throw new IllegalStateException(\"bean with name [\" + name + \"] and class [\" + clazz.getName() + \"] not found\");\r\n    }\r\n}","code_comment":"\/**\r\n *  Looks up a bean by its name and class. Throws IllegalState exception if bean not found.\r\n *\r\n *  @param ctx\r\n *             spring application context\r\n *\r\n *  @param name\r\n *             bean name\r\n *  @param clazz\r\n *             bean class\r\n *  @throws IllegalStateException\r\n *  @return found bean\r\n *\/\r\n","code_no_comment":"private static Object lookupSpringBean(final ApplicationContext ctx, final String name, final Class<?> clazz) {\r\n    try {\r\n        if (name == null) {\r\n            return ctx.getBean(clazz);\r\n        } else {\r\n            return ctx.getBean(name, clazz);\r\n        }\r\n    } catch (NoSuchBeanDefinitionException e) {\r\n        throw new IllegalStateException(\"bean with name [\" + name + \"] and class [\" + clazz.getName() + \"] not found\");\r\n    }\r\n}","lc":-0.1363636364,"pi":0.4593301435,"ma":0.0,"nbd":0.0,"ml":-0.25,"d":-0.0674603175,"mi":0.1484143763,"fo":-0.25,"r":1.7631578947,"e":-0.0761190159}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7146_b6981cfd","label":3,"code":"\/**\r\n * Add the given {@link Exchange} under the correlation key.\r\n * <p\/>\r\n * Will replace any existing exchange.\r\n *\r\n * @param camelContext   the current CamelContext\r\n * @param key            the correlation key\r\n * @param exchange       the aggregated exchange\r\n * @return the old exchange if any existed\r\n *\/\r\nExchange add(CamelContext camelContext, String key, Exchange exchange);","code_comment":"\/**\r\n * Add the given {@link Exchange} under the correlation key.\r\n * <p\/>\r\n * Will replace any existing exchange.\r\n *\r\n * @param camelContext   the current CamelContext\r\n * @param key            the correlation key\r\n * @param exchange       the aggregated exchange\r\n * @return the old exchange if any existed\r\n *\/\r\n","code_no_comment":"Exchange add(CamelContext camelContext, String key, Exchange exchange);","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.48794926,"fo":-0.5,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-554_3f51fb09","label":1,"code":"\/**\r\n * Create a multi valued {@code PropertyState} based on a list of\r\n * {@link Value} instances. The {@link Type} of the property is determined\r\n * by the type of the first value in the list or {@link Type#STRING} if the\r\n * list is empty.\r\n *\r\n * @param name  The name of the property state\r\n * @param values  The values of the property state\r\n * @return  The new property state\r\n * @throws RepositoryException forwarded from {@code value}\r\n *\/\r\n@Nonnull\r\npublic static PropertyState createProperty(String name, Iterable<Value> values) throws RepositoryException {\r\n    Value first = Iterables.getFirst(values, null);\r\n    if (first == null) {\r\n        return EmptyPropertyState.emptyProperty(name, STRINGS);\r\n    }\r\n    int type = first.getType();\r\n    switch(type) {\r\n        case PropertyType.STRING:\r\n            List<String> strings = Lists.newArrayList();\r\n            for (Value value : values) {\r\n                strings.add(value.getString());\r\n            }\r\n            return MultiStringPropertyState.stringProperty(name, strings);\r\n        case PropertyType.BINARY:\r\n            List<Blob> blobs = Lists.newArrayList();\r\n            for (Value value : values) {\r\n                blobs.add(new ValueBasedBlob(value));\r\n            }\r\n            return MultiBinaryPropertyState.binaryPropertyFromBlob(name, blobs);\r\n        case PropertyType.LONG:\r\n            List<Long> longs = Lists.newArrayList();\r\n            for (Value value : values) {\r\n                longs.add(value.getLong());\r\n            }\r\n            return MultiLongPropertyState.createLongProperty(name, longs);\r\n        case PropertyType.DOUBLE:\r\n            List<Double> doubles = Lists.newArrayList();\r\n            for (Value value : values) {\r\n                doubles.add(value.getDouble());\r\n            }\r\n            return MultiDoublePropertyState.doubleProperty(name, doubles);\r\n        case PropertyType.DATE:\r\n            List<Long> dates = Lists.newArrayList();\r\n            for (Value value : values) {\r\n                dates.add(value.getLong());\r\n            }\r\n            return MultiLongPropertyState.createDatePropertyFromLong(name, dates);\r\n        case PropertyType.BOOLEAN:\r\n            List<Boolean> booleans = Lists.newArrayList();\r\n            for (Value value : values) {\r\n                booleans.add(value.getBoolean());\r\n            }\r\n            return MultiBooleanPropertyState.booleanProperty(name, booleans);\r\n        case PropertyType.DECIMAL:\r\n            List<BigDecimal> decimals = Lists.newArrayList();\r\n            for (Value value : values) {\r\n                decimals.add(value.getDecimal());\r\n            }\r\n            return MultiDecimalPropertyState.decimalProperty(name, decimals);\r\n        default:\r\n            List<String> vals = Lists.newArrayList();\r\n            for (Value value : values) {\r\n                vals.add(value.getString());\r\n            }\r\n            return new MultiGenericPropertyState(name, vals, Type.fromTag(type, true));\r\n    }\r\n}","code_comment":"\/**\r\n * Create a multi valued {@code PropertyState} based on a list of\r\n * {@link Value} instances. The {@link Type} of the property is determined\r\n * by the type of the first value in the list or {@link Type#STRING} if the\r\n * list is empty.\r\n *\r\n * @param name  The name of the property state\r\n * @param values  The values of the property state\r\n * @return  The new property state\r\n * @throws RepositoryException forwarded from {@code value}\r\n *\/\r\n","code_no_comment":"@Nonnull\r\npublic static PropertyState createProperty(String name, Iterable<Value> values) throws RepositoryException {\r\n    Value first = Iterables.getFirst(values, null);\r\n    if (first == null) {\r\n        return EmptyPropertyState.emptyProperty(name, STRINGS);\r\n    }\r\n    int type = first.getType();\r\n    switch(type) {\r\n        case PropertyType.STRING:\r\n            List<String> strings = Lists.newArrayList();\r\n            for (Value value : values) {\r\n                strings.add(value.getString());\r\n            }\r\n            return MultiStringPropertyState.stringProperty(name, strings);\r\n        case PropertyType.BINARY:\r\n            List<Blob> blobs = Lists.newArrayList();\r\n            for (Value value : values) {\r\n                blobs.add(new ValueBasedBlob(value));\r\n            }\r\n            return MultiBinaryPropertyState.binaryPropertyFromBlob(name, blobs);\r\n        case PropertyType.LONG:\r\n            List<Long> longs = Lists.newArrayList();\r\n            for (Value value : values) {\r\n                longs.add(value.getLong());\r\n            }\r\n            return MultiLongPropertyState.createLongProperty(name, longs);\r\n        case PropertyType.DOUBLE:\r\n            List<Double> doubles = Lists.newArrayList();\r\n            for (Value value : values) {\r\n                doubles.add(value.getDouble());\r\n            }\r\n            return MultiDoublePropertyState.doubleProperty(name, doubles);\r\n        case PropertyType.DATE:\r\n            List<Long> dates = Lists.newArrayList();\r\n            for (Value value : values) {\r\n                dates.add(value.getLong());\r\n            }\r\n            return MultiLongPropertyState.createDatePropertyFromLong(name, dates);\r\n        case PropertyType.BOOLEAN:\r\n            List<Boolean> booleans = Lists.newArrayList();\r\n            for (Value value : values) {\r\n                booleans.add(value.getBoolean());\r\n            }\r\n            return MultiBooleanPropertyState.booleanProperty(name, booleans);\r\n        case PropertyType.DECIMAL:\r\n            List<BigDecimal> decimals = Lists.newArrayList();\r\n            for (Value value : values) {\r\n                decimals.add(value.getDecimal());\r\n            }\r\n            return MultiDecimalPropertyState.decimalProperty(name, decimals);\r\n        default:\r\n            List<String> vals = Lists.newArrayList();\r\n            for (Value value : values) {\r\n                vals.add(value.getString());\r\n            }\r\n            return new MultiGenericPropertyState(name, vals, Type.fromTag(type, true));\r\n    }\r\n}","lc":2.0,"pi":0.5119617225,"ma":2.8,"nbd":0.5,"ml":0.4166666667,"d":0.1329365079,"mi":-1.021987315,"fo":2.3333333333,"r":-0.0263157895,"e":1.1305129579}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4323_e24874da","label":3,"code":"\/**\r\n *  @see org.apache.wicket.model.IDetachable#detach()\r\n *\/\r\n@Override\r\nprotected final void onDetach() {\r\n    \/\/ detach any model\r\n    if (model != null) {\r\n        model.detach();\r\n    }\r\n    \/\/ some parameters can be detachable\r\n    if (parameters != null) {\r\n        for (Object parameter : parameters) {\r\n            if (parameter instanceof IDetachable) {\r\n                ((IDetachable) parameter).detach();\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.model.IDetachable#detach()\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected final void onDetach() {\r\n        if (model != null) {\r\n        model.detach();\r\n    }\r\n        if (parameters != null) {\r\n        for (Object parameter : parameters) {\r\n            if (parameter instanceof IDetachable) {\r\n                ((IDetachable) parameter).detach();\r\n            }\r\n        }\r\n    }\r\n}","lc":-0.0454545455,"pi":0.8995215311,"ma":0.2,"nbd":0.5,"ml":0.0833333333,"d":-0.3650793651,"mi":0.1602536998,"fo":-0.3333333333,"r":1.5,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1429_c2f5ca6c","label":1,"code":"DocumentNodeState.Children readChildren(DocumentNodeState parent, String name, int limit) {\r\n    \/\/ TODO use offset, to avoid O(n^2) and running out of memory\r\n    \/\/ to do that, use the *name* of the last entry of the previous batch of children\r\n    \/\/ as the starting point\r\n    String path = parent.getPath();\r\n    Revision rev = parent.getLastRevision();\r\n    Iterable<NodeDocument> docs;\r\n    DocumentNodeState.Children c = new DocumentNodeState.Children();\r\n    \/\/ add one to the requested limit for the raw limit\r\n    \/\/ this gives us a chance to detect whether there are more\r\n    \/\/ child nodes than requested.\r\n    int rawLimit = (int) Math.min(Integer.MAX_VALUE, ((long) limit) + 1);\r\n    for (; ; ) {\r\n        c.children.clear();\r\n        docs = readChildDocs(path, name, rawLimit);\r\n        int numReturned = 0;\r\n        for (NodeDocument doc : docs) {\r\n            numReturned++;\r\n            \/\/ filter out deleted children\r\n            String p = Utils.getPathFromId(doc.getId());\r\n            DocumentNodeState child = getNode(p, rev);\r\n            if (child == null) {\r\n                continue;\r\n            }\r\n            if (c.children.size() < limit) {\r\n                \/\/ add to children until limit is reached\r\n                c.children.add(p);\r\n            } else {\r\n                \/\/ enough collected and we know there are more\r\n                c.hasMore = true;\r\n                return c;\r\n            }\r\n        }\r\n        \/\/ if we get here we have less than or equal the requested children\r\n        if (numReturned < rawLimit) {\r\n            \/\/ fewer documents returned than requested\r\n            \/\/ -> no more documents\r\n            c.hasMore = false;\r\n            return c;\r\n        }\r\n        \/\/ double rawLimit for next round\r\n        rawLimit = (int) Math.min(((long) rawLimit) * 2, Integer.MAX_VALUE);\r\n    }\r\n}","code_comment":null,"code_no_comment":"DocumentNodeState.Children readChildren(DocumentNodeState parent, String name, int limit) {\r\n                String path = parent.getPath();\r\n    Revision rev = parent.getLastRevision();\r\n    Iterable<NodeDocument> docs;\r\n    DocumentNodeState.Children c = new DocumentNodeState.Children();\r\n                int rawLimit = (int) Math.min(Integer.MAX_VALUE, ((long) limit) + 1);\r\n    for (; ; ) {\r\n        c.children.clear();\r\n        docs = readChildDocs(path, name, rawLimit);\r\n        int numReturned = 0;\r\n        for (NodeDocument doc : docs) {\r\n            numReturned++;\r\n                        String p = Utils.getPathFromId(doc.getId());\r\n            DocumentNodeState child = getNode(p, rev);\r\n            if (child == null) {\r\n                continue;\r\n            }\r\n            if (c.children.size() < limit) {\r\n                                c.children.add(p);\r\n            } else {\r\n                                c.hasMore = true;\r\n                return c;\r\n            }\r\n        }\r\n                if (numReturned < rawLimit) {\r\n                                    c.hasMore = false;\r\n            return c;\r\n        }\r\n                rawLimit = (int) Math.min(((long) rawLimit) * 2, Integer.MAX_VALUE);\r\n    }\r\n}","lc":0.7727272727,"pi":0.7272727273,"ma":0.6,"nbd":0.5,"ml":0.25,"d":0.8253968254,"mi":-0.5644820296,"fo":0.4166666667,"r":-0.0263157895,"e":1.3975715035}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * Expands the internal storage array using the expansion factor.\r\n * <p>\r\n * if <code>expansionMode<\/code> is set to MULTIPLICATIVE_MODE,\r\n * the new array size will be <code>internalArray.length * expansionFactor.<\/code>\r\n * If <code>expansionMode<\/code> is set to ADDITIVE_MODE,  the length\r\n * after expansion will be <code>internalArray.length + expansionFactor<\/code>\r\n * <\/p>\r\n *\/\r\nprotected synchronized void expand() {\r\n    \/\/ notice the use of FastMath.ceil(), this guarantees that we will always\r\n    \/\/ have an array of at least currentSize + 1.   Assume that the\r\n    \/\/ current initial capacity is 1 and the expansion factor\r\n    \/\/ is 1.000000000000000001.  The newly calculated size will be\r\n    \/\/ rounded up to 2 after the multiplication is performed.\r\n    int newSize = 0;\r\n    if (expansionMode == ExpansionMode.MULTIPLICATIVE) {\r\n        newSize = (int) FastMath.ceil(internalArray.length * expansionFactor);\r\n    } else {\r\n        newSize = (int) (internalArray.length + FastMath.round(expansionFactor));\r\n    }\r\n    final double[] tempArray = new double[newSize];\r\n    \/\/ Copy and swap\r\n    System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\r\n    internalArray = tempArray;\r\n}","code_comment":"\/**\r\n * Expands the internal storage array using the expansion factor.\r\n * <p>\r\n * if <code>expansionMode<\/code> is set to MULTIPLICATIVE_MODE,\r\n * the new array size will be <code>internalArray.length * expansionFactor.<\/code>\r\n * If <code>expansionMode<\/code> is set to ADDITIVE_MODE,  the length\r\n * after expansion will be <code>internalArray.length + expansionFactor<\/code>\r\n * <\/p>\r\n *\/\r\n","code_no_comment":"protected synchronized void expand() {\r\n                        int newSize = 0;\r\n    if (expansionMode == ExpansionMode.MULTIPLICATIVE) {\r\n        newSize = (int) FastMath.ceil(internalArray.length * expansionFactor);\r\n    } else {\r\n        newSize = (int) (internalArray.length + FastMath.round(expansionFactor));\r\n    }\r\n    final double[] tempArray = new double[newSize];\r\n        System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\r\n    internalArray = tempArray;\r\n}","lc":-0.1363636364,"pi":-0.2775119617,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.4047619048,"mi":0.1179704017,"fo":-0.25,"r":0.0,"e":0.1383309417}
{"project_name":"Closure","project_version":"167","label":2,"code":"private FlowScope caseAndOrNotShortCircuiting(Node left, Node right, FlowScope blindScope, boolean condition) {\r\n    \/\/ left type\r\n    JSType leftType = getTypeIfRefinable(left, blindScope);\r\n    boolean leftIsRefineable;\r\n    if (leftType != null) {\r\n        leftIsRefineable = true;\r\n    } else {\r\n        leftIsRefineable = false;\r\n        leftType = left.getJSType();\r\n        blindScope = firstPreciserScopeKnowingConditionOutcome(left, blindScope, condition);\r\n    }\r\n    \/\/ restricting left type\r\n    JSType restrictedLeftType = (leftType == null) ? null : leftType.getRestrictedTypeGivenToBooleanOutcome(condition);\r\n    if (restrictedLeftType == null) {\r\n        return firstPreciserScopeKnowingConditionOutcome(right, blindScope, condition);\r\n    }\r\n    \/\/ right type\r\n    JSType rightType = getTypeIfRefinable(right, blindScope);\r\n    boolean rightIsRefineable;\r\n    if (rightType != null) {\r\n        rightIsRefineable = true;\r\n    } else {\r\n        rightIsRefineable = false;\r\n        rightType = right.getJSType();\r\n        blindScope = firstPreciserScopeKnowingConditionOutcome(right, blindScope, condition);\r\n    }\r\n    if (condition) {\r\n        JSType restrictedRightType = (rightType == null) ? null : rightType.getRestrictedTypeGivenToBooleanOutcome(condition);\r\n        \/\/ creating new scope\r\n        return maybeRestrictTwoNames(blindScope, left, leftIsRefineable, restrictedLeftType, right, rightIsRefineable, restrictedRightType);\r\n    }\r\n    return blindScope;\r\n}","code_comment":null,"code_no_comment":"private FlowScope caseAndOrNotShortCircuiting(Node left, Node right, FlowScope blindScope, boolean condition) {\r\n        JSType leftType = getTypeIfRefinable(left, blindScope);\r\n    boolean leftIsRefineable;\r\n    if (leftType != null) {\r\n        leftIsRefineable = true;\r\n    } else {\r\n        leftIsRefineable = false;\r\n        leftType = left.getJSType();\r\n        blindScope = firstPreciserScopeKnowingConditionOutcome(left, blindScope, condition);\r\n    }\r\n        JSType restrictedLeftType = (leftType == null) ? null : leftType.getRestrictedTypeGivenToBooleanOutcome(condition);\r\n    if (restrictedLeftType == null) {\r\n        return firstPreciserScopeKnowingConditionOutcome(right, blindScope, condition);\r\n    }\r\n        JSType rightType = getTypeIfRefinable(right, blindScope);\r\n    boolean rightIsRefineable;\r\n    if (rightType != null) {\r\n        rightIsRefineable = true;\r\n    } else {\r\n        rightIsRefineable = false;\r\n        rightType = right.getJSType();\r\n        blindScope = firstPreciserScopeKnowingConditionOutcome(right, blindScope, condition);\r\n    }\r\n    if (condition) {\r\n        JSType restrictedRightType = (rightType == null) ? null : rightType.getRestrictedTypeGivenToBooleanOutcome(condition);\r\n                return maybeRestrictTwoNames(blindScope, left, leftIsRefineable, restrictedLeftType, right, rightIsRefineable, restrictedRightType);\r\n    }\r\n    return blindScope;\r\n}","lc":0.6818181818,"pi":-0.2966507177,"ma":0.6,"nbd":-0.5,"ml":0.4166666667,"d":0.3432539683,"mi":-0.5058491896,"fo":0.3333333333,"r":-0.0263157895,"e":0.6020850262}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2172_ea4a3f8a","label":3,"code":"\/**\r\n *  @see IValueMap#getAsInteger(String)\r\n *\/\r\npublic Integer getAsInteger(String key) {\r\n    if (!containsKey(key))\r\n        return null;\r\n    try {\r\n        return getInt(key);\r\n    } catch (StringValueConversionException ignored) {\r\n        return null;\r\n    }\r\n}","code_comment":"\/**\r\n *  @see IValueMap#getAsInteger(String)\r\n *\/\r\n","code_no_comment":"public Integer getAsInteger(String key) {\r\n    if (!containsKey(key))\r\n        return null;\r\n    try {\r\n        return getInt(key);\r\n    } catch (StringValueConversionException ignored) {\r\n        return null;\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.2,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.3860465116,"fo":-0.3333333333,"r":2.4473684211,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2552_12e1f39b","label":1,"code":"\/**\r\n *  @see AbstractValidator#onValidate(IValidatable)\r\n *\/\r\n@Override\r\nprotected void onValidate(IValidatable<String> validatable) {\r\n    String input = (validatable.getValue());\r\n    String numberToCheck = input.replaceAll(\"[ -]\", \"\");\r\n    int nulOffset = '0';\r\n    int sum = 0;\r\n    for (int i = 1; i <= numberToCheck.length(); i++) {\r\n        int currentDigit = numberToCheck.charAt(numberToCheck.length() - i) - nulOffset;\r\n        if ((i % 2) == 0) {\r\n            currentDigit *= 2;\r\n            currentDigit = currentDigit > 9 ? currentDigit - 9 : currentDigit;\r\n            sum += currentDigit;\r\n        } else {\r\n            sum += currentDigit;\r\n        }\r\n    }\r\n    if (!((sum % 10) == 0)) {\r\n        error(validatable);\r\n    }\r\n}","code_comment":"\/**\r\n *  @see AbstractValidator#onValidate(IValidatable)\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void onValidate(IValidatable<String> validatable) {\r\n    String input = (validatable.getValue());\r\n    String numberToCheck = input.replaceAll(\"[ -]\", \"\");\r\n    int nulOffset = '0';\r\n    int sum = 0;\r\n    for (int i = 1; i <= numberToCheck.length(); i++) {\r\n        int currentDigit = numberToCheck.charAt(numberToCheck.length() - i) - nulOffset;\r\n        if ((i % 2) == 0) {\r\n            currentDigit *= 2;\r\n            currentDigit = currentDigit > 9 ? currentDigit - 9 : currentDigit;\r\n            sum += currentDigit;\r\n        } else {\r\n            sum += currentDigit;\r\n        }\r\n    }\r\n    if (!((sum % 10) == 0)) {\r\n        error(validatable);\r\n    }\r\n}","lc":0.2727272727,"pi":0.4354066986,"ma":0.2,"nbd":0.0,"ml":0.25,"d":1.8253968254,"mi":-0.2921775899,"fo":0.0,"r":0.1052631579,"e":1.7536695424}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-320_b2f3f6db","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic RealMatrix getV() throws InvalidMatrixException {\r\n    if (cachedV == null) {\r\n        final int p = singularValues.length;\r\n        if (m >= n) {\r\n            \/\/ the tridiagonal matrix is Bt.B, where B is upper bidiagonal\r\n            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\r\n            cachedV = transformer.getV().multiply(e);\r\n        } else {\r\n            \/\/ the tridiagonal matrix is B.Bt, where B is lower bidiagonal\r\n            \/\/ compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\r\n            final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\r\n            final double[][] eData = e.getData();\r\n            final double[][] wData = new double[n][p];\r\n            double[] ei1 = eData[0];\r\n            for (int i = 0; i < p - 1; ++i) {\r\n                final double mi = mainBidiagonal[i];\r\n                final double si = secondaryBidiagonal[i];\r\n                final double[] ei0 = ei1;\r\n                final double[] wi = wData[i];\r\n                ei1 = eData[i + 1];\r\n                for (int j = 0; j < p; ++j) {\r\n                    wi[j] = (mi * ei0[j] + si * ei1[j]) \/ singularValues[j];\r\n                }\r\n            }\r\n            \/\/ last row\r\n            final double lastMain = mainBidiagonal[p - 1];\r\n            final double[] wr1 = wData[p - 1];\r\n            for (int j = 0; j < p; ++j) {\r\n                wr1[j] = ei1[j] * lastMain \/ singularValues[j];\r\n            }\r\n            for (int i = p; i < n; ++i) {\r\n                wData[i] = new double[p];\r\n            }\r\n            cachedV = transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\r\n        }\r\n    }\r\n    \/\/ return the cached matrix\r\n    return cachedV;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public RealMatrix getV() throws InvalidMatrixException {\r\n    if (cachedV == null) {\r\n        final int p = singularValues.length;\r\n        if (m >= n) {\r\n                        final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\r\n            cachedV = transformer.getV().multiply(e);\r\n        } else {\r\n                                    final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\r\n            final double[][] eData = e.getData();\r\n            final double[][] wData = new double[n][p];\r\n            double[] ei1 = eData[0];\r\n            for (int i = 0; i < p - 1; ++i) {\r\n                final double mi = mainBidiagonal[i];\r\n                final double si = secondaryBidiagonal[i];\r\n                final double[] ei0 = ei1;\r\n                final double[] wi = wData[i];\r\n                ei1 = eData[i + 1];\r\n                for (int j = 0; j < p; ++j) {\r\n                    wi[j] = (mi * ei0[j] + si * ei1[j]) \/ singularValues[j];\r\n                }\r\n            }\r\n                        final double lastMain = mainBidiagonal[p - 1];\r\n            final double[] wr1 = wData[p - 1];\r\n            for (int j = 0; j < p; ++j) {\r\n                wr1[j] = ei1[j] * lastMain \/ singularValues[j];\r\n            }\r\n            for (int i = p; i < n; ++i) {\r\n                wData[i] = new double[p];\r\n            }\r\n            cachedV = transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\r\n        }\r\n    }\r\n        return cachedV;\r\n}","lc":0.9090909091,"pi":0.8038277512,"ma":0.6,"nbd":1.0,"ml":0.5833333333,"d":2.4126984127,"mi":-0.6744186047,"fo":0.3333333333,"r":-0.0263157895,"e":5.6161154429}
{"project_name":"Csv","project_version":"2","label":1,"code":"\/**\r\n * Returns a value by name.\r\n *\r\n * @param name\r\n *            the name of the column to be retrieved.\r\n * @return the column value, or {@code null} if the column name is not found\r\n * @throws IllegalStateException\r\n *             if no header mapping was provided\r\n * @throws IllegalArgumentException\r\n *             if the record is inconsistent\r\n * @see #isConsistent()\r\n *\/\r\npublic String get(final String name) {\r\n    if (mapping == null) {\r\n        throw new IllegalStateException(\"No header mapping was specified, the record values can't be accessed by name\");\r\n    }\r\n    final Integer index = mapping.get(name);\r\n    return index != null ? values[index.intValue()] : null;\r\n}","code_comment":"\/**\r\n * Returns a value by name.\r\n *\r\n * @param name\r\n *            the name of the column to be retrieved.\r\n * @return the column value, or {@code null} if the column name is not found\r\n * @throws IllegalStateException\r\n *             if no header mapping was provided\r\n * @throws IllegalArgumentException\r\n *             if the record is inconsistent\r\n * @see #isConsistent()\r\n *\/\r\n","code_no_comment":"public String get(final String name) {\r\n    if (mapping == null) {\r\n        throw new IllegalStateException(\"No header mapping was specified, the record values can't be accessed by name\");\r\n    }\r\n    final Integer index = mapping.get(name);\r\n    return index != null ? values[index.intValue()] : null;\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0337301587,"mi":0.4038054968,"fo":-0.3333333333,"r":2.2368421053,"e":-0.0937489555}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2799_3979fa8d","label":1,"code":"@Override\r\npublic OakIndexInput clone() {\r\n    return new OakIndexInput(this);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic OakIndexInput clone() {\r\n    return new OakIndexInput(this);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0005637773,"fo":-0.5,"r":1.8947368421,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2390_28294266","label":1,"code":"@Override\r\npublic Object invoke(Object obj, Method method, Object[] args) throws Throwable {\r\n    if (!sampler.next()) {\r\n        return method.invoke(instance, args);\r\n    }\r\n    Span span = Trace.on(method.getName());\r\n    try {\r\n        return method.invoke(instance, args);\r\n    } catch (Throwable ex) {\r\n        ex.printStackTrace();\r\n        throw ex;\r\n    } finally {\r\n        span.stop();\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Object invoke(Object obj, Method method, Object[] args) throws Throwable {\r\n    if (!sampler.next()) {\r\n        return method.invoke(instance, args);\r\n    }\r\n    Span span = Trace.on(method.getName());\r\n    try {\r\n        return method.invoke(instance, args);\r\n    } catch (Throwable ex) {\r\n        ex.printStackTrace();\r\n        throw ex;\r\n    } finally {\r\n        span.stop();\r\n    }\r\n}","lc":0.0454545455,"pi":-0.0574162679,"ma":0.0,"nbd":-0.5,"ml":-0.25,"d":-0.0277777778,"mi":-0.0294573643,"fo":0.0833333333,"r":0.1052631579,"e":-0.03696801}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2433_7fca85bf","label":1,"code":"@Override\r\n@Nonnull\r\npublic Iterator<Map.Entry<Revision, String>> iterator() {\r\n    final Comparator<? super Revision> c = map.comparator();\r\n    final Iterator<NodeDocument> docs;\r\n    if (map.isEmpty()) {\r\n        docs = doc.getPreviousDocs(property, null).iterator();\r\n    } else {\r\n        docs = Iterators.concat(Iterators.singletonIterator(doc), doc.getPreviousDocs(property, null).iterator());\r\n    }\r\n    return new MergeSortedIterators<Map.Entry<Revision, String>>(new Comparator<Map.Entry<Revision, String>>() {\r\n\r\n        @Override\r\n        public int compare(Map.Entry<Revision, String> o1, Map.Entry<Revision, String> o2) {\r\n            return c.compare(o1.getKey(), o2.getKey());\r\n        }\r\n    }) {\r\n\r\n        @Override\r\n        public Iterator<Map.Entry<Revision, String>> nextIterator() {\r\n            NodeDocument d = docs.hasNext() ? docs.next() : null;\r\n            if (d == null) {\r\n                return null;\r\n            }\r\n            Map<Revision, String> values;\r\n            if (Objects.equal(d.getId(), doc.getId())) {\r\n                \/\/ return local map for main document\r\n                values = d.getLocalMap(property);\r\n            } else {\r\n                values = d.getValueMap(property);\r\n            }\r\n            return values.entrySet().iterator();\r\n        }\r\n\r\n        @Override\r\n        public String description() {\r\n            return \"Revisioned values for property \" + doc.getId() + \"\/\" + property + \":\";\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"@Override\r\n@Nonnull\r\npublic Iterator<Map.Entry<Revision, String>> iterator() {\r\n    final Comparator<? super Revision> c = map.comparator();\r\n    final Iterator<NodeDocument> docs;\r\n    if (map.isEmpty()) {\r\n        docs = doc.getPreviousDocs(property, null).iterator();\r\n    } else {\r\n        docs = Iterators.concat(Iterators.singletonIterator(doc), doc.getPreviousDocs(property, null).iterator());\r\n    }\r\n    return new MergeSortedIterators<Map.Entry<Revision, String>>(new Comparator<Map.Entry<Revision, String>>() {\r\n\r\n        @Override\r\n        public int compare(Map.Entry<Revision, String> o1, Map.Entry<Revision, String> o2) {\r\n            return c.compare(o1.getKey(), o2.getKey());\r\n        }\r\n    }) {\r\n\r\n        @Override\r\n        public Iterator<Map.Entry<Revision, String>> nextIterator() {\r\n            NodeDocument d = docs.hasNext() ? docs.next() : null;\r\n            if (d == null) {\r\n                return null;\r\n            }\r\n            Map<Revision, String> values;\r\n            if (Objects.equal(d.getId(), doc.getId())) {\r\n                                values = d.getLocalMap(property);\r\n            } else {\r\n                values = d.getValueMap(property);\r\n            }\r\n            return values.entrySet().iterator();\r\n        }\r\n\r\n        @Override\r\n        public String description() {\r\n            return \"Revisioned values for property \" + doc.getId() + \"\/\" + property + \":\";\r\n        }\r\n    };\r\n}","lc":1.0,"pi":0.7320574163,"ma":0.2,"nbd":0.0,"ml":0.4166666667,"d":0.1468253968,"mi":-0.6422832981,"fo":1.25,"r":-0.0263157895,"e":0.6194706177}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1458_91f9bfc7","label":1,"code":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nprivate <OUT, IN1, IN2> TypeInformation<OUT> privateGetForClass(Class<OUT> clazz, ArrayList<Type> typeHierarchy, ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\r\n    Validate.notNull(clazz);\r\n    \/\/ check for abstract classes or interfaces\r\n    if (!clazz.isPrimitive() && (Modifier.isInterface(clazz.getModifiers()) || (Modifier.isAbstract(clazz.getModifiers()) && !clazz.isArray()))) {\r\n        throw new InvalidTypesException(\"Interfaces and abstract classes are not valid types: \" + clazz);\r\n    }\r\n    if (clazz.equals(Object.class)) {\r\n        return new GenericTypeInfo<OUT>(clazz);\r\n    }\r\n    \/\/ check for arrays\r\n    if (clazz.isArray()) {\r\n        \/\/ primitive arrays: int[], byte[], ...\r\n        PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = PrimitiveArrayTypeInfo.getInfoFor(clazz);\r\n        if (primitiveArrayInfo != null) {\r\n            return primitiveArrayInfo;\r\n        }\r\n        \/\/ basic type arrays: String[], Integer[], Double[]\r\n        BasicArrayTypeInfo<OUT, ?> basicArrayInfo = BasicArrayTypeInfo.getInfoFor(clazz);\r\n        if (basicArrayInfo != null) {\r\n            return basicArrayInfo;\r\n        } else \/\/ object arrays\r\n        {\r\n            return ObjectArrayTypeInfo.getInfoFor(clazz);\r\n        }\r\n    }\r\n    \/\/ check for writable types\r\n    if (Writable.class.isAssignableFrom(clazz)) {\r\n        return (TypeInformation<OUT>) WritableTypeInfo.getWritableTypeInfo((Class<? extends Writable>) clazz);\r\n    }\r\n    \/\/ check for basic types\r\n    TypeInformation<OUT> basicTypeInfo = BasicTypeInfo.getInfoFor(clazz);\r\n    if (basicTypeInfo != null) {\r\n        return basicTypeInfo;\r\n    }\r\n    \/\/ check for subclasses of Value\r\n    if (Value.class.isAssignableFrom(clazz)) {\r\n        Class<? extends Value> valueClass = clazz.asSubclass(Value.class);\r\n        return (TypeInformation<OUT>) ValueTypeInfo.getValueTypeInfo(valueClass);\r\n    }\r\n    \/\/ check for subclasses of Tuple\r\n    if (Tuple.class.isAssignableFrom(clazz)) {\r\n        throw new InvalidTypesException(\"Type information extraction for tuples cannot be done based on the class.\");\r\n    }\r\n    \/\/ check for Enums\r\n    if (Enum.class.isAssignableFrom(clazz)) {\r\n        return (TypeInformation<OUT>) new EnumTypeInfo(clazz);\r\n    }\r\n    if (alreadySeen.contains(clazz)) {\r\n        return new GenericTypeInfo<OUT>(clazz);\r\n    }\r\n    alreadySeen.add(clazz);\r\n    if (clazz.equals(Class.class)) {\r\n        \/\/ special case handling for Class, this should not be handled by the POJO logic\r\n        return new GenericTypeInfo<OUT>(clazz);\r\n    }\r\n    try {\r\n        TypeInformation<OUT> pojoType = analyzePojo(clazz, new ArrayList<Type>(typeHierarchy), parameterizedType, in1Type, in2Type);\r\n        if (pojoType != null) {\r\n            return pojoType;\r\n        }\r\n    } catch (InvalidTypesException e) {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Unable to handle type \" + clazz + \" as POJO. Message: \" + e.getMessage(), e);\r\n        }\r\n    \/\/ ignore and create generic type info\r\n    }\r\n    \/\/ return a generic type\r\n    return new GenericTypeInfo<OUT>(clazz);\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nprivate <OUT, IN1, IN2> TypeInformation<OUT> privateGetForClass(Class<OUT> clazz, ArrayList<Type> typeHierarchy, ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\r\n    Validate.notNull(clazz);\r\n        if (!clazz.isPrimitive() && (Modifier.isInterface(clazz.getModifiers()) || (Modifier.isAbstract(clazz.getModifiers()) && !clazz.isArray()))) {\r\n        throw new InvalidTypesException(\"Interfaces and abstract classes are not valid types: \" + clazz);\r\n    }\r\n    if (clazz.equals(Object.class)) {\r\n        return new GenericTypeInfo<OUT>(clazz);\r\n    }\r\n        if (clazz.isArray()) {\r\n                PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = PrimitiveArrayTypeInfo.getInfoFor(clazz);\r\n        if (primitiveArrayInfo != null) {\r\n            return primitiveArrayInfo;\r\n        }\r\n                BasicArrayTypeInfo<OUT, ?> basicArrayInfo = BasicArrayTypeInfo.getInfoFor(clazz);\r\n        if (basicArrayInfo != null) {\r\n            return basicArrayInfo;\r\n        } else         {\r\n            return ObjectArrayTypeInfo.getInfoFor(clazz);\r\n        }\r\n    }\r\n        if (Writable.class.isAssignableFrom(clazz)) {\r\n        return (TypeInformation<OUT>) WritableTypeInfo.getWritableTypeInfo((Class<? extends Writable>) clazz);\r\n    }\r\n        TypeInformation<OUT> basicTypeInfo = BasicTypeInfo.getInfoFor(clazz);\r\n    if (basicTypeInfo != null) {\r\n        return basicTypeInfo;\r\n    }\r\n        if (Value.class.isAssignableFrom(clazz)) {\r\n        Class<? extends Value> valueClass = clazz.asSubclass(Value.class);\r\n        return (TypeInformation<OUT>) ValueTypeInfo.getValueTypeInfo(valueClass);\r\n    }\r\n        if (Tuple.class.isAssignableFrom(clazz)) {\r\n        throw new InvalidTypesException(\"Type information extraction for tuples cannot be done based on the class.\");\r\n    }\r\n        if (Enum.class.isAssignableFrom(clazz)) {\r\n        return (TypeInformation<OUT>) new EnumTypeInfo(clazz);\r\n    }\r\n    if (alreadySeen.contains(clazz)) {\r\n        return new GenericTypeInfo<OUT>(clazz);\r\n    }\r\n    alreadySeen.add(clazz);\r\n    if (clazz.equals(Class.class)) {\r\n                return new GenericTypeInfo<OUT>(clazz);\r\n    }\r\n    try {\r\n        TypeInformation<OUT> pojoType = analyzePojo(clazz, new ArrayList<Type>(typeHierarchy), parameterizedType, in1Type, in2Type);\r\n        if (pojoType != null) {\r\n            return pojoType;\r\n        }\r\n    } catch (InvalidTypesException e) {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Unable to handle type \" + clazz + \" as POJO. Message: \" + e.getMessage(), e);\r\n        }\r\n        }\r\n        return new GenericTypeInfo<OUT>(clazz);\r\n}","lc":2.0,"pi":-0.043062201,"ma":2.8,"nbd":0.0,"ml":2.5,"d":1.0992063492,"mi":-1.0174770965,"fo":1.75,"r":-0.0263157895,"e":3.5221498015}
{"project_name":"Time","project_version":"13","label":3,"code":"public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\r\n    long valueLong = getFieldValue(period);\r\n    if (valueLong == Long.MAX_VALUE) {\r\n        return;\r\n    }\r\n    int value = (int) valueLong;\r\n    if (iFieldType >= SECONDS_MILLIS) {\r\n        value = (int) (valueLong \/ DateTimeConstants.MILLIS_PER_SECOND);\r\n    }\r\n    if (iPrefix != null) {\r\n        iPrefix.printTo(buf, value);\r\n    }\r\n    int minDigits = iMinPrintedDigits;\r\n    if (minDigits <= 1) {\r\n        FormatUtils.appendUnpaddedInteger(buf, value);\r\n    } else {\r\n        FormatUtils.appendPaddedInteger(buf, value, minDigits);\r\n    }\r\n    if (iFieldType >= SECONDS_MILLIS) {\r\n        int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\r\n        if (iFieldType == SECONDS_MILLIS || dp > 0) {\r\n            buf.append('.');\r\n            FormatUtils.appendPaddedInteger(buf, dp, 3);\r\n        }\r\n    }\r\n    if (iSuffix != null) {\r\n        iSuffix.printTo(buf, value);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\r\n    long valueLong = getFieldValue(period);\r\n    if (valueLong == Long.MAX_VALUE) {\r\n        return;\r\n    }\r\n    int value = (int) valueLong;\r\n    if (iFieldType >= SECONDS_MILLIS) {\r\n        value = (int) (valueLong \/ DateTimeConstants.MILLIS_PER_SECOND);\r\n    }\r\n    if (iPrefix != null) {\r\n        iPrefix.printTo(buf, value);\r\n    }\r\n    int minDigits = iMinPrintedDigits;\r\n    if (minDigits <= 1) {\r\n        FormatUtils.appendUnpaddedInteger(buf, value);\r\n    } else {\r\n        FormatUtils.appendPaddedInteger(buf, value, minDigits);\r\n    }\r\n    if (iFieldType >= SECONDS_MILLIS) {\r\n        int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\r\n        if (iFieldType == SECONDS_MILLIS || dp > 0) {\r\n            buf.append('.');\r\n            FormatUtils.appendPaddedInteger(buf, dp, 3);\r\n        }\r\n    }\r\n    if (iSuffix != null) {\r\n        iSuffix.printTo(buf, value);\r\n    }\r\n}","lc":0.6818181818,"pi":-0.0622009569,"ma":0.8,"nbd":0.0,"ml":0.75,"d":1.246031746,"mi":-0.5066948555,"fo":0.1666666667,"r":-0.0263157895,"e":1.5129498683}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5071_6e794ad0","label":1,"code":"\/**\r\n *  @see AbstractBookmarkableMapper#parseRequest(org.apache.wicket.request.Request)\r\n *\/\r\n@Override\r\nprotected UrlInfo parseRequest(Request request) {\r\n    Url url = request.getUrl();\r\n    if (matches(url)) {\r\n        \/\/ try to extract page and component information from URL\r\n        PageComponentInfo info = getPageComponentInfo(url);\r\n        \/\/ load the page class\r\n        String className = url.getSegments().get(2);\r\n        Class<? extends IRequestablePage> pageClass = getPageClass(className);\r\n        if (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass)) {\r\n            if (Application.exists()) {\r\n                Application application = Application.get();\r\n                if (application.getSecuritySettings().getEnforceMounts()) {\r\n                    \/\/ we make an excepion if the homepage itself was mounted, see WICKET-1898\r\n                    if (!pageClass.equals(application.getHomePage())) {\r\n                        \/\/ WICKET-5094 only enforce mount if page is mounted\r\n                        Url reverseUrl = application.getRootRequestMapper().mapHandler(new RenderPageRequestHandler(new PageProvider(pageClass)));\r\n                        if (!matches(reverseUrl)) {\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \/\/ extract the PageParameters from URL if there are any\r\n            PageParameters pageParameters = extractPageParameters(request, 3, pageParametersEncoder);\r\n            return new UrlInfo(info, pageClass, pageParameters);\r\n        }\r\n    }\r\n    return null;\r\n}","code_comment":"\/**\r\n *  @see AbstractBookmarkableMapper#parseRequest(org.apache.wicket.request.Request)\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected UrlInfo parseRequest(Request request) {\r\n    Url url = request.getUrl();\r\n    if (matches(url)) {\r\n                PageComponentInfo info = getPageComponentInfo(url);\r\n                String className = url.getSegments().get(2);\r\n        Class<? extends IRequestablePage> pageClass = getPageClass(className);\r\n        if (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass)) {\r\n            if (Application.exists()) {\r\n                Application application = Application.get();\r\n                if (application.getSecuritySettings().getEnforceMounts()) {\r\n                                        if (!pageClass.equals(application.getHomePage())) {\r\n                                                Url reverseUrl = application.getRootRequestMapper().mapHandler(new RenderPageRequestHandler(new PageProvider(pageClass)));\r\n                        if (!matches(reverseUrl)) {\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n                        PageParameters pageParameters = extractPageParameters(request, 3, pageParametersEncoder);\r\n            return new UrlInfo(info, pageClass, pageParameters);\r\n        }\r\n    }\r\n    return null;\r\n}","lc":0.5,"pi":2.4306220096,"ma":0.6,"nbd":2.0,"ml":1.0,"d":0.2837301587,"mi":-0.4260747005,"fo":0.9166666667,"r":-0.0263157895,"e":0.4826633933}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4067_56accddf","label":0,"code":"public static void updateSuggester(Directory directory, Analyzer analyzer, IndexReader reader) throws IOException {\r\n    File tempDir = null;\r\n    try {\r\n        \/\/ Analyzing infix suggester takes a file parameter. It uses its path to getDirectory()\r\n        \/\/ for actual storage of suggester data. BUT, while building it also does getDirectory() to\r\n        \/\/ a temporary location (original path + \".tmp\"). So, instead we create a temp dir and also\r\n        \/\/ create a placeholder non-existing-sub-child which would mark the location when we want to return\r\n        \/\/ our internal suggestion OakDirectory. After build is done, we'd delete the temp directory\r\n        \/\/ thereby removing any temp stuff that suggester created in the interim.\r\n        tempDir = Files.createTempDir();\r\n        File tempSubChild = new File(tempDir, \"non-existing-sub-child\");\r\n        Dictionary dictionary = new LuceneDictionary(reader, FieldNames.SUGGEST);\r\n        getLookup(directory, analyzer, tempSubChild).build(dictionary);\r\n    } catch (RuntimeException e) {\r\n        log.debug(\"could not update the suggester\", e);\r\n    } finally {\r\n        \/\/ cleanup temp dir\r\n        if (tempDir != null && !FileUtils.deleteQuietly(tempDir)) {\r\n            log.error(\"Cleanup failed for temp dir {}\", tempDir.getAbsolutePath());\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public static void updateSuggester(Directory directory, Analyzer analyzer, IndexReader reader) throws IOException {\r\n    File tempDir = null;\r\n    try {\r\n                                                        tempDir = Files.createTempDir();\r\n        File tempSubChild = new File(tempDir, \"non-existing-sub-child\");\r\n        Dictionary dictionary = new LuceneDictionary(reader, FieldNames.SUGGEST);\r\n        getLookup(directory, analyzer, tempSubChild).build(dictionary);\r\n    } catch (RuntimeException e) {\r\n        log.debug(\"could not update the suggester\", e);\r\n    } finally {\r\n                if (tempDir != null && !FileUtils.deleteQuietly(tempDir)) {\r\n            log.error(\"Cleanup failed for temp dir {}\", tempDir.getAbsolutePath());\r\n        }\r\n    }\r\n}","lc":0.0454545455,"pi":0.1100478469,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":0.2123015873,"mi":-0.1078224101,"fo":0.0833333333,"r":-0.0263157895,"e":0.2214830311}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4000_38e928c1","label":1,"code":"@Override\r\npublic void component(final Component component, final IVisit<Void> visit) {\r\n    component.renderHead(headerContainer);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void component(final Component component, final IVisit<Void> visit) {\r\n    component.renderHead(headerContainer);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8173361522,"fo":-0.4166666667,"r":0.3421052632,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"@Override\r\npublic <T> void setProperty(String name, T value) {\r\n    root.checkLive();\r\n    NodeBuilder builder = getNodeBuilder();\r\n    builder.setProperty(name, value);\r\n    root.updated();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic <T> void setProperty(String name, T value) {\r\n    root.checkLive();\r\n    NodeBuilder builder = getNodeBuilder();\r\n    builder.setProperty(name, value);\r\n    root.updated();\r\n}","lc":-0.3181818182,"pi":-0.4832535885,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4474982382,"fo":-0.1666666667,"r":0.3157894737,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-579_7d72e6ed","label":3,"code":"@Override\r\npublic String getPlan(NodeState rootState) {\r\n    return left.getPlan(rootState) + ' ' + joinType + \" \" + right.getPlan(rootState) + \" on \" + joinCondition;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String getPlan(NodeState rootState) {\r\n    return left.getPlan(rootState) + ' ' + joinType + \" \" + right.getPlan(rootState) + \" on \" + joinCondition;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7226215645,"fo":-0.3333333333,"r":1.9473684211,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-812_6eb46555","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic double dotProduct(RealVector v) {\r\n    if (v instanceof OpenMapRealVector) {\r\n        return dotProduct((OpenMapRealVector) v);\r\n    } else {\r\n        return super.dotProduct(v);\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic double dotProduct(RealVector v) {\r\n    if (v instanceof OpenMapRealVector) {\r\n        return dotProduct((OpenMapRealVector) v);\r\n    } else {\r\n        return super.dotProduct(v);\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.5114869626,"fo":-0.3333333333,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"Closure","project_version":"174","label":2,"code":"private void parse(AbstractCompiler compiler) {\r\n    try {\r\n        ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(), compiler.getParserConfig(), compiler.getDefaultErrorReporter(), logger_);\r\n        root = result.ast;\r\n        compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\r\n    } catch (IOException e) {\r\n        compiler.report(JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\r\n    }\r\n    if (root == null || compiler.hasHaltingErrors()) {\r\n        \/\/ Most passes try to report as many errors as possible,\r\n        \/\/ so there may already be errors. We only care if there were\r\n        \/\/ errors in the code we just parsed.\r\n        \/\/ There was a parse error or IOException, so use a dummy block.\r\n        root = IR.script();\r\n    } else {\r\n        compiler.prepareAst(root);\r\n    }\r\n    \/\/ Set the source name so that the compiler passes can track\r\n    \/\/ the source file and module.\r\n    root.setStaticSourceFile(sourceFile);\r\n}","code_comment":null,"code_no_comment":"private void parse(AbstractCompiler compiler) {\r\n    try {\r\n        ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(), compiler.getParserConfig(), compiler.getDefaultErrorReporter(), logger_);\r\n        root = result.ast;\r\n        compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\r\n    } catch (IOException e) {\r\n        compiler.report(JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\r\n    }\r\n    if (root == null || compiler.hasHaltingErrors()) {\r\n                                        root = IR.script();\r\n    } else {\r\n        compiler.prepareAst(root);\r\n    }\r\n            root.setStaticSourceFile(sourceFile);\r\n}","lc":0.0454545455,"pi":-0.1291866029,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0297619048,"mi":-0.0990838619,"fo":0.5833333333,"r":-0.0263157895,"e":0.0475349089}
{"project_name":"Closure","project_version":"106","label":2,"code":"\/**\r\n * Records a block-level description.\r\n *\r\n * @return {@code true} if the description was recorded.\r\n *\/\r\npublic boolean recordBlockDescription(String description) {\r\n    if (parseDocumentation) {\r\n        populated = true;\r\n    }\r\n    return currentInfo.documentBlock(description);\r\n}","code_comment":"\/**\r\n * Records a block-level description.\r\n *\r\n * @return {@code true} if the description was recorded.\r\n *\/\r\n","code_no_comment":"public boolean recordBlockDescription(String description) {\r\n    if (parseDocumentation) {\r\n        populated = true;\r\n    }\r\n    return currentInfo.documentBlock(description);\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.6188865398,"fo":-0.4166666667,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4038_557eec4f","label":1,"code":"\/**\r\n * Checks whether the given dynamic operand is a property\r\n * covered by this index.\r\n *\/\r\nprivate boolean isIndexed(DynamicOperandImpl operand) {\r\n    if (operand instanceof PropertyValueImpl) {\r\n        PropertyValueImpl property = (PropertyValueImpl) operand;\r\n        return properties.contains(property.getPropertyName());\r\n    } else {\r\n        return false;\r\n    }\r\n}","code_comment":"\/**\r\n * Checks whether the given dynamic operand is a property\r\n * covered by this index.\r\n *\/\r\n","code_no_comment":"private boolean isIndexed(DynamicOperandImpl operand) {\r\n    if (operand instanceof PropertyValueImpl) {\r\n        PropertyValueImpl property = (PropertyValueImpl) operand;\r\n        return properties.contains(property.getPropertyName());\r\n    } else {\r\n        return false;\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.4266384778,"fo":-0.3333333333,"r":2.2631578947,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1363_69b68890","label":0,"code":"@Override\r\npublic boolean commit() {\r\n    if (credentials == null || principals == null) {\r\n        \/\/ login attempt in this login module was not successful\r\n        clearState();\r\n        return false;\r\n    } else {\r\n        if (!subject.isReadOnly()) {\r\n            subject.getPrincipals().addAll(principals);\r\n            subject.getPublicCredentials().add(credentials);\r\n            Set<AuthInfo> ais = subject.getPublicCredentials(AuthInfo.class);\r\n            if (ais.isEmpty()) {\r\n                subject.getPublicCredentials().add(createAuthInfo());\r\n            }\r\n        } else {\r\n            log.debug(\"Could not add information to read only subject {}\", subject);\r\n        }\r\n        return true;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean commit() {\r\n    if (credentials == null || principals == null) {\r\n                clearState();\r\n        return false;\r\n    } else {\r\n        if (!subject.isReadOnly()) {\r\n            subject.getPrincipals().addAll(principals);\r\n            subject.getPublicCredentials().add(credentials);\r\n            Set<AuthInfo> ais = subject.getPublicCredentials(AuthInfo.class);\r\n            if (ais.isEmpty()) {\r\n                subject.getPublicCredentials().add(createAuthInfo());\r\n            }\r\n        } else {\r\n            log.debug(\"Could not add information to read only subject {}\", subject);\r\n        }\r\n        return true;\r\n    }\r\n}","lc":0.2272727273,"pi":0.7607655502,"ma":0.0,"nbd":0.5,"ml":0.25,"d":0.255952381,"mi":-0.1658914729,"fo":0.5,"r":0.0,"e":0.1185664148}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2707_3e233a38","label":1,"code":"@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic <S, C extends Serializable> OperatorState<S> getOperatorState(String name, S defaultState, boolean partitioned, StateCheckpointer<S, C> checkpointer) throws IOException {\r\n    if (defaultState == null) {\r\n        throw new RuntimeException(\"Cannot set default state to null.\");\r\n    }\r\n    StreamOperatorState<S, C> state = (StreamOperatorState<S, C>) getState(name, partitioned);\r\n    state.setDefaultState(defaultState);\r\n    state.setCheckpointer(checkpointer);\r\n    return (OperatorState<S>) state;\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic <S, C extends Serializable> OperatorState<S> getOperatorState(String name, S defaultState, boolean partitioned, StateCheckpointer<S, C> checkpointer) throws IOException {\r\n    if (defaultState == null) {\r\n        throw new RuntimeException(\"Cannot set default state to null.\");\r\n    }\r\n    StreamOperatorState<S, C> state = (StreamOperatorState<S, C>) getState(name, partitioned);\r\n    state.setDefaultState(defaultState);\r\n    state.setCheckpointer(checkpointer);\r\n    return (OperatorState<S>) state;\r\n}","lc":-0.1363636364,"pi":-0.2488038278,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0099206349,"mi":0.0782241015,"fo":-0.25,"r":-0.0263157895,"e":0.011924644}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-430_238ce8aa","label":1,"code":"private void appendMessage(final StringBuilder buffer, final LogEvent event) {\r\n    final Message message = event.getMessage();\r\n    final String text = message.getFormat();\r\n    if (text != null && text.length() > 0) {\r\n        buffer.append(\" \").append(escapeNewlines(text, escapeNewLine));\r\n    }\r\n    if (exceptionFormatters != null && event.getThrown() != null) {\r\n        final StringBuilder exception = new StringBuilder(LF);\r\n        for (final PatternFormatter formatter : exceptionFormatters) {\r\n            formatter.format(event, exception);\r\n        }\r\n        buffer.append(escapeNewlines(exception.toString(), escapeNewLine));\r\n    }\r\n    if (includeNewLine) {\r\n        buffer.append(LF);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void appendMessage(final StringBuilder buffer, final LogEvent event) {\r\n    final Message message = event.getMessage();\r\n    final String text = message.getFormat();\r\n    if (text != null && text.length() > 0) {\r\n        buffer.append(\" \").append(escapeNewlines(text, escapeNewLine));\r\n    }\r\n    if (exceptionFormatters != null && event.getThrown() != null) {\r\n        final StringBuilder exception = new StringBuilder(LF);\r\n        for (final PatternFormatter formatter : exceptionFormatters) {\r\n            formatter.format(event, exception);\r\n        }\r\n        buffer.append(escapeNewlines(exception.toString(), escapeNewLine));\r\n    }\r\n    if (includeNewLine) {\r\n        buffer.append(LF);\r\n    }\r\n}","lc":0.1363636364,"pi":0.028708134,"ma":0.2,"nbd":0.0,"ml":0.4166666667,"d":0.371031746,"mi":-0.1870331219,"fo":0.5,"r":-0.0263157895,"e":0.3594935542}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * The contraction criterion defines when the internal array will contract\r\n * to store only the number of elements in the element array.\r\n * If  the <code>expansionMode<\/code> is <code>MULTIPLICATIVE_MODE<\/code>,\r\n * contraction is triggered when the ratio between storage array length\r\n * and <code>numElements<\/code> exceeds <code>contractionFactor<\/code>.\r\n * If the <code>expansionMode<\/code> is <code>ADDITIVE_MODE<\/code>, the\r\n * number of excess storage locations is compared to\r\n * <code>contractionFactor.<\/code>\r\n *\r\n * @return the contraction criterion used to reclaim memory.\r\n * @since 3.1\r\n *\/\r\npublic double getContractionCriterion() {\r\n    return contractionCriterion;\r\n}","code_comment":"\/**\r\n * The contraction criterion defines when the internal array will contract\r\n * to store only the number of elements in the element array.\r\n * If  the <code>expansionMode<\/code> is <code>MULTIPLICATIVE_MODE<\/code>,\r\n * contraction is triggered when the ratio between storage array length\r\n * and <code>numElements<\/code> exceeds <code>contractionFactor<\/code>.\r\n * If the <code>expansionMode<\/code> is <code>ADDITIVE_MODE<\/code>, the\r\n * number of excess storage locations is compared to\r\n * <code>contractionFactor.<\/code>\r\n *\r\n * @return the contraction criterion used to reclaim memory.\r\n * @since 3.1\r\n *\/\r\n","code_no_comment":"public double getContractionCriterion() {\r\n    return contractionCriterion;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.2407329105,"fo":-0.5,"r":0.0,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2506_0f8a2990","label":1,"code":"private void ensureAllChildrenPresent(final MarkupContainer container, final MarkupStream markupStream, ComponentTag enclosureOpenTag) {\r\n    DirectChildTagIterator it = new DirectChildTagIterator(markupStream, enclosureOpenTag);\r\n    while (it.hasNext()) {\r\n        final ComponentTag tag = it.next();\r\n        Component child = container.get(tag.getId());\r\n        if (child == null) {\r\n            \/\/ component does not yet exist in the container, attempt to resolve it using\r\n            \/\/ resolvers\r\n            final int tagIndex = it.getCurrentIndex();\r\n            \/\/ because the resolvers can auto-add and therefore immediately render the component\r\n            \/\/ we have to buffer the output since we do not yet know the visibility of the\r\n            \/\/ enclosure\r\n            CharSequence buffer = new ResponseBufferZone(getRequestCycle(), markupStream) {\r\n\r\n                @Override\r\n                protected void executeInsideBufferedZone() {\r\n                    markupStream.setCurrentIndex(tagIndex);\r\n                    ComponentResolvers.resolve(container, markupStream, tag);\r\n                }\r\n            }.execute();\r\n            child = container.get(tag.getId());\r\n            checkChildComponent(child);\r\n            if (buffer.length() > 0) {\r\n                \/\/ we have already rendered this child component, insert a stub component that\r\n                \/\/ will dump the markup during the normal render process if the enclosure is\r\n                \/\/ visible\r\n                final Component stub = new AutoMarkupLabel(child.getId(), buffer);\r\n                \/\/ ok here because we are replacing auto with auto\r\n                container.replace(stub);\r\n            }\r\n        }\r\n    }\r\n    it.rewind();\r\n}","code_comment":null,"code_no_comment":"private void ensureAllChildrenPresent(final MarkupContainer container, final MarkupStream markupStream, ComponentTag enclosureOpenTag) {\r\n    DirectChildTagIterator it = new DirectChildTagIterator(markupStream, enclosureOpenTag);\r\n    while (it.hasNext()) {\r\n        final ComponentTag tag = it.next();\r\n        Component child = container.get(tag.getId());\r\n        if (child == null) {\r\n                                    final int tagIndex = it.getCurrentIndex();\r\n                                                CharSequence buffer = new ResponseBufferZone(getRequestCycle(), markupStream) {\r\n\r\n                @Override\r\n                protected void executeInsideBufferedZone() {\r\n                    markupStream.setCurrentIndex(tagIndex);\r\n                    ComponentResolvers.resolve(container, markupStream, tag);\r\n                }\r\n            }.execute();\r\n            child = container.get(tag.getId());\r\n            checkChildComponent(child);\r\n            if (buffer.length() > 0) {\r\n                                                                final Component stub = new AutoMarkupLabel(child.getId(), buffer);\r\n                                container.replace(stub);\r\n            }\r\n        }\r\n    }\r\n    it.rewind();\r\n}","lc":0.4545454545,"pi":1.2631578947,"ma":0.0,"nbd":0.5,"ml":0.0833333333,"d":-0.005952381,"mi":-0.3795630726,"fo":0.8333333333,"r":-0.0263157895,"e":0.1748724953}
{"project_name":"Cli","project_version":"12","label":1,"code":"\/**\r\n * <p>This flatten method does so using the following rules:\r\n * <ol>\r\n *  <li>If an {@link Option} exists for the first character of\r\n *  the <code>arguments<\/code> entry <b>AND<\/b> an {@link Option}\r\n *  does not exist for the whole <code>argument<\/code> then\r\n *  add the first character as an option to the processed tokens\r\n *  list e.g. \"-D\" and add the rest of the entry to the also.<\/li>\r\n *  <li>Otherwise just add the token to the processed tokens list.\r\n *  <\/li>\r\n * <\/ol>\r\n * <\/p>\r\n *\r\n * @param options The Options to parse the arguments by.\r\n * @param arguments The arguments that have to be flattened.\r\n * @param stopAtNonOption specifies whether to stop\r\n * flattening when a non option has been encountered\r\n * @return a String array of the flattened arguments\r\n *\/\r\nprotected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {\r\n    List tokens = new ArrayList();\r\n    boolean eatTheRest = false;\r\n    for (int i = 0; i < arguments.length; i++) {\r\n        String arg = arguments[i];\r\n        if (\"--\".equals(arg)) {\r\n            eatTheRest = true;\r\n            tokens.add(\"--\");\r\n        } else if (\"-\".equals(arg)) {\r\n            tokens.add(\"-\");\r\n        } else if (arg.startsWith(\"-\")) {\r\n            String opt = Util.stripLeadingHyphens(arg);\r\n            if (options.hasOption(opt)) {\r\n                tokens.add(arg);\r\n            } else {\r\n                if (options.hasOption(arg.substring(0, 2))) {\r\n                    \/\/ the format is --foo=value or -foo=value\r\n                    \/\/ the format is a special properties option (-Dproperty=value)\r\n                    \/\/ -D\r\n                    tokens.add(arg.substring(0, 2));\r\n                    \/\/ property=value\r\n                    tokens.add(arg.substring(2));\r\n                } else {\r\n                    eatTheRest = stopAtNonOption;\r\n                    tokens.add(arg);\r\n                }\r\n            }\r\n        } else {\r\n            tokens.add(arg);\r\n        }\r\n        if (eatTheRest) {\r\n            for (i++; i < arguments.length; i++) {\r\n                tokens.add(arguments[i]);\r\n            }\r\n        }\r\n    }\r\n    return (String[]) tokens.toArray(new String[tokens.size()]);\r\n}","code_comment":"\/**\r\n * <p>This flatten method does so using the following rules:\r\n * <ol>\r\n *  <li>If an {@link Option} exists for the first character of\r\n *  the <code>arguments<\/code> entry <b>AND<\/b> an {@link Option}\r\n *  does not exist for the whole <code>argument<\/code> then\r\n *  add the first character as an option to the processed tokens\r\n *  list e.g. \"-D\" and add the rest of the entry to the also.<\/li>\r\n *  <li>Otherwise just add the token to the processed tokens list.\r\n *  <\/li>\r\n * <\/ol>\r\n * <\/p>\r\n *\r\n * @param options The Options to parse the arguments by.\r\n * @param arguments The arguments that have to be flattened.\r\n * @param stopAtNonOption specifies whether to stop\r\n * flattening when a non option has been encountered\r\n * @return a String array of the flattened arguments\r\n *\/\r\n","code_no_comment":"protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) {\r\n    List tokens = new ArrayList();\r\n    boolean eatTheRest = false;\r\n    for (int i = 0; i < arguments.length; i++) {\r\n        String arg = arguments[i];\r\n        if (\"--\".equals(arg)) {\r\n            eatTheRest = true;\r\n            tokens.add(\"--\");\r\n        } else if (\"-\".equals(arg)) {\r\n            tokens.add(\"-\");\r\n        } else if (arg.startsWith(\"-\")) {\r\n            String opt = Util.stripLeadingHyphens(arg);\r\n            if (options.hasOption(opt)) {\r\n                tokens.add(arg);\r\n            } else {\r\n                if (options.hasOption(arg.substring(0, 2))) {\r\n                                                                                tokens.add(arg.substring(0, 2));\r\n                                        tokens.add(arg.substring(2));\r\n                } else {\r\n                    eatTheRest = stopAtNonOption;\r\n                    tokens.add(arg);\r\n                }\r\n            }\r\n        } else {\r\n            tokens.add(arg);\r\n        }\r\n        if (eatTheRest) {\r\n            for (i++; i < arguments.length; i++) {\r\n                tokens.add(arguments[i]);\r\n            }\r\n        }\r\n    }\r\n    return (String[]) tokens.toArray(new String[tokens.size()]);\r\n}","lc":0.9090909091,"pi":1.1818181818,"ma":1.0,"nbd":2.0,"ml":1.1666666667,"d":0.244047619,"mi":-0.6090204369,"fo":1.0833333333,"r":-0.0263157895,"e":0.5789318995}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5085_581c7306","label":1,"code":"@Override\r\npublic Component resolve(final MarkupContainer container, final MarkupStream markupStream, final ComponentTag tag) {\r\n    String inlineEnclosureChildId = getAttribute(tag, markupStream);\r\n    if (Strings.isEmpty(inlineEnclosureChildId) == false) {\r\n        String id = tag.getId();\r\n        if (id.startsWith(getWicketNamespace(markupStream))) {\r\n            id = id + container.getPage().getAutoIndex();\r\n        }\r\n        \/\/ Yes, we handled the tag\r\n        return new InlineEnclosure(id, inlineEnclosureChildId);\r\n    }\r\n    \/\/ We were not able to handle the tag\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Component resolve(final MarkupContainer container, final MarkupStream markupStream, final ComponentTag tag) {\r\n    String inlineEnclosureChildId = getAttribute(tag, markupStream);\r\n    if (Strings.isEmpty(inlineEnclosureChildId) == false) {\r\n        String id = tag.getId();\r\n        if (id.startsWith(getWicketNamespace(markupStream))) {\r\n            id = id + container.getPage().getAutoIndex();\r\n        }\r\n                return new InlineEnclosure(id, inlineEnclosureChildId);\r\n    }\r\n        return null;\r\n}","lc":-0.0909090909,"pi":0.3397129187,"ma":-0.2,"nbd":0.0,"ml":0.1666666667,"d":-0.0674603175,"mi":0.0505990134,"fo":0.0833333333,"r":0.1842105263,"e":-0.027973237}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4766_cda34428","label":1,"code":"\/**\r\n *  Renders the content of the &lt;head&gt; section of the page, including &lt;wicket:head&gt;\r\n *  sections in subclasses of the page. For every child-component, the content is rendered to a\r\n *  string and passed to {@link IHeaderResponse}.\r\n *\r\n *  @param headerStreamState\r\n *\/\r\npublic void renderHeaderTagBody(HeaderStreamState headerStreamState) {\r\n    if (headerStreamState == null)\r\n        return;\r\n    final Response oldResponse = getRequestCycle().getResponse();\r\n    try {\r\n        \/\/ Create a separate (string) response for the header container itself\r\n        final StringResponse bodyResponse = new StringResponse();\r\n        getRequestCycle().setResponse(bodyResponse);\r\n        \/\/ render the header section directly associated with the markup\r\n        super.onComponentTagBody(headerStreamState.getMarkupStream(), headerStreamState.getOpenTag());\r\n        CharSequence bodyOutput = getCleanResponse(bodyResponse);\r\n        if (bodyOutput.length() > 0) {\r\n            getHeaderResponse().render(StringHeaderItem.forString(bodyOutput));\r\n        }\r\n    } finally {\r\n        getRequestCycle().setResponse(oldResponse);\r\n    }\r\n}","code_comment":"\/**\r\n *  Renders the content of the &lt;head&gt; section of the page, including &lt;wicket:head&gt;\r\n *  sections in subclasses of the page. For every child-component, the content is rendered to a\r\n *  string and passed to {@link IHeaderResponse}.\r\n *\r\n *  @param headerStreamState\r\n *\/\r\n","code_no_comment":"public void renderHeaderTagBody(HeaderStreamState headerStreamState) {\r\n    if (headerStreamState == null)\r\n        return;\r\n    final Response oldResponse = getRequestCycle().getResponse();\r\n    try {\r\n                final StringResponse bodyResponse = new StringResponse();\r\n        getRequestCycle().setResponse(bodyResponse);\r\n                super.onComponentTagBody(headerStreamState.getMarkupStream(), headerStreamState.getOpenTag());\r\n        CharSequence bodyOutput = getCleanResponse(bodyResponse);\r\n        if (bodyOutput.length() > 0) {\r\n            getHeaderResponse().render(StringHeaderItem.forString(bodyOutput));\r\n        }\r\n    } finally {\r\n        getRequestCycle().setResponse(oldResponse);\r\n    }\r\n}","lc":0.0909090909,"pi":0.0813397129,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0674603175,"mi":-0.0807610994,"fo":0.6666666667,"r":-0.0263157895,"e":-0.027973237}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3989_6a8fc1cc","label":1,"code":"\/**\r\n *  Empty: nothing will be added to the header by default\r\n *\/\r\npublic void renderHead(final Component component, HtmlHeaderContainer container) {\r\n}","code_comment":"\/**\r\n *  Empty: nothing will be added to the header by default\r\n *\/\r\n","code_no_comment":"public void renderHead(final Component component, HtmlHeaderContainer container) {\r\n}","lc":-0.5454545455,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.2528541226,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2430_be3a9114","label":1,"code":"@Override\r\npublic boolean childNodeChanged(String name, NodeState before, NodeState after) {\r\n    if (!loader.isRunning()) {\r\n        return false;\r\n    }\r\n    return after.compareAgainstBaseState(before, new StandbyApplyDiff(builder.getChildNode(name), store, loader, path + name + \"\/\"));\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean childNodeChanged(String name, NodeState before, NodeState after) {\r\n    if (!loader.isRunning()) {\r\n        return false;\r\n    }\r\n    return after.compareAgainstBaseState(before, new StandbyApplyDiff(builder.getChildNode(name), store, loader, path + name + \"\/\"));\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.1011904762,"mi":0.3837914024,"fo":-0.25,"r":-0.0263157895,"e":-0.0937166831}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-926_e1ae968c","label":1,"code":"\/**\r\n * Returns previous revision ranges for this document. The revision keys are\r\n * sorted descending, newest first!\r\n *\r\n * @return the previous ranges for this document.\r\n *\/\r\n@Nonnull\r\nSortedMap<Revision, Range> getPreviousRanges() {\r\n    @SuppressWarnings(\"unchecked\")\r\n    SortedMap<Revision, Range> previous = (SortedMap<Revision, Range>) get(PREVIOUS);\r\n    if (previous == null) {\r\n        previous = EMPTY_RANGE_MAP;\r\n    }\r\n    return previous;\r\n}","code_comment":"\/**\r\n * Returns previous revision ranges for this document. The revision keys are\r\n * sorted descending, newest first!\r\n *\r\n * @return the previous ranges for this document.\r\n *\/\r\n","code_no_comment":"@Nonnull\r\nSortedMap<Revision, Range> getPreviousRanges() {\r\n    @SuppressWarnings(\"unchecked\")\r\n    SortedMap<Revision, Range> previous = (SortedMap<Revision, Range>) get(PREVIOUS);\r\n    if (previous == null) {\r\n        previous = EMPTY_RANGE_MAP;\r\n    }\r\n    return previous;\r\n}","lc":-0.2272727273,"pi":-0.2296650718,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0297619048,"mi":0.289640592,"fo":-0.4166666667,"r":0.6315789474,"e":-0.0865890977}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5898_ffdd0864","label":1,"code":"\/**\r\n *  If the child has not been directly added to the container, but via a\r\n *  TransparentWebMarkupContainer, then we are in trouble. In general Wicket iterates over the\r\n *  markup elements and searches for associated components, not the other way around. Because of\r\n *  TransparentWebMarkupContainer (or more generally resolvers), there is no \"synchronous\" search\r\n *  possible.\r\n *\r\n *  @param container\r\n *             the parent container.\r\n *  @param child\r\n *             The component to find the markup for.\r\n *  @return the markup fragment for the child, or {@code null}.\r\n *\/\r\nprotected IMarkupFragment searchMarkupInTransparentResolvers(final MarkupContainer container, final Component child) {\r\n    return container.visitChildren(MarkupContainer.class, new IVisitor<MarkupContainer, IMarkupFragment>() {\r\n\r\n        @Override\r\n        public void component(MarkupContainer resolvingContainer, IVisit<IMarkupFragment> visit) {\r\n            \/\/ prevents possible searching loops\r\n            if (child == resolvingContainer) {\r\n                visit.dontGoDeeper();\r\n                return;\r\n            }\r\n            if (resolvingContainer instanceof IComponentResolver) {\r\n                visit.dontGoDeeper();\r\n                IMarkupFragment childMarkup = resolvingContainer.getMarkup(child);\r\n                if (childMarkup != null && childMarkup.size() > 0) {\r\n                    IComponentResolver componentResolver = (IComponentResolver) resolvingContainer;\r\n                    MarkupStream stream = new MarkupStream(childMarkup);\r\n                    ComponentTag tag = stream.getTag();\r\n                    Component resolvedComponent = resolvingContainer.get(tag.getId());\r\n                    if (resolvedComponent == null) {\r\n                        resolvedComponent = componentResolver.resolve(resolvingContainer, stream, tag);\r\n                    }\r\n                    if (child == resolvedComponent) {\r\n                        visit.stop(childMarkup);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n}","code_comment":"\/**\r\n *  If the child has not been directly added to the container, but via a\r\n *  TransparentWebMarkupContainer, then we are in trouble. In general Wicket iterates over the\r\n *  markup elements and searches for associated components, not the other way around. Because of\r\n *  TransparentWebMarkupContainer (or more generally resolvers), there is no \"synchronous\" search\r\n *  possible.\r\n *\r\n *  @param container\r\n *             the parent container.\r\n *  @param child\r\n *             The component to find the markup for.\r\n *  @return the markup fragment for the child, or {@code null}.\r\n *\/\r\n","code_no_comment":"protected IMarkupFragment searchMarkupInTransparentResolvers(final MarkupContainer container, final Component child) {\r\n    return container.visitChildren(MarkupContainer.class, new IVisitor<MarkupContainer, IMarkupFragment>() {\r\n\r\n        @Override\r\n        public void component(MarkupContainer resolvingContainer, IVisit<IMarkupFragment> visit) {\r\n                        if (child == resolvingContainer) {\r\n                visit.dontGoDeeper();\r\n                return;\r\n            }\r\n            if (resolvingContainer instanceof IComponentResolver) {\r\n                visit.dontGoDeeper();\r\n                IMarkupFragment childMarkup = resolvingContainer.getMarkup(child);\r\n                if (childMarkup != null && childMarkup.size() > 0) {\r\n                    IComponentResolver componentResolver = (IComponentResolver) resolvingContainer;\r\n                    MarkupStream stream = new MarkupStream(childMarkup);\r\n                    ComponentTag tag = stream.getTag();\r\n                    Component resolvedComponent = resolvingContainer.get(tag.getId());\r\n                    if (resolvedComponent == null) {\r\n                        resolvedComponent = componentResolver.resolve(resolvingContainer, stream, tag);\r\n                    }\r\n                    if (child == resolvedComponent) {\r\n                        visit.stop(childMarkup);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n}","lc":0.5909090909,"pi":1.7942583732,"ma":0.4,"nbd":1.0,"ml":0.5,"d":0.4900793651,"mi":-0.452572234,"fo":0.3333333333,"r":-0.0263157895,"e":0.6761639667}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5571_0e87b84f","label":1,"code":"protected Object invokeWithbody(final Method method, Object body, final ExchangePattern pattern) throws InterruptedException, Throwable {\r\n    final Exchange exchange = new DefaultExchange(endpoint, pattern);\r\n    exchange.getIn().setBody(body);\r\n    \/\/ is the return type a future\r\n    final boolean isFuture = method.getReturnType() == Future.class;\r\n    \/\/ create task to execute the proxy and gather the reply\r\n    FutureTask<Object> task = new FutureTask<Object>(new Callable<Object>() {\r\n\r\n        public Object call() throws Exception {\r\n            \/\/ process the exchange\r\n            LOG.trace(\"Proxied method call {} invoking producer: {}\", method.getName(), producer);\r\n            producer.process(exchange);\r\n            Object answer = afterInvoke(method, exchange, pattern, isFuture);\r\n            LOG.trace(\"Proxied method call {} returning: {}\", method.getName(), answer);\r\n            return answer;\r\n        }\r\n    });\r\n    if (isFuture) {\r\n        \/\/ submit task and return future\r\n        if (LOG.isTraceEnabled()) {\r\n            LOG.trace(\"Submitting task for exchange id {}\", exchange.getExchangeId());\r\n        }\r\n        getExecutorService(exchange.getContext()).submit(task);\r\n        return task;\r\n    } else {\r\n        \/\/ execute task now\r\n        try {\r\n            task.run();\r\n            return task.get();\r\n        } catch (ExecutionException e) {\r\n            \/\/ we don't want the wrapped exception from JDK\r\n            throw e.getCause();\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"protected Object invokeWithbody(final Method method, Object body, final ExchangePattern pattern) throws InterruptedException, Throwable {\r\n    final Exchange exchange = new DefaultExchange(endpoint, pattern);\r\n    exchange.getIn().setBody(body);\r\n        final boolean isFuture = method.getReturnType() == Future.class;\r\n        FutureTask<Object> task = new FutureTask<Object>(new Callable<Object>() {\r\n\r\n        public Object call() throws Exception {\r\n                        LOG.trace(\"Proxied method call {} invoking producer: {}\", method.getName(), producer);\r\n            producer.process(exchange);\r\n            Object answer = afterInvoke(method, exchange, pattern, isFuture);\r\n            LOG.trace(\"Proxied method call {} returning: {}\", method.getName(), answer);\r\n            return answer;\r\n        }\r\n    });\r\n    if (isFuture) {\r\n                if (LOG.isTraceEnabled()) {\r\n            LOG.trace(\"Submitting task for exchange id {}\", exchange.getExchangeId());\r\n        }\r\n        getExecutorService(exchange.getContext()).submit(task);\r\n        return task;\r\n    } else {\r\n                try {\r\n            task.run();\r\n            return task.get();\r\n        } catch (ExecutionException e) {\r\n                        throw e.getCause();\r\n        }\r\n    }\r\n}","lc":0.6363636364,"pi":0.3684210526,"ma":0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0079365079,"mi":-0.4765327696,"fo":1.0,"r":-0.0263157895,"e":0.2212709554}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-434_133cbc2d","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic int hashCode() {\r\n    return Boolean.valueOf(restrictToNonNegative).hashCode() ^ numDecisionVariables ^ numSlackVariables ^ numArtificialVariables ^ Double.valueOf(epsilon).hashCode() ^ f.hashCode() ^ constraints.hashCode() ^ tableau.hashCode();\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic int hashCode() {\r\n    return Boolean.valueOf(restrictToNonNegative).hashCode() ^ numDecisionVariables ^ numSlackVariables ^ numArtificialVariables ^ Double.valueOf(epsilon).hashCode() ^ f.hashCode() ^ constraints.hashCode() ^ tableau.hashCode();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6918957012,"fo":0.0833333333,"r":1.7368421053,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5898_ffdd0864","label":1,"code":"@Override\r\npublic void component(MarkupContainer resolvingContainer, IVisit<IMarkupFragment> visit) {\r\n    \/\/ prevents possible searching loops\r\n    if (child == resolvingContainer) {\r\n        visit.dontGoDeeper();\r\n        return;\r\n    }\r\n    if (resolvingContainer instanceof IComponentResolver) {\r\n        visit.dontGoDeeper();\r\n        IMarkupFragment childMarkup = resolvingContainer.getMarkup(child);\r\n        if (childMarkup != null && childMarkup.size() > 0) {\r\n            IComponentResolver componentResolver = (IComponentResolver) resolvingContainer;\r\n            MarkupStream stream = new MarkupStream(childMarkup);\r\n            ComponentTag tag = stream.getTag();\r\n            Component resolvedComponent = resolvingContainer.get(tag.getId());\r\n            if (resolvedComponent == null) {\r\n                resolvedComponent = componentResolver.resolve(resolvingContainer, stream, tag);\r\n            }\r\n            if (child == resolvedComponent) {\r\n                visit.stop(childMarkup);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void component(MarkupContainer resolvingContainer, IVisit<IMarkupFragment> visit) {\r\n        if (child == resolvingContainer) {\r\n        visit.dontGoDeeper();\r\n        return;\r\n    }\r\n    if (resolvingContainer instanceof IComponentResolver) {\r\n        visit.dontGoDeeper();\r\n        IMarkupFragment childMarkup = resolvingContainer.getMarkup(child);\r\n        if (childMarkup != null && childMarkup.size() > 0) {\r\n            IComponentResolver componentResolver = (IComponentResolver) resolvingContainer;\r\n            MarkupStream stream = new MarkupStream(childMarkup);\r\n            ComponentTag tag = stream.getTag();\r\n            Component resolvedComponent = resolvingContainer.get(tag.getId());\r\n            if (resolvedComponent == null) {\r\n                resolvedComponent = componentResolver.resolve(resolvingContainer, stream, tag);\r\n            }\r\n            if (child == resolvedComponent) {\r\n                visit.stop(childMarkup);\r\n            }\r\n        }\r\n    }\r\n}","lc":0.4090909091,"pi":0.8229665072,"ma":0.4,"nbd":0.5,"ml":0.5,"d":0.4424603175,"mi":-0.3510923185,"fo":0.25,"r":-0.0263157895,"e":0.4905424641}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4138_eb0f9b41","label":1,"code":"@Override\r\npublic Options getOptions() {\r\n    final Options o = new Options();\r\n    forceOpt = new Option(\"f\", \"force\", false, \"delete data even if start or end are not specified\");\r\n    startRowOptExclusive = new Option(OptUtil.START_ROW_OPT, \"begin-row\", true, \"begin row (exclusive)\");\r\n    startRowOptExclusive.setArgName(\"begin-row\");\r\n    o.addOption(startRowOptExclusive);\r\n    o.addOption(OptUtil.endRowOpt());\r\n    o.addOption(OptUtil.tableOpt(\"table to delete a row range from\"));\r\n    o.addOption(forceOpt);\r\n    return o;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Options getOptions() {\r\n    final Options o = new Options();\r\n    forceOpt = new Option(\"f\", \"force\", false, \"delete data even if start or end are not specified\");\r\n    startRowOptExclusive = new Option(OptUtil.START_ROW_OPT, \"begin-row\", true, \"begin row (exclusive)\");\r\n    startRowOptExclusive.setArgName(\"begin-row\");\r\n    o.addOption(startRowOptExclusive);\r\n    o.addOption(OptUtil.endRowOpt());\r\n    o.addOption(OptUtil.tableOpt(\"table to delete a row range from\"));\r\n    o.addOption(forceOpt);\r\n    return o;\r\n}","lc":-0.0909090909,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.067230444,"fo":0.0833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6447_020c451a","label":1,"code":"public void done(boolean doneSync) {\r\n    \/\/ we only have to handle async completion of the pipeline\r\n    if (doneSync) {\r\n        return;\r\n    }\r\n    \/\/ continue processing the pipeline asynchronously\r\n    while (continueRouting(processors, exchange)) {\r\n        AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());\r\n        \/\/ check for error if so we should break out\r\n        if (!continueProcessing(exchange, \"so breaking out of pipeline\", LOG)) {\r\n            break;\r\n        }\r\n        doneSync = process(exchange, callback, processors, processor);\r\n        if (!doneSync) {\r\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\r\n            return;\r\n        }\r\n    }\r\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n    callback.done(false);\r\n}","code_comment":null,"code_no_comment":"public void done(boolean doneSync) {\r\n        if (doneSync) {\r\n        return;\r\n    }\r\n        while (continueRouting(processors, exchange)) {\r\n        AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());\r\n                if (!continueProcessing(exchange, \"so breaking out of pipeline\", LOG)) {\r\n            break;\r\n        }\r\n        doneSync = process(exchange, callback, processors, processor);\r\n        if (!doneSync) {\r\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\r\n            return;\r\n        }\r\n    }\r\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n    callback.done(false);\r\n}","lc":0.1818181818,"pi":0.2727272727,"ma":0.4,"nbd":0.0,"ml":0.3333333333,"d":-0.005952381,"mi":-0.1503875969,"fo":0.3333333333,"r":-0.0263157895,"e":-0.0042945316}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-891_2b852d79","label":1,"code":"\/**\r\n * Computes the Spearman's rank correlation coefficient between the two arrays.\r\n *\r\n * @param xArray first data array\r\n * @param yArray second data array\r\n * @return Returns Spearman's rank correlation coefficient for the two arrays\r\n * @throws DimensionMismatchException if the arrays lengths do not match\r\n * @throws MathIllegalArgumentException if the array length is less than 2\r\n *\/\r\npublic double correlation(final double[] xArray, final double[] yArray) {\r\n    if (xArray.length != yArray.length) {\r\n        throw new DimensionMismatchException(xArray.length, yArray.length);\r\n    } else if (xArray.length < 2) {\r\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION, xArray.length, 2);\r\n    } else {\r\n        return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(xArray), rankingAlgorithm.rank(yArray));\r\n    }\r\n}","code_comment":"\/**\r\n * Computes the Spearman's rank correlation coefficient between the two arrays.\r\n *\r\n * @param xArray first data array\r\n * @param yArray second data array\r\n * @return Returns Spearman's rank correlation coefficient for the two arrays\r\n * @throws DimensionMismatchException if the arrays lengths do not match\r\n * @throws MathIllegalArgumentException if the array length is less than 2\r\n *\/\r\n","code_no_comment":"public double correlation(final double[] xArray, final double[] yArray) {\r\n    if (xArray.length != yArray.length) {\r\n        throw new DimensionMismatchException(xArray.length, yArray.length);\r\n    } else if (xArray.length < 2) {\r\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION, xArray.length, 2);\r\n    } else {\r\n        return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(xArray), rankingAlgorithm.rank(yArray));\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":0.2,"nbd":0.0,"ml":-0.0833333333,"d":0.0932539683,"mi":0.2341085271,"fo":-0.25,"r":0.0789473684,"e":-0.0297804902}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3428_ffc0cae9","label":1,"code":"\/**\r\n *  Processes the request.\r\n *\r\n *  @return <code>true<\/code> if the request resolved to a Wicket request, <code>false<\/code>\r\n *          otherwise.\r\n *\/\r\npublic boolean processRequest() {\r\n    try {\r\n        set(this);\r\n        IRequestHandler handler = resolveRequestHandler();\r\n        if (handler != null) {\r\n            executeRequestHandler(handler);\r\n            return true;\r\n        }\r\n        \/\/ Did not find any suitable handler, thus not executing the request\r\n        log.debug(\"No suitable handler found for URL {}, falling back to container to process this request\", request.getUrl());\r\n    } catch (Exception e) {\r\n        IRequestHandler handler = handleException(e);\r\n        if (handler != null) {\r\n            executeExceptionRequestHandler(handler, getExceptionRetryCount());\r\n        } else {\r\n            log.error(\"Error during request processing. URL=\" + request.getUrl(), e);\r\n        }\r\n        return true;\r\n    } finally {\r\n        set(null);\r\n    }\r\n    return false;\r\n}","code_comment":"\/**\r\n *  Processes the request.\r\n *\r\n *  @return <code>true<\/code> if the request resolved to a Wicket request, <code>false<\/code>\r\n *          otherwise.\r\n *\/\r\n","code_no_comment":"public boolean processRequest() {\r\n    try {\r\n        set(this);\r\n        IRequestHandler handler = resolveRequestHandler();\r\n        if (handler != null) {\r\n            executeRequestHandler(handler);\r\n            return true;\r\n        }\r\n                log.debug(\"No suitable handler found for URL {}, falling back to container to process this request\", request.getUrl());\r\n    } catch (Exception e) {\r\n        IRequestHandler handler = handleException(e);\r\n        if (handler != null) {\r\n            executeExceptionRequestHandler(handler, getExceptionRetryCount());\r\n        } else {\r\n            log.error(\"Error during request processing. URL=\" + request.getUrl(), e);\r\n        }\r\n        return true;\r\n    } finally {\r\n        set(null);\r\n    }\r\n    return false;\r\n}","lc":0.3636363636,"pi":0.1961722488,"ma":0.0,"nbd":0.0,"ml":-0.1666666667,"d":-0.0317460317,"mi":-0.2329809725,"fo":0.4166666667,"r":-0.0263157895,"e":-0.0115604271}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1822_3e83a4c1","label":1,"code":"\/**\r\n * Remove a map entry.\r\n * The property is a map of revisions \/ values.\r\n *\r\n * @param property the property\r\n * @param revision the revision\r\n *\/\r\npublic void removeMapEntry(@Nonnull String property, @Nonnull Revision revision) {\r\n    Operation op = new Operation();\r\n    op.type = Operation.Type.REMOVE_MAP_ENTRY;\r\n    changes.put(new Key(property, checkNotNull(revision)), op);\r\n}","code_comment":"\/**\r\n * Remove a map entry.\r\n * The property is a map of revisions \/ values.\r\n *\r\n * @param property the property\r\n * @param revision the revision\r\n *\/\r\n","code_no_comment":"public void removeMapEntry(@Nonnull String property, @Nonnull Revision revision) {\r\n    Operation op = new Operation();\r\n    op.type = Operation.Type.REMOVE_MAP_ENTRY;\r\n    changes.put(new Key(property, checkNotNull(revision)), op);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5579985906,"fo":-0.3333333333,"r":2.2894736842,"e":-0.1627934049}
{"project_name":"Closure","project_version":"9","label":2,"code":"\/**\r\n * Emit goog.provide and add suffix to all global vars to avoid conflicts\r\n * with other modules.\r\n *\/\r\nprivate void visitScript(NodeTraversal t, Node script) {\r\n    Preconditions.checkArgument(scriptNodeCount == 1, \"ProcessCommonJSModules supports only one invocation per \" + \"CompilerInput \/ script node\");\r\n    String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\r\n    script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit()).copyInformationFromForTree(script));\r\n    if (reportDependencies) {\r\n        CompilerInput ci = t.getInput();\r\n        ci.addProvide(moduleName);\r\n        JSModule m = new JSModule(moduleName);\r\n        m.addAndOverrideModule(ci);\r\n        module = m;\r\n    }\r\n    script.addChildToFront(IR.exprResult(IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")), IR.string(moduleName))).copyInformationFromForTree(script));\r\n    emitOptionalModuleExportsOverride(script, moduleName);\r\n    \/\/ Rename vars to not conflict in global scope.\r\n    NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(moduleName));\r\n    compiler.reportCodeChange();\r\n}","code_comment":"\/**\r\n * Emit goog.provide and add suffix to all global vars to avoid conflicts\r\n * with other modules.\r\n *\/\r\n","code_no_comment":"private void visitScript(NodeTraversal t, Node script) {\r\n    Preconditions.checkArgument(scriptNodeCount == 1, \"ProcessCommonJSModules supports only one invocation per \" + \"CompilerInput \/ script node\");\r\n    String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\r\n    script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit()).copyInformationFromForTree(script));\r\n    if (reportDependencies) {\r\n        CompilerInput ci = t.getInput();\r\n        ci.addProvide(moduleName);\r\n        JSModule m = new JSModule(moduleName);\r\n        m.addAndOverrideModule(ci);\r\n        module = m;\r\n    }\r\n    script.addChildToFront(IR.exprResult(IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")), IR.string(moduleName))).copyInformationFromForTree(script));\r\n    emitOptionalModuleExportsOverride(script, moduleName);\r\n        NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(moduleName));\r\n    compiler.reportCodeChange();\r\n}","lc":0.0909090909,"pi":-0.2153110048,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0138888889,"mi":-0.1980267794,"fo":1.4166666667,"r":-0.0263157895,"e":0.2062781303}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1877_716e1237","label":0,"code":"private static void preAsyncRun(NodeStore store, String name) throws CommitFailedException {\r\n    NodeBuilder builder = store.getRoot().builder();\r\n    preAsyncRunNodeStatus(builder, name);\r\n    store.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\r\n}","code_comment":null,"code_no_comment":"private static void preAsyncRun(NodeStore store, String name) throws CommitFailedException {\r\n    NodeBuilder builder = store.getRoot().builder();\r\n    preAsyncRunNodeStatus(builder, name);\r\n    store.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5701198027,"fo":-0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3324_5f863af6","label":1,"code":"@Nonnull\r\n@Override\r\npublic RepositoryPermission getRepositoryPermission() {\r\n    return new RepositoryPermission() {\r\n\r\n        @Override\r\n        public boolean isGranted(long repositoryPermissions) {\r\n            return hasPermissions(getEntryIterator(new EntryPredicate()), repositoryPermissions, null);\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\n@Override\r\npublic RepositoryPermission getRepositoryPermission() {\r\n    return new RepositoryPermission() {\r\n\r\n        @Override\r\n        public boolean isGranted(long repositoryPermissions) {\r\n            return hasPermissions(getEntryIterator(new EntryPredicate()), repositoryPermissions, null);\r\n        }\r\n    };\r\n}","lc":-0.1818181818,"pi":0.5693779904,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.3508104299,"fo":-0.3333333333,"r":0.6842105263,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-4358_74cbba24","label":1,"code":"@Override\r\nprotected Revision computeNext() {\r\n    while (unfiltered.hasNext()) {\r\n        Revision next = unfiltered.next();\r\n        if (min.isRevisionNewer(next)) {\r\n            return next;\r\n        } else {\r\n            \/\/ further revisions with this clusterId\r\n            \/\/ are older than min revision\r\n            clusterIds.remove(next.getClusterId());\r\n            \/\/ no more revisions to check\r\n            if (clusterIds.isEmpty()) {\r\n                return endOfData();\r\n            }\r\n        }\r\n    }\r\n    return endOfData();\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected Revision computeNext() {\r\n    while (unfiltered.hasNext()) {\r\n        Revision next = unfiltered.next();\r\n        if (min.isRevisionNewer(next)) {\r\n            return next;\r\n        } else {\r\n                                    clusterIds.remove(next.getClusterId());\r\n                        if (clusterIds.isEmpty()) {\r\n                return endOfData();\r\n            }\r\n        }\r\n    }\r\n    return endOfData();\r\n}","lc":0.0454545455,"pi":0.9090909091,"ma":0.0,"nbd":0.5,"ml":0.1666666667,"d":-0.3650793651,"mi":0.0556730092,"fo":0.1666666667,"r":0.5,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"\/**\r\n * query the strategy for the provided constrains\r\n *\r\n * @param filter\r\n * @param propertyName\r\n * @param pr\r\n * @return the result set\r\n *\/\r\npublic Iterable<String> query(Filter filter, String propertyName, PropertyRestriction pr) {\r\n    NodeState indexMeta = getIndexNode(root, propertyName, filter);\r\n    if (indexMeta == null) {\r\n        throw new IllegalArgumentException(\"No index for \" + propertyName);\r\n    }\r\n    return getStrategy(indexMeta).query(filter, propertyName, indexMeta, pr);\r\n}","code_comment":"\/**\r\n * query the strategy for the provided constrains\r\n *\r\n * @param filter\r\n * @param propertyName\r\n * @param pr\r\n * @return the result set\r\n *\/\r\n","code_no_comment":"public Iterable<String> query(Filter filter, String propertyName, PropertyRestriction pr) {\r\n    NodeState indexMeta = getIndexNode(root, propertyName, filter);\r\n    if (indexMeta == null) {\r\n        throw new IllegalArgumentException(\"No index for \" + propertyName);\r\n    }\r\n    return getStrategy(indexMeta).query(filter, propertyName, indexMeta, pr);\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0376984127,"mi":0.3516560958,"fo":-0.25,"r":1.1315789474,"e":-0.0610570357}
{"project_name":"Cli","project_version":"24","label":1,"code":"\/**\r\n * Render the specified text and return the rendered Options\r\n * in a StringBuffer.\r\n *\r\n * @param sb The StringBuffer to place the rendered text into.\r\n * @param width The number of characters to display per line\r\n * @param nextLineTabStop The position on the next line for the first tab.\r\n * @param text The text to be rendered.\r\n *\r\n * @return the StringBuffer with the rendered Options contents.\r\n *\/\r\nprotected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\r\n    int pos = findWrapPos(text, width, 0);\r\n    if (pos == -1) {\r\n        sb.append(rtrim(text));\r\n        return sb;\r\n    }\r\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\r\n    if (nextLineTabStop >= width) {\r\n        \/\/ stops infinite loop happening\r\n        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\");\r\n    }\r\n    \/\/ all following lines must be padded with nextLineTabStop space\r\n    \/\/ characters\r\n    final String padding = createPadding(nextLineTabStop);\r\n    while (true) {\r\n        text = padding + text.substring(pos).trim();\r\n        pos = findWrapPos(text, width, 0);\r\n        if (pos == -1) {\r\n            sb.append(text);\r\n            return sb;\r\n        }\r\n        if ((text.length() > width) && (pos == nextLineTabStop - 1)) {\r\n            pos = width;\r\n        }\r\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\r\n    }\r\n}","code_comment":"\/**\r\n * Render the specified text and return the rendered Options\r\n * in a StringBuffer.\r\n *\r\n * @param sb The StringBuffer to place the rendered text into.\r\n * @param width The number of characters to display per line\r\n * @param nextLineTabStop The position on the next line for the first tab.\r\n * @param text The text to be rendered.\r\n *\r\n * @return the StringBuffer with the rendered Options contents.\r\n *\/\r\n","code_no_comment":"protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) {\r\n    int pos = findWrapPos(text, width, 0);\r\n    if (pos == -1) {\r\n        sb.append(rtrim(text));\r\n        return sb;\r\n    }\r\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\r\n    if (nextLineTabStop >= width) {\r\n                throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\");\r\n    }\r\n            final String padding = createPadding(nextLineTabStop);\r\n    while (true) {\r\n        text = padding + text.substring(pos).trim();\r\n        pos = findWrapPos(text, width, 0);\r\n        if (pos == -1) {\r\n            sb.append(text);\r\n            return sb;\r\n        }\r\n        if ((text.length() > width) && (pos == nextLineTabStop - 1)) {\r\n            pos = width;\r\n        }\r\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\r\n    }\r\n}","lc":0.4545454545,"pi":0.1244019139,"ma":0.6,"nbd":0.0,"ml":0.4166666667,"d":1.4702380952,"mi":-0.4131078224,"fo":0.9166666667,"r":-0.0263157895,"e":1.7386813275}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1235_1beb2a50","label":1,"code":"private void copyNodeTypes(NodeBuilder root) throws RepositoryException {\r\n    NodeTypeRegistry sourceRegistry = source.getNodeTypeRegistry();\r\n    NodeBuilder system = root.child(JCR_SYSTEM);\r\n    NodeBuilder types = system.child(JCR_NODE_TYPES);\r\n    logger.info(\"Copying registered node types\");\r\n    for (Name name : sourceRegistry.getRegisteredNodeTypes()) {\r\n        QNodeTypeDefinition def = sourceRegistry.getNodeTypeDef(name);\r\n        NodeBuilder type = types.child(getOakName(name));\r\n        copyNodeType(def, type);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void copyNodeTypes(NodeBuilder root) throws RepositoryException {\r\n    NodeTypeRegistry sourceRegistry = source.getNodeTypeRegistry();\r\n    NodeBuilder system = root.child(JCR_SYSTEM);\r\n    NodeBuilder types = system.child(JCR_NODE_TYPES);\r\n    logger.info(\"Copying registered node types\");\r\n    for (Name name : sourceRegistry.getRegisteredNodeTypes()) {\r\n        QNodeTypeDefinition def = sourceRegistry.getNodeTypeDef(name);\r\n        NodeBuilder type = types.child(getOakName(name));\r\n        copyNodeType(def, type);\r\n    }\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.0830162086,"fo":0.25,"r":0.0526315789,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1093_7cfbc0da","label":1,"code":"\/**\r\n * Create a split part.\r\n * @param tree BSP tree containing the limit angles of the split part\r\n * @return split part (may be null)\r\n *\/\r\nprivate ArcsSet createSplitPart(final BSPTree<Sphere1D> tree) {\r\n    if (tree.getCut() == null && !(Boolean) tree.getAttribute()) {\r\n        return null;\r\n    } else {\r\n        return new ArcsSet(tree, getTolerance());\r\n    }\r\n}","code_comment":"\/**\r\n * Create a split part.\r\n * @param tree BSP tree containing the limit angles of the split part\r\n * @return split part (may be null)\r\n *\/\r\n","code_no_comment":"private ArcsSet createSplitPart(final BSPTree<Sphere1D> tree) {\r\n    if (tree.getCut() == null && !(Boolean) tree.getAttribute()) {\r\n        return null;\r\n    } else {\r\n        return new ArcsSet(tree, getTolerance());\r\n    }\r\n}","lc":-0.3181818182,"pi":0.014354067,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0773809524,"mi":0.4483439042,"fo":-0.25,"r":1.7894736842,"e":-0.1142834091}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  Adds a message\r\n *  @param reporter\r\n *  @param message\r\n *  @param level\r\n *\/\r\npublic final void add(Component reporter, String message, int level) {\r\n    add(new FeedbackMessage(reporter, message, level));\r\n}","code_comment":"\/**\r\n *  Adds a message\r\n *  @param reporter\r\n *  @param message\r\n *  @param level\r\n *\/\r\n","code_no_comment":"public final void add(Component reporter, String message, int level) {\r\n    add(new FeedbackMessage(reporter, message, level));\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9441860465,"fo":-0.4166666667,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-519_26a61077","label":1,"code":"\/**\r\n * Determines whether a value is between two other values.\r\n *\r\n * @param value value to determine whether is between <code>boundary1<\/code>\r\n *        and <code>boundary2<\/code>\r\n * @param boundary1 one end of the range\r\n * @param boundary2 other end of the range\r\n *\r\n * @return true if <code>value<\/code> is between <code>boundary1<\/code> and\r\n *         <code>boundary2<\/code> (inclusive); false otherwise\r\n *\/\r\nprivate boolean isBetween(double value, double boundary1, double boundary2) {\r\n    return (value >= boundary1 && value <= boundary2) || (value >= boundary2 && value <= boundary1);\r\n}","code_comment":"\/**\r\n * Determines whether a value is between two other values.\r\n *\r\n * @param value value to determine whether is between <code>boundary1<\/code>\r\n *        and <code>boundary2<\/code>\r\n * @param boundary1 one end of the range\r\n * @param boundary2 other end of the range\r\n *\r\n * @return true if <code>value<\/code> is between <code>boundary1<\/code> and\r\n *         <code>boundary2<\/code> (inclusive); false otherwise\r\n *\/\r\n","code_no_comment":"private boolean isBetween(double value, double boundary1, double boundary2) {\r\n    return (value >= boundary1 && value <= boundary2) || (value >= boundary2 && value <= boundary1);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":0.6666666667,"mi":0.8613107822,"fo":-0.5,"r":0.7894736842,"e":-0.0108043314}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-373_bfe4623c","label":1,"code":"\/**\r\n * Returns the sum of the squares of the entries in the specified portion of\r\n * the input array, or <code>Double.NaN<\/code> if the designated subarray\r\n * is empty.\r\n * <p>\r\n * Throws <code>IllegalArgumentException<\/code> if the array is null.<\/p>\r\n *\r\n * @param values the input array\r\n * @param begin index of the first array element to include\r\n * @param length the number of elements to include\r\n * @return the sum of the squares of the values or Double.NaN if length = 0\r\n * @throws IllegalArgumentException if the array is null or the array index\r\n *  parameters are not valid\r\n *\/\r\n@Override\r\npublic double evaluate(final double[] values, final int begin, final int length) {\r\n    double sumSq = Double.NaN;\r\n    if (test(values, begin, length)) {\r\n        sumSq = 0.0;\r\n        for (int i = begin; i < begin + length; i++) {\r\n            sumSq += values[i] * values[i];\r\n        }\r\n    }\r\n    return sumSq;\r\n}","code_comment":"\/**\r\n * Returns the sum of the squares of the entries in the specified portion of\r\n * the input array, or <code>Double.NaN<\/code> if the designated subarray\r\n * is empty.\r\n * <p>\r\n * Throws <code>IllegalArgumentException<\/code> if the array is null.<\/p>\r\n *\r\n * @param values the input array\r\n * @param begin index of the first array element to include\r\n * @param length the number of elements to include\r\n * @return the sum of the squares of the values or Double.NaN if length = 0\r\n * @throws IllegalArgumentException if the array is null or the array index\r\n *  parameters are not valid\r\n *\/\r\n","code_no_comment":"@Override\r\npublic double evaluate(final double[] values, final int begin, final int length) {\r\n    double sumSq = Double.NaN;\r\n    if (test(values, begin, length)) {\r\n        sumSq = 0.0;\r\n        for (int i = begin; i < begin + length; i++) {\r\n            sumSq += values[i] * values[i];\r\n        }\r\n    }\r\n    return sumSq;\r\n}","lc":-0.1363636364,"pi":0.3588516746,"ma":-0.2,"nbd":0.0,"ml":0.1666666667,"d":0.9742063492,"mi":0.1326286117,"fo":-0.4166666667,"r":-0.0263157895,"e":0.2913896141}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-320_c06cc933","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic RealMatrix getCovariance(final double minSingularValue) {\r\n    \/\/ get the number of singular values to consider\r\n    int dimension = 0;\r\n    while ((dimension < n) && (singularValues[dimension] >= minSingularValue)) {\r\n        ++dimension;\r\n    }\r\n    if (dimension == 0) {\r\n        throw MathRuntimeException.createIllegalArgumentException(\"cutoff singular value is {0}, should be at most {1}\", minSingularValue, singularValues[0]);\r\n    }\r\n    final double[][] data = new double[dimension][n];\r\n    getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\r\n\r\n        \/**\r\n         * {@inheritDoc}\r\n         *\/\r\n        @Override\r\n        public void visit(final int row, final int column, final double value) {\r\n            data[row][column] = value \/ singularValues[row];\r\n        }\r\n    }, 0, dimension - 1, 0, n - 1);\r\n    RealMatrix jv = new Array2DRowRealMatrix(data, false);\r\n    return jv.transpose().multiply(jv);\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public RealMatrix getCovariance(final double minSingularValue) {\r\n        int dimension = 0;\r\n    while ((dimension < n) && (singularValues[dimension] >= minSingularValue)) {\r\n        ++dimension;\r\n    }\r\n    if (dimension == 0) {\r\n        throw MathRuntimeException.createIllegalArgumentException(\"cutoff singular value is {0}, should be at most {1}\", minSingularValue, singularValues[0]);\r\n    }\r\n    final double[][] data = new double[dimension][n];\r\n    getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\r\n\r\n        \/**\r\n         * {@inheritDoc}\r\n         *\/\r\n        @Override\r\n        public void visit(final int row, final int column, final double value) {\r\n            data[row][column] = value \/ singularValues[row];\r\n        }\r\n    }, 0, dimension - 1, 0, n - 1);\r\n    RealMatrix jv = new Array2DRowRealMatrix(data, false);\r\n    return jv.transpose().multiply(jv);\r\n}","lc":0.3181818182,"pi":-0.004784689,"ma":0.0,"nbd":-0.5,"ml":0.0833333333,"d":1.2222222222,"mi":-0.2868217054,"fo":-0.0833333333,"r":0.0789473684,"e":1.0380986959}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3281_f7dd2fff","label":1,"code":"\/**\r\n * Adds a route for an interceptor that intercepts incoming messages on the given endpoint.\r\n *\r\n * @param uri  endpoint uri\r\n * @return the builder\r\n *\/\r\npublic InterceptFromDefinition interceptFrom(String uri) {\r\n    routeCollection.setCamelContext(getContext());\r\n    return routeCollection.interceptFrom(uri);\r\n}","code_comment":"\/**\r\n * Adds a route for an interceptor that intercepts incoming messages on the given endpoint.\r\n *\r\n * @param uri  endpoint uri\r\n * @return the builder\r\n *\/\r\n","code_no_comment":"public InterceptFromDefinition interceptFrom(String uri) {\r\n    routeCollection.setCamelContext(getContext());\r\n    return routeCollection.interceptFrom(uri);\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8255109232,"fo":-0.25,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5883_cd3b9234","label":3,"code":"\/**\r\n *  Find out whether there is any registered error for a form component.\r\n *\r\n *  @return whether there is any registered error for a form component\r\n *\/\r\nprivate boolean anyFormComponentError() {\r\n    \/\/ Check ALL children for error messages irrespective of FormComponents or not\r\n    Boolean error = visitChildren(Component.class, new IVisitor<Component, Boolean>() {\r\n\r\n        @Override\r\n        public void component(final Component component, final IVisit<Boolean> visit) {\r\n            if (component.hasErrorMessage()) {\r\n                visit.stop(true);\r\n            }\r\n        }\r\n    });\r\n    return (error != null) && error;\r\n}","code_comment":"\/**\r\n *  Find out whether there is any registered error for a form component.\r\n *\r\n *  @return whether there is any registered error for a form component\r\n *\/\r\n","code_no_comment":"private boolean anyFormComponentError() {\r\n        Boolean error = visitChildren(Component.class, new IVisitor<Component, Boolean>() {\r\n\r\n        @Override\r\n        public void component(final Component component, final IVisit<Boolean> visit) {\r\n            if (component.hasErrorMessage()) {\r\n                visit.stop(true);\r\n            }\r\n        }\r\n    });\r\n    return (error != null) && error;\r\n}","lc":-0.1363636364,"pi":0.8899521531,"ma":-0.4,"nbd":0.0,"ml":-0.25,"d":-0.0476190476,"mi":0.177167019,"fo":-0.25,"r":0.2631578947,"e":-0.079742743}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-278_db19e70f","label":1,"code":"@Override\r\npublic boolean remove() {\r\n    if (isRemoved()) {\r\n        throw new IllegalStateException(\"Cannot remove removed tree\");\r\n    }\r\n    if (!isRoot() && parent.hasChild(name)) {\r\n        NodeBuilder builder = parent.getNodeBuilder();\r\n        builder.removeNode(name);\r\n        parent.children.remove(name);\r\n        parent = this;\r\n        root.purge();\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean remove() {\r\n    if (isRemoved()) {\r\n        throw new IllegalStateException(\"Cannot remove removed tree\");\r\n    }\r\n    if (!isRoot() && parent.hasChild(name)) {\r\n        NodeBuilder builder = parent.getNodeBuilder();\r\n        builder.removeNode(name);\r\n        parent.children.remove(name);\r\n        parent = this;\r\n        root.purge();\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}","lc":0.0909090909,"pi":0.038277512,"ma":0.0,"nbd":-0.5,"ml":0.1666666667,"d":-0.0932539683,"mi":-0.0322762509,"fo":0.0833333333,"r":0.2368421053,"e":-0.0783919135}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7275_44cad623","label":1,"code":"public boolean process(Exchange exchange, AsyncCallback callback) {\r\n    Iterator<Processor> processors = next().iterator();\r\n    Object lastHandled = exchange.getProperty(Exchange.EXCEPTION_HANDLED);\r\n    exchange.setProperty(Exchange.EXCEPTION_HANDLED, null);\r\n    while (continueRouting(processors, exchange)) {\r\n        ExchangeHelper.prepareOutToIn(exchange);\r\n        \/\/ process the next processor\r\n        Processor processor = processors.next();\r\n        AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\r\n        boolean sync = process(exchange, callback, processors, async, lastHandled);\r\n        \/\/ continue as long its being processed synchronously\r\n        if (!sync) {\r\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\r\n            \/\/ so we break out now, then the callback will be invoked which then continue routing from where we left here\r\n            return false;\r\n        }\r\n        LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\r\n    }\r\n    ExchangeHelper.prepareOutToIn(exchange);\r\n    exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled);\r\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n    callback.done(true);\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"public boolean process(Exchange exchange, AsyncCallback callback) {\r\n    Iterator<Processor> processors = next().iterator();\r\n    Object lastHandled = exchange.getProperty(Exchange.EXCEPTION_HANDLED);\r\n    exchange.setProperty(Exchange.EXCEPTION_HANDLED, null);\r\n    while (continueRouting(processors, exchange)) {\r\n        ExchangeHelper.prepareOutToIn(exchange);\r\n                Processor processor = processors.next();\r\n        AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\r\n        boolean sync = process(exchange, callback, processors, async, lastHandled);\r\n                if (!sync) {\r\n            LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\r\n                        return false;\r\n        }\r\n        LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\r\n    }\r\n    ExchangeHelper.prepareOutToIn(exchange);\r\n    exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled);\r\n    LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n    callback.done(true);\r\n    return true;\r\n}","lc":0.3181818182,"pi":0.0813397129,"ma":-0.2,"nbd":0.0,"ml":0.0833333333,"d":0.0535714286,"mi":-0.3164200141,"fo":1.0,"r":-0.0263157895,"e":0.2434420797}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1779_9d36bede","label":0,"code":"private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision, long oldestRevTimeStamp) {\r\n    List<String> docIdsToDelete = new ArrayList<String>();\r\n    Iterable<NodeDocument> itr = versionStore.getPossiblyDeletedDocs(oldestRevTimeStamp);\r\n    try {\r\n        for (NodeDocument doc : itr) {\r\n            \/\/ So deleting it is safe\r\n            if (doc.getNodeAtRevision(nodeStore, headRevision, null) == null) {\r\n                docIdsToDelete.add(doc.getId());\r\n                \/\/ Collect id of all previous docs also\r\n                for (NodeDocument prevDoc : ImmutableList.copyOf(doc.getAllPreviousDocs())) {\r\n                    docIdsToDelete.add(prevDoc.getId());\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        Utils.closeIfCloseable(itr);\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        StringBuilder sb = new StringBuilder(\"Deleted document with following ids were deleted as part of GC \\n\");\r\n        Joiner.on(StandardSystemProperty.LINE_SEPARATOR.value()).appendTo(sb, docIdsToDelete);\r\n        log.debug(sb.toString());\r\n    }\r\n    nodeStore.getDocumentStore().remove(Collection.NODES, docIdsToDelete);\r\n    stats.deletedDocGCCount += docIdsToDelete.size();\r\n}","code_comment":null,"code_no_comment":"private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision, long oldestRevTimeStamp) {\r\n    List<String> docIdsToDelete = new ArrayList<String>();\r\n    Iterable<NodeDocument> itr = versionStore.getPossiblyDeletedDocs(oldestRevTimeStamp);\r\n    try {\r\n        for (NodeDocument doc : itr) {\r\n                        if (doc.getNodeAtRevision(nodeStore, headRevision, null) == null) {\r\n                docIdsToDelete.add(doc.getId());\r\n                                for (NodeDocument prevDoc : ImmutableList.copyOf(doc.getAllPreviousDocs())) {\r\n                    docIdsToDelete.add(prevDoc.getId());\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        Utils.closeIfCloseable(itr);\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        StringBuilder sb = new StringBuilder(\"Deleted document with following ids were deleted as part of GC \\n\");\r\n        Joiner.on(StandardSystemProperty.LINE_SEPARATOR.value()).appendTo(sb, docIdsToDelete);\r\n        log.debug(sb.toString());\r\n    }\r\n    nodeStore.getDocumentStore().remove(Collection.NODES, docIdsToDelete);\r\n    stats.deletedDocGCCount += docIdsToDelete.size();\r\n}","lc":0.4090909091,"pi":1.0861244019,"ma":0.2,"nbd":1.0,"ml":0.0833333333,"d":-0.0615079365,"mi":-0.3770260747,"fo":1.0,"r":-0.0263157895,"e":0.1441307492}
{"project_name":"JxPath","project_version":"1","label":1,"code":"public static boolean testNode(NodePointer pointer, Object node, NodeTest test) {\r\n    if (test == null) {\r\n        return true;\r\n    } else if (test instanceof NodeNameTest) {\r\n        if (!(node instanceof Element)) {\r\n            return false;\r\n        }\r\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\r\n        QName testName = nodeNameTest.getNodeName();\r\n        String namespaceURI = nodeNameTest.getNamespaceURI();\r\n        boolean wildcard = nodeNameTest.isWildcard();\r\n        String testPrefix = testName.getPrefix();\r\n        if (wildcard && testPrefix == null) {\r\n            return true;\r\n        }\r\n        if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) {\r\n            String nodeNS = JDOMNodePointer.getNamespaceURI(node);\r\n            return equalStrings(namespaceURI, nodeNS);\r\n        }\r\n    } else if (test instanceof NodeTypeTest) {\r\n        switch(((NodeTypeTest) test).getNodeType()) {\r\n            case Compiler.NODE_TYPE_NODE:\r\n                return node instanceof Element;\r\n            case Compiler.NODE_TYPE_TEXT:\r\n                return (node instanceof Text) || (node instanceof CDATA);\r\n            case Compiler.NODE_TYPE_COMMENT:\r\n                return node instanceof Comment;\r\n            case Compiler.NODE_TYPE_PI:\r\n                return node instanceof ProcessingInstruction;\r\n        }\r\n        return false;\r\n    } else if (test instanceof ProcessingInstructionTest) {\r\n        if (node instanceof ProcessingInstruction) {\r\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\r\n            String nodePI = ((ProcessingInstruction) node).getTarget();\r\n            return testPI.equals(nodePI);\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"public static boolean testNode(NodePointer pointer, Object node, NodeTest test) {\r\n    if (test == null) {\r\n        return true;\r\n    } else if (test instanceof NodeNameTest) {\r\n        if (!(node instanceof Element)) {\r\n            return false;\r\n        }\r\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\r\n        QName testName = nodeNameTest.getNodeName();\r\n        String namespaceURI = nodeNameTest.getNamespaceURI();\r\n        boolean wildcard = nodeNameTest.isWildcard();\r\n        String testPrefix = testName.getPrefix();\r\n        if (wildcard && testPrefix == null) {\r\n            return true;\r\n        }\r\n        if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) {\r\n            String nodeNS = JDOMNodePointer.getNamespaceURI(node);\r\n            return equalStrings(namespaceURI, nodeNS);\r\n        }\r\n    } else if (test instanceof NodeTypeTest) {\r\n        switch(((NodeTypeTest) test).getNodeType()) {\r\n            case Compiler.NODE_TYPE_NODE:\r\n                return node instanceof Element;\r\n            case Compiler.NODE_TYPE_TEXT:\r\n                return (node instanceof Text) || (node instanceof CDATA);\r\n            case Compiler.NODE_TYPE_COMMENT:\r\n                return node instanceof Comment;\r\n            case Compiler.NODE_TYPE_PI:\r\n                return node instanceof ProcessingInstruction;\r\n        }\r\n        return false;\r\n    } else if (test instanceof ProcessingInstructionTest) {\r\n        if (node instanceof ProcessingInstruction) {\r\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\r\n            String nodePI = ((ProcessingInstruction) node).getTarget();\r\n            return testPI.equals(nodePI);\r\n        }\r\n    }\r\n    return false;\r\n}","lc":1.1818181818,"pi":0.4593301435,"ma":1.8,"nbd":1.5,"ml":1.3333333333,"d":0.4821428571,"mi":-0.7338971106,"fo":0.5833333333,"r":-0.0263157895,"e":1.0584164635}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-859_66dece12","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic boolean isSupportUpperBoundInclusive() {\r\n    return false;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public boolean isSupportUpperBoundInclusive() {\r\n    return false;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.2407329105,"fo":-0.5,"r":2.5,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1136_cc4ab51e","label":3,"code":"\/**\r\n * {@inheritDoc} *\r\n *\/\r\n@Override\r\npublic double logProbability(int x) {\r\n    double ret;\r\n    if (x < 0 || x > numberOfTrials) {\r\n        ret = Double.NEGATIVE_INFINITY;\r\n    } else {\r\n        ret = SaddlePointExpansion.logBinomialProbability(x, numberOfTrials, probabilityOfSuccess, 1.0 - probabilityOfSuccess);\r\n    }\r\n    return ret;\r\n}","code_comment":"\/**\r\n * {@inheritDoc} *\r\n *\/\r\n","code_no_comment":"@Override\r\npublic double logProbability(int x) {\r\n    double ret;\r\n    if (x < 0 || x > numberOfTrials) {\r\n        ret = Double.NEGATIVE_INFINITY;\r\n    } else {\r\n        ret = SaddlePointExpansion.logBinomialProbability(x, numberOfTrials, probabilityOfSuccess, 1.0 - probabilityOfSuccess);\r\n    }\r\n    return ret;\r\n}","lc":-0.1818181818,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":0.2757936508,"mi":0.2205778717,"fo":-0.4166666667,"r":1.1578947368,"e":0.0049077068}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1364_b481a14c","label":1,"code":"synchronized void clear() {\r\n    \/\/ calculate the size of the map array\r\n    \/\/ assume a fill factor of at most 80%\r\n    long maxLen = (long) (maxMemory \/ averageMemory \/ 0.75);\r\n    \/\/ the size needs to be a power of 2\r\n    long l = 8;\r\n    while (l < maxLen) {\r\n        l += l;\r\n    }\r\n    \/\/ the array size is at most 2^31 elements\r\n    int len = (int) Math.min(1L << 31, l);\r\n    \/\/ the bit mask has all bits set\r\n    mask = len - 1;\r\n    \/\/ initialize the stack and queue heads\r\n    stack = new Entry<K, V>();\r\n    stack.stackPrev = stack.stackNext = stack;\r\n    queue = new Entry<K, V>();\r\n    queue.queuePrev = queue.queueNext = queue;\r\n    queue2 = new Entry<K, V>();\r\n    queue2.queuePrev = queue2.queueNext = queue2;\r\n    \/\/ first set to null - avoiding out of memory\r\n    entries = null;\r\n    @SuppressWarnings(\"unchecked\")\r\n    Entry<K, V>[] e = new Entry[len];\r\n    entries = e;\r\n    mapSize = 0;\r\n    usedMemory = 0;\r\n    stackSize = queueSize = queue2Size = 0;\r\n}","code_comment":null,"code_no_comment":"synchronized void clear() {\r\n            long maxLen = (long) (maxMemory \/ averageMemory \/ 0.75);\r\n        long l = 8;\r\n    while (l < maxLen) {\r\n        l += l;\r\n    }\r\n        int len = (int) Math.min(1L << 31, l);\r\n        mask = len - 1;\r\n        stack = new Entry<K, V>();\r\n    stack.stackPrev = stack.stackNext = stack;\r\n    queue = new Entry<K, V>();\r\n    queue.queuePrev = queue.queueNext = queue;\r\n    queue2 = new Entry<K, V>();\r\n    queue2.queuePrev = queue2.queueNext = queue2;\r\n        entries = null;\r\n    @SuppressWarnings(\"unchecked\")\r\n    Entry<K, V>[] e = new Entry[len];\r\n    entries = e;\r\n    mapSize = 0;\r\n    usedMemory = 0;\r\n    stackSize = queueSize = queue2Size = 0;\r\n}","lc":0.3636363636,"pi":-0.7272727273,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":0.7599206349,"mi":-0.3598308668,"fo":-0.4166666667,"r":0.0,"e":1.1614391176}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-559_fc409e88","label":3,"code":"\/**\r\n * Returns true if both arguments are equal or within the range of allowed\r\n * error (inclusive).\r\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\r\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\r\n * point numbers are considered equal.\r\n * Adapted from <a\r\n * href=\"http:\/\/www.cygnus-software.com\/papers\/comparingfloats\/comparingfloats.htm\">\r\n * Bruce Dawson<\/a>\r\n *\r\n * @param x first value\r\n * @param y second value\r\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\r\n * values between {@code x} and {@code y}.\r\n * @return {@code true} if there are fewer than {@code maxUlps} floating\r\n * point values between {@code x} and {@code y}.\r\n * @since 2.2\r\n *\/\r\npublic static boolean equals(float x, float y, int maxUlps) {\r\n    \/\/ NaN won't compare as equal to anything (except another NaN).\r\n    assert maxUlps > 0 && maxUlps < NAN_GAP;\r\n    int xInt = Float.floatToIntBits(x);\r\n    int yInt = Float.floatToIntBits(y);\r\n    \/\/ Make lexicographically ordered as a two's-complement integer.\r\n    if (xInt < 0) {\r\n        xInt = SGN_MASK_FLOAT - xInt;\r\n    }\r\n    if (yInt < 0) {\r\n        yInt = SGN_MASK_FLOAT - yInt;\r\n    }\r\n    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\r\n    return isEqual && !Float.isNaN(x) && !Float.isNaN(y);\r\n}","code_comment":"\/**\r\n * Returns true if both arguments are equal or within the range of allowed\r\n * error (inclusive).\r\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\r\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\r\n * point numbers are considered equal.\r\n * Adapted from <a\r\n * href=\"http:\/\/www.cygnus-software.com\/papers\/comparingfloats\/comparingfloats.htm\">\r\n * Bruce Dawson<\/a>\r\n *\r\n * @param x first value\r\n * @param y second value\r\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\r\n * values between {@code x} and {@code y}.\r\n * @return {@code true} if there are fewer than {@code maxUlps} floating\r\n * point values between {@code x} and {@code y}.\r\n * @since 2.2\r\n *\/\r\n","code_no_comment":"public static boolean equals(float x, float y, int maxUlps) {\r\n        assert maxUlps > 0 && maxUlps < NAN_GAP;\r\n    int xInt = Float.floatToIntBits(x);\r\n    int yInt = Float.floatToIntBits(y);\r\n        if (xInt < 0) {\r\n        xInt = SGN_MASK_FLOAT - xInt;\r\n    }\r\n    if (yInt < 0) {\r\n        yInt = SGN_MASK_FLOAT - yInt;\r\n    }\r\n    final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\r\n    return isEqual && !Float.isNaN(x) && !Float.isNaN(y);\r\n}","lc":-0.0454545455,"pi":-0.3684210526,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.4274841438,"fo":-0.0833333333,"r":0.1842105263,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3931_8fbdc68f","label":1,"code":"\/**\r\n *  Detaches the component. This is called at the end of the request for all the pages that are\r\n *  touched in that request.\r\n *\/\r\npublic final void detach() {\r\n    \/\/ if the component has been previously attached via attach()\r\n    \/\/ detach it now\r\n    setFlag(FLAG_DETACHING, true);\r\n    onDetach();\r\n    if (getFlag(FLAG_DETACHING)) {\r\n        throw new IllegalStateException(Component.class.getName() + \" has not been properly detached. Something in the hierarchy of \" + getClass().getName() + \" has not called super.onDetach() in the override of onDetach() method\");\r\n    }\r\n    \/\/ always detach models because they can be attached without the\r\n    \/\/ component. eg component has a compoundpropertymodel and one of its\r\n    \/\/ children component's getmodelobject is called\r\n    detachModels();\r\n    \/\/ detach any behaviors\r\n    new Behaviors(this).detach();\r\n    \/\/ always detach children because components can be attached\r\n    \/\/ independently of their parents\r\n    detachChildren();\r\n    \/\/ The model will be created next time.\r\n    if (getFlag(FLAG_INHERITABLE_MODEL)) {\r\n        setModelImpl(null);\r\n        setFlag(FLAG_INHERITABLE_MODEL, false);\r\n    }\r\n    clearEnabledInHierarchyCache();\r\n    clearVisibleInHierarchyCache();\r\n    requestFlags = 0;\r\n    \/\/ notify any detach listener\r\n    IDetachListener detachListener = getApplication().getFrameworkSettings().getDetachListener();\r\n    if (detachListener != null) {\r\n        detachListener.onDetach(this);\r\n    }\r\n}","code_comment":"\/**\r\n *  Detaches the component. This is called at the end of the request for all the pages that are\r\n *  touched in that request.\r\n *\/\r\n","code_no_comment":"public final void detach() {\r\n            setFlag(FLAG_DETACHING, true);\r\n    onDetach();\r\n    if (getFlag(FLAG_DETACHING)) {\r\n        throw new IllegalStateException(Component.class.getName() + \" has not been properly detached. Something in the hierarchy of \" + getClass().getName() + \" has not called super.onDetach() in the override of onDetach() method\");\r\n    }\r\n                detachModels();\r\n        new Behaviors(this).detach();\r\n            detachChildren();\r\n        if (getFlag(FLAG_INHERITABLE_MODEL)) {\r\n        setModelImpl(null);\r\n        setFlag(FLAG_INHERITABLE_MODEL, false);\r\n    }\r\n    clearEnabledInHierarchyCache();\r\n    clearVisibleInHierarchyCache();\r\n    requestFlags = 0;\r\n        IDetachListener detachListener = getApplication().getFrameworkSettings().getDetachListener();\r\n    if (detachListener != null) {\r\n        detachListener.onDetach(this);\r\n    }\r\n}","lc":0.3181818182,"pi":-0.4258373206,"ma":0.2,"nbd":-0.5,"ml":0.0833333333,"d":-0.0992063492,"mi":-0.2324171952,"fo":1.0,"r":-0.0263157895,"e":-0.0294900388}
{"project_name":"Compress","project_version":"34","label":1,"code":"\/**\r\n * Length of the extra field in the central directory data - without\r\n * Header-ID or length specifier.\r\n *\r\n * @return a <code>ZipShort<\/code> for the length of the data of this extra field\r\n *\/\r\npublic ZipShort getCentralDirectoryLength() {\r\n    return getLocalFileDataLength();\r\n}","code_comment":"\/**\r\n * Length of the extra field in the central directory data - without\r\n * Header-ID or length specifier.\r\n *\r\n * @return a <code>ZipShort<\/code> for the length of the data of this extra field\r\n *\/\r\n","code_no_comment":"public ZipShort getCentralDirectoryLength() {\r\n    return getLocalFileDataLength();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1646229739,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  Removes any rendered feedback messages as well as compacts memory. This\r\n *  method is usually called at the end of the request cycle processing.\r\n *\/\r\nfinal void cleanupFeedbackMessages() {\r\n    int size = feedbackMessages.size();\r\n    feedbackMessages.clearRendered();\r\n    \/\/ the session is dirty when the list of feedback messages was changed\r\n    if (size != feedbackMessages.size()) {\r\n        dirty();\r\n    }\r\n}","code_comment":"\/**\r\n *  Removes any rendered feedback messages as well as compacts memory. This\r\n *  method is usually called at the end of the request cycle processing.\r\n *\/\r\n","code_no_comment":"final void cleanupFeedbackMessages() {\r\n    int size = feedbackMessages.size();\r\n    feedbackMessages.clearRendered();\r\n        if (size != feedbackMessages.size()) {\r\n        dirty();\r\n    }\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.001984127,"mi":0.5391120507,"fo":-0.1666666667,"r":2.1315789474,"e":-0.1298294751}
{"project_name":"Math","project_version":"78","label":1,"code":"\/**\r\n * Evaluate the impact of the proposed step on the event handler.\r\n * @param interpolator step interpolator for the proposed step\r\n * @return true if the event handler triggers an event before\r\n * the end of the proposed step (this implies the step should be\r\n * rejected)\r\n * @exception DerivativeException if the interpolator fails to\r\n * compute the switching function somewhere within the step\r\n * @exception EventException if the switching function\r\n * cannot be evaluated\r\n * @exception ConvergenceException if an event cannot be located\r\n *\/\r\npublic boolean evaluateStep(final StepInterpolator interpolator) throws DerivativeException, EventException, ConvergenceException {\r\n    try {\r\n        forward = interpolator.isForward();\r\n        final double t1 = interpolator.getCurrentTime();\r\n        final int n = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) \/ maxCheckInterval));\r\n        final double h = (t1 - t0) \/ n;\r\n        double ta = t0;\r\n        double ga = g0;\r\n        double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\r\n        for (int i = 0; i < n; ++i) {\r\n            \/\/ evaluate handler value at the end of the substep\r\n            tb += h;\r\n            interpolator.setInterpolatedTime(tb);\r\n            final double gb = handler.g(tb, interpolator.getInterpolatedState());\r\n            \/\/ check events occurrence\r\n            if (g0Positive ^ (gb >= 0)) {\r\n                \/\/ there is a sign change: an event is expected during this step\r\n                \/\/ this is a corner case:\r\n                \/\/ - there was an event near ta,\r\n                \/\/ - there is another event between ta and tb\r\n                \/\/ - when ta was computed, convergence was reached on the \"wrong side\" of the interval\r\n                \/\/ this implies that the real sign of ga is the same as gb, so we need to slightly\r\n                \/\/ shift ta to make sure ga and gb get opposite signs and the solver won't complain\r\n                \/\/ about bracketing\r\n                \/\/ this should never happen\r\n                \/\/ variation direction, with respect to the integration direction\r\n                increasing = gb >= ga;\r\n                final UnivariateRealFunction f = new UnivariateRealFunction() {\r\n\r\n                    public double value(final double t) throws FunctionEvaluationException {\r\n                        try {\r\n                            interpolator.setInterpolatedTime(t);\r\n                            return handler.g(t, interpolator.getInterpolatedState());\r\n                        } catch (DerivativeException e) {\r\n                            throw new FunctionEvaluationException(e, t);\r\n                        } catch (EventException e) {\r\n                            throw new FunctionEvaluationException(e, t);\r\n                        }\r\n                    }\r\n                };\r\n                final BrentSolver solver = new BrentSolver();\r\n                solver.setAbsoluteAccuracy(convergence);\r\n                solver.setMaximalIterationCount(maxIterationCount);\r\n                final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\r\n                if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\r\n                    \/\/ we have either found nothing or found (again ?) a past event, we simply ignore it\r\n                    ta = tb;\r\n                    ga = gb;\r\n                } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\r\n                    pendingEventTime = root;\r\n                    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\r\n                        \/\/ properly ends exactly at the event occurrence\r\n                        return false;\r\n                    }\r\n                    \/\/ either we were not waiting for the event or it has\r\n                    \/\/ moved in such a way the step cannot be accepted\r\n                    pendingEvent = true;\r\n                    return true;\r\n                }\r\n            } else {\r\n                \/\/ no sign change: there is no event for now\r\n                ta = tb;\r\n                ga = gb;\r\n            }\r\n        }\r\n        \/\/ no event during the whole step\r\n        pendingEvent = false;\r\n        pendingEventTime = Double.NaN;\r\n        return false;\r\n    } catch (FunctionEvaluationException e) {\r\n        final Throwable cause = e.getCause();\r\n        if ((cause != null) && (cause instanceof DerivativeException)) {\r\n            throw (DerivativeException) cause;\r\n        } else if ((cause != null) && (cause instanceof EventException)) {\r\n            throw (EventException) cause;\r\n        }\r\n        throw new EventException(e);\r\n    }\r\n}","code_comment":"\/**\r\n * Evaluate the impact of the proposed step on the event handler.\r\n * @param interpolator step interpolator for the proposed step\r\n * @return true if the event handler triggers an event before\r\n * the end of the proposed step (this implies the step should be\r\n * rejected)\r\n * @exception DerivativeException if the interpolator fails to\r\n * compute the switching function somewhere within the step\r\n * @exception EventException if the switching function\r\n * cannot be evaluated\r\n * @exception ConvergenceException if an event cannot be located\r\n *\/\r\n","code_no_comment":"public boolean evaluateStep(final StepInterpolator interpolator) throws DerivativeException, EventException, ConvergenceException {\r\n    try {\r\n        forward = interpolator.isForward();\r\n        final double t1 = interpolator.getCurrentTime();\r\n        final int n = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) \/ maxCheckInterval));\r\n        final double h = (t1 - t0) \/ n;\r\n        double ta = t0;\r\n        double ga = g0;\r\n        double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\r\n        for (int i = 0; i < n; ++i) {\r\n                        tb += h;\r\n            interpolator.setInterpolatedTime(tb);\r\n            final double gb = handler.g(tb, interpolator.getInterpolatedState());\r\n                        if (g0Positive ^ (gb >= 0)) {\r\n                                                                                                                                                                                increasing = gb >= ga;\r\n                final UnivariateRealFunction f = new UnivariateRealFunction() {\r\n\r\n                    public double value(final double t) throws FunctionEvaluationException {\r\n                        try {\r\n                            interpolator.setInterpolatedTime(t);\r\n                            return handler.g(t, interpolator.getInterpolatedState());\r\n                        } catch (DerivativeException e) {\r\n                            throw new FunctionEvaluationException(e, t);\r\n                        } catch (EventException e) {\r\n                            throw new FunctionEvaluationException(e, t);\r\n                        }\r\n                    }\r\n                };\r\n                final BrentSolver solver = new BrentSolver();\r\n                solver.setAbsoluteAccuracy(convergence);\r\n                solver.setMaximalIterationCount(maxIterationCount);\r\n                final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\r\n                if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {\r\n                                        ta = tb;\r\n                    ga = gb;\r\n                } else if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {\r\n                    pendingEventTime = root;\r\n                    if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\r\n                                                return false;\r\n                    }\r\n                                                            pendingEvent = true;\r\n                    return true;\r\n                }\r\n            } else {\r\n                                ta = tb;\r\n                ga = gb;\r\n            }\r\n        }\r\n                pendingEvent = false;\r\n        pendingEventTime = Double.NaN;\r\n        return false;\r\n    } catch (FunctionEvaluationException e) {\r\n        final Throwable cause = e.getCause();\r\n        if ((cause != null) && (cause instanceof DerivativeException)) {\r\n            throw (DerivativeException) cause;\r\n        } else if ((cause != null) && (cause instanceof EventException)) {\r\n            throw (EventException) cause;\r\n        }\r\n        throw new EventException(e);\r\n    }\r\n}","lc":2.0909090909,"pi":1.9473684211,"ma":2.8,"nbd":2.0,"ml":2.3333333333,"d":3.6369047619,"mi":-1.0665257223,"fo":1.3333333333,"r":-0.0263157895,"e":12.4999844401}
{"project_name":"Compress","project_version":"1","label":1,"code":"\/**\r\n * Closes the CPIO output stream as well as the stream being filtered.\r\n *\r\n * @throws IOException\r\n *             if an I\/O error has occurred or if a CPIO file error has\r\n *             occurred\r\n *\/\r\npublic void close() throws IOException {\r\n    if (!this.closed) {\r\n        super.close();\r\n        this.closed = true;\r\n    }\r\n}","code_comment":"\/**\r\n * Closes the CPIO output stream as well as the stream being filtered.\r\n *\r\n * @throws IOException\r\n *             if an I\/O error has occurred or if a CPIO file error has\r\n *             occurred\r\n *\/\r\n","code_no_comment":"public void close() throws IOException {\r\n    if (!this.closed) {\r\n        super.close();\r\n        this.closed = true;\r\n    }\r\n}","lc":-0.3636363636,"pi":0.1339712919,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0873015873,"mi":0.6730091614,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1464866329}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-414_116d5928","label":1,"code":"@Override\r\nprotected void consume() throws IOException {\r\n    while (getSource().hasTop()) {\r\n        Key k = getSource().getTopKey();\r\n        Value v = getSource().getTopValue();\r\n        if (match(v.get()) || match(k.getRowData()) || match(k.getColumnFamilyData()) || match(k.getColumnQualifierData())) {\r\n            break;\r\n        }\r\n        getSource().next();\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void consume() throws IOException {\r\n    while (getSource().hasTop()) {\r\n        Key k = getSource().getTopKey();\r\n        Value v = getSource().getTopValue();\r\n        if (match(v.get()) || match(k.getRowData()) || match(k.getColumnFamilyData()) || match(k.getColumnQualifierData())) {\r\n            break;\r\n        }\r\n        getSource().next();\r\n    }\r\n}","lc":-0.1363636364,"pi":0.4449760766,"ma":0.0,"nbd":0.0,"ml":0.75,"d":-0.0555555556,"mi":0.1388301621,"fo":0.8333333333,"r":0.2105263158,"e":-0.0667093123}
{"project_name":"Closure","project_version":"157","label":2,"code":"public void visit(NodeTraversal t, Node n, Node parent) {\r\n    switch(n.getType()) {\r\n        case Token.GETPROP:\r\n        case Token.GETELEM:\r\n            Node dest = n.getFirstChild().getNext();\r\n            if (dest.getType() == Token.STRING) {\r\n                String s = dest.getString();\r\n                if (s.equals(\"prototype\")) {\r\n                    processPrototypeParent(parent, t.getInput());\r\n                } else {\r\n                    markPropertyAccessCandidate(dest, t.getInput());\r\n                }\r\n            }\r\n            break;\r\n        case Token.OBJECTLIT:\r\n            if (!prototypeObjLits.contains(n)) {\r\n                \/\/ only the property names.\r\n                for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\r\n                    if (child.getType() != Token.NUMBER) {\r\n                        markObjLitPropertyCandidate(child, t.getInput());\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void visit(NodeTraversal t, Node n, Node parent) {\r\n    switch(n.getType()) {\r\n        case Token.GETPROP:\r\n        case Token.GETELEM:\r\n            Node dest = n.getFirstChild().getNext();\r\n            if (dest.getType() == Token.STRING) {\r\n                String s = dest.getString();\r\n                if (s.equals(\"prototype\")) {\r\n                    processPrototypeParent(parent, t.getInput());\r\n                } else {\r\n                    markPropertyAccessCandidate(dest, t.getInput());\r\n                }\r\n            }\r\n            break;\r\n        case Token.OBJECTLIT:\r\n            if (!prototypeObjLits.contains(n)) {\r\n                                for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\r\n                    if (child.getType() != Token.NUMBER) {\r\n                        markObjLitPropertyCandidate(child, t.getInput());\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n    }\r\n}","lc":0.5,"pi":1.5167464115,"ma":1.4,"nbd":1.5,"ml":0.8333333333,"d":0.4285714286,"mi":-0.4207188161,"fo":0.8333333333,"r":0.0,"e":0.4751808118}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5247_44a4132f","label":3,"code":"\/**\r\n *  @see AbstractBookmarkableMapper#buildUrl(AbstractBookmarkableMapper.UrlInfo)\r\n *\/\r\n@Override\r\nprotected Url buildUrl(UrlInfo info) {\r\n    Url url = new Url();\r\n    for (String s : mountSegments) {\r\n        url.getSegments().add(s);\r\n    }\r\n    encodePageComponentInfo(url, info.getPageComponentInfo());\r\n    PageParameters copy = new PageParameters(info.getPageParameters());\r\n    int dropped = 0;\r\n    for (int i = 0; i < mountSegments.length; ++i) {\r\n        String placeholder = getPlaceholder(mountSegments[i]);\r\n        String optionalPlaceholder = getOptionalPlaceholder(mountSegments[i]);\r\n        if (placeholder != null) {\r\n            url.getSegments().set(i - dropped, copy.get(placeholder).toString(\"\"));\r\n            copy.remove(placeholder);\r\n        } else if (optionalPlaceholder != null) {\r\n            if (copy.getNamedKeys().contains(optionalPlaceholder)) {\r\n                url.getSegments().set(i - dropped, copy.get(optionalPlaceholder).toString(\"\"));\r\n                copy.remove(optionalPlaceholder);\r\n            } else {\r\n                url.getSegments().remove(i - dropped);\r\n                dropped++;\r\n            }\r\n        }\r\n    }\r\n    return encodePageParameters(url, copy, pageParametersEncoder);\r\n}","code_comment":"\/**\r\n *  @see AbstractBookmarkableMapper#buildUrl(AbstractBookmarkableMapper.UrlInfo)\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected Url buildUrl(UrlInfo info) {\r\n    Url url = new Url();\r\n    for (String s : mountSegments) {\r\n        url.getSegments().add(s);\r\n    }\r\n    encodePageComponentInfo(url, info.getPageComponentInfo());\r\n    PageParameters copy = new PageParameters(info.getPageParameters());\r\n    int dropped = 0;\r\n    for (int i = 0; i < mountSegments.length; ++i) {\r\n        String placeholder = getPlaceholder(mountSegments[i]);\r\n        String optionalPlaceholder = getOptionalPlaceholder(mountSegments[i]);\r\n        if (placeholder != null) {\r\n            url.getSegments().set(i - dropped, copy.get(placeholder).toString(\"\"));\r\n            copy.remove(placeholder);\r\n        } else if (optionalPlaceholder != null) {\r\n            if (copy.getNamedKeys().contains(optionalPlaceholder)) {\r\n                url.getSegments().set(i - dropped, copy.get(optionalPlaceholder).toString(\"\"));\r\n                copy.remove(optionalPlaceholder);\r\n            } else {\r\n                url.getSegments().remove(i - dropped);\r\n                dropped++;\r\n            }\r\n        }\r\n    }\r\n    return encodePageParameters(url, copy, pageParametersEncoder);\r\n}","lc":0.5909090909,"pi":0.95215311,"ma":0.4,"nbd":1.0,"ml":0.3333333333,"d":0.621031746,"mi":-0.4878083157,"fo":1.3333333333,"r":-0.0263157895,"e":1.0691908277}
{"project_name":"Collections","project_version":"25","label":1,"code":"\/\/ Collated\r\n\/\/ -----------------------------------------------------------------------\r\n\/**\r\n * Gets an iterator that provides an ordered iteration over the elements\r\n * contained in a collection of ordered {@link Iterator}s.\r\n * <p>\r\n * Given two ordered {@link Iterator}s <code>A<\/code> and <code>B<\/code>,\r\n * the {@link Iterator#next()} method will return the lesser of\r\n * <code>A.next()<\/code> and <code>B.next()<\/code>.\r\n * <p>\r\n * The comparator is optional. If null is specified then natural order is used.\r\n *\r\n * @param <E>  the element type\r\n * @param comparator  the comparator to use, may be null for natural order\r\n * @param iterator1  the first iterators to use, not null\r\n * @param iterator2  the first iterators to use, not null\r\n * @return a combination iterator over the iterators\r\n * @throws NullPointerException if either iterator is null\r\n *\/\r\npublic static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {\r\n    return new CollatingIterator<E>(comparator, iterator1, iterator2);\r\n}","code_comment":"\/**\r\n * Gets an iterator that provides an ordered iteration over the elements\r\n * contained in a collection of ordered {@link Iterator}s.\r\n * <p>\r\n * Given two ordered {@link Iterator}s <code>A<\/code> and <code>B<\/code>,\r\n * the {@link Iterator#next()} method will return the lesser of\r\n * <code>A.next()<\/code> and <code>B.next()<\/code>.\r\n * <p>\r\n * The comparator is optional. If null is specified then natural order is used.\r\n *\r\n * @param <E>  the element type\r\n * @param comparator  the comparator to use, may be null for natural order\r\n * @param iterator1  the first iterators to use, not null\r\n * @param iterator2  the first iterators to use, not null\r\n * @return a combination iterator over the iterators\r\n * @throws NullPointerException if either iterator is null\r\n *\/\r\n","code_no_comment":"public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {\r\n    return new CollatingIterator<E>(comparator, iterator1, iterator2);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8686398872,"fo":-0.5,"r":0.3421052632,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1364_b481a14c","label":1,"code":"\/**\r\n * Add an entry to the cache. The entry may or may not exist in the\r\n * cache yet. This method will usually mark unknown entries as cold and\r\n * known entries as hot.\r\n *\r\n * @param key the key (may not be null)\r\n * @param hash the hash\r\n * @param value the value (may not be null)\r\n * @param memory the memory used for the given entry\r\n * @return the old value, or null if there was no resident entry\r\n *\/\r\nsynchronized V put(K key, int hash, V value, int memory) {\r\n    if (value == null) {\r\n        throw new NullPointerException(\"The value may not be null\");\r\n    }\r\n    V old;\r\n    Entry<K, V> e = find(key, hash);\r\n    if (e == null) {\r\n        old = null;\r\n    } else {\r\n        old = e.value;\r\n        invalidate(key, hash);\r\n    }\r\n    e = new Entry<K, V>();\r\n    e.key = key;\r\n    e.value = value;\r\n    e.memory = memory;\r\n    int index = hash & mask;\r\n    e.mapNext = entries[index];\r\n    entries[index] = e;\r\n    usedMemory += memory;\r\n    if (usedMemory > maxMemory && mapSize > 0) {\r\n        \/\/ an old entry needs to be removed\r\n        evict(e);\r\n    }\r\n    mapSize++;\r\n    \/\/ added entries are always added to the stack\r\n    addToStack(e);\r\n    return old;\r\n}","code_comment":"\/**\r\n * Add an entry to the cache. The entry may or may not exist in the\r\n * cache yet. This method will usually mark unknown entries as cold and\r\n * known entries as hot.\r\n *\r\n * @param key the key (may not be null)\r\n * @param hash the hash\r\n * @param value the value (may not be null)\r\n * @param memory the memory used for the given entry\r\n * @return the old value, or null if there was no resident entry\r\n *\/\r\n","code_no_comment":"synchronized V put(K key, int hash, V value, int memory) {\r\n    if (value == null) {\r\n        throw new NullPointerException(\"The value may not be null\");\r\n    }\r\n    V old;\r\n    Entry<K, V> e = find(key, hash);\r\n    if (e == null) {\r\n        old = null;\r\n    } else {\r\n        old = e.value;\r\n        invalidate(key, hash);\r\n    }\r\n    e = new Entry<K, V>();\r\n    e.key = key;\r\n    e.value = value;\r\n    e.memory = memory;\r\n    int index = hash & mask;\r\n    e.mapNext = entries[index];\r\n    entries[index] = e;\r\n    usedMemory += memory;\r\n    if (usedMemory > maxMemory && mapSize > 0) {\r\n                evict(e);\r\n    }\r\n    mapSize++;\r\n        addToStack(e);\r\n    return old;\r\n}","lc":0.5909090909,"pi":-0.4784688995,"ma":0.2,"nbd":-0.5,"ml":0.3333333333,"d":1.1686507937,"mi":-0.4483439042,"fo":-0.1666666667,"r":-0.0263157895,"e":1.3654189934}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-4486_f98ac676","label":1,"code":"private boolean doRoutingSlip(Exchange exchange, AsyncCallback callback) {\r\n    Exchange current = exchange;\r\n    RoutingSlipIterator iter;\r\n    try {\r\n        iter = createRoutingSlipIterator(exchange);\r\n    } catch (Exception e) {\r\n        exchange.setException(e);\r\n        callback.done(true);\r\n        return true;\r\n    }\r\n    \/\/ ensure the slip is empty when we start\r\n    if (current.hasProperties()) {\r\n        current.setProperty(Exchange.SLIP_ENDPOINT, null);\r\n    }\r\n    while (iter.hasNext(current)) {\r\n        Endpoint endpoint;\r\n        try {\r\n            endpoint = resolveEndpoint(iter, exchange);\r\n            \/\/ if no endpoint was resolved then try the next\r\n            if (endpoint == null) {\r\n                continue;\r\n            }\r\n        } catch (Exception e) {\r\n            \/\/ error resolving endpoint so we should break out\r\n            exchange.setException(e);\r\n            return true;\r\n        }\r\n        \/\/ prepare and process the routing slip\r\n        Exchange copy = prepareExchangeForRoutingSlip(current, endpoint);\r\n        boolean sync = processExchange(endpoint, copy, exchange, callback, iter);\r\n        current = copy;\r\n        if (!sync) {\r\n            log.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\r\n            \/\/ so we break out now, then the callback will be invoked which then continue routing from where we left here\r\n            return false;\r\n        }\r\n        log.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\r\n        \/\/ we ignore some kind of exceptions and allow us to continue\r\n        if (isIgnoreInvalidEndpoints()) {\r\n            FailedToCreateProducerException e = current.getException(FailedToCreateProducerException.class);\r\n            if (e != null) {\r\n                if (log.isDebugEnabled()) {\r\n                    log.debug(\"Endpoint uri is invalid: \" + endpoint + \". This exception will be ignored.\", e);\r\n                }\r\n                current.setException(null);\r\n            }\r\n        }\r\n        \/\/ check for error if so we should break out\r\n        if (!continueProcessing(current, \"so breaking out of the routing slip\", log)) {\r\n            break;\r\n        }\r\n    }\r\n    \/\/ logging nextExchange as it contains the exchange that might have altered the payload and since\r\n    \/\/ we are logging the completion if will be confusing if we log the original instead\r\n    \/\/ we could also consider logging the original and the nextExchange then we have *before* and *after* snapshots\r\n    log.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), current);\r\n    \/\/ copy results back to the original exchange\r\n    ExchangeHelper.copyResults(exchange, current);\r\n    callback.done(true);\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"private boolean doRoutingSlip(Exchange exchange, AsyncCallback callback) {\r\n    Exchange current = exchange;\r\n    RoutingSlipIterator iter;\r\n    try {\r\n        iter = createRoutingSlipIterator(exchange);\r\n    } catch (Exception e) {\r\n        exchange.setException(e);\r\n        callback.done(true);\r\n        return true;\r\n    }\r\n        if (current.hasProperties()) {\r\n        current.setProperty(Exchange.SLIP_ENDPOINT, null);\r\n    }\r\n    while (iter.hasNext(current)) {\r\n        Endpoint endpoint;\r\n        try {\r\n            endpoint = resolveEndpoint(iter, exchange);\r\n                        if (endpoint == null) {\r\n                continue;\r\n            }\r\n        } catch (Exception e) {\r\n                        exchange.setException(e);\r\n            return true;\r\n        }\r\n                Exchange copy = prepareExchangeForRoutingSlip(current, endpoint);\r\n        boolean sync = processExchange(endpoint, copy, exchange, callback, iter);\r\n        current = copy;\r\n        if (!sync) {\r\n            log.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\r\n                        return false;\r\n        }\r\n        log.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\r\n                if (isIgnoreInvalidEndpoints()) {\r\n            FailedToCreateProducerException e = current.getException(FailedToCreateProducerException.class);\r\n            if (e != null) {\r\n                if (log.isDebugEnabled()) {\r\n                    log.debug(\"Endpoint uri is invalid: \" + endpoint + \". This exception will be ignored.\", e);\r\n                }\r\n                current.setException(null);\r\n            }\r\n        }\r\n                if (!continueProcessing(current, \"so breaking out of the routing slip\", log)) {\r\n            break;\r\n        }\r\n    }\r\n                log.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), current);\r\n        ExchangeHelper.copyResults(exchange, current);\r\n    callback.done(true);\r\n    return true;\r\n}","lc":1.6363636364,"pi":0.6028708134,"ma":1.8,"nbd":1.0,"ml":1.0833333333,"d":0.6051587302,"mi":-0.850880902,"fo":1.5,"r":-0.0263157895,"e":1.3891622436}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3769_b4e9d426","label":1,"code":"public void invalidate(Request request) {\r\n    for (UnboundListener l : unboundListeners) {\r\n        l.sessionUnbound(sessionId);\r\n    }\r\n    cleanup();\r\n}","code_comment":null,"code_no_comment":"public void invalidate(Request request) {\r\n    for (UnboundListener l : unboundListeners) {\r\n        l.sessionUnbound(sessionId);\r\n    }\r\n    cleanup();\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6188865398,"fo":-0.3333333333,"r":1.5526315789,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1348_bc7b7e8c","label":1,"code":"@Override\r\npublic boolean apply(@Nullable ACE ace) {\r\n    return (ace != null) && ace.getPrincipal().equals(principal);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean apply(@Nullable ACE ace) {\r\n    return (ace != null) && ace.getPrincipal().equals(principal);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.126984127,"mi":0.7640591966,"fo":-0.3333333333,"r":1.6578947368,"e":-0.1350253281}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"@Override\r\npublic void removeProperty(String name) {\r\n    root.checkLive();\r\n    NodeBuilder builder = getNodeBuilder();\r\n    builder.removeProperty(name);\r\n    root.updated();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void removeProperty(String name) {\r\n    root.checkLive();\r\n    NodeBuilder builder = getNodeBuilder();\r\n    builder.removeProperty(name);\r\n    root.updated();\r\n}","lc":-0.3181818182,"pi":-0.4832535885,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4889358703,"fo":-0.1666666667,"r":1.2368421053,"e":-0.1627934049}
{"project_name":"Lang","project_version":"50","label":1,"code":"\/**\r\n * <p>Gets a date formatter instance using the specified style, time\r\n * zone and locale.<\/p>\r\n *\r\n * @param style  date style: FULL, LONG, MEDIUM, or SHORT\r\n * @param timeZone  optional time zone, overrides time zone of\r\n *  formatted date\r\n * @param locale  optional locale, overrides system locale\r\n * @return a localized standard date formatter\r\n * @throws IllegalArgumentException if the Locale has no date\r\n *  pattern defined\r\n *\/\r\npublic static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\r\n    Object key = new Integer(style);\r\n    if (timeZone != null) {\r\n        key = new Pair(key, timeZone);\r\n    }\r\n    if (locale != null) {\r\n        key = new Pair(key, locale);\r\n    }\r\n    FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\r\n    if (format == null) {\r\n        if (locale == null) {\r\n            locale = Locale.getDefault();\r\n        }\r\n        try {\r\n            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\r\n            String pattern = formatter.toPattern();\r\n            format = getInstance(pattern, timeZone, locale);\r\n            cDateInstanceCache.put(key, format);\r\n        } catch (ClassCastException ex) {\r\n            throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\r\n        }\r\n    }\r\n    return format;\r\n}","code_comment":"\/**\r\n * <p>Gets a date formatter instance using the specified style, time\r\n * zone and locale.<\/p>\r\n *\r\n * @param style  date style: FULL, LONG, MEDIUM, or SHORT\r\n * @param timeZone  optional time zone, overrides time zone of\r\n *  formatted date\r\n * @param locale  optional locale, overrides system locale\r\n * @return a localized standard date formatter\r\n * @throws IllegalArgumentException if the Locale has no date\r\n *  pattern defined\r\n *\/\r\n","code_no_comment":"public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\r\n    Object key = new Integer(style);\r\n    if (timeZone != null) {\r\n        key = new Pair(key, timeZone);\r\n    }\r\n    if (locale != null) {\r\n        key = new Pair(key, locale);\r\n    }\r\n    FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\r\n    if (format == null) {\r\n        if (locale == null) {\r\n            locale = Locale.getDefault();\r\n        }\r\n        try {\r\n            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\r\n            String pattern = formatter.toPattern();\r\n            format = getInstance(pattern, timeZone, locale);\r\n            cDateInstanceCache.put(key, format);\r\n        } catch (ClassCastException ex) {\r\n            throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\r\n        }\r\n    }\r\n    return format;\r\n}","lc":0.4545454545,"pi":0.3588516746,"ma":0.6,"nbd":0.0,"ml":0.1666666667,"d":0.496031746,"mi":-0.3911205074,"fo":0.0,"r":-0.0263157895,"e":0.6051462918}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1270_70564c7c","label":1,"code":"\/**\r\n * Tries to merge back tokens that are split on relevant fulltext query\r\n * wildcards ('*' or '?')\r\n *\r\n * @param text\r\n * @param analyzer\r\n * @return\r\n *\/\r\nstatic List<String> tokenize(String text, Analyzer analyzer) {\r\n    List<String> tokens = new ArrayList<String>();\r\n    TokenStream stream = null;\r\n    try {\r\n        stream = analyzer.tokenStream(FieldNames.FULLTEXT, new StringReader(text));\r\n        CharTermAttribute termAtt = stream.addAttribute(CharTermAttribute.class);\r\n        OffsetAttribute offsetAtt = stream.addAttribute(OffsetAttribute.class);\r\n        \/\/ TypeAttribute type = stream.addAttribute(TypeAttribute.class);\r\n        stream.reset();\r\n        int poz = 0;\r\n        boolean hasFulltextToken = false;\r\n        StringBuilder token = new StringBuilder();\r\n        while (stream.incrementToken()) {\r\n            String term = termAtt.toString();\r\n            int start = offsetAtt.startOffset();\r\n            int end = offsetAtt.endOffset();\r\n            if (start > poz) {\r\n                for (int i = poz; i < start; i++) {\r\n                    for (char c : fulltextTokens) {\r\n                        if (c == text.charAt(i)) {\r\n                            token.append(c);\r\n                            hasFulltextToken = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            poz = end;\r\n            if (hasFulltextToken) {\r\n                token.append(term);\r\n            } else {\r\n                if (token.length() > 0) {\r\n                    tokens.add(token.toString());\r\n                }\r\n                token = new StringBuilder();\r\n                token.append(term);\r\n            }\r\n        }\r\n        \/\/ consume to the end of the string\r\n        if (poz < text.length()) {\r\n            for (int i = poz; i < text.length(); i++) {\r\n                for (char c : fulltextTokens) {\r\n                    if (c == text.charAt(i)) {\r\n                        token.append(c);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (token.length() > 0) {\r\n            tokens.add(token.toString());\r\n        }\r\n        stream.end();\r\n    } catch (IOException e) {\r\n        LOG.error(\"Building fulltext query failed\", e.getMessage());\r\n        return null;\r\n    } finally {\r\n        try {\r\n            if (stream != null) {\r\n                stream.close();\r\n            }\r\n        } catch (IOException e) {\r\n        \/\/ ignore\r\n        }\r\n    }\r\n    return tokens;\r\n}","code_comment":"\/**\r\n * Tries to merge back tokens that are split on relevant fulltext query\r\n * wildcards ('*' or '?')\r\n *\r\n * @param text\r\n * @param analyzer\r\n * @return\r\n *\/\r\n","code_no_comment":"static List<String> tokenize(String text, Analyzer analyzer) {\r\n    List<String> tokens = new ArrayList<String>();\r\n    TokenStream stream = null;\r\n    try {\r\n        stream = analyzer.tokenStream(FieldNames.FULLTEXT, new StringReader(text));\r\n        CharTermAttribute termAtt = stream.addAttribute(CharTermAttribute.class);\r\n        OffsetAttribute offsetAtt = stream.addAttribute(OffsetAttribute.class);\r\n                stream.reset();\r\n        int poz = 0;\r\n        boolean hasFulltextToken = false;\r\n        StringBuilder token = new StringBuilder();\r\n        while (stream.incrementToken()) {\r\n            String term = termAtt.toString();\r\n            int start = offsetAtt.startOffset();\r\n            int end = offsetAtt.endOffset();\r\n            if (start > poz) {\r\n                for (int i = poz; i < start; i++) {\r\n                    for (char c : fulltextTokens) {\r\n                        if (c == text.charAt(i)) {\r\n                            token.append(c);\r\n                            hasFulltextToken = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            poz = end;\r\n            if (hasFulltextToken) {\r\n                token.append(term);\r\n            } else {\r\n                if (token.length() > 0) {\r\n                    tokens.add(token.toString());\r\n                }\r\n                token = new StringBuilder();\r\n                token.append(term);\r\n            }\r\n        }\r\n                if (poz < text.length()) {\r\n            for (int i = poz; i < text.length(); i++) {\r\n                for (char c : fulltextTokens) {\r\n                    if (c == text.charAt(i)) {\r\n                        token.append(c);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (token.length() > 0) {\r\n            tokens.add(token.toString());\r\n        }\r\n        stream.end();\r\n    } catch (IOException e) {\r\n        LOG.error(\"Building fulltext query failed\", e.getMessage());\r\n        return null;\r\n    } finally {\r\n        try {\r\n            if (stream != null) {\r\n                stream.close();\r\n            }\r\n        } catch (IOException e) {\r\n                }\r\n    }\r\n    return tokens;\r\n}","lc":2.1818181818,"pi":1.5837320574,"ma":2.4,"nbd":2.0,"ml":1.3333333333,"d":1.2063492063,"mi":-1.0118393235,"fo":1.6666666667,"r":-0.0263157895,"e":3.2087896129}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-757_76b7413d","label":1,"code":"\/**\r\n * The expansion mode determines whether the internal storage\r\n * array grows additively or multiplicatively when it is expanded.\r\n *\r\n * @return the expansion mode.\r\n * @deprecated As of 3.1. Return value to be changed to\r\n * {@link ExpansionMode} in 4.0.\r\n *\/\r\n@Deprecated\r\npublic int getExpansionMode() {\r\n    switch(expansionMode) {\r\n        case MULTIPLICATIVE:\r\n            return MULTIPLICATIVE_MODE;\r\n        case ADDITIVE:\r\n            return ADDITIVE_MODE;\r\n        default:\r\n            \/\/ Should never happen.\r\n            throw new MathInternalError();\r\n    }\r\n}","code_comment":"\/**\r\n * The expansion mode determines whether the internal storage\r\n * array grows additively or multiplicatively when it is expanded.\r\n *\r\n * @return the expansion mode.\r\n * @deprecated As of 3.1. Return value to be changed to\r\n * {@link ExpansionMode} in 4.0.\r\n *\/\r\n","code_no_comment":"@Deprecated\r\npublic int getExpansionMode() {\r\n    switch(expansionMode) {\r\n        case MULTIPLICATIVE:\r\n            return MULTIPLICATIVE_MODE;\r\n        case ADDITIVE:\r\n            return ADDITIVE_MODE;\r\n        default:\r\n                        throw new MathInternalError();\r\n    }\r\n}","lc":-0.1363636364,"pi":0.7846889952,"ma":0.2,"nbd":0.0,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.3589852008,"fo":-0.5,"r":2.3157894737,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1174_342809f7","label":3,"code":"public static boolean isValidLocalName(String local) {\r\n    if (local.isEmpty() || \".\".equals(local) || \"..\".equals(local)) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < local.length(); i++) {\r\n        char ch = local.charAt(i);\r\n        if (i == 0 && Character.isWhitespace(ch)) {\r\n            \/\/ leading whitespace\r\n            return false;\r\n        } else if (i == local.length() - 1 && Character.isWhitespace(ch)) {\r\n            \/\/ trailing whitespace\r\n            return false;\r\n        } else if (\"\/:[]|*\".indexOf(ch) != -1) {\r\n            \/\/ invalid name character\r\n            return false;\r\n        }\r\n    }\r\n    \/\/ TODO: Other name rules?\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"public static boolean isValidLocalName(String local) {\r\n    if (local.isEmpty() || \".\".equals(local) || \"..\".equals(local)) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < local.length(); i++) {\r\n        char ch = local.charAt(i);\r\n        if (i == 0 && Character.isWhitespace(ch)) {\r\n                        return false;\r\n        } else if (i == local.length() - 1 && Character.isWhitespace(ch)) {\r\n                        return false;\r\n        } else if (\"\/:[]|*\".indexOf(ch) != -1) {\r\n                        return false;\r\n        }\r\n    }\r\n        return true;\r\n}","lc":0.0909090909,"pi":0.3444976077,"ma":0.4,"nbd":1.0,"ml":1.0833333333,"d":1.3412698413,"mi":-0.1450317125,"fo":0.25,"r":0.2631578947,"e":0.8855425506}
{"project_name":"Compress","project_version":"11","label":1,"code":"\/**\r\n * Create an archive input stream from an input stream, autodetecting\r\n * the archive type from the first few bytes of the stream. The InputStream\r\n * must support marks, like BufferedInputStream.\r\n *\r\n * @param in the input stream\r\n * @return the archive input stream\r\n * @throws ArchiveException if the archiver name is not known\r\n * @throws IllegalArgumentException if the stream is null or does not support mark\r\n *\/\r\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\r\n    if (in == null) {\r\n        throw new IllegalArgumentException(\"Stream must not be null.\");\r\n    }\r\n    if (!in.markSupported()) {\r\n        throw new IllegalArgumentException(\"Mark is not supported.\");\r\n    }\r\n    final byte[] signature = new byte[12];\r\n    in.mark(signature.length);\r\n    try {\r\n        int signatureLength = in.read(signature);\r\n        in.reset();\r\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new ZipArchiveInputStream(in);\r\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new JarArchiveInputStream(in);\r\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new ArArchiveInputStream(in);\r\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new CpioArchiveInputStream(in);\r\n        }\r\n        \/\/ Dump needs a bigger buffer to check the signature;\r\n        final byte[] dumpsig = new byte[32];\r\n        in.mark(dumpsig.length);\r\n        signatureLength = in.read(dumpsig);\r\n        in.reset();\r\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\r\n            return new DumpArchiveInputStream(in);\r\n        }\r\n        \/\/ Tar needs an even bigger buffer to check the signature; read the first block\r\n        final byte[] tarheader = new byte[512];\r\n        in.mark(tarheader.length);\r\n        signatureLength = in.read(tarheader);\r\n        in.reset();\r\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\r\n            return new TarArchiveInputStream(in);\r\n        }\r\n        \/\/ COMPRESS-117 - improve auto-recognition\r\n        try {\r\n            TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\r\n            tais.getNextEntry();\r\n            return new TarArchiveInputStream(in);\r\n        } catch (Exception e) {\r\n        \/\/ NOPMD\r\n        \/\/ can generate IllegalArgumentException as well as IOException\r\n        \/\/ autodetection, simply not a TAR\r\n        \/\/ ignored\r\n        }\r\n    } catch (IOException e) {\r\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\r\n    }\r\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\r\n}","code_comment":"\/**\r\n * Create an archive input stream from an input stream, autodetecting\r\n * the archive type from the first few bytes of the stream. The InputStream\r\n * must support marks, like BufferedInputStream.\r\n *\r\n * @param in the input stream\r\n * @return the archive input stream\r\n * @throws ArchiveException if the archiver name is not known\r\n * @throws IllegalArgumentException if the stream is null or does not support mark\r\n *\/\r\n","code_no_comment":"public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\r\n    if (in == null) {\r\n        throw new IllegalArgumentException(\"Stream must not be null.\");\r\n    }\r\n    if (!in.markSupported()) {\r\n        throw new IllegalArgumentException(\"Mark is not supported.\");\r\n    }\r\n    final byte[] signature = new byte[12];\r\n    in.mark(signature.length);\r\n    try {\r\n        int signatureLength = in.read(signature);\r\n        in.reset();\r\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new ZipArchiveInputStream(in);\r\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new JarArchiveInputStream(in);\r\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new ArArchiveInputStream(in);\r\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\r\n            return new CpioArchiveInputStream(in);\r\n        }\r\n                final byte[] dumpsig = new byte[32];\r\n        in.mark(dumpsig.length);\r\n        signatureLength = in.read(dumpsig);\r\n        in.reset();\r\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\r\n            return new DumpArchiveInputStream(in);\r\n        }\r\n                final byte[] tarheader = new byte[512];\r\n        in.mark(tarheader.length);\r\n        signatureLength = in.read(tarheader);\r\n        in.reset();\r\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\r\n            return new TarArchiveInputStream(in);\r\n        }\r\n                try {\r\n            TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\r\n            tais.getNextEntry();\r\n            return new TarArchiveInputStream(in);\r\n        } catch (Exception e) {\r\n                                        }\r\n    } catch (IOException e) {\r\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\r\n    }\r\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\r\n}","lc":1.4545454545,"pi":0.019138756,"ma":2.2,"nbd":1.5,"ml":1.25,"d":0.1924603175,"mi":-0.8060606061,"fo":0.9166666667,"r":-0.0263157895,"e":0.6165200002}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2172_ea4a3f8a","label":3,"code":"\/**\r\n *  @see IValueMap#getAsTime(String)\r\n *\/\r\npublic Time getAsTime(String key) {\r\n    return getAsTime(key, null);\r\n}","code_comment":"\/**\r\n *  @see IValueMap#getAsTime(String)\r\n *\/\r\n","code_no_comment":"public Time getAsTime(String key) {\r\n    return getAsTime(key, null);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0253699789,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  Clean up the request cycle.\r\n *\/\r\nprivate void detach() {\r\n    \/\/ furthermore, the targets will be cg-ed with this cycle too\r\n    for (Iterator iter = requestTargets.iterator(); iter.hasNext(); ) {\r\n        IRequestTarget target = (IRequestTarget) iter.next();\r\n        if (target != null) {\r\n            try {\r\n                target.detach(this);\r\n            } catch (RuntimeException e) {\r\n                log.error(\"there was an error cleaning up target \" + target + \".\", e);\r\n            }\r\n        }\r\n    }\r\n    \/\/ remove any rendered feedback messages from the session\r\n    try {\r\n        session.cleanupFeedbackMessages();\r\n    } catch (RuntimeException re) {\r\n        log.error(\"there was an error cleaning up the feedback messages\", re);\r\n    }\r\n    if (updateSession) {\r\n        \/\/ attributes that might be required to update the cluster\r\n        try {\r\n            session.update();\r\n        } catch (RuntimeException re) {\r\n            log.error(\"there was an error updating the session \" + session + \".\", re);\r\n        }\r\n    }\r\n    try {\r\n        IRequestLogger requestLogger = getApplication().getRequestLogger();\r\n        if (requestLogger != null) {\r\n            requestLogger.requestTime((System.currentTimeMillis() - startTime));\r\n        }\r\n    } catch (RuntimeException re) {\r\n        log.error(\"there was an error in the RequestLogger ending.\", re);\r\n    }\r\n    \/\/ clear the used pagemap for this thread,\r\n    try {\r\n        session.requestDetached();\r\n    } catch (RuntimeException re) {\r\n        log.error(\"there was an error detaching the request from the session \" + session + \".\", re);\r\n    }\r\n    if (getResponse() instanceof BufferedWebResponse) {\r\n        try {\r\n            ((BufferedWebResponse) getResponse()).filter();\r\n        } catch (RuntimeException re) {\r\n            log.error(\"there was an error filtering the response.\", re);\r\n        }\r\n    }\r\n    try {\r\n        onEndRequest();\r\n    } catch (RuntimeException e) {\r\n        log.error(\"Exception occurred during onEndRequest\", e);\r\n    }\r\n    \/\/ Release thread local resources\r\n    try {\r\n        threadDetach();\r\n    } catch (RuntimeException re) {\r\n        log.error(\"Exception occurred during threadDetach\", re);\r\n    }\r\n}","code_comment":"\/**\r\n *  Clean up the request cycle.\r\n *\/\r\n","code_no_comment":"private void detach() {\r\n        for (Iterator iter = requestTargets.iterator(); iter.hasNext(); ) {\r\n        IRequestTarget target = (IRequestTarget) iter.next();\r\n        if (target != null) {\r\n            try {\r\n                target.detach(this);\r\n            } catch (RuntimeException e) {\r\n                log.error(\"there was an error cleaning up target \" + target + \".\", e);\r\n            }\r\n        }\r\n    }\r\n        try {\r\n        session.cleanupFeedbackMessages();\r\n    } catch (RuntimeException re) {\r\n        log.error(\"there was an error cleaning up the feedback messages\", re);\r\n    }\r\n    if (updateSession) {\r\n                try {\r\n            session.update();\r\n        } catch (RuntimeException re) {\r\n            log.error(\"there was an error updating the session \" + session + \".\", re);\r\n        }\r\n    }\r\n    try {\r\n        IRequestLogger requestLogger = getApplication().getRequestLogger();\r\n        if (requestLogger != null) {\r\n            requestLogger.requestTime((System.currentTimeMillis() - startTime));\r\n        }\r\n    } catch (RuntimeException re) {\r\n        log.error(\"there was an error in the RequestLogger ending.\", re);\r\n    }\r\n        try {\r\n        session.requestDetached();\r\n    } catch (RuntimeException re) {\r\n        log.error(\"there was an error detaching the request from the session \" + session + \".\", re);\r\n    }\r\n    if (getResponse() instanceof BufferedWebResponse) {\r\n        try {\r\n            ((BufferedWebResponse) getResponse()).filter();\r\n        } catch (RuntimeException re) {\r\n            log.error(\"there was an error filtering the response.\", re);\r\n        }\r\n    }\r\n    try {\r\n        onEndRequest();\r\n    } catch (RuntimeException e) {\r\n        log.error(\"Exception occurred during onEndRequest\", e);\r\n    }\r\n        try {\r\n        threadDetach();\r\n    } catch (RuntimeException re) {\r\n        log.error(\"Exception occurred during threadDetach\", re);\r\n    }\r\n}","lc":1.8181818182,"pi":0.2535885167,"ma":2.0,"nbd":0.5,"ml":0.4166666667,"d":0.5218253968,"mi":-0.8683579986,"fo":1.5,"r":-0.0263157895,"e":1.0378312961}
{"project_name":"Math","project_version":"81","label":1,"code":"\/**\r\n * Find realEigenvalues using dqd\/dqds algorithms.\r\n * <p>This implementation is based on Beresford N. Parlett\r\n * and Osni A. Marques paper <a\r\n * href=\"http:\/\/www.netlib.org\/lapack\/lawnspdf\/lawn155.pdf\">An\r\n * Implementation of the dqds Algorithm (Positive Case)<\/a> and on the\r\n * corresponding LAPACK routine DLASQ2.<\/p>\r\n * @param n number of rows of the block\r\n * @exception InvalidMatrixException if block cannot be diagonalized\r\n * after 30 * n iterations\r\n *\/\r\nprivate void processGeneralBlock(final int n) throws InvalidMatrixException {\r\n    \/\/ check decomposed matrix data range\r\n    double sumOffDiag = 0;\r\n    for (int i = 0; i < n - 1; ++i) {\r\n        final int fourI = 4 * i;\r\n        final double ei = work[fourI + 2];\r\n        sumOffDiag += ei;\r\n    }\r\n    if (sumOffDiag == 0) {\r\n        \/\/ matrix is already diagonal\r\n        return;\r\n    }\r\n    \/\/ initial checks for splits (see Parlett & Marques section 3.3)\r\n    flipIfWarranted(n, 2);\r\n    \/\/ two iterations with Li's test for initial splits\r\n    initialSplits(n);\r\n    \/\/ initialize parameters used by goodStep\r\n    tType = 0;\r\n    dMin1 = 0;\r\n    dMin2 = 0;\r\n    dN = 0;\r\n    dN1 = 0;\r\n    dN2 = 0;\r\n    tau = 0;\r\n    \/\/ process split segments\r\n    int i0 = 0;\r\n    int n0 = n;\r\n    while (n0 > 0) {\r\n        \/\/ retrieve shift that was temporarily stored as a negative off-diagonal element\r\n        sigma = (n0 == n) ? 0 : -work[4 * n0 - 2];\r\n        sigmaLow = 0;\r\n        \/\/ find start of a new split segment to process\r\n        double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\r\n        double offDiagMax = 0;\r\n        double diagMax = work[4 * n0 - 4];\r\n        double diagMin = diagMax;\r\n        i0 = 0;\r\n        for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\r\n            if (work[i + 2] <= 0) {\r\n                i0 = 1 + i \/ 4;\r\n                break;\r\n            }\r\n            if (diagMin >= 4 * offDiagMax) {\r\n                diagMin = Math.min(diagMin, work[i + 4]);\r\n                offDiagMax = Math.max(offDiagMax, work[i + 2]);\r\n            }\r\n            diagMax = Math.max(diagMax, work[i] + work[i + 2]);\r\n            offDiagMin = Math.min(offDiagMin, work[i + 2]);\r\n        }\r\n        work[4 * n0 - 2] = offDiagMin;\r\n        \/\/ lower bound of Gershgorin disk\r\n        dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\r\n        pingPong = 0;\r\n        int maxIter = 30 * (n0 - i0);\r\n        for (int k = 0; i0 < n0; ++k) {\r\n            if (k >= maxIter) {\r\n                throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\r\n            }\r\n            \/\/ perform one step\r\n            n0 = goodStep(i0, n0);\r\n            pingPong = 1 - pingPong;\r\n            \/\/ when the last elements of qd array are very small\r\n            if ((pingPong == 0) && (n0 - i0 > 3) && (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) && (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\r\n                int split = i0 - 1;\r\n                diagMax = work[4 * i0];\r\n                offDiagMin = work[4 * i0 + 2];\r\n                double previousEMin = work[4 * i0 + 3];\r\n                for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\r\n                    if ((work[i + 3] <= TOLERANCE_2 * work[i]) && (work[i + 2] <= TOLERANCE_2 * sigma)) {\r\n                        \/\/ insert a split\r\n                        work[i + 2] = -sigma;\r\n                        split = i \/ 4;\r\n                        diagMax = 0;\r\n                        offDiagMin = work[i + 6];\r\n                        previousEMin = work[i + 7];\r\n                    } else {\r\n                        diagMax = Math.max(diagMax, work[i + 4]);\r\n                        offDiagMin = Math.min(offDiagMin, work[i + 2]);\r\n                        previousEMin = Math.min(previousEMin, work[i + 3]);\r\n                    }\r\n                }\r\n                work[4 * n0 - 2] = offDiagMin;\r\n                work[4 * n0 - 1] = previousEMin;\r\n                i0 = split + 1;\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Find realEigenvalues using dqd\/dqds algorithms.\r\n * <p>This implementation is based on Beresford N. Parlett\r\n * and Osni A. Marques paper <a\r\n * href=\"http:\/\/www.netlib.org\/lapack\/lawnspdf\/lawn155.pdf\">An\r\n * Implementation of the dqds Algorithm (Positive Case)<\/a> and on the\r\n * corresponding LAPACK routine DLASQ2.<\/p>\r\n * @param n number of rows of the block\r\n * @exception InvalidMatrixException if block cannot be diagonalized\r\n * after 30 * n iterations\r\n *\/\r\n","code_no_comment":"private void processGeneralBlock(final int n) throws InvalidMatrixException {\r\n        double sumOffDiag = 0;\r\n    for (int i = 0; i < n - 1; ++i) {\r\n        final int fourI = 4 * i;\r\n        final double ei = work[fourI + 2];\r\n        sumOffDiag += ei;\r\n    }\r\n    if (sumOffDiag == 0) {\r\n                return;\r\n    }\r\n        flipIfWarranted(n, 2);\r\n        initialSplits(n);\r\n        tType = 0;\r\n    dMin1 = 0;\r\n    dMin2 = 0;\r\n    dN = 0;\r\n    dN1 = 0;\r\n    dN2 = 0;\r\n    tau = 0;\r\n        int i0 = 0;\r\n    int n0 = n;\r\n    while (n0 > 0) {\r\n                sigma = (n0 == n) ? 0 : -work[4 * n0 - 2];\r\n        sigmaLow = 0;\r\n                double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\r\n        double offDiagMax = 0;\r\n        double diagMax = work[4 * n0 - 4];\r\n        double diagMin = diagMax;\r\n        i0 = 0;\r\n        for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\r\n            if (work[i + 2] <= 0) {\r\n                i0 = 1 + i \/ 4;\r\n                break;\r\n            }\r\n            if (diagMin >= 4 * offDiagMax) {\r\n                diagMin = Math.min(diagMin, work[i + 4]);\r\n                offDiagMax = Math.max(offDiagMax, work[i + 2]);\r\n            }\r\n            diagMax = Math.max(diagMax, work[i] + work[i + 2]);\r\n            offDiagMin = Math.min(offDiagMin, work[i + 2]);\r\n        }\r\n        work[4 * n0 - 2] = offDiagMin;\r\n                dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\r\n        pingPong = 0;\r\n        int maxIter = 30 * (n0 - i0);\r\n        for (int k = 0; i0 < n0; ++k) {\r\n            if (k >= maxIter) {\r\n                throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\r\n            }\r\n                        n0 = goodStep(i0, n0);\r\n            pingPong = 1 - pingPong;\r\n                        if ((pingPong == 0) && (n0 - i0 > 3) && (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) && (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\r\n                int split = i0 - 1;\r\n                diagMax = work[4 * i0];\r\n                offDiagMin = work[4 * i0 + 2];\r\n                double previousEMin = work[4 * i0 + 3];\r\n                for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\r\n                    if ((work[i + 3] <= TOLERANCE_2 * work[i]) && (work[i + 2] <= TOLERANCE_2 * sigma)) {\r\n                                                work[i + 2] = -sigma;\r\n                        split = i \/ 4;\r\n                        diagMax = 0;\r\n                        offDiagMin = work[i + 6];\r\n                        previousEMin = work[i + 7];\r\n                    } else {\r\n                        diagMax = Math.max(diagMax, work[i + 4]);\r\n                        offDiagMin = Math.min(offDiagMin, work[i + 2]);\r\n                        previousEMin = Math.min(previousEMin, work[i + 3]);\r\n                    }\r\n                }\r\n                work[4 * n0 - 2] = offDiagMin;\r\n                work[4 * n0 - 1] = previousEMin;\r\n                i0 = split + 1;\r\n            }\r\n        }\r\n    }\r\n}","lc":2.8181818182,"pi":1.6985645933,"ma":2.4,"nbd":1.5,"ml":2.0,"d":7.4186507937,"mi":-1.2455250176,"fo":0.5,"r":-0.0263157895,"e":43.4506295995}
{"project_name":"Lang","project_version":"46","label":0,"code":"\/**\r\n * <p>Worker method for the {@link #escapeJavaScript(String)} method.<\/p>\r\n *\r\n * @param str String to escape values in, may be null\r\n * @param escapeSingleQuotes escapes single quotes if <code>true<\/code>\r\n * @param escapeForwardSlash TODO\r\n * @return the escaped string\r\n *\/\r\nprivate static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    try {\r\n        StringWriter writer = new StringWriter(str.length() * 2);\r\n        escapeJavaStyleString(writer, str, escapeSingleQuotes);\r\n        return writer.toString();\r\n    } catch (IOException ioe) {\r\n        \/\/ this should never ever happen while writing to a StringWriter\r\n        ioe.printStackTrace();\r\n        return null;\r\n    }\r\n}","code_comment":"\/**\r\n * <p>Worker method for the {@link #escapeJavaScript(String)} method.<\/p>\r\n *\r\n * @param str String to escape values in, may be null\r\n * @param escapeSingleQuotes escapes single quotes if <code>true<\/code>\r\n * @param escapeForwardSlash TODO\r\n * @return the escaped string\r\n *\/\r\n","code_no_comment":"private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    try {\r\n        StringWriter writer = new StringWriter(str.length() * 2);\r\n        escapeJavaStyleString(writer, str, escapeSingleQuotes);\r\n        return writer.toString();\r\n    } catch (IOException ioe) {\r\n                ioe.printStackTrace();\r\n        return null;\r\n    }\r\n}","lc":-0.0454545455,"pi":-0.04784689,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":0.003968254,"mi":0.0869626498,"fo":-0.1666666667,"r":0.5526315789,"e":-0.0613013837}
{"project_name":"Time","project_version":"17","label":2,"code":"\/**\r\n * Adjusts the offset to be the earlier or later one during an overlap.\r\n *\r\n * @param instant  the instant to adjust\r\n * @param earlierOrLater  false for earlier, true for later\r\n * @return the adjusted instant millis\r\n *\/\r\npublic long adjustOffset(long instant, boolean earlierOrLater) {\r\n    \/\/ a bit messy, but will work in all non-pathological cases\r\n    \/\/ evaluate 3 hours before and after to work out if anything is happening\r\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\r\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\r\n    if (instantBefore == instantAfter) {\r\n        \/\/ not an overlap (less than is a gap, equal is normal case)\r\n        return instant;\r\n    }\r\n    \/\/ work out range of instants that have duplicate local times\r\n    long local = convertUTCToLocal(instant);\r\n    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\r\n\/\/ calculate result\r\n\/\/ currently in later offset\r\n\/\/ currently in earlier offset\r\n}","code_comment":"\/**\r\n * Adjusts the offset to be the earlier or later one during an overlap.\r\n *\r\n * @param instant  the instant to adjust\r\n * @param earlierOrLater  false for earlier, true for later\r\n * @return the adjusted instant millis\r\n *\/\r\n","code_no_comment":"public long adjustOffset(long instant, boolean earlierOrLater) {\r\n            long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\r\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\r\n    if (instantBefore == instantAfter) {\r\n                return instant;\r\n    }\r\n        long local = convertUTCToLocal(instant);\r\n    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\r\n}","lc":-0.2272727273,"pi":-0.3444976077,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":0.4900793651,"mi":0.2202959831,"fo":-0.1666666667,"r":0.1315789474,"e":0.1353388312}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5147_184e51e9","label":1,"code":"\/**\r\n *  Gets whether the page is stateless. Components on stateless page must not render any stateful\r\n *  urls, and components on stateful page must not render any stateless urls. Stateful urls are\r\n *  urls, which refer to a certain (current) page instance.\r\n *\r\n *  @return Whether this page is stateless\r\n *\/\r\n@Override\r\npublic final boolean isPageStateless() {\r\n    if (isBookmarkable() == false) {\r\n        stateless = Boolean.FALSE;\r\n        if (getStatelessHint()) {\r\n            log.warn(\"Page '\" + this + \"' is not stateless because it is not bookmarkable, \" + \"but the stateless hint is set to true!\");\r\n        }\r\n    }\r\n    if (getStatelessHint() == false) {\r\n        return false;\r\n    }\r\n    if (stateless == null) {\r\n        if (isStateless() == false) {\r\n            stateless = Boolean.FALSE;\r\n        }\r\n    }\r\n    if (stateless == null) {\r\n        Component statefulComponent = visitChildren(Component.class, new IVisitor<Component, Component>() {\r\n\r\n            @Override\r\n            public void component(final Component component, final IVisit<Component> visit) {\r\n                if (!component.isStateless()) {\r\n                    visit.stop(component);\r\n                }\r\n            }\r\n        });\r\n        stateless = statefulComponent == null;\r\n        if (log.isDebugEnabled() && !stateless.booleanValue() && getStatelessHint()) {\r\n            log.debug(\"Page '{}' is not stateless because of component with path '{}'.\", this, statefulComponent.getPageRelativePath());\r\n        }\r\n    }\r\n    return stateless;\r\n}","code_comment":"\/**\r\n *  Gets whether the page is stateless. Components on stateless page must not render any stateful\r\n *  urls, and components on stateful page must not render any stateless urls. Stateful urls are\r\n *  urls, which refer to a certain (current) page instance.\r\n *\r\n *  @return Whether this page is stateless\r\n *\/\r\n","code_no_comment":"@Override\r\npublic final boolean isPageStateless() {\r\n    if (isBookmarkable() == false) {\r\n        stateless = Boolean.FALSE;\r\n        if (getStatelessHint()) {\r\n            log.warn(\"Page '\" + this + \"' is not stateless because it is not bookmarkable, \" + \"but the stateless hint is set to true!\");\r\n        }\r\n    }\r\n    if (getStatelessHint() == false) {\r\n        return false;\r\n    }\r\n    if (stateless == null) {\r\n        if (isStateless() == false) {\r\n            stateless = Boolean.FALSE;\r\n        }\r\n    }\r\n    if (stateless == null) {\r\n        Component statefulComponent = visitChildren(Component.class, new IVisitor<Component, Component>() {\r\n\r\n            @Override\r\n            public void component(final Component component, final IVisit<Component> visit) {\r\n                if (!component.isStateless()) {\r\n                    visit.stop(component);\r\n                }\r\n            }\r\n        });\r\n        stateless = statefulComponent == null;\r\n        if (log.isDebugEnabled() && !stateless.booleanValue() && getStatelessHint()) {\r\n            log.debug(\"Page '{}' is not stateless because of component with path '{}'.\", this, statefulComponent.getPageRelativePath());\r\n        }\r\n    }\r\n    return stateless;\r\n}","lc":0.8181818182,"pi":0.8086124402,"ma":1.0,"nbd":0.5,"ml":1.0,"d":0.4424603175,"mi":-0.5306553911,"fo":0.5833333333,"r":-0.0263157895,"e":0.5338981}
{"project_name":"Math","project_version":"9","label":1,"code":"\/**\r\n * Get a line with reversed direction.\r\n * @return a new instance, with reversed direction\r\n *\/\r\npublic Line revert() {\r\n    final Line reverted = new Line(zero, zero.subtract(direction));\r\n    return reverted;\r\n}","code_comment":"\/**\r\n * Get a line with reversed direction.\r\n * @return a new instance, with reversed direction\r\n *\/\r\n","code_no_comment":"public Line revert() {\r\n    final Line reverted = new Line(zero, zero.subtract(direction));\r\n    return reverted;\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8128259338,"fo":-0.4166666667,"r":2.4736842105,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4658_ef3adb12","label":3,"code":"\/**\r\n *  Generates a loop item used to represent a specific tab's <code>li<\/code> element.\r\n *\r\n *  @param tabIndex\r\n *  @return new loop item\r\n *\/\r\nprotected LoopItem newTabContainer(final int tabIndex) {\r\n    return new LoopItem(tabIndex) {\r\n\r\n        private static final long serialVersionUID = 1L;\r\n\r\n        @Override\r\n        protected void onComponentTag(final ComponentTag tag) {\r\n            super.onComponentTag(tag);\r\n            String cssClass = tag.getAttribute(\"class\");\r\n            if (cssClass == null) {\r\n                cssClass = \" \";\r\n            }\r\n            cssClass += \" tab\" + getIndex();\r\n            if (getIndex() == getSelectedTab()) {\r\n                cssClass += ' ' + getSelectedTabCssClass();\r\n            }\r\n            if (getIndex() == getTabs().size() - 1) {\r\n                cssClass += ' ' + getLastTabCssClass();\r\n            }\r\n            tag.put(\"class\", cssClass.trim());\r\n        }\r\n\r\n        @Override\r\n        public boolean isVisible() {\r\n            return getTabs().get(tabIndex).isVisible();\r\n        }\r\n    };\r\n}","code_comment":"\/**\r\n *  Generates a loop item used to represent a specific tab's <code>li<\/code> element.\r\n *\r\n *  @param tabIndex\r\n *  @return new loop item\r\n *\/\r\n","code_no_comment":"protected LoopItem newTabContainer(final int tabIndex) {\r\n    return new LoopItem(tabIndex) {\r\n\r\n        private static final long serialVersionUID = 1L;\r\n\r\n        @Override\r\n        protected void onComponentTag(final ComponentTag tag) {\r\n            super.onComponentTag(tag);\r\n            String cssClass = tag.getAttribute(\"class\");\r\n            if (cssClass == null) {\r\n                cssClass = \" \";\r\n            }\r\n            cssClass += \" tab\" + getIndex();\r\n            if (getIndex() == getSelectedTab()) {\r\n                cssClass += ' ' + getSelectedTabCssClass();\r\n            }\r\n            if (getIndex() == getTabs().size() - 1) {\r\n                cssClass += ' ' + getLastTabCssClass();\r\n            }\r\n            tag.put(\"class\", cssClass.trim());\r\n        }\r\n\r\n        @Override\r\n        public boolean isVisible() {\r\n            return getTabs().get(tabIndex).isVisible();\r\n        }\r\n    };\r\n}","lc":0.5,"pi":0.6028708134,"ma":0.0,"nbd":0.0,"ml":0.1666666667,"d":0.3293650794,"mi":-0.3603946441,"fo":0.75,"r":0.3684210526,"e":0.341868225}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-1897_8ee095bf","label":1,"code":"@Override\r\npublic void processEvents(RequestCycle requestCycle) {\r\n    Page page = getPage();\r\n    if (page == null) {\r\n        page = Session.get().getPage(getPageMapName(), componentPath, -1);\r\n        if (page != null) {\r\n            setPage(page);\r\n        } else if (page == null) {\r\n            page = getPage(requestCycle);\r\n        }\r\n    }\r\n    if (page == null) {\r\n        throw new PageExpiredException(\"Request cannot be processed. The target page does not exist anymore.\");\r\n    }\r\n    final String pageRelativeComponentPath = Strings.afterFirstPathComponent(componentPath, Component.PATH_SEPARATOR);\r\n    Component component = page.get(pageRelativeComponentPath);\r\n    if (component == null) {\r\n        \/\/ this is quite a hack to get components in repeater work.\r\n        \/\/ But it still can fail if the repeater is a paging one or on every render\r\n        \/\/ it will generate new index for the items...\r\n        page.prepareForRender(false);\r\n        component = page.get(pageRelativeComponentPath);\r\n        if (component == null) {\r\n            throw new WicketRuntimeException(\"unable to find component with path \" + pageRelativeComponentPath + \" on stateless page \" + page + \" it could be that the component is inside a repeater make your component return false in getStatelessHint()\");\r\n        }\r\n    }\r\n    RequestListenerInterface listenerInterface = RequestListenerInterface.forName(interfaceName);\r\n    if (listenerInterface == null) {\r\n        throw new WicketRuntimeException(\"unable to find listener interface \" + interfaceName);\r\n    }\r\n    listenerInterface.invoke(page, component);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void processEvents(RequestCycle requestCycle) {\r\n    Page page = getPage();\r\n    if (page == null) {\r\n        page = Session.get().getPage(getPageMapName(), componentPath, -1);\r\n        if (page != null) {\r\n            setPage(page);\r\n        } else if (page == null) {\r\n            page = getPage(requestCycle);\r\n        }\r\n    }\r\n    if (page == null) {\r\n        throw new PageExpiredException(\"Request cannot be processed. The target page does not exist anymore.\");\r\n    }\r\n    final String pageRelativeComponentPath = Strings.afterFirstPathComponent(componentPath, Component.PATH_SEPARATOR);\r\n    Component component = page.get(pageRelativeComponentPath);\r\n    if (component == null) {\r\n                                page.prepareForRender(false);\r\n        component = page.get(pageRelativeComponentPath);\r\n        if (component == null) {\r\n            throw new WicketRuntimeException(\"unable to find component with path \" + pageRelativeComponentPath + \" on stateless page \" + page + \" it could be that the component is inside a repeater make your component return false in getStatelessHint()\");\r\n        }\r\n    }\r\n    RequestListenerInterface listenerInterface = RequestListenerInterface.forName(interfaceName);\r\n    if (listenerInterface == null) {\r\n        throw new WicketRuntimeException(\"unable to find listener interface \" + interfaceName);\r\n    }\r\n    listenerInterface.invoke(page, component);\r\n}","lc":0.6818181818,"pi":0.1244019139,"ma":1.4,"nbd":0.5,"ml":0.4166666667,"d":0.4404761905,"mi":-0.5371388302,"fo":0.5,"r":-0.0263157895,"e":0.7387631611}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-43_668f08f2","label":1,"code":"public String commit(String path, String jsonDiff, String revision, String message) throws MicroKernelException {\r\n    if (rep == null) {\r\n        throw new IllegalStateException(\"this instance has already been disposed\");\r\n    }\r\n    if (path.length() > 0 && !PathUtils.isAbsolute(path)) {\r\n        throw new IllegalArgumentException(\"absolute path expected: \" + path);\r\n    }\r\n    Id revisionId = revision == null ? getHeadRevisionId() : Id.fromString(revision);\r\n    try {\r\n        JsopTokenizer t = new JsopTokenizer(jsonDiff);\r\n        CommitBuilder cb = rep.getCommitBuilder(revisionId, message);\r\n        while (true) {\r\n            int r = t.read();\r\n            if (r == JsopTokenizer.END) {\r\n                break;\r\n            }\r\n            \/\/ used for error reporting\r\n            int pos;\r\n            switch(r) {\r\n                case '+':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        t.read(':');\r\n                        if (t.matches('{')) {\r\n                            String nodePath = PathUtils.concat(path, subPath);\r\n                            if (!PathUtils.isAbsolute(nodePath)) {\r\n                                throw new Exception(\"absolute path expected: \" + nodePath + \", pos: \" + pos);\r\n                            }\r\n                            String parentPath = PathUtils.getParentPath(nodePath);\r\n                            String nodeName = PathUtils.getName(nodePath);\r\n                            \/\/ build the list of added nodes recursively\r\n                            LinkedList<AddNodeOperation> list = new LinkedList<AddNodeOperation>();\r\n                            addNode(list, parentPath, nodeName, t);\r\n                            for (AddNodeOperation op : list) {\r\n                                cb.addNode(op.path, op.name, op.props);\r\n                            }\r\n                        } else {\r\n                            String value;\r\n                            if (t.matches(JsopTokenizer.NULL)) {\r\n                                value = null;\r\n                            } else {\r\n                                value = t.readRawValue().trim();\r\n                            }\r\n                            String targetPath = PathUtils.concat(path, subPath);\r\n                            if (!PathUtils.isAbsolute(targetPath)) {\r\n                                throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                            }\r\n                            String parentPath = PathUtils.getParentPath(targetPath);\r\n                            String propName = PathUtils.getName(targetPath);\r\n                            cb.setProperty(parentPath, propName, value);\r\n                        }\r\n                        break;\r\n                    }\r\n                case '-':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        String targetPath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(targetPath)) {\r\n                            throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                        }\r\n                        cb.removeNode(targetPath);\r\n                        break;\r\n                    }\r\n                case '^':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        t.read(':');\r\n                        String value;\r\n                        if (t.matches(JsopTokenizer.NULL)) {\r\n                            value = null;\r\n                        } else {\r\n                            value = t.readRawValue().trim();\r\n                        }\r\n                        String targetPath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(targetPath)) {\r\n                            throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                        }\r\n                        String parentPath = PathUtils.getParentPath(targetPath);\r\n                        String propName = PathUtils.getName(targetPath);\r\n                        cb.setProperty(parentPath, propName, value);\r\n                        break;\r\n                    }\r\n                case '>':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        String srcPath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(srcPath)) {\r\n                            throw new Exception(\"absolute path expected: \" + srcPath + \", pos: \" + pos);\r\n                        }\r\n                        t.read(':');\r\n                        pos = t.getLastPos();\r\n                        String targetPath = t.readString();\r\n                        if (!PathUtils.isAbsolute(targetPath)) {\r\n                            targetPath = PathUtils.concat(path, targetPath);\r\n                            if (!PathUtils.isAbsolute(targetPath)) {\r\n                                throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                            }\r\n                        }\r\n                        cb.moveNode(srcPath, targetPath);\r\n                        break;\r\n                    }\r\n                case '*':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        String srcPath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(srcPath)) {\r\n                            throw new Exception(\"absolute path expected: \" + srcPath + \", pos: \" + pos);\r\n                        }\r\n                        t.read(':');\r\n                        pos = t.getLastPos();\r\n                        String targetPath = t.readString();\r\n                        if (!PathUtils.isAbsolute(targetPath)) {\r\n                            targetPath = PathUtils.concat(path, targetPath);\r\n                            if (!PathUtils.isAbsolute(targetPath)) {\r\n                                throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                            }\r\n                        }\r\n                        cb.copyNode(srcPath, targetPath);\r\n                        break;\r\n                    }\r\n                default:\r\n                    throw new AssertionError(\"token type: \" + t.getTokenType());\r\n            }\r\n        }\r\n        Id newHead = cb.doCommit();\r\n        if (!newHead.equals(revisionId)) {\r\n            \/\/ non-empty commit\r\n            gate.commit(newHead.toString());\r\n        }\r\n        return newHead.toString();\r\n    } catch (Exception e) {\r\n        throw new MicroKernelException(e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public String commit(String path, String jsonDiff, String revision, String message) throws MicroKernelException {\r\n    if (rep == null) {\r\n        throw new IllegalStateException(\"this instance has already been disposed\");\r\n    }\r\n    if (path.length() > 0 && !PathUtils.isAbsolute(path)) {\r\n        throw new IllegalArgumentException(\"absolute path expected: \" + path);\r\n    }\r\n    Id revisionId = revision == null ? getHeadRevisionId() : Id.fromString(revision);\r\n    try {\r\n        JsopTokenizer t = new JsopTokenizer(jsonDiff);\r\n        CommitBuilder cb = rep.getCommitBuilder(revisionId, message);\r\n        while (true) {\r\n            int r = t.read();\r\n            if (r == JsopTokenizer.END) {\r\n                break;\r\n            }\r\n                        int pos;\r\n            switch(r) {\r\n                case '+':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        t.read(':');\r\n                        if (t.matches('{')) {\r\n                            String nodePath = PathUtils.concat(path, subPath);\r\n                            if (!PathUtils.isAbsolute(nodePath)) {\r\n                                throw new Exception(\"absolute path expected: \" + nodePath + \", pos: \" + pos);\r\n                            }\r\n                            String parentPath = PathUtils.getParentPath(nodePath);\r\n                            String nodeName = PathUtils.getName(nodePath);\r\n                                                        LinkedList<AddNodeOperation> list = new LinkedList<AddNodeOperation>();\r\n                            addNode(list, parentPath, nodeName, t);\r\n                            for (AddNodeOperation op : list) {\r\n                                cb.addNode(op.path, op.name, op.props);\r\n                            }\r\n                        } else {\r\n                            String value;\r\n                            if (t.matches(JsopTokenizer.NULL)) {\r\n                                value = null;\r\n                            } else {\r\n                                value = t.readRawValue().trim();\r\n                            }\r\n                            String targetPath = PathUtils.concat(path, subPath);\r\n                            if (!PathUtils.isAbsolute(targetPath)) {\r\n                                throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                            }\r\n                            String parentPath = PathUtils.getParentPath(targetPath);\r\n                            String propName = PathUtils.getName(targetPath);\r\n                            cb.setProperty(parentPath, propName, value);\r\n                        }\r\n                        break;\r\n                    }\r\n                case '-':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        String targetPath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(targetPath)) {\r\n                            throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                        }\r\n                        cb.removeNode(targetPath);\r\n                        break;\r\n                    }\r\n                case '^':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        t.read(':');\r\n                        String value;\r\n                        if (t.matches(JsopTokenizer.NULL)) {\r\n                            value = null;\r\n                        } else {\r\n                            value = t.readRawValue().trim();\r\n                        }\r\n                        String targetPath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(targetPath)) {\r\n                            throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                        }\r\n                        String parentPath = PathUtils.getParentPath(targetPath);\r\n                        String propName = PathUtils.getName(targetPath);\r\n                        cb.setProperty(parentPath, propName, value);\r\n                        break;\r\n                    }\r\n                case '>':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        String srcPath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(srcPath)) {\r\n                            throw new Exception(\"absolute path expected: \" + srcPath + \", pos: \" + pos);\r\n                        }\r\n                        t.read(':');\r\n                        pos = t.getLastPos();\r\n                        String targetPath = t.readString();\r\n                        if (!PathUtils.isAbsolute(targetPath)) {\r\n                            targetPath = PathUtils.concat(path, targetPath);\r\n                            if (!PathUtils.isAbsolute(targetPath)) {\r\n                                throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                            }\r\n                        }\r\n                        cb.moveNode(srcPath, targetPath);\r\n                        break;\r\n                    }\r\n                case '*':\r\n                    {\r\n                        pos = t.getLastPos();\r\n                        String subPath = t.readString();\r\n                        String srcPath = PathUtils.concat(path, subPath);\r\n                        if (!PathUtils.isAbsolute(srcPath)) {\r\n                            throw new Exception(\"absolute path expected: \" + srcPath + \", pos: \" + pos);\r\n                        }\r\n                        t.read(':');\r\n                        pos = t.getLastPos();\r\n                        String targetPath = t.readString();\r\n                        if (!PathUtils.isAbsolute(targetPath)) {\r\n                            targetPath = PathUtils.concat(path, targetPath);\r\n                            if (!PathUtils.isAbsolute(targetPath)) {\r\n                                throw new Exception(\"absolute path expected: \" + targetPath + \", pos: \" + pos);\r\n                            }\r\n                        }\r\n                        cb.copyNode(srcPath, targetPath);\r\n                        break;\r\n                    }\r\n                default:\r\n                    throw new AssertionError(\"token type: \" + t.getTokenType());\r\n            }\r\n        }\r\n        Id newHead = cb.doCommit();\r\n        if (!newHead.equals(revisionId)) {\r\n                        gate.commit(newHead.toString());\r\n        }\r\n        return newHead.toString();\r\n    } catch (Exception e) {\r\n        throw new MicroKernelException(e);\r\n    }\r\n}","lc":5.5454545455,"pi":2.3827751196,"ma":8.4,"nbd":2.0,"ml":3.0,"d":2.3373015873,"mi":-1.7210711769,"fo":5.1666666667,"r":-0.0263157895,"e":16.6498204849}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-546_428e32c6","label":1,"code":"\/**\r\n * Execute a query and get the result.\r\n *\r\n * @param statement the query statement\r\n * @param language the language\r\n * @param limit the maximum result set size\r\n * @param offset the number of rows to skip\r\n * @param bindings the bind variable value bindings\r\n * @param namePathMapper the name and path mapper to use\r\n * @return the result\r\n * @throws ParseException if the statement could not be parsed\r\n * @throws IllegalArgumentException if there was an error executing the query\r\n *\/\r\nResult executeQuery(String statement, String language, long limit, long offset, Map<String, ? extends PropertyValue> bindings, NamePathMapper namePathMapper) throws ParseException;","code_comment":"\/**\r\n * Execute a query and get the result.\r\n *\r\n * @param statement the query statement\r\n * @param language the language\r\n * @param limit the maximum result set size\r\n * @param offset the number of rows to skip\r\n * @param bindings the bind variable value bindings\r\n * @param namePathMapper the name and path mapper to use\r\n * @return the result\r\n * @throws ParseException if the statement could not be parsed\r\n * @throws IllegalArgumentException if there was an error executing the query\r\n *\/\r\n","code_no_comment":"Result executeQuery(String statement, String language, long limit, long offset, Map<String, ? extends PropertyValue> bindings, NamePathMapper namePathMapper) throws ParseException;","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.3687103594,"fo":-0.5,"r":1.5789473684,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2388_487de751","label":1,"code":"public void readBytes(byte[] b, int offset, int len) throws IOException {\r\n    checkPositionIndexes(offset, offset + len, checkNotNull(b).length);\r\n    if (len < 0 || position + len > length) {\r\n        throw new IOException(\"Invalid byte range request\");\r\n    }\r\n    int i = (int) (position \/ blobSize);\r\n    int o = (int) (position % blobSize);\r\n    while (len > 0) {\r\n        loadBlob(i);\r\n        int l = Math.min(len, blobSize - o);\r\n        System.arraycopy(blob, o, b, offset, l);\r\n        offset += l;\r\n        len -= l;\r\n        position += l;\r\n        i++;\r\n        o = 0;\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void readBytes(byte[] b, int offset, int len) throws IOException {\r\n    checkPositionIndexes(offset, offset + len, checkNotNull(b).length);\r\n    if (len < 0 || position + len > length) {\r\n        throw new IOException(\"Invalid byte range request\");\r\n    }\r\n    int i = (int) (position \/ blobSize);\r\n    int o = (int) (position % blobSize);\r\n    while (len > 0) {\r\n        loadBlob(i);\r\n        int l = Math.min(len, blobSize - o);\r\n        System.arraycopy(blob, o, b, offset, l);\r\n        offset += l;\r\n        len -= l;\r\n        position += l;\r\n        i++;\r\n        o = 0;\r\n    }\r\n}","lc":0.1818181818,"pi":-0.1339712919,"ma":0.0,"nbd":-0.5,"ml":0.0833333333,"d":1.9801587302,"mi":-0.2262156448,"fo":-0.0833333333,"r":0.0,"e":1.7336560571}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-412_be2fdba7","label":1,"code":"\/**\r\n * Returns top key. Can be called 0 or more times without affecting behavior of next() or hasTop().\r\n *\r\n * @return <tt>K<\/tt>\r\n * @exception IllegalStateException\r\n *              if called before seek.\r\n * @exception NoSuchElementException\r\n *              if top element doesn't exist.\r\n *\/\r\nK getTopKey();","code_comment":"\/**\r\n * Returns top key. Can be called 0 or more times without affecting behavior of next() or hasTop().\r\n *\r\n * @return <tt>K<\/tt>\r\n * @exception IllegalStateException\r\n *              if called before seek.\r\n * @exception NoSuchElementException\r\n *              if top element doesn't exist.\r\n *\/\r\n","code_no_comment":"K getTopKey();","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.7424947146,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"Closure","project_version":"114","label":2,"code":"private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\r\n    Node nameNode = n.getFirstChild();\r\n    Node parent = n.getParent();\r\n    NameInformation ns = createNameInformation(t, nameNode);\r\n    if (ns != null) {\r\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\r\n            \/\/ logic.\r\n            if (parent.getFirstChild().getNext() != n) {\r\n                recordDepScope(recordNode, ns);\r\n            } else {\r\n                recordDepScope(nameNode, ns);\r\n            }\r\n        } else {\r\n            \/\/ The rhs of the assignment is the caller, so it's used by the\r\n            \/\/ context. Don't associate it w\/ the lhs.\r\n            \/\/ FYI: this fixes only the specific case where the assignment is the\r\n            \/\/ caller expression, but it could be nested deeper in the caller and\r\n            \/\/ we would still get a bug.\r\n            \/\/ See testAssignWithCall2 for an example of this.\r\n            recordDepScope(recordNode, ns);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\r\n    Node nameNode = n.getFirstChild();\r\n    Node parent = n.getParent();\r\n    NameInformation ns = createNameInformation(t, nameNode);\r\n    if (ns != null) {\r\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\r\n                        if (parent.getFirstChild().getNext() != n) {\r\n                recordDepScope(recordNode, ns);\r\n            } else {\r\n                recordDepScope(nameNode, ns);\r\n            }\r\n        } else {\r\n                                                                                    recordDepScope(recordNode, ns);\r\n        }\r\n    }\r\n}","lc":0.0909090909,"pi":0.956937799,"ma":0.0,"nbd":0.5,"ml":0.4166666667,"d":0.4484126984,"mi":-0.1050035236,"fo":0.3333333333,"r":-0.0263157895,"e":0.2532067795}
{"project_name":"JxPath","project_version":"5","label":1,"code":"private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2) {\r\n    if (depth1 < depth2) {\r\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\r\n        return r == 0 ? -1 : r;\r\n    }\r\n    if (depth1 > depth2) {\r\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\r\n        return r == 0 ? 1 : r;\r\n    }\r\n    if (p1 == null && p2 == null) {\r\n        return 0;\r\n    }\r\n    if (p1 != null && p1.equals(p2)) {\r\n        return 0;\r\n    }\r\n    if (depth1 == 1) {\r\n        throw new JXPathException(\"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\");\r\n    }\r\n    int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\r\n    if (r != 0) {\r\n        return r;\r\n    }\r\n    return p1.parent.compareChildNodePointers(p1, p2);\r\n}","code_comment":null,"code_no_comment":"private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2) {\r\n    if (depth1 < depth2) {\r\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\r\n        return r == 0 ? -1 : r;\r\n    }\r\n    if (depth1 > depth2) {\r\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\r\n        return r == 0 ? 1 : r;\r\n    }\r\n    if (p1 == null && p2 == null) {\r\n        return 0;\r\n    }\r\n    if (p1 != null && p1.equals(p2)) {\r\n        return 0;\r\n    }\r\n    if (depth1 == 1) {\r\n        throw new JXPathException(\"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\");\r\n    }\r\n    int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\r\n    if (r != 0) {\r\n        return r;\r\n    }\r\n    return p1.parent.compareChildNodePointers(p1, p2);\r\n}","lc":0.4545454545,"pi":-0.2918660287,"ma":1.2,"nbd":-0.5,"ml":0.9166666667,"d":2.8531746032,"mi":-0.429739253,"fo":-0.0833333333,"r":-0.0263157895,"e":3.106582989}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1848_7164b2b6","label":0,"code":"\/**\r\n *  Recursively creates the directory specified by the provided path.\r\n *\r\n *  @return <code>true<\/code>if the directories either already existed or have been created successfully,\r\n *          <code>false<\/code> otherwise\r\n *  @throws IOException\r\n *          thrown if an error occurred while creating the directory\/directories\r\n *\/\r\npublic boolean mkdirs(final Path f) throws IOException {\r\n    final Path parent = f.getParent();\r\n    final File p2f = pathToFile(f);\r\n    return (parent == null || mkdirs(parent)) && (p2f.mkdir() || p2f.isDirectory());\r\n}","code_comment":"\/**\r\n *  Recursively creates the directory specified by the provided path.\r\n *\r\n *  @return <code>true<\/code>if the directories either already existed or have been created successfully,\r\n *          <code>false<\/code> otherwise\r\n *  @throws IOException\r\n *          thrown if an error occurred while creating the directory\/directories\r\n *\/\r\n","code_no_comment":"public boolean mkdirs(final Path f) throws IOException {\r\n    final Path parent = f.getParent();\r\n    final File p2f = pathToFile(f);\r\n    return (parent == null || mkdirs(parent)) && (p2f.mkdir() || p2f.isDirectory());\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":0.2757936508,"mi":0.5467230444,"fo":-0.0833333333,"r":2.3684210526,"e":0.0015882621}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5215_033eb6fe","label":3,"code":"public void loadContent(Exchange exchange, GenericFile<?> file) throws IOException {\r\n    if (content == null) {\r\n        try {\r\n            content = exchange.getContext().getTypeConverter().mandatoryConvertTo(byte[].class, file.getFile());\r\n        } catch (NoTypeConversionAvailableException e) {\r\n            throw new IOException(\"Cannot load file content: \" + file.getAbsoluteFilePath(), e);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void loadContent(Exchange exchange, GenericFile<?> file) throws IOException {\r\n    if (content == null) {\r\n        try {\r\n            content = exchange.getContext().getTypeConverter().mandatoryConvertTo(byte[].class, file.getFile());\r\n        } catch (NoTypeConversionAvailableException e) {\r\n            throw new IOException(\"Cannot load file content: \" + file.getAbsoluteFilePath(), e);\r\n        }\r\n    }\r\n}","lc":-0.2272727273,"pi":0.6076555024,"ma":0.0,"nbd":0.0,"ml":-0.25,"d":-0.0972222222,"mi":0.2560958421,"fo":-0.0833333333,"r":0.0263157895,"e":-0.0927024083}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-405_784e4f69","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\r\n    \/\/ arrays shared with the other private methods\r\n    solvedCols = Math.min(rows, cols);\r\n    diagR = new double[cols];\r\n    jacNorm = new double[cols];\r\n    beta = new double[cols];\r\n    permutation = new int[cols];\r\n    lmDir = new double[cols];\r\n    \/\/ local point\r\n    double delta = 0;\r\n    double xNorm = 0;\r\n    double[] diag = new double[cols];\r\n    double[] oldX = new double[cols];\r\n    double[] oldRes = new double[rows];\r\n    double[] work1 = new double[cols];\r\n    double[] work2 = new double[cols];\r\n    double[] work3 = new double[cols];\r\n    \/\/ evaluate the function at the starting point and calculate its norm\r\n    updateResidualsAndCost();\r\n    \/\/ outer loop\r\n    lmPar = 0;\r\n    boolean firstIteration = true;\r\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\r\n    while (true) {\r\n        incrementIterationsCounter();\r\n        \/\/ compute the Q.R. decomposition of the jacobian matrix\r\n        VectorialPointValuePair previous = current;\r\n        updateJacobian();\r\n        qrDecomposition();\r\n        \/\/ compute Qt.res\r\n        qTy(residuals);\r\n        \/\/ so let jacobian contain the R matrix with its diagonal elements\r\n        for (int k = 0; k < solvedCols; ++k) {\r\n            int pk = permutation[k];\r\n            jacobian[k][pk] = diagR[pk];\r\n        }\r\n        if (firstIteration) {\r\n            \/\/ scale the point according to the norms of the columns\r\n            \/\/ of the initial jacobian\r\n            xNorm = 0;\r\n            for (int k = 0; k < cols; ++k) {\r\n                double dk = jacNorm[k];\r\n                if (dk == 0) {\r\n                    dk = 1.0;\r\n                }\r\n                double xk = dk * point[k];\r\n                xNorm += xk * xk;\r\n                diag[k] = dk;\r\n            }\r\n            xNorm = Math.sqrt(xNorm);\r\n            \/\/ initialize the step bound delta\r\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\r\n        }\r\n        \/\/ check orthogonality between function vector and jacobian columns\r\n        double maxCosine = 0;\r\n        if (cost != 0) {\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                double s = jacNorm[pj];\r\n                if (s != 0) {\r\n                    double sum = 0;\r\n                    for (int i = 0; i <= j; ++i) {\r\n                        sum += jacobian[i][pj] * residuals[i];\r\n                    }\r\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) \/ (s * cost));\r\n                }\r\n            }\r\n        }\r\n        if (maxCosine <= orthoTolerance) {\r\n            \/\/ convergence has been reached\r\n            return current;\r\n        }\r\n        \/\/ rescale if necessary\r\n        for (int j = 0; j < cols; ++j) {\r\n            diag[j] = Math.max(diag[j], jacNorm[j]);\r\n        }\r\n        \/\/ inner loop\r\n        for (double ratio = 0; ratio < 1.0e-4; ) {\r\n            \/\/ save the state\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                oldX[pj] = point[pj];\r\n            }\r\n            double previousCost = cost;\r\n            double[] tmpVec = residuals;\r\n            residuals = oldRes;\r\n            oldRes = tmpVec;\r\n            \/\/ determine the Levenberg-Marquardt parameter\r\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\r\n            \/\/ compute the new point and the norm of the evolution direction\r\n            double lmNorm = 0;\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                lmDir[pj] = -lmDir[pj];\r\n                point[pj] = oldX[pj] + lmDir[pj];\r\n                double s = diag[pj] * lmDir[pj];\r\n                lmNorm += s * s;\r\n            }\r\n            lmNorm = Math.sqrt(lmNorm);\r\n            \/\/ on the first iteration, adjust the initial step bound.\r\n            if (firstIteration) {\r\n                delta = Math.min(delta, lmNorm);\r\n            }\r\n            \/\/ evaluate the function at x + p and calculate its norm\r\n            updateResidualsAndCost();\r\n            current = new VectorialPointValuePair(point, objective);\r\n            \/\/ compute the scaled actual reduction\r\n            double actRed = -1.0;\r\n            if (0.1 * cost < previousCost) {\r\n                double r = cost \/ previousCost;\r\n                actRed = 1.0 - r * r;\r\n            }\r\n            \/\/ and the scaled directional derivative\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                double dirJ = lmDir[pj];\r\n                work1[j] = 0;\r\n                for (int i = 0; i <= j; ++i) {\r\n                    work1[i] += jacobian[i][pj] * dirJ;\r\n                }\r\n            }\r\n            double coeff1 = 0;\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                coeff1 += work1[j] * work1[j];\r\n            }\r\n            double pc2 = previousCost * previousCost;\r\n            coeff1 = coeff1 \/ pc2;\r\n            double coeff2 = lmPar * lmNorm * lmNorm \/ pc2;\r\n            double preRed = coeff1 + 2 * coeff2;\r\n            double dirDer = -(coeff1 + coeff2);\r\n            \/\/ ratio of the actual to the predicted reduction\r\n            ratio = (preRed == 0) ? 0 : (actRed \/ preRed);\r\n            \/\/ update the step bound\r\n            if (ratio <= 0.25) {\r\n                double tmp = (actRed < 0) ? (0.5 * dirDer \/ (dirDer + 0.5 * actRed)) : 0.5;\r\n                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\r\n                    tmp = 0.1;\r\n                }\r\n                delta = tmp * Math.min(delta, 10.0 * lmNorm);\r\n                lmPar \/= tmp;\r\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\r\n                delta = 2 * lmNorm;\r\n                lmPar *= 0.5;\r\n            }\r\n            \/\/ test for successful iteration.\r\n            if (ratio >= 1.0e-4) {\r\n                \/\/ successful iteration, update the norm\r\n                firstIteration = false;\r\n                xNorm = 0;\r\n                for (int k = 0; k < cols; ++k) {\r\n                    double xK = diag[k] * point[k];\r\n                    xNorm += xK * xK;\r\n                }\r\n                xNorm = Math.sqrt(xNorm);\r\n            } else {\r\n                \/\/ failed iteration, reset the previous values\r\n                cost = previousCost;\r\n                for (int j = 0; j < solvedCols; ++j) {\r\n                    int pj = permutation[j];\r\n                    point[pj] = oldX[pj];\r\n                }\r\n                tmpVec = residuals;\r\n                residuals = oldRes;\r\n                oldRes = tmpVec;\r\n            }\r\n            \/\/ tests for convergence.\r\n            if (checker != null) {\r\n                \/\/ we use the vectorial convergence checker\r\n                if (checker.converged(getIterations(), previous, current)) {\r\n                    return current;\r\n                }\r\n            } else {\r\n                \/\/ we use the Levenberg-Marquardt specific convergence parameters\r\n                if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {\r\n                    return current;\r\n                }\r\n            }\r\n            \/\/ (2.2204e-16 is the machine epsilon for IEEE754)\r\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\r\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\r\n            } else if (delta <= 2.2204e-16 * xNorm) {\r\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\r\n            } else if (maxCosine <= 2.2204e-16) {\r\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\r\n            }\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\r\n        solvedCols = Math.min(rows, cols);\r\n    diagR = new double[cols];\r\n    jacNorm = new double[cols];\r\n    beta = new double[cols];\r\n    permutation = new int[cols];\r\n    lmDir = new double[cols];\r\n        double delta = 0;\r\n    double xNorm = 0;\r\n    double[] diag = new double[cols];\r\n    double[] oldX = new double[cols];\r\n    double[] oldRes = new double[rows];\r\n    double[] work1 = new double[cols];\r\n    double[] work2 = new double[cols];\r\n    double[] work3 = new double[cols];\r\n        updateResidualsAndCost();\r\n        lmPar = 0;\r\n    boolean firstIteration = true;\r\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\r\n    while (true) {\r\n        incrementIterationsCounter();\r\n                VectorialPointValuePair previous = current;\r\n        updateJacobian();\r\n        qrDecomposition();\r\n                qTy(residuals);\r\n                for (int k = 0; k < solvedCols; ++k) {\r\n            int pk = permutation[k];\r\n            jacobian[k][pk] = diagR[pk];\r\n        }\r\n        if (firstIteration) {\r\n                                    xNorm = 0;\r\n            for (int k = 0; k < cols; ++k) {\r\n                double dk = jacNorm[k];\r\n                if (dk == 0) {\r\n                    dk = 1.0;\r\n                }\r\n                double xk = dk * point[k];\r\n                xNorm += xk * xk;\r\n                diag[k] = dk;\r\n            }\r\n            xNorm = Math.sqrt(xNorm);\r\n                        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\r\n        }\r\n                double maxCosine = 0;\r\n        if (cost != 0) {\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                double s = jacNorm[pj];\r\n                if (s != 0) {\r\n                    double sum = 0;\r\n                    for (int i = 0; i <= j; ++i) {\r\n                        sum += jacobian[i][pj] * residuals[i];\r\n                    }\r\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) \/ (s * cost));\r\n                }\r\n            }\r\n        }\r\n        if (maxCosine <= orthoTolerance) {\r\n                        return current;\r\n        }\r\n                for (int j = 0; j < cols; ++j) {\r\n            diag[j] = Math.max(diag[j], jacNorm[j]);\r\n        }\r\n                for (double ratio = 0; ratio < 1.0e-4; ) {\r\n                        for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                oldX[pj] = point[pj];\r\n            }\r\n            double previousCost = cost;\r\n            double[] tmpVec = residuals;\r\n            residuals = oldRes;\r\n            oldRes = tmpVec;\r\n                        determineLMParameter(oldRes, delta, diag, work1, work2, work3);\r\n                        double lmNorm = 0;\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                lmDir[pj] = -lmDir[pj];\r\n                point[pj] = oldX[pj] + lmDir[pj];\r\n                double s = diag[pj] * lmDir[pj];\r\n                lmNorm += s * s;\r\n            }\r\n            lmNorm = Math.sqrt(lmNorm);\r\n                        if (firstIteration) {\r\n                delta = Math.min(delta, lmNorm);\r\n            }\r\n                        updateResidualsAndCost();\r\n            current = new VectorialPointValuePair(point, objective);\r\n                        double actRed = -1.0;\r\n            if (0.1 * cost < previousCost) {\r\n                double r = cost \/ previousCost;\r\n                actRed = 1.0 - r * r;\r\n            }\r\n                        for (int j = 0; j < solvedCols; ++j) {\r\n                int pj = permutation[j];\r\n                double dirJ = lmDir[pj];\r\n                work1[j] = 0;\r\n                for (int i = 0; i <= j; ++i) {\r\n                    work1[i] += jacobian[i][pj] * dirJ;\r\n                }\r\n            }\r\n            double coeff1 = 0;\r\n            for (int j = 0; j < solvedCols; ++j) {\r\n                coeff1 += work1[j] * work1[j];\r\n            }\r\n            double pc2 = previousCost * previousCost;\r\n            coeff1 = coeff1 \/ pc2;\r\n            double coeff2 = lmPar * lmNorm * lmNorm \/ pc2;\r\n            double preRed = coeff1 + 2 * coeff2;\r\n            double dirDer = -(coeff1 + coeff2);\r\n                        ratio = (preRed == 0) ? 0 : (actRed \/ preRed);\r\n                        if (ratio <= 0.25) {\r\n                double tmp = (actRed < 0) ? (0.5 * dirDer \/ (dirDer + 0.5 * actRed)) : 0.5;\r\n                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\r\n                    tmp = 0.1;\r\n                }\r\n                delta = tmp * Math.min(delta, 10.0 * lmNorm);\r\n                lmPar \/= tmp;\r\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\r\n                delta = 2 * lmNorm;\r\n                lmPar *= 0.5;\r\n            }\r\n                        if (ratio >= 1.0e-4) {\r\n                                firstIteration = false;\r\n                xNorm = 0;\r\n                for (int k = 0; k < cols; ++k) {\r\n                    double xK = diag[k] * point[k];\r\n                    xNorm += xK * xK;\r\n                }\r\n                xNorm = Math.sqrt(xNorm);\r\n            } else {\r\n                                cost = previousCost;\r\n                for (int j = 0; j < solvedCols; ++j) {\r\n                    int pj = permutation[j];\r\n                    point[pj] = oldX[pj];\r\n                }\r\n                tmpVec = residuals;\r\n                residuals = oldRes;\r\n                oldRes = tmpVec;\r\n            }\r\n                        if (checker != null) {\r\n                                if (checker.converged(getIterations(), previous, current)) {\r\n                    return current;\r\n                }\r\n            } else {\r\n                                if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {\r\n                    return current;\r\n                }\r\n            }\r\n                        if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\r\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\r\n            } else if (delta <= 2.2204e-16 * xNorm) {\r\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\r\n            } else if (maxCosine <= 2.2204e-16) {\r\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\r\n            }\r\n        }\r\n    }\r\n}","lc":6.5909090909,"pi":0.8995215311,"ma":6.8,"nbd":1.5,"ml":5.25,"d":7.0714285714,"mi":-1.8056377731,"fo":1.1666666667,"r":-0.0263157895,"e":71.9677114849}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5326_ded3c583","label":1,"code":"@Override\r\npublic IRequestHandler mapRequest(final Request request) {\r\n    Url url = decryptUrl(request, request.getUrl());\r\n    if (url == null) {\r\n        return wrappedMapper.mapRequest(request);\r\n    }\r\n    Request decryptedRequest = request.cloneWithUrl(url);\r\n    IRequestHandler handler = wrappedMapper.mapRequest(decryptedRequest);\r\n    if (handler != null) {\r\n        handler = new RequestSettingRequestHandler(decryptedRequest, handler);\r\n    }\r\n    return handler;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic IRequestHandler mapRequest(final Request request) {\r\n    Url url = decryptUrl(request, request.getUrl());\r\n    if (url == null) {\r\n        return wrappedMapper.mapRequest(request);\r\n    }\r\n    Request decryptedRequest = request.cloneWithUrl(url);\r\n    IRequestHandler handler = wrappedMapper.mapRequest(decryptedRequest);\r\n    if (handler != null) {\r\n        handler = new RequestSettingRequestHandler(decryptedRequest, handler);\r\n    }\r\n    return handler;\r\n}","lc":-0.0454545455,"pi":-0.2535885167,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":0.0555555556,"mi":0.0339675828,"fo":-0.0833333333,"r":0.0526315789,"e":0.0036721357}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2033_420ac965","label":3,"code":"\/**\r\n *  @see org.apache.wicket.behavior.AbstractAjaxBehavior#onComponentTag(org.apache.wicket.markup.ComponentTag)\r\n *\/\r\n@Override\r\nprotected void onComponentTag(final ComponentTag tag) {\r\n    super.onComponentTag(tag);\r\n    \/\/ only add the event handler when the component is enabled.\r\n    Component myComponent = getComponent();\r\n    if (myComponent.isEnabledInHierarchy()) {\r\n        tag.put(event, getEventHandler());\r\n    }\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.behavior.AbstractAjaxBehavior#onComponentTag(org.apache.wicket.markup.ComponentTag)\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void onComponentTag(final ComponentTag tag) {\r\n    super.onComponentTag(tag);\r\n        Component myComponent = getComponent();\r\n    if (myComponent.isEnabledInHierarchy()) {\r\n        tag.put(event, getEventHandler());\r\n    }\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.4080338266,"fo":-0.0833333333,"r":1.0526315789,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5716_2d0ec942","label":3,"code":"public ToolchainPrivate[] getToolchainsForType(String type, MavenSession context) throws MisconfiguredToolchainException {\r\n    DefaultToolchainsBuildingRequest buildRequest = new DefaultToolchainsBuildingRequest();\r\n    File globalToolchainsFile = context.getRequest().getGlobalToolchainsFile();\r\n    if (globalToolchainsFile != null && globalToolchainsFile.isFile()) {\r\n        buildRequest.setGlobalToolchainsSource(new FileSource(globalToolchainsFile));\r\n    }\r\n    File userToolchainsFile = context.getRequest().getUserToolchainsFile();\r\n    if (userToolchainsFile != null && userToolchainsFile.isFile()) {\r\n        buildRequest.setUserToolchainsSource(new FileSource(userToolchainsFile));\r\n    }\r\n    ToolchainsBuildingResult buildResult;\r\n    try {\r\n        buildResult = toolchainsBuilder.build(buildRequest);\r\n    } catch (ToolchainsBuildingException e) {\r\n        throw new MisconfiguredToolchainException(e.getMessage(), e);\r\n    }\r\n    PersistedToolchains pers = buildResult.getEffectiveToolchains();\r\n    List<ToolchainPrivate> toRet = new ArrayList<ToolchainPrivate>();\r\n    ToolchainFactory fact = factories.get(type);\r\n    if (fact == null) {\r\n        logger.error(\"Missing toolchain factory for type: \" + type + \". Possibly caused by misconfigured project.\");\r\n    } else if (pers != null) {\r\n        List<ToolchainModel> lst = pers.getToolchains();\r\n        if (lst != null) {\r\n            for (ToolchainModel toolchainModel : lst) {\r\n                if (type.equals(toolchainModel.getType())) {\r\n                    toRet.add(fact.createToolchain(toolchainModel));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (ToolchainFactory toolchainFactory : factories.values()) {\r\n        ToolchainPrivate tool = toolchainFactory.createDefaultToolchain();\r\n        if (tool != null) {\r\n            toRet.add(tool);\r\n        }\r\n    }\r\n    return toRet.toArray(new ToolchainPrivate[toRet.size()]);\r\n}","code_comment":null,"code_no_comment":"public ToolchainPrivate[] getToolchainsForType(String type, MavenSession context) throws MisconfiguredToolchainException {\r\n    DefaultToolchainsBuildingRequest buildRequest = new DefaultToolchainsBuildingRequest();\r\n    File globalToolchainsFile = context.getRequest().getGlobalToolchainsFile();\r\n    if (globalToolchainsFile != null && globalToolchainsFile.isFile()) {\r\n        buildRequest.setGlobalToolchainsSource(new FileSource(globalToolchainsFile));\r\n    }\r\n    File userToolchainsFile = context.getRequest().getUserToolchainsFile();\r\n    if (userToolchainsFile != null && userToolchainsFile.isFile()) {\r\n        buildRequest.setUserToolchainsSource(new FileSource(userToolchainsFile));\r\n    }\r\n    ToolchainsBuildingResult buildResult;\r\n    try {\r\n        buildResult = toolchainsBuilder.build(buildRequest);\r\n    } catch (ToolchainsBuildingException e) {\r\n        throw new MisconfiguredToolchainException(e.getMessage(), e);\r\n    }\r\n    PersistedToolchains pers = buildResult.getEffectiveToolchains();\r\n    List<ToolchainPrivate> toRet = new ArrayList<ToolchainPrivate>();\r\n    ToolchainFactory fact = factories.get(type);\r\n    if (fact == null) {\r\n        logger.error(\"Missing toolchain factory for type: \" + type + \". Possibly caused by misconfigured project.\");\r\n    } else if (pers != null) {\r\n        List<ToolchainModel> lst = pers.getToolchains();\r\n        if (lst != null) {\r\n            for (ToolchainModel toolchainModel : lst) {\r\n                if (type.equals(toolchainModel.getType())) {\r\n                    toRet.add(fact.createToolchain(toolchainModel));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (ToolchainFactory toolchainFactory : factories.values()) {\r\n        ToolchainPrivate tool = toolchainFactory.createDefaultToolchain();\r\n        if (tool != null) {\r\n            toRet.add(tool);\r\n        }\r\n    }\r\n    return toRet.toArray(new ToolchainPrivate[toRet.size()]);\r\n}","lc":1.1363636364,"pi":0.5789473684,"ma":1.6,"nbd":1.5,"ml":1.1666666667,"d":0.4067460317,"mi":-0.7443269908,"fo":1.4166666667,"r":-0.0263157895,"e":1.1890089498}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1662_3efb5cbf","label":0,"code":"@Nonnull\r\n@Override\r\npublic NodeState merge(@Nonnull NodeBuilder builder, @Nonnull CommitHook commitHook, @Nullable CommitInfo info) throws CommitFailedException {\r\n    return asDocumentRootBuilder(builder).merge(commitHook, info);\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\n@Override\r\npublic NodeState merge(@Nonnull NodeBuilder builder, @Nonnull CommitHook commitHook, @Nullable CommitInfo info) throws CommitFailedException {\r\n    return asDocumentRootBuilder(builder).merge(commitHook, info);\r\n}","lc":-0.4090909091,"pi":-0.6650717703,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6011275546,"fo":-0.3333333333,"r":0.2105263158,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3620_1a2bc1bc","label":1,"code":"\/**\r\n *  @see org.apache.wicket.request.handler.IPageRequestHandler#respond(org.apache.wicket.request.IRequestCycle)\r\n *\/\r\npublic final void respond(final IRequestCycle requestCycle) {\r\n    \/\/ do not increment page id during ajax processing\r\n    boolean frozen = page.setFreezePageId(true);\r\n    try {\r\n        final RequestCycle rc = (RequestCycle) requestCycle;\r\n        final WebResponse response = (WebResponse) requestCycle.getResponse();\r\n        if (markupIdToComponent.values().contains(page)) {\r\n            \/\/ the page itself has been added to the request target, we simply issue a redirect\r\n            \/\/ back to the page\r\n            IRequestHandler handler = new RenderPageRequestHandler(new PageProvider(page));\r\n            final String url = rc.urlFor(handler).toString();\r\n            response.sendRedirect(url);\r\n            return;\r\n        }\r\n        for (ITargetRespondListener listener : respondListeners) {\r\n            listener.onTargetRespond(this);\r\n        }\r\n        final Application app = Application.get();\r\n        page.send(app, Broadcast.BREADTH, this);\r\n        \/\/ Determine encoding\r\n        final String encoding = app.getRequestCycleSettings().getResponseRequestEncoding();\r\n        \/\/ Set content type based on markup type for page\r\n        response.setContentType(\"text\/xml; charset=\" + encoding);\r\n        \/\/ Make sure it is not cached by a client\r\n        response.disableCaching();\r\n        try {\r\n            final StringResponse bodyResponse = new StringResponse();\r\n            contructResponseBody(bodyResponse, encoding);\r\n            invokeResponseFilters(bodyResponse);\r\n            response.write(bodyResponse.getBuffer());\r\n        } finally {\r\n            \/\/ restore the original response\r\n            RequestCycle.get().setResponse(response);\r\n        }\r\n    } finally {\r\n        page.setFreezePageId(frozen);\r\n    }\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.request.handler.IPageRequestHandler#respond(org.apache.wicket.request.IRequestCycle)\r\n *\/\r\n","code_no_comment":"public final void respond(final IRequestCycle requestCycle) {\r\n        boolean frozen = page.setFreezePageId(true);\r\n    try {\r\n        final RequestCycle rc = (RequestCycle) requestCycle;\r\n        final WebResponse response = (WebResponse) requestCycle.getResponse();\r\n        if (markupIdToComponent.values().contains(page)) {\r\n                                    IRequestHandler handler = new RenderPageRequestHandler(new PageProvider(page));\r\n            final String url = rc.urlFor(handler).toString();\r\n            response.sendRedirect(url);\r\n            return;\r\n        }\r\n        for (ITargetRespondListener listener : respondListeners) {\r\n            listener.onTargetRespond(this);\r\n        }\r\n        final Application app = Application.get();\r\n        page.send(app, Broadcast.BREADTH, this);\r\n                final String encoding = app.getRequestCycleSettings().getResponseRequestEncoding();\r\n                response.setContentType(\"text\/xml; charset=\" + encoding);\r\n                response.disableCaching();\r\n        try {\r\n            final StringResponse bodyResponse = new StringResponse();\r\n            contructResponseBody(bodyResponse, encoding);\r\n            invokeResponseFilters(bodyResponse);\r\n            response.write(bodyResponse.getBuffer());\r\n        } finally {\r\n                        RequestCycle.get().setResponse(response);\r\n        }\r\n    } finally {\r\n        page.setFreezePageId(frozen);\r\n    }\r\n}","lc":0.7727272727,"pi":0.1770334928,"ma":-0.2,"nbd":0.0,"ml":-0.1666666667,"d":-0.0376984127,"mi":-0.5199436223,"fo":1.25,"r":-0.0263157895,"e":0.2140649943}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5656_f539c18c","label":1,"code":"boolean isRequired() {\r\n    List<NotNull> constraints = findNotNullConstraints();\r\n    if (constraints.isEmpty()) {\r\n        return false;\r\n    }\r\n    HashSet<Class<?>> validatorGroups = new HashSet<Class<?>>();\r\n    validatorGroups.addAll(Arrays.asList(getGroups()));\r\n    for (NotNull constraint : constraints) {\r\n        if (constraint.groups().length == 0 && validatorGroups.isEmpty()) {\r\n            return true;\r\n        }\r\n        for (Class<?> constraintGroup : constraint.groups()) {\r\n            if (validatorGroups.contains(constraintGroup)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"boolean isRequired() {\r\n    List<NotNull> constraints = findNotNullConstraints();\r\n    if (constraints.isEmpty()) {\r\n        return false;\r\n    }\r\n    HashSet<Class<?>> validatorGroups = new HashSet<Class<?>>();\r\n    validatorGroups.addAll(Arrays.asList(getGroups()));\r\n    for (NotNull constraint : constraints) {\r\n        if (constraint.groups().length == 0 && validatorGroups.isEmpty()) {\r\n            return true;\r\n        }\r\n        for (Class<?> constraintGroup : constraint.groups()) {\r\n            if (validatorGroups.contains(constraintGroup)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}","lc":0.2272727273,"pi":0.5550239234,"ma":0.4,"nbd":0.5,"ml":0.3333333333,"d":-0.0218253968,"mi":-0.178858351,"fo":0.25,"r":0.0263157895,"e":-0.0074756661}
{"project_name":"Cli","project_version":"19","label":1,"code":"\/**\r\n * <p>If an {@link Option} exists for <code>token<\/code> then\r\n * set the current option and add the token to the processed\r\n * list.<\/p>\r\n *\r\n * <p>If an {@link Option} does not exist and <code>stopAtNonOption<\/code>\r\n * is set then ignore the current token and add the remaining tokens\r\n * to the processed tokens list directly.<\/p>\r\n *\r\n * @param token The current option token\r\n * @param stopAtNonOption Specifies whether flattening should halt\r\n * at the first non option.\r\n *\/\r\nprivate void processOptionToken(String token, boolean stopAtNonOption) {\r\n    if (options.hasOption(token)) {\r\n        currentOption = options.getOption(token);\r\n        tokens.add(token);\r\n    } else if (stopAtNonOption) {\r\n        eatTheRest = true;\r\n        tokens.add(token);\r\n    }\r\n}","code_comment":"\/**\r\n * <p>If an {@link Option} exists for <code>token<\/code> then\r\n * set the current option and add the token to the processed\r\n * list.<\/p>\r\n *\r\n * <p>If an {@link Option} does not exist and <code>stopAtNonOption<\/code>\r\n * is set then ignore the current token and add the remaining tokens\r\n * to the processed tokens list directly.<\/p>\r\n *\r\n * @param token The current option token\r\n * @param stopAtNonOption Specifies whether flattening should halt\r\n * at the first non option.\r\n *\/\r\n","code_no_comment":"private void processOptionToken(String token, boolean stopAtNonOption) {\r\n    if (options.hasOption(token)) {\r\n        currentOption = options.getOption(token);\r\n        tokens.add(token);\r\n    } else if (stopAtNonOption) {\r\n        eatTheRest = true;\r\n        tokens.add(token);\r\n    }\r\n}","lc":-0.2272727273,"pi":0.0717703349,"ma":-0.2,"nbd":0.0,"ml":0.0,"d":-0.3650793651,"mi":0.2992248062,"fo":-0.1666666667,"r":0.1052631579,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5071_a2f848f2","label":1,"code":"\/**\r\n *  @see org.apache.wicket.request.IRequestMapper#getCompatibilityScore(org.apache.wicket.request.Request)\r\n *\/\r\n@Override\r\npublic int getCompatibilityScore(final Request request) {\r\n    int score = 0;\r\n    Url url = request.getUrl();\r\n    if (matches(url)) {\r\n        score = Integer.MAX_VALUE;\r\n    }\r\n    return score;\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.request.IRequestMapper#getCompatibilityScore(org.apache.wicket.request.Request)\r\n *\/\r\n","code_no_comment":"@Override\r\npublic int getCompatibilityScore(final Request request) {\r\n    int score = 0;\r\n    Url url = request.getUrl();\r\n    if (matches(url)) {\r\n        score = Integer.MAX_VALUE;\r\n    }\r\n    return score;\r\n}","lc":-0.2272727273,"pi":-0.2296650718,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.326286117,"fo":-0.3333333333,"r":0.8684210526,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1877_716e1237","label":0,"code":"@Override\r\n@Nonnull\r\npublic NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {\r\n    \/\/ check for concurrent updates by this async task\r\n    String checkpointAfterRebase = before.getChildNode(ASYNC).getString(name);\r\n    if (Objects.equal(checkpoint, checkpointAfterRebase)) {\r\n        return postAsyncRunNodeStatus(after.builder(), name).getNodeState();\r\n    } else {\r\n        throw CONCURRENT_UPDATE;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\n@Nonnull\r\npublic NodeState processCommit(NodeState before, NodeState after, CommitInfo info) throws CommitFailedException {\r\n        String checkpointAfterRebase = before.getChildNode(ASYNC).getString(name);\r\n    if (Objects.equal(checkpoint, checkpointAfterRebase)) {\r\n        return postAsyncRunNodeStatus(after.builder(), name).getNodeState();\r\n    } else {\r\n        throw CONCURRENT_UPDATE;\r\n    }\r\n}","lc":-0.1818181818,"pi":0.0,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.1847780127,"fo":0.0,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"Math","project_version":"77","label":1,"code":"public double getLInfNorm() {\r\n    double max = 0;\r\n    Iterator iter = entries.iterator();\r\n    while (iter.hasNext()) {\r\n        iter.advance();\r\n        max += iter.value();\r\n    }\r\n    return max;\r\n}","code_comment":null,"code_no_comment":"public double getLInfNorm() {\r\n    double max = 0;\r\n    Iterator iter = entries.iterator();\r\n    while (iter.hasNext()) {\r\n        iter.advance();\r\n        max += iter.value();\r\n    }\r\n    return max;\r\n}","lc":-0.2272727273,"pi":-0.1531100478,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0773809524,"mi":0.3378435518,"fo":-0.1666666667,"r":0.6315789474,"e":-0.1156434594}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5071_d3d42d42","label":1,"code":"private boolean matches(final Request request) {\r\n    boolean matches = false;\r\n    Url url = request.getUrl();\r\n    Url baseUrl = request.getClientUrl();\r\n    String namespace = getContext().getNamespace();\r\n    String bookmarkableIdentifier = getContext().getBookmarkableIdentifier();\r\n    String pageIdentifier = getContext().getPageIdentifier();\r\n    if (url.getSegments().size() >= 3 && urlStartsWith(url, namespace, bookmarkableIdentifier)) {\r\n        matches = true;\r\n    } else \/\/ baseUrl = 'wicket\/bookmarkable\/com.example.SomePage[?...]', requestUrl = 'bookmarkable\/com.example.SomePage'\r\n    if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace, bookmarkableIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {\r\n        matches = true;\r\n    } else \/\/ baseUrl = 'wicket\/page[?...]', requestUrl = 'bookmarkable\/com.example.SomePage'\r\n    if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {\r\n        matches = true;\r\n    }\r\n    return matches;\r\n}","code_comment":null,"code_no_comment":"private boolean matches(final Request request) {\r\n    boolean matches = false;\r\n    Url url = request.getUrl();\r\n    Url baseUrl = request.getClientUrl();\r\n    String namespace = getContext().getNamespace();\r\n    String bookmarkableIdentifier = getContext().getBookmarkableIdentifier();\r\n    String pageIdentifier = getContext().getPageIdentifier();\r\n    if (url.getSegments().size() >= 3 && urlStartsWith(url, namespace, bookmarkableIdentifier)) {\r\n        matches = true;\r\n    } else     if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace, bookmarkableIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {\r\n        matches = true;\r\n    } else     if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier)) {\r\n        matches = true;\r\n    }\r\n    return matches;\r\n}","lc":0.1818181818,"pi":-0.4258373206,"ma":0.0,"nbd":0.5,"ml":1.3333333333,"d":0.8095238095,"mi":-0.2611698379,"fo":1.4166666667,"r":-0.0263157895,"e":1.0436403243}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1216_e403e003","label":1,"code":"\/**\r\n * Returns the Oak path for the given JCR path, or throws a\r\n * {@link javax.jcr.RepositoryException} if the path can not be mapped.\r\n *\r\n * @param jcrPath JCR path\r\n * @return Oak path\r\n * @throws javax.jcr.RepositoryException if the path can not be mapped\r\n *\/\r\n@Nonnull\r\npublic String getOakPathOrThrow(String jcrPath) throws RepositoryException {\r\n    String oakPath = getOakPath(jcrPath);\r\n    if (oakPath != null) {\r\n        return oakPath;\r\n    } else {\r\n        throw new RepositoryException(\"Invalid name or path: \" + jcrPath);\r\n    }\r\n}","code_comment":"\/**\r\n * Returns the Oak path for the given JCR path, or throws a\r\n * {@link javax.jcr.RepositoryException} if the path can not be mapped.\r\n *\r\n * @param jcrPath JCR path\r\n * @return Oak path\r\n * @throws javax.jcr.RepositoryException if the path can not be mapped\r\n *\/\r\n","code_no_comment":"@Nonnull\r\npublic String getOakPathOrThrow(String jcrPath) throws RepositoryException {\r\n    String oakPath = getOakPath(jcrPath);\r\n    if (oakPath != null) {\r\n        return oakPath;\r\n    } else {\r\n        throw new RepositoryException(\"Invalid name or path: \" + jcrPath);\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.0277777778,"mi":0.3237491191,"fo":-0.4166666667,"r":1.6315789474,"e":-0.1047907194}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4927_8c827e33","label":1,"code":"@Override\r\npublic void setHeader(String name, String value) {\r\n    checkHeader();\r\n    bufferedResponse.setHeader(name, value);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void setHeader(String name, String value) {\r\n    checkHeader();\r\n    bufferedResponse.setHeader(name, value);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.710782241,"fo":-0.3333333333,"r":0.4210526316,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-3433_e76d23b0","label":3,"code":"public Object evaluate(Exchange exchange) {\r\n    return expression.evaluate(exchange, type.evaluate(exchange, Object.class).getClass());\r\n}","code_comment":null,"code_no_comment":"public Object evaluate(Exchange exchange) {\r\n    return expression.evaluate(exchange, type.evaluate(exchange, Object.class).getClass());\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.932346723,"fo":-0.25,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-676_3b2e880e","label":1,"code":"@Override\r\nprotected void commitAndClose() {\r\n    try {\r\n        if (this.connection != null && !this.connection.isClosed()) {\r\n            this.connection.close();\r\n        }\r\n    } catch (Exception e) {\r\n        throw new AppenderLoggingException(\"Failed to commit and close NoSQL connection in manager.\", e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected void commitAndClose() {\r\n    try {\r\n        if (this.connection != null && !this.connection.isClosed()) {\r\n            this.connection.close();\r\n        }\r\n    } catch (Exception e) {\r\n        throw new AppenderLoggingException(\"Failed to commit and close NoSQL connection in manager.\", e);\r\n    }\r\n}","lc":-0.1818181818,"pi":0.4449760766,"ma":0.0,"nbd":0.0,"ml":-0.0833333333,"d":-0.1130952381,"mi":0.288794926,"fo":-0.3333333333,"r":0.2894736842,"e":-0.1248134253}
{"project_name":"Closure","project_version":"103","label":2,"code":"@Override\r\npublic ObjectType getTypeWithProperty(String field, JSType type) {\r\n    if (!(type instanceof ObjectType)) {\r\n        if (type.autoboxesTo() != null) {\r\n            type = type.autoboxesTo();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    \/\/ Ignore the prototype itself at all times.\r\n    if (\"prototype\".equals(field)) {\r\n        return null;\r\n    }\r\n    \/\/ We look up the prototype chain to find the highest place (if any) that\r\n    \/\/ this appears.  This will make references to overriden properties look\r\n    \/\/ like references to the initial property, so they are renamed alike.\r\n    ObjectType foundType = null;\r\n    ObjectType objType = ObjectType.cast(type);\r\n    while (objType != null && objType.getImplicitPrototype() != objType) {\r\n        if (objType.hasOwnProperty(field)) {\r\n            foundType = objType;\r\n        }\r\n        objType = objType.getImplicitPrototype();\r\n    }\r\n    \/\/ so we have to double check.\r\n    return foundType;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic ObjectType getTypeWithProperty(String field, JSType type) {\r\n    if (!(type instanceof ObjectType)) {\r\n        if (type.autoboxesTo() != null) {\r\n            type = type.autoboxesTo();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n        if (\"prototype\".equals(field)) {\r\n        return null;\r\n    }\r\n                ObjectType foundType = null;\r\n    ObjectType objType = ObjectType.cast(type);\r\n    while (objType != null && objType.getImplicitPrototype() != objType) {\r\n        if (objType.hasOwnProperty(field)) {\r\n            foundType = objType;\r\n        }\r\n        objType = objType.getImplicitPrototype();\r\n    }\r\n        return foundType;\r\n}","lc":0.3636363636,"pi":0.2727272727,"ma":0.4,"nbd":0.0,"ml":0.6666666667,"d":0.6388888889,"mi":-0.2718816068,"fo":0.0833333333,"r":0.0,"e":0.3801478767}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2713_63d9800e","label":1,"code":"public StateHandle<Serializable> snapshotState(long checkpointId, long checkpointTimestamp) throws Exception {\r\n    return provider.createStateHandle(checkpointer.snapshotState(value(), checkpointId, checkpointTimestamp));\r\n}","code_comment":null,"code_no_comment":"public StateHandle<Serializable> snapshotState(long checkpointId, long checkpointTimestamp) throws Exception {\r\n    return provider.createStateHandle(checkpointer.snapshotState(value(), checkpointId, checkpointTimestamp));\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9007751938,"fo":-0.25,"r":0.0,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-367_3a15d8ce","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic boolean hasNext() {\r\n    return current != null;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public boolean hasNext() {\r\n    return current != null;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1099365751,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1471_d033fa8f","label":1,"code":"private static void validateInputType(Class<?> baseClass, Class<?> clazz, int inputParamPos, TypeInformation<?> inType) {\r\n    ArrayList<Type> typeHierarchy = new ArrayList<Type>();\r\n    try {\r\n        validateInfo(typeHierarchy, getParameterType(baseClass, typeHierarchy, clazz, inputParamPos), inType);\r\n    } catch (InvalidTypesException e) {\r\n        throw new InvalidTypesException(\"Input mismatch: \" + e.getMessage());\r\n    }\r\n}","code_comment":null,"code_no_comment":"private static void validateInputType(Class<?> baseClass, Class<?> clazz, int inputParamPos, TypeInformation<?> inType) {\r\n    ArrayList<Type> typeHierarchy = new ArrayList<Type>();\r\n    try {\r\n        validateInfo(typeHierarchy, getParameterType(baseClass, typeHierarchy, clazz, inputParamPos), inType);\r\n    } catch (InvalidTypesException e) {\r\n        throw new InvalidTypesException(\"Input mismatch: \" + e.getMessage());\r\n    }\r\n}","lc":-0.2727272727,"pi":-0.0765550239,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.0376984127,"mi":0.2980972516,"fo":-0.25,"r":-0.0263157895,"e":-0.0660223717}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1214_6ecd0f82","label":1,"code":"@Override\r\npublic void computeInterestingPropertiesForInputs(CostEstimator estimator) {\r\n    \/\/ get what we inherit and what is preserved by our user code\r\n    final InterestingProperties props = getInterestingProperties().filterByCodeAnnotations(this, 0);\r\n    \/\/ add all properties relevant to this node\r\n    for (OperatorDescriptorSingle dps : getPossibleProperties()) {\r\n        for (RequestedGlobalProperties gp : dps.getPossibleGlobalProperties()) {\r\n            props.addGlobalProperties(gp);\r\n        }\r\n        for (RequestedLocalProperties lp : dps.getPossibleLocalProperties()) {\r\n            props.addLocalProperties(lp);\r\n        }\r\n    }\r\n    this.inConn.setInterestingProperties(props);\r\n    for (PactConnection conn : getBroadcastConnections()) {\r\n        conn.setInterestingProperties(new InterestingProperties());\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void computeInterestingPropertiesForInputs(CostEstimator estimator) {\r\n        final InterestingProperties props = getInterestingProperties().filterByCodeAnnotations(this, 0);\r\n        for (OperatorDescriptorSingle dps : getPossibleProperties()) {\r\n        for (RequestedGlobalProperties gp : dps.getPossibleGlobalProperties()) {\r\n            props.addGlobalProperties(gp);\r\n        }\r\n        for (RequestedLocalProperties lp : dps.getPossibleLocalProperties()) {\r\n            props.addLocalProperties(lp);\r\n        }\r\n    }\r\n    this.inConn.setInterestingProperties(props);\r\n    for (PactConnection conn : getBroadcastConnections()) {\r\n        conn.setInterestingProperties(new InterestingProperties());\r\n    }\r\n}","lc":0.0909090909,"pi":0.3444976077,"ma":0.2,"nbd":0.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.0787878788,"fo":0.3333333333,"r":0.0,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-657_32b0f733","label":3,"code":"\/**\r\n * Returns a {@code Complex} whose value is {@code (this \/ divisor)},\r\n * with {@code divisor} interpreted as a real number.\r\n *\r\n * @param  divisor Value by which this {@code Complex} is to be divided.\r\n * @return {@code this \/ divisor}.\r\n * @see #divide(Complex)\r\n *\/\r\npublic Complex divide(double divisor) {\r\n    if (isNaN || Double.isNaN(divisor)) {\r\n        return NaN;\r\n    }\r\n    if (divisor == 0d) {\r\n        return NaN;\r\n    }\r\n    if (Double.isInfinite(divisor)) {\r\n        return !isInfinite() ? ZERO : NaN;\r\n    }\r\n    return createComplex(real \/ divisor, imaginary \/ divisor);\r\n}","code_comment":"\/**\r\n * Returns a {@code Complex} whose value is {@code (this \/ divisor)},\r\n * with {@code divisor} interpreted as a real number.\r\n *\r\n * @param  divisor Value by which this {@code Complex} is to be divided.\r\n * @return {@code this \/ divisor}.\r\n * @see #divide(Complex)\r\n *\/\r\n","code_no_comment":"public Complex divide(double divisor) {\r\n    if (isNaN || Double.isNaN(divisor)) {\r\n        return NaN;\r\n    }\r\n    if (divisor == 0d) {\r\n        return NaN;\r\n    }\r\n    if (Double.isInfinite(divisor)) {\r\n        return !isInfinite() ? ZERO : NaN;\r\n    }\r\n    return createComplex(real \/ divisor, imaginary \/ divisor);\r\n}","lc":-0.0909090909,"pi":-0.2057416268,"ma":0.2,"nbd":-0.5,"ml":0.4166666667,"d":0.3373015873,"mi":0.1157152925,"fo":-0.1666666667,"r":0.3421052632,"e":0.0239115276}
{"project_name":"Math","project_version":"44","label":1,"code":"\/**\r\n * Accept a step, triggering events and step handlers.\r\n * @param interpolator step interpolator\r\n * @param y state vector at step end time, must be reset if an event\r\n * asks for resetting or if an events stops integration during the step\r\n * @param yDot placeholder array where to put the time derivative of the state vector\r\n * @param tEnd final integration time\r\n * @return time at end of step\r\n * @exception MathIllegalStateException if the value of one event state cannot be evaluated\r\n * @since 2.2\r\n *\/\r\nprotected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException {\r\n    double previousT = interpolator.getGlobalPreviousTime();\r\n    final double currentT = interpolator.getGlobalCurrentTime();\r\n    resetOccurred = false;\r\n    \/\/ initialize the events states if needed\r\n    if (!statesInitialized) {\r\n        for (EventState state : eventsStates) {\r\n            state.reinitializeBegin(interpolator);\r\n        }\r\n        statesInitialized = true;\r\n    }\r\n    \/\/ search for next events that may occur during the step\r\n    final int orderingSign = interpolator.isForward() ? +1 : -1;\r\n    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\r\n\r\n        \/**\r\n         * {@inheritDoc}\r\n         *\/\r\n        public int compare(EventState es0, EventState es1) {\r\n            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\r\n        }\r\n    });\r\n    for (final EventState state : eventsStates) {\r\n        if (state.evaluateStep(interpolator)) {\r\n            \/\/ the event occurs during the current step\r\n            occuringEvents.add(state);\r\n        }\r\n    }\r\n    while (!occuringEvents.isEmpty()) {\r\n        \/\/ handle the chronologically first event\r\n        final Iterator<EventState> iterator = occuringEvents.iterator();\r\n        final EventState currentEvent = iterator.next();\r\n        iterator.remove();\r\n        \/\/ restrict the interpolator to the first part of the step, up to the event\r\n        final double eventT = currentEvent.getEventTime();\r\n        interpolator.setSoftPreviousTime(previousT);\r\n        interpolator.setSoftCurrentTime(eventT);\r\n        \/\/ trigger the event\r\n        interpolator.setInterpolatedTime(eventT);\r\n        final double[] eventY = interpolator.getInterpolatedState();\r\n        currentEvent.stepAccepted(eventT, eventY);\r\n        isLastStep = currentEvent.stop();\r\n        \/\/ handle the first part of the step, up to the event\r\n        for (final StepHandler handler : stepHandlers) {\r\n            handler.handleStep(interpolator, isLastStep);\r\n        }\r\n        if (isLastStep) {\r\n            \/\/ the event asked to stop integration\r\n            System.arraycopy(eventY, 0, y, 0, y.length);\r\n            return eventT;\r\n        }\r\n        if (currentEvent.reset(eventT, eventY)) {\r\n            \/\/ some event handler has triggered changes that\r\n            \/\/ invalidate the derivatives, we need to recompute them\r\n            System.arraycopy(eventY, 0, y, 0, y.length);\r\n            computeDerivatives(eventT, y, yDot);\r\n            resetOccurred = true;\r\n            return eventT;\r\n        }\r\n        \/\/ prepare handling of the remaining part of the step\r\n        previousT = eventT;\r\n        interpolator.setSoftPreviousTime(eventT);\r\n        interpolator.setSoftCurrentTime(currentT);\r\n        \/\/ check if the same event occurs again in the remaining part of the step\r\n        if (currentEvent.evaluateStep(interpolator)) {\r\n            \/\/ the event occurs during the current step\r\n            occuringEvents.add(currentEvent);\r\n        }\r\n    }\r\n    interpolator.setInterpolatedTime(currentT);\r\n    final double[] currentY = interpolator.getInterpolatedState();\r\n    for (final EventState state : eventsStates) {\r\n        state.stepAccepted(currentT, currentY);\r\n        isLastStep = isLastStep || state.stop();\r\n    }\r\n    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\r\n    \/\/ handle the remaining part of the step, after all events if any\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.handleStep(interpolator, isLastStep);\r\n    }\r\n    return currentT;\r\n}","code_comment":"\/**\r\n * Accept a step, triggering events and step handlers.\r\n * @param interpolator step interpolator\r\n * @param y state vector at step end time, must be reset if an event\r\n * asks for resetting or if an events stops integration during the step\r\n * @param yDot placeholder array where to put the time derivative of the state vector\r\n * @param tEnd final integration time\r\n * @return time at end of step\r\n * @exception MathIllegalStateException if the value of one event state cannot be evaluated\r\n * @since 2.2\r\n *\/\r\n\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException {\r\n    double previousT = interpolator.getGlobalPreviousTime();\r\n    final double currentT = interpolator.getGlobalCurrentTime();\r\n    resetOccurred = false;\r\n        if (!statesInitialized) {\r\n        for (EventState state : eventsStates) {\r\n            state.reinitializeBegin(interpolator);\r\n        }\r\n        statesInitialized = true;\r\n    }\r\n        final int orderingSign = interpolator.isForward() ? +1 : -1;\r\n    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\r\n\r\n        \/**\r\n         * {@inheritDoc}\r\n         *\/\r\n        public int compare(EventState es0, EventState es1) {\r\n            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\r\n        }\r\n    });\r\n    for (final EventState state : eventsStates) {\r\n        if (state.evaluateStep(interpolator)) {\r\n                        occuringEvents.add(state);\r\n        }\r\n    }\r\n    while (!occuringEvents.isEmpty()) {\r\n                final Iterator<EventState> iterator = occuringEvents.iterator();\r\n        final EventState currentEvent = iterator.next();\r\n        iterator.remove();\r\n                final double eventT = currentEvent.getEventTime();\r\n        interpolator.setSoftPreviousTime(previousT);\r\n        interpolator.setSoftCurrentTime(eventT);\r\n                interpolator.setInterpolatedTime(eventT);\r\n        final double[] eventY = interpolator.getInterpolatedState();\r\n        currentEvent.stepAccepted(eventT, eventY);\r\n        isLastStep = currentEvent.stop();\r\n                for (final StepHandler handler : stepHandlers) {\r\n            handler.handleStep(interpolator, isLastStep);\r\n        }\r\n        if (isLastStep) {\r\n                        System.arraycopy(eventY, 0, y, 0, y.length);\r\n            return eventT;\r\n        }\r\n        if (currentEvent.reset(eventT, eventY)) {\r\n                                    System.arraycopy(eventY, 0, y, 0, y.length);\r\n            computeDerivatives(eventT, y, yDot);\r\n            resetOccurred = true;\r\n            return eventT;\r\n        }\r\n                previousT = eventT;\r\n        interpolator.setSoftPreviousTime(eventT);\r\n        interpolator.setSoftCurrentTime(currentT);\r\n                if (currentEvent.evaluateStep(interpolator)) {\r\n                        occuringEvents.add(currentEvent);\r\n        }\r\n    }\r\n    interpolator.setInterpolatedTime(currentT);\r\n    final double[] currentY = interpolator.getInterpolatedState();\r\n    for (final EventState state : eventsStates) {\r\n        state.stepAccepted(currentT, currentY);\r\n        isLastStep = isLastStep || state.stop();\r\n    }\r\n    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\r\n        for (StepHandler handler : stepHandlers) {\r\n        handler.handleStep(interpolator, isLastStep);\r\n    }\r\n    return currentT;\r\n}","lc":2.4090909091,"pi":-0.014354067,"ma":1.8,"nbd":0.0,"ml":1.0,"d":1.3154761905,"mi":-1.066807611,"fo":2.4166666667,"r":-0.0263157895,"e":4.5426669663}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2621_c849f986","label":1,"code":"private boolean isMultiPart() {\r\n    if (multiPart) {\r\n        return true;\r\n    } else {\r\n        final boolean[] anyEmbeddedMultipart = new boolean[] { false };\r\n        visitChildren(Form.class, new IVisitor<Form<?>>() {\r\n\r\n            public Object component(Form<?> form) {\r\n                if (form.multiPart) {\r\n                    anyEmbeddedMultipart[0] = true;\r\n                    return STOP_TRAVERSAL;\r\n                } else {\r\n                    return CONTINUE_TRAVERSAL;\r\n                }\r\n            }\r\n        });\r\n        return anyEmbeddedMultipart[0];\r\n    }\r\n}","code_comment":null,"code_no_comment":"private boolean isMultiPart() {\r\n    if (multiPart) {\r\n        return true;\r\n    } else {\r\n        final boolean[] anyEmbeddedMultipart = new boolean[] { false };\r\n        visitChildren(Form.class, new IVisitor<Form<?>>() {\r\n\r\n            public Object component(Form<?> form) {\r\n                if (form.multiPart) {\r\n                    anyEmbeddedMultipart[0] = true;\r\n                    return STOP_TRAVERSAL;\r\n                } else {\r\n                    return CONTINUE_TRAVERSAL;\r\n                }\r\n            }\r\n        });\r\n        return anyEmbeddedMultipart[0];\r\n    }\r\n}","lc":0.1818181818,"pi":1.6459330144,"ma":-0.2,"nbd":0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":-0.0367864693,"fo":-0.4166666667,"r":0.3421052632,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4505_a4caaa57","label":1,"code":"\/**\r\n *  Parses the text between tags. For example, \"a href=foo.html\".\r\n *\r\n *  @param tag\r\n *  @param tagText\r\n *             The text between tags\r\n *  @return false in case of an error\r\n *  @throws ParseException\r\n *\/\r\nprivate boolean parseTagText(final XmlTag tag, final String tagText) throws ParseException {\r\n    \/\/ Get the length of the tagtext\r\n    final int tagTextLength = tagText.length();\r\n    \/\/ If we match tagname pattern\r\n    final TagNameParser tagnameParser = new TagNameParser(tagText);\r\n    if (tagnameParser.matcher().lookingAt()) {\r\n        \/\/ Extract the tag from the pattern matcher\r\n        tag.name = tagnameParser.getName();\r\n        tag.namespace = tagnameParser.getNamespace();\r\n        \/\/ Are we at the end? Then there are no attributes, so we just\r\n        \/\/ return the tag\r\n        int pos = tagnameParser.matcher().end(0);\r\n        if (pos == tagTextLength) {\r\n            return true;\r\n        }\r\n        \/\/ Extract attributes\r\n        final VariableAssignmentParser attributeParser = new VariableAssignmentParser(tagText);\r\n        while (attributeParser.matcher().find(pos)) {\r\n            \/\/ Get key and value using attribute pattern\r\n            String value = attributeParser.getValue();\r\n            \/\/ In case like <html xmlns:wicket> will the value be null\r\n            if (value == null) {\r\n                value = \"\";\r\n            }\r\n            \/\/ Set new position to end of attribute\r\n            pos = attributeParser.matcher().end(0);\r\n            \/\/ Chop off double quotes or single quotes\r\n            if (value.startsWith(\"\\\"\") || value.startsWith(\"\\'\")) {\r\n                value = value.substring(1, value.length() - 1);\r\n            }\r\n            \/\/ Trim trailing whitespace\r\n            value = value.trim();\r\n            \/\/ Get key\r\n            final String key = attributeParser.getKey();\r\n            \/\/ Put the attribute in the attributes hash\r\n            if (null != tag.getAttributes().put(key, value)) {\r\n                throw new ParseException(\"Same attribute found twice: \" + key + getLineAndColumnText(), input.getPosition());\r\n            }\r\n            \/\/ attributes)\r\n            if (pos == tagTextLength) {\r\n                return true;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}","code_comment":"\/**\r\n *  Parses the text between tags. For example, \"a href=foo.html\".\r\n *\r\n *  @param tag\r\n *  @param tagText\r\n *             The text between tags\r\n *  @return false in case of an error\r\n *  @throws ParseException\r\n *\/\r\n","code_no_comment":"private boolean parseTagText(final XmlTag tag, final String tagText) throws ParseException {\r\n        final int tagTextLength = tagText.length();\r\n        final TagNameParser tagnameParser = new TagNameParser(tagText);\r\n    if (tagnameParser.matcher().lookingAt()) {\r\n                tag.name = tagnameParser.getName();\r\n        tag.namespace = tagnameParser.getNamespace();\r\n                        int pos = tagnameParser.matcher().end(0);\r\n        if (pos == tagTextLength) {\r\n            return true;\r\n        }\r\n                final VariableAssignmentParser attributeParser = new VariableAssignmentParser(tagText);\r\n        while (attributeParser.matcher().find(pos)) {\r\n                        String value = attributeParser.getValue();\r\n                        if (value == null) {\r\n                value = \"\";\r\n            }\r\n                        pos = attributeParser.matcher().end(0);\r\n                        if (value.startsWith(\"\\\"\") || value.startsWith(\"\\'\")) {\r\n                value = value.substring(1, value.length() - 1);\r\n            }\r\n                        value = value.trim();\r\n                        final String key = attributeParser.getKey();\r\n                        if (null != tag.getAttributes().put(key, value)) {\r\n                throw new ParseException(\"Same attribute found twice: \" + key + getLineAndColumnText(), input.getPosition());\r\n            }\r\n                        if (pos == tagTextLength) {\r\n                return true;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}","lc":0.8636363636,"pi":0.6124401914,"ma":1.0,"nbd":0.5,"ml":1.0,"d":0.8948412698,"mi":-0.6194503171,"fo":1.3333333333,"r":-0.0263157895,"e":1.6449946117}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_add180fb","label":1,"code":"@Override\r\npublic Collection<Text> getSplits(String tableName) {\r\n    return Collections.emptyList();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Collection<Text> getSplits(String tableName) {\r\n    return Collections.emptyList();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8469344609,"fo":-0.4166666667,"r":1.6315789474,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-621_00b4b8a0","label":1,"code":"private PropertyState internalGetProperty(String propertyName) {\r\n    return getNodeBuilder().getProperty(propertyName);\r\n}","code_comment":null,"code_no_comment":"private PropertyState internalGetProperty(String propertyName) {\r\n    return getNodeBuilder().getProperty(propertyName);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0132487667,"fo":-0.3333333333,"r":1.7105263158,"e":-0.1627934049}
{"project_name":"Chart","project_version":"9","label":2,"code":"\/**\r\n * Creates a new timeseries by copying a subset of the data in this time\r\n * series.\r\n *\r\n * @param start  the first time period to copy (<code>null<\/code> not\r\n *         permitted).\r\n * @param end  the last time period to copy (<code>null<\/code> not\r\n *         permitted).\r\n *\r\n * @return A time series containing a copy of this time series from start\r\n *         until end.\r\n *\r\n * @throws CloneNotSupportedException if there is a cloning problem.\r\n *\/\r\npublic TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException {\r\n    if (start == null) {\r\n        throw new IllegalArgumentException(\"Null 'start' argument.\");\r\n    }\r\n    if (end == null) {\r\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\r\n    }\r\n    if (start.compareTo(end) > 0) {\r\n        throw new IllegalArgumentException(\"Requires start on or before end.\");\r\n    }\r\n    boolean emptyRange = false;\r\n    int startIndex = getIndex(start);\r\n    if (startIndex < 0) {\r\n        startIndex = -(startIndex + 1);\r\n        if (startIndex == this.data.size()) {\r\n            \/\/ start is after last data item\r\n            emptyRange = true;\r\n        }\r\n    }\r\n    int endIndex = getIndex(end);\r\n    if (endIndex < 0) {\r\n        \/\/ end period is not in original series\r\n        \/\/ this is first item AFTER end period\r\n        endIndex = -(endIndex + 1);\r\n        \/\/ so this is last item BEFORE end\r\n        endIndex = endIndex - 1;\r\n    }\r\n    if (endIndex < 0) {\r\n        emptyRange = true;\r\n    }\r\n    if (emptyRange) {\r\n        TimeSeries copy = (TimeSeries) super.clone();\r\n        copy.data = new java.util.ArrayList();\r\n        return copy;\r\n    } else {\r\n        return createCopy(startIndex, endIndex);\r\n    }\r\n}","code_comment":"\/**\r\n * Creates a new timeseries by copying a subset of the data in this time\r\n * series.\r\n *\r\n * @param start  the first time period to copy (<code>null<\/code> not\r\n *         permitted).\r\n * @param end  the last time period to copy (<code>null<\/code> not\r\n *         permitted).\r\n *\r\n * @return A time series containing a copy of this time series from start\r\n *         until end.\r\n *\r\n * @throws CloneNotSupportedException if there is a cloning problem.\r\n *\/\r\n","code_no_comment":"public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException {\r\n    if (start == null) {\r\n        throw new IllegalArgumentException(\"Null 'start' argument.\");\r\n    }\r\n    if (end == null) {\r\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\r\n    }\r\n    if (start.compareTo(end) > 0) {\r\n        throw new IllegalArgumentException(\"Requires start on or before end.\");\r\n    }\r\n    boolean emptyRange = false;\r\n    int startIndex = getIndex(start);\r\n    if (startIndex < 0) {\r\n        startIndex = -(startIndex + 1);\r\n        if (startIndex == this.data.size()) {\r\n                        emptyRange = true;\r\n        }\r\n    }\r\n    int endIndex = getIndex(end);\r\n    if (endIndex < 0) {\r\n                        endIndex = -(endIndex + 1);\r\n                endIndex = endIndex - 1;\r\n    }\r\n    if (endIndex < 0) {\r\n        emptyRange = true;\r\n    }\r\n    if (emptyRange) {\r\n        TimeSeries copy = (TimeSeries) super.clone();\r\n        copy.data = new java.util.ArrayList();\r\n        return copy;\r\n    } else {\r\n        return createCopy(startIndex, endIndex);\r\n    }\r\n}","lc":0.9090909091,"pi":-0.2009569378,"ma":1.6,"nbd":0.0,"ml":0.8333333333,"d":1.0376984127,"mi":-0.6053558844,"fo":0.0,"r":-0.0263157895,"e":1.2967756436}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1358_4d10c92f","label":1,"code":"private static String setUpOptions(ClassLoader classloader, final ConsoleReader reader, final String className, final Map<String, String> options) throws IOException, ShellCommandException {\r\n    String input;\r\n    OptionDescriber skvi;\r\n    Class<? extends OptionDescriber> clazz;\r\n    try {\r\n        clazz = classloader.loadClass(className).asSubclass(OptionDescriber.class);\r\n        skvi = clazz.newInstance();\r\n    } catch (ClassNotFoundException e) {\r\n        throw new IllegalArgumentException(e.getMessage());\r\n    } catch (InstantiationException e) {\r\n        throw new IllegalArgumentException(e.getMessage());\r\n    } catch (IllegalAccessException e) {\r\n        throw new IllegalArgumentException(e.getMessage());\r\n    } catch (ClassCastException e) {\r\n        throw new ShellCommandException(ErrorCode.INITIALIZATION_FAILURE, \"Unable to load \" + className + \" as type \" + OptionDescriber.class.getName() + \"; configure with 'config' instead\");\r\n    }\r\n    final IteratorOptions itopts = skvi.describeOptions();\r\n    if (itopts.getName() == null) {\r\n        throw new IllegalArgumentException(className + \" described its default distinguishing name as null\");\r\n    }\r\n    String shortClassName = className;\r\n    if (className.contains(\".\")) {\r\n        shortClassName = className.substring(className.lastIndexOf('.') + 1);\r\n    }\r\n    final Map<String, String> localOptions = new HashMap<String, String>();\r\n    do {\r\n        \/\/ clean up the overall options that caused things to fail\r\n        for (String key : localOptions.keySet()) {\r\n            options.remove(key);\r\n        }\r\n        localOptions.clear();\r\n        reader.printString(itopts.getDescription());\r\n        reader.printNewline();\r\n        String prompt;\r\n        if (itopts.getNamedOptions() != null) {\r\n            for (Entry<String, String> e : itopts.getNamedOptions().entrySet()) {\r\n                prompt = Shell.repeat(\"-\", 10) + \"> set \" + shortClassName + \" parameter \" + e.getKey() + \", \" + e.getValue() + \": \";\r\n                reader.flushConsole();\r\n                input = reader.readLine(prompt);\r\n                if (input == null) {\r\n                    reader.printNewline();\r\n                    throw new IOException(\"Input stream closed\");\r\n                } else {\r\n                    input = new String(input);\r\n                }\r\n                \/\/ Places all Parameters and Values into the LocalOptions, even if the value is \"\".\r\n                \/\/ This allows us to check for \"\" values when setting the iterators and allows us to remove\r\n                \/\/ the parameter and value from the table property.\r\n                localOptions.put(e.getKey(), input);\r\n            }\r\n        }\r\n        if (itopts.getUnnamedOptionDescriptions() != null) {\r\n            for (String desc : itopts.getUnnamedOptionDescriptions()) {\r\n                reader.printString(Shell.repeat(\"-\", 10) + \"> entering options: \" + desc + \"\\n\");\r\n                input = \"start\";\r\n                while (true) {\r\n                    prompt = Shell.repeat(\"-\", 10) + \"> set \" + shortClassName + \" option (<name> <value>, hit enter to skip): \";\r\n                    reader.flushConsole();\r\n                    input = reader.readLine(prompt);\r\n                    if (input == null) {\r\n                        reader.printNewline();\r\n                        throw new IOException(\"Input stream closed\");\r\n                    } else {\r\n                        input = new String(input);\r\n                    }\r\n                    if (input.length() == 0)\r\n                        break;\r\n                    String[] sa = input.split(\" \", 2);\r\n                    localOptions.put(sa[0], sa[1]);\r\n                }\r\n            }\r\n        }\r\n        options.putAll(localOptions);\r\n        if (!skvi.validateOptions(options))\r\n            reader.printString(\"invalid options for \" + clazz.getName() + \"\\n\");\r\n    } while (!skvi.validateOptions(options));\r\n    return itopts.getName();\r\n}","code_comment":null,"code_no_comment":"private static String setUpOptions(ClassLoader classloader, final ConsoleReader reader, final String className, final Map<String, String> options) throws IOException, ShellCommandException {\r\n    String input;\r\n    OptionDescriber skvi;\r\n    Class<? extends OptionDescriber> clazz;\r\n    try {\r\n        clazz = classloader.loadClass(className).asSubclass(OptionDescriber.class);\r\n        skvi = clazz.newInstance();\r\n    } catch (ClassNotFoundException e) {\r\n        throw new IllegalArgumentException(e.getMessage());\r\n    } catch (InstantiationException e) {\r\n        throw new IllegalArgumentException(e.getMessage());\r\n    } catch (IllegalAccessException e) {\r\n        throw new IllegalArgumentException(e.getMessage());\r\n    } catch (ClassCastException e) {\r\n        throw new ShellCommandException(ErrorCode.INITIALIZATION_FAILURE, \"Unable to load \" + className + \" as type \" + OptionDescriber.class.getName() + \"; configure with 'config' instead\");\r\n    }\r\n    final IteratorOptions itopts = skvi.describeOptions();\r\n    if (itopts.getName() == null) {\r\n        throw new IllegalArgumentException(className + \" described its default distinguishing name as null\");\r\n    }\r\n    String shortClassName = className;\r\n    if (className.contains(\".\")) {\r\n        shortClassName = className.substring(className.lastIndexOf('.') + 1);\r\n    }\r\n    final Map<String, String> localOptions = new HashMap<String, String>();\r\n    do {\r\n                for (String key : localOptions.keySet()) {\r\n            options.remove(key);\r\n        }\r\n        localOptions.clear();\r\n        reader.printString(itopts.getDescription());\r\n        reader.printNewline();\r\n        String prompt;\r\n        if (itopts.getNamedOptions() != null) {\r\n            for (Entry<String, String> e : itopts.getNamedOptions().entrySet()) {\r\n                prompt = Shell.repeat(\"-\", 10) + \"> set \" + shortClassName + \" parameter \" + e.getKey() + \", \" + e.getValue() + \": \";\r\n                reader.flushConsole();\r\n                input = reader.readLine(prompt);\r\n                if (input == null) {\r\n                    reader.printNewline();\r\n                    throw new IOException(\"Input stream closed\");\r\n                } else {\r\n                    input = new String(input);\r\n                }\r\n                                                                localOptions.put(e.getKey(), input);\r\n            }\r\n        }\r\n        if (itopts.getUnnamedOptionDescriptions() != null) {\r\n            for (String desc : itopts.getUnnamedOptionDescriptions()) {\r\n                reader.printString(Shell.repeat(\"-\", 10) + \"> entering options: \" + desc + \"\\n\");\r\n                input = \"start\";\r\n                while (true) {\r\n                    prompt = Shell.repeat(\"-\", 10) + \"> set \" + shortClassName + \" option (<name> <value>, hit enter to skip): \";\r\n                    reader.flushConsole();\r\n                    input = reader.readLine(prompt);\r\n                    if (input == null) {\r\n                        reader.printNewline();\r\n                        throw new IOException(\"Input stream closed\");\r\n                    } else {\r\n                        input = new String(input);\r\n                    }\r\n                    if (input.length() == 0)\r\n                        break;\r\n                    String[] sa = input.split(\" \", 2);\r\n                    localOptions.put(sa[0], sa[1]);\r\n                }\r\n            }\r\n        }\r\n        options.putAll(localOptions);\r\n        if (!skvi.validateOptions(options))\r\n            reader.printString(\"invalid options for \" + clazz.getName() + \"\\n\");\r\n    } while (!skvi.validateOptions(options));\r\n    return itopts.getName();\r\n}","lc":2.7272727273,"pi":1.7559808612,"ma":4.4,"nbd":1.5,"ml":1.0833333333,"d":0.6468253968,"mi":-1.2412966878,"fo":3.3333333333,"r":-0.0263157895,"e":3.6898186408}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4113_27300d81","label":0,"code":"public static byte[] toBytes(ByteBuffer buffer) {\r\n    if (buffer == null)\r\n        return null;\r\n    return Arrays.copyOfRange(buffer.array(), buffer.position(), buffer.limit());\r\n}","code_comment":null,"code_no_comment":"public static byte[] toBytes(ByteBuffer buffer) {\r\n    if (buffer == null)\r\n        return null;\r\n    return Arrays.copyOfRange(buffer.array(), buffer.position(), buffer.limit());\r\n}","lc":-0.4090909091,"pi":0.0,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.3650793651,"mi":0.6414376321,"fo":-0.1666666667,"r":0.0,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-172_99e22ce4","label":1,"code":"private final int children_indexOf(Component<?> child) {\r\n    if (children instanceof Component) {\r\n        if (((Component) children).getId().equals(child.getId())) {\r\n            return 0;\r\n        }\r\n    } else {\r\n        if (children != null) {\r\n            final Component[] components = (Component[]) children;\r\n            for (int i = 0; i < components.length; i++) {\r\n                if (components[i].getId().equals(child.getId())) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}","code_comment":null,"code_no_comment":"private final int children_indexOf(Component<?> child) {\r\n    if (children instanceof Component) {\r\n        if (((Component) children).getId().equals(child.getId())) {\r\n            return 0;\r\n        }\r\n    } else {\r\n        if (children != null) {\r\n            final Component[] components = (Component[]) children;\r\n            for (int i = 0; i < components.length; i++) {\r\n                if (components[i].getId().equals(child.getId())) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}","lc":0.1363636364,"pi":1.2153110048,"ma":0.4,"nbd":1.0,"ml":0.5,"d":0.6428571429,"mi":-0.1013389711,"fo":0.0,"r":0.1052631579,"e":0.217859304}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1822_3e83a4c1","label":1,"code":"public Operation getReverse() {\r\n    Operation reverse = null;\r\n    switch(type) {\r\n        case INCREMENT:\r\n            reverse = new Operation();\r\n            reverse.type = Type.INCREMENT;\r\n            reverse.value = -(Long) value;\r\n            break;\r\n        case SET:\r\n        case REMOVE_MAP_ENTRY:\r\n        case CONTAINS_MAP_ENTRY:\r\n            \/\/ nothing to do\r\n            break;\r\n        case SET_MAP_ENTRY:\r\n            reverse = new Operation();\r\n            reverse.type = Type.REMOVE_MAP_ENTRY;\r\n            break;\r\n    }\r\n    return reverse;\r\n}","code_comment":null,"code_no_comment":"public Operation getReverse() {\r\n    Operation reverse = null;\r\n    switch(type) {\r\n        case INCREMENT:\r\n            reverse = new Operation();\r\n            reverse.type = Type.INCREMENT;\r\n            reverse.value = -(Long) value;\r\n            break;\r\n        case SET:\r\n        case REMOVE_MAP_ENTRY:\r\n        case CONTAINS_MAP_ENTRY:\r\n                        break;\r\n        case SET_MAP_ENTRY:\r\n            reverse = new Operation();\r\n            reverse.type = Type.REMOVE_MAP_ENTRY;\r\n            break;\r\n    }\r\n    return reverse;\r\n}","lc":0.2272727273,"pi":0.5311004785,"ma":1.0,"nbd":0.0,"ml":0.0833333333,"d":0.0456349206,"mi":-0.1537702607,"fo":-0.5,"r":0.1315789474,"e":-0.0252715778}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-334_9d8cc45d","label":1,"code":"@Override\r\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\r\n    return new AgeOffFilter(getSource(), threshold, currentTime);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {\r\n    return new AgeOffFilter(getSource(), threshold, currentTime);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7866102889,"fo":-0.4166666667,"r":0.1315789474,"e":-0.1627934049}
{"project_name":"Closure","project_version":"17","label":2,"code":"\/**\r\n * Look for a type declaration on a property assignment\r\n * (in an ASSIGN or an object literal key).\r\n *\r\n * @param info The doc info for this property.\r\n * @param lValue The l-value node.\r\n * @param rValue The node that {@code n} is being initialized to,\r\n *     or {@code null} if this is a stub declaration.\r\n *\/\r\nprivate JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\r\n    if (info != null && info.hasType()) {\r\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\r\n    } else if (rValue != null && rValue.isFunction() && shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\r\n        return rValue.getJSType();\r\n    } else if (info != null) {\r\n        if (info.hasEnumParameterType()) {\r\n            if (rValue != null && rValue.isObjectLit()) {\r\n                return rValue.getJSType();\r\n            } else {\r\n                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\r\n            }\r\n        } else if (info.isConstructor() || info.isInterface()) {\r\n            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\r\n        } else {\r\n            \/\/ Check if this is constant, and if it has a known type.\r\n            if (info.isConstant()) {\r\n                JSType knownType = null;\r\n                if (rValue != null) {\r\n                    if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\r\n                        \/\/ then we can safely use that.\r\n                        return rValue.getJSType();\r\n                    } else if (rValue.isOr()) {\r\n                        \/\/ Check for a very specific JS idiom:\r\n                        \/\/ var x = x || TYPE;\r\n                        \/\/ This is used by Closure's base namespace for esoteric\r\n                        \/\/ reasons.\r\n                        Node firstClause = rValue.getFirstChild();\r\n                        Node secondClause = firstClause.getNext();\r\n                        boolean namesMatch = firstClause.isName() && lValue.isName() && firstClause.getString().equals(lValue.getString());\r\n                        if (namesMatch && secondClause.getJSType() != null && !secondClause.getJSType().isUnknownType()) {\r\n                            return secondClause.getJSType();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\r\n}","code_comment":"\/**\r\n * Look for a type declaration on a property assignment\r\n * (in an ASSIGN or an object literal key).\r\n *\r\n * @param info The doc info for this property.\r\n * @param lValue The l-value node.\r\n * @param rValue The node that {@code n} is being initialized to,\r\n *     or {@code null} if this is a stub declaration.\r\n *\/\r\n","code_no_comment":"private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\r\n    if (info != null && info.hasType()) {\r\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\r\n    } else if (rValue != null && rValue.isFunction() && shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\r\n        return rValue.getJSType();\r\n    } else if (info != null) {\r\n        if (info.hasEnumParameterType()) {\r\n            if (rValue != null && rValue.isObjectLit()) {\r\n                return rValue.getJSType();\r\n            } else {\r\n                return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\r\n            }\r\n        } else if (info.isConstructor() || info.isInterface()) {\r\n            return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue);\r\n        } else {\r\n                        if (info.isConstant()) {\r\n                JSType knownType = null;\r\n                if (rValue != null) {\r\n                    if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\r\n                                                return rValue.getJSType();\r\n                    } else if (rValue.isOr()) {\r\n                                                                                                                        Node firstClause = rValue.getFirstChild();\r\n                        Node secondClause = firstClause.getNext();\r\n                        boolean namesMatch = firstClause.isName() && lValue.isName() && firstClause.getString().equals(lValue.getString());\r\n                        if (namesMatch && secondClause.getJSType() != null && !secondClause.getJSType().isUnknownType()) {\r\n                            return secondClause.getJSType();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\r\n}","lc":0.9090909091,"pi":2.2727272727,"ma":1.6,"nbd":4.0,"ml":2.6666666667,"d":0.7817460317,"mi":-0.6699083862,"fo":2.3333333333,"r":-0.0263157895,"e":1.6920615711}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4184_a0150366","label":1,"code":"\/**\r\n *  Inserts the string representation of the <code>Object<\/code> argument into this string\r\n *  buffer.\r\n *  <p>\r\n *  The second argument is converted to a string as if by the method <code>String.valueOf<\/code>,\r\n *  and the characters of that string are then inserted into this string buffer at the indicated\r\n *  offset.\r\n *  <p>\r\n *  The offset argument must be greater than or equal to <code>0<\/code>, and less than or equal\r\n *  to the length of this string buffer.\r\n *\r\n *  @param offset\r\n *             the offset.\r\n *  @param obj\r\n *             an <code>Object<\/code>.\r\n *  @return a reference to this <code>AppendingStringBuffer<\/code> object.\r\n *  @exception StringIndexOutOfBoundsException\r\n *                 if the offset is invalid.\r\n *  @see java.lang.String#valueOf(java.lang.Object)\r\n *  @see AppendingStringBuffer#insert(int, java.lang.String)\r\n *  @see AppendingStringBuffer#length()\r\n *\/\r\npublic AppendingStringBuffer insert(final int offset, final Object obj) {\r\n    if (obj instanceof AppendingStringBuffer) {\r\n        AppendingStringBuffer asb = (AppendingStringBuffer) obj;\r\n        return insert(offset, asb.value, 0, asb.count);\r\n    } else if (obj instanceof StringBuffer) {\r\n        return insert(offset, obj);\r\n    }\r\n    return insert(offset, String.valueOf(obj));\r\n}","code_comment":"\/**\r\n *  Inserts the string representation of the <code>Object<\/code> argument into this string\r\n *  buffer.\r\n *  <p>\r\n *  The second argument is converted to a string as if by the method <code>String.valueOf<\/code>,\r\n *  and the characters of that string are then inserted into this string buffer at the indicated\r\n *  offset.\r\n *  <p>\r\n *  The offset argument must be greater than or equal to <code>0<\/code>, and less than or equal\r\n *  to the length of this string buffer.\r\n *\r\n *  @param offset\r\n *             the offset.\r\n *  @param obj\r\n *             an <code>Object<\/code>.\r\n *  @return a reference to this <code>AppendingStringBuffer<\/code> object.\r\n *  @exception StringIndexOutOfBoundsException\r\n *                 if the offset is invalid.\r\n *  @see java.lang.String#valueOf(java.lang.Object)\r\n *  @see AppendingStringBuffer#insert(int, java.lang.String)\r\n *  @see AppendingStringBuffer#length()\r\n *\/\r\n","code_no_comment":"public AppendingStringBuffer insert(final int offset, final Object obj) {\r\n    if (obj instanceof AppendingStringBuffer) {\r\n        AppendingStringBuffer asb = (AppendingStringBuffer) obj;\r\n        return insert(offset, asb.value, 0, asb.count);\r\n    } else if (obj instanceof StringBuffer) {\r\n        return insert(offset, obj);\r\n    }\r\n    return insert(offset, String.valueOf(obj));\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.2,"nbd":0.0,"ml":-0.1666666667,"d":-0.3650793651,"mi":0.260324172,"fo":-0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3433_b76b31f7","label":0,"code":"@Override\r\npublic void acquiring() {\r\n    if (store.create(JOURNAL, singletonList(changes.asUpdateOp(getHeadRevision())))) {\r\n        changes = JOURNAL.newDocument(getDocumentStore());\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void acquiring() {\r\n    if (store.create(JOURNAL, singletonList(changes.asUpdateOp(getHeadRevision())))) {\r\n        changes = JOURNAL.newDocument(getDocumentStore());\r\n    }\r\n}","lc":-0.3636363636,"pi":-0.004784689,"ma":-0.4,"nbd":-0.5,"ml":0.0,"d":-0.3650793651,"mi":0.5577167019,"fo":0.0,"r":0.7368421053,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5154_a8586a69","label":3,"code":"\/**\r\n * Choose one of the available methods to invoke if we can match\r\n * the message body to the body parameter\r\n *\r\n * @param pojo the bean to invoke a method on\r\n * @param exchange the message exchange\r\n * @param name an optional name of the method that must match, use <tt>null<\/tt> to indicate all methods\r\n * @return the method to invoke or null if no definitive method could be matched\r\n * @throws AmbiguousMethodCallException is thrown if cannot choose method due to ambiguity\r\n *\/\r\nprotected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) throws AmbiguousMethodCallException {\r\n    \/\/ @Handler should be select first\r\n    \/\/ then any single method that has a custom @annotation\r\n    \/\/ or any single method that has a match parameter type that matches the Exchange payload\r\n    \/\/ and last then try to select the best among the rest\r\n    \/\/ must use defensive copy, to avoid altering the shared lists\r\n    \/\/ and we want to remove unwanted operations from these local lists\r\n    final List<MethodInfo> localOperationsWithBody = new ArrayList<MethodInfo>(operationsWithBody);\r\n    final List<MethodInfo> localOperationsWithCustomAnnotation = new ArrayList<MethodInfo>(operationsWithCustomAnnotation);\r\n    final List<MethodInfo> localOperationsWithHandlerAnnotation = new ArrayList<MethodInfo>(operationsWithHandlerAnnotation);\r\n    if (name != null) {\r\n        \/\/ filter all lists to only include methods with this name\r\n        removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);\r\n        removeNonMatchingMethods(localOperationsWithCustomAnnotation, name);\r\n        removeNonMatchingMethods(localOperationsWithBody, name);\r\n    } else {\r\n        \/\/ remove all getter\/setter as we do not want to consider these methods\r\n        removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation);\r\n        removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation);\r\n        removeAllSetterOrGetterMethods(localOperationsWithBody);\r\n    }\r\n    if (localOperationsWithHandlerAnnotation.size() > 1) {\r\n        \/\/ if we have more than 1 @Handler then its ambiguous\r\n        throw new AmbiguousMethodCallException(exchange, localOperationsWithHandlerAnnotation);\r\n    }\r\n    if (localOperationsWithHandlerAnnotation.size() == 1) {\r\n        \/\/ methods with handler should be preferred\r\n        return localOperationsWithHandlerAnnotation.get(0);\r\n    } else if (localOperationsWithCustomAnnotation.size() == 1) {\r\n        \/\/ if there is one method with an annotation then use that one\r\n        return localOperationsWithCustomAnnotation.get(0);\r\n    } else if (localOperationsWithBody.size() == 1) {\r\n        \/\/ if there is one method with body then use that one\r\n        return localOperationsWithBody.get(0);\r\n    }\r\n    Collection<MethodInfo> possibleOperations = new ArrayList<MethodInfo>();\r\n    possibleOperations.addAll(localOperationsWithBody);\r\n    possibleOperations.addAll(localOperationsWithCustomAnnotation);\r\n    if (!possibleOperations.isEmpty()) {\r\n        \/\/ multiple possible operations so find the best suited if possible\r\n        MethodInfo answer = chooseMethodWithMatchingBody(exchange, possibleOperations, localOperationsWithCustomAnnotation);\r\n        if (answer == null) {\r\n            throw new AmbiguousMethodCallException(exchange, possibleOperations);\r\n        } else {\r\n            return answer;\r\n        }\r\n    }\r\n    \/\/ not possible to determine\r\n    return null;\r\n}","code_comment":"\/**\r\n * Choose one of the available methods to invoke if we can match\r\n * the message body to the body parameter\r\n *\r\n * @param pojo the bean to invoke a method on\r\n * @param exchange the message exchange\r\n * @param name an optional name of the method that must match, use <tt>null<\/tt> to indicate all methods\r\n * @return the method to invoke or null if no definitive method could be matched\r\n * @throws AmbiguousMethodCallException is thrown if cannot choose method due to ambiguity\r\n *\/\r\n","code_no_comment":"protected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) throws AmbiguousMethodCallException {\r\n                            final List<MethodInfo> localOperationsWithBody = new ArrayList<MethodInfo>(operationsWithBody);\r\n    final List<MethodInfo> localOperationsWithCustomAnnotation = new ArrayList<MethodInfo>(operationsWithCustomAnnotation);\r\n    final List<MethodInfo> localOperationsWithHandlerAnnotation = new ArrayList<MethodInfo>(operationsWithHandlerAnnotation);\r\n    if (name != null) {\r\n                removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);\r\n        removeNonMatchingMethods(localOperationsWithCustomAnnotation, name);\r\n        removeNonMatchingMethods(localOperationsWithBody, name);\r\n    } else {\r\n                removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation);\r\n        removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation);\r\n        removeAllSetterOrGetterMethods(localOperationsWithBody);\r\n    }\r\n    if (localOperationsWithHandlerAnnotation.size() > 1) {\r\n                throw new AmbiguousMethodCallException(exchange, localOperationsWithHandlerAnnotation);\r\n    }\r\n    if (localOperationsWithHandlerAnnotation.size() == 1) {\r\n                return localOperationsWithHandlerAnnotation.get(0);\r\n    } else if (localOperationsWithCustomAnnotation.size() == 1) {\r\n                return localOperationsWithCustomAnnotation.get(0);\r\n    } else if (localOperationsWithBody.size() == 1) {\r\n                return localOperationsWithBody.get(0);\r\n    }\r\n    Collection<MethodInfo> possibleOperations = new ArrayList<MethodInfo>();\r\n    possibleOperations.addAll(localOperationsWithBody);\r\n    possibleOperations.addAll(localOperationsWithCustomAnnotation);\r\n    if (!possibleOperations.isEmpty()) {\r\n                MethodInfo answer = chooseMethodWithMatchingBody(exchange, possibleOperations, localOperationsWithCustomAnnotation);\r\n        if (answer == null) {\r\n            throw new AmbiguousMethodCallException(exchange, possibleOperations);\r\n        } else {\r\n            return answer;\r\n        }\r\n    }\r\n        return null;\r\n}","lc":1.0,"pi":-0.1196172249,"ma":1.2,"nbd":0.5,"ml":0.6666666667,"d":0.8511904762,"mi":-0.6493305144,"fo":0.9166666667,"r":-0.0263157895,"e":1.4003284867}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1655_01a8b283","label":1,"code":"@Override\r\npublic Iterator<String> getAllChunkIds(long maxLastModifiedTime) throws Exception {\r\n    \/\/ TODO Ignores the maxLastModifiedTime currently.\r\n    return Iterators.transform(delegate.getAllIdentifiers(), new Function<DataIdentifier, String>() {\r\n\r\n        @Nullable\r\n        @Override\r\n        public String apply(@Nullable DataIdentifier input) {\r\n            return input.toString();\r\n        }\r\n    });\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Iterator<String> getAllChunkIds(long maxLastModifiedTime) throws Exception {\r\n        return Iterators.transform(delegate.getAllIdentifiers(), new Function<DataIdentifier, String>() {\r\n\r\n        @Nullable\r\n        @Override\r\n        public String apply(@Nullable DataIdentifier input) {\r\n            return input.toString();\r\n        }\r\n    });\r\n}","lc":-0.1818181818,"pi":0.4928229665,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.2535588443,"fo":-0.25,"r":0.5526315789,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-193_8ad5a888","label":3,"code":"public String toStringNoTime() {\r\n    String labelString = new ColumnVisibility(colVisibility).toString();\r\n    String s = new String(row, 0, row.length) + \" \" + new String(colFamily, 0, colFamily.length) + \":\" + new String(colQualifier, 0, colQualifier.length) + \" \" + labelString;\r\n    return s;\r\n}","code_comment":null,"code_no_comment":"public String toStringNoTime() {\r\n    String labelString = new ColumnVisibility(colVisibility).toString();\r\n    String s = new String(row, 0, row.length) + \" \" + new String(colFamily, 0, colFamily.length) + \":\" + new String(colQualifier, 0, colQualifier.length) + \" \" + labelString;\r\n    return s;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":0.0317460317,"mi":0.5171247357,"fo":-0.4166666667,"r":-0.0263157895,"e":-0.0384202671}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4119_bb7a6995","label":1,"code":"@Override\r\nprotected ResourceResponse newResourceResponse(Attributes attributes) {\r\n    ResourceResponse data = new ResourceResponse();\r\n    Time lastModifiedTime = stream.lastModifiedTime();\r\n    if (lastModifiedTime != null) {\r\n        data.setLastModified(lastModifiedTime);\r\n    }\r\n    \/\/ performance check; don't bother to do anything if the resource is still cached by client\r\n    if (data.dataNeedsToBeWritten(attributes)) {\r\n        InputStream inputStream = null;\r\n        if (stream instanceof IResourceStreamWriter == false) {\r\n            try {\r\n                inputStream = stream.getInputStream();\r\n            } catch (ResourceStreamNotFoundException e) {\r\n                data.setError(HttpServletResponse.SC_NOT_FOUND);\r\n                close();\r\n            }\r\n        }\r\n        data.setContentDisposition(contentDisposition);\r\n        Bytes length = stream.length();\r\n        if (length != null) {\r\n            data.setContentLength(length.bytes());\r\n        }\r\n        data.setFileName(fileName);\r\n        String contentType = stream.getContentType();\r\n        if (contentType == null && fileName != null && Application.exists()) {\r\n            contentType = Application.get().getMimeType(fileName);\r\n        }\r\n        data.setContentType(contentType);\r\n        data.setTextEncoding(textEncoding);\r\n        if (stream instanceof IResourceStreamWriter) {\r\n            data.setWriteCallback(new WriteCallback() {\r\n\r\n                @Override\r\n                public void writeData(Attributes attributes) {\r\n                    ((IResourceStreamWriter) stream).write(attributes.getResponse());\r\n                    close();\r\n                }\r\n            });\r\n        } else {\r\n            final InputStream s = inputStream;\r\n            data.setWriteCallback(new WriteCallback() {\r\n\r\n                @Override\r\n                public void writeData(Attributes attributes) {\r\n                    try {\r\n                        writeStream(attributes, s);\r\n                    } finally {\r\n                        close();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n    return data;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected ResourceResponse newResourceResponse(Attributes attributes) {\r\n    ResourceResponse data = new ResourceResponse();\r\n    Time lastModifiedTime = stream.lastModifiedTime();\r\n    if (lastModifiedTime != null) {\r\n        data.setLastModified(lastModifiedTime);\r\n    }\r\n        if (data.dataNeedsToBeWritten(attributes)) {\r\n        InputStream inputStream = null;\r\n        if (stream instanceof IResourceStreamWriter == false) {\r\n            try {\r\n                inputStream = stream.getInputStream();\r\n            } catch (ResourceStreamNotFoundException e) {\r\n                data.setError(HttpServletResponse.SC_NOT_FOUND);\r\n                close();\r\n            }\r\n        }\r\n        data.setContentDisposition(contentDisposition);\r\n        Bytes length = stream.length();\r\n        if (length != null) {\r\n            data.setContentLength(length.bytes());\r\n        }\r\n        data.setFileName(fileName);\r\n        String contentType = stream.getContentType();\r\n        if (contentType == null && fileName != null && Application.exists()) {\r\n            contentType = Application.get().getMimeType(fileName);\r\n        }\r\n        data.setContentType(contentType);\r\n        data.setTextEncoding(textEncoding);\r\n        if (stream instanceof IResourceStreamWriter) {\r\n            data.setWriteCallback(new WriteCallback() {\r\n\r\n                @Override\r\n                public void writeData(Attributes attributes) {\r\n                    ((IResourceStreamWriter) stream).write(attributes.getResponse());\r\n                    close();\r\n                }\r\n            });\r\n        } else {\r\n            final InputStream s = inputStream;\r\n            data.setWriteCallback(new WriteCallback() {\r\n\r\n                @Override\r\n                public void writeData(Attributes attributes) {\r\n                    try {\r\n                        writeStream(attributes, s);\r\n                    } finally {\r\n                        close();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n    return data;\r\n}","lc":1.7727272727,"pi":1.3875598086,"ma":0.8,"nbd":1.0,"ml":0.9166666667,"d":0.4761904762,"mi":-0.8438336857,"fo":1.5,"r":-0.0263157895,"e":1.171171545}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-4467_79168a23","label":3,"code":"protected synchronized void doStop() throws Exception {\r\n    stopWatch.restart();\r\n    log.info(\"Apache Camel \" + getVersion() + \" (CamelContext:\" + getName() + \") is shutting down\");\r\n    EventHelper.notifyCamelContextStopping(this);\r\n    \/\/ stop route inputs in the same order as they was started so we stop the very first inputs first\r\n    try {\r\n        shutdownStrategy.shutdown(this, getRouteStartupOrder());\r\n    } catch (Throwable e) {\r\n        log.warn(\"Error occurred while shutting down routes. This exception will be ignored.\", e);\r\n    }\r\n    getRouteStartupOrder().clear();\r\n    shutdownServices(routeServices.values());\r\n    \/\/ do not clear route services or startup listeners as we can start Camel again and get the route back as before\r\n    \/\/ but clear any suspend routes\r\n    suspendedRouteServices.clear();\r\n    \/\/ the stop order is important\r\n    \/\/ shutdown debugger\r\n    ServiceHelper.stopAndShutdownService(getDebugger());\r\n    shutdownServices(endpoints.values());\r\n    endpoints.clear();\r\n    shutdownServices(components.values());\r\n    components.clear();\r\n    try {\r\n        for (LifecycleStrategy strategy : lifecycleStrategies) {\r\n            strategy.onContextStop(this);\r\n        }\r\n    } catch (Throwable e) {\r\n        log.warn(\"Error occurred while stopping lifecycle strategies. This exception will be ignored.\", e);\r\n    }\r\n    \/\/ shutdown services as late as possible\r\n    shutdownServices(servicesToClose);\r\n    servicesToClose.clear();\r\n    \/\/ must notify that we are stopped before stopping the management strategy\r\n    EventHelper.notifyCamelContextStopped(this);\r\n    \/\/ stop the notifier service\r\n    for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {\r\n        shutdownServices(notifier);\r\n    }\r\n    \/\/ shutdown management as the last one\r\n    shutdownServices(managementStrategy);\r\n    \/\/ stop the lazy created so they can be re-created on restart\r\n    forceStopLazyInitialization();\r\n    stopWatch.stop();\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"Uptime: \" + getUptime());\r\n        log.info(\"Apache Camel \" + getVersion() + \" (CamelContext: \" + getName() + \") is shutdown in \" + TimeUtils.printDuration(stopWatch.taken()));\r\n    }\r\n    \/\/ and clear start date\r\n    startDate = null;\r\n}","code_comment":null,"code_no_comment":"protected synchronized void doStop() throws Exception {\r\n    stopWatch.restart();\r\n    log.info(\"Apache Camel \" + getVersion() + \" (CamelContext:\" + getName() + \") is shutting down\");\r\n    EventHelper.notifyCamelContextStopping(this);\r\n        try {\r\n        shutdownStrategy.shutdown(this, getRouteStartupOrder());\r\n    } catch (Throwable e) {\r\n        log.warn(\"Error occurred while shutting down routes. This exception will be ignored.\", e);\r\n    }\r\n    getRouteStartupOrder().clear();\r\n    shutdownServices(routeServices.values());\r\n            suspendedRouteServices.clear();\r\n            ServiceHelper.stopAndShutdownService(getDebugger());\r\n    shutdownServices(endpoints.values());\r\n    endpoints.clear();\r\n    shutdownServices(components.values());\r\n    components.clear();\r\n    try {\r\n        for (LifecycleStrategy strategy : lifecycleStrategies) {\r\n            strategy.onContextStop(this);\r\n        }\r\n    } catch (Throwable e) {\r\n        log.warn(\"Error occurred while stopping lifecycle strategies. This exception will be ignored.\", e);\r\n    }\r\n        shutdownServices(servicesToClose);\r\n    servicesToClose.clear();\r\n        EventHelper.notifyCamelContextStopped(this);\r\n        for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {\r\n        shutdownServices(notifier);\r\n    }\r\n        shutdownServices(managementStrategy);\r\n        forceStopLazyInitialization();\r\n    stopWatch.stop();\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"Uptime: \" + getUptime());\r\n        log.info(\"Apache Camel \" + getVersion() + \" (CamelContext: \" + getName() + \") is shutdown in \" + TimeUtils.printDuration(stopWatch.taken()));\r\n    }\r\n        startDate = null;\r\n}","lc":1.1363636364,"pi":-0.3540669856,"ma":0.4,"nbd":0.0,"ml":-0.25,"d":-0.0396825397,"mi":-0.6589147287,"fo":2.8333333333,"r":-0.0263157895,"e":0.2508462855}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-880_2a9cbbab","label":1,"code":"\/**\r\n * Recursively build a tree by inserting cut sub-hyperplanes.\r\n * @param hyperplaneThickness tolerance below which points are consider to\r\n * belong to the hyperplane (which is therefore more a slab)\r\n * @param node current tree node (it is a leaf node at the beginning\r\n * of the call)\r\n * @param vertices list of vertices belonging to the boundary of the\r\n * cell defined by the node\r\n *\/\r\nprivate static void insertVertices(final double hyperplaneThickness, final BSPTree<Euclidean2D> node, final List<Vertex> vertices) {\r\n    Vertex current = vertices.get(vertices.size() - 1);\r\n    int index = 0;\r\n    Line inserted = null;\r\n    while (inserted == null && index < vertices.size()) {\r\n        final Vertex previous = current;\r\n        current = vertices.get(index++);\r\n        if (previous.outgoingNeedsProcessing() && current.incomingNeedsProcessing()) {\r\n            if (previous.shareNodeWith(current)) {\r\n                \/\/ both vertices are already handled by an existing node,\r\n                \/\/ closer to the tree root, they were probably created\r\n                \/\/ when split points were introduced\r\n                inserted = null;\r\n            } else {\r\n                inserted = new Line(previous.getLocation(), current.getLocation());\r\n                if (node.insertCut(inserted)) {\r\n                    previous.addNode(node);\r\n                    previous.outgoingProcessed();\r\n                    current.addNode(node);\r\n                    current.incomingProcessed();\r\n                } else {\r\n                    inserted = null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (node.getCut() == null) {\r\n        final BSPTree<Euclidean2D> parent = node.getParent();\r\n        if (parent == null || node == parent.getMinus()) {\r\n            node.setAttribute(Boolean.TRUE);\r\n        } else {\r\n            node.setAttribute(Boolean.FALSE);\r\n        }\r\n        return;\r\n    }\r\n    \/\/ distribute the remaining vertices in the two sub-trees\r\n    Side currentSide = Side.HYPER;\r\n    final List<Vertex> plusList = new ArrayList<Vertex>();\r\n    plusList.add(current);\r\n    int plusCount = 0;\r\n    final List<Vertex> minusList = new ArrayList<Vertex>();\r\n    minusList.add(current);\r\n    int minusCount = 0;\r\n    while (index < vertices.size()) {\r\n        final Vertex previous = current;\r\n        final Side previousSide = currentSide;\r\n        current = vertices.get(index++);\r\n        final double currentOffset = inserted.getOffset(current.getLocation());\r\n        currentSide = (FastMath.abs(currentOffset) <= hyperplaneThickness) ? Side.HYPER : ((currentOffset < 0) ? Side.MINUS : Side.PLUS);\r\n        switch(currentSide) {\r\n            case PLUS:\r\n                if (previousSide == Side.MINUS) {\r\n                    \/\/ we need to insert a split point on the hyperplane\r\n                    final Line line = new Line(previous.getLocation(), current.getLocation());\r\n                    final Vertex splitPoint = new Vertex(inserted.intersection(line));\r\n                    splitPoint.addNode(node);\r\n                    minusList.add(splitPoint);\r\n                    plusList.add(splitPoint);\r\n                }\r\n                plusList.add(current);\r\n                if (current.incomingNeedsProcessing() || current.outgoingNeedsProcessing()) {\r\n                    ++plusCount;\r\n                }\r\n                break;\r\n            case MINUS:\r\n                if (previousSide == Side.PLUS) {\r\n                    \/\/ we need to insert a split point on the hyperplane\r\n                    final Line line = new Line(previous.getLocation(), current.getLocation());\r\n                    final Vertex splitPoint = new Vertex(inserted.intersection(line));\r\n                    splitPoint.addNode(node);\r\n                    minusList.add(splitPoint);\r\n                    plusList.add(splitPoint);\r\n                }\r\n                minusList.add(current);\r\n                if (current.incomingNeedsProcessing() || current.outgoingNeedsProcessing()) {\r\n                    ++minusCount;\r\n                }\r\n                break;\r\n            default:\r\n                current.addNode(node);\r\n                plusList.add(current);\r\n                minusList.add(current);\r\n                break;\r\n        }\r\n    }\r\n    \/\/ recurse through lower levels\r\n    if (plusCount > 0) {\r\n        insertVertices(hyperplaneThickness, node.getPlus(), plusList);\r\n    } else {\r\n        node.getPlus().setAttribute(Boolean.FALSE);\r\n    }\r\n    if (minusCount > 0) {\r\n        insertVertices(hyperplaneThickness, node.getMinus(), minusList);\r\n    } else {\r\n        node.getMinus().setAttribute(Boolean.TRUE);\r\n    }\r\n}","code_comment":"\/**\r\n * Recursively build a tree by inserting cut sub-hyperplanes.\r\n * @param hyperplaneThickness tolerance below which points are consider to\r\n * belong to the hyperplane (which is therefore more a slab)\r\n * @param node current tree node (it is a leaf node at the beginning\r\n * of the call)\r\n * @param vertices list of vertices belonging to the boundary of the\r\n * cell defined by the node\r\n *\/\r\n","code_no_comment":"private static void insertVertices(final double hyperplaneThickness, final BSPTree<Euclidean2D> node, final List<Vertex> vertices) {\r\n    Vertex current = vertices.get(vertices.size() - 1);\r\n    int index = 0;\r\n    Line inserted = null;\r\n    while (inserted == null && index < vertices.size()) {\r\n        final Vertex previous = current;\r\n        current = vertices.get(index++);\r\n        if (previous.outgoingNeedsProcessing() && current.incomingNeedsProcessing()) {\r\n            if (previous.shareNodeWith(current)) {\r\n                                                                inserted = null;\r\n            } else {\r\n                inserted = new Line(previous.getLocation(), current.getLocation());\r\n                if (node.insertCut(inserted)) {\r\n                    previous.addNode(node);\r\n                    previous.outgoingProcessed();\r\n                    current.addNode(node);\r\n                    current.incomingProcessed();\r\n                } else {\r\n                    inserted = null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (node.getCut() == null) {\r\n        final BSPTree<Euclidean2D> parent = node.getParent();\r\n        if (parent == null || node == parent.getMinus()) {\r\n            node.setAttribute(Boolean.TRUE);\r\n        } else {\r\n            node.setAttribute(Boolean.FALSE);\r\n        }\r\n        return;\r\n    }\r\n        Side currentSide = Side.HYPER;\r\n    final List<Vertex> plusList = new ArrayList<Vertex>();\r\n    plusList.add(current);\r\n    int plusCount = 0;\r\n    final List<Vertex> minusList = new ArrayList<Vertex>();\r\n    minusList.add(current);\r\n    int minusCount = 0;\r\n    while (index < vertices.size()) {\r\n        final Vertex previous = current;\r\n        final Side previousSide = currentSide;\r\n        current = vertices.get(index++);\r\n        final double currentOffset = inserted.getOffset(current.getLocation());\r\n        currentSide = (FastMath.abs(currentOffset) <= hyperplaneThickness) ? Side.HYPER : ((currentOffset < 0) ? Side.MINUS : Side.PLUS);\r\n        switch(currentSide) {\r\n            case PLUS:\r\n                if (previousSide == Side.MINUS) {\r\n                                        final Line line = new Line(previous.getLocation(), current.getLocation());\r\n                    final Vertex splitPoint = new Vertex(inserted.intersection(line));\r\n                    splitPoint.addNode(node);\r\n                    minusList.add(splitPoint);\r\n                    plusList.add(splitPoint);\r\n                }\r\n                plusList.add(current);\r\n                if (current.incomingNeedsProcessing() || current.outgoingNeedsProcessing()) {\r\n                    ++plusCount;\r\n                }\r\n                break;\r\n            case MINUS:\r\n                if (previousSide == Side.PLUS) {\r\n                                        final Line line = new Line(previous.getLocation(), current.getLocation());\r\n                    final Vertex splitPoint = new Vertex(inserted.intersection(line));\r\n                    splitPoint.addNode(node);\r\n                    minusList.add(splitPoint);\r\n                    plusList.add(splitPoint);\r\n                }\r\n                minusList.add(current);\r\n                if (current.incomingNeedsProcessing() || current.outgoingNeedsProcessing()) {\r\n                    ++minusCount;\r\n                }\r\n                break;\r\n            default:\r\n                current.addNode(node);\r\n                plusList.add(current);\r\n                minusList.add(current);\r\n                break;\r\n        }\r\n    }\r\n        if (plusCount > 0) {\r\n        insertVertices(hyperplaneThickness, node.getPlus(), plusList);\r\n    } else {\r\n        node.getPlus().setAttribute(Boolean.FALSE);\r\n    }\r\n    if (minusCount > 0) {\r\n        insertVertices(hyperplaneThickness, node.getMinus(), minusList);\r\n    } else {\r\n        node.getMinus().setAttribute(Boolean.TRUE);\r\n    }\r\n}","lc":3.4545454545,"pi":1.5119617225,"ma":3.6,"nbd":1.0,"ml":3.0833333333,"d":3.1130952381,"mi":-1.3117688513,"fo":4.0833333333,"r":-0.0263157895,"e":13.7036335241}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5326_ded3c583","label":1,"code":"@Override\r\npublic int getCompatibilityScore(final Request request) {\r\n    return wrappedMapper.getCompatibilityScore(request);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int getCompatibilityScore(final Request request) {\r\n    return wrappedMapper.getCompatibilityScore(request);\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8940098661,"fo":-0.4166666667,"r":1.3947368421,"e":-0.1627934049}
{"project_name":"Closure","project_version":"111","label":2,"code":"@Override\r\nprotected JSType caseTopType(JSType topType) {\r\n    return topType;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected JSType caseTopType(JSType topType) {\r\n    return topType;\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9292459479,"fo":-0.5,"r":2.1315789474,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3740_f2f5bd5b","label":1,"code":"@SuppressWarnings(\"unchecked\")\r\nprotected void processTriggerResult(TriggerResult triggerResult, K key, W window) throws Exception {\r\n    if (!triggerResult.isFire() && !triggerResult.isPurge()) {\r\n        \/\/ do nothing\r\n        return;\r\n    }\r\n    AppendingState<IN, ACC> windowState;\r\n    MergingWindowSet<W> mergingWindows = null;\r\n    if (windowAssigner instanceof MergingWindowAssigner) {\r\n        mergingWindows = mergingWindowsByKey.get(key);\r\n        W stateWindow = mergingWindows.getStateWindow(window);\r\n        windowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\r\n    } else {\r\n        windowState = getPartitionedState(window, windowSerializer, windowStateDescriptor);\r\n    }\r\n    if (triggerResult.isFire()) {\r\n        timestampedCollector.setAbsoluteTimestamp(window.maxTimestamp());\r\n        ACC contents = windowState.get();\r\n        userFunction.apply(context.key, context.window, contents, timestampedCollector);\r\n    }\r\n    if (triggerResult.isPurge()) {\r\n        windowState.clear();\r\n        if (mergingWindows != null) {\r\n            mergingWindows.retireWindow(window);\r\n        }\r\n        context.clear();\r\n    }\r\n}","code_comment":null,"code_no_comment":"@SuppressWarnings(\"unchecked\")\r\nprotected void processTriggerResult(TriggerResult triggerResult, K key, W window) throws Exception {\r\n    if (!triggerResult.isFire() && !triggerResult.isPurge()) {\r\n                return;\r\n    }\r\n    AppendingState<IN, ACC> windowState;\r\n    MergingWindowSet<W> mergingWindows = null;\r\n    if (windowAssigner instanceof MergingWindowAssigner) {\r\n        mergingWindows = mergingWindowsByKey.get(key);\r\n        W stateWindow = mergingWindows.getStateWindow(window);\r\n        windowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\r\n    } else {\r\n        windowState = getPartitionedState(window, windowSerializer, windowStateDescriptor);\r\n    }\r\n    if (triggerResult.isFire()) {\r\n        timestampedCollector.setAbsoluteTimestamp(window.maxTimestamp());\r\n        ACC contents = windowState.get();\r\n        userFunction.apply(context.key, context.window, contents, timestampedCollector);\r\n    }\r\n    if (triggerResult.isPurge()) {\r\n        windowState.clear();\r\n        if (mergingWindows != null) {\r\n            mergingWindows.retireWindow(window);\r\n        }\r\n        context.clear();\r\n    }\r\n}","lc":0.5909090909,"pi":-0.028708134,"ma":0.4,"nbd":0.0,"ml":0.4166666667,"d":0.3968253968,"mi":-0.4610288936,"fo":0.75,"r":-0.0263157895,"e":0.6299914132}
{"project_name":"Closure","project_version":"57","label":2,"code":"private static String extractClassNameIfGoog(Node node, Node parent, String functionName) {\r\n    String className = null;\r\n    if (NodeUtil.isExprCall(parent)) {\r\n        Node callee = node.getFirstChild();\r\n        if (callee != null && callee.getType() == Token.GETPROP) {\r\n            String qualifiedName = callee.getQualifiedName();\r\n            if (functionName.equals(qualifiedName)) {\r\n                Node target = callee.getNext();\r\n                if (target != null) {\r\n                    className = target.getString();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return className;\r\n}","code_comment":null,"code_no_comment":"private static String extractClassNameIfGoog(Node node, Node parent, String functionName) {\r\n    String className = null;\r\n    if (NodeUtil.isExprCall(parent)) {\r\n        Node callee = node.getFirstChild();\r\n        if (callee != null && callee.getType() == Token.GETPROP) {\r\n            String qualifiedName = callee.getQualifiedName();\r\n            if (functionName.equals(qualifiedName)) {\r\n                Node target = callee.getNext();\r\n                if (target != null) {\r\n                    className = target.getString();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return className;\r\n}","lc":0.0909090909,"pi":1.4019138756,"ma":0.2,"nbd":1.0,"ml":0.5833333333,"d":0.3928571429,"mi":-0.1241719521,"fo":0.0833333333,"r":0.1052631579,"e":0.2591910006}
{"project_name":"Cli","project_version":"1","label":1,"code":"\/**\r\n * Retrieves the array of values, if any, of an option.\r\n *\r\n * @param opt string name of the option\r\n * @return Values of the argument if option is set, and has an argument,\r\n * otherwise null.\r\n *\/\r\npublic String[] getOptionValues(String opt) {\r\n    opt = Util.stripLeadingHyphens(opt);\r\n    String key = opt;\r\n    if (names.containsKey(opt)) {\r\n        key = (String) names.get(opt);\r\n    }\r\n    if (options.containsKey(key)) {\r\n        return ((Option) options.get(key)).getValues();\r\n    }\r\n    return null;\r\n}","code_comment":"\/**\r\n * Retrieves the array of values, if any, of an option.\r\n *\r\n * @param opt string name of the option\r\n * @return Values of the argument if option is set, and has an argument,\r\n * otherwise null.\r\n *\/\r\n","code_no_comment":"public String[] getOptionValues(String opt) {\r\n    opt = Util.stripLeadingHyphens(opt);\r\n    String key = opt;\r\n    if (names.containsKey(opt)) {\r\n        key = (String) names.get(opt);\r\n    }\r\n    if (options.containsKey(key)) {\r\n        return ((Option) options.get(key)).getValues();\r\n    }\r\n    return null;\r\n}","lc":-0.1363636364,"pi":-0.2775119617,"ma":-0.2,"nbd":-0.5,"ml":0.0833333333,"d":-0.3650793651,"mi":0.1554615927,"fo":0.0,"r":0.6052631579,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  @see wicket.feedback.IFeedback#updateFeedback()\r\n *\/\r\npublic void updateFeedback() {\r\n    \/\/ Get the messages for the current page\r\n    setVisible(getPage().getFeedbackMessages().hasMessage(getFeedbackMessageFilter()));\r\n}","code_comment":"\/**\r\n *  @see wicket.feedback.IFeedback#updateFeedback()\r\n *\/\r\n","code_no_comment":"public void updateFeedback() {\r\n        setVisible(getPage().getFeedbackMessages().hasMessage(getFeedbackMessageFilter()));\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0329809725,"fo":-0.0833333333,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3511_4a875f46","label":1,"code":"public String getReference() {\r\n    return url;\r\n}","code_comment":null,"code_no_comment":"public String getReference() {\r\n    return url;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.1646229739,"fo":-0.5,"r":2.3684210526,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-614_6feacf6b","label":1,"code":"@Nonnull\r\nprivate NodeState read() {\r\n    if (revision != root.revision) {\r\n        \/\/ root never gets here since revision == root.revision\r\n        assert (!isRoot());\r\n        checkState(!removed(), \"This node has already been removed\");\r\n        parent.read();\r\n        \/\/ The builder could have been reset, need to re-get base state\r\n        baseState = parent.getBaseState(name);\r\n        \/\/ ... same for the write state\r\n        writeState = parent.getWriteState(name);\r\n        revision = root.revision;\r\n    }\r\n    assert classInvariants();\r\n    if (writeState != null) {\r\n        return writeState;\r\n    } else {\r\n        return baseState;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\nprivate NodeState read() {\r\n    if (revision != root.revision) {\r\n                assert (!isRoot());\r\n        checkState(!removed(), \"This node has already been removed\");\r\n        parent.read();\r\n                baseState = parent.getBaseState(name);\r\n                writeState = parent.getWriteState(name);\r\n        revision = root.revision;\r\n    }\r\n    assert classInvariants();\r\n    if (writeState != null) {\r\n        return writeState;\r\n    } else {\r\n        return baseState;\r\n    }\r\n}","lc":0.1363636364,"pi":0.0,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":-0.3650793651,"mi":0.3595489782,"fo":0.0833333333,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1227_117b0a3d","label":1,"code":"@Override\r\npublic boolean hasNode(String relPath) throws RepositoryException {\r\n    final String oakPath = getOakPathOrThrow(relPath);\r\n    return perform(new NodeOperation<Boolean>(dlg) {\r\n\r\n        @Override\r\n        public Boolean perform() throws RepositoryException {\r\n            return node.getChild(oakPath) != null;\r\n        }\r\n    });\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean hasNode(String relPath) throws RepositoryException {\r\n    final String oakPath = getOakPathOrThrow(relPath);\r\n    return perform(new NodeOperation<Boolean>(dlg) {\r\n\r\n        @Override\r\n        public Boolean perform() throws RepositoryException {\r\n            return node.getChild(oakPath) != null;\r\n        }\r\n    });\r\n}","lc":-0.1818181818,"pi":0.4449760766,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.0734126984,"mi":0.2473572939,"fo":-0.25,"r":1.7105263158,"e":-0.0964598353}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2857_9fcca2ed","label":1,"code":"@Override\r\npublic Map<String, String> tableIdMap() {\r\n    Map<String, String> result = new HashMap<String, String>();\r\n    for (String table : acu.tables.keySet()) {\r\n        result.put(table, table);\r\n    }\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Map<String, String> tableIdMap() {\r\n    Map<String, String> result = new HashMap<String, String>();\r\n    for (String table : acu.tables.keySet()) {\r\n        result.put(table, table);\r\n    }\r\n    return result;\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.3572938689,"fo":-0.3333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Codec","project_version":"1","label":1,"code":"\/**\r\n *  Cleans up the input string before Soundex processing by only returning\r\n *  upper case letters.\r\n *\r\n *  @param str\r\n *                   The String to clean.\r\n *  @return A clean String.\r\n *\/\r\nstatic String clean(String str) {\r\n    if (str == null || str.length() == 0) {\r\n        return str;\r\n    }\r\n    int len = str.length();\r\n    char[] chars = new char[len];\r\n    int count = 0;\r\n    for (int i = 0; i < len; i++) {\r\n        if (Character.isLetter(str.charAt(i))) {\r\n            chars[count++] = str.charAt(i);\r\n        }\r\n    }\r\n    if (count == len) {\r\n        return str.toUpperCase();\r\n    }\r\n    return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\r\n}","code_comment":"\/**\r\n *  Cleans up the input string before Soundex processing by only returning\r\n *  upper case letters.\r\n *\r\n *  @param str\r\n *                   The String to clean.\r\n *  @return A clean String.\r\n *\/\r\n","code_no_comment":"static String clean(String str) {\r\n    if (str == null || str.length() == 0) {\r\n        return str;\r\n    }\r\n    int len = str.length();\r\n    char[] chars = new char[len];\r\n    int count = 0;\r\n    for (int i = 0; i < len; i++) {\r\n        if (Character.isLetter(str.charAt(i))) {\r\n            chars[count++] = str.charAt(i);\r\n        }\r\n    }\r\n    if (count == len) {\r\n        return str.toUpperCase();\r\n    }\r\n    return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);\r\n}","lc":0.1363636364,"pi":-0.033492823,"ma":0.2,"nbd":0.0,"ml":0.5833333333,"d":0.5952380952,"mi":-0.1670190275,"fo":0.0833333333,"r":0.0789473684,"e":0.4308570045}
{"project_name":"Compress","project_version":"26","label":1,"code":"\/**\r\n * Skips the given number of bytes by repeatedly invoking skip on\r\n * the given input stream if necessary.\r\n *\r\n * <p>In a case where the stream's skip() method returns 0 before\r\n * the requested number of bytes has been skip this implementation\r\n * will fall back to using the read() method.<\/p>\r\n *\r\n * <p>This method will only skip less than the requested number of\r\n * bytes if the end of the input stream has been reached.<\/p>\r\n *\r\n * @param input stream to skip bytes in\r\n * @param numToSkip the number of bytes to skip\r\n * @return the number of bytes actually skipped\r\n * @throws IOException\r\n *\/\r\npublic static long skip(InputStream input, long numToSkip) throws IOException {\r\n    long available = numToSkip;\r\n    while (numToSkip > 0) {\r\n        long skipped = input.skip(numToSkip);\r\n        if (skipped == 0) {\r\n            break;\r\n        }\r\n        numToSkip -= skipped;\r\n    }\r\n    return available - numToSkip;\r\n}","code_comment":"\/**\r\n * Skips the given number of bytes by repeatedly invoking skip on\r\n * the given input stream if necessary.\r\n *\r\n * <p>In a case where the stream's skip() method returns 0 before\r\n * the requested number of bytes has been skip this implementation\r\n * will fall back to using the read() method.<\/p>\r\n *\r\n * <p>This method will only skip less than the requested number of\r\n * bytes if the end of the input stream has been reached.<\/p>\r\n *\r\n * @param input stream to skip bytes in\r\n * @param numToSkip the number of bytes to skip\r\n * @return the number of bytes actually skipped\r\n * @throws IOException\r\n *\/\r\n","code_no_comment":"public static long skip(InputStream input, long numToSkip) throws IOException {\r\n    long available = numToSkip;\r\n    while (numToSkip > 0) {\r\n        long skipped = input.skip(numToSkip);\r\n        if (skipped == 0) {\r\n            break;\r\n        }\r\n        numToSkip -= skipped;\r\n    }\r\n    return available - numToSkip;\r\n}","lc":-0.1363636364,"pi":0.2583732057,"ma":0.0,"nbd":0.0,"ml":-0.0833333333,"d":0.5158730159,"mi":0.1830866808,"fo":-0.4166666667,"r":0.2631578947,"e":0.0400431067}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6936_4954d573","label":1,"code":"\/**\r\n * Strategy for validating if the given remote file should be included or not\r\n *\r\n * @param file        the file\r\n * @param isDirectory whether the file is a directory or a file\r\n * @param files       files in the directory\r\n * @return <tt>true<\/tt> to include the file, <tt>false<\/tt> to skip it\r\n *\/\r\nprotected boolean isValidFile(GenericFile<T> file, boolean isDirectory, List<T> files) {\r\n    if (!isMatched(file, isDirectory, files)) {\r\n        log.trace(\"File did not match. Will skip this file: {}\", file);\r\n        return false;\r\n    }\r\n    \/\/ if its a file then check if its already in progress\r\n    if (!isDirectory && isInProgress(file)) {\r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"Skipping as file is already in progress: {}\", file.getFileName());\r\n        }\r\n        return false;\r\n    }\r\n    \/\/ if its a file then check we have the file in the idempotent registry already\r\n    if (!isDirectory && endpoint.isIdempotent()) {\r\n        \/\/ use absolute file path as default key, but evaluate if an expression key was configured\r\n        String key = file.getAbsoluteFilePath();\r\n        if (endpoint.getIdempotentKey() != null) {\r\n            Exchange dummy = endpoint.createExchange(file);\r\n            key = endpoint.getIdempotentKey().evaluate(dummy, String.class);\r\n        }\r\n        if (key != null && endpoint.getIdempotentRepository().contains(key)) {\r\n            log.trace(\"This consumer is idempotent and the file has been consumed before. Will skip this file: {}\", file);\r\n            return false;\r\n        }\r\n    }\r\n    \/\/ file matched\r\n    return true;\r\n}","code_comment":"\/**\r\n * Strategy for validating if the given remote file should be included or not\r\n *\r\n * @param file        the file\r\n * @param isDirectory whether the file is a directory or a file\r\n * @param files       files in the directory\r\n * @return <tt>true<\/tt> to include the file, <tt>false<\/tt> to skip it\r\n *\/\r\n","code_no_comment":"protected boolean isValidFile(GenericFile<T> file, boolean isDirectory, List<T> files) {\r\n    if (!isMatched(file, isDirectory, files)) {\r\n        log.trace(\"File did not match. Will skip this file: {}\", file);\r\n        return false;\r\n    }\r\n        if (!isDirectory && isInProgress(file)) {\r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"Skipping as file is already in progress: {}\", file.getFileName());\r\n        }\r\n        return false;\r\n    }\r\n        if (!isDirectory && endpoint.isIdempotent()) {\r\n                String key = file.getAbsoluteFilePath();\r\n        if (endpoint.getIdempotentKey() != null) {\r\n            Exchange dummy = endpoint.createExchange(file);\r\n            key = endpoint.getIdempotentKey().evaluate(dummy, String.class);\r\n        }\r\n        if (key != null && endpoint.getIdempotentRepository().contains(key)) {\r\n            log.trace(\"This consumer is idempotent and the file has been consumed before. Will skip this file: {}\", file);\r\n            return false;\r\n        }\r\n    }\r\n        return true;\r\n}","lc":0.4545454545,"pi":0.2488038278,"ma":0.6,"nbd":0.0,"ml":1.1666666667,"d":0.4047619048,"mi":-0.3888653982,"fo":0.75,"r":-0.0263157895,"e":0.5114411346}
{"project_name":"Compress","project_version":"2","label":1,"code":"\/**\r\n * Returns the next AR entry in this stream.\r\n *\r\n * @return the next AR entry.\r\n * @throws IOException\r\n *             if the entry could not be read\r\n *\/\r\npublic ArArchiveEntry getNextArEntry() throws IOException {\r\n    if (offset == 0) {\r\n        final byte[] expected = ArArchiveEntry.HEADER.getBytes();\r\n        final byte[] realized = new byte[expected.length];\r\n        final int read = read(realized);\r\n        if (read != expected.length) {\r\n            throw new IOException(\"failed to read header\");\r\n        }\r\n        for (int i = 0; i < expected.length; i++) {\r\n            if (expected[i] != realized[i]) {\r\n                throw new IOException(\"invalid header \" + new String(realized));\r\n            }\r\n        }\r\n    }\r\n    if (input.available() == 0) {\r\n        return null;\r\n    }\r\n    if (offset % 2 != 0) {\r\n        read();\r\n    }\r\n    final byte[] name = new byte[16];\r\n    final byte[] lastmodified = new byte[12];\r\n    final byte[] userid = new byte[6];\r\n    final byte[] groupid = new byte[6];\r\n    final byte[] filemode = new byte[8];\r\n    final byte[] length = new byte[10];\r\n    read(name);\r\n    read(lastmodified);\r\n    read(userid);\r\n    read(groupid);\r\n    read(filemode);\r\n    read(length);\r\n    {\r\n        final byte[] expected = ArArchiveEntry.TRAILER.getBytes();\r\n        final byte[] realized = new byte[expected.length];\r\n        final int read = read(realized);\r\n        if (read != expected.length) {\r\n            throw new IOException(\"failed to read entry header\");\r\n        }\r\n        for (int i = 0; i < expected.length; i++) {\r\n            if (expected[i] != realized[i]) {\r\n                throw new IOException(\"invalid entry header. not read the content?\");\r\n            }\r\n        }\r\n    }\r\n    return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim()));\r\n}","code_comment":"\/**\r\n * Returns the next AR entry in this stream.\r\n *\r\n * @return the next AR entry.\r\n * @throws IOException\r\n *             if the entry could not be read\r\n *\/\r\n","code_no_comment":"public ArArchiveEntry getNextArEntry() throws IOException {\r\n    if (offset == 0) {\r\n        final byte[] expected = ArArchiveEntry.HEADER.getBytes();\r\n        final byte[] realized = new byte[expected.length];\r\n        final int read = read(realized);\r\n        if (read != expected.length) {\r\n            throw new IOException(\"failed to read header\");\r\n        }\r\n        for (int i = 0; i < expected.length; i++) {\r\n            if (expected[i] != realized[i]) {\r\n                throw new IOException(\"invalid header \" + new String(realized));\r\n            }\r\n        }\r\n    }\r\n    if (input.available() == 0) {\r\n        return null;\r\n    }\r\n    if (offset % 2 != 0) {\r\n        read();\r\n    }\r\n    final byte[] name = new byte[16];\r\n    final byte[] lastmodified = new byte[12];\r\n    final byte[] userid = new byte[6];\r\n    final byte[] groupid = new byte[6];\r\n    final byte[] filemode = new byte[8];\r\n    final byte[] length = new byte[10];\r\n    read(name);\r\n    read(lastmodified);\r\n    read(userid);\r\n    read(groupid);\r\n    read(filemode);\r\n    read(length);\r\n    {\r\n        final byte[] expected = ArArchiveEntry.TRAILER.getBytes();\r\n        final byte[] realized = new byte[expected.length];\r\n        final int read = read(realized);\r\n        if (read != expected.length) {\r\n            throw new IOException(\"failed to read entry header\");\r\n        }\r\n        for (int i = 0; i < expected.length; i++) {\r\n            if (expected[i] != realized[i]) {\r\n                throw new IOException(\"invalid entry header. not read the content?\");\r\n            }\r\n        }\r\n    }\r\n    return new ArArchiveEntry(new String(name).trim(), Long.parseLong(new String(length).trim()));\r\n}","lc":1.5,"pi":0.2966507177,"ma":2.0,"nbd":0.5,"ml":0.75,"d":1.3373015873,"mi":-0.8328400282,"fo":0.75,"r":-0.0263157895,"e":2.6286797716}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5357_4cf7e80e","label":1,"code":"public static String encode(String s) {\r\n    int n = s == null ? 0 : s.length();\r\n    if (n == 0) {\r\n        return s;\r\n    }\r\n    \/\/ First check whether we actually need to encode\r\n    char[] chars = s.toCharArray();\r\n    for (int i = 0; ; ) {\r\n        \/\/ just deal with the ascii character\r\n        if (chars[i] > 0 && chars[i] < 128) {\r\n            if (unsafeCharacters.get(chars[i])) {\r\n                break;\r\n            }\r\n        }\r\n        if (++i >= chars.length) {\r\n            return s;\r\n        }\r\n    }\r\n    \/\/ okay there are some unsafe characters so we do need to encode\r\n    StringBuilder sb = new StringBuilder();\r\n    for (char ch : chars) {\r\n        if (ch > 0 && ch < 128 && unsafeCharacters.get(ch)) {\r\n            appendEscape(sb, (byte) ch);\r\n        } else {\r\n            sb.append(ch);\r\n        }\r\n    }\r\n    return sb.toString();\r\n}","code_comment":null,"code_no_comment":"public static String encode(String s) {\r\n    int n = s == null ? 0 : s.length();\r\n    if (n == 0) {\r\n        return s;\r\n    }\r\n        char[] chars = s.toCharArray();\r\n    for (int i = 0; ; ) {\r\n                if (chars[i] > 0 && chars[i] < 128) {\r\n            if (unsafeCharacters.get(chars[i])) {\r\n                break;\r\n            }\r\n        }\r\n        if (++i >= chars.length) {\r\n            return s;\r\n        }\r\n    }\r\n        StringBuilder sb = new StringBuilder();\r\n    for (char ch : chars) {\r\n        if (ch > 0 && ch < 128 && unsafeCharacters.get(ch)) {\r\n            appendEscape(sb, (byte) ch);\r\n        } else {\r\n            sb.append(ch);\r\n        }\r\n    }\r\n    return sb.toString();\r\n}","lc":0.5454545455,"pi":0.4497607656,"ma":1.2,"nbd":0.5,"ml":0.9166666667,"d":1.2123015873,"mi":-0.4221282593,"fo":0.0833333333,"r":0.1315789474,"e":1.0222898405}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7973_799b45df","label":3,"code":"public boolean process(final Exchange exchange, final AsyncCallback callback) {\r\n    \/\/ can we still run\r\n    if (!isRunAllowed()) {\r\n        log.trace(\"Run not allowed, will reject executing exchange: {}\", exchange);\r\n        if (exchange.getException() == null) {\r\n            exchange.setException(new RejectedExecutionException(\"Run is not allowed\"));\r\n        }\r\n        callback.done(true);\r\n        return true;\r\n    }\r\n    if (failures.get() >= threshold && System.currentTimeMillis() - lastFailure < halfOpenAfter) {\r\n        exchange.setException(new RejectedExecutionException(\"CircuitBreaker Open: failures: \" + failures + \", lastFailure: \" + lastFailure));\r\n    }\r\n    Processor processor = getProcessors().get(0);\r\n    if (processor == null) {\r\n        throw new IllegalStateException(\"No processors could be chosen to process CircuitBreaker\");\r\n    }\r\n    AsyncProcessor albp = AsyncProcessorConverterHelper.convert(processor);\r\n    boolean sync = albp.process(exchange, callback);\r\n    boolean failed = hasFailed(exchange);\r\n    if (!failed) {\r\n        failures.set(0);\r\n    } else {\r\n        failures.incrementAndGet();\r\n        lastFailure = System.currentTimeMillis();\r\n    }\r\n    if (!sync) {\r\n        log.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\r\n        return false;\r\n    }\r\n    log.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\r\n    callback.done(true);\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"public boolean process(final Exchange exchange, final AsyncCallback callback) {\r\n        if (!isRunAllowed()) {\r\n        log.trace(\"Run not allowed, will reject executing exchange: {}\", exchange);\r\n        if (exchange.getException() == null) {\r\n            exchange.setException(new RejectedExecutionException(\"Run is not allowed\"));\r\n        }\r\n        callback.done(true);\r\n        return true;\r\n    }\r\n    if (failures.get() >= threshold && System.currentTimeMillis() - lastFailure < halfOpenAfter) {\r\n        exchange.setException(new RejectedExecutionException(\"CircuitBreaker Open: failures: \" + failures + \", lastFailure: \" + lastFailure));\r\n    }\r\n    Processor processor = getProcessors().get(0);\r\n    if (processor == null) {\r\n        throw new IllegalStateException(\"No processors could be chosen to process CircuitBreaker\");\r\n    }\r\n    AsyncProcessor albp = AsyncProcessorConverterHelper.convert(processor);\r\n    boolean sync = albp.process(exchange, callback);\r\n    boolean failed = hasFailed(exchange);\r\n    if (!failed) {\r\n        failures.set(0);\r\n    } else {\r\n        failures.incrementAndGet();\r\n        lastFailure = System.currentTimeMillis();\r\n    }\r\n    if (!sync) {\r\n        log.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\r\n        return false;\r\n    }\r\n    log.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\r\n    callback.done(true);\r\n    return true;\r\n}","lc":0.8636363636,"pi":-0.2009569378,"ma":0.8,"nbd":0.0,"ml":1.0,"d":1.0992063492,"mi":-0.5988724454,"fo":1.25,"r":-0.0263157895,"e":1.7465373466}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1770_192ee9e4","label":0,"code":"\/**\r\n * Returns update operations to split this document. The implementation may\r\n * decide to not return any operations if no splitting is required.\r\n *\r\n * @param context the revision context.\r\n * @return the split operations.\r\n *\/\r\n@Nonnull\r\npublic Iterable<UpdateOp> split(@Nonnull RevisionContext context) {\r\n    SortedMap<Revision, Range> previous = getPreviousRanges();\r\n    \/\/ unless document is really big\r\n    if (getLocalRevisions().size() + getLocalCommitRoot().size() <= NUM_REVS_THRESHOLD && getMemory() < DOC_SIZE_THRESHOLD && previous.size() < PREV_SPLIT_FACTOR) {\r\n        return Collections.emptyList();\r\n    }\r\n    String path = getPath();\r\n    String id = getId();\r\n    if (id == null) {\r\n        throw new IllegalStateException(\"document does not have an id: \" + this);\r\n    }\r\n    \/\/ collect ranges and create a histogram of the height\r\n    Map<Integer, List<Range>> prevHisto = Maps.newHashMap();\r\n    for (Map.Entry<Revision, Range> entry : previous.entrySet()) {\r\n        Revision rev = entry.getKey();\r\n        if (rev.getClusterId() != context.getClusterId()) {\r\n            continue;\r\n        }\r\n        Range r = entry.getValue();\r\n        List<Range> list = prevHisto.get(r.getHeight());\r\n        if (list == null) {\r\n            list = new ArrayList<Range>();\r\n            prevHisto.put(r.getHeight(), list);\r\n        }\r\n        list.add(r);\r\n    }\r\n    Map<String, NavigableMap<Revision, String>> splitValues = new HashMap<String, NavigableMap<Revision, String>>();\r\n    for (String property : data.keySet()) {\r\n        if (IGNORE_ON_SPLIT.contains(property)) {\r\n            continue;\r\n        }\r\n        NavigableMap<Revision, String> splitMap = new TreeMap<Revision, String>(context.getRevisionComparator());\r\n        splitValues.put(property, splitMap);\r\n        Map<Revision, String> valueMap = getLocalMap(property);\r\n        \/\/ most recent previous split revision\r\n        for (Map.Entry<Revision, String> entry : valueMap.entrySet()) {\r\n            Revision rev = entry.getKey();\r\n            if (rev.getClusterId() != context.getClusterId()) {\r\n                continue;\r\n            }\r\n            if (isCommitted(rev)) {\r\n                splitMap.put(rev, entry.getValue());\r\n            }\r\n        }\r\n    }\r\n    List<UpdateOp> splitOps = Lists.newArrayList();\r\n    int numValues = 0;\r\n    Revision high = null;\r\n    Revision low = null;\r\n    for (NavigableMap<Revision, String> splitMap : splitValues.values()) {\r\n        \/\/ keep the most recent in the main document\r\n        if (!splitMap.isEmpty()) {\r\n            splitMap.remove(splitMap.lastKey());\r\n        }\r\n        if (splitMap.isEmpty()) {\r\n            continue;\r\n        }\r\n        \/\/ remember highest \/ lowest revision\r\n        if (high == null || isRevisionNewer(context, splitMap.lastKey(), high)) {\r\n            high = splitMap.lastKey();\r\n        }\r\n        if (low == null || isRevisionNewer(context, low, splitMap.firstKey())) {\r\n            low = splitMap.firstKey();\r\n        }\r\n        numValues += splitMap.size();\r\n    }\r\n    UpdateOp main = null;\r\n    if (high != null && low != null && (numValues >= NUM_REVS_THRESHOLD || getMemory() > DOC_SIZE_THRESHOLD)) {\r\n        \/\/ enough revisions to split off\r\n        \/\/ move to another document\r\n        main = new UpdateOp(id, false);\r\n        setPrevious(main, new Range(high, low, 0));\r\n        String oldPath = Utils.getPreviousPathFor(path, high, 0);\r\n        UpdateOp old = new UpdateOp(Utils.getIdFromPath(oldPath), true);\r\n        old.set(ID, old.getId());\r\n        if (Utils.isLongPath(oldPath)) {\r\n            old.set(PATH, oldPath);\r\n        }\r\n        for (String property : splitValues.keySet()) {\r\n            NavigableMap<Revision, String> splitMap = splitValues.get(property);\r\n            for (Map.Entry<Revision, String> entry : splitMap.entrySet()) {\r\n                Revision r = entry.getKey();\r\n                main.removeMapEntry(property, r);\r\n                old.setMapEntry(property, r, entry.getValue());\r\n            }\r\n        }\r\n        \/\/ check size of old document\r\n        NodeDocument oldDoc = new NodeDocument(store);\r\n        UpdateUtils.applyChanges(oldDoc, old, context.getRevisionComparator());\r\n        setSplitDocProps(this, oldDoc, old, high);\r\n        \/\/ only split if enough of the data can be moved to old document\r\n        if (oldDoc.getMemory() > getMemory() * SPLIT_RATIO) {\r\n            splitOps.add(old);\r\n        } else {\r\n            main = null;\r\n        }\r\n    }\r\n    \/\/ check if we need to create intermediate previous documents\r\n    for (Map.Entry<Integer, List<Range>> entry : prevHisto.entrySet()) {\r\n        if (entry.getValue().size() >= PREV_SPLIT_FACTOR) {\r\n            if (main == null) {\r\n                main = new UpdateOp(id, false);\r\n            }\r\n            \/\/ calculate range new range\r\n            Revision h = null;\r\n            Revision l = null;\r\n            for (Range r : entry.getValue()) {\r\n                if (h == null || isRevisionNewer(context, r.high, h)) {\r\n                    h = r.high;\r\n                }\r\n                if (l == null || isRevisionNewer(context, l, r.low)) {\r\n                    l = r.low;\r\n                }\r\n                removePrevious(main, r);\r\n            }\r\n            if (h == null || l == null) {\r\n                throw new IllegalStateException();\r\n            }\r\n            String prevPath = Utils.getPreviousPathFor(path, h, entry.getKey() + 1);\r\n            String prevId = Utils.getIdFromPath(prevPath);\r\n            UpdateOp intermediate = new UpdateOp(prevId, true);\r\n            intermediate.set(ID, prevId);\r\n            if (Utils.isLongPath(prevPath)) {\r\n                intermediate.set(PATH, prevPath);\r\n            }\r\n            setPrevious(main, new Range(h, l, entry.getKey() + 1));\r\n            for (Range r : entry.getValue()) {\r\n                setPrevious(intermediate, r);\r\n            }\r\n            setIntermediateDocProps(intermediate, h);\r\n            splitOps.add(intermediate);\r\n        }\r\n    }\r\n    \/\/ main document must be updated last\r\n    if (main != null && !splitOps.isEmpty()) {\r\n        splitOps.add(main);\r\n    }\r\n    return splitOps;\r\n}","code_comment":"\/**\r\n * Returns update operations to split this document. The implementation may\r\n * decide to not return any operations if no splitting is required.\r\n *\r\n * @param context the revision context.\r\n * @return the split operations.\r\n *\/\r\n","code_no_comment":"@Nonnull\r\npublic Iterable<UpdateOp> split(@Nonnull RevisionContext context) {\r\n    SortedMap<Revision, Range> previous = getPreviousRanges();\r\n        if (getLocalRevisions().size() + getLocalCommitRoot().size() <= NUM_REVS_THRESHOLD && getMemory() < DOC_SIZE_THRESHOLD && previous.size() < PREV_SPLIT_FACTOR) {\r\n        return Collections.emptyList();\r\n    }\r\n    String path = getPath();\r\n    String id = getId();\r\n    if (id == null) {\r\n        throw new IllegalStateException(\"document does not have an id: \" + this);\r\n    }\r\n        Map<Integer, List<Range>> prevHisto = Maps.newHashMap();\r\n    for (Map.Entry<Revision, Range> entry : previous.entrySet()) {\r\n        Revision rev = entry.getKey();\r\n        if (rev.getClusterId() != context.getClusterId()) {\r\n            continue;\r\n        }\r\n        Range r = entry.getValue();\r\n        List<Range> list = prevHisto.get(r.getHeight());\r\n        if (list == null) {\r\n            list = new ArrayList<Range>();\r\n            prevHisto.put(r.getHeight(), list);\r\n        }\r\n        list.add(r);\r\n    }\r\n    Map<String, NavigableMap<Revision, String>> splitValues = new HashMap<String, NavigableMap<Revision, String>>();\r\n    for (String property : data.keySet()) {\r\n        if (IGNORE_ON_SPLIT.contains(property)) {\r\n            continue;\r\n        }\r\n        NavigableMap<Revision, String> splitMap = new TreeMap<Revision, String>(context.getRevisionComparator());\r\n        splitValues.put(property, splitMap);\r\n        Map<Revision, String> valueMap = getLocalMap(property);\r\n                for (Map.Entry<Revision, String> entry : valueMap.entrySet()) {\r\n            Revision rev = entry.getKey();\r\n            if (rev.getClusterId() != context.getClusterId()) {\r\n                continue;\r\n            }\r\n            if (isCommitted(rev)) {\r\n                splitMap.put(rev, entry.getValue());\r\n            }\r\n        }\r\n    }\r\n    List<UpdateOp> splitOps = Lists.newArrayList();\r\n    int numValues = 0;\r\n    Revision high = null;\r\n    Revision low = null;\r\n    for (NavigableMap<Revision, String> splitMap : splitValues.values()) {\r\n                if (!splitMap.isEmpty()) {\r\n            splitMap.remove(splitMap.lastKey());\r\n        }\r\n        if (splitMap.isEmpty()) {\r\n            continue;\r\n        }\r\n                if (high == null || isRevisionNewer(context, splitMap.lastKey(), high)) {\r\n            high = splitMap.lastKey();\r\n        }\r\n        if (low == null || isRevisionNewer(context, low, splitMap.firstKey())) {\r\n            low = splitMap.firstKey();\r\n        }\r\n        numValues += splitMap.size();\r\n    }\r\n    UpdateOp main = null;\r\n    if (high != null && low != null && (numValues >= NUM_REVS_THRESHOLD || getMemory() > DOC_SIZE_THRESHOLD)) {\r\n                        main = new UpdateOp(id, false);\r\n        setPrevious(main, new Range(high, low, 0));\r\n        String oldPath = Utils.getPreviousPathFor(path, high, 0);\r\n        UpdateOp old = new UpdateOp(Utils.getIdFromPath(oldPath), true);\r\n        old.set(ID, old.getId());\r\n        if (Utils.isLongPath(oldPath)) {\r\n            old.set(PATH, oldPath);\r\n        }\r\n        for (String property : splitValues.keySet()) {\r\n            NavigableMap<Revision, String> splitMap = splitValues.get(property);\r\n            for (Map.Entry<Revision, String> entry : splitMap.entrySet()) {\r\n                Revision r = entry.getKey();\r\n                main.removeMapEntry(property, r);\r\n                old.setMapEntry(property, r, entry.getValue());\r\n            }\r\n        }\r\n                NodeDocument oldDoc = new NodeDocument(store);\r\n        UpdateUtils.applyChanges(oldDoc, old, context.getRevisionComparator());\r\n        setSplitDocProps(this, oldDoc, old, high);\r\n                if (oldDoc.getMemory() > getMemory() * SPLIT_RATIO) {\r\n            splitOps.add(old);\r\n        } else {\r\n            main = null;\r\n        }\r\n    }\r\n        for (Map.Entry<Integer, List<Range>> entry : prevHisto.entrySet()) {\r\n        if (entry.getValue().size() >= PREV_SPLIT_FACTOR) {\r\n            if (main == null) {\r\n                main = new UpdateOp(id, false);\r\n            }\r\n                        Revision h = null;\r\n            Revision l = null;\r\n            for (Range r : entry.getValue()) {\r\n                if (h == null || isRevisionNewer(context, r.high, h)) {\r\n                    h = r.high;\r\n                }\r\n                if (l == null || isRevisionNewer(context, l, r.low)) {\r\n                    l = r.low;\r\n                }\r\n                removePrevious(main, r);\r\n            }\r\n            if (h == null || l == null) {\r\n                throw new IllegalStateException();\r\n            }\r\n            String prevPath = Utils.getPreviousPathFor(path, h, entry.getKey() + 1);\r\n            String prevId = Utils.getIdFromPath(prevPath);\r\n            UpdateOp intermediate = new UpdateOp(prevId, true);\r\n            intermediate.set(ID, prevId);\r\n            if (Utils.isLongPath(prevPath)) {\r\n                intermediate.set(PATH, prevPath);\r\n            }\r\n            setPrevious(main, new Range(h, l, entry.getKey() + 1));\r\n            for (Range r : entry.getValue()) {\r\n                setPrevious(intermediate, r);\r\n            }\r\n            setIntermediateDocProps(intermediate, h);\r\n            splitOps.add(intermediate);\r\n        }\r\n    }\r\n        if (main != null && !splitOps.isEmpty()) {\r\n        splitOps.add(main);\r\n    }\r\n    return splitOps;\r\n}","lc":5.1818181818,"pi":0.5645933014,"ma":6.6,"nbd":1.0,"ml":5.1666666667,"d":4.2063492063,"mi":-1.666384778,"fo":6.8333333333,"r":-0.0263157895,"e":35.0613647759}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-43_668f08f2","label":1,"code":"public void setProperties(String nodePath, Map<String, String> properties) throws Exception {\r\n    MutableNode node = getOrCreateStagedNode(nodePath);\r\n    node.getProperties().clear();\r\n    node.getProperties().putAll(properties);\r\n    \/\/ update change log\r\n    changeLog.add(new SetProperties(nodePath, properties));\r\n}","code_comment":null,"code_no_comment":"public void setProperties(String nodePath, Map<String, String> properties) throws Exception {\r\n    MutableNode node = getOrCreateStagedNode(nodePath);\r\n    node.getProperties().clear();\r\n    node.getProperties().putAll(properties);\r\n        changeLog.add(new SetProperties(nodePath, properties));\r\n}","lc":-0.3636363636,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.4689217759,"fo":0.0,"r":0.1052631579,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3563_c62b66c1","label":1,"code":"private String getAjaxRegionMarkupId(Component component) {\r\n    String markupId = null;\r\n    for (Behavior behavior : component.getBehaviors()) {\r\n        if (behavior instanceof IAjaxRegionMarkupIdProvider) {\r\n            markupId = ((IAjaxRegionMarkupIdProvider) behavior).getAjaxRegionMarkupId(component);\r\n        }\r\n    }\r\n    if (markupId == null) {\r\n        if (component instanceof IAjaxRegionMarkupIdProvider) {\r\n            markupId = ((IAjaxRegionMarkupIdProvider) component).getAjaxRegionMarkupId(component);\r\n        }\r\n    }\r\n    if (markupId == null) {\r\n        markupId = component.getMarkupId();\r\n    }\r\n    return markupId;\r\n}","code_comment":null,"code_no_comment":"private String getAjaxRegionMarkupId(Component component) {\r\n    String markupId = null;\r\n    for (Behavior behavior : component.getBehaviors()) {\r\n        if (behavior instanceof IAjaxRegionMarkupIdProvider) {\r\n            markupId = ((IAjaxRegionMarkupIdProvider) behavior).getAjaxRegionMarkupId(component);\r\n        }\r\n    }\r\n    if (markupId == null) {\r\n        if (component instanceof IAjaxRegionMarkupIdProvider) {\r\n            markupId = ((IAjaxRegionMarkupIdProvider) component).getAjaxRegionMarkupId(component);\r\n        }\r\n    }\r\n    if (markupId == null) {\r\n        markupId = component.getMarkupId();\r\n    }\r\n    return markupId;\r\n}","lc":0.1363636364,"pi":0.1866028708,"ma":0.4,"nbd":0.0,"ml":0.1666666667,"d":0.1964285714,"mi":-0.0917547569,"fo":-0.1666666667,"r":0.1052631579,"e":0.0361427592}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-779_ebadb558","label":1,"code":"\/**\r\n * Chromosome list iterator\r\n *\r\n * @return chromosome iterator\r\n *\/\r\npublic Iterator<Chromosome> iterator() {\r\n    return chromosomes.iterator();\r\n}","code_comment":"\/**\r\n * Chromosome list iterator\r\n *\r\n * @return chromosome iterator\r\n *\/\r\n","code_no_comment":"public Iterator<Chromosome> iterator() {\r\n    return chromosomes.iterator();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.0831571529,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5698_f45ce896","label":1,"code":"@Override\r\npublic void unmount(String path) {\r\n    final Url url = Url.parse(path);\r\n    final Request request = createRequest(url);\r\n    for (IRequestMapper mapper : this) {\r\n        if (mapper.mapRequest(request) != null) {\r\n            remove(mapper);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void unmount(String path) {\r\n    final Url url = Url.parse(path);\r\n    final Request request = createRequest(url);\r\n    for (IRequestMapper mapper : this) {\r\n        if (mapper.mapRequest(request) != null) {\r\n            remove(mapper);\r\n        }\r\n    }\r\n}","lc":-0.1818181818,"pi":0.3732057416,"ma":-0.2,"nbd":0.0,"ml":-0.1666666667,"d":-0.0912698413,"mi":0.2253699789,"fo":-0.1666666667,"r":1.2105263158,"e":-0.0967087936}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3077_17654199","label":0,"code":"\/**\r\n * Write replication ingest entries for each provided file with the given {@link Status}.\r\n *\/\r\npublic static void updateFiles(Credentials creds, KeyExtent extent, Collection<String> files, Status stat) {\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Updating replication for \" + extent + \" with \" + files + \" using \" + ProtobufUtil.toString(stat));\r\n    }\r\n    \/\/ TODO could use batch writer, would need to handle failure and retry like update does - ACCUMULO-1294\r\n    if (files.isEmpty()) {\r\n        return;\r\n    }\r\n    Value v = ProtobufUtil.toValue(stat);\r\n    for (String file : files) {\r\n        \/\/ TODO Can preclude this addition if the extent is for a table we don't need to replicate\r\n        update(creds, createUpdateMutation(new Path(file), v, extent), extent);\r\n    }\r\n}","code_comment":"\/**\r\n * Write replication ingest entries for each provided file with the given {@link Status}.\r\n *\/\r\n","code_no_comment":"public static void updateFiles(Credentials creds, KeyExtent extent, Collection<String> files, Status stat) {\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Updating replication for \" + extent + \" with \" + files + \" using \" + ProtobufUtil.toString(stat));\r\n    }\r\n        if (files.isEmpty()) {\r\n        return;\r\n    }\r\n    Value v = ProtobufUtil.toValue(stat);\r\n    for (String file : files) {\r\n                update(creds, createUpdateMutation(new Path(file), v, extent), extent);\r\n    }\r\n}","lc":-0.0909090909,"pi":-0.2057416268,"ma":0.0,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0634920635,"mi":0.0339675828,"fo":0.0833333333,"r":0.0,"e":-0.0165488149}
{"project_name":"Lang","project_version":"21","label":1,"code":"\/\/ -----------------------------------------------------------------------\r\n\/**\r\n * <p>Checks if two calendar objects represent the same local time.<\/p>\r\n *\r\n * <p>This method compares the values of the fields of the two objects.\r\n * In addition, both calendars must be the same of the same type.<\/p>\r\n *\r\n * @param cal1  the first calendar, not altered, not null\r\n * @param cal2  the second calendar, not altered, not null\r\n * @return true if they represent the same millisecond instant\r\n * @throws IllegalArgumentException if either date is <code>null<\/code>\r\n * @since 2.1\r\n *\/\r\npublic static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\r\n    if (cal1 == null || cal2 == null) {\r\n        throw new IllegalArgumentException(\"The date must not be null\");\r\n    }\r\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass());\r\n}","code_comment":"\/**\r\n * <p>Checks if two calendar objects represent the same local time.<\/p>\r\n *\r\n * <p>This method compares the values of the fields of the two objects.\r\n * In addition, both calendars must be the same of the same type.<\/p>\r\n *\r\n * @param cal1  the first calendar, not altered, not null\r\n * @param cal2  the second calendar, not altered, not null\r\n * @return true if they represent the same millisecond instant\r\n * @throws IllegalArgumentException if either date is <code>null<\/code>\r\n * @since 2.1\r\n *\/\r\n","code_no_comment":"public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\r\n    if (cal1 == null || cal2 == null) {\r\n        throw new IllegalArgumentException(\"The date must not be null\");\r\n    }\r\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass());\r\n}","lc":-0.3636363636,"pi":-0.1148325359,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":0.4761904762,"mi":0.2656800564,"fo":0.8333333333,"r":-0.0263157895,"e":0.596723201}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-644_55a4f738","label":3,"code":"@Nonnull\r\n@Override\r\npublic CommitHookProvider getSecurityHooks() {\r\n    return new CommitHookProvider() {\r\n\r\n        @Override\r\n        public CommitHook getCommitHook(String workspaceName) {\r\n            return new CompositeHook(new PermissionHook(workspaceName), new VersionablePathHook(workspaceName));\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\n@Override\r\npublic CommitHookProvider getSecurityHooks() {\r\n    return new CommitHookProvider() {\r\n\r\n        @Override\r\n        public CommitHook getCommitHook(String workspaceName) {\r\n            return new CompositeHook(new PermissionHook(workspaceName), new VersionablePathHook(workspaceName));\r\n        }\r\n    };\r\n}","lc":-0.1818181818,"pi":0.5693779904,"ma":-0.6,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.3260042283,"fo":-0.5,"r":0.6578947368,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1289_0c3e3d70","label":1,"code":"\/**\r\n * Returns <code>true<\/code> if the given revision is within this range.\r\n *\r\n * @param r the revision to check.\r\n * @return <code>true<\/code> if within this range; <code>false<\/code>\r\n * otherwise.\r\n *\/\r\nboolean includes(Revision r) {\r\n    return high.compareRevisionTime(r) >= 0 && low.compareRevisionTime(r) <= 0;\r\n}","code_comment":"\/**\r\n * Returns <code>true<\/code> if the given revision is within this range.\r\n *\r\n * @param r the revision to check.\r\n * @return <code>true<\/code> if within this range; <code>false<\/code>\r\n * otherwise.\r\n *\/\r\n","code_no_comment":"boolean includes(Revision r) {\r\n    return high.compareRevisionTime(r) >= 0 && low.compareRevisionTime(r) <= 0;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.0674603175,"mi":0.8906272023,"fo":-0.3333333333,"r":2.1052631579,"e":-0.1269065196}
{"project_name":"Closure","project_version":"124","label":2,"code":"\/**\r\n * Checks name referenced in node to determine if it might have\r\n * changed.\r\n * @return Whether the replacement can be made.\r\n *\/\r\nprivate boolean isSafeReplacement(Node node, Node replacement) {\r\n    \/\/ No checks are needed for simple names.\r\n    if (node.isName()) {\r\n        return true;\r\n    }\r\n    Preconditions.checkArgument(node.isGetProp());\r\n    node = node.getFirstChild();\r\n    if (node.isName() && isNameAssignedTo(node.getString(), replacement)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}","code_comment":"\/**\r\n * Checks name referenced in node to determine if it might have\r\n * changed.\r\n * @return Whether the replacement can be made.\r\n *\/\r\n","code_no_comment":"private boolean isSafeReplacement(Node node, Node replacement) {\r\n        if (node.isName()) {\r\n        return true;\r\n    }\r\n    Preconditions.checkArgument(node.isGetProp());\r\n    node = node.getFirstChild();\r\n    if (node.isName() && isNameAssignedTo(node.getString(), replacement)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}","lc":-0.1363636364,"pi":-0.2775119617,"ma":-0.2,"nbd":-0.5,"ml":0.1666666667,"d":-0.0257936508,"mi":0.1822410148,"fo":0.0833333333,"r":0.0263157895,"e":-0.0805956559}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2359_b3071839","label":0,"code":"@Nonnull\r\nstatic Map<Revision, String> create(@Nonnull final NodeDocument doc, @Nonnull final String property) {\r\n    final SortedMap<Revision, String> map = doc.getLocalMap(property);\r\n    if (doc.getPreviousRanges().isEmpty()) {\r\n        return map;\r\n    }\r\n    final Set<Map.Entry<Revision, String>> entrySet = new AbstractSet<Map.Entry<Revision, String>>() {\r\n\r\n        @Override\r\n        @Nonnull\r\n        public Iterator<Map.Entry<Revision, String>> iterator() {\r\n            final Comparator<? super Revision> c = map.comparator();\r\n            final Iterator<NodeDocument> docs;\r\n            if (map.isEmpty()) {\r\n                docs = doc.getPreviousDocs(property, null).iterator();\r\n            } else {\r\n                docs = Iterators.concat(Iterators.singletonIterator(doc), doc.getPreviousDocs(property, null).iterator());\r\n            }\r\n            return new MergeSortedIterators<Map.Entry<Revision, String>>(new Comparator<Map.Entry<Revision, String>>() {\r\n\r\n                @Override\r\n                public int compare(Map.Entry<Revision, String> o1, Map.Entry<Revision, String> o2) {\r\n                    return c.compare(o1.getKey(), o2.getKey());\r\n                }\r\n            }) {\r\n\r\n                @Override\r\n                public Iterator<Map.Entry<Revision, String>> nextIterator() {\r\n                    NodeDocument d = docs.hasNext() ? docs.next() : null;\r\n                    if (d == null) {\r\n                        return null;\r\n                    }\r\n                    Map<Revision, String> values;\r\n                    if (Objects.equal(d.getId(), doc.getId())) {\r\n                        \/\/ return local map for main document\r\n                        values = d.getLocalMap(property);\r\n                    } else {\r\n                        values = d.getValueMap(property);\r\n                    }\r\n                    return values.entrySet().iterator();\r\n                }\r\n\r\n                @Override\r\n                public String description() {\r\n                    return \"Revisioned values for property \" + doc.getId() + \"\/\" + property + \":\";\r\n                }\r\n            };\r\n        }\r\n\r\n        @Override\r\n        public int size() {\r\n            int size = map.size();\r\n            for (NodeDocument prev : doc.getPreviousDocs(property, null)) {\r\n                size += prev.getValueMap(property).size();\r\n            }\r\n            return size;\r\n        }\r\n    };\r\n    return new AbstractMap<Revision, String>() {\r\n\r\n        private final Map<Revision, String> map = doc.getLocalMap(property);\r\n\r\n        @Override\r\n        @Nonnull\r\n        public Set<Entry<Revision, String>> entrySet() {\r\n            return entrySet;\r\n        }\r\n\r\n        @Override\r\n        public String get(Object key) {\r\n            \/\/ first check values map of this document\r\n            String value = map.get(key);\r\n            if (value != null) {\r\n                return value;\r\n            }\r\n            Revision r = (Revision) key;\r\n            for (NodeDocument prev : doc.getPreviousDocs(property, r)) {\r\n                value = prev.getValueMap(property).get(key);\r\n                if (value != null) {\r\n                    return value;\r\n                }\r\n            }\r\n            \/\/ not found\r\n            return null;\r\n        }\r\n\r\n        @Override\r\n        public boolean containsKey(Object key) {\r\n            \/\/ the values map does not have null values\r\n            return get(key) != null;\r\n        }\r\n    };\r\n}","code_comment":null,"code_no_comment":"@Nonnull\r\nstatic Map<Revision, String> create(@Nonnull final NodeDocument doc, @Nonnull final String property) {\r\n    final SortedMap<Revision, String> map = doc.getLocalMap(property);\r\n    if (doc.getPreviousRanges().isEmpty()) {\r\n        return map;\r\n    }\r\n    final Set<Map.Entry<Revision, String>> entrySet = new AbstractSet<Map.Entry<Revision, String>>() {\r\n\r\n        @Override\r\n        @Nonnull\r\n        public Iterator<Map.Entry<Revision, String>> iterator() {\r\n            final Comparator<? super Revision> c = map.comparator();\r\n            final Iterator<NodeDocument> docs;\r\n            if (map.isEmpty()) {\r\n                docs = doc.getPreviousDocs(property, null).iterator();\r\n            } else {\r\n                docs = Iterators.concat(Iterators.singletonIterator(doc), doc.getPreviousDocs(property, null).iterator());\r\n            }\r\n            return new MergeSortedIterators<Map.Entry<Revision, String>>(new Comparator<Map.Entry<Revision, String>>() {\r\n\r\n                @Override\r\n                public int compare(Map.Entry<Revision, String> o1, Map.Entry<Revision, String> o2) {\r\n                    return c.compare(o1.getKey(), o2.getKey());\r\n                }\r\n            }) {\r\n\r\n                @Override\r\n                public Iterator<Map.Entry<Revision, String>> nextIterator() {\r\n                    NodeDocument d = docs.hasNext() ? docs.next() : null;\r\n                    if (d == null) {\r\n                        return null;\r\n                    }\r\n                    Map<Revision, String> values;\r\n                    if (Objects.equal(d.getId(), doc.getId())) {\r\n                                                values = d.getLocalMap(property);\r\n                    } else {\r\n                        values = d.getValueMap(property);\r\n                    }\r\n                    return values.entrySet().iterator();\r\n                }\r\n\r\n                @Override\r\n                public String description() {\r\n                    return \"Revisioned values for property \" + doc.getId() + \"\/\" + property + \":\";\r\n                }\r\n            };\r\n        }\r\n\r\n        @Override\r\n        public int size() {\r\n            int size = map.size();\r\n            for (NodeDocument prev : doc.getPreviousDocs(property, null)) {\r\n                size += prev.getValueMap(property).size();\r\n            }\r\n            return size;\r\n        }\r\n    };\r\n    return new AbstractMap<Revision, String>() {\r\n\r\n        private final Map<Revision, String> map = doc.getLocalMap(property);\r\n\r\n        @Override\r\n        @Nonnull\r\n        public Set<Entry<Revision, String>> entrySet() {\r\n            return entrySet;\r\n        }\r\n\r\n        @Override\r\n        public String get(Object key) {\r\n                        String value = map.get(key);\r\n            if (value != null) {\r\n                return value;\r\n            }\r\n            Revision r = (Revision) key;\r\n            for (NodeDocument prev : doc.getPreviousDocs(property, r)) {\r\n                value = prev.getValueMap(property).get(key);\r\n                if (value != null) {\r\n                    return value;\r\n                }\r\n            }\r\n                        return null;\r\n        }\r\n\r\n        @Override\r\n        public boolean containsKey(Object key) {\r\n                        return get(key) != null;\r\n        }\r\n    };\r\n}","lc":3.0,"pi":1.2822966507,"ma":1.2,"nbd":0.5,"ml":0.8333333333,"d":1.1587301587,"mi":-1.1519379845,"fo":2.3333333333,"r":-0.0263157895,"e":4.857534736}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4309_b4274415","label":1,"code":"\/**\r\n *  Convert to object types, returning null if text is null.\r\n *\r\n *  @return converted\r\n *  @throws StringValueConversionException\r\n *\/\r\npublic final Time toOptionalTime() throws StringValueConversionException {\r\n    return (text == null) ? null : toTime();\r\n}","code_comment":"\/**\r\n *  Convert to object types, returning null if text is null.\r\n *\r\n *  @return converted\r\n *  @throws StringValueConversionException\r\n *\/\r\n","code_no_comment":"public final Time toOptionalTime() throws StringValueConversionException {\r\n    return (text == null) ? null : toTime();\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.3650793651,"mi":0.9797040169,"fo":-0.4166666667,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-4138_50db442b","label":1,"code":"\/**\r\n * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.\r\n *\r\n * @param tableName\r\n *          the table to compact\r\n * @param start\r\n *          first tablet to be compacted contains the row after this row, null means the first tablet in table\r\n * @param end\r\n *          last tablet to be merged contains this row, null means the last tablet in table\r\n * @param iterators\r\n *          A set of iterators that will be applied to each tablet compacted\r\n * @param flush\r\n *          when true, table memory is flushed before compaction starts\r\n * @param wait\r\n *          when true, the call will not return until compactions are finished\r\n * @since 1.5.0\r\n *\/\r\nvoid compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;","code_comment":"\/**\r\n * Starts a full major compaction of the tablets in the range (start, end]. The compaction is preformed even for tablets that have only one file.\r\n *\r\n * @param tableName\r\n *          the table to compact\r\n * @param start\r\n *          first tablet to be compacted contains the row after this row, null means the first tablet in table\r\n * @param end\r\n *          last tablet to be merged contains this row, null means the last tablet in table\r\n * @param iterators\r\n *          A set of iterators that will be applied to each tablet compacted\r\n * @param flush\r\n *          when true, table memory is flushed before compaction starts\r\n * @param wait\r\n *          when true, the call will not return until compactions are finished\r\n * @since 1.5.0\r\n *\/\r\n","code_no_comment":"void compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException, AccumuloException;","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.3650458069,"fo":-0.5,"r":0.3157894737,"e":-0.1627934049}
{"project_name":"Math","project_version":"47","label":3,"code":"\/**\r\n * Returns a {@code Complex} whose value is\r\n * {@code (this \/ divisor)}.\r\n * Implements the definitional formula\r\n * <pre>\r\n *  <code>\r\n *    a + bi          ac + bd + (bc - ad)i\r\n *    ----------- = -------------------------\r\n *    c + di         c<sup>2<\/sup> + d<sup>2<\/sup>\r\n *  <\/code>\r\n * <\/pre>\r\n * but uses\r\n * <a href=\"http:\/\/doi.acm.org\/10.1145\/1039813.1039814\">\r\n * prescaling of operands<\/a> to limit the effects of overflows and\r\n * underflows in the computation.\r\n * <br\/>\r\n * {@code Infinite} and {@code NaN} values are handled according to the\r\n * following rules, applied in the order presented:\r\n * <ul>\r\n *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\r\n *   in either part, {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},\r\n *   {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} and {@code divisor} are both infinite,\r\n *   {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\r\n *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\r\n *   infinite), {@link #ZERO} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} is infinite and {@code divisor} is finite,\r\n *   {@code NaN} values are returned in the parts of the result if the\r\n *   {@link java.lang.Double} rules applied to the definitional formula\r\n *   force {@code NaN} results.\r\n *  <\/li>\r\n * <\/ul>\r\n *\r\n * @param divisor Value by which this {@code Complex} is to be divided.\r\n * @return {@code this \/ divisor}.\r\n * @throws NullArgumentException if {@code divisor} is {@code null}.\r\n *\/\r\npublic Complex divide(Complex divisor) throws NullArgumentException {\r\n    MathUtils.checkNotNull(divisor);\r\n    if (isNaN || divisor.isNaN) {\r\n        return NaN;\r\n    }\r\n    if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {\r\n        return NaN;\r\n    }\r\n    if (divisor.isInfinite() && !isInfinite()) {\r\n        return ZERO;\r\n    }\r\n    final double c = divisor.getReal();\r\n    final double d = divisor.getImaginary();\r\n    if (FastMath.abs(c) < FastMath.abs(d)) {\r\n        double q = c \/ d;\r\n        double denominator = c * q + d;\r\n        return createComplex((real * q + imaginary) \/ denominator, (imaginary * q - real) \/ denominator);\r\n    } else {\r\n        double q = d \/ c;\r\n        double denominator = d * q + c;\r\n        return createComplex((imaginary * q + real) \/ denominator, (imaginary - real * q) \/ denominator);\r\n    }\r\n}","code_comment":"\/**\r\n * Returns a {@code Complex} whose value is\r\n * {@code (this \/ divisor)}.\r\n * Implements the definitional formula\r\n * <pre>\r\n *  <code>\r\n *    a + bi          ac + bd + (bc - ad)i\r\n *    ----------- = -------------------------\r\n *    c + di         c<sup>2<\/sup> + d<sup>2<\/sup>\r\n *  <\/code>\r\n * <\/pre>\r\n * but uses\r\n * <a href=\"http:\/\/doi.acm.org\/10.1145\/1039813.1039814\">\r\n * prescaling of operands<\/a> to limit the effects of overflows and\r\n * underflows in the computation.\r\n * <br\/>\r\n * {@code Infinite} and {@code NaN} values are handled according to the\r\n * following rules, applied in the order presented:\r\n * <ul>\r\n *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\r\n *   in either part, {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},\r\n *   {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} and {@code divisor} are both infinite,\r\n *   {@link #NaN} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\r\n *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\r\n *   infinite), {@link #ZERO} is returned.\r\n *  <\/li>\r\n *  <li>If {@code this} is infinite and {@code divisor} is finite,\r\n *   {@code NaN} values are returned in the parts of the result if the\r\n *   {@link java.lang.Double} rules applied to the definitional formula\r\n *   force {@code NaN} results.\r\n *  <\/li>\r\n * <\/ul>\r\n *\r\n * @param divisor Value by which this {@code Complex} is to be divided.\r\n * @return {@code this \/ divisor}.\r\n * @throws NullArgumentException if {@code divisor} is {@code null}.\r\n *\/\r\n","code_no_comment":"public Complex divide(Complex divisor) throws NullArgumentException {\r\n    MathUtils.checkNotNull(divisor);\r\n    if (isNaN || divisor.isNaN) {\r\n        return NaN;\r\n    }\r\n    if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {\r\n        return NaN;\r\n    }\r\n    if (divisor.isInfinite() && !isInfinite()) {\r\n        return ZERO;\r\n    }\r\n    final double c = divisor.getReal();\r\n    final double d = divisor.getImaginary();\r\n    if (FastMath.abs(c) < FastMath.abs(d)) {\r\n        double q = c \/ d;\r\n        double denominator = c * q + d;\r\n        return createComplex((real * q + imaginary) \/ denominator, (imaginary * q - real) \/ denominator);\r\n    } else {\r\n        double q = d \/ c;\r\n        double denominator = d * q + c;\r\n        return createComplex((imaginary * q + real) \/ denominator, (imaginary - real * q) \/ denominator);\r\n    }\r\n}","lc":0.4090909091,"pi":-0.2440191388,"ma":0.2,"nbd":-0.5,"ml":1.0,"d":2.5674603175,"mi":-0.3973220578,"fo":0.4166666667,"r":-0.0263157895,"e":3.240725437}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1977_4bfbfcdd","label":1,"code":"@Override\r\npublic String getPath() {\r\n    String sub = r.getPath();\r\n    if (PathUtils.isAbsolute(sub)) {\r\n        return path + sub;\r\n    } else {\r\n        return PathUtils.concat(path, r.getPath());\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String getPath() {\r\n    String sub = r.getPath();\r\n    if (PathUtils.isAbsolute(sub)) {\r\n        return path + sub;\r\n    } else {\r\n        return PathUtils.concat(path, r.getPath());\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.019138756,"ma":-0.4,"nbd":-0.5,"ml":-0.1666666667,"d":-0.0079365079,"mi":0.3350246653,"fo":-0.1666666667,"r":0.6842105263,"e":-0.1032923589}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-482_6d6649ef","label":1,"code":"\/**\r\n * Compute the maximum of two values\r\n * @param a first value\r\n * @param b second value\r\n * @return b if a is lesser or equal to b, a otherwise\r\n *\/\r\npublic static float max(final float a, final float b) {\r\n    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\r\n}","code_comment":"\/**\r\n * Compute the maximum of two values\r\n * @param a first value\r\n * @param b second value\r\n * @return b if a is lesser or equal to b, a otherwise\r\n *\/\r\n","code_no_comment":"public static float max(final float a, final float b) {\r\n    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.2,"nbd":-1.0,"ml":0.0,"d":0.0317460317,"mi":0.881042988,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1160261176}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3513_d90672fd","label":0,"code":"\/**\r\n *  Applies the {@link Hasher} to the {@link StreamNode} (only node local\r\n *  attributes are taken into account). The hasher encapsulates the current\r\n *  state of the hash.\r\n *\r\n *  <p>The specified ID is local to this node. We cannot use the\r\n *  {@link StreamNode#id}, because it is incremented in a static counter.\r\n *  Therefore, the IDs for identical jobs will otherwise be different.\r\n *\/\r\nprivate void generateNodeLocalHash(StreamNode node, Hasher hasher, int id) {\r\n    \/\/ This resolves conflicts for otherwise identical source nodes. BUT\r\n    \/\/ the generated hash codes depend on the ordering of the nodes in the\r\n    \/\/ stream graph.\r\n    hasher.putInt(id);\r\n    hasher.putInt(node.getParallelism());\r\n    hasher.putString(node.getOperatorName(), Charset.forName(\"UTF-8\"));\r\n    if (node.getOperator() instanceof AbstractUdfStreamOperator) {\r\n        String udfClassName = ((AbstractUdfStreamOperator<?, ?>) node.getOperator()).getUserFunction().getClass().getName();\r\n        hasher.putString(udfClassName, Charset.forName(\"UTF-8\"));\r\n    }\r\n}","code_comment":"\/**\r\n *  Applies the {@link Hasher} to the {@link StreamNode} (only node local\r\n *  attributes are taken into account). The hasher encapsulates the current\r\n *  state of the hash.\r\n *\r\n *  <p>The specified ID is local to this node. We cannot use the\r\n *  {@link StreamNode#id}, because it is incremented in a static counter.\r\n *  Therefore, the IDs for identical jobs will otherwise be different.\r\n *\/\r\n","code_no_comment":"private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id) {\r\n                hasher.putInt(id);\r\n    hasher.putInt(node.getParallelism());\r\n    hasher.putString(node.getOperatorName(), Charset.forName(\"UTF-8\"));\r\n    if (node.getOperator() instanceof AbstractUdfStreamOperator) {\r\n        String udfClassName = ((AbstractUdfStreamOperator<?, ?>) node.getOperator()).getUserFunction().getClass().getName();\r\n        hasher.putString(udfClassName, Charset.forName(\"UTF-8\"));\r\n    }\r\n}","lc":-0.2272727273,"pi":-0.1531100478,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.2050739958,"fo":0.5833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-434_133cbc2d","label":1,"code":"\/**\r\n * Checks whether the given column is basic.\r\n * @param col index of the column to check\r\n * @return the row that the variable is basic in.  null if the column is not basic\r\n *\/\r\nprotected Integer getBasicRow(final int col) {\r\n    Integer row = null;\r\n    for (int i = 0; i < getHeight(); i++) {\r\n        if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\r\n            row = i;\r\n        } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\r\n            return null;\r\n        }\r\n    }\r\n    return row;\r\n}","code_comment":"\/**\r\n * Checks whether the given column is basic.\r\n * @param col index of the column to check\r\n * @return the row that the variable is basic in.  null if the column is not basic\r\n *\/\r\n","code_no_comment":"protected Integer getBasicRow(final int col) {\r\n    Integer row = null;\r\n    for (int i = 0; i < getHeight(); i++) {\r\n        if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\r\n            row = i;\r\n        } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\r\n            return null;\r\n        }\r\n    }\r\n    return row;\r\n}","lc":-0.1363636364,"pi":0.4593301435,"ma":0.0,"nbd":0.5,"ml":0.5833333333,"d":0.9047619048,"mi":0.0990838619,"fo":-0.0833333333,"r":0.2894736842,"e":0.3556070377}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-313_e115fd90","label":3,"code":"private String getOakPath(String jcrPath, final boolean keepIndex) {\r\n    final List<String> elements = new ArrayList<String>();\r\n    final StringBuilder parseErrors = new StringBuilder();\r\n    if (\"\/\".equals(jcrPath)) {\r\n        \/\/ avoid the need to special case the root path later on\r\n        return \"\/\";\r\n    }\r\n    int length = jcrPath.length();\r\n    \/\/ identifier path?\r\n    if (length > 0 && jcrPath.charAt(0) == '[') {\r\n        if (jcrPath.charAt(length - 1) != ']') {\r\n            \/\/ TODO error handling?\r\n            log.debug(\"Could not parse path \" + jcrPath + \": unterminated identifier\");\r\n            return null;\r\n        }\r\n        if (this.idManager == null) {\r\n            \/\/ TODO error handling?\r\n            log.debug(\"Could not parse path \" + jcrPath + \": could not resolve identifier\");\r\n            return null;\r\n        }\r\n        return this.idManager.getPath(jcrPath.substring(1, length - 1));\r\n    }\r\n    boolean hasClarkBrackets = false;\r\n    boolean hasIndexBrackets = false;\r\n    boolean hasColon = false;\r\n    boolean hasNameStartingWithDot = false;\r\n    char prev = 0;\r\n    for (int i = 0; i < length; i++) {\r\n        char c = jcrPath.charAt(i);\r\n        if (c == '{' || c == '}') {\r\n            hasClarkBrackets = true;\r\n        } else if (c == '[' || c == ']') {\r\n            hasIndexBrackets = true;\r\n        } else if (c == ':') {\r\n            hasColon = true;\r\n        } else if (c == '.' && (prev == 0 || prev == '\/')) {\r\n            hasNameStartingWithDot = true;\r\n        }\r\n        prev = c;\r\n    }\r\n    \/\/ try a shortcut\r\n    if (!hasNameStartingWithDot && !hasClarkBrackets && !hasIndexBrackets) {\r\n        if (!hasColon || !hasSessionLocalMappings()) {\r\n            if (JcrPathParser.validate(jcrPath)) {\r\n                return jcrPath;\r\n            } else {\r\n                log.debug(\"Invalid path: {}\", jcrPath);\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    JcrPathParser.Listener listener = new JcrPathParser.Listener() {\r\n\r\n        @Override\r\n        public boolean root() {\r\n            if (!elements.isEmpty()) {\r\n                parseErrors.append(\"\/ on non-empty path\");\r\n                return false;\r\n            }\r\n            elements.add(\"\");\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean current() {\r\n            \/\/ nothing to do here\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean parent() {\r\n            if (elements.isEmpty() || \"..\".equals(elements.get(elements.size() - 1))) {\r\n                elements.add(\"..\");\r\n                return true;\r\n            }\r\n            elements.remove(elements.size() - 1);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public void error(String message) {\r\n            parseErrors.append(message);\r\n        }\r\n\r\n        @Override\r\n        public boolean name(String name, int index) {\r\n            if (!keepIndex && index > 1) {\r\n                parseErrors.append(\"index > 1\");\r\n                return false;\r\n            }\r\n            String p = nameMapper.getOakName(name);\r\n            if (p == null) {\r\n                parseErrors.append(\"Invalid name: \").append(name);\r\n                return false;\r\n            }\r\n            if (keepIndex && index > 0) {\r\n                p += \"[\" + index + ']';\r\n            }\r\n            elements.add(p);\r\n            return true;\r\n        }\r\n    };\r\n    JcrPathParser.parse(jcrPath, listener);\r\n    if (parseErrors.length() != 0) {\r\n        log.debug(\"Could not parse path \" + jcrPath + \": \" + parseErrors.toString());\r\n        return null;\r\n    }\r\n    \/\/ Empty path maps to \"\"\r\n    if (elements.isEmpty()) {\r\n        return \"\";\r\n    }\r\n    StringBuilder oakPath = new StringBuilder();\r\n    for (String element : elements) {\r\n        if (element.isEmpty()) {\r\n            \/\/ root\r\n            oakPath.append('\/');\r\n        } else {\r\n            oakPath.append(element);\r\n            oakPath.append('\/');\r\n        }\r\n    }\r\n    \/\/ root path is special-cased early on so it does not need to\r\n    \/\/ be considered here\r\n    oakPath.deleteCharAt(oakPath.length() - 1);\r\n    return oakPath.toString();\r\n}","code_comment":null,"code_no_comment":"private String getOakPath(String jcrPath, final boolean keepIndex) {\r\n    final List<String> elements = new ArrayList<String>();\r\n    final StringBuilder parseErrors = new StringBuilder();\r\n    if (\"\/\".equals(jcrPath)) {\r\n                return \"\/\";\r\n    }\r\n    int length = jcrPath.length();\r\n        if (length > 0 && jcrPath.charAt(0) == '[') {\r\n        if (jcrPath.charAt(length - 1) != ']') {\r\n                        log.debug(\"Could not parse path \" + jcrPath + \": unterminated identifier\");\r\n            return null;\r\n        }\r\n        if (this.idManager == null) {\r\n                        log.debug(\"Could not parse path \" + jcrPath + \": could not resolve identifier\");\r\n            return null;\r\n        }\r\n        return this.idManager.getPath(jcrPath.substring(1, length - 1));\r\n    }\r\n    boolean hasClarkBrackets = false;\r\n    boolean hasIndexBrackets = false;\r\n    boolean hasColon = false;\r\n    boolean hasNameStartingWithDot = false;\r\n    char prev = 0;\r\n    for (int i = 0; i < length; i++) {\r\n        char c = jcrPath.charAt(i);\r\n        if (c == '{' || c == '}') {\r\n            hasClarkBrackets = true;\r\n        } else if (c == '[' || c == ']') {\r\n            hasIndexBrackets = true;\r\n        } else if (c == ':') {\r\n            hasColon = true;\r\n        } else if (c == '.' && (prev == 0 || prev == '\/')) {\r\n            hasNameStartingWithDot = true;\r\n        }\r\n        prev = c;\r\n    }\r\n        if (!hasNameStartingWithDot && !hasClarkBrackets && !hasIndexBrackets) {\r\n        if (!hasColon || !hasSessionLocalMappings()) {\r\n            if (JcrPathParser.validate(jcrPath)) {\r\n                return jcrPath;\r\n            } else {\r\n                log.debug(\"Invalid path: {}\", jcrPath);\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    JcrPathParser.Listener listener = new JcrPathParser.Listener() {\r\n\r\n        @Override\r\n        public boolean root() {\r\n            if (!elements.isEmpty()) {\r\n                parseErrors.append(\"\/ on non-empty path\");\r\n                return false;\r\n            }\r\n            elements.add(\"\");\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean current() {\r\n                        return true;\r\n        }\r\n\r\n        @Override\r\n        public boolean parent() {\r\n            if (elements.isEmpty() || \"..\".equals(elements.get(elements.size() - 1))) {\r\n                elements.add(\"..\");\r\n                return true;\r\n            }\r\n            elements.remove(elements.size() - 1);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public void error(String message) {\r\n            parseErrors.append(message);\r\n        }\r\n\r\n        @Override\r\n        public boolean name(String name, int index) {\r\n            if (!keepIndex && index > 1) {\r\n                parseErrors.append(\"index > 1\");\r\n                return false;\r\n            }\r\n            String p = nameMapper.getOakName(name);\r\n            if (p == null) {\r\n                parseErrors.append(\"Invalid name: \").append(name);\r\n                return false;\r\n            }\r\n            if (keepIndex && index > 0) {\r\n                p += \"[\" + index + ']';\r\n            }\r\n            elements.add(p);\r\n            return true;\r\n        }\r\n    };\r\n    JcrPathParser.parse(jcrPath, listener);\r\n    if (parseErrors.length() != 0) {\r\n        log.debug(\"Could not parse path \" + jcrPath + \": \" + parseErrors.toString());\r\n        return null;\r\n    }\r\n        if (elements.isEmpty()) {\r\n        return \"\";\r\n    }\r\n    StringBuilder oakPath = new StringBuilder();\r\n    for (String element : elements) {\r\n        if (element.isEmpty()) {\r\n                        oakPath.append('\/');\r\n        } else {\r\n            oakPath.append(element);\r\n            oakPath.append('\/');\r\n        }\r\n    }\r\n            oakPath.deleteCharAt(oakPath.length() - 1);\r\n    return oakPath.toString();\r\n}","lc":4.4090909091,"pi":0.4880382775,"ma":3.6,"nbd":1.5,"ml":4.1666666667,"d":3.4642857143,"mi":-1.4250880902,"fo":2.8333333333,"r":-0.0263157895,"e":17.0461621802}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5147_184e51e9","label":1,"code":"@Override\r\npublic IRequestHandler map(Exception e) {\r\n    try {\r\n        Response response = RequestCycle.get().getResponse();\r\n        if (response instanceof WebResponse) {\r\n            \/\/ we don't wan't to cache an exceptional reply in the browser\r\n            ((WebResponse) response).disableCaching();\r\n        }\r\n        return internalMap(e);\r\n    } catch (RuntimeException e2) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.error(\"An error occurred while handling a previous error: \" + e2.getMessage(), e2);\r\n        }\r\n        \/\/ hmmm, we were already handling an exception! give up\r\n        logger.error(\"unexpected exception when handling another exception: \" + e.getMessage(), e);\r\n        return new ErrorCodeRequestHandler(500);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic IRequestHandler map(Exception e) {\r\n    try {\r\n        Response response = RequestCycle.get().getResponse();\r\n        if (response instanceof WebResponse) {\r\n                        ((WebResponse) response).disableCaching();\r\n        }\r\n        return internalMap(e);\r\n    } catch (RuntimeException e2) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.error(\"An error occurred while handling a previous error: \" + e2.getMessage(), e2);\r\n        }\r\n                logger.error(\"unexpected exception when handling another exception: \" + e.getMessage(), e);\r\n        return new ErrorCodeRequestHandler(500);\r\n    }\r\n}","lc":0.0909090909,"pi":0.3540669856,"ma":0.0,"nbd":0.0,"ml":-0.0833333333,"d":-0.0674603175,"mi":-0.0782241015,"fo":0.25,"r":0.0,"e":-0.03601828}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5082_217fbb3b","label":1,"code":"@Override\r\npublic void renderHead(final Component component, final IHeaderResponse response) {\r\n    super.renderHead(component, response);\r\n    if (component.isEnabledInHierarchy()) {\r\n        CharSequence js = getCallbackScript(component);\r\n        AjaxRequestTarget target = component.getRequestCycle().find(AjaxRequestTarget.class);\r\n        if (target == null) {\r\n            response.render(OnDomReadyHeaderItem.forScript(js.toString()));\r\n        } else {\r\n            target.appendJavaScript(js);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void renderHead(final Component component, final IHeaderResponse response) {\r\n    super.renderHead(component, response);\r\n    if (component.isEnabledInHierarchy()) {\r\n        CharSequence js = getCallbackScript(component);\r\n        AjaxRequestTarget target = component.getRequestCycle().find(AjaxRequestTarget.class);\r\n        if (target == null) {\r\n            response.render(OnDomReadyHeaderItem.forScript(js.toString()));\r\n        } else {\r\n            target.appendJavaScript(js);\r\n        }\r\n    }\r\n}","lc":-0.0454545455,"pi":0.5023923445,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.0535714286,"mi":0.0404510218,"fo":0.25,"r":0.0,"e":-0.0448148084}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-366_db4a291f","label":1,"code":"boolean initiateMinorCompaction() {\r\n    \/\/ get the flush id before the new memmap is made available for write\r\n    long flushId = getFlushID();\r\n    return initiateMinorCompaction(flushId);\r\n}","code_comment":null,"code_no_comment":"boolean initiateMinorCompaction() {\r\n        long flushId = getFlushID();\r\n    return initiateMinorCompaction(flushId);\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9292459479,"fo":-0.3333333333,"r":2.3157894737,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-127_029e79da","label":1,"code":"\/**\r\n * Logs a message with the specific Marker at the FATAL level.\r\n *\r\n * @param marker the marker data specific to this log statement\r\n * @param msg    the message string to be logged\r\n *\/\r\npublic void fatal(Marker marker, Message msg) {\r\n    if (isEnabled(Level.FATAL, marker, msg, null)) {\r\n        log(null, FQCN, Level.FATAL, msg, null);\r\n    }\r\n}","code_comment":"\/**\r\n * Logs a message with the specific Marker at the FATAL level.\r\n *\r\n * @param marker the marker data specific to this log statement\r\n * @param msg    the message string to be logged\r\n *\/\r\n","code_no_comment":"public void fatal(Marker marker, Message msg) {\r\n    if (isEnabled(Level.FATAL, marker, msg, null)) {\r\n        log(null, FQCN, Level.FATAL, msg, null);\r\n    }\r\n}","lc":-0.4090909091,"pi":0.0,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.6109936575,"fo":-0.3333333333,"r":1.0,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5215_033eb6fe","label":3,"code":"public void process(Exchange exchange) throws Exception {\r\n    endpoint.configureExchange(exchange);\r\n    String target = createFileName(exchange);\r\n    \/\/ use lock for same file name to avoid concurrent writes to the same file\r\n    \/\/ for example when you concurrently append to the same file\r\n    Lock lock;\r\n    synchronized (locks) {\r\n        lock = locks.get(target);\r\n        if (lock == null) {\r\n            lock = new ReentrantLock();\r\n            locks.put(target, lock);\r\n        }\r\n    }\r\n    lock.lock();\r\n    try {\r\n        processExchange(exchange, target);\r\n    } finally {\r\n        \/\/ do not remove as the locks cache has an upper bound\r\n        \/\/ this ensure the locks is appropriate reused\r\n        lock.unlock();\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void process(Exchange exchange) throws Exception {\r\n    endpoint.configureExchange(exchange);\r\n    String target = createFileName(exchange);\r\n            Lock lock;\r\n    synchronized (locks) {\r\n        lock = locks.get(target);\r\n        if (lock == null) {\r\n            lock = new ReentrantLock();\r\n            locks.put(target, lock);\r\n        }\r\n    }\r\n    lock.lock();\r\n    try {\r\n        processExchange(exchange, target);\r\n    } finally {\r\n                        lock.unlock();\r\n    }\r\n}","lc":0.1818181818,"pi":0.1483253589,"ma":-0.4,"nbd":0.0,"ml":-0.25,"d":-0.0099206349,"mi":-0.1052854123,"fo":0.0833333333,"r":0.0,"e":-0.0250917746}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3107_937963e3","label":1,"code":"\/**\r\n *  Resets the state of {@link Execution} instances back to the state of a savepoint.\r\n *\r\n *  <p>The execution vertices need to be in state {@link ExecutionState#CREATED} when calling\r\n *  this method. The operation might block. Make sure that calls don't block the job manager\r\n *  actor.\r\n *\r\n *  @param tasks         Tasks that will possibly be reset\r\n *  @param savepointPath The path of the savepoint to rollback to\r\n *  @return The application ID of the rolled back savepoint\r\n *  @throws IllegalStateException If coordinator is shut down\r\n *  @throws IllegalStateException If mismatch between program and savepoint state\r\n *  @throws Exception             If savepoint store failure\r\n *\/\r\npublic ApplicationID restoreSavepoint(Map<JobVertexID, ExecutionJobVertex> tasks, String savepointPath) throws Exception {\r\n    checkNotNull(savepointPath, \"Savepoint path\");\r\n    synchronized (lock) {\r\n        if (isShutdown()) {\r\n            throw new IllegalStateException(\"CheckpointCoordinator is shut down\");\r\n        }\r\n        long recoveryTimestamp = System.currentTimeMillis();\r\n        LOG.info(\"Rolling back to savepoint '{}'.\", savepointPath);\r\n        Savepoint savepoint = savepointStore.getState(savepointPath);\r\n        CompletedCheckpoint checkpoint = savepoint.getCompletedCheckpoint();\r\n        LOG.info(\"Savepoint: {}@{}\", checkpoint.getCheckpointID(), checkpoint.getTimestamp());\r\n        \/\/ Set the initial state of all tasks\r\n        LOG.debug(\"Rolling back individual operators.\");\r\n        for (StateForTask state : checkpoint.getStates()) {\r\n            LOG.debug(\"Rolling back subtask {} of operator {}.\", state.getSubtask(), state.getOperatorId());\r\n            ExecutionJobVertex vertex = tasks.get(state.getOperatorId());\r\n            if (vertex == null) {\r\n                String msg = String.format(\"Failed to rollback to savepoint %s. \" + \"Cannot map old state for task %s to the new program. \" + \"This indicates that the program has been changed in a \" + \"non-compatible way  after the savepoint.\", savepoint, state.getOperatorId());\r\n                throw new IllegalStateException(msg);\r\n            }\r\n            if (state.getSubtask() >= vertex.getParallelism()) {\r\n                String msg = String.format(\"Failed to rollback to savepoint %s. \" + \"Parallelism mismatch between savepoint state and new program. \" + \"Cannot map subtask %d of operator %s to new program with \" + \"parallelism %d. This indicates that the program has been changed \" + \"in a non-compatible way after the savepoint.\", savepoint, state.getSubtask(), state.getOperatorId(), vertex.getParallelism());\r\n                throw new IllegalStateException(msg);\r\n            }\r\n            Execution exec = vertex.getTaskVertices()[state.getSubtask()].getCurrentExecutionAttempt();\r\n            exec.setInitialState(state.getState(), recoveryTimestamp);\r\n        }\r\n        \/\/ Reset the checkpoint ID counter\r\n        long nextCheckpointId = checkpoint.getCheckpointID();\r\n        checkpointIdCounter.setCount(nextCheckpointId + 1);\r\n        LOG.info(\"Reset the checkpoint ID to {}\", nextCheckpointId);\r\n        this.appId = savepoint.getApplicationId();\r\n        LOG.info(\"Reset the application ID to {}\", appId);\r\n        return appId;\r\n    }\r\n}","code_comment":"\/**\r\n *  Resets the state of {@link Execution} instances back to the state of a savepoint.\r\n *\r\n *  <p>The execution vertices need to be in state {@link ExecutionState#CREATED} when calling\r\n *  this method. The operation might block. Make sure that calls don't block the job manager\r\n *  actor.\r\n *\r\n *  @param tasks         Tasks that will possibly be reset\r\n *  @param savepointPath The path of the savepoint to rollback to\r\n *  @return The application ID of the rolled back savepoint\r\n *  @throws IllegalStateException If coordinator is shut down\r\n *  @throws IllegalStateException If mismatch between program and savepoint state\r\n *  @throws Exception             If savepoint store failure\r\n *\/\r\n","code_no_comment":"public ApplicationID restoreSavepoint(Map<JobVertexID, ExecutionJobVertex> tasks, String savepointPath) throws Exception {\r\n    checkNotNull(savepointPath, \"Savepoint path\");\r\n    synchronized (lock) {\r\n        if (isShutdown()) {\r\n            throw new IllegalStateException(\"CheckpointCoordinator is shut down\");\r\n        }\r\n        long recoveryTimestamp = System.currentTimeMillis();\r\n        LOG.info(\"Rolling back to savepoint '{}'.\", savepointPath);\r\n        Savepoint savepoint = savepointStore.getState(savepointPath);\r\n        CompletedCheckpoint checkpoint = savepoint.getCompletedCheckpoint();\r\n        LOG.info(\"Savepoint: {}@{}\", checkpoint.getCheckpointID(), checkpoint.getTimestamp());\r\n                LOG.debug(\"Rolling back individual operators.\");\r\n        for (StateForTask state : checkpoint.getStates()) {\r\n            LOG.debug(\"Rolling back subtask {} of operator {}.\", state.getSubtask(), state.getOperatorId());\r\n            ExecutionJobVertex vertex = tasks.get(state.getOperatorId());\r\n            if (vertex == null) {\r\n                String msg = String.format(\"Failed to rollback to savepoint %s. \" + \"Cannot map old state for task %s to the new program. \" + \"This indicates that the program has been changed in a \" + \"non-compatible way  after the savepoint.\", savepoint, state.getOperatorId());\r\n                throw new IllegalStateException(msg);\r\n            }\r\n            if (state.getSubtask() >= vertex.getParallelism()) {\r\n                String msg = String.format(\"Failed to rollback to savepoint %s. \" + \"Parallelism mismatch between savepoint state and new program. \" + \"Cannot map subtask %d of operator %s to new program with \" + \"parallelism %d. This indicates that the program has been changed \" + \"in a non-compatible way after the savepoint.\", savepoint, state.getSubtask(), state.getOperatorId(), vertex.getParallelism());\r\n                throw new IllegalStateException(msg);\r\n            }\r\n            Execution exec = vertex.getTaskVertices()[state.getSubtask()].getCurrentExecutionAttempt();\r\n            exec.setInitialState(state.getState(), recoveryTimestamp);\r\n        }\r\n                long nextCheckpointId = checkpoint.getCheckpointID();\r\n        checkpointIdCounter.setCount(nextCheckpointId + 1);\r\n        LOG.info(\"Reset the checkpoint ID to {}\", nextCheckpointId);\r\n        this.appId = savepoint.getApplicationId();\r\n        LOG.info(\"Reset the application ID to {}\", appId);\r\n        return appId;\r\n    }\r\n}","lc":0.9090909091,"pi":0.4545454545,"ma":0.8,"nbd":0.5,"ml":0.1666666667,"d":0.3928571429,"mi":-0.6772374912,"fo":2.3333333333,"r":-0.0263157895,"e":1.3755156377}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-1008_0c20bfd8","label":1,"code":"\/**\r\n * Returns the classloader that will be used for scanning for classes. If no explicit\r\n * ClassLoader has been set by the calling, the context class loader will be used.\r\n *\r\n * @return the ClassLoader that will be used to scan for classes\r\n *\/\r\npublic ClassLoader getClassLoader() {\r\n    return classloader != null ? classloader : (classloader = Loader.getClassLoader(ResolverUtil.class, null));\r\n}","code_comment":"\/**\r\n * Returns the classloader that will be used for scanning for classes. If no explicit\r\n * ClassLoader has been set by the calling, the context class loader will be used.\r\n *\r\n * @return the ClassLoader that will be used to scan for classes\r\n *\/\r\n","code_no_comment":"public ClassLoader getClassLoader() {\r\n    return classloader != null ? classloader : (classloader = Loader.getClassLoader(ResolverUtil.class, null));\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.4,"nbd":-1.0,"ml":-0.25,"d":-0.0535714286,"mi":0.9179704017,"fo":-0.4166666667,"r":2.1842105263,"e":-0.1329368441}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3644_ab1856db","label":1,"code":"public IRequestHandler onException(final RequestCycle cycle, final Exception ex) {\r\n    final List<IRequestHandler> handlers = new ArrayList<IRequestHandler>();\r\n    notify(new INotifier<IRequestCycleListener>() {\r\n\r\n        public void notify(IRequestCycleListener listener) {\r\n            IRequestHandler handler = listener.onException(cycle, ex);\r\n            if (handler != null) {\r\n                handlers.add(handler);\r\n            }\r\n        }\r\n    });\r\n    if (handlers.isEmpty()) {\r\n        return null;\r\n    }\r\n    if (handlers.size() > 1) {\r\n        throw new WicketRuntimeException(\"More than one request cycle listener returned a request handler while handling the exception.\", ex);\r\n    }\r\n    return handlers.get(0);\r\n}","code_comment":null,"code_no_comment":"public IRequestHandler onException(final RequestCycle cycle, final Exception ex) {\r\n    final List<IRequestHandler> handlers = new ArrayList<IRequestHandler>();\r\n    notify(new INotifier<IRequestCycleListener>() {\r\n\r\n        public void notify(IRequestCycleListener listener) {\r\n            IRequestHandler handler = listener.onException(cycle, ex);\r\n            if (handler != null) {\r\n                handlers.add(handler);\r\n            }\r\n        }\r\n    });\r\n    if (handlers.isEmpty()) {\r\n        return null;\r\n    }\r\n    if (handlers.size() > 1) {\r\n        throw new WicketRuntimeException(\"More than one request cycle listener returned a request handler while handling the exception.\", ex);\r\n    }\r\n    return handlers.get(0);\r\n}","lc":0.1818181818,"pi":0.6028708134,"ma":0.2,"nbd":0.0,"ml":0.0833333333,"d":-0.0257936508,"mi":-0.1613812544,"fo":0.0,"r":0.0,"e":0.0057283473}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-5727_ce6f0bfd","label":1,"code":"\/\/ DefaultProjectBuilder\r\npublic Artifact createDependencyArtifact(Dependency d) {\r\n    VersionRange versionRange;\r\n    try {\r\n        versionRange = VersionRange.createFromVersionSpec(d.getVersion());\r\n    } catch (InvalidVersionSpecificationException e) {\r\n        return null;\r\n    }\r\n    Artifact artifact = XcreateDependencyArtifact(d.getGroupId(), d.getArtifactId(), versionRange, d.getType(), d.getClassifier(), d.getScope(), d.isOptional());\r\n    if (Artifact.SCOPE_SYSTEM.equals(d.getScope()) && d.getSystemPath() != null) {\r\n        artifact.setFile(new File(d.getSystemPath()));\r\n    }\r\n    if (!d.getExclusions().isEmpty()) {\r\n        List<String> exclusions = new ArrayList<String>();\r\n        for (Exclusion exclusion : d.getExclusions()) {\r\n            exclusions.add(exclusion.getGroupId() + ':' + exclusion.getArtifactId());\r\n        }\r\n        artifact.setDependencyFilter(new ExcludesArtifactFilter(exclusions));\r\n    }\r\n    return artifact;\r\n}","code_comment":null,"code_no_comment":"public Artifact createDependencyArtifact(Dependency d) {\r\n    VersionRange versionRange;\r\n    try {\r\n        versionRange = VersionRange.createFromVersionSpec(d.getVersion());\r\n    } catch (InvalidVersionSpecificationException e) {\r\n        return null;\r\n    }\r\n    Artifact artifact = XcreateDependencyArtifact(d.getGroupId(), d.getArtifactId(), versionRange, d.getType(), d.getClassifier(), d.getScope(), d.isOptional());\r\n    if (Artifact.SCOPE_SYSTEM.equals(d.getScope()) && d.getSystemPath() != null) {\r\n        artifact.setFile(new File(d.getSystemPath()));\r\n    }\r\n    if (!d.getExclusions().isEmpty()) {\r\n        List<String> exclusions = new ArrayList<String>();\r\n        for (Exclusion exclusion : d.getExclusions()) {\r\n            exclusions.add(exclusion.getGroupId() + ':' + exclusion.getArtifactId());\r\n        }\r\n        artifact.setDependencyFilter(new ExcludesArtifactFilter(exclusions));\r\n    }\r\n    return artifact;\r\n}","lc":0.2727272727,"pi":-0.038277512,"ma":0.2,"nbd":0.0,"ml":0.1666666667,"d":0.3650793651,"mi":-0.30260747,"fo":1.25,"r":-0.0263157895,"e":0.5225474433}
{"project_name":"JxPath","project_version":"1","label":1,"code":"public static boolean testNode(Node node, NodeTest test) {\r\n    if (test == null) {\r\n        return true;\r\n    } else if (test instanceof NodeNameTest) {\r\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\r\n            return false;\r\n        }\r\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\r\n        QName testName = nodeNameTest.getNodeName();\r\n        String namespaceURI = nodeNameTest.getNamespaceURI();\r\n        boolean wildcard = nodeNameTest.isWildcard();\r\n        String testPrefix = testName.getPrefix();\r\n        if (wildcard && testPrefix == null) {\r\n            return true;\r\n        }\r\n        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {\r\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\r\n            return equalStrings(namespaceURI, nodeNS);\r\n        }\r\n    } else if (test instanceof NodeTypeTest) {\r\n        int nodeType = node.getNodeType();\r\n        switch(((NodeTypeTest) test).getNodeType()) {\r\n            case Compiler.NODE_TYPE_NODE:\r\n                return nodeType == Node.ELEMENT_NODE;\r\n            case Compiler.NODE_TYPE_TEXT:\r\n                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;\r\n            case Compiler.NODE_TYPE_COMMENT:\r\n                return nodeType == Node.COMMENT_NODE;\r\n            case Compiler.NODE_TYPE_PI:\r\n                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\r\n        }\r\n        return false;\r\n    } else if (test instanceof ProcessingInstructionTest) {\r\n        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\r\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\r\n            String nodePI = ((ProcessingInstruction) node).getTarget();\r\n            return testPI.equals(nodePI);\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"public static boolean testNode(Node node, NodeTest test) {\r\n    if (test == null) {\r\n        return true;\r\n    } else if (test instanceof NodeNameTest) {\r\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\r\n            return false;\r\n        }\r\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\r\n        QName testName = nodeNameTest.getNodeName();\r\n        String namespaceURI = nodeNameTest.getNamespaceURI();\r\n        boolean wildcard = nodeNameTest.isWildcard();\r\n        String testPrefix = testName.getPrefix();\r\n        if (wildcard && testPrefix == null) {\r\n            return true;\r\n        }\r\n        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {\r\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\r\n            return equalStrings(namespaceURI, nodeNS);\r\n        }\r\n    } else if (test instanceof NodeTypeTest) {\r\n        int nodeType = node.getNodeType();\r\n        switch(((NodeTypeTest) test).getNodeType()) {\r\n            case Compiler.NODE_TYPE_NODE:\r\n                return nodeType == Node.ELEMENT_NODE;\r\n            case Compiler.NODE_TYPE_TEXT:\r\n                return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;\r\n            case Compiler.NODE_TYPE_COMMENT:\r\n                return nodeType == Node.COMMENT_NODE;\r\n            case Compiler.NODE_TYPE_PI:\r\n                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\r\n        }\r\n        return false;\r\n    } else if (test instanceof ProcessingInstructionTest) {\r\n        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\r\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\r\n            String nodePI = ((ProcessingInstruction) node).getTarget();\r\n            return testPI.equals(nodePI);\r\n        }\r\n    }\r\n    return false;\r\n}","lc":1.2272727273,"pi":0.4354066986,"ma":1.8,"nbd":1.5,"ml":1.4166666667,"d":0.5694444444,"mi":-0.7663143058,"fo":0.8333333333,"r":-0.0263157895,"e":1.3940169315}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-448_999097e1","label":1,"code":"@Override\r\npublic boolean isModified() {\r\n    if (writeState == null) {\r\n        return false;\r\n    } else {\r\n        NodeState baseState = getBaseState();\r\n        for (Entry<String, MutableNodeState> n : writeState.nodes.entrySet()) {\r\n            if (n.getValue() == null) {\r\n                return true;\r\n            }\r\n            if (baseState == null || !baseState.hasChildNode(n.getKey())) {\r\n                return true;\r\n            }\r\n        }\r\n        for (Entry<String, PropertyState> p : writeState.properties.entrySet()) {\r\n            PropertyState pState = p.getValue();\r\n            if (pState == null) {\r\n                return true;\r\n            }\r\n            if (baseState == null || !pState.equals(baseState.getProperty(p.getKey()))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean isModified() {\r\n    if (writeState == null) {\r\n        return false;\r\n    } else {\r\n        NodeState baseState = getBaseState();\r\n        for (Entry<String, MutableNodeState> n : writeState.nodes.entrySet()) {\r\n            if (n.getValue() == null) {\r\n                return true;\r\n            }\r\n            if (baseState == null || !baseState.hasChildNode(n.getKey())) {\r\n                return true;\r\n            }\r\n        }\r\n        for (Entry<String, PropertyState> p : writeState.properties.entrySet()) {\r\n            PropertyState pState = p.getValue();\r\n            if (pState == null) {\r\n                return true;\r\n            }\r\n            if (baseState == null || !pState.equals(baseState.getProperty(p.getKey()))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}","lc":0.5454545455,"pi":0.8708133971,"ma":0.8,"nbd":0.5,"ml":0.9166666667,"d":0.4444444444,"mi":-0.3987315011,"fo":0.3333333333,"r":-0.0263157895,"e":0.403757427}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4256_09166ea8","label":1,"code":"\/**\r\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT!\r\n *  <p>\r\n *  Prepares the component and it's children for rendering. On whole page render this method must\r\n *  be called on the page. On AJAX request, this method must be called on the updated component.\r\n *\r\n *  @param setRenderingFlag\r\n *             Whether to set the rendering flag. This must be true if the page is about to be\r\n *             rendered. However, there are usecases to call this method without an immediate\r\n *             render (e.g. on stateless listener request target to build the component\r\n *             hierarchy), in that case setRenderingFlag should be false.\r\n *\/\r\npublic void internalPrepareForRender(boolean setRenderingFlag) {\r\n    beforeRender();\r\n    if (setRenderingFlag) {\r\n        \/\/ only process feedback panel when we are about to be rendered.\r\n        \/\/ setRenderingFlag is false in case prepareForRender is called only to build component\r\n        \/\/ hierarchy (i.e. in BookmarkableListenerInterfaceRequestTarget).\r\n        \/\/ prepareForRender(true) is always called before the actual rendering is done so\r\n        \/\/ that's where feedback panels gather the messages\r\n        List<Component> feedbacks = getRequestCycle().getMetaData(FEEDBACK_LIST);\r\n        if (feedbacks != null) {\r\n            for (Component feedback : feedbacks) {\r\n                feedback.internalBeforeRender();\r\n            }\r\n        }\r\n        getRequestCycle().setMetaData(FEEDBACK_LIST, null);\r\n    }\r\n    markRendering(setRenderingFlag);\r\n    \/\/ check authorization\r\n    \/\/ first the component itself\r\n    \/\/ (after attach as otherwise list views etc wont work)\r\n    setRenderAllowed();\r\n}","code_comment":"\/**\r\n *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT!\r\n *  <p>\r\n *  Prepares the component and it's children for rendering. On whole page render this method must\r\n *  be called on the page. On AJAX request, this method must be called on the updated component.\r\n *\r\n *  @param setRenderingFlag\r\n *             Whether to set the rendering flag. This must be true if the page is about to be\r\n *             rendered. However, there are usecases to call this method without an immediate\r\n *             render (e.g. on stateless listener request target to build the component\r\n *             hierarchy), in that case setRenderingFlag should be false.\r\n *\/\r\n","code_no_comment":"public void internalPrepareForRender(boolean setRenderingFlag) {\r\n    beforeRender();\r\n    if (setRenderingFlag) {\r\n                                                List<Component> feedbacks = getRequestCycle().getMetaData(FEEDBACK_LIST);\r\n        if (feedbacks != null) {\r\n            for (Component feedback : feedbacks) {\r\n                feedback.internalBeforeRender();\r\n            }\r\n        }\r\n        getRequestCycle().setMetaData(FEEDBACK_LIST, null);\r\n    }\r\n    markRendering(setRenderingFlag);\r\n                setRenderAllowed();\r\n}","lc":0.0,"pi":0.6937799043,"ma":0.0,"nbd":0.5,"ml":-0.0833333333,"d":-0.0555555556,"mi":0.0539816772,"fo":0.1666666667,"r":-0.0263157895,"e":-0.0816883064}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2062_5c4589bd","label":1,"code":"private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {\r\n    boolean asterisk = oakPropertyName.indexOf('*') >= 0;\r\n    if (asterisk) {\r\n        Tree t = currentTree();\r\n        ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();\r\n        readOakProperties(list, t, oakPropertyName, propertyType);\r\n        if (list.size() == 0) {\r\n            return null;\r\n        } else if (list.size() == 1) {\r\n            return list.get(0);\r\n        }\r\n        Type<?> type = list.get(0).getType();\r\n        for (int i = 1; i < list.size(); i++) {\r\n            Type<?> t2 = list.get(i).getType();\r\n            if (t2 != type) {\r\n                \/\/ types don't match\r\n                type = Type.STRING;\r\n                break;\r\n            }\r\n        }\r\n        if (type == Type.STRING) {\r\n            ArrayList<String> strings = new ArrayList<String>();\r\n            for (PropertyValue p : list) {\r\n                Iterables.addAll(strings, p.getValue(Type.STRINGS));\r\n            }\r\n            return PropertyValues.newString(strings);\r\n        }\r\n        @SuppressWarnings(\"unchecked\")\r\n        PropertyBuilder<Object> builder = (PropertyBuilder<Object>) PropertyBuilder.array(type);\r\n        builder.setName(\"\");\r\n        for (PropertyValue v : list) {\r\n            builder.addValue(v.getValue(type));\r\n        }\r\n        PropertyState s = builder.getPropertyState();\r\n        return PropertyValues.create(s);\r\n    }\r\n    boolean relative = oakPropertyName.indexOf('\/') >= 0;\r\n    Tree t = currentTree();\r\n    if (relative) {\r\n        for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {\r\n            if (t == null) {\r\n                return null;\r\n            }\r\n            if (p.equals(\"..\")) {\r\n                t = t.isRoot() ? null : t.getParent();\r\n            } else if (p.equals(\".\")) {\r\n            \/\/ same node\r\n            } else {\r\n                t = t.getChild(p);\r\n            }\r\n        }\r\n        oakPropertyName = PathUtils.getName(oakPropertyName);\r\n    }\r\n    return currentOakProperty(t, oakPropertyName, propertyType);\r\n}","code_comment":null,"code_no_comment":"private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {\r\n    boolean asterisk = oakPropertyName.indexOf('*') >= 0;\r\n    if (asterisk) {\r\n        Tree t = currentTree();\r\n        ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();\r\n        readOakProperties(list, t, oakPropertyName, propertyType);\r\n        if (list.size() == 0) {\r\n            return null;\r\n        } else if (list.size() == 1) {\r\n            return list.get(0);\r\n        }\r\n        Type<?> type = list.get(0).getType();\r\n        for (int i = 1; i < list.size(); i++) {\r\n            Type<?> t2 = list.get(i).getType();\r\n            if (t2 != type) {\r\n                                type = Type.STRING;\r\n                break;\r\n            }\r\n        }\r\n        if (type == Type.STRING) {\r\n            ArrayList<String> strings = new ArrayList<String>();\r\n            for (PropertyValue p : list) {\r\n                Iterables.addAll(strings, p.getValue(Type.STRINGS));\r\n            }\r\n            return PropertyValues.newString(strings);\r\n        }\r\n        @SuppressWarnings(\"unchecked\")\r\n        PropertyBuilder<Object> builder = (PropertyBuilder<Object>) PropertyBuilder.array(type);\r\n        builder.setName(\"\");\r\n        for (PropertyValue v : list) {\r\n            builder.addValue(v.getValue(type));\r\n        }\r\n        PropertyState s = builder.getPropertyState();\r\n        return PropertyValues.create(s);\r\n    }\r\n    boolean relative = oakPropertyName.indexOf('\/') >= 0;\r\n    Tree t = currentTree();\r\n    if (relative) {\r\n        for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {\r\n            if (t == null) {\r\n                return null;\r\n            }\r\n            if (p.equals(\"..\")) {\r\n                t = t.isRoot() ? null : t.getParent();\r\n            } else if (p.equals(\".\")) {\r\n                        } else {\r\n                t = t.getChild(p);\r\n            }\r\n        }\r\n        oakPropertyName = PathUtils.getName(oakPropertyName);\r\n    }\r\n    return currentOakProperty(t, oakPropertyName, propertyType);\r\n}","lc":1.7727272727,"pi":0.4497607656,"ma":2.4,"nbd":1.0,"ml":1.3333333333,"d":1.1091269841,"mi":-0.9605355884,"fo":2.0833333333,"r":-0.0263157895,"e":3.4717357353}
{"project_name":"Lang","project_version":"4","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic int translate(final CharSequence input, final int index, final Writer out) throws IOException {\r\n    int max = longest;\r\n    if (index + longest > input.length()) {\r\n        max = input.length() - index;\r\n    }\r\n    \/\/ descend so as to get a greedy algorithm\r\n    for (int i = max; i >= shortest; i--) {\r\n        final CharSequence subSeq = input.subSequence(index, index + i);\r\n        final CharSequence result = lookupMap.get(subSeq);\r\n        if (result != null) {\r\n            out.write(result.toString());\r\n            return i;\r\n        }\r\n    }\r\n    return 0;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic int translate(final CharSequence input, final int index, final Writer out) throws IOException {\r\n    int max = longest;\r\n    if (index + longest > input.length()) {\r\n        max = input.length() - index;\r\n    }\r\n        for (int i = max; i >= shortest; i--) {\r\n        final CharSequence subSeq = input.subSequence(index, index + i);\r\n        final CharSequence result = lookupMap.get(subSeq);\r\n        if (result != null) {\r\n            out.write(result.toString());\r\n            return i;\r\n        }\r\n    }\r\n    return 0;\r\n}","lc":0.0909090909,"pi":0.3444976077,"ma":0.0,"nbd":0.0,"ml":0.3333333333,"d":0.7738095238,"mi":-0.1377026075,"fo":0.0,"r":0.6052631579,"e":0.5642710188}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2079_ceac38b1","label":3,"code":"\/**\r\n *  Throw an exception if not all components rendered.\r\n *\r\n *  @param renderedContainer\r\n *             The page itself if it was a full page render or the container that was rendered\r\n *             standalone\r\n *\/\r\nprivate final void checkRendering(final MarkupContainer renderedContainer) {\r\n    \/\/ If the application wants component uses checked and\r\n    \/\/ the response is not a redirect\r\n    final IDebugSettings debugSettings = Application.get().getDebugSettings();\r\n    if (debugSettings.getComponentUseCheck() && !getResponse().isRedirect()) {\r\n        final List<Component> unrenderedComponents = new ArrayList<Component>();\r\n        final StringBuffer buffer = new StringBuffer();\r\n        renderedContainer.visitChildren(new IVisitor<Component>() {\r\n\r\n            public Object component(final Component component) {\r\n                \/\/ If component never rendered\r\n                if (renderedComponents == null || !renderedComponents.contains(component)) {\r\n                    \/\/ If auto component ...\r\n                    if (!component.isAuto() && component.isVisibleInHierarchy()) {\r\n                        \/\/ Increase number of unrendered components\r\n                        unrenderedComponents.add(component);\r\n                        \/\/ Add to explanatory string to buffer\r\n                        buffer.append(Integer.toString(unrenderedComponents.size()) + \". \" + component + \"\\n\");\r\n                        String metadata = component.getMetaData(Component.CONSTRUCTED_AT_KEY);\r\n                        if (metadata != null) {\r\n                            buffer.append(metadata);\r\n                        }\r\n                        metadata = component.getMetaData(Component.ADDED_AT_KEY);\r\n                        if (metadata != null) {\r\n                            buffer.append(metadata);\r\n                        }\r\n                    } else {\r\n                        \/\/ not visible\r\n                        return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;\r\n                    }\r\n                }\r\n                return CONTINUE_TRAVERSAL;\r\n            }\r\n        });\r\n        \/\/ Throw exception if any errors were found\r\n        if (unrenderedComponents.size() > 0) {\r\n            \/\/ Get rid of set\r\n            renderedComponents = null;\r\n            Iterator<Component> iterator = unrenderedComponents.iterator();\r\n            while (iterator.hasNext()) {\r\n                Component component = iterator.next();\r\n                \/\/ Now first test if the component has a sibling that is a transparent resolver.\r\n                Iterator<? extends Component> iterator2 = component.getParent().iterator();\r\n                while (iterator2.hasNext()) {\r\n                    Component sibling = iterator2.next();\r\n                    if (!sibling.isVisible()) {\r\n                        boolean isTransparentMarkupContainer = sibling instanceof MarkupContainer && ((MarkupContainer) sibling).isTransparentResolver();\r\n                        boolean isComponentResolver = sibling instanceof IComponentResolver;\r\n                        if (isTransparentMarkupContainer || isComponentResolver) {\r\n                            \/\/ we found a transparent container that isn't visible\r\n                            \/\/ then ignore this component and only do a debug statement here.\r\n                            log.debug(\"Component {} wasn't rendered but most likely it has a transparent parent: {}\", component, sibling);\r\n                            iterator.remove();\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \/\/ if still > 0\r\n            if (unrenderedComponents.size() > 0) {\r\n                \/\/ Throw exception\r\n                throw new WicketRuntimeException(\"The component(s) below failed to render. A common problem is that you have added a component in code but forgot to reference it in the markup (thus the component will never be rendered).\\n\\n\" + buffer.toString());\r\n            }\r\n        }\r\n    }\r\n    \/\/ Get rid of set\r\n    renderedComponents = null;\r\n}","code_comment":"\/**\r\n *  Throw an exception if not all components rendered.\r\n *\r\n *  @param renderedContainer\r\n *             The page itself if it was a full page render or the container that was rendered\r\n *             standalone\r\n *\/\r\n","code_no_comment":"private final void checkRendering(final MarkupContainer renderedContainer) {\r\n            final IDebugSettings debugSettings = Application.get().getDebugSettings();\r\n    if (debugSettings.getComponentUseCheck() && !getResponse().isRedirect()) {\r\n        final List<Component> unrenderedComponents = new ArrayList<Component>();\r\n        final StringBuffer buffer = new StringBuffer();\r\n        renderedContainer.visitChildren(new IVisitor<Component>() {\r\n\r\n            public Object component(final Component component) {\r\n                                if (renderedComponents == null || !renderedComponents.contains(component)) {\r\n                                        if (!component.isAuto() && component.isVisibleInHierarchy()) {\r\n                                                unrenderedComponents.add(component);\r\n                                                buffer.append(Integer.toString(unrenderedComponents.size()) + \". \" + component + \"\\n\");\r\n                        String metadata = component.getMetaData(Component.CONSTRUCTED_AT_KEY);\r\n                        if (metadata != null) {\r\n                            buffer.append(metadata);\r\n                        }\r\n                        metadata = component.getMetaData(Component.ADDED_AT_KEY);\r\n                        if (metadata != null) {\r\n                            buffer.append(metadata);\r\n                        }\r\n                    } else {\r\n                                                return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;\r\n                    }\r\n                }\r\n                return CONTINUE_TRAVERSAL;\r\n            }\r\n        });\r\n                if (unrenderedComponents.size() > 0) {\r\n                        renderedComponents = null;\r\n            Iterator<Component> iterator = unrenderedComponents.iterator();\r\n            while (iterator.hasNext()) {\r\n                Component component = iterator.next();\r\n                                Iterator<? extends Component> iterator2 = component.getParent().iterator();\r\n                while (iterator2.hasNext()) {\r\n                    Component sibling = iterator2.next();\r\n                    if (!sibling.isVisible()) {\r\n                        boolean isTransparentMarkupContainer = sibling instanceof MarkupContainer && ((MarkupContainer) sibling).isTransparentResolver();\r\n                        boolean isComponentResolver = sibling instanceof IComponentResolver;\r\n                        if (isTransparentMarkupContainer || isComponentResolver) {\r\n                                                                                    log.debug(\"Component {} wasn't rendered but most likely it has a transparent parent: {}\", component, sibling);\r\n                            iterator.remove();\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n                        if (unrenderedComponents.size() > 0) {\r\n                                throw new WicketRuntimeException(\"The component(s) below failed to render. A common problem is that you have added a component in code but forgot to reference it in the markup (thus the component will never be rendered).\\n\\n\" + buffer.toString());\r\n            }\r\n        }\r\n    }\r\n        renderedComponents = null;\r\n}","lc":1.7272727273,"pi":2.3397129187,"ma":2.0,"nbd":2.0,"ml":2.0,"d":1.3551587302,"mi":-0.9252995067,"fo":2.0833333333,"r":-0.0263157895,"e":3.7045993903}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5853_b80f6640","label":3,"code":"\/**\r\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)\r\n *\/\r\n@Override\r\npublic Long convertToObject(final String value, final Locale locale) {\r\n    final Number number = parse(value, Long.MIN_VALUE, Long.MAX_VALUE, locale);\r\n    if (number == null) {\r\n        return null;\r\n    }\r\n    return number.longValue();\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)\r\n *\/\r\n","code_no_comment":"@Override\r\npublic Long convertToObject(final String value, final Locale locale) {\r\n    final Number number = parse(value, Long.MIN_VALUE, Long.MAX_VALUE, locale);\r\n    if (number == null) {\r\n        return null;\r\n    }\r\n    return number.longValue();\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0734126984,"mi":0.3429175476,"fo":-0.3333333333,"r":0.2631578947,"e":-0.0964598353}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5662_9aec4f33","label":1,"code":"\/**\r\n *  @param field\r\n *  @return bean name\r\n *\/\r\nprivate String getBeanName(final Field field) {\r\n    SpringBean annot = field.getAnnotation(SpringBean.class);\r\n    String name;\r\n    boolean required;\r\n    if (annot != null) {\r\n        name = annot.name();\r\n        required = annot.required();\r\n    } else {\r\n        Named named = field.getAnnotation(Named.class);\r\n        name = named != null ? named.value() : \"\";\r\n        required = false;\r\n    }\r\n    if (Strings.isEmpty(name)) {\r\n        name = beanNameCache.get(field.getType());\r\n        if (name == null) {\r\n            name = getBeanNameOfClass(contextLocator.getSpringContext(), field.getType(), required);\r\n            if (name != null) {\r\n                String tmpName = beanNameCache.putIfAbsent(field.getType(), name);\r\n                if (tmpName != null) {\r\n                    name = tmpName;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return name;\r\n}","code_comment":"\/**\r\n *  @param field\r\n *  @return bean name\r\n *\/\r\n","code_no_comment":"private String getBeanName(final Field field) {\r\n    SpringBean annot = field.getAnnotation(SpringBean.class);\r\n    String name;\r\n    boolean required;\r\n    if (annot != null) {\r\n        name = annot.name();\r\n        required = annot.required();\r\n    } else {\r\n        Named named = field.getAnnotation(Named.class);\r\n        name = named != null ? named.value() : \"\";\r\n        required = false;\r\n    }\r\n    if (Strings.isEmpty(name)) {\r\n        name = beanNameCache.get(field.getType());\r\n        if (name == null) {\r\n            name = getBeanNameOfClass(contextLocator.getSpringContext(), field.getType(), required);\r\n            if (name != null) {\r\n                String tmpName = beanNameCache.putIfAbsent(field.getType(), name);\r\n                if (tmpName != null) {\r\n                    name = tmpName;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return name;\r\n}","lc":0.5454545455,"pi":0.971291866,"ma":0.6,"nbd":1.0,"ml":0.5,"d":0.130952381,"mi":-0.429739253,"fo":0.5833333333,"r":-0.0263157895,"e":0.2851472139}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-393_d4b02f6a","label":3,"code":"\/**\r\n * Get the result of the last run of the optimizer.\r\n *\r\n * @return the value of the function at the last result.\r\n * @throws IllegalStateException if there is no result available, either\r\n * because no result was yet computed or the last attempt failed.\r\n *\/\r\ndouble getFunctionValue();","code_comment":"\/**\r\n * Get the result of the last run of the optimizer.\r\n *\r\n * @return the value of the function at the last result.\r\n * @throws IllegalStateException if there is no result available, either\r\n * because no result was yet computed or the last attempt failed.\r\n *\/\r\n","code_no_comment":"double getFunctionValue();","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.8696264975,"fo":-0.5,"r":2.5526315789,"e":-0.1627934049}
{"project_name":"Time","project_version":"26","label":2,"code":"public long add(long instant, int value) {\r\n    if (iTimeField) {\r\n        int offset = getOffsetToAdd(instant);\r\n        long localInstant = iField.add(instant + offset, value);\r\n        return localInstant - offset;\r\n    } else {\r\n        long localInstant = iZone.convertUTCToLocal(instant);\r\n        localInstant = iField.add(localInstant, value);\r\n        return iZone.convertLocalToUTC(localInstant, false);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public long add(long instant, int value) {\r\n    if (iTimeField) {\r\n        int offset = getOffsetToAdd(instant);\r\n        long localInstant = iField.add(instant + offset, value);\r\n        return localInstant - offset;\r\n    } else {\r\n        long localInstant = iZone.convertUTCToLocal(instant);\r\n        localInstant = iField.add(localInstant, value);\r\n        return iZone.convertLocalToUTC(localInstant, false);\r\n    }\r\n}","lc":-0.1363636364,"pi":0.04784689,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.0773809524,"mi":0.1453136011,"fo":-0.0833333333,"r":0.0263157895,"e":-0.0188078814}
{"project_name":"Math","project_version":"16","label":1,"code":"\/**\r\n * Compute the hyperbolic sine of a number.\r\n * @param x number on which evaluation is done\r\n * @return hyperbolic sine of x\r\n *\/\r\npublic static double sinh(double x) {\r\n    boolean negate = false;\r\n    if (x != x) {\r\n        return x;\r\n    }\r\n    if (x > 20) {\r\n        \/\/ Avoid overflow (MATH-905).\r\n        return 0.5 * exp(x);\r\n    }\r\n    if (x < -20) {\r\n        \/\/ Avoid overflow (MATH-905).\r\n        return -0.5 * exp(-x);\r\n    }\r\n    if (x == 0) {\r\n        return x;\r\n    }\r\n    if (x < 0.0) {\r\n        x = -x;\r\n        negate = true;\r\n    }\r\n    double result;\r\n    if (x > 0.25) {\r\n        double[] hiPrec = new double[2];\r\n        exp(x, 0.0, hiPrec);\r\n        double ya = hiPrec[0] + hiPrec[1];\r\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\r\n        double temp = ya * HEX_40000000;\r\n        double yaa = ya + temp - temp;\r\n        double yab = ya - yaa;\r\n        \/\/ recip = 1\/y\r\n        double recip = 1.0 \/ ya;\r\n        temp = recip * HEX_40000000;\r\n        double recipa = recip + temp - temp;\r\n        double recipb = recip - recipa;\r\n        \/\/ Correct for rounding in division\r\n        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\r\n        \/\/ Account for yb\r\n        recipb += -yb * recip * recip;\r\n        recipa = -recipa;\r\n        recipb = -recipb;\r\n        \/\/ y = y + 1\/y\r\n        temp = ya + recipa;\r\n        yb += -(temp - ya - recipa);\r\n        ya = temp;\r\n        temp = ya + recipb;\r\n        yb += -(temp - ya - recipb);\r\n        ya = temp;\r\n        result = ya + yb;\r\n        result *= 0.5;\r\n    } else {\r\n        double[] hiPrec = new double[2];\r\n        expm1(x, hiPrec);\r\n        double ya = hiPrec[0] + hiPrec[1];\r\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\r\n        \/* Compute expm1(-x) = -expm1(x) \/ (expm1(x) + 1) *\/\r\n        double denom = 1.0 + ya;\r\n        double denomr = 1.0 \/ denom;\r\n        double denomb = -(denom - 1.0 - ya) + yb;\r\n        double ratio = ya * denomr;\r\n        double temp = ratio * HEX_40000000;\r\n        double ra = ratio + temp - temp;\r\n        double rb = ratio - ra;\r\n        temp = denom * HEX_40000000;\r\n        double za = denom + temp - temp;\r\n        double zb = denom - za;\r\n        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\r\n        \/\/ Adjust for yb\r\n        \/\/ numerator\r\n        rb += yb * denomr;\r\n        \/\/ denominator\r\n        rb += -ya * denomb * denomr * denomr;\r\n        \/\/ y = y - 1\/y\r\n        temp = ya + ra;\r\n        yb += -(temp - ya - ra);\r\n        ya = temp;\r\n        temp = ya + rb;\r\n        yb += -(temp - ya - rb);\r\n        ya = temp;\r\n        result = ya + yb;\r\n        result *= 0.5;\r\n    }\r\n    if (negate) {\r\n        result = -result;\r\n    }\r\n    return result;\r\n}","code_comment":"\/**\r\n * Compute the hyperbolic sine of a number.\r\n * @param x number on which evaluation is done\r\n * @return hyperbolic sine of x\r\n *\/\r\n","code_no_comment":"public static double sinh(double x) {\r\n    boolean negate = false;\r\n    if (x != x) {\r\n        return x;\r\n    }\r\n    if (x > 20) {\r\n                return 0.5 * exp(x);\r\n    }\r\n    if (x < -20) {\r\n                return -0.5 * exp(-x);\r\n    }\r\n    if (x == 0) {\r\n        return x;\r\n    }\r\n    if (x < 0.0) {\r\n        x = -x;\r\n        negate = true;\r\n    }\r\n    double result;\r\n    if (x > 0.25) {\r\n        double[] hiPrec = new double[2];\r\n        exp(x, 0.0, hiPrec);\r\n        double ya = hiPrec[0] + hiPrec[1];\r\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\r\n        double temp = ya * HEX_40000000;\r\n        double yaa = ya + temp - temp;\r\n        double yab = ya - yaa;\r\n                double recip = 1.0 \/ ya;\r\n        temp = recip * HEX_40000000;\r\n        double recipa = recip + temp - temp;\r\n        double recipb = recip - recipa;\r\n                recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\r\n                recipb += -yb * recip * recip;\r\n        recipa = -recipa;\r\n        recipb = -recipb;\r\n                temp = ya + recipa;\r\n        yb += -(temp - ya - recipa);\r\n        ya = temp;\r\n        temp = ya + recipb;\r\n        yb += -(temp - ya - recipb);\r\n        ya = temp;\r\n        result = ya + yb;\r\n        result *= 0.5;\r\n    } else {\r\n        double[] hiPrec = new double[2];\r\n        expm1(x, hiPrec);\r\n        double ya = hiPrec[0] + hiPrec[1];\r\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\r\n                double denom = 1.0 + ya;\r\n        double denomr = 1.0 \/ denom;\r\n        double denomb = -(denom - 1.0 - ya) + yb;\r\n        double ratio = ya * denomr;\r\n        double temp = ratio * HEX_40000000;\r\n        double ra = ratio + temp - temp;\r\n        double rb = ratio - ra;\r\n        temp = denom * HEX_40000000;\r\n        double za = denom + temp - temp;\r\n        double zb = denom - za;\r\n        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\r\n                        rb += yb * denomr;\r\n                rb += -ya * denomb * denomr * denomr;\r\n                temp = ya + ra;\r\n        yb += -(temp - ya - ra);\r\n        ya = temp;\r\n        temp = ya + rb;\r\n        yb += -(temp - ya - rb);\r\n        ya = temp;\r\n        result = ya + yb;\r\n        result *= 0.5;\r\n    }\r\n    if (negate) {\r\n        result = -result;\r\n    }\r\n    return result;\r\n}","lc":2.7727272727,"pi":-0.4545454545,"ma":0.8,"nbd":-0.5,"ml":0.3333333333,"d":5.5297619048,"mi":-1.1505285412,"fo":-0.1666666667,"r":-0.0263157895,"e":25.4889668805}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4932_f20b2d70","label":1,"code":"\/**\r\n *  Creates a {@code IRequestHandler} that processes a listener request.\r\n *\r\n *  @param pageComponentInfo\r\n *  @param pageClass\r\n *  @param pageParameters\r\n *  @return a {@code IRequestHandler} that invokes the listener interface\r\n *\/\r\nprotected IRequestHandler processListener(PageComponentInfo pageComponentInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters) {\r\n    PageInfo pageInfo = pageComponentInfo.getPageInfo();\r\n    ComponentInfo componentInfo = pageComponentInfo.getComponentInfo();\r\n    Integer renderCount = null;\r\n    RequestListenerInterface listenerInterface = null;\r\n    if (componentInfo != null) {\r\n        renderCount = componentInfo.getRenderCount();\r\n        listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());\r\n    }\r\n    if (listenerInterface != null) {\r\n        PageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(), pageClass, pageParameters, renderCount, componentInfo.getComponentPath());\r\n        provider.setPageSource(getContext());\r\n        return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());\r\n    } else {\r\n        if (logger.isWarnEnabled()) {\r\n            if (componentInfo != null) {\r\n                logger.warn(\"Unknown listener interface '{}'\", componentInfo.getListenerInterface());\r\n            } else {\r\n                logger.warn(\"Cannot extract the listener interface for PageComponentInfo: '{}'\" + pageComponentInfo);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}","code_comment":"\/**\r\n *  Creates a {@code IRequestHandler} that processes a listener request.\r\n *\r\n *  @param pageComponentInfo\r\n *  @param pageClass\r\n *  @param pageParameters\r\n *  @return a {@code IRequestHandler} that invokes the listener interface\r\n *\/\r\n","code_no_comment":"protected IRequestHandler processListener(PageComponentInfo pageComponentInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters) {\r\n    PageInfo pageInfo = pageComponentInfo.getPageInfo();\r\n    ComponentInfo componentInfo = pageComponentInfo.getComponentInfo();\r\n    Integer renderCount = null;\r\n    RequestListenerInterface listenerInterface = null;\r\n    if (componentInfo != null) {\r\n        renderCount = componentInfo.getRenderCount();\r\n        listenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());\r\n    }\r\n    if (listenerInterface != null) {\r\n        PageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(), pageClass, pageParameters, renderCount, componentInfo.getComponentPath());\r\n        provider.setPageSource(getContext());\r\n        return new ListenerInterfaceRequestHandler(provider, listenerInterface, componentInfo.getBehaviorId());\r\n    } else {\r\n        if (logger.isWarnEnabled()) {\r\n            if (componentInfo != null) {\r\n                logger.warn(\"Unknown listener interface '{}'\", componentInfo.getListenerInterface());\r\n            } else {\r\n                logger.warn(\"Cannot extract the listener interface for PageComponentInfo: '{}'\" + pageComponentInfo);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}","lc":0.4545454545,"pi":0.5789473684,"ma":0.2,"nbd":0.5,"ml":0.1666666667,"d":-0.005952381,"mi":-0.3897110641,"fo":0.6666666667,"r":-0.0263157895,"e":0.1837612305}
{"project_name":"Codec","project_version":"18","label":1,"code":"\/**\r\n * <p>\r\n * Compares two CharSequences, returning <code>true<\/code> if they represent equal sequences of characters.\r\n * <\/p>\r\n *\r\n * <p>\r\n * <code>null<\/code>s are handled without exceptions. Two <code>null<\/code> references are considered to be equal.\r\n * The comparison is case sensitive.\r\n * <\/p>\r\n *\r\n * <pre>\r\n * StringUtils.equals(null, null)   = true\r\n * StringUtils.equals(null, \"abc\")  = false\r\n * StringUtils.equals(\"abc\", null)  = false\r\n * StringUtils.equals(\"abc\", \"abc\") = true\r\n * StringUtils.equals(\"abc\", \"ABC\") = false\r\n * <\/pre>\r\n *\r\n * <p>\r\n * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\r\n * <\/p>\r\n *\r\n * @see Object#equals(Object)\r\n * @param cs1\r\n *            the first CharSequence, may be <code>null<\/code>\r\n * @param cs2\r\n *            the second CharSequence, may be <code>null<\/code>\r\n * @return <code>true<\/code> if the CharSequences are equal (case-sensitive), or both <code>null<\/code>\r\n * @since 1.10\r\n *\/\r\npublic static boolean equals(final CharSequence cs1, final CharSequence cs2) {\r\n    if (cs1 == cs2) {\r\n        return true;\r\n    }\r\n    if (cs1 == null || cs2 == null) {\r\n        return false;\r\n    }\r\n    if (cs1 instanceof String && cs2 instanceof String) {\r\n        return cs1.equals(cs2);\r\n    }\r\n    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\r\n}","code_comment":"\/**\r\n * <p>\r\n * Compares two CharSequences, returning <code>true<\/code> if they represent equal sequences of characters.\r\n * <\/p>\r\n *\r\n * <p>\r\n * <code>null<\/code>s are handled without exceptions. Two <code>null<\/code> references are considered to be equal.\r\n * The comparison is case sensitive.\r\n * <\/p>\r\n *\r\n * <pre>\r\n * StringUtils.equals(null, null)   = true\r\n * StringUtils.equals(null, \"abc\")  = false\r\n * StringUtils.equals(\"abc\", null)  = false\r\n * StringUtils.equals(\"abc\", \"abc\") = true\r\n * StringUtils.equals(\"abc\", \"ABC\") = false\r\n * <\/pre>\r\n *\r\n * <p>\r\n * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\r\n * <\/p>\r\n *\r\n * @see Object#equals(Object)\r\n * @param cs1\r\n *            the first CharSequence, may be <code>null<\/code>\r\n * @param cs2\r\n *            the second CharSequence, may be <code>null<\/code>\r\n * @return <code>true<\/code> if the CharSequences are equal (case-sensitive), or both <code>null<\/code>\r\n * @since 1.10\r\n *\/\r\n","code_no_comment":"public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\r\n    if (cs1 == cs2) {\r\n        return true;\r\n    }\r\n    if (cs1 == null || cs2 == null) {\r\n        return false;\r\n    }\r\n    if (cs1 instanceof String && cs2 instanceof String) {\r\n        return cs1.equals(cs2);\r\n    }\r\n    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\r\n}","lc":-0.0909090909,"pi":-0.2057416268,"ma":0.0,"nbd":-0.5,"ml":0.1666666667,"d":0.0853174603,"mi":0.0706131078,"fo":-0.0833333333,"r":-0.0263157895,"e":0.0071529423}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-844_7994d3ee","label":3,"code":"\/**\r\n * Estimate a first guess of the amplitude and angular frequency.\r\n * This method assumes that the {@link #sortObservations()} method\r\n * has been called previously.\r\n *\r\n * @throws ZeroException if the abscissa range is zero.\r\n *\/\r\nprivate void guessAOmega() {\r\n    \/\/ initialize the sums for the linear model between the two integrals\r\n    double sx2 = 0;\r\n    double sy2 = 0;\r\n    double sxy = 0;\r\n    double sxz = 0;\r\n    double syz = 0;\r\n    double currentX = observations[0].getX();\r\n    double currentY = observations[0].getY();\r\n    double f2Integral = 0;\r\n    double fPrime2Integral = 0;\r\n    final double startX = currentX;\r\n    for (int i = 1; i < observations.length; ++i) {\r\n        \/\/ one step forward\r\n        final double previousX = currentX;\r\n        final double previousY = currentY;\r\n        currentX = observations[i].getX();\r\n        currentY = observations[i].getY();\r\n        \/\/ update the integrals of f<sup>2<\/sup> and f'<sup>2<\/sup>\r\n        \/\/ considering a linear model for f (and therefore constant f')\r\n        final double dx = currentX - previousX;\r\n        final double dy = currentY - previousY;\r\n        final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) \/ 3;\r\n        final double fPrime2StepIntegral = dy * dy \/ dx;\r\n        final double x = currentX - startX;\r\n        f2Integral += f2StepIntegral;\r\n        fPrime2Integral += fPrime2StepIntegral;\r\n        sx2 += x * x;\r\n        sy2 += f2Integral * f2Integral;\r\n        sxy += x * f2Integral;\r\n        sxz += x * fPrime2Integral;\r\n        syz += f2Integral * fPrime2Integral;\r\n    }\r\n    \/\/ compute the amplitude and pulsation coefficients\r\n    double c1 = sy2 * sxz - sxy * syz;\r\n    double c2 = sxy * sxz - sx2 * syz;\r\n    double c3 = sx2 * sy2 - sxy * sxy;\r\n    if ((c1 \/ c2 < 0) || (c2 \/ c3 < 0)) {\r\n        final int last = observations.length - 1;\r\n        \/\/ Range of the observations, assuming that the\r\n        \/\/ observations are sorted.\r\n        final double xRange = observations[last].getX() - observations[0].getX();\r\n        if (xRange == 0) {\r\n            throw new ZeroException();\r\n        }\r\n        omega = 2 * Math.PI \/ xRange;\r\n        double yMin = Double.POSITIVE_INFINITY;\r\n        double yMax = Double.NEGATIVE_INFINITY;\r\n        for (int i = 1; i < observations.length; ++i) {\r\n            final double y = observations[i].getY();\r\n            if (y < yMin) {\r\n                yMin = y;\r\n            }\r\n            if (y > yMax) {\r\n                yMax = y;\r\n            }\r\n        }\r\n        a = 0.5 * (yMax - yMin);\r\n    } else {\r\n        a = FastMath.sqrt(c1 \/ c2);\r\n        omega = FastMath.sqrt(c2 \/ c3);\r\n    }\r\n}","code_comment":"\/**\r\n * Estimate a first guess of the amplitude and angular frequency.\r\n * This method assumes that the {@link #sortObservations()} method\r\n * has been called previously.\r\n *\r\n * @throws ZeroException if the abscissa range is zero.\r\n *\/\r\n","code_no_comment":"private void guessAOmega() {\r\n        double sx2 = 0;\r\n    double sy2 = 0;\r\n    double sxy = 0;\r\n    double sxz = 0;\r\n    double syz = 0;\r\n    double currentX = observations[0].getX();\r\n    double currentY = observations[0].getY();\r\n    double f2Integral = 0;\r\n    double fPrime2Integral = 0;\r\n    final double startX = currentX;\r\n    for (int i = 1; i < observations.length; ++i) {\r\n                final double previousX = currentX;\r\n        final double previousY = currentY;\r\n        currentX = observations[i].getX();\r\n        currentY = observations[i].getY();\r\n                        final double dx = currentX - previousX;\r\n        final double dy = currentY - previousY;\r\n        final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) \/ 3;\r\n        final double fPrime2StepIntegral = dy * dy \/ dx;\r\n        final double x = currentX - startX;\r\n        f2Integral += f2StepIntegral;\r\n        fPrime2Integral += fPrime2StepIntegral;\r\n        sx2 += x * x;\r\n        sy2 += f2Integral * f2Integral;\r\n        sxy += x * f2Integral;\r\n        sxz += x * fPrime2Integral;\r\n        syz += f2Integral * fPrime2Integral;\r\n    }\r\n        double c1 = sy2 * sxz - sxy * syz;\r\n    double c2 = sxy * sxz - sx2 * syz;\r\n    double c3 = sx2 * sy2 - sxy * sxy;\r\n    if ((c1 \/ c2 < 0) || (c2 \/ c3 < 0)) {\r\n        final int last = observations.length - 1;\r\n                        final double xRange = observations[last].getX() - observations[0].getX();\r\n        if (xRange == 0) {\r\n            throw new ZeroException();\r\n        }\r\n        omega = 2 * Math.PI \/ xRange;\r\n        double yMin = Double.POSITIVE_INFINITY;\r\n        double yMax = Double.NEGATIVE_INFINITY;\r\n        for (int i = 1; i < observations.length; ++i) {\r\n            final double y = observations[i].getY();\r\n            if (y < yMin) {\r\n                yMin = y;\r\n            }\r\n            if (y > yMax) {\r\n                yMax = y;\r\n            }\r\n        }\r\n        a = 0.5 * (yMax - yMin);\r\n    } else {\r\n        a = FastMath.sqrt(c1 \/ c2);\r\n        omega = FastMath.sqrt(c2 \/ c3);\r\n    }\r\n}","lc":1.9090909091,"pi":0.1339712919,"ma":0.8,"nbd":0.5,"ml":0.9166666667,"d":3.0753968254,"mi":-0.9816772375,"fo":0.25,"r":-0.0263157895,"e":11.591982619}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-395_a19ecc9e","label":1,"code":"\/**\r\n * Default Factory Constructor.\r\n * @param name The configuration name.\r\n * @param configLocation The configuration location.\r\n * @return The Configuration.\r\n *\/\r\n@Override\r\npublic Configuration getConfiguration(final String name, final URI configLocation) {\r\n    if (configLocation == null) {\r\n        final String config = PropertiesUtil.getProperties().getStringProperty(CONFIGURATION_FILE_PROPERTY);\r\n        if (config != null) {\r\n            final ClassLoader loader = this.getClass().getClassLoader();\r\n            final ConfigurationSource source = getInputFromString(config, loader);\r\n            if (source != null) {\r\n                for (final ConfigurationFactory factory : factories) {\r\n                    final String[] types = factory.getSupportedTypes();\r\n                    if (types != null) {\r\n                        for (final String type : types) {\r\n                            if (type.equals(\"*\") || config.endsWith(type)) {\r\n                                final Configuration c = factory.getConfiguration(source);\r\n                                if (c != null) {\r\n                                    return c;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        for (final ConfigurationFactory factory : factories) {\r\n            final String[] types = factory.getSupportedTypes();\r\n            if (types != null) {\r\n                for (final String type : types) {\r\n                    if (type.equals(\"*\") || configLocation.toString().endsWith(type)) {\r\n                        final Configuration config = factory.getConfiguration(name, configLocation);\r\n                        if (config != null) {\r\n                            return config;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Configuration config = getConfiguration(true, name);\r\n    if (config == null) {\r\n        config = getConfiguration(true, null);\r\n        if (config == null) {\r\n            config = getConfiguration(false, name);\r\n            if (config == null) {\r\n                config = getConfiguration(false, null);\r\n            }\r\n        }\r\n    }\r\n    return config != null ? config : new DefaultConfiguration();\r\n}","code_comment":"\/**\r\n * Default Factory Constructor.\r\n * @param name The configuration name.\r\n * @param configLocation The configuration location.\r\n * @return The Configuration.\r\n *\/\r\n","code_no_comment":"@Override\r\npublic Configuration getConfiguration(final String name, final URI configLocation) {\r\n    if (configLocation == null) {\r\n        final String config = PropertiesUtil.getProperties().getStringProperty(CONFIGURATION_FILE_PROPERTY);\r\n        if (config != null) {\r\n            final ClassLoader loader = this.getClass().getClassLoader();\r\n            final ConfigurationSource source = getInputFromString(config, loader);\r\n            if (source != null) {\r\n                for (final ConfigurationFactory factory : factories) {\r\n                    final String[] types = factory.getSupportedTypes();\r\n                    if (types != null) {\r\n                        for (final String type : types) {\r\n                            if (type.equals(\"*\") || config.endsWith(type)) {\r\n                                final Configuration c = factory.getConfiguration(source);\r\n                                if (c != null) {\r\n                                    return c;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        for (final ConfigurationFactory factory : factories) {\r\n            final String[] types = factory.getSupportedTypes();\r\n            if (types != null) {\r\n                for (final String type : types) {\r\n                    if (type.equals(\"*\") || configLocation.toString().endsWith(type)) {\r\n                        final Configuration config = factory.getConfiguration(name, configLocation);\r\n                        if (config != null) {\r\n                            return config;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Configuration config = getConfiguration(true, name);\r\n    if (config == null) {\r\n        config = getConfiguration(true, null);\r\n        if (config == null) {\r\n            config = getConfiguration(false, name);\r\n            if (config == null) {\r\n                config = getConfiguration(false, null);\r\n            }\r\n        }\r\n    }\r\n    return config != null ? config : new DefaultConfiguration();\r\n}","lc":1.6363636364,"pi":3.028708134,"ma":2.8,"nbd":3.0,"ml":1.5833333333,"d":0.8829365079,"mi":-0.8875264271,"fo":1.0,"r":-0.0263157895,"e":1.8896469056}
{"project_name":"Closure","project_version":"47","label":2,"code":"public void addMapping(Node node, FilePosition outputStartPosition, FilePosition outputEndPosition) {\r\n    String sourceFile = node.getSourceFileName();\r\n    \/\/ information for a mapping to be useful.\r\n    if (sourceFile == null || node.getLineno() < 0) {\r\n        return;\r\n    }\r\n    sourceFile = fixupSourceLocation(sourceFile);\r\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\r\n    \/\/ Strangely, Rhino source lines are one based but columns are\r\n    \/\/ zero based.\r\n    \/\/ We don't change this for the v1 or v2 source maps but for\r\n    \/\/ v3 we make them both 0 based.\r\n    generator.addMapping(sourceFile, originalName, new FilePosition(node.getLineno(), node.getCharno()), outputStartPosition, outputEndPosition);\r\n}","code_comment":null,"code_no_comment":"public void addMapping(Node node, FilePosition outputStartPosition, FilePosition outputEndPosition) {\r\n    String sourceFile = node.getSourceFileName();\r\n        if (sourceFile == null || node.getLineno() < 0) {\r\n        return;\r\n    }\r\n    sourceFile = fixupSourceLocation(sourceFile);\r\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\r\n                    generator.addMapping(sourceFile, originalName, new FilePosition(node.getLineno(), node.getCharno()), outputStartPosition, outputEndPosition);\r\n}","lc":-0.2272727273,"pi":-0.3444976077,"ma":-0.4,"nbd":-0.5,"ml":-0.0833333333,"d":0.4285714286,"mi":0.18534179,"fo":0.0833333333,"r":-0.0263157895,"e":0.2042588014}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4927_8c827e33","label":1,"code":"@Override\r\npublic void setDateHeader(String name, Time date) {\r\n    Args.notNull(date, \"date\");\r\n    checkHeader();\r\n    bufferedResponse.setDateHeader(name, date);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void setDateHeader(String name, Time date) {\r\n    Args.notNull(date, \"date\");\r\n    checkHeader();\r\n    bufferedResponse.setDateHeader(name, date);\r\n}","lc":-0.3636363636,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5644820296,"fo":-0.25,"r":0.0263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3718_73ce9cfb","label":0,"code":"public boolean equals(Mutation m) {\r\n    serialize();\r\n    m.serialize();\r\n    if (Arrays.equals(row, m.row) && entries == m.entries && Arrays.equals(data, m.data)) {\r\n        if (values == null && m.values == null)\r\n            return true;\r\n        if (values != null && m.values != null && values.size() == m.values.size()) {\r\n            for (int i = 0; i < values.size(); i++) {\r\n                if (!Arrays.equals(values.get(i), m.values.get(i)))\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":null,"code_no_comment":"public boolean equals(Mutation m) {\r\n    serialize();\r\n    m.serialize();\r\n    if (Arrays.equals(row, m.row) && entries == m.entries && Arrays.equals(data, m.data)) {\r\n        if (values == null && m.values == null)\r\n            return true;\r\n        if (values != null && m.values != null && values.size() == m.values.size()) {\r\n            for (int i = 0; i < values.size(); i++) {\r\n                if (!Arrays.equals(values.get(i), m.values.get(i)))\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}","lc":0.0909090909,"pi":1.1913875598,"ma":0.4,"nbd":0.5,"ml":1.75,"d":1.5257936508,"mi":-0.1712473573,"fo":0.3333333333,"r":-0.0263157895,"e":1.2271087983}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-412_be2fdba7","label":1,"code":"public static List<TabletLocation> findOverlappingTablets(AccumuloConfiguration acuConf, FileSystem fs, TabletLocator locator, Path file, Text startRow, Text endRow) throws Exception {\r\n    List<TabletLocation> result = new ArrayList<TabletLocation>();\r\n    Collection<ByteSequence> columnFamilies = Collections.emptyList();\r\n    FileSKVIterator reader = FileOperations.getInstance().openReader(file.toString(), true, fs, fs.getConf(), acuConf);\r\n    try {\r\n        Text row = startRow;\r\n        if (row == null)\r\n            row = new Text();\r\n        while (true) {\r\n            reader.seek(new Range(row, null), columnFamilies, false);\r\n            if (!reader.hasTop())\r\n                break;\r\n            row = reader.getTopKey().getRow();\r\n            TabletLocation tabletLocation = locator.locateTablet(row, false, true);\r\n            result.add(tabletLocation);\r\n            row = tabletLocation.tablet_extent.getEndRow();\r\n            if (row != null && (endRow == null || row.compareTo(endRow) < 0))\r\n                row = Range.followingPrefix(row);\r\n            else\r\n                break;\r\n        }\r\n    } finally {\r\n        reader.close();\r\n    }\r\n    return result;\r\n}","code_comment":null,"code_no_comment":"public static List<TabletLocation> findOverlappingTablets(AccumuloConfiguration acuConf, FileSystem fs, TabletLocator locator, Path file, Text startRow, Text endRow) throws Exception {\r\n    List<TabletLocation> result = new ArrayList<TabletLocation>();\r\n    Collection<ByteSequence> columnFamilies = Collections.emptyList();\r\n    FileSKVIterator reader = FileOperations.getInstance().openReader(file.toString(), true, fs, fs.getConf(), acuConf);\r\n    try {\r\n        Text row = startRow;\r\n        if (row == null)\r\n            row = new Text();\r\n        while (true) {\r\n            reader.seek(new Range(row, null), columnFamilies, false);\r\n            if (!reader.hasTop())\r\n                break;\r\n            row = reader.getTopKey().getRow();\r\n            TabletLocation tabletLocation = locator.locateTablet(row, false, true);\r\n            result.add(tabletLocation);\r\n            row = tabletLocation.tablet_extent.getEndRow();\r\n            if (row != null && (endRow == null || row.compareTo(endRow) < 0))\r\n                row = Range.followingPrefix(row);\r\n            else\r\n                break;\r\n        }\r\n    } finally {\r\n        reader.close();\r\n    }\r\n    return result;\r\n}","lc":0.5454545455,"pi":0.8038277512,"ma":0.6,"nbd":0.0,"ml":0.4166666667,"d":0.7380952381,"mi":-0.4951374207,"fo":0.75,"r":-0.0263157895,"e":1.3939708281}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-358_061f5017","label":0,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\r\n    sanityChecks(equations, t0, y0, t, y);\r\n    setEquations(equations);\r\n    resetEvaluations();\r\n    final boolean forward = t > t0;\r\n    \/\/ create some internal working arrays\r\n    final int stages = c.length + 1;\r\n    if (y != y0) {\r\n        System.arraycopy(y0, 0, y, 0, y0.length);\r\n    }\r\n    final double[][] yDotK = new double[stages][y0.length];\r\n    final double[] yTmp = new double[y0.length];\r\n    \/\/ set up an interpolator sharing the integrator arrays\r\n    AbstractStepInterpolator interpolator;\r\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\r\n        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\r\n        rki.reinitialize(this, yTmp, yDotK, forward);\r\n        interpolator = rki;\r\n    } else {\r\n        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\r\n    }\r\n    interpolator.storeTime(t0);\r\n    \/\/ set up integration control objects\r\n    stepStart = t0;\r\n    double hNew = 0;\r\n    boolean firstTime = true;\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.reset();\r\n    }\r\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\r\n    boolean lastStep = false;\r\n    \/\/ main integration loop\r\n    while (!lastStep) {\r\n        interpolator.shift();\r\n        double error = 0;\r\n        for (boolean loop = true; loop; ) {\r\n            if (firstTime || !fsal) {\r\n                \/\/ first stage\r\n                computeDerivatives(stepStart, y, yDotK[0]);\r\n            }\r\n            if (firstTime) {\r\n                final double[] scale = new double[y0.length];\r\n                if (vecAbsoluteTolerance == null) {\r\n                    for (int i = 0; i < scale.length; ++i) {\r\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\r\n                    }\r\n                } else {\r\n                    for (int i = 0; i < scale.length; ++i) {\r\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\r\n                    }\r\n                }\r\n                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\r\n                firstTime = false;\r\n            }\r\n            stepSize = hNew;\r\n            \/\/ next stages\r\n            for (int k = 1; k < stages; ++k) {\r\n                for (int j = 0; j < y0.length; ++j) {\r\n                    double sum = a[k - 1][0] * yDotK[0][j];\r\n                    for (int l = 1; l < k; ++l) {\r\n                        sum += a[k - 1][l] * yDotK[l][j];\r\n                    }\r\n                    yTmp[j] = y[j] + stepSize * sum;\r\n                }\r\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\r\n            }\r\n            \/\/ estimate the state at the end of the step\r\n            for (int j = 0; j < y0.length; ++j) {\r\n                double sum = b[0] * yDotK[0][j];\r\n                for (int l = 1; l < stages; ++l) {\r\n                    sum += b[l] * yDotK[l][j];\r\n                }\r\n                yTmp[j] = y[j] + stepSize * sum;\r\n            }\r\n            \/\/ estimate the error at the end of the step\r\n            error = estimateError(yDotK, y, yTmp, stepSize);\r\n            if (error <= 1.0) {\r\n                \/\/ discrete events handling\r\n                interpolator.storeTime(stepStart + stepSize);\r\n                if (manager.evaluateStep(interpolator)) {\r\n                    final double dt = manager.getEventTime() - stepStart;\r\n                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\r\n                        \/\/ rejecting the step would lead to a too small next step, we accept it\r\n                        loop = false;\r\n                    } else {\r\n                        \/\/ reject the step to match exactly the next switch time\r\n                        hNew = dt;\r\n                    }\r\n                } else {\r\n                    \/\/ accept the step\r\n                    loop = false;\r\n                }\r\n            } else {\r\n                \/\/ reject the step and attempt to reduce error by stepsize control\r\n                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\r\n                hNew = filterStep(stepSize * factor, forward, false);\r\n            }\r\n        }\r\n        \/\/ the step has been accepted\r\n        final double nextStep = stepStart + stepSize;\r\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\r\n        manager.stepAccepted(nextStep, y);\r\n        lastStep = manager.stop();\r\n        \/\/ provide the step data to the step handler\r\n        interpolator.storeTime(nextStep);\r\n        for (StepHandler handler : stepHandlers) {\r\n            handler.handleStep(interpolator, lastStep);\r\n        }\r\n        stepStart = nextStep;\r\n        if (fsal) {\r\n            \/\/ save the last evaluation for the next step\r\n            System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\r\n        }\r\n        if (manager.reset(stepStart, y) && !lastStep) {\r\n            \/\/ some event handler has triggered changes that\r\n            \/\/ invalidate the derivatives, we need to recompute them\r\n            computeDerivatives(stepStart, y, yDotK[0]);\r\n        }\r\n        if (!lastStep) {\r\n            \/\/ in some rare cases we may get here with stepSize = 0, for example\r\n            \/\/ when an event occurs at integration start, reducing the first step\r\n            \/\/ to zero; we have to reset the step to some safe non zero value\r\n            stepSize = filterStep(stepSize, forward, true);\r\n            \/\/ stepsize control for next step\r\n            final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\r\n            final double scaledH = stepSize * factor;\r\n            final double nextT = stepStart + scaledH;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            hNew = filterStep(scaledH, forward, nextIsLast);\r\n        }\r\n    }\r\n    final double stopTime = stepStart;\r\n    resetInternalState();\r\n    return stopTime;\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException {\r\n    sanityChecks(equations, t0, y0, t, y);\r\n    setEquations(equations);\r\n    resetEvaluations();\r\n    final boolean forward = t > t0;\r\n        final int stages = c.length + 1;\r\n    if (y != y0) {\r\n        System.arraycopy(y0, 0, y, 0, y0.length);\r\n    }\r\n    final double[][] yDotK = new double[stages][y0.length];\r\n    final double[] yTmp = new double[y0.length];\r\n        AbstractStepInterpolator interpolator;\r\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\r\n        final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\r\n        rki.reinitialize(this, yTmp, yDotK, forward);\r\n        interpolator = rki;\r\n    } else {\r\n        interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\r\n    }\r\n    interpolator.storeTime(t0);\r\n        stepStart = t0;\r\n    double hNew = 0;\r\n    boolean firstTime = true;\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.reset();\r\n    }\r\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\r\n    boolean lastStep = false;\r\n        while (!lastStep) {\r\n        interpolator.shift();\r\n        double error = 0;\r\n        for (boolean loop = true; loop; ) {\r\n            if (firstTime || !fsal) {\r\n                                computeDerivatives(stepStart, y, yDotK[0]);\r\n            }\r\n            if (firstTime) {\r\n                final double[] scale = new double[y0.length];\r\n                if (vecAbsoluteTolerance == null) {\r\n                    for (int i = 0; i < scale.length; ++i) {\r\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\r\n                    }\r\n                } else {\r\n                    for (int i = 0; i < scale.length; ++i) {\r\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\r\n                    }\r\n                }\r\n                hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]);\r\n                firstTime = false;\r\n            }\r\n            stepSize = hNew;\r\n                        for (int k = 1; k < stages; ++k) {\r\n                for (int j = 0; j < y0.length; ++j) {\r\n                    double sum = a[k - 1][0] * yDotK[0][j];\r\n                    for (int l = 1; l < k; ++l) {\r\n                        sum += a[k - 1][l] * yDotK[l][j];\r\n                    }\r\n                    yTmp[j] = y[j] + stepSize * sum;\r\n                }\r\n                computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\r\n            }\r\n                        for (int j = 0; j < y0.length; ++j) {\r\n                double sum = b[0] * yDotK[0][j];\r\n                for (int l = 1; l < stages; ++l) {\r\n                    sum += b[l] * yDotK[l][j];\r\n                }\r\n                yTmp[j] = y[j] + stepSize * sum;\r\n            }\r\n                        error = estimateError(yDotK, y, yTmp, stepSize);\r\n            if (error <= 1.0) {\r\n                                interpolator.storeTime(stepStart + stepSize);\r\n                if (manager.evaluateStep(interpolator)) {\r\n                    final double dt = manager.getEventTime() - stepStart;\r\n                    if (Math.abs(dt) <= Math.ulp(stepStart)) {\r\n                                                loop = false;\r\n                    } else {\r\n                                                hNew = dt;\r\n                    }\r\n                } else {\r\n                                        loop = false;\r\n                }\r\n            } else {\r\n                                final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\r\n                hNew = filterStep(stepSize * factor, forward, false);\r\n            }\r\n        }\r\n                final double nextStep = stepStart + stepSize;\r\n        System.arraycopy(yTmp, 0, y, 0, y0.length);\r\n        manager.stepAccepted(nextStep, y);\r\n        lastStep = manager.stop();\r\n                interpolator.storeTime(nextStep);\r\n        for (StepHandler handler : stepHandlers) {\r\n            handler.handleStep(interpolator, lastStep);\r\n        }\r\n        stepStart = nextStep;\r\n        if (fsal) {\r\n                        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\r\n        }\r\n        if (manager.reset(stepStart, y) && !lastStep) {\r\n                                    computeDerivatives(stepStart, y, yDotK[0]);\r\n        }\r\n        if (!lastStep) {\r\n                                                stepSize = filterStep(stepSize, forward, true);\r\n                        final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\r\n            final double scaledH = stepSize * factor;\r\n            final double nextT = stepStart + scaledH;\r\n            final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\r\n            hNew = filterStep(scaledH, forward, nextIsLast);\r\n        }\r\n    }\r\n    final double stopTime = stepStart;\r\n    resetInternalState();\r\n    return stopTime;\r\n}","lc":4.5454545455,"pi":1.5263157895,"ma":4.0,"nbd":1.5,"ml":3.6666666667,"d":5.0456349206,"mi":-1.5268498943,"fo":3.0,"r":-0.0263157895,"e":40.9264869787}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5476_813d8bee","label":3,"code":"\/**\r\n *  @see Component#onComponentTag(ComponentTag)\r\n *  @param tag\r\n *             the abstraction representing html tag of this component\r\n *\/\r\n@Override\r\nprotected void onComponentTag(final ComponentTag tag) {\r\n    \/\/ Default handling for component tag\r\n    super.onComponentTag(tag);\r\n    \/\/ must be attached to <input type=\"radio\" ...\/> tag\r\n    checkComponentTag(tag, \"input\");\r\n    checkComponentTagAttribute(tag, \"type\", \"radio\");\r\n    final String value = getValue();\r\n    RadioGroup<?> group = getGroup();\r\n    \/\/ assign name and value\r\n    tag.put(\"name\", group.getInputName());\r\n    tag.put(\"value\", value);\r\n    \/\/ checked attribute, first check if there was a raw input on the group.\r\n    if (group.hasRawInput()) {\r\n        String rawInput = group.getRawInput();\r\n        if (rawInput != null && rawInput.equals(value)) {\r\n            tag.put(\"checked\", \"checked\");\r\n        }\r\n    } else if (group.getModelComparator().compare(group, getDefaultModelObject())) {\r\n        tag.put(\"checked\", \"checked\");\r\n    }\r\n    if (group.wantOnSelectionChangedNotifications()) {\r\n        \/\/ url that points to this components IOnChangeListener method\r\n        CharSequence url = group.urlFor(IOnChangeListener.INTERFACE, new PageParameters());\r\n        Form<?> form = group.findParent(Form.class);\r\n        if (form != null) {\r\n            tag.put(\"onclick\", form.getJsForInterfaceUrl(url));\r\n        } else {\r\n            \/\/ NOTE: do not encode the url as that would give invalid JavaScript\r\n            tag.put(\"onclick\", \"window.location.href='\" + url + (url.toString().indexOf('?') > -1 ? \"&\" : \"?\") + group.getInputName() + \"=' + this.value;\");\r\n        }\r\n    }\r\n    if (!isEnabledInHierarchy()) {\r\n        tag.put(ATTR_DISABLED, ATTR_DISABLED);\r\n    }\r\n    \/\/ put group id into the class so we can easily identify all radios belonging to the group\r\n    final String marker = \"wicket-\" + getGroup().getMarkupId();\r\n    String clazz = tag.getAttribute(\"class\");\r\n    if (Strings.isEmpty(clazz)) {\r\n        clazz = marker;\r\n    } else {\r\n        clazz = clazz + \" \" + marker;\r\n    }\r\n    tag.put(\"class\", clazz);\r\n}","code_comment":"\/**\r\n *  @see Component#onComponentTag(ComponentTag)\r\n *  @param tag\r\n *             the abstraction representing html tag of this component\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void onComponentTag(final ComponentTag tag) {\r\n        super.onComponentTag(tag);\r\n        checkComponentTag(tag, \"input\");\r\n    checkComponentTagAttribute(tag, \"type\", \"radio\");\r\n    final String value = getValue();\r\n    RadioGroup<?> group = getGroup();\r\n        tag.put(\"name\", group.getInputName());\r\n    tag.put(\"value\", value);\r\n        if (group.hasRawInput()) {\r\n        String rawInput = group.getRawInput();\r\n        if (rawInput != null && rawInput.equals(value)) {\r\n            tag.put(\"checked\", \"checked\");\r\n        }\r\n    } else if (group.getModelComparator().compare(group, getDefaultModelObject())) {\r\n        tag.put(\"checked\", \"checked\");\r\n    }\r\n    if (group.wantOnSelectionChangedNotifications()) {\r\n                CharSequence url = group.urlFor(IOnChangeListener.INTERFACE, new PageParameters());\r\n        Form<?> form = group.findParent(Form.class);\r\n        if (form != null) {\r\n            tag.put(\"onclick\", form.getJsForInterfaceUrl(url));\r\n        } else {\r\n                        tag.put(\"onclick\", \"window.location.href='\" + url + (url.toString().indexOf('?') > -1 ? \"&\" : \"?\") + group.getInputName() + \"=' + this.value;\");\r\n        }\r\n    }\r\n    if (!isEnabledInHierarchy()) {\r\n        tag.put(ATTR_DISABLED, ATTR_DISABLED);\r\n    }\r\n        final String marker = \"wicket-\" + getGroup().getMarkupId();\r\n    String clazz = tag.getAttribute(\"class\");\r\n    if (Strings.isEmpty(clazz)) {\r\n        clazz = marker;\r\n    } else {\r\n        clazz = clazz + \" \" + marker;\r\n    }\r\n    tag.put(\"class\", clazz);\r\n}","lc":1.0909090909,"pi":-0.004784689,"ma":1.0,"nbd":0.0,"ml":1.4166666667,"d":0.8452380952,"mi":-0.7251585624,"fo":2.1666666667,"r":-0.0263157895,"e":2.1419062603}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3740_f2f5bd5b","label":1,"code":"@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic void processElement(StreamRecord<IN> element) throws Exception {\r\n    Collection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\r\n    K key = (K) getStateBackend().getCurrentKey();\r\n    if (windowAssigner instanceof MergingWindowAssigner) {\r\n        MergingWindowSet<W> mergingWindows = mergingWindowsByKey.get(getStateBackend().getCurrentKey());\r\n        if (mergingWindows == null) {\r\n            mergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner);\r\n            mergingWindowsByKey.put(key, mergingWindows);\r\n        }\r\n        for (W window : elementWindows) {\r\n            \/\/ If there is a merge, it can only result in a window that contains our new\r\n            \/\/ element because we always eagerly merge\r\n            final Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\r\n            \/\/ adding the new window might result in a merge, in that case the actualWindow\r\n            \/\/ is the merged window and we work with that. If we don't merge then\r\n            \/\/ actualWindow == window\r\n            W actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\r\n\r\n                @Override\r\n                public void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception {\r\n                    context.window = mergeResult;\r\n                    \/\/ store for later use\r\n                    mergeTriggerResult.f0 = context.onMerge(mergedWindows);\r\n                    for (W m : mergedWindows) {\r\n                        context.window = m;\r\n                        context.clear();\r\n                    }\r\n                    \/\/ merge the merged state windows into the newly resulting state window\r\n                    getStateBackend().mergePartitionedStates(stateWindowResult, mergedStateWindows, windowSerializer, (StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\r\n                }\r\n            });\r\n            W stateWindow = mergingWindows.getStateWindow(actualWindow);\r\n            ListState<StreamRecord<IN>> windowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\r\n            windowState.add(element);\r\n            context.key = key;\r\n            context.window = actualWindow;\r\n            \/\/ we might have already fired because of a merge but still call onElement\r\n            \/\/ on the (possibly merged) window\r\n            TriggerResult triggerResult = context.onElement(element);\r\n            TriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\r\n            processTriggerResult(combinedTriggerResult, key, actualWindow);\r\n        }\r\n    } else {\r\n        for (W window : elementWindows) {\r\n            ListState<StreamRecord<IN>> windowState = getPartitionedState(window, windowSerializer, windowStateDescriptor);\r\n            windowState.add(element);\r\n            context.key = key;\r\n            context.window = window;\r\n            TriggerResult triggerResult = context.onElement(element);\r\n            processTriggerResult(triggerResult, key, window);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic void processElement(StreamRecord<IN> element) throws Exception {\r\n    Collection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\r\n    K key = (K) getStateBackend().getCurrentKey();\r\n    if (windowAssigner instanceof MergingWindowAssigner) {\r\n        MergingWindowSet<W> mergingWindows = mergingWindowsByKey.get(getStateBackend().getCurrentKey());\r\n        if (mergingWindows == null) {\r\n            mergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner);\r\n            mergingWindowsByKey.put(key, mergingWindows);\r\n        }\r\n        for (W window : elementWindows) {\r\n                                    final Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\r\n                                                W actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\r\n\r\n                @Override\r\n                public void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception {\r\n                    context.window = mergeResult;\r\n                                        mergeTriggerResult.f0 = context.onMerge(mergedWindows);\r\n                    for (W m : mergedWindows) {\r\n                        context.window = m;\r\n                        context.clear();\r\n                    }\r\n                                        getStateBackend().mergePartitionedStates(stateWindowResult, mergedStateWindows, windowSerializer, (StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\r\n                }\r\n            });\r\n            W stateWindow = mergingWindows.getStateWindow(actualWindow);\r\n            ListState<StreamRecord<IN>> windowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\r\n            windowState.add(element);\r\n            context.key = key;\r\n            context.window = actualWindow;\r\n                                    TriggerResult triggerResult = context.onElement(element);\r\n            TriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\r\n            processTriggerResult(combinedTriggerResult, key, actualWindow);\r\n        }\r\n    } else {\r\n        for (W window : elementWindows) {\r\n            ListState<StreamRecord<IN>> windowState = getPartitionedState(window, windowSerializer, windowStateDescriptor);\r\n            windowState.add(element);\r\n            context.key = key;\r\n            context.window = window;\r\n            TriggerResult triggerResult = context.onElement(element);\r\n            processTriggerResult(triggerResult, key, window);\r\n        }\r\n    }\r\n}","lc":1.4090909091,"pi":1.4497607656,"ma":0.4,"nbd":1.0,"ml":-0.0833333333,"d":0.1805555556,"mi":-0.8263565891,"fo":1.5,"r":-0.0263157895,"e":1.2337707393}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-366_db4a291f","label":1,"code":"private CompactionStats _majorCompact(MajorCompactionReason reason) throws IOException, CompactionCanceledException {\r\n    boolean propogateDeletes;\r\n    long t1, t2, t3;\r\n    \/\/ acquire first and last key info outside of tablet lock\r\n    Map<String, Pair<Key, Key>> falks = null;\r\n    if (reason == MajorCompactionReason.CHOP)\r\n        falks = getFirstAndLastKeys(datafileManager.getDatafileSizes());\r\n    Map<String, Long> filesToCompact;\r\n    int maxFilesToCompact = acuTableConf.getCount(Property.TSERV_MAJC_THREAD_MAXOPEN);\r\n    CompactionStats majCStats = new CompactionStats();\r\n    synchronized (this) {\r\n        \/\/ plan all that work that needs to be done in the sync block... then do the actual work\r\n        \/\/ outside the sync block\r\n        t1 = System.currentTimeMillis();\r\n        majorCompactionWaitingToStart = true;\r\n        tabletMemory.waitForMinC();\r\n        t2 = System.currentTimeMillis();\r\n        majorCompactionWaitingToStart = false;\r\n        notifyAll();\r\n        if (extent.equals(Constants.ROOT_TABLET_EXTENT)) {\r\n            \/\/ very important that we call this before doing major compaction,\r\n            \/\/ otherwise deleted compacted files could possible be brought back\r\n            \/\/ at some point if the file they were compacted to was legitimately\r\n            \/\/ removed by a major compaction\r\n            cleanUpFiles(fs, fs.listStatus(this.location), this.location, false);\r\n        }\r\n        \/\/ getFilesToCompact() and cleanUpFiles() both\r\n        \/\/ do dir listings, which means two calls to the namenode\r\n        \/\/ we should refactor so that there is only one call\r\n        CompactionTuple ret = getFilesToCompact(reason, falks);\r\n        if (ret == null) {\r\n            \/\/ nothing to compact\r\n            return majCStats;\r\n        }\r\n        filesToCompact = ret.getFilesToCompact();\r\n        if (!ret.getCompactAll()) {\r\n            \/\/ since not all files are being compacted, we want to propagate delete entries\r\n            propogateDeletes = true;\r\n        } else {\r\n            propogateDeletes = false;\r\n        }\r\n        t3 = System.currentTimeMillis();\r\n        datafileManager.reserveMajorCompactingFiles(filesToCompact.keySet());\r\n    }\r\n    try {\r\n        log.debug(String.format(\"MajC initiate lock %.2f secs, wait %.2f secs\", (t3 - t2) \/ 1000.0, (t2 - t1) \/ 1000.0));\r\n        Long compactionId = null;\r\n        if (!propogateDeletes) {\r\n            \/\/ compacting everything, so update the compaction id in !METADATA\r\n            compactionId = getCompactionID();\r\n        }\r\n        \/\/ need to handle case where only one file is being major compacted\r\n        while (filesToCompact.size() > 0) {\r\n            int numToCompact = maxFilesToCompact;\r\n            if (filesToCompact.size() > maxFilesToCompact && filesToCompact.size() < 2 * maxFilesToCompact) {\r\n                \/\/ on the second to last compaction pass, compact the minimum amount of files possible\r\n                numToCompact = filesToCompact.size() - maxFilesToCompact + 1;\r\n            }\r\n            Set<String> smallestFiles = removeSmallest(filesToCompact, numToCompact);\r\n            String fileName = getNextMapFilename((filesToCompact.size() == 0 && !propogateDeletes) ? \"A\" : \"C\");\r\n            String compactTmpName = fileName + \"_tmp\";\r\n            Span span = Trace.start(\"compactFiles\");\r\n            try {\r\n                CompactionEnv cenv = new CompactionEnv() {\r\n\r\n                    @Override\r\n                    public boolean isCompactionEnabled() {\r\n                        return Tablet.this.isCompactionEnabled();\r\n                    }\r\n\r\n                    @Override\r\n                    public IteratorScope getIteratorScope() {\r\n                        return IteratorScope.majc;\r\n                    }\r\n                };\r\n                HashMap<String, DataFileValue> copy = new HashMap<String, DataFileValue>(datafileManager.getDatafileSizes());\r\n                if (!copy.keySet().containsAll(smallestFiles))\r\n                    throw new IllegalStateException(\"Cannot find data file values for \" + smallestFiles);\r\n                copy.keySet().retainAll(smallestFiles);\r\n                log.debug(\"Starting MajC \" + extent + \" (\" + reason + \") \" + datafileManager.abs2rel(datafileManager.string2path(copy.keySet())) + \" --> \" + datafileManager.abs2rel(new Path(compactTmpName)));\r\n                Compactor compactor = new \/\/ always\r\n                Compactor(\/\/ always\r\n                conf, \/\/ always\r\n                fs, \/\/ always\r\n                copy, \/\/ always\r\n                null, \/\/ always\r\n                compactTmpName, \/\/ always\r\n                filesToCompact.size() == 0 ? propogateDeletes : true, \/\/ batch\r\n                acuTableConf, extent, cenv);\r\n                CompactionStats mcs = compactor.call();\r\n                span.data(\"files\", \"\" + smallestFiles.size());\r\n                span.data(\"read\", \"\" + mcs.getEntriesRead());\r\n                span.data(\"written\", \"\" + mcs.getEntriesWritten());\r\n                majCStats.add(mcs);\r\n                datafileManager.bringMajorCompactionOnline(smallestFiles, compactTmpName, fileName, filesToCompact.size() == 0 ? compactionId : null, new DataFileValue(mcs.getFileSize(), mcs.getEntriesWritten()));\r\n                \/\/ to add the deleted file\r\n                if (filesToCompact.size() > 0 && mcs.getEntriesWritten() > 0) {\r\n                    filesToCompact.put(fileName, mcs.getFileSize());\r\n                }\r\n            } finally {\r\n                span.stop();\r\n            }\r\n        }\r\n        return majCStats;\r\n    } finally {\r\n        synchronized (Tablet.this) {\r\n            datafileManager.clearMajorCompactingFile();\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"private CompactionStats _majorCompact(MajorCompactionReason reason) throws IOException, CompactionCanceledException {\r\n    boolean propogateDeletes;\r\n    long t1, t2, t3;\r\n        Map<String, Pair<Key, Key>> falks = null;\r\n    if (reason == MajorCompactionReason.CHOP)\r\n        falks = getFirstAndLastKeys(datafileManager.getDatafileSizes());\r\n    Map<String, Long> filesToCompact;\r\n    int maxFilesToCompact = acuTableConf.getCount(Property.TSERV_MAJC_THREAD_MAXOPEN);\r\n    CompactionStats majCStats = new CompactionStats();\r\n    synchronized (this) {\r\n                        t1 = System.currentTimeMillis();\r\n        majorCompactionWaitingToStart = true;\r\n        tabletMemory.waitForMinC();\r\n        t2 = System.currentTimeMillis();\r\n        majorCompactionWaitingToStart = false;\r\n        notifyAll();\r\n        if (extent.equals(Constants.ROOT_TABLET_EXTENT)) {\r\n                                                            cleanUpFiles(fs, fs.listStatus(this.location), this.location, false);\r\n        }\r\n                                CompactionTuple ret = getFilesToCompact(reason, falks);\r\n        if (ret == null) {\r\n                        return majCStats;\r\n        }\r\n        filesToCompact = ret.getFilesToCompact();\r\n        if (!ret.getCompactAll()) {\r\n                        propogateDeletes = true;\r\n        } else {\r\n            propogateDeletes = false;\r\n        }\r\n        t3 = System.currentTimeMillis();\r\n        datafileManager.reserveMajorCompactingFiles(filesToCompact.keySet());\r\n    }\r\n    try {\r\n        log.debug(String.format(\"MajC initiate lock %.2f secs, wait %.2f secs\", (t3 - t2) \/ 1000.0, (t2 - t1) \/ 1000.0));\r\n        Long compactionId = null;\r\n        if (!propogateDeletes) {\r\n                        compactionId = getCompactionID();\r\n        }\r\n                while (filesToCompact.size() > 0) {\r\n            int numToCompact = maxFilesToCompact;\r\n            if (filesToCompact.size() > maxFilesToCompact && filesToCompact.size() < 2 * maxFilesToCompact) {\r\n                                numToCompact = filesToCompact.size() - maxFilesToCompact + 1;\r\n            }\r\n            Set<String> smallestFiles = removeSmallest(filesToCompact, numToCompact);\r\n            String fileName = getNextMapFilename((filesToCompact.size() == 0 && !propogateDeletes) ? \"A\" : \"C\");\r\n            String compactTmpName = fileName + \"_tmp\";\r\n            Span span = Trace.start(\"compactFiles\");\r\n            try {\r\n                CompactionEnv cenv = new CompactionEnv() {\r\n\r\n                    @Override\r\n                    public boolean isCompactionEnabled() {\r\n                        return Tablet.this.isCompactionEnabled();\r\n                    }\r\n\r\n                    @Override\r\n                    public IteratorScope getIteratorScope() {\r\n                        return IteratorScope.majc;\r\n                    }\r\n                };\r\n                HashMap<String, DataFileValue> copy = new HashMap<String, DataFileValue>(datafileManager.getDatafileSizes());\r\n                if (!copy.keySet().containsAll(smallestFiles))\r\n                    throw new IllegalStateException(\"Cannot find data file values for \" + smallestFiles);\r\n                copy.keySet().retainAll(smallestFiles);\r\n                log.debug(\"Starting MajC \" + extent + \" (\" + reason + \") \" + datafileManager.abs2rel(datafileManager.string2path(copy.keySet())) + \" --> \" + datafileManager.abs2rel(new Path(compactTmpName)));\r\n                Compactor compactor = new                 Compactor(                conf,                 fs,                 copy,                 null,                 compactTmpName,                 filesToCompact.size() == 0 ? propogateDeletes : true,                 acuTableConf, extent, cenv);\r\n                CompactionStats mcs = compactor.call();\r\n                span.data(\"files\", \"\" + smallestFiles.size());\r\n                span.data(\"read\", \"\" + mcs.getEntriesRead());\r\n                span.data(\"written\", \"\" + mcs.getEntriesWritten());\r\n                majCStats.add(mcs);\r\n                datafileManager.bringMajorCompactionOnline(smallestFiles, compactTmpName, fileName, filesToCompact.size() == 0 ? compactionId : null, new DataFileValue(mcs.getFileSize(), mcs.getEntriesWritten()));\r\n                                if (filesToCompact.size() > 0 && mcs.getEntriesWritten() > 0) {\r\n                    filesToCompact.put(fileName, mcs.getFileSize());\r\n                }\r\n            } finally {\r\n                span.stop();\r\n            }\r\n        }\r\n        return majCStats;\r\n    } finally {\r\n        synchronized (Tablet.this) {\r\n            datafileManager.clearMajorCompactingFile();\r\n        }\r\n    }\r\n}","lc":3.5454545455,"pi":1.1483253589,"ma":2.0,"nbd":1.0,"ml":1.6666666667,"d":1.8908730159,"mi":-1.3089499648,"fo":4.25,"r":-0.0263157895,"e":11.5942785683}
{"project_name":"Math","project_version":"40","label":3,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected double doSolve() {\r\n    \/\/ prepare arrays with the first points\r\n    final double[] x = new double[maximalOrder + 1];\r\n    final double[] y = new double[maximalOrder + 1];\r\n    x[0] = getMin();\r\n    x[1] = getStartValue();\r\n    x[2] = getMax();\r\n    verifySequence(x[0], x[1], x[2]);\r\n    \/\/ evaluate initial guess\r\n    y[1] = computeObjectiveValue(x[1]);\r\n    if (Precision.equals(y[1], 0.0, 1)) {\r\n        \/\/ return the initial guess if it is a perfect root.\r\n        return x[1];\r\n    }\r\n    \/\/ evaluate first  endpoint\r\n    y[0] = computeObjectiveValue(x[0]);\r\n    if (Precision.equals(y[0], 0.0, 1)) {\r\n        \/\/ return the first endpoint if it is a perfect root.\r\n        return x[0];\r\n    }\r\n    int nbPoints;\r\n    int signChangeIndex;\r\n    if (y[0] * y[1] < 0) {\r\n        \/\/ reduce interval if it brackets the root\r\n        nbPoints = 2;\r\n        signChangeIndex = 1;\r\n    } else {\r\n        \/\/ evaluate second endpoint\r\n        y[2] = computeObjectiveValue(x[2]);\r\n        if (Precision.equals(y[2], 0.0, 1)) {\r\n            \/\/ return the second endpoint if it is a perfect root.\r\n            return x[2];\r\n        }\r\n        if (y[1] * y[2] < 0) {\r\n            \/\/ use all computed point as a start sampling array for solving\r\n            nbPoints = 3;\r\n            signChangeIndex = 2;\r\n        } else {\r\n            throw new NoBracketingException(x[0], x[2], y[0], y[2]);\r\n        }\r\n    }\r\n    \/\/ prepare a work array for inverse polynomial interpolation\r\n    final double[] tmpX = new double[x.length];\r\n    \/\/ current tightest bracketing of the root\r\n    double xA = x[signChangeIndex - 1];\r\n    double yA = y[signChangeIndex - 1];\r\n    double absYA = FastMath.abs(yA);\r\n    int agingA = 0;\r\n    double xB = x[signChangeIndex];\r\n    double yB = y[signChangeIndex];\r\n    double absYB = FastMath.abs(yB);\r\n    int agingB = 0;\r\n    \/\/ search loop\r\n    while (true) {\r\n        \/\/ check convergence of bracketing interval\r\n        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\r\n        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\r\n            switch(allowed) {\r\n                case ANY_SIDE:\r\n                    return absYA < absYB ? xA : xB;\r\n                case LEFT_SIDE:\r\n                    return xA;\r\n                case RIGHT_SIDE:\r\n                    return xB;\r\n                case BELOW_SIDE:\r\n                    return (yA <= 0) ? xA : xB;\r\n                case ABOVE_SIDE:\r\n                    return (yA < 0) ? xB : xA;\r\n                default:\r\n                    \/\/ this should never happen\r\n                    throw new MathInternalError(null);\r\n            }\r\n        }\r\n        \/\/ target for the next evaluation point\r\n        double targetY;\r\n        if (agingA >= MAXIMAL_AGING) {\r\n            \/\/ we keep updating the high bracket, try to compensate this\r\n            targetY = -REDUCTION_FACTOR * yB;\r\n        } else if (agingB >= MAXIMAL_AGING) {\r\n            \/\/ we keep updating the low bracket, try to compensate this\r\n            targetY = -REDUCTION_FACTOR * yA;\r\n        } else {\r\n            \/\/ bracketing is balanced, try to find the root itself\r\n            targetY = 0;\r\n        }\r\n        \/\/ make a few attempts to guess a root,\r\n        double nextX;\r\n        int start = 0;\r\n        int end = nbPoints;\r\n        do {\r\n            \/\/ guess a value for current target, using inverse polynomial interpolation\r\n            System.arraycopy(x, start, tmpX, start, end - start);\r\n            nextX = guessX(targetY, tmpX, y, start, end);\r\n            if (!((nextX > xA) && (nextX < xB))) {\r\n                \/\/ we try again with a lower interpolation order\r\n                if (signChangeIndex - start >= end - signChangeIndex) {\r\n                    \/\/ we have more points before the sign change, drop the lowest point\r\n                    ++start;\r\n                } else {\r\n                    \/\/ we have more points after sign change, drop the highest point\r\n                    --end;\r\n                }\r\n                \/\/ we need to do one more attempt\r\n                nextX = Double.NaN;\r\n            }\r\n        } while (Double.isNaN(nextX) && (end - start > 1));\r\n        if (Double.isNaN(nextX)) {\r\n            \/\/ fall back to bisection\r\n            nextX = xA + 0.5 * (xB - xA);\r\n            start = signChangeIndex - 1;\r\n            end = signChangeIndex;\r\n        }\r\n        \/\/ evaluate the function at the guessed root\r\n        final double nextY = computeObjectiveValue(nextX);\r\n        if (Precision.equals(nextY, 0.0, 1)) {\r\n            \/\/ we don't need to bother about the allowed solutions setting\r\n            return nextX;\r\n        }\r\n        if ((nbPoints > 2) && (end - start != nbPoints)) {\r\n            \/\/ we have been forced to ignore some points to keep bracketing,\r\n            \/\/ they are probably too far from the root, drop them from now on\r\n            nbPoints = end - start;\r\n            System.arraycopy(x, start, x, 0, nbPoints);\r\n            System.arraycopy(y, start, y, 0, nbPoints);\r\n            signChangeIndex -= start;\r\n        } else if (nbPoints == x.length) {\r\n            \/\/ we have to drop one point in order to insert the new one\r\n            nbPoints--;\r\n            \/\/ keep the tightest bracketing interval as centered as possible\r\n            if (signChangeIndex >= (x.length + 1) \/ 2) {\r\n                \/\/ we drop the lowest point, we have to shift the arrays and the index\r\n                System.arraycopy(x, 1, x, 0, nbPoints);\r\n                System.arraycopy(y, 1, y, 0, nbPoints);\r\n                --signChangeIndex;\r\n            }\r\n        }\r\n        \/\/ insert the last computed point\r\n        \/\/ (by construction, we know it lies inside the tightest bracketing interval)\r\n        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\r\n        x[signChangeIndex] = nextX;\r\n        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\r\n        y[signChangeIndex] = nextY;\r\n        ++nbPoints;\r\n        \/\/ update the bracketing interval\r\n        if (nextY * yA <= 0) {\r\n            \/\/ the sign change occurs before the inserted point\r\n            xB = nextX;\r\n            yB = nextY;\r\n            absYB = FastMath.abs(yB);\r\n            ++agingA;\r\n            agingB = 0;\r\n        } else {\r\n            \/\/ the sign change occurs after the inserted point\r\n            xA = nextX;\r\n            yA = nextY;\r\n            absYA = FastMath.abs(yA);\r\n            agingA = 0;\r\n            ++agingB;\r\n            \/\/ update the sign change index\r\n            signChangeIndex++;\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected double doSolve() {\r\n        final double[] x = new double[maximalOrder + 1];\r\n    final double[] y = new double[maximalOrder + 1];\r\n    x[0] = getMin();\r\n    x[1] = getStartValue();\r\n    x[2] = getMax();\r\n    verifySequence(x[0], x[1], x[2]);\r\n        y[1] = computeObjectiveValue(x[1]);\r\n    if (Precision.equals(y[1], 0.0, 1)) {\r\n                return x[1];\r\n    }\r\n        y[0] = computeObjectiveValue(x[0]);\r\n    if (Precision.equals(y[0], 0.0, 1)) {\r\n                return x[0];\r\n    }\r\n    int nbPoints;\r\n    int signChangeIndex;\r\n    if (y[0] * y[1] < 0) {\r\n                nbPoints = 2;\r\n        signChangeIndex = 1;\r\n    } else {\r\n                y[2] = computeObjectiveValue(x[2]);\r\n        if (Precision.equals(y[2], 0.0, 1)) {\r\n                        return x[2];\r\n        }\r\n        if (y[1] * y[2] < 0) {\r\n                        nbPoints = 3;\r\n            signChangeIndex = 2;\r\n        } else {\r\n            throw new NoBracketingException(x[0], x[2], y[0], y[2]);\r\n        }\r\n    }\r\n        final double[] tmpX = new double[x.length];\r\n        double xA = x[signChangeIndex - 1];\r\n    double yA = y[signChangeIndex - 1];\r\n    double absYA = FastMath.abs(yA);\r\n    int agingA = 0;\r\n    double xB = x[signChangeIndex];\r\n    double yB = y[signChangeIndex];\r\n    double absYB = FastMath.abs(yB);\r\n    int agingB = 0;\r\n        while (true) {\r\n                final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\r\n        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\r\n            switch(allowed) {\r\n                case ANY_SIDE:\r\n                    return absYA < absYB ? xA : xB;\r\n                case LEFT_SIDE:\r\n                    return xA;\r\n                case RIGHT_SIDE:\r\n                    return xB;\r\n                case BELOW_SIDE:\r\n                    return (yA <= 0) ? xA : xB;\r\n                case ABOVE_SIDE:\r\n                    return (yA < 0) ? xB : xA;\r\n                default:\r\n                                        throw new MathInternalError(null);\r\n            }\r\n        }\r\n                double targetY;\r\n        if (agingA >= MAXIMAL_AGING) {\r\n                        targetY = -REDUCTION_FACTOR * yB;\r\n        } else if (agingB >= MAXIMAL_AGING) {\r\n                        targetY = -REDUCTION_FACTOR * yA;\r\n        } else {\r\n                        targetY = 0;\r\n        }\r\n                double nextX;\r\n        int start = 0;\r\n        int end = nbPoints;\r\n        do {\r\n                        System.arraycopy(x, start, tmpX, start, end - start);\r\n            nextX = guessX(targetY, tmpX, y, start, end);\r\n            if (!((nextX > xA) && (nextX < xB))) {\r\n                                if (signChangeIndex - start >= end - signChangeIndex) {\r\n                                        ++start;\r\n                } else {\r\n                                        --end;\r\n                }\r\n                                nextX = Double.NaN;\r\n            }\r\n        } while (Double.isNaN(nextX) && (end - start > 1));\r\n        if (Double.isNaN(nextX)) {\r\n                        nextX = xA + 0.5 * (xB - xA);\r\n            start = signChangeIndex - 1;\r\n            end = signChangeIndex;\r\n        }\r\n                final double nextY = computeObjectiveValue(nextX);\r\n        if (Precision.equals(nextY, 0.0, 1)) {\r\n                        return nextX;\r\n        }\r\n        if ((nbPoints > 2) && (end - start != nbPoints)) {\r\n                                    nbPoints = end - start;\r\n            System.arraycopy(x, start, x, 0, nbPoints);\r\n            System.arraycopy(y, start, y, 0, nbPoints);\r\n            signChangeIndex -= start;\r\n        } else if (nbPoints == x.length) {\r\n                        nbPoints--;\r\n                        if (signChangeIndex >= (x.length + 1) \/ 2) {\r\n                                System.arraycopy(x, 1, x, 0, nbPoints);\r\n                System.arraycopy(y, 1, y, 0, nbPoints);\r\n                --signChangeIndex;\r\n            }\r\n        }\r\n                        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\r\n        x[signChangeIndex] = nextX;\r\n        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\r\n        y[signChangeIndex] = nextY;\r\n        ++nbPoints;\r\n                if (nextY * yA <= 0) {\r\n                        xB = nextX;\r\n            yB = nextY;\r\n            absYB = FastMath.abs(yB);\r\n            ++agingA;\r\n            agingB = 0;\r\n        } else {\r\n                        xA = nextX;\r\n            yA = nextY;\r\n            absYA = FastMath.abs(yA);\r\n            agingA = 0;\r\n            ++agingB;\r\n                        signChangeIndex++;\r\n        }\r\n    }\r\n}","lc":5.0909090909,"pi":0.8468899522,"ma":5.2,"nbd":1.0,"ml":4.0,"d":8.4047619048,"mi":-1.5880197322,"fo":2.25,"r":-0.0263157895,"e":56.573348778}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3510_01f5a26f","label":1,"code":"\/**\r\n * Escapes the given string and appends it to the builder.\r\n * @param builder the builder\r\n * @param str the string\r\n *\/\r\nprivate void escape(StringBuilder builder, CharSequence str) {\r\n    final int len = str.length();\r\n    for (int i = 0; i < len; i++) {\r\n        char c = str.charAt(i);\r\n        if (c == '%') {\r\n            builder.append(\"%25\");\r\n        } else if (c == ';') {\r\n            builder.append(\"%3b\");\r\n        } else {\r\n            builder.append(c);\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n * Escapes the given string and appends it to the builder.\r\n * @param builder the builder\r\n * @param str the string\r\n *\/\r\n","code_no_comment":"private void escape(StringBuilder builder, CharSequence str) {\r\n    final int len = str.length();\r\n    for (int i = 0; i < len; i++) {\r\n        char c = str.charAt(i);\r\n        if (c == '%') {\r\n            builder.append(\"%25\");\r\n        } else if (c == ';') {\r\n            builder.append(\"%3b\");\r\n        } else {\r\n            builder.append(c);\r\n        }\r\n    }\r\n}","lc":-0.0454545455,"pi":0.4641148325,"ma":0.0,"nbd":0.5,"ml":0.0833333333,"d":0.3591269841,"mi":0.0303030303,"fo":-0.0833333333,"r":0.8947368421,"e":0.1178472018}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-326_ce185345","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic double getNorm() {\r\n    double sum = 0;\r\n    for (double a : data) {\r\n        sum += a * a;\r\n    }\r\n    return Math.sqrt(sum);\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public double getNorm() {\r\n    double sum = 0;\r\n    for (double a : data) {\r\n        sum += a * a;\r\n    }\r\n    return Math.sqrt(sum);\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.0674603175,"mi":0.4971106413,"fo":-0.4166666667,"r":2.5789473684,"e":-0.1269065196}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-1190_e29dc4f5","label":3,"code":"@Override\r\npublic String createWriter(ByteBuffer login, String tableName, WriterOptions opts) throws TException {\r\n    try {\r\n        BatchWriter writer = getWriter(login, tableName, opts);\r\n        UUID uuid = UUID.randomUUID();\r\n        writerCache.put(uuid, writer);\r\n        return uuid.toString();\r\n    } catch (Exception e) {\r\n        throw translateException(e);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String createWriter(ByteBuffer login, String tableName, WriterOptions opts) throws TException {\r\n    try {\r\n        BatchWriter writer = getWriter(login, tableName, opts);\r\n        UUID uuid = UUID.randomUUID();\r\n        writerCache.put(uuid, writer);\r\n        return uuid.toString();\r\n    } catch (Exception e) {\r\n        throw translateException(e);\r\n    }\r\n}","lc":-0.1363636364,"pi":0.1626794258,"ma":-0.2,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.1292459479,"fo":-0.0833333333,"r":0.1578947368,"e":-0.1627934049}
{"project_name":"logging-log4j2","project_version":"remotes\/origin\/bugs-dot-jar_LOG4J2-470_50340d0c","label":3,"code":"\/**\r\n * Set the Configuration to be used.\r\n * @param config The new Configuration.\r\n * @return The previous Configuration.\r\n *\/\r\nprivate synchronized Configuration setConfiguration(final Configuration config) {\r\n    if (config == null) {\r\n        throw new NullPointerException(\"No Configuration was provided\");\r\n    }\r\n    final Configuration prev = this.config;\r\n    config.addListener(this);\r\n    final Map<String, String> map = new HashMap<String, String>();\r\n    map.put(\"hostName\", NetUtils.getLocalHostname());\r\n    map.put(\"contextName\", name);\r\n    config.addComponent(Configuration.CONTEXT_PROPERTIES, map);\r\n    config.start();\r\n    this.config = config;\r\n    updateLoggers();\r\n    if (prev != null) {\r\n        prev.removeListener(this);\r\n        prev.stop();\r\n    }\r\n    \/\/ notify listeners\r\n    final PropertyChangeEvent evt = new PropertyChangeEvent(this, PROPERTY_CONFIG, prev, config);\r\n    for (final PropertyChangeListener listener : propertyChangeListeners) {\r\n        listener.propertyChange(evt);\r\n    }\r\n    return prev;\r\n}","code_comment":"\/**\r\n * Set the Configuration to be used.\r\n * @param config The new Configuration.\r\n * @return The previous Configuration.\r\n *\/\r\n","code_no_comment":"private synchronized Configuration setConfiguration(final Configuration config) {\r\n    if (config == null) {\r\n        throw new NullPointerException(\"No Configuration was provided\");\r\n    }\r\n    final Configuration prev = this.config;\r\n    config.addListener(this);\r\n    final Map<String, String> map = new HashMap<String, String>();\r\n    map.put(\"hostName\", NetUtils.getLocalHostname());\r\n    map.put(\"contextName\", name);\r\n    config.addComponent(Configuration.CONTEXT_PROPERTIES, map);\r\n    config.start();\r\n    this.config = config;\r\n    updateLoggers();\r\n    if (prev != null) {\r\n        prev.removeListener(this);\r\n        prev.stop();\r\n    }\r\n        final PropertyChangeEvent evt = new PropertyChangeEvent(this, PROPERTY_CONFIG, prev, config);\r\n    for (final PropertyChangeListener listener : propertyChangeListeners) {\r\n        listener.propertyChange(evt);\r\n    }\r\n    return prev;\r\n}","lc":0.4090909091,"pi":-0.4688995215,"ma":0.2,"nbd":-0.5,"ml":-0.0833333333,"d":0.0,"mi":-0.3381254405,"fo":0.3333333333,"r":-0.0263157895,"e":0.1206087954}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4760_2f1ece4b","label":1,"code":"\/**\r\n *  Removes javascript comments and whitespace from specified string.\r\n *\r\n *  @param original\r\n *             Source string\r\n *  @return String with removed comments and whitespace\r\n *\/\r\npublic String stripCommentsAndWhitespace(String original) {\r\n    \/\/ let's be optimistic\r\n    AppendingStringBuffer result = new AppendingStringBuffer(original.length() \/ 2);\r\n    int state = REGULAR_TEXT;\r\n    boolean wasNewLineInWhitespace = false;\r\n    for (int i = 0; i < original.length(); ++i) {\r\n        char c = original.charAt(i);\r\n        char next = (i < original.length() - 1) ? original.charAt(i + 1) : 0;\r\n        char prev = (i > 0) ? original.charAt(i - 1) : 0;\r\n        if (state == WHITE_SPACE) {\r\n            \/\/ WICKET 2060\r\n            if (c == '\\n' && !wasNewLineInWhitespace) {\r\n                result.append(\"\\n\");\r\n                wasNewLineInWhitespace = true;\r\n            }\r\n            if (Character.isWhitespace(next) == false) {\r\n                state = REGULAR_TEXT;\r\n            }\r\n            continue;\r\n        }\r\n        if (state == REGULAR_TEXT) {\r\n            if (c == '\/' && next == '\/' && prev != '\\\\') {\r\n                state = LINE_COMMENT;\r\n                continue;\r\n            } else if (c == '\/' && next == '*') {\r\n                state = MULTILINE_COMMENT;\r\n                ++i;\r\n                continue;\r\n            } else if (c == '\/') {\r\n                \/\/ This might be a divide operator, or it might be a regular expression.\r\n                \/\/ Work out if it's a regular expression by finding the previous non-whitespace\r\n                \/\/ char, which\r\n                \/\/ will be either '=' or '('. If it's not, it's just a divide operator.\r\n                int idx = result.length() - 1;\r\n                while (idx > 0) {\r\n                    char tmp = result.charAt(idx);\r\n                    if (Character.isWhitespace(tmp)) {\r\n                        idx--;\r\n                        continue;\r\n                    }\r\n                    if (tmp == '=' || tmp == '(' || tmp == '{' || tmp == ':' || tmp == ',' || tmp == '[' || tmp == ';' || tmp == '!') {\r\n                        state = REG_EXP;\r\n                        break;\r\n                    }\r\n                    break;\r\n                }\r\n            } else if (Character.isWhitespace(c) && Character.isWhitespace(next)) {\r\n                \/\/ WICKET-2060\r\n                if (c == '\\n' || next == '\\n') {\r\n                    c = '\\n';\r\n                    wasNewLineInWhitespace = true;\r\n                } else {\r\n                    c = ' ';\r\n                    wasNewLineInWhitespace = false;\r\n                }\r\n                \/\/ ignore all whitespace characters after this one\r\n                state = WHITE_SPACE;\r\n            } else if (c == '\\'') {\r\n                state = STRING_SINGLE_QUOTE;\r\n            } else if (c == '\"') {\r\n                state = STRING_DOUBLE_QUOTES;\r\n            }\r\n            result.append(c);\r\n            continue;\r\n        }\r\n        if (state == LINE_COMMENT) {\r\n            if (c == '\\n' || c == '\\r') {\r\n                state = REGULAR_TEXT;\r\n                continue;\r\n            }\r\n        }\r\n        if (state == MULTILINE_COMMENT) {\r\n            if (c == '*' && next == '\/') {\r\n                state = REGULAR_TEXT;\r\n                ++i;\r\n                continue;\r\n            }\r\n        }\r\n        if (state == STRING_SINGLE_QUOTE) {\r\n            \/\/ to leave a string expression we need even (or zero) number of backslashes\r\n            int count = getPrevCount(original, i, '\\\\');\r\n            if (c == '\\'' && count % 2 == 0) {\r\n                state = REGULAR_TEXT;\r\n            }\r\n            result.append(c);\r\n            continue;\r\n        }\r\n        if (state == STRING_DOUBLE_QUOTES) {\r\n            \/\/ to leave a string expression we need even (or zero) number of backslashes\r\n            int count = getPrevCount(original, i, '\\\\');\r\n            if (c == '\"' && count % 2 == 0) {\r\n                state = REGULAR_TEXT;\r\n            }\r\n            result.append(c);\r\n            continue;\r\n        }\r\n        if (state == REG_EXP) {\r\n            \/\/ to leave regular expression we need even (or zero) number of backslashes\r\n            int count = getPrevCount(original, i, '\\\\');\r\n            if (c == '\/' && count % 2 == 0) {\r\n                state = REGULAR_TEXT;\r\n            }\r\n            result.append(c);\r\n        }\r\n    }\r\n    return result.toString();\r\n}","code_comment":"\/**\r\n *  Removes javascript comments and whitespace from specified string.\r\n *\r\n *  @param original\r\n *             Source string\r\n *  @return String with removed comments and whitespace\r\n *\/\r\n","code_no_comment":"public String stripCommentsAndWhitespace(String original) {\r\n        AppendingStringBuffer result = new AppendingStringBuffer(original.length() \/ 2);\r\n    int state = REGULAR_TEXT;\r\n    boolean wasNewLineInWhitespace = false;\r\n    for (int i = 0; i < original.length(); ++i) {\r\n        char c = original.charAt(i);\r\n        char next = (i < original.length() - 1) ? original.charAt(i + 1) : 0;\r\n        char prev = (i > 0) ? original.charAt(i - 1) : 0;\r\n        if (state == WHITE_SPACE) {\r\n                        if (c == '\\n' && !wasNewLineInWhitespace) {\r\n                result.append(\"\\n\");\r\n                wasNewLineInWhitespace = true;\r\n            }\r\n            if (Character.isWhitespace(next) == false) {\r\n                state = REGULAR_TEXT;\r\n            }\r\n            continue;\r\n        }\r\n        if (state == REGULAR_TEXT) {\r\n            if (c == '\/' && next == '\/' && prev != '\\\\') {\r\n                state = LINE_COMMENT;\r\n                continue;\r\n            } else if (c == '\/' && next == '*') {\r\n                state = MULTILINE_COMMENT;\r\n                ++i;\r\n                continue;\r\n            } else if (c == '\/') {\r\n                                                                                int idx = result.length() - 1;\r\n                while (idx > 0) {\r\n                    char tmp = result.charAt(idx);\r\n                    if (Character.isWhitespace(tmp)) {\r\n                        idx--;\r\n                        continue;\r\n                    }\r\n                    if (tmp == '=' || tmp == '(' || tmp == '{' || tmp == ':' || tmp == ',' || tmp == '[' || tmp == ';' || tmp == '!') {\r\n                        state = REG_EXP;\r\n                        break;\r\n                    }\r\n                    break;\r\n                }\r\n            } else if (Character.isWhitespace(c) && Character.isWhitespace(next)) {\r\n                                if (c == '\\n' || next == '\\n') {\r\n                    c = '\\n';\r\n                    wasNewLineInWhitespace = true;\r\n                } else {\r\n                    c = ' ';\r\n                    wasNewLineInWhitespace = false;\r\n                }\r\n                                state = WHITE_SPACE;\r\n            } else if (c == '\\'') {\r\n                state = STRING_SINGLE_QUOTE;\r\n            } else if (c == '\"') {\r\n                state = STRING_DOUBLE_QUOTES;\r\n            }\r\n            result.append(c);\r\n            continue;\r\n        }\r\n        if (state == LINE_COMMENT) {\r\n            if (c == '\\n' || c == '\\r') {\r\n                state = REGULAR_TEXT;\r\n                continue;\r\n            }\r\n        }\r\n        if (state == MULTILINE_COMMENT) {\r\n            if (c == '*' && next == '\/') {\r\n                state = REGULAR_TEXT;\r\n                ++i;\r\n                continue;\r\n            }\r\n        }\r\n        if (state == STRING_SINGLE_QUOTE) {\r\n                        int count = getPrevCount(original, i, '\\\\');\r\n            if (c == '\\'' && count % 2 == 0) {\r\n                state = REGULAR_TEXT;\r\n            }\r\n            result.append(c);\r\n            continue;\r\n        }\r\n        if (state == STRING_DOUBLE_QUOTES) {\r\n                        int count = getPrevCount(original, i, '\\\\');\r\n            if (c == '\"' && count % 2 == 0) {\r\n                state = REGULAR_TEXT;\r\n            }\r\n            result.append(c);\r\n            continue;\r\n        }\r\n        if (state == REG_EXP) {\r\n                        int count = getPrevCount(original, i, '\\\\');\r\n            if (c == '\/' && count % 2 == 0) {\r\n                state = REGULAR_TEXT;\r\n            }\r\n            result.append(c);\r\n        }\r\n    }\r\n    return result.toString();\r\n}","lc":3.7272727273,"pi":1.0,"ma":7.0,"nbd":3.0,"ml":4.4166666667,"d":5.496031746,"mi":-1.4639887245,"fo":1.25,"r":-0.0263157895,"e":25.3318695504}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4932_f20b2d70","label":1,"code":"\/**\r\n *  Builds URL for the given {@link UrlInfo} instance. The URL this method produces must be\r\n *  parseable by the {@link #parseRequest(Request)} method.\r\n *\r\n *  @param info\r\n *  @return Url result URL\r\n *\/\r\nprotected abstract Url buildUrl(UrlInfo info);","code_comment":"\/**\r\n *  Builds URL for the given {@link UrlInfo} instance. The URL this method produces must be\r\n *  parseable by the {@link #parseRequest(Request)} method.\r\n *\r\n *  @param info\r\n *  @return Url result URL\r\n *\/\r\n","code_no_comment":"protected abstract Url buildUrl(UrlInfo info);","lc":-0.5909090909,"pi":-1.4306220096,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.6116983791,"fo":-0.5,"r":2.6052631579,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4259_1f128536","label":3,"code":"\/**\r\n *  {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected void onBeforeRender() {\r\n    super.onBeforeRender();\r\n    \/\/ lazily add label and editor\r\n    if (editor == null) {\r\n        initLabelAndEditor(getDelegatingParentModel());\r\n    }\r\n\/\/ obsolete with WICKET-1919\r\n\/\/ label.setEnabled(isEnabledInHierarchy());\r\n}","code_comment":"\/**\r\n *  {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void onBeforeRender() {\r\n    super.onBeforeRender();\r\n        if (editor == null) {\r\n        initLabelAndEditor(getDelegatingParentModel());\r\n    }\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.5929527837,"fo":-0.25,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2202_24ac1a35","label":1,"code":"\/**\r\n *  Find out whether there is any registered error for a form component.\r\n *\r\n *  @return whether there is any registered error for a form component\r\n *\/\r\nprivate boolean anyFormComponentError() {\r\n    final boolean[] error = new boolean[] { false };\r\n    final IVisitor<Component> visitor = new IVisitor<Component>() {\r\n\r\n        public Object component(final Component component) {\r\n            if (component.hasErrorMessage()) {\r\n                error[0] = true;\r\n                return Component.IVisitor.STOP_TRAVERSAL;\r\n            }\r\n            \/\/ Traverse all children\r\n            return Component.IVisitor.CONTINUE_TRAVERSAL;\r\n        }\r\n    };\r\n    visitChildren(FormComponent.class, new IVisitor<Component>() {\r\n\r\n        public Object component(final Component component) {\r\n            return visitor.component(component);\r\n        }\r\n    });\r\n    if (!error[0]) {\r\n        if (getParent() instanceof Border) {\r\n            MarkupContainer border = getParent();\r\n            Iterator<? extends Component> iter = border.iterator();\r\n            while (iter.hasNext()) {\r\n                Component child = iter.next();\r\n                if ((child != this) && (child instanceof FormComponent)) {\r\n                    visitor.component(child);\r\n                    if (error[0]) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error[0];\r\n}","code_comment":"\/**\r\n *  Find out whether there is any registered error for a form component.\r\n *\r\n *  @return whether there is any registered error for a form component\r\n *\/\r\n","code_no_comment":"private boolean anyFormComponentError() {\r\n    final boolean[] error = new boolean[] { false };\r\n    final IVisitor<Component> visitor = new IVisitor<Component>() {\r\n\r\n        public Object component(final Component component) {\r\n            if (component.hasErrorMessage()) {\r\n                error[0] = true;\r\n                return Component.IVisitor.STOP_TRAVERSAL;\r\n            }\r\n                        return Component.IVisitor.CONTINUE_TRAVERSAL;\r\n        }\r\n    };\r\n    visitChildren(FormComponent.class, new IVisitor<Component>() {\r\n\r\n        public Object component(final Component component) {\r\n            return visitor.component(component);\r\n        }\r\n    });\r\n    if (!error[0]) {\r\n        if (getParent() instanceof Border) {\r\n            MarkupContainer border = getParent();\r\n            Iterator<? extends Component> iter = border.iterator();\r\n            while (iter.hasNext()) {\r\n                Component child = iter.next();\r\n                if ((child != this) && (child instanceof FormComponent)) {\r\n                    visitor.component(child);\r\n                    if (error[0]) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error[0];\r\n}","lc":0.8636363636,"pi":1.4736842105,"ma":0.8,"nbd":1.5,"ml":0.5,"d":0.5972222222,"mi":-0.5309372798,"fo":0.25,"r":-0.0263157895,"e":0.6265567101}
{"project_name":"Codec","project_version":"6","label":1,"code":"\/**\r\n * Attempts to read <code>len<\/code> bytes into the specified <code>b<\/code> array starting at <code>offset<\/code>\r\n * from this InputStream.\r\n *\r\n * @param b\r\n *            destination byte array\r\n * @param offset\r\n *            where to start writing the bytes\r\n * @param len\r\n *            maximum number of bytes to read\r\n *\r\n * @return number of bytes read\r\n * @throws IOException\r\n *             if an I\/O error occurs.\r\n * @throws NullPointerException\r\n *             if the byte array parameter is null\r\n * @throws IndexOutOfBoundsException\r\n *             if offset, len or buffer size are invalid\r\n *\/\r\npublic int read(byte[] b, int offset, int len) throws IOException {\r\n    if (b == null) {\r\n        throw new NullPointerException();\r\n    } else if (offset < 0 || len < 0) {\r\n        throw new IndexOutOfBoundsException();\r\n    } else if (offset > b.length || offset + len > b.length) {\r\n        throw new IndexOutOfBoundsException();\r\n    } else if (len == 0) {\r\n        return 0;\r\n    } else {\r\n        \/*\r\n             Rationale for while-loop on (readLen == 0):\r\n             -----\r\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\r\n             rare case where it returns 0, we just keep trying.\r\n\r\n             This is essentially an undocumented contract for InputStream\r\n             implementors that want their code to work properly with\r\n             java.io.InputStreamReader, since the latter hates it when\r\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\r\n             readResults() call must return 0 if a large amount of the data\r\n             being decoded was non-base64, so this while-loop enables proper\r\n             interop with InputStreamReader for that scenario.\r\n             -----\r\n             This is a fix for CODEC-101\r\n            *\/\r\n        if (!base64.hasData()) {\r\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\r\n            int c = in.read(buf);\r\n            \/\/ when possible.\r\n            if (c > 0 && b.length == len) {\r\n                base64.setInitialBuffer(b, offset, len);\r\n            }\r\n            if (doEncode) {\r\n                base64.encode(buf, 0, c);\r\n            } else {\r\n                base64.decode(buf, 0, c);\r\n            }\r\n        }\r\n        return base64.readResults(b, offset, len);\r\n    }\r\n}","code_comment":"\/**\r\n * Attempts to read <code>len<\/code> bytes into the specified <code>b<\/code> array starting at <code>offset<\/code>\r\n * from this InputStream.\r\n *\r\n * @param b\r\n *            destination byte array\r\n * @param offset\r\n *            where to start writing the bytes\r\n * @param len\r\n *            maximum number of bytes to read\r\n *\r\n * @return number of bytes read\r\n * @throws IOException\r\n *             if an I\/O error occurs.\r\n * @throws NullPointerException\r\n *             if the byte array parameter is null\r\n * @throws IndexOutOfBoundsException\r\n *             if offset, len or buffer size are invalid\r\n *\/\r\n","code_no_comment":"public int read(byte[] b, int offset, int len) throws IOException {\r\n    if (b == null) {\r\n        throw new NullPointerException();\r\n    } else if (offset < 0 || len < 0) {\r\n        throw new IndexOutOfBoundsException();\r\n    } else if (offset > b.length || offset + len > b.length) {\r\n        throw new IndexOutOfBoundsException();\r\n    } else if (len == 0) {\r\n        return 0;\r\n    } else {\r\n                if (!base64.hasData()) {\r\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\r\n            int c = in.read(buf);\r\n                        if (c > 0 && b.length == len) {\r\n                base64.setInitialBuffer(b, offset, len);\r\n            }\r\n            if (doEncode) {\r\n                base64.encode(buf, 0, c);\r\n            } else {\r\n                base64.decode(buf, 0, c);\r\n            }\r\n        }\r\n        return base64.readResults(b, offset, len);\r\n    }\r\n}","lc":0.5,"pi":0.7559808612,"ma":1.6,"nbd":2.0,"ml":1.0833333333,"d":1.7400793651,"mi":-0.4396053559,"fo":0.0,"r":-0.0263157895,"e":1.6787469096}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-3454_f1e854b3","label":1,"code":"\/**\r\n *  If the tag is of form <wicket:message>{foo}<\/wicket:message> then scan for any child\r\n *  wicket component and save their tag index\r\n *\r\n *  @param markupStream\r\n *  @param openTag\r\n *  @return map of child components\r\n *\/\r\nprivate Map<String, CharSequence> findAndRenderChildWicketTags(final MarkupStream markupStream, final ComponentTag openTag) {\r\n    Map<String, CharSequence> childTags = new HashMap<String, CharSequence>();\r\n    \/\/ get original tag from markup because we modified openTag to always be open\r\n    ComponentTag tag = markupStream.getPreviousTag();\r\n    \/\/ child component and save their tag index\r\n    if (!tag.isOpenClose()) {\r\n        while (markupStream.hasMore() && !markupStream.get().closes(openTag)) {\r\n            MarkupElement element = markupStream.get();\r\n            \/\/ If it a tag like <wicket..> or <span wicket:id=\"...\" >\r\n            if ((element instanceof ComponentTag) && !markupStream.atCloseTag()) {\r\n                String id = ((ComponentTag) element).getId();\r\n                \/\/ Temporarily replace the web response with a String response\r\n                final Response webResponse = getResponse();\r\n                try {\r\n                    final StringResponse response = new StringResponse();\r\n                    getRequestCycle().setResponse(response);\r\n                    Component component = getParent().get(id);\r\n                    if (component != null) {\r\n                        component.render();\r\n                        markupStream.skipComponent();\r\n                    } else {\r\n                        markupStream.next();\r\n                    }\r\n                    childTags.put(id, response.getBuffer());\r\n                } finally {\r\n                    \/\/ Restore the original response\r\n                    getRequestCycle().setResponse(webResponse);\r\n                }\r\n            } else {\r\n                markupStream.next();\r\n            }\r\n        }\r\n    }\r\n    return childTags;\r\n}","code_comment":"\/**\r\n *  If the tag is of form <wicket:message>{foo}<\/wicket:message> then scan for any child\r\n *  wicket component and save their tag index\r\n *\r\n *  @param markupStream\r\n *  @param openTag\r\n *  @return map of child components\r\n *\/\r\n","code_no_comment":"private Map<String, CharSequence> findAndRenderChildWicketTags(final MarkupStream markupStream, final ComponentTag openTag) {\r\n    Map<String, CharSequence> childTags = new HashMap<String, CharSequence>();\r\n        ComponentTag tag = markupStream.getPreviousTag();\r\n        if (!tag.isOpenClose()) {\r\n        while (markupStream.hasMore() && !markupStream.get().closes(openTag)) {\r\n            MarkupElement element = markupStream.get();\r\n                        if ((element instanceof ComponentTag) && !markupStream.atCloseTag()) {\r\n                String id = ((ComponentTag) element).getId();\r\n                                final Response webResponse = getResponse();\r\n                try {\r\n                    final StringResponse response = new StringResponse();\r\n                    getRequestCycle().setResponse(response);\r\n                    Component component = getParent().get(id);\r\n                    if (component != null) {\r\n                        component.render();\r\n                        markupStream.skipComponent();\r\n                    } else {\r\n                        markupStream.next();\r\n                    }\r\n                    childTags.put(id, response.getBuffer());\r\n                } finally {\r\n                                        getRequestCycle().setResponse(webResponse);\r\n                }\r\n            } else {\r\n                markupStream.next();\r\n            }\r\n        }\r\n    }\r\n    return childTags;\r\n}","lc":0.7272727273,"pi":2.0526315789,"ma":0.2,"nbd":1.5,"ml":0.6666666667,"d":0.4067460317,"mi":-0.5095137421,"fo":1.25,"r":-0.0263157895,"e":0.6795802286}
{"project_name":"Lang","project_version":"31","label":3,"code":"\/\/ ContainsAny\r\n\/\/ -----------------------------------------------------------------------\r\n\/**\r\n * <p>Checks if the CharSequence contains any character in the given\r\n * set of characters.<\/p>\r\n *\r\n * <p>A <code>null<\/code> CharSequence will return <code>false<\/code>.\r\n * A <code>null<\/code> or zero length search array will return <code>false<\/code>.<\/p>\r\n *\r\n * <pre>\r\n * StringUtils.containsAny(null, *)                = false\r\n * StringUtils.containsAny(\"\", *)                  = false\r\n * StringUtils.containsAny(*, null)                = false\r\n * StringUtils.containsAny(*, [])                  = false\r\n * StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true\r\n * StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true\r\n * StringUtils.containsAny(\"aba\", ['z'])           = false\r\n * <\/pre>\r\n *\r\n * @param cs  the CharSequence to check, may be null\r\n * @param searchChars  the chars to search for, may be null\r\n * @return the <code>true<\/code> if any of the chars are found,\r\n * <code>false<\/code> if no match or null input\r\n * @since 2.4\r\n *\/\r\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\r\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\r\n        return false;\r\n    }\r\n    int csLength = cs.length();\r\n    int searchLength = searchChars.length;\r\n    for (int i = 0; i < csLength; i++) {\r\n        char ch = cs.charAt(i);\r\n        for (int j = 0; j < searchLength; j++) {\r\n            if (searchChars[j] == ch) {\r\n                \/\/ ch is in the Basic Multilingual Plane\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}","code_comment":"\/**\r\n * <p>Checks if the CharSequence contains any character in the given\r\n * set of characters.<\/p>\r\n *\r\n * <p>A <code>null<\/code> CharSequence will return <code>false<\/code>.\r\n * A <code>null<\/code> or zero length search array will return <code>false<\/code>.<\/p>\r\n *\r\n * <pre>\r\n * StringUtils.containsAny(null, *)                = false\r\n * StringUtils.containsAny(\"\", *)                  = false\r\n * StringUtils.containsAny(*, null)                = false\r\n * StringUtils.containsAny(*, [])                  = false\r\n * StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true\r\n * StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true\r\n * StringUtils.containsAny(\"aba\", ['z'])           = false\r\n * <\/pre>\r\n *\r\n * @param cs  the CharSequence to check, may be null\r\n * @param searchChars  the chars to search for, may be null\r\n * @return the <code>true<\/code> if any of the chars are found,\r\n * <code>false<\/code> if no match or null input\r\n * @since 2.4\r\n *\/\r\n","code_no_comment":"public static boolean containsAny(CharSequence cs, char[] searchChars) {\r\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\r\n        return false;\r\n    }\r\n    int csLength = cs.length();\r\n    int searchLength = searchChars.length;\r\n    for (int i = 0; i < csLength; i++) {\r\n        char ch = cs.charAt(i);\r\n        for (int j = 0; j < searchLength; j++) {\r\n            if (searchChars[j] == ch) {\r\n                                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}","lc":0.0909090909,"pi":0.5980861244,"ma":0.2,"nbd":0.5,"ml":0.75,"d":0.4761904762,"mi":-0.1044397463,"fo":-0.1666666667,"r":0.0,"e":0.2464618523}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1761_f37ce716","label":0,"code":"@Override\r\npublic String serialize(Blob blob) {\r\n    if (blob instanceof BlobStoreBlob) {\r\n        return ((BlobStoreBlob) blob).getBlobId();\r\n    }\r\n    String id;\r\n    try {\r\n        id = createBlob(blob.getNewStream()).getBlobId();\r\n    } catch (IOException e) {\r\n        throw new IllegalStateException(e);\r\n    }\r\n    return id;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String serialize(Blob blob) {\r\n    if (blob instanceof BlobStoreBlob) {\r\n        return ((BlobStoreBlob) blob).getBlobId();\r\n    }\r\n    String id;\r\n    try {\r\n        id = createBlob(blob.getNewStream()).getBlobId();\r\n    } catch (IOException e) {\r\n        throw new IllegalStateException(e);\r\n    }\r\n    return id;\r\n}","lc":-0.0454545455,"pi":-0.1291866029,"ma":0.0,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.1148696265,"fo":-0.1666666667,"r":0.9736842105,"e":-0.1627934049}
{"project_name":"maven","project_version":"remotes\/origin\/bugs-dot-jar_MNG-2174_778f044e","label":1,"code":"private PomClassicDomainModel buildModel(File pom, List<Model> mixins, Collection<InterpolatorProperty> interpolatorProperties, Collection<String> activeProfileIds, PomArtifactResolver resolver) throws IOException {\r\n    if (pom == null) {\r\n        throw new IllegalArgumentException(\"pom: null\");\r\n    }\r\n    if (resolver == null) {\r\n        throw new IllegalArgumentException(\"resolver: null\");\r\n    }\r\n    if (mixins == null) {\r\n        mixins = new ArrayList<Model>();\r\n        mixins.add(getSuperModel());\r\n    } else {\r\n        mixins = new ArrayList<Model>(mixins);\r\n        Collections.reverse(mixins);\r\n    }\r\n    if (activeProfileIds == null) {\r\n        activeProfileIds = new ArrayList<String>();\r\n    }\r\n    List<InterpolatorProperty> properties;\r\n    if (interpolatorProperties == null) {\r\n        properties = new ArrayList<InterpolatorProperty>();\r\n    } else {\r\n        properties = new ArrayList<InterpolatorProperty>(interpolatorProperties);\r\n    }\r\n    PomClassicDomainModel domainModel = new PomClassicDomainModel(pom);\r\n    domainModel.setProjectDirectory(pom.getParentFile());\r\n    ProfileContext profileContext = new ProfileContext(new DefaultModelDataSource(domainModel.getModelProperties(), PomTransformer.MODEL_CONTAINER_FACTORIES), activeProfileIds, properties);\r\n    Collection<ModelContainer> profileContainers = profileContext.getActiveProfiles();\r\n    \/\/ get mixin\r\n    List<DomainModel> domainModels = new ArrayList<DomainModel>();\r\n    domainModels.add(domainModel);\r\n    File parentFile = null;\r\n    int lineageCount = 0;\r\n    if (domainModel.getModel().getParent() != null) {\r\n        List<DomainModel> mavenParents;\r\n        if (isParentLocal(domainModel.getModel().getParent(), pom.getParentFile())) {\r\n            mavenParents = getDomainModelParentsFromLocalPath(domainModel, resolver, pom.getParentFile(), properties, activeProfileIds);\r\n        } else {\r\n            mavenParents = getDomainModelParentsFromRepository(domainModel, resolver, properties, activeProfileIds);\r\n        }\r\n        if (mavenParents.size() > 0) {\r\n            PomClassicDomainModel dm = (PomClassicDomainModel) mavenParents.get(0);\r\n            parentFile = dm.getFile();\r\n            domainModel.setParentFile(parentFile);\r\n            lineageCount = mavenParents.size();\r\n        }\r\n        domainModels.addAll(mavenParents);\r\n    }\r\n    for (Model model : mixins) {\r\n        domainModels.add(new PomClassicDomainModel(model));\r\n    }\r\n    PomClassicTransformer transformer = new PomClassicTransformer(new PomClassicDomainModelFactory());\r\n    ModelTransformerContext ctx = new ModelTransformerContext(PomTransformer.MODEL_CONTAINER_INFOS);\r\n    PomClassicDomainModel transformedDomainModel = ((PomClassicDomainModel) ctx.transform(domainModels, transformer, transformer, Collections.EMPTY_LIST, properties, listeners));\r\n    \/\/ Lineage count is inclusive to add the POM read in itself.\r\n    transformedDomainModel.setLineageCount(lineageCount + 1);\r\n    transformedDomainModel.setParentFile(parentFile);\r\n    return transformedDomainModel;\r\n}","code_comment":null,"code_no_comment":"private PomClassicDomainModel buildModel(File pom, List<Model> mixins, Collection<InterpolatorProperty> interpolatorProperties, Collection<String> activeProfileIds, PomArtifactResolver resolver) throws IOException {\r\n    if (pom == null) {\r\n        throw new IllegalArgumentException(\"pom: null\");\r\n    }\r\n    if (resolver == null) {\r\n        throw new IllegalArgumentException(\"resolver: null\");\r\n    }\r\n    if (mixins == null) {\r\n        mixins = new ArrayList<Model>();\r\n        mixins.add(getSuperModel());\r\n    } else {\r\n        mixins = new ArrayList<Model>(mixins);\r\n        Collections.reverse(mixins);\r\n    }\r\n    if (activeProfileIds == null) {\r\n        activeProfileIds = new ArrayList<String>();\r\n    }\r\n    List<InterpolatorProperty> properties;\r\n    if (interpolatorProperties == null) {\r\n        properties = new ArrayList<InterpolatorProperty>();\r\n    } else {\r\n        properties = new ArrayList<InterpolatorProperty>(interpolatorProperties);\r\n    }\r\n    PomClassicDomainModel domainModel = new PomClassicDomainModel(pom);\r\n    domainModel.setProjectDirectory(pom.getParentFile());\r\n    ProfileContext profileContext = new ProfileContext(new DefaultModelDataSource(domainModel.getModelProperties(), PomTransformer.MODEL_CONTAINER_FACTORIES), activeProfileIds, properties);\r\n    Collection<ModelContainer> profileContainers = profileContext.getActiveProfiles();\r\n        List<DomainModel> domainModels = new ArrayList<DomainModel>();\r\n    domainModels.add(domainModel);\r\n    File parentFile = null;\r\n    int lineageCount = 0;\r\n    if (domainModel.getModel().getParent() != null) {\r\n        List<DomainModel> mavenParents;\r\n        if (isParentLocal(domainModel.getModel().getParent(), pom.getParentFile())) {\r\n            mavenParents = getDomainModelParentsFromLocalPath(domainModel, resolver, pom.getParentFile(), properties, activeProfileIds);\r\n        } else {\r\n            mavenParents = getDomainModelParentsFromRepository(domainModel, resolver, properties, activeProfileIds);\r\n        }\r\n        if (mavenParents.size() > 0) {\r\n            PomClassicDomainModel dm = (PomClassicDomainModel) mavenParents.get(0);\r\n            parentFile = dm.getFile();\r\n            domainModel.setParentFile(parentFile);\r\n            lineageCount = mavenParents.size();\r\n        }\r\n        domainModels.addAll(mavenParents);\r\n    }\r\n    for (Model model : mixins) {\r\n        domainModels.add(new PomClassicDomainModel(model));\r\n    }\r\n    PomClassicTransformer transformer = new PomClassicTransformer(new PomClassicDomainModelFactory());\r\n    ModelTransformerContext ctx = new ModelTransformerContext(PomTransformer.MODEL_CONTAINER_INFOS);\r\n    PomClassicDomainModel transformedDomainModel = ((PomClassicDomainModel) ctx.transform(domainModels, transformer, transformer, Collections.EMPTY_LIST, properties, listeners));\r\n        transformedDomainModel.setLineageCount(lineageCount + 1);\r\n    transformedDomainModel.setParentFile(parentFile);\r\n    return transformedDomainModel;\r\n}","lc":1.9090909091,"pi":-0.028708134,"ma":1.6,"nbd":0.0,"ml":1.0,"d":0.6686507937,"mi":-0.9850599013,"fo":1.75,"r":-0.0263157895,"e":2.8678549818}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4775_1ac05533","label":1,"code":"\/**\r\n *  Merges the page parameters into this, overwriting existing values\r\n *\r\n *  @param other\r\n *  @return this\r\n *\/\r\npublic PageParameters mergeWith(final PageParameters other) {\r\n    if (this != other) {\r\n        for (int index = 0; index < other.getIndexedCount(); index++) set(index, other.get(index));\r\n        for (NamedPair curNamed : other.getAllNamed()) set(curNamed.getKey(), curNamed.getValue());\r\n    }\r\n    return this;\r\n}","code_comment":"\/**\r\n *  Merges the page parameters into this, overwriting existing values\r\n *\r\n *  @param other\r\n *  @return this\r\n *\/\r\n","code_no_comment":"public PageParameters mergeWith(final PageParameters other) {\r\n    if (this != other) {\r\n        for (int index = 0; index < other.getIndexedCount(); index++) set(index, other.get(index));\r\n        for (NamedPair curNamed : other.getAllNamed()) set(curNamed.getKey(), curNamed.getValue());\r\n    }\r\n    return this;\r\n}","lc":-0.3181818182,"pi":0.014354067,"ma":0.0,"nbd":-0.5,"ml":0.0,"d":0.371031746,"mi":0.3550387597,"fo":0.0833333333,"r":0.6315789474,"e":0.0514260357}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-93_0be7e8f0","label":1,"code":"@Override\r\npublic void removeProperty(String name) {\r\n    builder.removeProperty(name);\r\n    if (listener != null) {\r\n        listener.removeProperty(this, name);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void removeProperty(String name) {\r\n    builder.removeProperty(name);\r\n    if (listener != null) {\r\n        listener.removeProperty(this, name);\r\n    }\r\n}","lc":-0.3181818182,"pi":-0.0909090909,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.5199436223,"fo":-0.3333333333,"r":0.6052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3324_5f863af6","label":1,"code":"\/\/ ------------------------------------------------------------< private >---\r\nprivate boolean internalIsGranted(@Nonnull Tree tree, @Nullable PropertyState property, long permissions) {\r\n    Iterator<PermissionEntry> it = getEntryIterator(tree, property, permissions);\r\n    return hasPermissions(it, permissions, tree.getPath());\r\n}","code_comment":null,"code_no_comment":"private boolean internalIsGranted(@Nonnull Tree tree, @Nullable PropertyState property, long permissions) {\r\n    Iterator<PermissionEntry> it = getEntryIterator(tree, property, permissions);\r\n    return hasPermissions(it, permissions, tree.getPath());\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.6817477097,"fo":-0.25,"r":1.7105263158,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3011_a402002d","label":0,"code":"public void restart() {\r\n    try {\r\n        if (state == JobStatus.FAILED) {\r\n            if (!transitionState(JobStatus.FAILED, JobStatus.RESTARTING)) {\r\n                throw new IllegalStateException(\"Execution Graph left the state FAILED while trying to restart.\");\r\n            }\r\n        }\r\n        synchronized (progressLock) {\r\n            if (state != JobStatus.RESTARTING) {\r\n                throw new IllegalStateException(\"Can only restart job from state restarting.\");\r\n            }\r\n            if (scheduler == null) {\r\n                throw new IllegalStateException(\"The execution graph has not been scheduled before - scheduler is null.\");\r\n            }\r\n            this.currentExecutions.clear();\r\n            for (ExecutionJobVertex jv : this.verticesInCreationOrder) {\r\n                jv.resetForNewExecution();\r\n            }\r\n            for (int i = 0; i < stateTimestamps.length; i++) {\r\n                stateTimestamps[i] = 0;\r\n            }\r\n            numFinishedJobVertices = 0;\r\n            transitionState(JobStatus.RESTARTING, JobStatus.CREATED);\r\n            \/\/ if we have checkpointed state, reload it into the executions\r\n            if (checkpointCoordinator != null) {\r\n                checkpointCoordinator.restoreLatestCheckpointedState(getAllVertices(), false, false);\r\n            }\r\n        }\r\n        scheduleForExecution(scheduler);\r\n    } catch (Throwable t) {\r\n        fail(t);\r\n    }\r\n}","code_comment":null,"code_no_comment":"public void restart() {\r\n    try {\r\n        if (state == JobStatus.FAILED) {\r\n            if (!transitionState(JobStatus.FAILED, JobStatus.RESTARTING)) {\r\n                throw new IllegalStateException(\"Execution Graph left the state FAILED while trying to restart.\");\r\n            }\r\n        }\r\n        synchronized (progressLock) {\r\n            if (state != JobStatus.RESTARTING) {\r\n                throw new IllegalStateException(\"Can only restart job from state restarting.\");\r\n            }\r\n            if (scheduler == null) {\r\n                throw new IllegalStateException(\"The execution graph has not been scheduled before - scheduler is null.\");\r\n            }\r\n            this.currentExecutions.clear();\r\n            for (ExecutionJobVertex jv : this.verticesInCreationOrder) {\r\n                jv.resetForNewExecution();\r\n            }\r\n            for (int i = 0; i < stateTimestamps.length; i++) {\r\n                stateTimestamps[i] = 0;\r\n            }\r\n            numFinishedJobVertices = 0;\r\n            transitionState(JobStatus.RESTARTING, JobStatus.CREATED);\r\n                        if (checkpointCoordinator != null) {\r\n                checkpointCoordinator.restoreLatestCheckpointedState(getAllVertices(), false, false);\r\n            }\r\n        }\r\n        scheduleForExecution(scheduler);\r\n    } catch (Throwable t) {\r\n        fail(t);\r\n    }\r\n}","lc":0.8181818182,"pi":0.6411483254,"ma":1.6,"nbd":0.5,"ml":0.5833333333,"d":0.6507936508,"mi":-0.5464411557,"fo":0.1666666667,"r":-0.0263157895,"e":0.6910553644}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2109_d594d024","label":1,"code":"\/**\r\n *  Marks task execution failed for an external reason (a reason other than th task code itself\r\n *  throwing an exception). If the task is already in a terminal state\r\n *  (such as FINISHED, CANCELED, FAILED), or if the task is already canceling this does nothing.\r\n *  Otherwise it sets the state to FAILED, and, if the invokable code is running,\r\n *  starts an asynchronous thread that aborts that code.\r\n *\r\n *  <p>This method never blocks.<\/p>\r\n *\/\r\npublic void failExternally(Throwable cause) {\r\n    LOG.info(\"Attempting to fail task externally \" + taskNameWithSubtask);\r\n    cancelOrFailAndCancelInvokable(ExecutionState.FAILED, cause);\r\n}","code_comment":"\/**\r\n *  Marks task execution failed for an external reason (a reason other than th task code itself\r\n *  throwing an exception). If the task is already in a terminal state\r\n *  (such as FINISHED, CANCELED, FAILED), or if the task is already canceling this does nothing.\r\n *  Otherwise it sets the state to FAILED, and, if the invokable code is running,\r\n *  starts an asynchronous thread that aborts that code.\r\n *\r\n *  <p>This method never blocks.<\/p>\r\n *\/\r\n","code_no_comment":"public void failExternally(Throwable cause) {\r\n    LOG.info(\"Attempting to fail task externally \" + taskNameWithSubtask);\r\n    cancelOrFailAndCancelInvokable(ExecutionState.FAILED, cause);\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7750528541,"fo":-0.3333333333,"r":0.9473684211,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-442_246d53c5","label":1,"code":"\/**\r\n *  Call this method when the current (ajax) request shouldn't merge\r\n *  the changes that are happening to the page with the previous version.\r\n *\r\n *  This is for example needed when you want to redirect to this\r\n *  page in an ajax request and then you do want to version normally..\r\n *\r\n *  This method doesn't do anything if the getRequest().mergeVersion\r\n *  doesn't return true.\r\n *\/\r\npublic final void ignoreVersionMerge() {\r\n    if (getRequest().mergeVersion()) {\r\n        mayTrackChangesFor(this, null);\r\n        if (versionManager != null) {\r\n            versionManager.ignoreVersionMerge();\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  Call this method when the current (ajax) request shouldn't merge\r\n *  the changes that are happening to the page with the previous version.\r\n *\r\n *  This is for example needed when you want to redirect to this\r\n *  page in an ajax request and then you do want to version normally..\r\n *\r\n *  This method doesn't do anything if the getRequest().mergeVersion\r\n *  doesn't return true.\r\n *\/\r\n","code_no_comment":"public final void ignoreVersionMerge() {\r\n    if (getRequest().mergeVersion()) {\r\n        mayTrackChangesFor(this, null);\r\n        if (versionManager != null) {\r\n            versionManager.ignoreVersionMerge();\r\n        }\r\n    }\r\n}","lc":-0.2727272727,"pi":0.4688995215,"ma":-0.2,"nbd":0.0,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.4959830867,"fo":-0.1666666667,"r":1.7894736842,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-695_7980a242","label":1,"code":"\/**\r\n * Accept a step, triggering events and step handlers.\r\n * @param interpolator step interpolator\r\n * @param y state vector at step end time, must be reset if an event\r\n * asks for resetting or if an events stops integration during the step\r\n * @param yDot placeholder array where to put the time derivative of the state vector\r\n * @param tEnd final integration time\r\n * @return time at end of step\r\n * @exception MathIllegalStateException if the value of one event state cannot be evaluated\r\n * @since 2.2\r\n *\/\r\nprotected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException {\r\n    double previousT = interpolator.getGlobalPreviousTime();\r\n    final double currentT = interpolator.getGlobalCurrentTime();\r\n    resetOccurred = false;\r\n    \/\/ initialize the events states if needed\r\n    if (!statesInitialized) {\r\n        for (EventState state : eventsStates) {\r\n            state.reinitializeBegin(interpolator);\r\n        }\r\n        statesInitialized = true;\r\n    }\r\n    \/\/ search for next events that may occur during the step\r\n    final int orderingSign = interpolator.isForward() ? +1 : -1;\r\n    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\r\n\r\n        \/**\r\n         * {@inheritDoc}\r\n         *\/\r\n        public int compare(EventState es0, EventState es1) {\r\n            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\r\n        }\r\n    });\r\n    for (final EventState state : eventsStates) {\r\n        if (state.evaluateStep(interpolator)) {\r\n            \/\/ the event occurs during the current step\r\n            occuringEvents.add(state);\r\n        }\r\n    }\r\n    while (!occuringEvents.isEmpty()) {\r\n        \/\/ handle the chronologically first event\r\n        final Iterator<EventState> iterator = occuringEvents.iterator();\r\n        final EventState currentEvent = iterator.next();\r\n        iterator.remove();\r\n        \/\/ restrict the interpolator to the first part of the step, up to the event\r\n        final double eventT = currentEvent.getEventTime();\r\n        interpolator.setSoftPreviousTime(previousT);\r\n        interpolator.setSoftCurrentTime(eventT);\r\n        \/\/ trigger the event\r\n        interpolator.setInterpolatedTime(eventT);\r\n        final double[] eventY = interpolator.getInterpolatedState();\r\n        currentEvent.stepAccepted(eventT, eventY);\r\n        isLastStep = currentEvent.stop();\r\n        \/\/ handle the first part of the step, up to the event\r\n        for (final StepHandler handler : stepHandlers) {\r\n            handler.handleStep(interpolator, isLastStep);\r\n        }\r\n        if (isLastStep) {\r\n            \/\/ the event asked to stop integration\r\n            System.arraycopy(eventY, 0, y, 0, y.length);\r\n            return eventT;\r\n        }\r\n        if (currentEvent.reset(eventT, eventY)) {\r\n            \/\/ some event handler has triggered changes that\r\n            \/\/ invalidate the derivatives, we need to recompute them\r\n            System.arraycopy(eventY, 0, y, 0, y.length);\r\n            computeDerivatives(eventT, y, yDot);\r\n            resetOccurred = true;\r\n            return eventT;\r\n        }\r\n        \/\/ prepare handling of the remaining part of the step\r\n        previousT = eventT;\r\n        interpolator.setSoftPreviousTime(eventT);\r\n        interpolator.setSoftCurrentTime(currentT);\r\n        \/\/ check if the same event occurs again in the remaining part of the step\r\n        if (currentEvent.evaluateStep(interpolator)) {\r\n            \/\/ the event occurs during the current step\r\n            occuringEvents.add(currentEvent);\r\n        }\r\n    }\r\n    interpolator.setInterpolatedTime(currentT);\r\n    final double[] currentY = interpolator.getInterpolatedState();\r\n    for (final EventState state : eventsStates) {\r\n        state.stepAccepted(currentT, currentY);\r\n        isLastStep = isLastStep || state.stop();\r\n    }\r\n    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\r\n    \/\/ handle the remaining part of the step, after all events if any\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.handleStep(interpolator, isLastStep);\r\n    }\r\n    return currentT;\r\n}","code_comment":"\/**\r\n * Accept a step, triggering events and step handlers.\r\n * @param interpolator step interpolator\r\n * @param y state vector at step end time, must be reset if an event\r\n * asks for resetting or if an events stops integration during the step\r\n * @param yDot placeholder array where to put the time derivative of the state vector\r\n * @param tEnd final integration time\r\n * @return time at end of step\r\n * @exception MathIllegalStateException if the value of one event state cannot be evaluated\r\n * @since 2.2\r\n *\/\r\n\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MathIllegalStateException {\r\n    double previousT = interpolator.getGlobalPreviousTime();\r\n    final double currentT = interpolator.getGlobalCurrentTime();\r\n    resetOccurred = false;\r\n        if (!statesInitialized) {\r\n        for (EventState state : eventsStates) {\r\n            state.reinitializeBegin(interpolator);\r\n        }\r\n        statesInitialized = true;\r\n    }\r\n        final int orderingSign = interpolator.isForward() ? +1 : -1;\r\n    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\r\n\r\n        \/**\r\n         * {@inheritDoc}\r\n         *\/\r\n        public int compare(EventState es0, EventState es1) {\r\n            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\r\n        }\r\n    });\r\n    for (final EventState state : eventsStates) {\r\n        if (state.evaluateStep(interpolator)) {\r\n                        occuringEvents.add(state);\r\n        }\r\n    }\r\n    while (!occuringEvents.isEmpty()) {\r\n                final Iterator<EventState> iterator = occuringEvents.iterator();\r\n        final EventState currentEvent = iterator.next();\r\n        iterator.remove();\r\n                final double eventT = currentEvent.getEventTime();\r\n        interpolator.setSoftPreviousTime(previousT);\r\n        interpolator.setSoftCurrentTime(eventT);\r\n                interpolator.setInterpolatedTime(eventT);\r\n        final double[] eventY = interpolator.getInterpolatedState();\r\n        currentEvent.stepAccepted(eventT, eventY);\r\n        isLastStep = currentEvent.stop();\r\n                for (final StepHandler handler : stepHandlers) {\r\n            handler.handleStep(interpolator, isLastStep);\r\n        }\r\n        if (isLastStep) {\r\n                        System.arraycopy(eventY, 0, y, 0, y.length);\r\n            return eventT;\r\n        }\r\n        if (currentEvent.reset(eventT, eventY)) {\r\n                                    System.arraycopy(eventY, 0, y, 0, y.length);\r\n            computeDerivatives(eventT, y, yDot);\r\n            resetOccurred = true;\r\n            return eventT;\r\n        }\r\n                previousT = eventT;\r\n        interpolator.setSoftPreviousTime(eventT);\r\n        interpolator.setSoftCurrentTime(currentT);\r\n                if (currentEvent.evaluateStep(interpolator)) {\r\n                        occuringEvents.add(currentEvent);\r\n        }\r\n    }\r\n    interpolator.setInterpolatedTime(currentT);\r\n    final double[] currentY = interpolator.getInterpolatedState();\r\n    for (final EventState state : eventsStates) {\r\n        state.stepAccepted(currentT, currentY);\r\n        isLastStep = isLastStep || state.stop();\r\n    }\r\n    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\r\n        for (StepHandler handler : stepHandlers) {\r\n        handler.handleStep(interpolator, isLastStep);\r\n    }\r\n    return currentT;\r\n}","lc":2.4090909091,"pi":-0.014354067,"ma":1.8,"nbd":0.0,"ml":1.0,"d":1.3154761905,"mi":-1.066807611,"fo":2.4166666667,"r":-0.0263157895,"e":4.5426669663}
{"project_name":"Closure","project_version":"158","label":2,"code":"private void processFlagFile(PrintStream err) throws CmdLineException, IOException {\r\n    List<String> argsInFile = Lists.newArrayList();\r\n    File flagFileInput = new File(flags.flag_file);\r\n    StringTokenizer tokenizer = new StringTokenizer(Files.toString(flagFileInput, Charset.defaultCharset()));\r\n    while (tokenizer.hasMoreTokens()) {\r\n        argsInFile.add(tokenizer.nextToken());\r\n    }\r\n    flags.flag_file = \"\";\r\n    List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {}));\r\n    CmdLineParser parserFileArgs = new CmdLineParser(flags);\r\n    parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {}));\r\n    \/\/ Currently we are not supporting this (prevent direct\/indirect loops)\r\n    if (!flags.flag_file.equals(\"\")) {\r\n        err.println(\"ERROR - Arguments in the file cannot contain \" + \"--flagfile option.\");\r\n        isConfigValid = false;\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void processFlagFile(PrintStream err) throws CmdLineException, IOException {\r\n    List<String> argsInFile = Lists.newArrayList();\r\n    File flagFileInput = new File(flags.flag_file);\r\n    StringTokenizer tokenizer = new StringTokenizer(Files.toString(flagFileInput, Charset.defaultCharset()));\r\n    while (tokenizer.hasMoreTokens()) {\r\n        argsInFile.add(tokenizer.nextToken());\r\n    }\r\n    flags.flag_file = \"\";\r\n    List<String> processedFileArgs = processArgs(argsInFile.toArray(new String[] {}));\r\n    CmdLineParser parserFileArgs = new CmdLineParser(flags);\r\n    parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {}));\r\n        if (!flags.flag_file.equals(\"\")) {\r\n        err.println(\"ERROR - Arguments in the file cannot contain \" + \"--flagfile option.\");\r\n        isConfigValid = false;\r\n    }\r\n}","lc":0.0909090909,"pi":-0.3684210526,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.0496031746,"mi":-0.1715292459,"fo":0.5,"r":0.0,"e":0.1032554762}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-434_133cbc2d","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\npublic RealPointValuePair doOptimize() throws OptimizationException {\r\n    final SimplexTableau tableau = new SimplexTableau(function, linearConstraints, goal, nonNegative, epsilon);\r\n    solvePhase1(tableau);\r\n    tableau.dropPhase1Objective();\r\n    while (!tableau.isOptimal()) {\r\n        doIteration(tableau);\r\n    }\r\n    return tableau.getSolution();\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\npublic RealPointValuePair doOptimize() throws OptimizationException {\r\n    final SimplexTableau tableau = new SimplexTableau(function, linearConstraints, goal, nonNegative, epsilon);\r\n    solvePhase1(tableau);\r\n    tableau.dropPhase1Objective();\r\n    while (!tableau.isOptimal()) {\r\n        doIteration(tableau);\r\n    }\r\n    return tableau.getSolution();\r\n}","lc":-0.1818181818,"pi":-0.2822966507,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0972222222,"mi":0.22931642,"fo":-0.0833333333,"r":0.2105263158,"e":-0.0965520421}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2174_5931a4a7","label":1,"code":"private void updateIndex(NodeState before, String beforeCheckpoint, NodeState after, String afterCheckpoint, String afterTime) throws CommitFailedException {\r\n    \/\/ start collecting runtime statistics\r\n    preAsyncRunStatsStats(indexStats);\r\n    \/\/ create an update callback for tracking index updates\r\n    \/\/ and maintaining the update lease\r\n    AsyncUpdateCallback callback = new AsyncUpdateCallback(beforeCheckpoint, afterCheckpoint);\r\n    try {\r\n        NodeBuilder builder = store.getRoot().builder();\r\n        IndexUpdate indexUpdate = new IndexUpdate(provider, name, after, builder, callback);\r\n        CommitFailedException exception = EditorDiff.process(VisibleEditor.wrap(indexUpdate), before, after);\r\n        if (exception != null) {\r\n            throw exception;\r\n        }\r\n        builder.child(ASYNC).setProperty(name, afterCheckpoint);\r\n        builder.child(ASYNC).setProperty(PropertyStates.createProperty(lastIndexedTo, afterTime, Type.DATE));\r\n        if (callback.isDirty() || before == MISSING_NODE) {\r\n            if (switchOnSync) {\r\n                reindexedDefinitions.addAll(indexUpdate.getReindexedDefinitions());\r\n            } else {\r\n                postAsyncRunStatsStatus(indexStats);\r\n            }\r\n        } else if (switchOnSync) {\r\n            log.debug(\"No changes detected after diff; will try to\" + \" switch to synchronous updates on {}\", reindexedDefinitions);\r\n            \/\/ no changes after diff, switch to sync on the async defs\r\n            for (String path : reindexedDefinitions) {\r\n                NodeBuilder c = builder;\r\n                for (String p : elements(path)) {\r\n                    c = c.getChildNode(p);\r\n                }\r\n                if (c.exists() && !c.getBoolean(REINDEX_PROPERTY_NAME)) {\r\n                    c.removeProperty(ASYNC_PROPERTY_NAME);\r\n                }\r\n            }\r\n            reindexedDefinitions.clear();\r\n        }\r\n        mergeWithConcurrencyCheck(builder, beforeCheckpoint, callback.lease);\r\n    } finally {\r\n        callback.close();\r\n    }\r\n    postAsyncRunStatsStatus(indexStats);\r\n}","code_comment":null,"code_no_comment":"private void updateIndex(NodeState before, String beforeCheckpoint, NodeState after, String afterCheckpoint, String afterTime) throws CommitFailedException {\r\n        preAsyncRunStatsStats(indexStats);\r\n            AsyncUpdateCallback callback = new AsyncUpdateCallback(beforeCheckpoint, afterCheckpoint);\r\n    try {\r\n        NodeBuilder builder = store.getRoot().builder();\r\n        IndexUpdate indexUpdate = new IndexUpdate(provider, name, after, builder, callback);\r\n        CommitFailedException exception = EditorDiff.process(VisibleEditor.wrap(indexUpdate), before, after);\r\n        if (exception != null) {\r\n            throw exception;\r\n        }\r\n        builder.child(ASYNC).setProperty(name, afterCheckpoint);\r\n        builder.child(ASYNC).setProperty(PropertyStates.createProperty(lastIndexedTo, afterTime, Type.DATE));\r\n        if (callback.isDirty() || before == MISSING_NODE) {\r\n            if (switchOnSync) {\r\n                reindexedDefinitions.addAll(indexUpdate.getReindexedDefinitions());\r\n            } else {\r\n                postAsyncRunStatsStatus(indexStats);\r\n            }\r\n        } else if (switchOnSync) {\r\n            log.debug(\"No changes detected after diff; will try to\" + \" switch to synchronous updates on {}\", reindexedDefinitions);\r\n                        for (String path : reindexedDefinitions) {\r\n                NodeBuilder c = builder;\r\n                for (String p : elements(path)) {\r\n                    c = c.getChildNode(p);\r\n                }\r\n                if (c.exists() && !c.getBoolean(REINDEX_PROPERTY_NAME)) {\r\n                    c.removeProperty(ASYNC_PROPERTY_NAME);\r\n                }\r\n            }\r\n            reindexedDefinitions.clear();\r\n        }\r\n        mergeWithConcurrencyCheck(builder, beforeCheckpoint, callback.lease);\r\n    } finally {\r\n        callback.close();\r\n    }\r\n    postAsyncRunStatsStatus(indexStats);\r\n}","lc":1.0454545455,"pi":0.990430622,"ma":1.0,"nbd":1.5,"ml":0.6666666667,"d":0.7182539683,"mi":-0.6997885835,"fo":1.5,"r":-0.0263157895,"e":1.7216737839}
{"project_name":"Cli","project_version":"1","label":1,"code":"\/**\r\n * Add an option to the command line.  The values of\r\n * the option are stored.\r\n *\r\n * @param opt the processed option\r\n *\/\r\nvoid addOption(Option opt) {\r\n    hashcodeMap.put(new Integer(opt.hashCode()), opt);\r\n    String key = opt.getKey();\r\n    if (key == null) {\r\n        key = opt.getLongOpt();\r\n    } else {\r\n        names.put(opt.getLongOpt(), key);\r\n    }\r\n    options.put(key, opt);\r\n}","code_comment":"\/**\r\n * Add an option to the command line.  The values of\r\n * the option are stored.\r\n *\r\n * @param opt the processed option\r\n *\/\r\n","code_no_comment":"void addOption(Option opt) {\r\n    hashcodeMap.put(new Integer(opt.hashCode()), opt);\r\n    String key = opt.getKey();\r\n    if (key == null) {\r\n        key = opt.getLongOpt();\r\n    } else {\r\n        names.put(opt.getLongOpt(), key);\r\n    }\r\n    options.put(key, opt);\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.005952381,"mi":0.2033826638,"fo":0.0833333333,"r":0.4210526316,"e":-0.0537450367}
{"project_name":"Lang","project_version":"18","label":1,"code":"\/\/ Parse the pattern\r\n\/\/ -----------------------------------------------------------------------\r\n\/**\r\n * <p>Returns a list of Rules given a pattern.<\/p>\r\n *\r\n * @return a {@code List} of Rule objects\r\n * @throws IllegalArgumentException if pattern is invalid\r\n *\/\r\nprotected List<Rule> parsePattern() {\r\n    DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\r\n    List<Rule> rules = new ArrayList<Rule>();\r\n    String[] ERAs = symbols.getEras();\r\n    String[] months = symbols.getMonths();\r\n    String[] shortMonths = symbols.getShortMonths();\r\n    String[] weekdays = symbols.getWeekdays();\r\n    String[] shortWeekdays = symbols.getShortWeekdays();\r\n    String[] AmPmStrings = symbols.getAmPmStrings();\r\n    int length = mPattern.length();\r\n    int[] indexRef = new int[1];\r\n    for (int i = 0; i < length; i++) {\r\n        indexRef[0] = i;\r\n        String token = parseToken(mPattern, indexRef);\r\n        i = indexRef[0];\r\n        int tokenLen = token.length();\r\n        if (tokenLen == 0) {\r\n            break;\r\n        }\r\n        Rule rule;\r\n        char c = token.charAt(0);\r\n        switch(c) {\r\n            case \/\/ era designator (text)\r\n            'G':\r\n                rule = new TextField(Calendar.ERA, ERAs);\r\n                break;\r\n            case \/\/ year (number)\r\n            'y':\r\n                if (tokenLen >= 4) {\r\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\r\n                } else {\r\n                    rule = TwoDigitYearField.INSTANCE;\r\n                }\r\n                break;\r\n            case \/\/ month in year (text and number)\r\n            'M':\r\n                if (tokenLen >= 4) {\r\n                    rule = new TextField(Calendar.MONTH, months);\r\n                } else if (tokenLen == 3) {\r\n                    rule = new TextField(Calendar.MONTH, shortMonths);\r\n                } else if (tokenLen == 2) {\r\n                    rule = TwoDigitMonthField.INSTANCE;\r\n                } else {\r\n                    rule = UnpaddedMonthField.INSTANCE;\r\n                }\r\n                break;\r\n            case \/\/ day in month (number)\r\n            'd':\r\n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\r\n                break;\r\n            case \/\/ hour in am\/pm (number, 1..12)\r\n            'h':\r\n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\r\n                break;\r\n            case \/\/ hour in day (number, 0..23)\r\n            'H':\r\n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\r\n                break;\r\n            case \/\/ minute in hour (number)\r\n            'm':\r\n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\r\n                break;\r\n            case \/\/ second in minute (number)\r\n            's':\r\n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\r\n                break;\r\n            case \/\/ millisecond (number)\r\n            'S':\r\n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\r\n                break;\r\n            case \/\/ day in week (text)\r\n            'E':\r\n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\r\n                break;\r\n            case \/\/ day in year (number)\r\n            'D':\r\n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\r\n                break;\r\n            case \/\/ day of week in month (number)\r\n            'F':\r\n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\r\n                break;\r\n            case \/\/ week in year (number)\r\n            'w':\r\n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\r\n                break;\r\n            case \/\/ week in month (number)\r\n            'W':\r\n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\r\n                break;\r\n            case \/\/ am\/pm marker (text)\r\n            'a':\r\n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\r\n                break;\r\n            case \/\/ hour in day (1..24)\r\n            'k':\r\n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\r\n                break;\r\n            case \/\/ hour in am\/pm (0..11)\r\n            'K':\r\n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\r\n                break;\r\n            case \/\/ time zone (text)\r\n            'z':\r\n                if (tokenLen >= 4) {\r\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\r\n                } else {\r\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\r\n                }\r\n                break;\r\n            case \/\/ time zone (value)\r\n            'Z':\r\n                if (tokenLen == 1) {\r\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\r\n                } else {\r\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\r\n                }\r\n                break;\r\n            case \/\/ literal text\r\n            '\\'':\r\n                String sub = token.substring(1);\r\n                if (sub.length() == 1) {\r\n                    rule = new CharacterLiteral(sub.charAt(0));\r\n                } else {\r\n                    rule = new StringLiteral(sub);\r\n                }\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\r\n        }\r\n        rules.add(rule);\r\n    }\r\n    return rules;\r\n}","code_comment":"\/**\r\n * <p>Returns a list of Rules given a pattern.<\/p>\r\n *\r\n * @return a {@code List} of Rule objects\r\n * @throws IllegalArgumentException if pattern is invalid\r\n *\/\r\n","code_no_comment":"protected List<Rule> parsePattern() {\r\n    DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\r\n    List<Rule> rules = new ArrayList<Rule>();\r\n    String[] ERAs = symbols.getEras();\r\n    String[] months = symbols.getMonths();\r\n    String[] shortMonths = symbols.getShortMonths();\r\n    String[] weekdays = symbols.getWeekdays();\r\n    String[] shortWeekdays = symbols.getShortWeekdays();\r\n    String[] AmPmStrings = symbols.getAmPmStrings();\r\n    int length = mPattern.length();\r\n    int[] indexRef = new int[1];\r\n    for (int i = 0; i < length; i++) {\r\n        indexRef[0] = i;\r\n        String token = parseToken(mPattern, indexRef);\r\n        i = indexRef[0];\r\n        int tokenLen = token.length();\r\n        if (tokenLen == 0) {\r\n            break;\r\n        }\r\n        Rule rule;\r\n        char c = token.charAt(0);\r\n        switch(c) {\r\n            case             'G':\r\n                rule = new TextField(Calendar.ERA, ERAs);\r\n                break;\r\n            case             'y':\r\n                if (tokenLen >= 4) {\r\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\r\n                } else {\r\n                    rule = TwoDigitYearField.INSTANCE;\r\n                }\r\n                break;\r\n            case             'M':\r\n                if (tokenLen >= 4) {\r\n                    rule = new TextField(Calendar.MONTH, months);\r\n                } else if (tokenLen == 3) {\r\n                    rule = new TextField(Calendar.MONTH, shortMonths);\r\n                } else if (tokenLen == 2) {\r\n                    rule = TwoDigitMonthField.INSTANCE;\r\n                } else {\r\n                    rule = UnpaddedMonthField.INSTANCE;\r\n                }\r\n                break;\r\n            case             'd':\r\n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\r\n                break;\r\n            case             'h':\r\n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\r\n                break;\r\n            case             'H':\r\n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\r\n                break;\r\n            case             'm':\r\n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\r\n                break;\r\n            case             's':\r\n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\r\n                break;\r\n            case             'S':\r\n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\r\n                break;\r\n            case             'E':\r\n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\r\n                break;\r\n            case             'D':\r\n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\r\n                break;\r\n            case             'F':\r\n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\r\n                break;\r\n            case             'w':\r\n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\r\n                break;\r\n            case             'W':\r\n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\r\n                break;\r\n            case             'a':\r\n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\r\n                break;\r\n            case             'k':\r\n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\r\n                break;\r\n            case             'K':\r\n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\r\n                break;\r\n            case             'z':\r\n                if (tokenLen >= 4) {\r\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\r\n                } else {\r\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\r\n                }\r\n                break;\r\n            case             'Z':\r\n                if (tokenLen == 1) {\r\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\r\n                } else {\r\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\r\n                }\r\n                break;\r\n            case             '\\'':\r\n                String sub = token.substring(1);\r\n                if (sub.length() == 1) {\r\n                    rule = new CharacterLiteral(sub.charAt(0));\r\n                } else {\r\n                    rule = new StringLiteral(sub);\r\n                }\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\r\n        }\r\n        rules.add(rule);\r\n    }\r\n    return rules;\r\n}","lc":5.4545454545,"pi":0.7511961722,"ma":10.0,"nbd":2.0,"ml":2.5,"d":1.1666666667,"mi":-1.725017618,"fo":1.75,"r":-0.0263157895,"e":7.0317986665}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-276_1bf5c550","label":1,"code":"public Id writeNode(Node node) throws Exception {\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    node.serialize(new BinaryBinding(out));\r\n    byte[] bytes = out.toByteArray();\r\n    byte[] rawId = idFactory.createContentId(bytes);\r\n    Timestamp ts = new Timestamp(System.currentTimeMillis());\r\n    \/\/ String id = StringUtils.convertBytesToHex(rawId);\r\n    Connection con = cp.getConnection();\r\n    try {\r\n        PreparedStatement stmt = con.prepareStatement(\"insert into REVS (ID, DATA, TIME) select ?, ?, ? where not exists (select 1 from REVS where ID = ?)\");\r\n        try {\r\n            stmt.setBytes(1, rawId);\r\n            stmt.setBytes(2, bytes);\r\n            stmt.setTimestamp(3, ts);\r\n            stmt.setBytes(4, rawId);\r\n            stmt.executeUpdate();\r\n        } finally {\r\n            stmt.close();\r\n        }\r\n    } finally {\r\n        con.close();\r\n    }\r\n    return new Id(rawId);\r\n}","code_comment":null,"code_no_comment":"public Id writeNode(Node node) throws Exception {\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    node.serialize(new BinaryBinding(out));\r\n    byte[] bytes = out.toByteArray();\r\n    byte[] rawId = idFactory.createContentId(bytes);\r\n    Timestamp ts = new Timestamp(System.currentTimeMillis());\r\n        Connection con = cp.getConnection();\r\n    try {\r\n        PreparedStatement stmt = con.prepareStatement(\"insert into REVS (ID, DATA, TIME) select ?, ?, ? where not exists (select 1 from REVS where ID = ?)\");\r\n        try {\r\n            stmt.setBytes(1, rawId);\r\n            stmt.setBytes(2, bytes);\r\n            stmt.setTimestamp(3, ts);\r\n            stmt.setBytes(4, rawId);\r\n            stmt.executeUpdate();\r\n        } finally {\r\n            stmt.close();\r\n        }\r\n    } finally {\r\n        con.close();\r\n    }\r\n    return new Id(rawId);\r\n}","lc":0.4090909091,"pi":0.4066985646,"ma":-0.6,"nbd":0.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":-0.3110641297,"fo":0.5833333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Compress","project_version":"4","label":1,"code":"\/**\r\n * Closes the underlying OutputStream.\r\n * @throws IOException on error\r\n *\/\r\npublic void close() throws IOException {\r\n    if (!closed) {\r\n        finish();\r\n        buffer.close();\r\n        out.close();\r\n        closed = true;\r\n    }\r\n}","code_comment":"\/**\r\n * Closes the underlying OutputStream.\r\n * @throws IOException on error\r\n *\/\r\n","code_no_comment":"public void close() throws IOException {\r\n    if (!closed) {\r\n        finish();\r\n        buffer.close();\r\n        out.close();\r\n        closed = true;\r\n    }\r\n}","lc":-0.2727272727,"pi":0.1578947368,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.0912698413,"mi":0.4630021142,"fo":-0.25,"r":2.5263157895,"e":-0.1354172069}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4932_f20b2d70","label":1,"code":"\/**\r\n *  Creates a {@code IRequestHandler} that processes a hybrid request. When the page identified\r\n *  by {@code pageInfo} was not available, the request should be treated as a bookmarkable\r\n *  request.\r\n *\r\n *  @param pageInfo\r\n *  @param pageClass\r\n *  @param pageParameters\r\n *  @param renderCount\r\n *  @return a {@code IRequestHandler} capable of processing the hybrid request.\r\n *\/\r\nprotected IRequestHandler processHybrid(PageInfo pageInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {\r\n    PageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters, renderCount);\r\n    provider.setPageSource(getContext());\r\n    return new RenderPageRequestHandler(provider);\r\n}","code_comment":"\/**\r\n *  Creates a {@code IRequestHandler} that processes a hybrid request. When the page identified\r\n *  by {@code pageInfo} was not available, the request should be treated as a bookmarkable\r\n *  request.\r\n *\r\n *  @param pageInfo\r\n *  @param pageClass\r\n *  @param pageParameters\r\n *  @param renderCount\r\n *  @return a {@code IRequestHandler} capable of processing the hybrid request.\r\n *\/\r\n","code_no_comment":"protected IRequestHandler processHybrid(PageInfo pageInfo, Class<? extends IRequestablePage> pageClass, PageParameters pageParameters, Integer renderCount) {\r\n    PageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters, renderCount);\r\n    provider.setPageSource(getContext());\r\n    return new RenderPageRequestHandler(provider);\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.5464411557,"fo":-0.25,"r":1.1315789474,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-428_4a6a573b","label":3,"code":"public Object next() {\r\n    \/\/ Find next key\r\n    i = nextKey(nextIndex(i));\r\n    \/\/ Just in case... (WICKET-428)\r\n    if (!hasNext()) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    \/\/ Get key\r\n    return keys[i];\r\n}","code_comment":null,"code_no_comment":"public Object next() {\r\n        i = nextKey(nextIndex(i));\r\n        if (!hasNext()) {\r\n        throw new NoSuchElementException();\r\n    }\r\n        return keys[i];\r\n}","lc":-0.3181818182,"pi":-0.2057416268,"ma":-0.2,"nbd":-0.5,"ml":-0.25,"d":-0.123015873,"mi":0.5114869626,"fo":-0.25,"r":2.5526315789,"e":-0.1374503668}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-43_668f08f2","label":1,"code":"public static StoredCommit deserialize(Id id, Binding binding) throws Exception {\r\n    Id rootNodeId = new Id(binding.readBytesValue(\"rootNodeId\"));\r\n    long commitTS = binding.readLongValue(\"commitTS\");\r\n    String msg = binding.readStringValue(\"msg\");\r\n    String parentId = binding.readStringValue(\"parentId\");\r\n    return new StoredCommit(id, \"\".equals(parentId) ? null : Id.fromString(parentId), commitTS, rootNodeId, \"\".equals(msg) ? null : msg);\r\n}","code_comment":null,"code_no_comment":"public static StoredCommit deserialize(Id id, Binding binding) throws Exception {\r\n    Id rootNodeId = new Id(binding.readBytesValue(\"rootNodeId\"));\r\n    long commitTS = binding.readLongValue(\"commitTS\");\r\n    String msg = binding.readStringValue(\"msg\");\r\n    String parentId = binding.readStringValue(\"parentId\");\r\n    return new StoredCommit(id, \"\".equals(parentId) ? null : Id.fromString(parentId), commitTS, rootNodeId, \"\".equals(msg) ? null : msg);\r\n}","lc":-0.3181818182,"pi":-0.5645933014,"ma":-0.2,"nbd":-1.0,"ml":0.0833333333,"d":-0.3650793651,"mi":0.2851303735,"fo":0.0833333333,"r":0.0,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2427_e6d4f9a6","label":1,"code":"@Override\r\npublic String toString() {\r\n    StringBuilder buff = new StringBuilder();\r\n    \/\/ explain | measure ...\r\n    if (explain) {\r\n        buff.append(\"explain \");\r\n    } else if (measure) {\r\n        buff.append(\"measure \");\r\n    }\r\n    \/\/ select ...\r\n    buff.append(\"select \");\r\n    buff.append(new Expression.Property(columnSelector, QueryImpl.JCR_PATH, false).toString());\r\n    if (selectors.size() > 1) {\r\n        buff.append(\" as \").append('[').append(QueryImpl.JCR_PATH).append(']');\r\n    }\r\n    buff.append(\", \");\r\n    buff.append(new Expression.Property(columnSelector, QueryImpl.JCR_SCORE, false).toString());\r\n    if (selectors.size() > 1) {\r\n        buff.append(\" as \").append('[').append(QueryImpl.JCR_SCORE).append(']');\r\n    }\r\n    if (columnList.isEmpty()) {\r\n        buff.append(\", \");\r\n        buff.append(new Expression.Property(columnSelector, \"*\", false).toString());\r\n    } else {\r\n        for (int i = 0; i < columnList.size(); i++) {\r\n            buff.append(\", \");\r\n            Expression e = columnList.get(i);\r\n            String columnName = e.toString();\r\n            buff.append(columnName);\r\n            if (selectors.size() > 1) {\r\n                buff.append(\" as [\").append(e.getColumnAliasName()).append(\"]\");\r\n            }\r\n        }\r\n    }\r\n    \/\/ from ...\r\n    buff.append(\" from \");\r\n    for (int i = 0; i < selectors.size(); i++) {\r\n        Selector s = selectors.get(i);\r\n        if (i > 0) {\r\n            buff.append(\" inner join \");\r\n        }\r\n        String nodeType = s.nodeType;\r\n        if (nodeType == null) {\r\n            nodeType = \"nt:base\";\r\n        }\r\n        buff.append('[' + nodeType + ']').append(\" as \").append(s.name);\r\n        if (s.joinCondition != null) {\r\n            buff.append(\" on \").append(s.joinCondition);\r\n        }\r\n    }\r\n    \/\/ where ...\r\n    if (where != null) {\r\n        buff.append(\" where \").append(where.toString());\r\n    }\r\n    \/\/ order by ...\r\n    if (!orderList.isEmpty()) {\r\n        buff.append(\" order by \");\r\n        for (int i = 0; i < orderList.size(); i++) {\r\n            if (i > 0) {\r\n                buff.append(\", \");\r\n            }\r\n            buff.append(orderList.get(i));\r\n        }\r\n    }\r\n    \/\/ leave original xpath string as a comment\r\n    if (xpathQuery != null) {\r\n        buff.append(\" \/* xpath: \");\r\n        \/\/ the xpath query may not contain the \"end comment\" marker\r\n        String xpathEscaped = xpathQuery.replaceAll(\"\\\\*\\\\\/\", \"* \/\");\r\n        buff.append(xpathEscaped);\r\n        buff.append(\" *\/\");\r\n    }\r\n    return buff.toString();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic String toString() {\r\n    StringBuilder buff = new StringBuilder();\r\n        if (explain) {\r\n        buff.append(\"explain \");\r\n    } else if (measure) {\r\n        buff.append(\"measure \");\r\n    }\r\n        buff.append(\"select \");\r\n    buff.append(new Expression.Property(columnSelector, QueryImpl.JCR_PATH, false).toString());\r\n    if (selectors.size() > 1) {\r\n        buff.append(\" as \").append('[').append(QueryImpl.JCR_PATH).append(']');\r\n    }\r\n    buff.append(\", \");\r\n    buff.append(new Expression.Property(columnSelector, QueryImpl.JCR_SCORE, false).toString());\r\n    if (selectors.size() > 1) {\r\n        buff.append(\" as \").append('[').append(QueryImpl.JCR_SCORE).append(']');\r\n    }\r\n    if (columnList.isEmpty()) {\r\n        buff.append(\", \");\r\n        buff.append(new Expression.Property(columnSelector, \"*\", false).toString());\r\n    } else {\r\n        for (int i = 0; i < columnList.size(); i++) {\r\n            buff.append(\", \");\r\n            Expression e = columnList.get(i);\r\n            String columnName = e.toString();\r\n            buff.append(columnName);\r\n            if (selectors.size() > 1) {\r\n                buff.append(\" as [\").append(e.getColumnAliasName()).append(\"]\");\r\n            }\r\n        }\r\n    }\r\n        buff.append(\" from \");\r\n    for (int i = 0; i < selectors.size(); i++) {\r\n        Selector s = selectors.get(i);\r\n        if (i > 0) {\r\n            buff.append(\" inner join \");\r\n        }\r\n        String nodeType = s.nodeType;\r\n        if (nodeType == null) {\r\n            nodeType = \"nt:base\";\r\n        }\r\n        buff.append('[' + nodeType + ']').append(\" as \").append(s.name);\r\n        if (s.joinCondition != null) {\r\n            buff.append(\" on \").append(s.joinCondition);\r\n        }\r\n    }\r\n        if (where != null) {\r\n        buff.append(\" where \").append(where.toString());\r\n    }\r\n        if (!orderList.isEmpty()) {\r\n        buff.append(\" order by \");\r\n        for (int i = 0; i < orderList.size(); i++) {\r\n            if (i > 0) {\r\n                buff.append(\", \");\r\n            }\r\n            buff.append(orderList.get(i));\r\n        }\r\n    }\r\n        if (xpathQuery != null) {\r\n        buff.append(\" \/* xpath: \");\r\n                String xpathEscaped = xpathQuery.replaceAll(\"\\\\*\\\\\/\", \"* \/\");\r\n        buff.append(xpathEscaped);\r\n        buff.append(\" *\/\");\r\n    }\r\n    return buff.toString();\r\n}","lc":2.4090909091,"pi":0.2822966507,"ma":2.6,"nbd":0.5,"ml":1.9166666667,"d":2.4761904762,"mi":-1.1136011276,"fo":4.0833333333,"r":-0.0263157895,"e":9.0189980579}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3530_4d231938","label":1,"code":"public int getType(Tree tree, int parentType) {\r\n    if (tree.isRoot()) {\r\n        return TYPE_DEFAULT;\r\n    }\r\n    int type;\r\n    switch(parentType) {\r\n        case TYPE_HIDDEN:\r\n            type = TYPE_HIDDEN;\r\n            break;\r\n        case TYPE_VERSION:\r\n            type = TYPE_VERSION;\r\n            break;\r\n        case TYPE_INTERNAL:\r\n            type = TYPE_INTERNAL;\r\n            break;\r\n        case TYPE_AC:\r\n            type = TYPE_AC;\r\n            break;\r\n        default:\r\n            String name = tree.getName();\r\n            if (NodeStateUtils.isHidden(name)) {\r\n                type = TYPE_HIDDEN;\r\n            } else if (VersionConstants.VERSION_STORE_ROOT_NAMES.contains(name)) {\r\n                type = TYPE_VERSION;\r\n            } else if (PermissionConstants.REP_PERMISSION_STORE.equals(name)) {\r\n                type = TYPE_INTERNAL;\r\n            } else if (contextInfo.definesContextRoot(tree)) {\r\n                type = TYPE_AC;\r\n            } else {\r\n                type = TYPE_DEFAULT;\r\n            }\r\n    }\r\n    return type;\r\n}","code_comment":null,"code_no_comment":"public int getType(Tree tree, int parentType) {\r\n    if (tree.isRoot()) {\r\n        return TYPE_DEFAULT;\r\n    }\r\n    int type;\r\n    switch(parentType) {\r\n        case TYPE_HIDDEN:\r\n            type = TYPE_HIDDEN;\r\n            break;\r\n        case TYPE_VERSION:\r\n            type = TYPE_VERSION;\r\n            break;\r\n        case TYPE_INTERNAL:\r\n            type = TYPE_INTERNAL;\r\n            break;\r\n        case TYPE_AC:\r\n            type = TYPE_AC;\r\n            break;\r\n        default:\r\n            String name = tree.getName();\r\n            if (NodeStateUtils.isHidden(name)) {\r\n                type = TYPE_HIDDEN;\r\n            } else if (VersionConstants.VERSION_STORE_ROOT_NAMES.contains(name)) {\r\n                type = TYPE_VERSION;\r\n            } else if (PermissionConstants.REP_PERMISSION_STORE.equals(name)) {\r\n                type = TYPE_INTERNAL;\r\n            } else if (contextInfo.definesContextRoot(tree)) {\r\n                type = TYPE_AC;\r\n            } else {\r\n                type = TYPE_DEFAULT;\r\n            }\r\n    }\r\n    return type;\r\n}","lc":0.9090909091,"pi":0.7081339713,"ma":2.2,"nbd":2.0,"ml":1.0,"d":-0.3650793651,"mi":-0.5594080338,"fo":0.0,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-949_f83bbc1d","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n@Override\r\nprotected PointValuePair doOptimize() {\r\n    checkParameters();\r\n    \/\/ Indirect call to \"computeObjectiveValue\" in order to update the\r\n    \/\/ evaluations counter.\r\n    final MultivariateFunction evalFunc = new MultivariateFunction() {\r\n\r\n        public double value(double[] point) {\r\n            return computeObjectiveValue(point);\r\n        }\r\n    };\r\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\r\n    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {\r\n\r\n        public int compare(final PointValuePair o1, final PointValuePair o2) {\r\n            final double v1 = o1.getValue();\r\n            final double v2 = o2.getValue();\r\n            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\r\n        }\r\n    };\r\n    \/\/ Initialize search.\r\n    simplex.build(getStartPoint());\r\n    simplex.evaluate(evalFunc, comparator);\r\n    PointValuePair[] previous = null;\r\n    int iteration = 0;\r\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\r\n    while (true) {\r\n        if (iteration > 0) {\r\n            boolean converged = true;\r\n            for (int i = 0; i < simplex.getSize(); i++) {\r\n                PointValuePair prev = previous[i];\r\n                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));\r\n            }\r\n            if (converged) {\r\n                \/\/ We have found an optimum.\r\n                return simplex.getPoint(0);\r\n            }\r\n        }\r\n        \/\/ We still need to search.\r\n        previous = simplex.getPoints();\r\n        simplex.iterate(evalFunc, comparator);\r\n        ++iteration;\r\n    }\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected PointValuePair doOptimize() {\r\n    checkParameters();\r\n            final MultivariateFunction evalFunc = new MultivariateFunction() {\r\n\r\n        public double value(double[] point) {\r\n            return computeObjectiveValue(point);\r\n        }\r\n    };\r\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\r\n    final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() {\r\n\r\n        public int compare(final PointValuePair o1, final PointValuePair o2) {\r\n            final double v1 = o1.getValue();\r\n            final double v2 = o2.getValue();\r\n            return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\r\n        }\r\n    };\r\n        simplex.build(getStartPoint());\r\n    simplex.evaluate(evalFunc, comparator);\r\n    PointValuePair[] previous = null;\r\n    int iteration = 0;\r\n    final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\r\n    while (true) {\r\n        if (iteration > 0) {\r\n            boolean converged = true;\r\n            for (int i = 0; i < simplex.getSize(); i++) {\r\n                PointValuePair prev = previous[i];\r\n                converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));\r\n            }\r\n            if (converged) {\r\n                                return simplex.getPoint(0);\r\n            }\r\n        }\r\n                previous = simplex.getPoints();\r\n        simplex.iterate(evalFunc, comparator);\r\n        ++iteration;\r\n    }\r\n}","lc":1.0454545455,"pi":0.6937799043,"ma":0.4,"nbd":0.5,"ml":0.4166666667,"d":0.9523809524,"mi":-0.6541226216,"fo":0.9166666667,"r":-0.0263157895,"e":1.7528996156}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-320_c06cc933","label":1,"code":"\/**\r\n * {@inheritDoc}\r\n *\/\r\npublic DecompositionSolver getSolver() {\r\n    return new Solver(singularValues, getUT(), getV(), getRank() == singularValues.length);\r\n}","code_comment":"\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"public DecompositionSolver getSolver() {\r\n    return new Solver(singularValues, getUT(), getV(), getRank() == singularValues.length);\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.9419309373,"fo":-0.25,"r":2.5263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7767_eab06182","label":1,"code":"\/**\r\n * Extracts the value for logging purpose.\r\n * <p\/>\r\n * Will clip the value if its too big for logging.\r\n *\r\n * @see org.apache.camel.Exchange#LOG_DEBUG_BODY_MAX_CHARS\r\n * @param obj     the value\r\n * @param message the message\r\n * @param prepend a message to prepend\r\n * @param allowStreams whether or not streams is allowed\r\n * @param allowFiles whether or not files is allowed (currently not in use)\r\n * @param maxChars limit to maximum number of chars. Use 0 for not limit, and -1 for turning logging message body off.\r\n * @return the logging message\r\n *\/\r\npublic static String extractValueForLogging(Object obj, Message message, String prepend, boolean allowStreams, boolean allowFiles, int maxChars) {\r\n    if (maxChars < 0) {\r\n        return prepend + \"[Body is not logged]\";\r\n    }\r\n    if (obj == null) {\r\n        return prepend + \"[Body is null]\";\r\n    }\r\n    if (!allowStreams) {\r\n        if (obj instanceof Source && !(obj instanceof StringSource || obj instanceof BytesSource)) {\r\n            \/\/ all other kinds we should not touch the body\r\n            return prepend + \"[Body is instance of java.xml.transform.Source]\";\r\n        } else if (obj instanceof StreamCache) {\r\n            return prepend + \"[Body is instance of org.apache.camel.StreamCache]\";\r\n        } else if (obj instanceof InputStream) {\r\n            return prepend + \"[Body is instance of java.io.InputStream]\";\r\n        } else if (obj instanceof OutputStream) {\r\n            return prepend + \"[Body is instance of java.io.OutputStream]\";\r\n        } else if (obj instanceof Reader) {\r\n            return prepend + \"[Body is instance of java.io.Reader]\";\r\n        } else if (obj instanceof Writer) {\r\n            return prepend + \"[Body is instance of java.io.Writer]\";\r\n        } else if (obj instanceof WrappedFile || obj instanceof File) {\r\n            if (!allowFiles) {\r\n                return prepend + \"[Body is file based: \" + obj + \"]\";\r\n            }\r\n        }\r\n    }\r\n    if (!allowFiles) {\r\n        if (obj instanceof WrappedFile || obj instanceof File) {\r\n            return prepend + \"[Body is file based: \" + obj + \"]\";\r\n        }\r\n    }\r\n    \/\/ is the body a stream cache\r\n    StreamCache cache;\r\n    if (obj instanceof StreamCache) {\r\n        cache = (StreamCache) obj;\r\n    } else {\r\n        cache = null;\r\n    }\r\n    \/\/ grab the message body as a string\r\n    String body = null;\r\n    if (message.getExchange() != null) {\r\n        try {\r\n            body = message.getExchange().getContext().getTypeConverter().convertTo(String.class, message.getExchange(), obj);\r\n        } catch (Exception e) {\r\n        \/\/ ignore as the body is for logging purpose\r\n        }\r\n    }\r\n    if (body == null) {\r\n        body = obj.toString();\r\n    }\r\n    \/\/ reset stream cache after use\r\n    if (cache != null) {\r\n        cache.reset();\r\n    }\r\n    if (body == null) {\r\n        return prepend + \"[Body is null]\";\r\n    }\r\n    \/\/ clip body if length enabled and the body is too big\r\n    if (maxChars > 0 && body.length() > maxChars) {\r\n        body = body.substring(0, maxChars) + \"... [Body clipped after \" + maxChars + \" chars, total length is \" + body.length() + \"]\";\r\n    }\r\n    return prepend + body;\r\n}","code_comment":"\/**\r\n * Extracts the value for logging purpose.\r\n * <p\/>\r\n * Will clip the value if its too big for logging.\r\n *\r\n * @see org.apache.camel.Exchange#LOG_DEBUG_BODY_MAX_CHARS\r\n * @param obj     the value\r\n * @param message the message\r\n * @param prepend a message to prepend\r\n * @param allowStreams whether or not streams is allowed\r\n * @param allowFiles whether or not files is allowed (currently not in use)\r\n * @param maxChars limit to maximum number of chars. Use 0 for not limit, and -1 for turning logging message body off.\r\n * @return the logging message\r\n *\/\r\n","code_no_comment":"public static String extractValueForLogging(Object obj, Message message, String prepend, boolean allowStreams, boolean allowFiles, int maxChars) {\r\n    if (maxChars < 0) {\r\n        return prepend + \"[Body is not logged]\";\r\n    }\r\n    if (obj == null) {\r\n        return prepend + \"[Body is null]\";\r\n    }\r\n    if (!allowStreams) {\r\n        if (obj instanceof Source && !(obj instanceof StringSource || obj instanceof BytesSource)) {\r\n                        return prepend + \"[Body is instance of java.xml.transform.Source]\";\r\n        } else if (obj instanceof StreamCache) {\r\n            return prepend + \"[Body is instance of org.apache.camel.StreamCache]\";\r\n        } else if (obj instanceof InputStream) {\r\n            return prepend + \"[Body is instance of java.io.InputStream]\";\r\n        } else if (obj instanceof OutputStream) {\r\n            return prepend + \"[Body is instance of java.io.OutputStream]\";\r\n        } else if (obj instanceof Reader) {\r\n            return prepend + \"[Body is instance of java.io.Reader]\";\r\n        } else if (obj instanceof Writer) {\r\n            return prepend + \"[Body is instance of java.io.Writer]\";\r\n        } else if (obj instanceof WrappedFile || obj instanceof File) {\r\n            if (!allowFiles) {\r\n                return prepend + \"[Body is file based: \" + obj + \"]\";\r\n            }\r\n        }\r\n    }\r\n    if (!allowFiles) {\r\n        if (obj instanceof WrappedFile || obj instanceof File) {\r\n            return prepend + \"[Body is file based: \" + obj + \"]\";\r\n        }\r\n    }\r\n        StreamCache cache;\r\n    if (obj instanceof StreamCache) {\r\n        cache = (StreamCache) obj;\r\n    } else {\r\n        cache = null;\r\n    }\r\n        String body = null;\r\n    if (message.getExchange() != null) {\r\n        try {\r\n            body = message.getExchange().getContext().getTypeConverter().convertTo(String.class, message.getExchange(), obj);\r\n        } catch (Exception e) {\r\n                }\r\n    }\r\n    if (body == null) {\r\n        body = obj.toString();\r\n    }\r\n        if (cache != null) {\r\n        cache.reset();\r\n    }\r\n    if (body == null) {\r\n        return prepend + \"[Body is null]\";\r\n    }\r\n        if (maxChars > 0 && body.length() > maxChars) {\r\n        body = body.substring(0, maxChars) + \"... [Body clipped after \" + maxChars + \" chars, total length is \" + body.length() + \"]\";\r\n    }\r\n    return prepend + body;\r\n}","lc":2.0,"pi":0.1913875598,"ma":3.4,"nbd":3.5,"ml":2.25,"d":1.746031746,"mi":-1.015503876,"fo":0.4166666667,"r":-0.0263157895,"e":4.4229456614}
{"project_name":"Closure","project_version":"163","label":1,"code":"@Override\r\npublic void enterScope(NodeTraversal t) {\r\n    symbolStack.peek().scope = t.getScope();\r\n\/\/ NOTE(nicksantos): We use the same anonymous node for all\r\n\/\/ functions that do not have reasonable names. I can't remember\r\n\/\/ at the moment why we do this. I think it's because anonymous\r\n\/\/ nodes can never have in-edges. They're just there as a placeholder\r\n\/\/ for scope information, and do not matter in the edge propagation.\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void enterScope(NodeTraversal t) {\r\n    symbolStack.peek().scope = t.getScope();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8105708245,"fo":-0.3333333333,"r":0.7105263158,"e":-0.1627934049}
{"project_name":"Closure","project_version":"142","label":2,"code":"@Override\r\npublic void enterScope(NodeTraversal t) {\r\n    \/\/ TODO(user): We CAN do this in the global scope, just need to be\r\n    \/\/ careful when something is exported. Liveness uses bit-vector for live\r\n    \/\/ sets so I don't see compilation time will be a problem for running this\r\n    \/\/ pass in the global scope.\r\n    Scope scope = t.getScope();\r\n    if (scope.isGlobal()) {\r\n        return;\r\n    }\r\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\r\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\r\n    \/\/ If the function has exactly 2 params, mark them as escaped. This is\r\n    \/\/ a work-around for an IE bug where it throws an exception if you\r\n    \/\/ write to the parameters of the callback in a sort(). See:\r\n    \/\/ http:\/\/code.google.com\/p\/closure-compiler\/issues\/detail?id=58\r\n    liveness.analyze();\r\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\r\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\r\n    coloring.color();\r\n    colorings.push(coloring);\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void enterScope(NodeTraversal t) {\r\n                    Scope scope = t.getScope();\r\n    if (scope.isGlobal()) {\r\n        return;\r\n    }\r\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\r\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\r\n                    liveness.analyze();\r\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\r\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\r\n    coloring.color();\r\n    colorings.push(coloring);\r\n}","lc":0.0,"pi":-0.4449760766,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":-0.0542635659,"fo":0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-5681_78c73502","label":1,"code":"@Override\r\nprotected boolean processNext(final Exchange exchange, final AsyncCallback callback) {\r\n    final Exception caught = exchange.getException();\r\n    if (caught == null) {\r\n        return true;\r\n    }\r\n    \/\/ store the last to endpoint as the failure endpoint\r\n    if (exchange.getProperty(Exchange.FAILURE_ENDPOINT) == null) {\r\n        exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\r\n    }\r\n    \/\/ give the rest of the pipeline another chance\r\n    exchange.setProperty(Exchange.EXCEPTION_CAUGHT, caught);\r\n    exchange.setException(null);\r\n    \/\/ is the exception handled by the catch clause\r\n    final Boolean handled = catchClause.handles(exchange);\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"The exception is handled: {} for the exception: {} caused by: {}\", new Object[] { handled, caught.getClass().getName(), caught.getMessage() });\r\n    }\r\n    boolean sync = super.processNext(exchange, new AsyncCallback() {\r\n\r\n        public void done(boolean doneSync) {\r\n            \/\/ we only have to handle async completion of the pipeline\r\n            if (doneSync) {\r\n                return;\r\n            }\r\n            if (!handled) {\r\n                if (exchange.getException() == null) {\r\n                    exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));\r\n                }\r\n            }\r\n            \/\/ always clear redelivery exhausted in a catch clause\r\n            exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);\r\n            \/\/ signal callback to continue routing async\r\n            ExchangeHelper.prepareOutToIn(exchange);\r\n            callback.done(false);\r\n        }\r\n    });\r\n    if (sync) {\r\n        \/\/ set exception back on exchange\r\n        if (!handled) {\r\n            if (exchange.getException() == null) {\r\n                exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));\r\n            }\r\n        }\r\n        \/\/ always clear redelivery exhausted in a catch clause\r\n        exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);\r\n    }\r\n    return sync;\r\n}","code_comment":null,"code_no_comment":"@Override\r\nprotected boolean processNext(final Exchange exchange, final AsyncCallback callback) {\r\n    final Exception caught = exchange.getException();\r\n    if (caught == null) {\r\n        return true;\r\n    }\r\n        if (exchange.getProperty(Exchange.FAILURE_ENDPOINT) == null) {\r\n        exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\r\n    }\r\n        exchange.setProperty(Exchange.EXCEPTION_CAUGHT, caught);\r\n    exchange.setException(null);\r\n        final Boolean handled = catchClause.handles(exchange);\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"The exception is handled: {} for the exception: {} caused by: {}\", new Object[] { handled, caught.getClass().getName(), caught.getMessage() });\r\n    }\r\n    boolean sync = super.processNext(exchange, new AsyncCallback() {\r\n\r\n        public void done(boolean doneSync) {\r\n                        if (doneSync) {\r\n                return;\r\n            }\r\n            if (!handled) {\r\n                if (exchange.getException() == null) {\r\n                    exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));\r\n                }\r\n            }\r\n                        exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);\r\n                        ExchangeHelper.prepareOutToIn(exchange);\r\n            callback.done(false);\r\n        }\r\n    });\r\n    if (sync) {\r\n                if (!handled) {\r\n            if (exchange.getException() == null) {\r\n                exchange.setException(exchange.getProperty(Exchange.EXCEPTION_CAUGHT, Exception.class));\r\n            }\r\n        }\r\n                exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);\r\n    }\r\n    return sync;\r\n}","lc":1.1818181818,"pi":0.9330143541,"ma":1.2,"nbd":0.5,"ml":0.9166666667,"d":0.1408730159,"mi":-0.7014799154,"fo":1.4166666667,"r":-0.0263157895,"e":0.5055398996}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-612_df9e6913","label":1,"code":"@Override\r\npublic Void perform() throws RepositoryException {\r\n    \/\/ TODO: figure out the right place for this check\r\n    NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();\r\n    \/\/ throws on not found\r\n    NodeType nt = ntm.getNodeType(nodeTypeName);\r\n    if (nt.isAbstract() || nt.isMixin()) {\r\n        throw new ConstraintViolationException();\r\n    }\r\n    \/\/ TODO: END\r\n    String jcrPrimaryType = sessionDelegate.getOakPath(Property.JCR_PRIMARY_TYPE);\r\n    Value value = sessionDelegate.getValueFactory().createValue(nodeTypeName, PropertyType.NAME);\r\n    dlg.setProperty(jcrPrimaryType, value);\r\n    return null;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Void perform() throws RepositoryException {\r\n        NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();\r\n        NodeType nt = ntm.getNodeType(nodeTypeName);\r\n    if (nt.isAbstract() || nt.isMixin()) {\r\n        throw new ConstraintViolationException();\r\n    }\r\n        String jcrPrimaryType = sessionDelegate.getOakPath(Property.JCR_PRIMARY_TYPE);\r\n    Value value = sessionDelegate.getValueFactory().createValue(nodeTypeName, PropertyType.NAME);\r\n    dlg.setProperty(jcrPrimaryType, value);\r\n    return null;\r\n}","lc":-0.0909090909,"pi":-0.3732057416,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":-0.1130952381,"mi":0.036222692,"fo":0.1666666667,"r":0.2894736842,"e":-0.0372400201}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3746_47c64d9a","label":0,"code":"\/**\r\n * Gets all properties under the given prefix in this configuration.\r\n *\r\n * @param property\r\n *          prefix property, must be of type PropertyType.PREFIX\r\n * @return a map of property keys to values\r\n * @throws IllegalArgumentException\r\n *           if property is not a prefix\r\n *\/\r\npublic Map<String, String> getAllPropertiesWithPrefix(ClientProperty property) {\r\n    checkType(property, PropertyType.PREFIX);\r\n    Map<String, String> propMap = new HashMap<String, String>();\r\n    Iterator<?> iter = this.getKeys(property.getKey());\r\n    while (iter.hasNext()) {\r\n        String p = (String) iter.next();\r\n        propMap.put(p, getString(p));\r\n    }\r\n    return propMap;\r\n}","code_comment":"\/**\r\n * Gets all properties under the given prefix in this configuration.\r\n *\r\n * @param property\r\n *          prefix property, must be of type PropertyType.PREFIX\r\n * @return a map of property keys to values\r\n * @throws IllegalArgumentException\r\n *           if property is not a prefix\r\n *\/\r\n","code_no_comment":"public Map<String, String> getAllPropertiesWithPrefix(ClientProperty property) {\r\n    checkType(property, PropertyType.PREFIX);\r\n    Map<String, String> propMap = new HashMap<String, String>();\r\n    Iterator<?> iter = this.getKeys(property.getKey());\r\n    while (iter.hasNext()) {\r\n        String p = (String) iter.next();\r\n        propMap.put(p, getString(p));\r\n    }\r\n    return propMap;\r\n}","lc":-0.1818181818,"pi":-0.2200956938,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.1591261452,"fo":0.0833333333,"r":0.1315789474,"e":-0.1627934049}
{"project_name":"Lang","project_version":"30","label":3,"code":"\/**\r\n * <p>Search a String to find the first index of any\r\n * character not in the given set of characters.<\/p>\r\n *\r\n * <p>A <code>null<\/code> String will return <code>-1<\/code>.\r\n * A <code>null<\/code> search string will return <code>-1<\/code>.<\/p>\r\n *\r\n * <pre>\r\n * StringUtils.indexOfAnyBut(null, *)            = -1\r\n * StringUtils.indexOfAnyBut(\"\", *)              = -1\r\n * StringUtils.indexOfAnyBut(*, null)            = -1\r\n * StringUtils.indexOfAnyBut(*, \"\")              = -1\r\n * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"za\") = 3\r\n * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"\")   = 0\r\n * StringUtils.indexOfAnyBut(\"aba\",\"ab\")         = -1\r\n * <\/pre>\r\n *\r\n * @param str  the String to check, may be null\r\n * @param searchChars  the chars to search for, may be null\r\n * @return the index of any of the chars, -1 if no match or null input\r\n * @since 2.0\r\n *\/\r\npublic static int indexOfAnyBut(String str, String searchChars) {\r\n    if (isEmpty(str) || isEmpty(searchChars)) {\r\n        return INDEX_NOT_FOUND;\r\n    }\r\n    int strLen = str.length();\r\n    for (int i = 0; i < strLen; i++) {\r\n        char ch = str.charAt(i);\r\n        if (searchChars.indexOf(ch) < 0) {\r\n            return i;\r\n        }\r\n    }\r\n    return INDEX_NOT_FOUND;\r\n}","code_comment":"\/**\r\n * <p>Search a String to find the first index of any\r\n * character not in the given set of characters.<\/p>\r\n *\r\n * <p>A <code>null<\/code> String will return <code>-1<\/code>.\r\n * A <code>null<\/code> search string will return <code>-1<\/code>.<\/p>\r\n *\r\n * <pre>\r\n * StringUtils.indexOfAnyBut(null, *)            = -1\r\n * StringUtils.indexOfAnyBut(\"\", *)              = -1\r\n * StringUtils.indexOfAnyBut(*, null)            = -1\r\n * StringUtils.indexOfAnyBut(*, \"\")              = -1\r\n * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"za\") = 3\r\n * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"\")   = 0\r\n * StringUtils.indexOfAnyBut(\"aba\",\"ab\")         = -1\r\n * <\/pre>\r\n *\r\n * @param str  the String to check, may be null\r\n * @param searchChars  the chars to search for, may be null\r\n * @return the index of any of the chars, -1 if no match or null input\r\n * @since 2.0\r\n *\/\r\n","code_no_comment":"public static int indexOfAnyBut(String str, String searchChars) {\r\n    if (isEmpty(str) || isEmpty(searchChars)) {\r\n        return INDEX_NOT_FOUND;\r\n    }\r\n    int strLen = str.length();\r\n    for (int i = 0; i < strLen; i++) {\r\n        char ch = str.charAt(i);\r\n        if (searchChars.indexOf(ch) < 0) {\r\n            return i;\r\n        }\r\n    }\r\n    return INDEX_NOT_FOUND;\r\n}","lc":-0.0454545455,"pi":0.1435406699,"ma":0.0,"nbd":0.0,"ml":0.5833333333,"d":0.4563492063,"mi":0.0458069063,"fo":-0.0833333333,"r":0.0789473684,"e":0.1239282401}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-2082_0cfa43d7","label":3,"code":"public StreamingRuntimeContext createRuntimeContext(String taskName) {\r\n    Environment env = getEnvironment();\r\n    return new StreamingRuntimeContext(taskName, env, getUserCodeClassLoader(), getExecutionConfig());\r\n}","code_comment":null,"code_no_comment":"public StreamingRuntimeContext createRuntimeContext(String taskName) {\r\n    Environment env = getEnvironment();\r\n    return new StreamingRuntimeContext(taskName, env, getUserCodeClassLoader(), getExecutionConfig());\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.769415081,"fo":-0.25,"r":0.5263157895,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2359_b3071839","label":0,"code":"\/**\r\n * Returns a {@link DocumentNodeState} as seen at the given\r\n * <code>readRevision<\/code>.\r\n *\r\n * @param nodeStore    the node store.\r\n * @param readRevision the read revision.\r\n * @param lastModified the revision when this node was last modified, but\r\n *                     the value is potentially not yet reflected in this\r\n *                     document.\r\n *                     See {@link RevisionContext#getPendingModifications()}.\r\n * @return the node or <code>null<\/code> if the node doesn't exist at the\r\n *         given read revision.\r\n *\/\r\n@CheckForNull\r\npublic DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore, @Nonnull Revision readRevision, @Nullable Revision lastModified) {\r\n    Map<Revision, String> validRevisions = Maps.newHashMap();\r\n    Branch branch = nodeStore.getBranches().getBranch(readRevision);\r\n    LastRevs lastRevs = new LastRevs(getLastRev(), readRevision, branch);\r\n    \/\/ overlay with unsaved last modified from this instance\r\n    lastRevs.update(lastModified);\r\n    Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);\r\n    if (min == null) {\r\n        \/\/ deleted\r\n        return null;\r\n    }\r\n    String path = getPath();\r\n    DocumentNodeState n = new DocumentNodeState(nodeStore, path, readRevision, hasChildren());\r\n    Revision lastRevision = min;\r\n    for (String key : keySet()) {\r\n        if (!Utils.isPropertyName(key)) {\r\n            continue;\r\n        }\r\n        \/\/ first check local map, which contains most recent values\r\n        Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions, lastRevs);\r\n        \/\/ check if there may be more recent values in a previous document\r\n        if (value != null && !getPreviousRanges().isEmpty()) {\r\n            Revision newest = getLocalMap(key).firstKey();\r\n            if (isRevisionNewer(nodeStore, newest, value.revision)) {\r\n                \/\/ not reading the most recent value, we may need to\r\n                \/\/ consider previous documents as well\r\n                Revision newestPrev = getPreviousRanges().firstKey();\r\n                if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {\r\n                    \/\/ a previous document has more recent changes\r\n                    \/\/ than value.revision\r\n                    value = null;\r\n                }\r\n            }\r\n        }\r\n        if (value == null && !getPreviousRanges().isEmpty()) {\r\n            \/\/ check complete revision history\r\n            value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);\r\n        }\r\n        String propertyName = Utils.unescapePropertyName(key);\r\n        String v = value != null ? value.value : null;\r\n        n.setProperty(propertyName, v);\r\n        \/\/ keep track of when this node was last modified\r\n        if (value != null && isRevisionNewer(nodeStore, value.revision, lastRevision)) {\r\n            lastRevision = value.revision;\r\n        }\r\n    }\r\n    \/\/ lastRevision now points to the revision when this node was\r\n    \/\/ last modified directly. but it may also have been 'modified'\r\n    \/\/ by an operation on a descendant node, which is tracked in\r\n    \/\/ _lastRev.\r\n    \/\/ when was this node last modified?\r\n    Revision branchBase = null;\r\n    if (branch != null) {\r\n        branchBase = branch.getBase(readRevision);\r\n    }\r\n    for (Revision r : lastRevs.get().values()) {\r\n        \/\/ ignore if newer than readRevision\r\n        if (isRevisionNewer(nodeStore, r, readRevision)) {\r\n            \/\/ the node has a _lastRev which is newer than readRevision\r\n            \/\/ this means we don't know when this node was\r\n            \/\/ modified by an operation on a descendant node between\r\n            \/\/ current lastRevision and readRevision. therefore we have\r\n            \/\/ to stay on the safe side and use readRevision\r\n            lastRevision = readRevision;\r\n            continue;\r\n        } else if (branchBase != null && isRevisionNewer(nodeStore, r, branchBase)) {\r\n            \/\/ readRevision is on a branch and the node has a\r\n            \/\/ _lastRev which is newer than the base of the branch\r\n            \/\/ we cannot use this _lastRev because it is not visible\r\n            \/\/ from this branch. highest possible revision of visible\r\n            \/\/ changes is the base of the branch\r\n            r = branchBase;\r\n        }\r\n        if (revisionAreAmbiguous(nodeStore, r, lastRevision)) {\r\n            \/\/ _lastRev entries from multiple cluster nodes are ambiguous\r\n            \/\/ use readRevision to make sure read is consistent\r\n            lastRevision = readRevision;\r\n        } else if (isRevisionNewer(nodeStore, r, lastRevision)) {\r\n            lastRevision = r;\r\n        }\r\n    }\r\n    if (branch != null) {\r\n        \/\/ read from a branch\r\n        \/\/ -> possibly overlay with unsaved last revs from branch\r\n        lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));\r\n        Revision r = lastRevs.getBranchRevision();\r\n        if (r != null) {\r\n            lastRevision = r;\r\n        }\r\n    }\r\n    n.setLastRevision(lastRevision);\r\n    return n;\r\n}","code_comment":"\/**\r\n * Returns a {@link DocumentNodeState} as seen at the given\r\n * <code>readRevision<\/code>.\r\n *\r\n * @param nodeStore    the node store.\r\n * @param readRevision the read revision.\r\n * @param lastModified the revision when this node was last modified, but\r\n *                     the value is potentially not yet reflected in this\r\n *                     document.\r\n *                     See {@link RevisionContext#getPendingModifications()}.\r\n * @return the node or <code>null<\/code> if the node doesn't exist at the\r\n *         given read revision.\r\n *\/\r\n","code_no_comment":"@CheckForNull\r\npublic DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore, @Nonnull Revision readRevision, @Nullable Revision lastModified) {\r\n    Map<Revision, String> validRevisions = Maps.newHashMap();\r\n    Branch branch = nodeStore.getBranches().getBranch(readRevision);\r\n    LastRevs lastRevs = new LastRevs(getLastRev(), readRevision, branch);\r\n        lastRevs.update(lastModified);\r\n    Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);\r\n    if (min == null) {\r\n                return null;\r\n    }\r\n    String path = getPath();\r\n    DocumentNodeState n = new DocumentNodeState(nodeStore, path, readRevision, hasChildren());\r\n    Revision lastRevision = min;\r\n    for (String key : keySet()) {\r\n        if (!Utils.isPropertyName(key)) {\r\n            continue;\r\n        }\r\n                Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions, lastRevs);\r\n                if (value != null && !getPreviousRanges().isEmpty()) {\r\n            Revision newest = getLocalMap(key).firstKey();\r\n            if (isRevisionNewer(nodeStore, newest, value.revision)) {\r\n                                                Revision newestPrev = getPreviousRanges().firstKey();\r\n                if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {\r\n                                                            value = null;\r\n                }\r\n            }\r\n        }\r\n        if (value == null && !getPreviousRanges().isEmpty()) {\r\n                        value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);\r\n        }\r\n        String propertyName = Utils.unescapePropertyName(key);\r\n        String v = value != null ? value.value : null;\r\n        n.setProperty(propertyName, v);\r\n                if (value != null && isRevisionNewer(nodeStore, value.revision, lastRevision)) {\r\n            lastRevision = value.revision;\r\n        }\r\n    }\r\n                        Revision branchBase = null;\r\n    if (branch != null) {\r\n        branchBase = branch.getBase(readRevision);\r\n    }\r\n    for (Revision r : lastRevs.get().values()) {\r\n                if (isRevisionNewer(nodeStore, r, readRevision)) {\r\n                                                                        lastRevision = readRevision;\r\n            continue;\r\n        } else if (branchBase != null && isRevisionNewer(nodeStore, r, branchBase)) {\r\n                                                                        r = branchBase;\r\n        }\r\n        if (revisionAreAmbiguous(nodeStore, r, lastRevision)) {\r\n                                    lastRevision = readRevision;\r\n        } else if (isRevisionNewer(nodeStore, r, lastRevision)) {\r\n            lastRevision = r;\r\n        }\r\n    }\r\n    if (branch != null) {\r\n                        lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));\r\n        Revision r = lastRevs.getBranchRevision();\r\n        if (r != null) {\r\n            lastRevision = r;\r\n        }\r\n    }\r\n    n.setLastRevision(lastRevision);\r\n    return n;\r\n}","lc":2.2727272727,"pi":0.5023923445,"ma":3.2,"nbd":1.0,"ml":2.9166666667,"d":0.8948412698,"mi":-1.1164200141,"fo":2.6666666667,"r":-0.0263157895,"e":4.0314955366}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-2671_17344890","label":1,"code":"@Override\r\npublic void write(byte[] b, int off, int len) throws IOException {\r\n    if (bb.remaining() >= len) {\r\n        bb.put(b, off, len);\r\n        if (bb.remaining() == 0)\r\n            flush();\r\n    } else {\r\n        int remaining = bb.remaining();\r\n        write(b, off, remaining);\r\n        write(b, off + remaining, len - remaining);\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic void write(byte[] b, int off, int len) throws IOException {\r\n    if (bb.remaining() >= len) {\r\n        bb.put(b, off, len);\r\n        if (bb.remaining() == 0)\r\n            flush();\r\n    } else {\r\n        int remaining = bb.remaining();\r\n        write(b, off, remaining);\r\n        write(b, off + remaining, len - remaining);\r\n    }\r\n}","lc":-0.0909090909,"pi":0.3732057416,"ma":-0.2,"nbd":-0.5,"ml":-0.0833333333,"d":0.6924603175,"mi":0.0878083157,"fo":0.0833333333,"r":-0.0263157895,"e":0.2090719962}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5916_def03add","label":1,"code":"\/**\r\n *  @see org.apache.wicket.model.IDetachable#detach()\r\n *\/\r\n@Override\r\npublic void detach() {\r\n    if (attached) {\r\n        try {\r\n            onDetach();\r\n        } finally {\r\n            attached = false;\r\n            transientModelObject = null;\r\n            log.debug(\"removed transient object for {}, requestCycle {}\", this, RequestCycle.get());\r\n        }\r\n    }\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.model.IDetachable#detach()\r\n *\/\r\n","code_no_comment":"@Override\r\npublic void detach() {\r\n    if (attached) {\r\n        try {\r\n            onDetach();\r\n        } finally {\r\n            attached = false;\r\n            transientModelObject = null;\r\n            log.debug(\"removed transient object for {}, requestCycle {}\", this, RequestCycle.get());\r\n        }\r\n    }\r\n}","lc":-0.0909090909,"pi":0.8229665072,"ma":-0.4,"nbd":0.0,"ml":-0.25,"d":-0.3650793651,"mi":0.2273431994,"fo":-0.25,"r":1.3157894737,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4997_ee02c883","label":1,"code":"\/**\r\n *  Gets a URL for the listener interface (e.g. ILinkListener).\r\n *\r\n *  @see RequestCycle#urlFor(IRequestHandler)\r\n *\r\n *  @param listener\r\n *             The listener interface that the URL should call\r\n *  @param parameters\r\n *             The parameters that should be rendered into the urls\r\n *  @return The URL\r\n *\/\r\npublic final CharSequence urlFor(final RequestListenerInterface listener, final PageParameters parameters) {\r\n    Page page = getPage();\r\n    PageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);\r\n    IRequestHandler handler;\r\n    if (page.isBookmarkable()) {\r\n        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener);\r\n    } else {\r\n        handler = new ListenerInterfaceRequestHandler(provider, listener);\r\n    }\r\n    return getRequestCycle().urlFor(handler);\r\n}","code_comment":"\/**\r\n *  Gets a URL for the listener interface (e.g. ILinkListener).\r\n *\r\n *  @see RequestCycle#urlFor(IRequestHandler)\r\n *\r\n *  @param listener\r\n *             The listener interface that the URL should call\r\n *  @param parameters\r\n *             The parameters that should be rendered into the urls\r\n *  @return The URL\r\n *\/\r\n","code_no_comment":"public final CharSequence urlFor(final RequestListenerInterface listener, final PageParameters parameters) {\r\n    Page page = getPage();\r\n    PageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);\r\n    IRequestHandler handler;\r\n    if (page.isBookmarkable()) {\r\n        handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener);\r\n    } else {\r\n        handler = new ListenerInterfaceRequestHandler(provider, listener);\r\n    }\r\n    return getRequestCycle().urlFor(handler);\r\n}","lc":-0.1363636364,"pi":-0.2775119617,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.1408033827,"fo":-0.1666666667,"r":0.2894736842,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-3740_f2f5bd5b","label":1,"code":"@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic void processElement(StreamRecord<IN> element) throws Exception {\r\n    Collection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\r\n    K key = (K) getStateBackend().getCurrentKey();\r\n    if (windowAssigner instanceof MergingWindowAssigner) {\r\n        MergingWindowSet<W> mergingWindows = mergingWindowsByKey.get(getStateBackend().getCurrentKey());\r\n        if (mergingWindows == null) {\r\n            mergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner);\r\n            mergingWindowsByKey.put(key, mergingWindows);\r\n        }\r\n        for (W window : elementWindows) {\r\n            \/\/ If there is a merge, it can only result in a window that contains our new\r\n            \/\/ element because we always eagerly merge\r\n            final Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\r\n            \/\/ adding the new window might result in a merge, in that case the actualWindow\r\n            \/\/ is the merged window and we work with that. If we don't merge then\r\n            \/\/ actualWindow == window\r\n            W actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\r\n\r\n                @Override\r\n                public void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception {\r\n                    context.window = mergeResult;\r\n                    \/\/ store for later use\r\n                    mergeTriggerResult.f0 = context.onMerge(mergedWindows);\r\n                    for (W m : mergedWindows) {\r\n                        context.window = m;\r\n                        context.clear();\r\n                    }\r\n                    \/\/ merge the merged state windows into the newly resulting state window\r\n                    getStateBackend().mergePartitionedStates(stateWindowResult, mergedStateWindows, windowSerializer, (StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\r\n                }\r\n            });\r\n            W stateWindow = mergingWindows.getStateWindow(actualWindow);\r\n            AppendingState<IN, ACC> windowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\r\n            windowState.add(element.getValue());\r\n            context.key = key;\r\n            context.window = actualWindow;\r\n            \/\/ we might have already fired because of a merge but still call onElement\r\n            \/\/ on the (possibly merged) window\r\n            TriggerResult triggerResult = context.onElement(element);\r\n            TriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\r\n            processTriggerResult(combinedTriggerResult, key, actualWindow);\r\n        }\r\n    } else {\r\n        for (W window : elementWindows) {\r\n            AppendingState<IN, ACC> windowState = getPartitionedState(window, windowSerializer, windowStateDescriptor);\r\n            windowState.add(element.getValue());\r\n            context.key = key;\r\n            context.window = window;\r\n            TriggerResult triggerResult = context.onElement(element);\r\n            processTriggerResult(triggerResult, key, window);\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"@Override\r\n@SuppressWarnings(\"unchecked\")\r\npublic void processElement(StreamRecord<IN> element) throws Exception {\r\n    Collection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\r\n    K key = (K) getStateBackend().getCurrentKey();\r\n    if (windowAssigner instanceof MergingWindowAssigner) {\r\n        MergingWindowSet<W> mergingWindows = mergingWindowsByKey.get(getStateBackend().getCurrentKey());\r\n        if (mergingWindows == null) {\r\n            mergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner);\r\n            mergingWindowsByKey.put(key, mergingWindows);\r\n        }\r\n        for (W window : elementWindows) {\r\n                                    final Tuple1<TriggerResult> mergeTriggerResult = new Tuple1<>(TriggerResult.CONTINUE);\r\n                                                W actualWindow = mergingWindows.addWindow(window, new MergingWindowSet.MergeFunction<W>() {\r\n\r\n                @Override\r\n                public void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception {\r\n                    context.window = mergeResult;\r\n                                        mergeTriggerResult.f0 = context.onMerge(mergedWindows);\r\n                    for (W m : mergedWindows) {\r\n                        context.window = m;\r\n                        context.clear();\r\n                    }\r\n                                        getStateBackend().mergePartitionedStates(stateWindowResult, mergedStateWindows, windowSerializer, (StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);\r\n                }\r\n            });\r\n            W stateWindow = mergingWindows.getStateWindow(actualWindow);\r\n            AppendingState<IN, ACC> windowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\r\n            windowState.add(element.getValue());\r\n            context.key = key;\r\n            context.window = actualWindow;\r\n                                    TriggerResult triggerResult = context.onElement(element);\r\n            TriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\r\n            processTriggerResult(combinedTriggerResult, key, actualWindow);\r\n        }\r\n    } else {\r\n        for (W window : elementWindows) {\r\n            AppendingState<IN, ACC> windowState = getPartitionedState(window, windowSerializer, windowStateDescriptor);\r\n            windowState.add(element.getValue());\r\n            context.key = key;\r\n            context.window = window;\r\n            TriggerResult triggerResult = context.onElement(element);\r\n            processTriggerResult(triggerResult, key, window);\r\n        }\r\n    }\r\n}","lc":1.4090909091,"pi":1.4497607656,"ma":0.4,"nbd":1.0,"ml":-0.0833333333,"d":0.1785714286,"mi":-0.8286116984,"fo":1.6666666667,"r":-0.0263157895,"e":1.2480028584}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-2882_ebe56869","label":1,"code":"\/**\r\n *  @see org.apache.wicket.MarkupContainer#onComponentTagBody(org.apache.wicket.markup.MarkupStream,\r\n *       org.apache.wicket.markup.ComponentTag)\r\n *\/\r\n@Override\r\nprotected void onComponentTagBody(MarkupStream markupStream, ComponentTag openTag) {\r\n    \/\/ enclosure's parent container\r\n    MarkupContainer container = getEnclosureParent();\r\n    Component controller = container.get(childId.toString());\r\n    checkChildComponent(controller);\r\n    \/\/ set the enclosure visibility\r\n    boolean visible = controller.determineVisibility();\r\n    \/\/ We want to know which components are rendered inside the enclosure\r\n    final IComponentOnAfterRenderListener listener = new EnclosureListener(this);\r\n    try {\r\n        \/\/ register the listener\r\n        getApplication().addComponentOnAfterRenderListener(listener);\r\n        if (visible) {\r\n            super.onComponentTagBody(markupStream, openTag);\r\n        } else {\r\n            RequestCycle cycle = getRequestCycle();\r\n            Response response = cycle.getResponse();\r\n            try {\r\n                cycle.setResponse(NullResponse.getInstance());\r\n                super.onComponentTagBody(markupStream, openTag);\r\n            } finally {\r\n                cycle.setResponse(response);\r\n            }\r\n        }\r\n    } finally {\r\n        \/\/ make sure we remove the listener\r\n        getApplication().removeComponentOnAfterRenderListener(listener);\r\n    }\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.MarkupContainer#onComponentTagBody(org.apache.wicket.markup.MarkupStream,\r\n *       org.apache.wicket.markup.ComponentTag)\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void onComponentTagBody(MarkupStream markupStream, ComponentTag openTag) {\r\n        MarkupContainer container = getEnclosureParent();\r\n    Component controller = container.get(childId.toString());\r\n    checkChildComponent(controller);\r\n        boolean visible = controller.determineVisibility();\r\n        final IComponentOnAfterRenderListener listener = new EnclosureListener(this);\r\n    try {\r\n                getApplication().addComponentOnAfterRenderListener(listener);\r\n        if (visible) {\r\n            super.onComponentTagBody(markupStream, openTag);\r\n        } else {\r\n            RequestCycle cycle = getRequestCycle();\r\n            Response response = cycle.getResponse();\r\n            try {\r\n                cycle.setResponse(NullResponse.getInstance());\r\n                super.onComponentTagBody(markupStream, openTag);\r\n            } finally {\r\n                cycle.setResponse(response);\r\n            }\r\n        }\r\n    } finally {\r\n                getApplication().removeComponentOnAfterRenderListener(listener);\r\n    }\r\n}","lc":0.5,"pi":0.9234449761,"ma":-0.4,"nbd":0.5,"ml":-0.25,"d":-0.3650793651,"mi":-0.3364341085,"fo":0.8333333333,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-217_46f62443","label":1,"code":"@Override\r\npublic Collection<Text> getSplits(String tableName) {\r\n    return Collections.emptyList();\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic Collection<Text> getSplits(String tableName) {\r\n    return Collections.emptyList();\r\n}","lc":-0.4545454545,"pi":-0.6028708134,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.8469344609,"fo":-0.4166666667,"r":1.6315789474,"e":-0.1627934049}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-218_3d55560a","label":1,"code":"@Override\r\npublic int compareTo(Key o) {\r\n    int compare = super.compareTo(o);\r\n    if (compare != 0)\r\n        return compare;\r\n    if (o instanceof MockMemKey) {\r\n        MockMemKey other = (MockMemKey) o;\r\n        if (count < other.count)\r\n            return -1;\r\n        if (count > other.count)\r\n            return 1;\r\n    } else {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic int compareTo(Key o) {\r\n    int compare = super.compareTo(o);\r\n    if (compare != 0)\r\n        return compare;\r\n    if (o instanceof MockMemKey) {\r\n        MockMemKey other = (MockMemKey) o;\r\n        if (count < other.count)\r\n            return -1;\r\n        if (count > other.count)\r\n            return 1;\r\n    } else {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}","lc":0.0909090909,"pi":0.3444976077,"ma":0.2,"nbd":-0.5,"ml":0.25,"d":0.6091269841,"mi":-0.0367864693,"fo":-0.4166666667,"r":0.3157894737,"e":0.1359566167}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3897_94c6c575","label":1,"code":"private void resetBranch(DocumentNodeState branchHead, DocumentNodeState ancestor) {\r\n    try {\r\n        head = store.getRoot(store.reset(branchHead.getRevision(), ancestor.getRevision(), DocumentNodeStoreBranch.this));\r\n    } catch (Exception e) {\r\n        CommitFailedException ex = new CommitFailedException(OAK, 100, \"Branch reset failed\", e);\r\n        branchState = new ResetFailed(base, ex);\r\n    }\r\n}","code_comment":null,"code_no_comment":"private void resetBranch(DocumentNodeState branchHead, DocumentNodeState ancestor) {\r\n    try {\r\n        head = store.getRoot(store.reset(branchHead.getRevision(), ancestor.getRevision(), DocumentNodeStoreBranch.this));\r\n    } catch (Exception e) {\r\n        CommitFailedException ex = new CommitFailedException(OAK, 100, \"Branch reset failed\", e);\r\n        branchState = new ResetFailed(base, ex);\r\n    }\r\n}","lc":-0.2727272727,"pi":0.0622009569,"ma":-0.4,"nbd":-0.5,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.28794926,"fo":-0.1666666667,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"flink","project_version":"remotes\/origin\/bugs-dot-jar_FLINK-1167_259f10c0","label":3,"code":"\/**\r\n *  Sets the nextPartialSolution for this BulkIterationNode.\r\n *\r\n *  @param nextPartialSolution The nextPartialSolution to set.\r\n *\/\r\npublic void setNextPartialSolution(OptimizerNode nextPartialSolution, OptimizerNode terminationCriterion) {\r\n    \/\/ or if the steo function has any operator at all\r\n    if (nextPartialSolution.getDegreeOfParallelism() != getDegreeOfParallelism() || nextPartialSolution == partialSolution) {\r\n        \/\/ add a no-op to the root to express the re-partitioning\r\n        NoOpNode noop = new NoOpNode();\r\n        noop.setDegreeOfParallelism(getDegreeOfParallelism());\r\n        PactConnection noOpConn = new PactConnection(nextPartialSolution, noop);\r\n        noop.setIncomingConnection(noOpConn);\r\n        nextPartialSolution.addOutgoingConnection(noOpConn);\r\n        nextPartialSolution = noop;\r\n    }\r\n    this.nextPartialSolution = nextPartialSolution;\r\n    this.terminationCriterion = terminationCriterion;\r\n    if (terminationCriterion == null) {\r\n        this.singleRoot = nextPartialSolution;\r\n        this.rootConnection = new PactConnection(nextPartialSolution);\r\n    } else {\r\n        \/\/ we have a termination criterion\r\n        SingleRootJoiner singleRootJoiner = new SingleRootJoiner();\r\n        this.rootConnection = new PactConnection(nextPartialSolution, singleRootJoiner);\r\n        this.terminationCriterionRootConnection = new PactConnection(terminationCriterion, singleRootJoiner);\r\n        singleRootJoiner.setInputs(this.rootConnection, this.terminationCriterionRootConnection);\r\n        this.singleRoot = singleRootJoiner;\r\n        \/\/ add connection to terminationCriterion for interesting properties visitor\r\n        terminationCriterion.addOutgoingConnection(terminationCriterionRootConnection);\r\n    }\r\n    nextPartialSolution.addOutgoingConnection(rootConnection);\r\n}","code_comment":"\/**\r\n *  Sets the nextPartialSolution for this BulkIterationNode.\r\n *\r\n *  @param nextPartialSolution The nextPartialSolution to set.\r\n *\/\r\n","code_no_comment":"public void setNextPartialSolution(OptimizerNode nextPartialSolution, OptimizerNode terminationCriterion) {\r\n        if (nextPartialSolution.getDegreeOfParallelism() != getDegreeOfParallelism() || nextPartialSolution == partialSolution) {\r\n                NoOpNode noop = new NoOpNode();\r\n        noop.setDegreeOfParallelism(getDegreeOfParallelism());\r\n        PactConnection noOpConn = new PactConnection(nextPartialSolution, noop);\r\n        noop.setIncomingConnection(noOpConn);\r\n        nextPartialSolution.addOutgoingConnection(noOpConn);\r\n        nextPartialSolution = noop;\r\n    }\r\n    this.nextPartialSolution = nextPartialSolution;\r\n    this.terminationCriterion = terminationCriterion;\r\n    if (terminationCriterion == null) {\r\n        this.singleRoot = nextPartialSolution;\r\n        this.rootConnection = new PactConnection(nextPartialSolution);\r\n    } else {\r\n                SingleRootJoiner singleRootJoiner = new SingleRootJoiner();\r\n        this.rootConnection = new PactConnection(nextPartialSolution, singleRootJoiner);\r\n        this.terminationCriterionRootConnection = new PactConnection(terminationCriterion, singleRootJoiner);\r\n        singleRootJoiner.setInputs(this.rootConnection, this.terminationCriterionRootConnection);\r\n        this.singleRoot = singleRootJoiner;\r\n                terminationCriterion.addOutgoingConnection(terminationCriterionRootConnection);\r\n    }\r\n    nextPartialSolution.addOutgoingConnection(rootConnection);\r\n}","lc":0.4545454545,"pi":-0.1961722488,"ma":-0.2,"nbd":-0.5,"ml":0.25,"d":0.8452380952,"mi":-0.3587033122,"fo":0.25,"r":-0.0263157895,"e":0.8681385177}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4185_5fd03973","label":1,"code":"public final boolean isPageInstanceCreated() {\r\n    \/\/ this request handler always operates on a created page instance\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"public final boolean isPageInstanceCreated() {\r\n        return true;\r\n}","lc":-0.5,"pi":-0.5263157895,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":1.2407329105,"fo":-0.5,"r":2.5789473684,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-3110_d10362c0","label":1,"code":"private boolean deleteFile(Directory dir, String fileName, boolean copiedFromRemote) {\r\n    LocalIndexFile file = new LocalIndexFile(dir, fileName, getFileLength(dir, fileName), copiedFromRemote);\r\n    boolean successFullyDeleted = false;\r\n    try {\r\n        boolean fileExisted = false;\r\n        if (dir.fileExists(fileName)) {\r\n            fileExisted = true;\r\n            dir.deleteFile(fileName);\r\n        }\r\n        successfullyDeleted(file, fileExisted);\r\n        successFullyDeleted = true;\r\n    } catch (IOException e) {\r\n        failedToDelete(file);\r\n        log.debug(\"Error occurred while removing deleted file {} from Local {}. \" + \"Attempt would be maid to delete it on next run \", fileName, dir, e);\r\n    }\r\n    return successFullyDeleted;\r\n}","code_comment":null,"code_no_comment":"private boolean deleteFile(Directory dir, String fileName, boolean copiedFromRemote) {\r\n    LocalIndexFile file = new LocalIndexFile(dir, fileName, getFileLength(dir, fileName), copiedFromRemote);\r\n    boolean successFullyDeleted = false;\r\n    try {\r\n        boolean fileExisted = false;\r\n        if (dir.fileExists(fileName)) {\r\n            fileExisted = true;\r\n            dir.deleteFile(fileName);\r\n        }\r\n        successfullyDeleted(file, fileExisted);\r\n        successFullyDeleted = true;\r\n    } catch (IOException e) {\r\n        failedToDelete(file);\r\n        log.debug(\"Error occurred while removing deleted file {} from Local {}. \" + \"Attempt would be maid to delete it on next run \", fileName, dir, e);\r\n    }\r\n    return successFullyDeleted;\r\n}","lc":0.1363636364,"pi":0.1913875598,"ma":-0.2,"nbd":0.0,"ml":-0.1666666667,"d":0.0238095238,"mi":-0.1371388302,"fo":0.0,"r":-0.0263157895,"e":0.0508405226}
{"project_name":"JxPath","project_version":"20","label":3,"code":"\/**\r\n * Compare left to right.\r\n * @param left left operand\r\n * @param right right operand\r\n * @return operation success\/failure\r\n *\/\r\nprivate boolean compute(Object left, Object right) {\r\n    left = reduce(left);\r\n    right = reduce(right);\r\n    if (left instanceof InitialContext) {\r\n        ((InitialContext) left).reset();\r\n    }\r\n    if (right instanceof InitialContext) {\r\n        ((InitialContext) right).reset();\r\n    }\r\n    if (left instanceof Iterator && right instanceof Iterator) {\r\n        return findMatch((Iterator) left, (Iterator) right);\r\n    }\r\n    if (left instanceof Iterator) {\r\n        return containsMatch((Iterator) left, right);\r\n    }\r\n    if (right instanceof Iterator) {\r\n        return containsMatch((Iterator) right, left);\r\n    }\r\n    double ld = InfoSetUtil.doubleValue(left);\r\n    if (Double.isNaN(ld)) {\r\n        return false;\r\n    }\r\n    double rd = InfoSetUtil.doubleValue(right);\r\n    if (Double.isNaN(rd)) {\r\n        return false;\r\n    }\r\n    return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\r\n}","code_comment":"\/**\r\n * Compare left to right.\r\n * @param left left operand\r\n * @param right right operand\r\n * @return operation success\/failure\r\n *\/\r\n","code_no_comment":"private boolean compute(Object left, Object right) {\r\n    left = reduce(left);\r\n    right = reduce(right);\r\n    if (left instanceof InitialContext) {\r\n        ((InitialContext) left).reset();\r\n    }\r\n    if (right instanceof InitialContext) {\r\n        ((InitialContext) right).reset();\r\n    }\r\n    if (left instanceof Iterator && right instanceof Iterator) {\r\n        return findMatch((Iterator) left, (Iterator) right);\r\n    }\r\n    if (left instanceof Iterator) {\r\n        return containsMatch((Iterator) left, right);\r\n    }\r\n    if (right instanceof Iterator) {\r\n        return containsMatch((Iterator) right, left);\r\n    }\r\n    double ld = InfoSetUtil.doubleValue(left);\r\n    if (Double.isNaN(ld)) {\r\n        return false;\r\n    }\r\n    double rd = InfoSetUtil.doubleValue(right);\r\n    if (Double.isNaN(rd)) {\r\n        return false;\r\n    }\r\n    return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\r\n}","lc":0.6363636364,"pi":-0.4019138756,"ma":1.2,"nbd":-0.5,"ml":0.9166666667,"d":0.9007936508,"mi":-0.4686398872,"fo":0.5,"r":-0.0263157895,"e":0.874302542}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6447_020c451a","label":1,"code":"private boolean process(final Exchange exchange, final AsyncCallback callback, final Iterator<Processor> processors, final AsyncProcessor asyncProcessor) {\r\n    \/\/ this does the actual processing so log at trace level\r\n    LOG.trace(\"Processing exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n    \/\/ implement asynchronous routing logic in callback so we can have the callback being\r\n    \/\/ triggered and then continue routing where we left\r\n    boolean sync = asyncProcessor.process(exchange, new AsyncCallback() {\r\n\r\n        public void done(boolean doneSync) {\r\n            \/\/ we only have to handle async completion of the pipeline\r\n            if (doneSync) {\r\n                return;\r\n            }\r\n            \/\/ continue processing the pipeline asynchronously\r\n            while (continueRouting(processors, exchange)) {\r\n                AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());\r\n                \/\/ check for error if so we should break out\r\n                if (!continueProcessing(exchange, \"so breaking out of pipeline\", LOG)) {\r\n                    break;\r\n                }\r\n                doneSync = process(exchange, callback, processors, processor);\r\n                if (!doneSync) {\r\n                    LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\r\n                    return;\r\n                }\r\n            }\r\n            LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n            callback.done(false);\r\n        }\r\n    });\r\n    return sync;\r\n}","code_comment":null,"code_no_comment":"private boolean process(final Exchange exchange, final AsyncCallback callback, final Iterator<Processor> processors, final AsyncProcessor asyncProcessor) {\r\n        LOG.trace(\"Processing exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n            boolean sync = asyncProcessor.process(exchange, new AsyncCallback() {\r\n\r\n        public void done(boolean doneSync) {\r\n                        if (doneSync) {\r\n                return;\r\n            }\r\n                        while (continueRouting(processors, exchange)) {\r\n                AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());\r\n                                if (!continueProcessing(exchange, \"so breaking out of pipeline\", LOG)) {\r\n                    break;\r\n                }\r\n                doneSync = process(exchange, callback, processors, processor);\r\n                if (!doneSync) {\r\n                    LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\r\n                    return;\r\n                }\r\n            }\r\n            LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\r\n            callback.done(false);\r\n        }\r\n    });\r\n    return sync;\r\n}","lc":0.4545454545,"pi":1.4545454545,"ma":0.4,"nbd":0.5,"ml":0.3333333333,"d":0.0595238095,"mi":-0.3575757576,"fo":0.5833333333,"r":-0.0263157895,"e":0.1523048818}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-4116_4624ab3d","label":1,"code":"\/**\r\n *  @see org.apache.wicket.request.IRequestHandler#respond(org.apache.wicket.request.IRequestCycle)\r\n *\/\r\npublic void respond(final IRequestCycle requestCycle) {\r\n    final IRequestablePage page = getPage();\r\n    if (getComponent().getPage() == page) {\r\n        boolean isAjax = ((WebRequest) requestCycle.getRequest()).isAjax();\r\n        if (isAjax == false && listenerInterface.isRenderPageAfterInvocation()) {\r\n            \/\/ schedule page render after current request handler is done. this can be\r\n            \/\/ overridden during invocation of listener\r\n            \/\/ method (i.e. by calling RequestCycle#setResponsePage)\r\n            final IPageProvider pageProvider = new PageProvider(page);\r\n            final RedirectPolicy policy = page.isPageStateless() ? RedirectPolicy.NEVER_REDIRECT : RedirectPolicy.AUTO_REDIRECT;\r\n            requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(pageProvider, policy));\r\n        }\r\n        invokeListener();\r\n    } else {\r\n        throw new WicketRuntimeException(\"Component \" + getComponent() + \" has been removed from page.\");\r\n    }\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.request.IRequestHandler#respond(org.apache.wicket.request.IRequestCycle)\r\n *\/\r\n","code_no_comment":"public void respond(final IRequestCycle requestCycle) {\r\n    final IRequestablePage page = getPage();\r\n    if (getComponent().getPage() == page) {\r\n        boolean isAjax = ((WebRequest) requestCycle.getRequest()).isAjax();\r\n        if (isAjax == false && listenerInterface.isRenderPageAfterInvocation()) {\r\n                                                final IPageProvider pageProvider = new PageProvider(page);\r\n            final RedirectPolicy policy = page.isPageStateless() ? RedirectPolicy.NEVER_REDIRECT : RedirectPolicy.AUTO_REDIRECT;\r\n            requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(pageProvider, policy));\r\n        }\r\n        invokeListener();\r\n    } else {\r\n        throw new WicketRuntimeException(\"Component \" + getComponent() + \" has been removed from page.\");\r\n    }\r\n}","lc":0.0,"pi":0.4306220096,"ma":0.2,"nbd":0.0,"ml":0.3333333333,"d":0.2162698413,"mi":-0.066384778,"fo":0.3333333333,"r":-0.0263157895,"e":0.1679984786}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-2430_be3a9114","label":1,"code":"@Override\r\npublic boolean propertyChanged(PropertyState before, PropertyState after) {\r\n    if (!loader.isRunning()) {\r\n        return false;\r\n    }\r\n    builder.setProperty(binaryCheck(after));\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean propertyChanged(PropertyState before, PropertyState after) {\r\n    if (!loader.isRunning()) {\r\n        return false;\r\n    }\r\n    builder.setProperty(binaryCheck(after));\r\n    return true;\r\n}","lc":-0.2727272727,"pi":-0.1626794258,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":-0.3650793651,"mi":0.4125440451,"fo":-0.25,"r":0.4210526316,"e":-0.1627934049}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5359_61122bab","label":3,"code":"\/**\r\n *  Convert to boolean, returning default value if text is inconvertible.\r\n *\r\n *  @param defaultValue\r\n *             the default value\r\n *  @return the converted text as a boolean or the default value if text is empty or inconvertible\r\n *  @see Strings#isTrue(String)\r\n *\/\r\npublic final boolean toBoolean(final boolean defaultValue) {\r\n    if (text != null) {\r\n        try {\r\n            return toBoolean();\r\n        } catch (StringValueConversionException x) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a boolean: %s\", text, x.getMessage()), x);\r\n            }\r\n        }\r\n    }\r\n    return defaultValue;\r\n}","code_comment":"\/**\r\n *  Convert to boolean, returning default value if text is inconvertible.\r\n *\r\n *  @param defaultValue\r\n *             the default value\r\n *  @return the converted text as a boolean or the default value if text is empty or inconvertible\r\n *  @see Strings#isTrue(String)\r\n *\/\r\n","code_no_comment":"public final boolean toBoolean(final boolean defaultValue) {\r\n    if (text != null) {\r\n        try {\r\n            return toBoolean();\r\n        } catch (StringValueConversionException x) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(String.format(\"An error occurred while converting '%s' to a boolean: %s\", text, x.getMessage()), x);\r\n            }\r\n        }\r\n    }\r\n    return defaultValue;\r\n}","lc":-0.0909090909,"pi":0.8899521531,"ma":0.0,"nbd":0.5,"ml":-0.0833333333,"d":-0.3650793651,"mi":0.1709654686,"fo":-0.0833333333,"r":1.1315789474,"e":-0.1627934049}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-722_95d15eff","label":3,"code":"\/**\r\n * Compute the\r\n * <a href=\"http:\/\/mathworld.wolfram.com\/HyperbolicTangent.html\" TARGET=\"_top\">\r\n * hyperbolic tangent<\/a> of this complex number.\r\n * Implements the formula:\r\n * <pre>\r\n *  <code>\r\n *   tan(a + bi) = sinh(2a)\/(cosh(2a)+cos(2b)) + [sin(2b)\/(cosh(2a)+cos(2b))]i\r\n *  <\/code>\r\n * <\/pre>\r\n * where the (real) functions on the right-hand side are\r\n * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\r\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\r\n * <br\/>\r\n * Returns {@link Complex#NaN} if either real or imaginary part of the\r\n * input argument is {@code NaN}.\r\n * <br\/>\r\n * Infinite values in real or imaginary parts of the input may result in\r\n * infinite or NaN values returned in parts of the result.\r\n * <pre>\r\n *  Examples:\r\n *  <code>\r\n *   tanh(1 &plusmn; INFINITY i) = NaN + NaN i\r\n *   tanh(&plusmn;INFINITY + i) = NaN + 0 i\r\n *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\r\n *   tanh(0 + (&pi;\/2)i) = NaN + INFINITY i\r\n *  <\/code>\r\n * <\/pre>\r\n *\r\n * @return the hyperbolic tangent of {@code this}.\r\n * @since 1.2\r\n *\/\r\npublic Complex tanh() {\r\n    if (isNaN) {\r\n        return NaN;\r\n    }\r\n    double real2 = 2.0 * real;\r\n    double imaginary2 = 2.0 * imaginary;\r\n    double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\r\n    return createComplex(FastMath.sinh(real2) \/ d, FastMath.sin(imaginary2) \/ d);\r\n}","code_comment":"\/**\r\n * Compute the\r\n * <a href=\"http:\/\/mathworld.wolfram.com\/HyperbolicTangent.html\" TARGET=\"_top\">\r\n * hyperbolic tangent<\/a> of this complex number.\r\n * Implements the formula:\r\n * <pre>\r\n *  <code>\r\n *   tan(a + bi) = sinh(2a)\/(cosh(2a)+cos(2b)) + [sin(2b)\/(cosh(2a)+cos(2b))]i\r\n *  <\/code>\r\n * <\/pre>\r\n * where the (real) functions on the right-hand side are\r\n * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\r\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\r\n * <br\/>\r\n * Returns {@link Complex#NaN} if either real or imaginary part of the\r\n * input argument is {@code NaN}.\r\n * <br\/>\r\n * Infinite values in real or imaginary parts of the input may result in\r\n * infinite or NaN values returned in parts of the result.\r\n * <pre>\r\n *  Examples:\r\n *  <code>\r\n *   tanh(1 &plusmn; INFINITY i) = NaN + NaN i\r\n *   tanh(&plusmn;INFINITY + i) = NaN + 0 i\r\n *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\r\n *   tanh(0 + (&pi;\/2)i) = NaN + INFINITY i\r\n *  <\/code>\r\n * <\/pre>\r\n *\r\n * @return the hyperbolic tangent of {@code this}.\r\n * @since 1.2\r\n *\/\r\n","code_no_comment":"public Complex tanh() {\r\n    if (isNaN) {\r\n        return NaN;\r\n    }\r\n    double real2 = 2.0 * real;\r\n    double imaginary2 = 2.0 * imaginary;\r\n    double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\r\n    return createComplex(FastMath.sinh(real2) \/ d, FastMath.sin(imaginary2) \/ d);\r\n}","lc":-0.2272727273,"pi":-0.3444976077,"ma":-0.4,"nbd":-0.5,"ml":-0.25,"d":0.2658730159,"mi":0.2231148696,"fo":-0.0833333333,"r":0.2894736842,"e":0.0623387101}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5881_8c83c5c5","label":1,"code":"\/**\r\n *  Update the model of a {@link FormComponent} containing a {@link Collection}.\r\n *\r\n *  If the model object does not yet exists, a new {@link ArrayList} is filled with the converted\r\n *  input and used as the new model object. Otherwise the existing collection is modified\r\n *  in-place, then {@link Model#setObject(Object)} is called with the same instance: it allows\r\n *  the Model to be notified of changes even when {@link Model#getObject()} returns a different\r\n *  {@link Collection} at every invocation.\r\n *\r\n *  @param <S>\r\n *             collection type\r\n *  @param formComponent\r\n *             the form component to update\r\n *  @see FormComponent#updateModel()\r\n *  @throws WicketRuntimeException\r\n *              if the existing model object collection is unmodifiable and no setter exists\r\n *\/\r\npublic static <S> void updateCollectionModel(FormComponent<Collection<S>> formComponent) {\r\n    Collection<S> convertedInput = formComponent.getConvertedInput();\r\n    Collection<S> collection = formComponent.getModelObject();\r\n    if (collection == null) {\r\n        collection = new ArrayList<>(convertedInput);\r\n        formComponent.setModelObject(collection);\r\n    } else {\r\n        boolean modified = false;\r\n        formComponent.modelChanging();\r\n        try {\r\n            collection.clear();\r\n            if (convertedInput != null) {\r\n                collection.addAll(convertedInput);\r\n            }\r\n            modified = true;\r\n        } catch (UnsupportedOperationException unmodifiable) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"An error occurred while trying to modify the collection attached to \" + formComponent, unmodifiable);\r\n            }\r\n            collection = new ArrayList<>(convertedInput);\r\n        }\r\n        try {\r\n            formComponent.getModel().setObject(collection);\r\n        } catch (Exception noSetter) {\r\n            if (!modified) {\r\n                throw new WicketRuntimeException(\"An error occurred while trying to set the collection attached to \" + formComponent, noSetter);\r\n            } else if (logger.isDebugEnabled()) {\r\n                logger.debug(\"An error occurred while trying to set the collection attached to \" + formComponent, noSetter);\r\n            }\r\n        }\r\n        formComponent.modelChanged();\r\n    }\r\n}","code_comment":"\/**\r\n *  Update the model of a {@link FormComponent} containing a {@link Collection}.\r\n *\r\n *  If the model object does not yet exists, a new {@link ArrayList} is filled with the converted\r\n *  input and used as the new model object. Otherwise the existing collection is modified\r\n *  in-place, then {@link Model#setObject(Object)} is called with the same instance: it allows\r\n *  the Model to be notified of changes even when {@link Model#getObject()} returns a different\r\n *  {@link Collection} at every invocation.\r\n *\r\n *  @param <S>\r\n *             collection type\r\n *  @param formComponent\r\n *             the form component to update\r\n *  @see FormComponent#updateModel()\r\n *  @throws WicketRuntimeException\r\n *              if the existing model object collection is unmodifiable and no setter exists\r\n *\/\r\n","code_no_comment":"public static <S> void updateCollectionModel(FormComponent<Collection<S>> formComponent) {\r\n    Collection<S> convertedInput = formComponent.getConvertedInput();\r\n    Collection<S> collection = formComponent.getModelObject();\r\n    if (collection == null) {\r\n        collection = new ArrayList<>(convertedInput);\r\n        formComponent.setModelObject(collection);\r\n    } else {\r\n        boolean modified = false;\r\n        formComponent.modelChanging();\r\n        try {\r\n            collection.clear();\r\n            if (convertedInput != null) {\r\n                collection.addAll(convertedInput);\r\n            }\r\n            modified = true;\r\n        } catch (UnsupportedOperationException unmodifiable) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"An error occurred while trying to modify the collection attached to \" + formComponent, unmodifiable);\r\n            }\r\n            collection = new ArrayList<>(convertedInput);\r\n        }\r\n        try {\r\n            formComponent.getModel().setObject(collection);\r\n        } catch (Exception noSetter) {\r\n            if (!modified) {\r\n                throw new WicketRuntimeException(\"An error occurred while trying to set the collection attached to \" + formComponent, noSetter);\r\n            } else if (logger.isDebugEnabled()) {\r\n                logger.debug(\"An error occurred while trying to set the collection attached to \" + formComponent, noSetter);\r\n            }\r\n        }\r\n        formComponent.modelChanged();\r\n    }\r\n}","lc":0.8636363636,"pi":0.5933014354,"ma":1.0,"nbd":1.0,"ml":0.3333333333,"d":0.503968254,"mi":-0.5653276956,"fo":0.5833333333,"r":-0.0263157895,"e":0.6988283974}
{"project_name":"wicket","project_version":"remotes\/origin\/bugs-dot-jar_WICKET-5426_fb45a781","label":3,"code":"\/**\r\n *  @see org.apache.wicket.Component#onBeforeRender()\r\n *\/\r\n@Override\r\nprotected void onBeforeRender() {\r\n    \/\/ Make sure it is really empty\r\n    renderedComponents = null;\r\n    \/\/ if the page is stateless, reset the flag so that it is tested again\r\n    if (Boolean.TRUE.equals(stateless)) {\r\n        stateless = null;\r\n    }\r\n    super.onBeforeRender();\r\n    \/\/ for links rendered before first stateful component\r\n    if (getSession().isTemporary() && !peekPageStateless()) {\r\n        getSession().bind();\r\n    }\r\n}","code_comment":"\/**\r\n *  @see org.apache.wicket.Component#onBeforeRender()\r\n *\/\r\n","code_no_comment":"@Override\r\nprotected void onBeforeRender() {\r\n        renderedComponents = null;\r\n        if (Boolean.TRUE.equals(stateless)) {\r\n        stateless = null;\r\n    }\r\n    super.onBeforeRender();\r\n        if (getSession().isTemporary() && !peekPageStateless()) {\r\n        getSession().bind();\r\n    }\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":0.1666666667,"d":-0.1051587302,"mi":0.2135306554,"fo":0.0833333333,"r":0.4210526316,"e":-0.1121488218}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-867_bfbb156d","label":1,"code":"\/**\r\n * @param x Normalized objective variables.\r\n * @return the original objective variables.\r\n *\/\r\npublic double[] decode(final double[] x) {\r\n    if (boundaries == null) {\r\n        return x;\r\n    }\r\n    double[] res = new double[x.length];\r\n    for (int i = 0; i < x.length; i++) {\r\n        double diff = boundaries[1][i] - boundaries[0][i];\r\n        res[i] = diff * x[i];\r\n    }\r\n    return res;\r\n}","code_comment":"\/**\r\n * @param x Normalized objective variables.\r\n * @return the original objective variables.\r\n *\/\r\n","code_no_comment":"public double[] decode(final double[] x) {\r\n    if (boundaries == null) {\r\n        return x;\r\n    }\r\n    double[] res = new double[x.length];\r\n    for (int i = 0; i < x.length; i++) {\r\n        double diff = boundaries[1][i] - boundaries[0][i];\r\n        res[i] = diff * x[i];\r\n    }\r\n    return res;\r\n}","lc":-0.1363636364,"pi":-0.1531100478,"ma":-0.2,"nbd":-0.5,"ml":0.0,"d":1.1507936508,"mi":0.1275546159,"fo":-0.5,"r":1.9473684211,"e":0.3696501328}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-1117_f4c926ea","label":1,"code":"\/**\r\n * Create a list of hyperplanes representing the boundary of a box.\r\n * @param xMin low bound along the x direction\r\n * @param xMax high bound along the x direction\r\n * @param yMin low bound along the y direction\r\n * @param yMax high bound along the y direction\r\n * @param tolerance tolerance below which points are considered identical\r\n * @return boundary of the box\r\n *\/\r\nprivate static Line[] boxBoundary(final double xMin, final double xMax, final double yMin, final double yMax, final double tolerance) {\r\n    final Vector2D minMin = new Vector2D(xMin, yMin);\r\n    final Vector2D minMax = new Vector2D(xMin, yMax);\r\n    final Vector2D maxMin = new Vector2D(xMax, yMin);\r\n    final Vector2D maxMax = new Vector2D(xMax, yMax);\r\n    return new Line[] { new Line(minMin, maxMin, tolerance), new Line(maxMin, maxMax, tolerance), new Line(maxMax, minMax, tolerance), new Line(minMax, minMin, tolerance) };\r\n}","code_comment":"\/**\r\n * Create a list of hyperplanes representing the boundary of a box.\r\n * @param xMin low bound along the x direction\r\n * @param xMax high bound along the x direction\r\n * @param yMin low bound along the y direction\r\n * @param yMax high bound along the y direction\r\n * @param tolerance tolerance below which points are considered identical\r\n * @return boundary of the box\r\n *\/\r\n","code_no_comment":"private static Line[] boxBoundary(final double xMin, final double xMax, final double yMin, final double yMax, final double tolerance) {\r\n    final Vector2D minMin = new Vector2D(xMin, yMin);\r\n    final Vector2D minMax = new Vector2D(xMin, yMax);\r\n    final Vector2D maxMin = new Vector2D(xMax, yMin);\r\n    final Vector2D maxMax = new Vector2D(xMax, yMax);\r\n    return new Line[] { new Line(minMin, maxMin, tolerance), new Line(maxMin, maxMax, tolerance), new Line(maxMax, minMax, tolerance), new Line(minMax, minMin, tolerance) };\r\n}","lc":-0.3181818182,"pi":-0.5645933014,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.3161381254,"fo":-0.5,"r":-0.0263157895,"e":-0.1627934049}
{"project_name":"Math","project_version":"80","label":1,"code":"\/**\r\n * Flip qd array if warranted.\r\n * @param n number of rows in the block\r\n * @param step within the array (1 for flipping all elements, 2 for flipping\r\n * only every other element)\r\n * @return true if qd array was flipped\r\n *\/\r\nprivate boolean flipIfWarranted(final int n, final int step) {\r\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\r\n        \/\/ flip array\r\n        int j = 4 * n - 1;\r\n        for (int i = 0; i < j; i += 4) {\r\n            for (int k = 0; k < 4; k += step) {\r\n                final double tmp = work[i + k];\r\n                work[i + k] = work[j - k];\r\n                work[j - k] = tmp;\r\n            }\r\n            j -= 4;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}","code_comment":"\/**\r\n * Flip qd array if warranted.\r\n * @param n number of rows in the block\r\n * @param step within the array (1 for flipping all elements, 2 for flipping\r\n * only every other element)\r\n * @return true if qd array was flipped\r\n *\/\r\n","code_no_comment":"private boolean flipIfWarranted(final int n, final int step) {\r\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\r\n                int j = 4 * n - 1;\r\n        for (int i = 0; i < j; i += 4) {\r\n            for (int k = 0; k < 4; k += step) {\r\n                final double tmp = work[i + k];\r\n                work[i + k] = work[j - k];\r\n                work[j - k] = tmp;\r\n            }\r\n            j -= 4;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}","lc":0.0454545455,"pi":1.0765550239,"ma":0.0,"nbd":0.5,"ml":0.0833333333,"d":1.3452380952,"mi":-0.1247357294,"fo":-0.5,"r":0.9736842105,"e":1.0603620269}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-7429_43956f93","label":1,"code":"public String parseUri(String text, Properties properties, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) throws IllegalArgumentException {\r\n    String answer = text;\r\n    boolean done = false;\r\n    \/\/ the placeholders can contain nested placeholders so we need to do recursive parsing\r\n    \/\/ we must therefore also do circular reference check and must keep a list of visited keys\r\n    List<String> visited = new ArrayList<String>();\r\n    while (!done) {\r\n        List<String> replaced = new ArrayList<String>();\r\n        answer = doParseUri(answer, properties, replaced, prefixToken, suffixToken, propertyPrefix, propertySuffix, fallbackToUnaugmentedProperty);\r\n        \/\/ check the replaced with the visited to avoid circular reference\r\n        for (String replace : replaced) {\r\n            if (visited.contains(replace)) {\r\n                throw new IllegalArgumentException(\"Circular reference detected with key [\" + replace + \"] from text: \" + text);\r\n            }\r\n        }\r\n        \/\/ okay all okay so add the replaced as visited\r\n        visited.addAll(replaced);\r\n        \/\/ we are done when we can no longer find any prefix tokens in the answer\r\n        done = findTokenPosition(answer, 0, prefixToken) == -1;\r\n    }\r\n    return answer;\r\n}","code_comment":null,"code_no_comment":"public String parseUri(String text, Properties properties, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) throws IllegalArgumentException {\r\n    String answer = text;\r\n    boolean done = false;\r\n            List<String> visited = new ArrayList<String>();\r\n    while (!done) {\r\n        List<String> replaced = new ArrayList<String>();\r\n        answer = doParseUri(answer, properties, replaced, prefixToken, suffixToken, propertyPrefix, propertySuffix, fallbackToUnaugmentedProperty);\r\n                for (String replace : replaced) {\r\n            if (visited.contains(replace)) {\r\n                throw new IllegalArgumentException(\"Circular reference detected with key [\" + replace + \"] from text: \" + text);\r\n            }\r\n        }\r\n                visited.addAll(replaced);\r\n                done = findTokenPosition(answer, 0, prefixToken) == -1;\r\n    }\r\n    return answer;\r\n}","lc":0.1363636364,"pi":0.5311004785,"ma":0.2,"nbd":0.5,"ml":0.0,"d":0.5416666667,"mi":-0.2166314306,"fo":-0.1666666667,"r":-0.0263157895,"e":0.623938037}
{"project_name":"commons-math","project_version":"remotes\/origin\/bugs-dot-jar_MATH-950_424cbd20","label":0,"code":"\/**\r\n * Accept a step, triggering events and step handlers.\r\n * @param interpolator step interpolator\r\n * @param y state vector at step end time, must be reset if an event\r\n * asks for resetting or if an events stops integration during the step\r\n * @param yDot placeholder array where to put the time derivative of the state vector\r\n * @param tEnd final integration time\r\n * @return time at end of step\r\n * @exception MaxCountExceededException if the interpolator throws one because\r\n * the number of functions evaluations is exceeded\r\n * @exception NoBracketingException if the location of an event cannot be bracketed\r\n * @exception DimensionMismatchException if arrays dimensions do not match equations settings\r\n * @since 2.2\r\n *\/\r\nprotected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\r\n    double previousT = interpolator.getGlobalPreviousTime();\r\n    final double currentT = interpolator.getGlobalCurrentTime();\r\n    \/\/ initialize the events states if needed\r\n    if (!statesInitialized) {\r\n        for (EventState state : eventsStates) {\r\n            state.reinitializeBegin(interpolator);\r\n        }\r\n        statesInitialized = true;\r\n    }\r\n    \/\/ search for next events that may occur during the step\r\n    final int orderingSign = interpolator.isForward() ? +1 : -1;\r\n    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\r\n\r\n        \/**\r\n         * {@inheritDoc}\r\n         *\/\r\n        public int compare(EventState es0, EventState es1) {\r\n            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\r\n        }\r\n    });\r\n    for (final EventState state : eventsStates) {\r\n        if (state.evaluateStep(interpolator)) {\r\n            \/\/ the event occurs during the current step\r\n            occuringEvents.add(state);\r\n        }\r\n    }\r\n    while (!occuringEvents.isEmpty()) {\r\n        \/\/ handle the chronologically first event\r\n        final Iterator<EventState> iterator = occuringEvents.iterator();\r\n        final EventState currentEvent = iterator.next();\r\n        iterator.remove();\r\n        \/\/ restrict the interpolator to the first part of the step, up to the event\r\n        final double eventT = currentEvent.getEventTime();\r\n        interpolator.setSoftPreviousTime(previousT);\r\n        interpolator.setSoftCurrentTime(eventT);\r\n        \/\/ trigger the event\r\n        interpolator.setInterpolatedTime(eventT);\r\n        final double[] eventY = interpolator.getInterpolatedState().clone();\r\n        currentEvent.stepAccepted(eventT, eventY);\r\n        isLastStep = currentEvent.stop();\r\n        \/\/ handle the first part of the step, up to the event\r\n        for (final StepHandler handler : stepHandlers) {\r\n            handler.handleStep(interpolator, isLastStep);\r\n        }\r\n        if (isLastStep) {\r\n            \/\/ the event asked to stop integration\r\n            System.arraycopy(eventY, 0, y, 0, y.length);\r\n            for (final EventState remaining : occuringEvents) {\r\n                remaining.stepAccepted(eventT, eventY);\r\n            }\r\n            return eventT;\r\n        }\r\n        if (currentEvent.reset(eventT, eventY)) {\r\n            \/\/ some event handler has triggered changes that\r\n            \/\/ invalidate the derivatives, we need to recompute them\r\n            System.arraycopy(eventY, 0, y, 0, y.length);\r\n            computeDerivatives(eventT, y, yDot);\r\n            resetOccurred = true;\r\n            for (final EventState remaining : occuringEvents) {\r\n                remaining.stepAccepted(eventT, eventY);\r\n            }\r\n            return eventT;\r\n        }\r\n        \/\/ prepare handling of the remaining part of the step\r\n        previousT = eventT;\r\n        interpolator.setSoftPreviousTime(eventT);\r\n        interpolator.setSoftCurrentTime(currentT);\r\n        \/\/ check if the same event occurs again in the remaining part of the step\r\n        if (currentEvent.evaluateStep(interpolator)) {\r\n            \/\/ the event occurs during the current step\r\n            occuringEvents.add(currentEvent);\r\n        }\r\n    }\r\n    interpolator.setInterpolatedTime(currentT);\r\n    final double[] currentY = interpolator.getInterpolatedState();\r\n    for (final EventState state : eventsStates) {\r\n        state.stepAccepted(currentT, currentY);\r\n        isLastStep = isLastStep || state.stop();\r\n    }\r\n    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\r\n    \/\/ handle the remaining part of the step, after all events if any\r\n    for (StepHandler handler : stepHandlers) {\r\n        handler.handleStep(interpolator, isLastStep);\r\n    }\r\n    return currentT;\r\n}","code_comment":"\/**\r\n * Accept a step, triggering events and step handlers.\r\n * @param interpolator step interpolator\r\n * @param y state vector at step end time, must be reset if an event\r\n * asks for resetting or if an events stops integration during the step\r\n * @param yDot placeholder array where to put the time derivative of the state vector\r\n * @param tEnd final integration time\r\n * @return time at end of step\r\n * @exception MaxCountExceededException if the interpolator throws one because\r\n * the number of functions evaluations is exceeded\r\n * @exception NoBracketingException if the location of an event cannot be bracketed\r\n * @exception DimensionMismatchException if arrays dimensions do not match equations settings\r\n * @since 2.2\r\n *\/\r\n\/**\r\n * {@inheritDoc}\r\n *\/\r\n","code_no_comment":"protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\r\n    double previousT = interpolator.getGlobalPreviousTime();\r\n    final double currentT = interpolator.getGlobalCurrentTime();\r\n        if (!statesInitialized) {\r\n        for (EventState state : eventsStates) {\r\n            state.reinitializeBegin(interpolator);\r\n        }\r\n        statesInitialized = true;\r\n    }\r\n        final int orderingSign = interpolator.isForward() ? +1 : -1;\r\n    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\r\n\r\n        \/**\r\n         * {@inheritDoc}\r\n         *\/\r\n        public int compare(EventState es0, EventState es1) {\r\n            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\r\n        }\r\n    });\r\n    for (final EventState state : eventsStates) {\r\n        if (state.evaluateStep(interpolator)) {\r\n                        occuringEvents.add(state);\r\n        }\r\n    }\r\n    while (!occuringEvents.isEmpty()) {\r\n                final Iterator<EventState> iterator = occuringEvents.iterator();\r\n        final EventState currentEvent = iterator.next();\r\n        iterator.remove();\r\n                final double eventT = currentEvent.getEventTime();\r\n        interpolator.setSoftPreviousTime(previousT);\r\n        interpolator.setSoftCurrentTime(eventT);\r\n                interpolator.setInterpolatedTime(eventT);\r\n        final double[] eventY = interpolator.getInterpolatedState().clone();\r\n        currentEvent.stepAccepted(eventT, eventY);\r\n        isLastStep = currentEvent.stop();\r\n                for (final StepHandler handler : stepHandlers) {\r\n            handler.handleStep(interpolator, isLastStep);\r\n        }\r\n        if (isLastStep) {\r\n                        System.arraycopy(eventY, 0, y, 0, y.length);\r\n            for (final EventState remaining : occuringEvents) {\r\n                remaining.stepAccepted(eventT, eventY);\r\n            }\r\n            return eventT;\r\n        }\r\n        if (currentEvent.reset(eventT, eventY)) {\r\n                                    System.arraycopy(eventY, 0, y, 0, y.length);\r\n            computeDerivatives(eventT, y, yDot);\r\n            resetOccurred = true;\r\n            for (final EventState remaining : occuringEvents) {\r\n                remaining.stepAccepted(eventT, eventY);\r\n            }\r\n            return eventT;\r\n        }\r\n                previousT = eventT;\r\n        interpolator.setSoftPreviousTime(eventT);\r\n        interpolator.setSoftCurrentTime(currentT);\r\n                if (currentEvent.evaluateStep(interpolator)) {\r\n                        occuringEvents.add(currentEvent);\r\n        }\r\n    }\r\n    interpolator.setInterpolatedTime(currentT);\r\n    final double[] currentY = interpolator.getInterpolatedState();\r\n    for (final EventState state : eventsStates) {\r\n        state.stepAccepted(currentT, currentY);\r\n        isLastStep = isLastStep || state.stop();\r\n    }\r\n    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\r\n        for (StepHandler handler : stepHandlers) {\r\n        handler.handleStep(interpolator, isLastStep);\r\n    }\r\n    return currentT;\r\n}","lc":2.6363636364,"pi":0.1626794258,"ma":2.2,"nbd":0.5,"ml":1.0,"d":1.375,"mi":-1.1240310078,"fo":2.6666666667,"r":-0.0263157895,"e":5.1081389787}
{"project_name":"accumulo","project_version":"remotes\/origin\/bugs-dot-jar_ACCUMULO-3006_d6472040","label":0,"code":"protected void ensureSyncIsEnabled() {\r\n    for (Entry<String, Volume> entry : getFileSystems().entrySet()) {\r\n        final String volumeName = entry.getKey();\r\n        FileSystem fs = entry.getValue().getFileSystem();\r\n        if (ViewFSUtils.isViewFS(fs)) {\r\n            try {\r\n                FileSystem resolvedFs = ViewFSUtils.resolvePath(fs, new Path(\"\/\")).getFileSystem(fs.getConf());\r\n                log.debug(\"resolved \" + fs.getUri() + \" to \" + resolvedFs.getUri() + \" for sync check\");\r\n                fs = resolvedFs;\r\n            } catch (IOException e) {\r\n                log.warn(\"Failed to resolve \" + fs.getUri(), e);\r\n            }\r\n        }\r\n        if (fs instanceof DistributedFileSystem) {\r\n            final String DFS_DURABLE_SYNC = \"dfs.durable.sync\", DFS_SUPPORT_APPEND = \"dfs.support.append\";\r\n            final String ticketMessage = \"See ACCUMULO-623 and ACCUMULO-1637 for more details.\";\r\n            \/\/ Check to make sure that we have proper defaults configured\r\n            try {\r\n                \/\/ If the default is off (0.20.205.x or 1.0.x)\r\n                DFSConfigKeys configKeys = new DFSConfigKeys();\r\n                \/\/ Can't use the final constant itself as Java will inline it at compile time\r\n                Field dfsSupportAppendDefaultField = configKeys.getClass().getField(\"DFS_SUPPORT_APPEND_DEFAULT\");\r\n                boolean dfsSupportAppendDefaultValue = dfsSupportAppendDefaultField.getBoolean(configKeys);\r\n                if (!dfsSupportAppendDefaultValue) {\r\n                    \/\/ See if the user did the correct override\r\n                    if (!fs.getConf().getBoolean(DFS_SUPPORT_APPEND, false)) {\r\n                        String msg = \"Accumulo requires that dfs.support.append to true. \" + ticketMessage;\r\n                        log.fatal(msg);\r\n                        throw new RuntimeException(msg);\r\n                    }\r\n                }\r\n            } catch (NoSuchFieldException e) {\r\n            \/\/ If we can't find DFSConfigKeys.DFS_SUPPORT_APPEND_DEFAULT, the user is running\r\n            \/\/ 1.1.x or 1.2.x. This is ok, though, as, by default, these versions have append\/sync enabled.\r\n            } catch (Exception e) {\r\n                log.warn(\"Error while checking for \" + DFS_SUPPORT_APPEND + \" on volume \" + volumeName + \". The user should ensure that Hadoop is configured to properly supports append and sync. \" + ticketMessage, e);\r\n            }\r\n            \/\/ This is a sign that someone is writing bad configuration.\r\n            if (!fs.getConf().getBoolean(DFS_SUPPORT_APPEND, true) || !fs.getConf().getBoolean(DFS_DURABLE_SYNC, true)) {\r\n                String msg = \"Accumulo requires that \" + DFS_SUPPORT_APPEND + \" and \" + DFS_DURABLE_SYNC + \" not be configured as false. \" + ticketMessage;\r\n                log.fatal(msg);\r\n                throw new RuntimeException(msg);\r\n            }\r\n            try {\r\n                \/\/ Check DFSConfigKeys to see if DFS_DATANODE_SYNCONCLOSE_KEY exists (should be everything >=1.1.1 and the 0.23 line)\r\n                Class<?> dfsConfigKeysClz = Class.forName(\"org.apache.hadoop.hdfs.DFSConfigKeys\");\r\n                dfsConfigKeysClz.getDeclaredField(\"DFS_DATANODE_SYNCONCLOSE_KEY\");\r\n                \/\/ Everything else\r\n                if (!fs.getConf().getBoolean(\"dfs.datanode.synconclose\", false)) {\r\n                    log.warn(\"dfs.datanode.synconclose set to false in hdfs-site.xml: data loss is possible on system reset or power loss\");\r\n                }\r\n            } catch (ClassNotFoundException ex) {\r\n            \/\/ hadoop 1.0.X or hadoop 1.1.0\r\n            } catch (SecurityException e) {\r\n            \/\/ hadoop 1.0.X or hadoop 1.1.0\r\n            } catch (NoSuchFieldException e) {\r\n            \/\/ hadoop 1.0.X or hadoop 1.1.0\r\n            }\r\n        }\r\n    }\r\n}","code_comment":null,"code_no_comment":"protected void ensureSyncIsEnabled() {\r\n    for (Entry<String, Volume> entry : getFileSystems().entrySet()) {\r\n        final String volumeName = entry.getKey();\r\n        FileSystem fs = entry.getValue().getFileSystem();\r\n        if (ViewFSUtils.isViewFS(fs)) {\r\n            try {\r\n                FileSystem resolvedFs = ViewFSUtils.resolvePath(fs, new Path(\"\/\")).getFileSystem(fs.getConf());\r\n                log.debug(\"resolved \" + fs.getUri() + \" to \" + resolvedFs.getUri() + \" for sync check\");\r\n                fs = resolvedFs;\r\n            } catch (IOException e) {\r\n                log.warn(\"Failed to resolve \" + fs.getUri(), e);\r\n            }\r\n        }\r\n        if (fs instanceof DistributedFileSystem) {\r\n            final String DFS_DURABLE_SYNC = \"dfs.durable.sync\", DFS_SUPPORT_APPEND = \"dfs.support.append\";\r\n            final String ticketMessage = \"See ACCUMULO-623 and ACCUMULO-1637 for more details.\";\r\n                        try {\r\n                                DFSConfigKeys configKeys = new DFSConfigKeys();\r\n                                Field dfsSupportAppendDefaultField = configKeys.getClass().getField(\"DFS_SUPPORT_APPEND_DEFAULT\");\r\n                boolean dfsSupportAppendDefaultValue = dfsSupportAppendDefaultField.getBoolean(configKeys);\r\n                if (!dfsSupportAppendDefaultValue) {\r\n                                        if (!fs.getConf().getBoolean(DFS_SUPPORT_APPEND, false)) {\r\n                        String msg = \"Accumulo requires that dfs.support.append to true. \" + ticketMessage;\r\n                        log.fatal(msg);\r\n                        throw new RuntimeException(msg);\r\n                    }\r\n                }\r\n            } catch (NoSuchFieldException e) {\r\n                                    } catch (Exception e) {\r\n                log.warn(\"Error while checking for \" + DFS_SUPPORT_APPEND + \" on volume \" + volumeName + \". The user should ensure that Hadoop is configured to properly supports append and sync. \" + ticketMessage, e);\r\n            }\r\n                        if (!fs.getConf().getBoolean(DFS_SUPPORT_APPEND, true) || !fs.getConf().getBoolean(DFS_DURABLE_SYNC, true)) {\r\n                String msg = \"Accumulo requires that \" + DFS_SUPPORT_APPEND + \" and \" + DFS_DURABLE_SYNC + \" not be configured as false. \" + ticketMessage;\r\n                log.fatal(msg);\r\n                throw new RuntimeException(msg);\r\n            }\r\n            try {\r\n                                Class<?> dfsConfigKeysClz = Class.forName(\"org.apache.hadoop.hdfs.DFSConfigKeys\");\r\n                dfsConfigKeysClz.getDeclaredField(\"DFS_DATANODE_SYNCONCLOSE_KEY\");\r\n                                if (!fs.getConf().getBoolean(\"dfs.datanode.synconclose\", false)) {\r\n                    log.warn(\"dfs.datanode.synconclose set to false in hdfs-site.xml: data loss is possible on system reset or power loss\");\r\n                }\r\n            } catch (ClassNotFoundException ex) {\r\n                        } catch (SecurityException e) {\r\n                        } catch (NoSuchFieldException e) {\r\n                        }\r\n        }\r\n    }\r\n}","lc":1.5909090909,"pi":1.0574162679,"ma":2.4,"nbd":1.5,"ml":0.75,"d":0.4345238095,"mi":-0.9238900634,"fo":2.0833333333,"r":-0.0263157895,"e":1.7979518565}
{"project_name":"Closure","project_version":"158","label":2,"code":"CommandLineConfig setJscompOff(List<String> jscompOff) {\r\n    this.jscompOff.clear();\r\n    this.jscompOff.addAll(jscompOff);\r\n    return this;\r\n}","code_comment":null,"code_no_comment":"CommandLineConfig setJscompOff(List<String> jscompOff) {\r\n    this.jscompOff.clear();\r\n    this.jscompOff.addAll(jscompOff);\r\n    return this;\r\n}","lc":-0.4090909091,"pi":-0.4928229665,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.3650793651,"mi":0.7237491191,"fo":-0.3333333333,"r":0.1052631579,"e":-0.1627934049}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1270_70564c7c","label":1,"code":"@Override\r\npublic boolean visit(FullTextTerm term) {\r\n    String p = term.getPropertyName();\r\n    if (p != null && p.indexOf('\/') >= 0) {\r\n        \/\/ do not add constraints on child nodes properties\r\n        p = \"*\";\r\n    }\r\n    Query q = tokenToQuery(term.getText(), analyzer);\r\n    if (q == null) {\r\n        return false;\r\n    }\r\n    String boost = term.getBoost();\r\n    if (boost != null) {\r\n        q.setBoost(Float.parseFloat(boost));\r\n    }\r\n    if (term.isNot()) {\r\n        BooleanQuery bq = new BooleanQuery();\r\n        bq.add(q, MUST_NOT);\r\n        result.set(bq);\r\n    } else {\r\n        result.set(q);\r\n    }\r\n    return true;\r\n}","code_comment":null,"code_no_comment":"@Override\r\npublic boolean visit(FullTextTerm term) {\r\n    String p = term.getPropertyName();\r\n    if (p != null && p.indexOf('\/') >= 0) {\r\n                p = \"*\";\r\n    }\r\n    Query q = tokenToQuery(term.getText(), analyzer);\r\n    if (q == null) {\r\n        return false;\r\n    }\r\n    String boost = term.getBoost();\r\n    if (boost != null) {\r\n        q.setBoost(Float.parseFloat(boost));\r\n    }\r\n    if (term.isNot()) {\r\n        BooleanQuery bq = new BooleanQuery();\r\n        bq.add(q, MUST_NOT);\r\n        result.set(bq);\r\n    } else {\r\n        result.set(q);\r\n    }\r\n    return true;\r\n}","lc":0.4090909091,"pi":-0.2153110048,"ma":0.2,"nbd":-0.5,"ml":0.4166666667,"d":0.2916666667,"mi":-0.3358703312,"fo":0.4166666667,"r":0.2105263158,"e":0.3384196908}
{"project_name":"jackrabbit-oak","project_version":"remotes\/origin\/bugs-dot-jar_OAK-1075_79467350","label":1,"code":"public static boolean match(PropertyValue p1, PropertyValue p2) {\r\n    if (p1.getType().tag() != p2.getType().tag()) {\r\n        return false;\r\n    }\r\n    switch(p1.getType().tag()) {\r\n        case PropertyType.BINARY:\r\n            if (p1.isArray() && !p2.isArray()) {\r\n                return contains(p1.getValue(Type.BINARIES), p2.getValue(Type.BINARY));\r\n            }\r\n            if (!p1.isArray() && p2.isArray()) {\r\n                return contains(p2.getValue(Type.BINARIES), p2.getValue(Type.BINARY));\r\n            }\r\n            break;\r\n        default:\r\n            if (p1.isArray() && !p2.isArray()) {\r\n                return contains(p1.getValue(Type.STRINGS), p2.getValue(Type.STRING));\r\n            }\r\n            if (!p1.isArray() && p2.isArray()) {\r\n                return contains(p2.getValue(Type.STRINGS), p1.getValue(Type.STRING));\r\n            }\r\n    }\r\n    \/\/ both arrays or both single values\r\n    return p1.compareTo(p2) == 0;\r\n}","code_comment":null,"code_no_comment":"public static boolean match(PropertyValue p1, PropertyValue p2) {\r\n    if (p1.getType().tag() != p2.getType().tag()) {\r\n        return false;\r\n    }\r\n    switch(p1.getType().tag()) {\r\n        case PropertyType.BINARY:\r\n            if (p1.isArray() && !p2.isArray()) {\r\n                return contains(p1.getValue(Type.BINARIES), p2.getValue(Type.BINARY));\r\n            }\r\n            if (!p1.isArray() && p2.isArray()) {\r\n                return contains(p2.getValue(Type.BINARIES), p2.getValue(Type.BINARY));\r\n            }\r\n            break;\r\n        default:\r\n            if (p1.isArray() && !p2.isArray()) {\r\n                return contains(p1.getValue(Type.STRINGS), p2.getValue(Type.STRING));\r\n            }\r\n            if (!p1.isArray() && p2.isArray()) {\r\n                return contains(p2.getValue(Type.STRINGS), p1.getValue(Type.STRING));\r\n            }\r\n    }\r\n        return p1.compareTo(p2) == 0;\r\n}","lc":0.4090909091,"pi":0.9377990431,"ma":1.0,"nbd":0.5,"ml":0.75,"d":1.1805555556,"mi":-0.3832276251,"fo":1.75,"r":-0.0263157895,"e":1.2017934222}
{"project_name":"camel","project_version":"remotes\/origin\/bugs-dot-jar_CAMEL-6936_4954d573","label":1,"code":"\/**\r\n * Is the given file already in progress.\r\n *\r\n * @param file the file\r\n * @return <tt>true<\/tt> if the file is already in progress\r\n *\/\r\nprotected boolean isInProgress(GenericFile<T> file) {\r\n    String key = file.getAbsoluteFilePath();\r\n    return !endpoint.getInProgressRepository().add(key);\r\n}","code_comment":"\/**\r\n * Is the given file already in progress.\r\n *\r\n * @param file the file\r\n * @return <tt>true<\/tt> if the file is already in progress\r\n *\/\r\n","code_no_comment":"protected boolean isInProgress(GenericFile<T> file) {\r\n    String key = file.getAbsoluteFilePath();\r\n    return !endpoint.getInProgressRepository().add(key);\r\n}","lc":-0.4545454545,"pi":-0.4736842105,"ma":-0.6,"nbd":-1.0,"ml":-0.4166666667,"d":-0.130952381,"mi":0.7494009866,"fo":-0.25,"r":2.3684210526,"e":-0.1325495756}
{"project_name":"Closure","project_version":"117","label":2,"code":"\/**\r\n * Given a node, get a human-readable name for the type of that node so\r\n * that will be easy for the programmer to find the original declaration.\r\n *\r\n * For example, if SubFoo's property \"bar\" might have the human-readable\r\n * name \"Foo.prototype.bar\".\r\n *\r\n * @param n The node.\r\n * @param dereference If true, the type of the node will be dereferenced\r\n *     to an Object type, if possible.\r\n *\/\r\nString getReadableJSTypeName(Node n, boolean dereference) {\r\n    \/\/ the property was originally defined.\r\n    if (n.isGetProp()) {\r\n        ObjectType objectType = getJSType(n.getFirstChild()).dereference();\r\n        if (objectType != null) {\r\n            String propName = n.getLastChild().getString();\r\n            if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) {\r\n                objectType = FunctionType.getTopDefiningInterface(objectType, propName);\r\n            } else {\r\n                \/\/ classes\r\n                while (objectType != null && !objectType.hasOwnProperty(propName)) {\r\n                    objectType = objectType.getImplicitPrototype();\r\n                }\r\n            }\r\n            \/\/ Instead, try to get a human-readable type name.\r\n            if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) {\r\n                return objectType.toString() + \".\" + propName;\r\n            }\r\n        }\r\n    }\r\n    JSType type = getJSType(n);\r\n    if (dereference) {\r\n        ObjectType dereferenced = type.dereference();\r\n        if (dereferenced != null) {\r\n            type = dereferenced;\r\n        }\r\n    }\r\n    if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {\r\n        return type.toString();\r\n    }\r\n    String qualifiedName = n.getQualifiedName();\r\n    if (qualifiedName != null) {\r\n        return qualifiedName;\r\n    } else if (type.isFunctionType()) {\r\n        \/\/ Don't show complex function names.\r\n        return \"function\";\r\n    } else {\r\n        return type.toString();\r\n    }\r\n}","code_comment":"\/**\r\n * Given a node, get a human-readable name for the type of that node so\r\n * that will be easy for the programmer to find the original declaration.\r\n *\r\n * For example, if SubFoo's property \"bar\" might have the human-readable\r\n * name \"Foo.prototype.bar\".\r\n *\r\n * @param n The node.\r\n * @param dereference If true, the type of the node will be dereferenced\r\n *     to an Object type, if possible.\r\n *\/\r\n","code_no_comment":"String getReadableJSTypeName(Node n, boolean dereference) {\r\n        if (n.isGetProp()) {\r\n        ObjectType objectType = getJSType(n.getFirstChild()).dereference();\r\n        if (objectType != null) {\r\n            String propName = n.getLastChild().getString();\r\n            if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) {\r\n                objectType = FunctionType.getTopDefiningInterface(objectType, propName);\r\n            } else {\r\n                                while (objectType != null && !objectType.hasOwnProperty(propName)) {\r\n                    objectType = objectType.getImplicitPrototype();\r\n                }\r\n            }\r\n                        if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) {\r\n                return objectType.toString() + \".\" + propName;\r\n            }\r\n        }\r\n    }\r\n    JSType type = getJSType(n);\r\n    if (dereference) {\r\n        ObjectType dereferenced = type.dereference();\r\n        if (dereferenced != null) {\r\n            type = dereferenced;\r\n        }\r\n    }\r\n    if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {\r\n        return type.toString();\r\n    }\r\n    String qualifiedName = n.getQualifiedName();\r\n    if (qualifiedName != null) {\r\n        return qualifiedName;\r\n    } else if (type.isFunctionType()) {\r\n                return \"function\";\r\n    } else {\r\n        return type.toString();\r\n    }\r\n}","lc":1.0,"pi":0.8660287081,"ma":1.4,"nbd":1.0,"ml":2.0833333333,"d":1.253968254,"mi":-0.6648343904,"fo":1.5833333333,"r":-0.0263157895,"e":2.0473942936}
